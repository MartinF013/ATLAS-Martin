import {
  e as e3
} from "./chunk-K4ARIGIL.js";
import "./chunk-AGO2OES3.js";
import "./chunk-ARI6FRU4.js";
import "./chunk-BBO6WYBO.js";
import {
  l as l4
} from "./chunk-ADLZUJXZ.js";
import {
  h as h2
} from "./chunk-TH2ECCFL.js";
import "./chunk-TCBD6DES.js";
import "./chunk-ZIAGZEFK.js";
import {
  r as r5,
  t as t5
} from "./chunk-CMKLTW5X.js";
import "./chunk-FR7M4UDR.js";
import "./chunk-KBCUY3VB.js";
import {
  m as m2
} from "./chunk-LPRAS3HG.js";
import "./chunk-G2GJVIQC.js";
import {
  G,
  U as U2,
  _,
  a as a3,
  a2 as a4,
  e as e4,
  e2 as e5,
  i2,
  i3,
  n2 as n4,
  n3 as n5,
  o2 as o4,
  p as p3,
  s as s4,
  s2 as s5,
  s3 as s6,
  t as t6,
  t2 as t7,
  u as u3,
  w as w3
} from "./chunk-IG67ATRS.js";
import "./chunk-WTYOB7O7.js";
import "./chunk-EDJZEIRN.js";
import "./chunk-KDNPPW3Z.js";
import "./chunk-2EPPX4WN.js";
import {
  Gt,
  H,
  St,
  Y,
  Z,
  gt,
  ht,
  jt,
  pt,
  tt,
  wt,
  xt
} from "./chunk-4ZEOAETN.js";
import "./chunk-MEW2XKT2.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-6EODZIDR.js";
import "./chunk-MV2XZ5BA.js";
import {
  l as l3,
  r as r4,
  s as s3,
  w as w2
} from "./chunk-MZ4JF5C6.js";
import "./chunk-PQO66WZ2.js";
import "./chunk-6S5B4VLQ.js";
import "./chunk-24OMPNTT.js";
import "./chunk-DLW46BXD.js";
import "./chunk-3NPGGTI6.js";
import "./chunk-KBILTFOD.js";
import {
  u as u2
} from "./chunk-QNKOXOOY.js";
import "./chunk-G4ERZR5M.js";
import "./chunk-AMGAY4O5.js";
import {
  g as g3
} from "./chunk-GRW2GUB3.js";
import {
  o as o3,
  r as r6
} from "./chunk-RBVTRJPJ.js";
import {
  a as a2,
  m,
  o as o2,
  r as r3
} from "./chunk-YZNDHJDJ.js";
import "./chunk-ZZCCRN4U.js";
import "./chunk-TWQ374WD.js";
import "./chunk-GT2OBOXC.js";
import {
  c as c4,
  g as g2,
  i
} from "./chunk-Z3S5X75I.js";
import "./chunk-YK4ZKK2Q.js";
import "./chunk-NMRWU44S.js";
import "./chunk-LBBA3SFR.js";
import "./chunk-2KZBVPWA.js";
import "./chunk-CXIMLSDF.js";
import "./chunk-ZDSMRGKC.js";
import "./chunk-I6H66HCE.js";
import "./chunk-4P4OV7G6.js";
import "./chunk-ZUDEVIXR.js";
import "./chunk-RRFFPL7N.js";
import "./chunk-JYR7GBAU.js";
import "./chunk-IG4CY4XM.js";
import "./chunk-HB4HVKJV.js";
import "./chunk-CC32E45Q.js";
import "./chunk-V7M26XZ7.js";
import "./chunk-ZN2MGN4S.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import {
  n as n3
} from "./chunk-RTHP2LNT.js";
import "./chunk-XZTXACPW.js";
import "./chunk-EHYYP2L2.js";
import "./chunk-ZUEYZA7M.js";
import "./chunk-74GUBHRJ.js";
import "./chunk-E447OCKN.js";
import "./chunk-LPU5TMA4.js";
import "./chunk-25QHXOZB.js";
import "./chunk-AA7FGPNP.js";
import "./chunk-UHJVTABQ.js";
import "./chunk-W66LN57L.js";
import "./chunk-PNUWGOXY.js";
import "./chunk-FUQI3AAI.js";
import "./chunk-22YODLVL.js";
import "./chunk-TB42IUV7.js";
import "./chunk-ZWMYDR2G.js";
import "./chunk-ZZY5IDKU.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-6FKG7JUE.js";
import {
  An,
  en,
  rn,
  tn
} from "./chunk-PZWU5EHT.js";
import "./chunk-37ZVELW7.js";
import "./chunk-45UEUCUL.js";
import "./chunk-4AZE5OWC.js";
import "./chunk-CQSGZXR7.js";
import "./chunk-POPR7XUB.js";
import "./chunk-7LOJJ46D.js";
import "./chunk-VNR743PA.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-SWCA522B.js";
import "./chunk-YPIBZ3CH.js";
import "./chunk-XLCZFN6R.js";
import "./chunk-OMNBM2E4.js";
import "./chunk-WKHS6QIX.js";
import "./chunk-6O7ZZEV7.js";
import {
  c as c3
} from "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-OBCAVCXI.js";
import "./chunk-RFOZTYJH.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-L2YBXQTH.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-4XBERLPX.js";
import {
  S,
  p
} from "./chunk-HR2OX32D.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-SZPDY7KN.js";
import "./chunk-Y6YGVGFR.js";
import "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import "./chunk-MZX3HN4G.js";
import "./chunk-T47JAOQZ.js";
import "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import {
  p as p2
} from "./chunk-TMSBC6BS.js";
import "./chunk-RIWDMEW4.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-OG6CQEZJ.js";
import "./chunk-X5Z3DJQ4.js";
import "./chunk-BUWXVMJU.js";
import "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import "./chunk-D3XXPCBB.js";
import "./chunk-OWBMOIIV.js";
import "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  f as f2,
  h,
  j as j3,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import {
  j as j2
} from "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import {
  c as c2
} from "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import {
  l
} from "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import {
  o,
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  M,
  c,
  r as r2
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  E
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  A,
  d,
  n8 as n2,
  t as t2,
  t6 as t4,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  f,
  t as t3
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  n
} from "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  a,
  e as e2,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/2d/AnimationManager.js
var m3 = class {
  constructor(t11, i9, s11, e9) {
    const o9 = t11.targetGeometry, n9 = i9.targetGeometry;
    e9 ? "string" == typeof e9 && (e9 = r5(e9) || t5.ease) : e9 = t5.ease, this.easing = e9, this.duration = s11, this.sCenterX = o9.x, this.sCenterY = o9.y, this.sScale = t11.scale, this.sRotation = t11.rotation, this.tCenterX = n9.x, this.tCenterY = n9.y, this.tScale = i9.scale, this.tRotation = i9.rotation, this.dCenterX = this.tCenterX - this.sCenterX, this.dCenterY = this.tCenterY - this.sCenterY, this.dScale = this.tScale - this.sScale, this.dRotation = this.tRotation - this.sRotation, this.dRotation > 180 ? this.dRotation -= 360 : this.dRotation < -180 && (this.dRotation += 360);
  }
  applyRatio(t11, i9) {
    const s11 = this.easing(i9);
    let e9, o9, n9, a10;
    i9 >= 1 ? (e9 = this.tCenterX, o9 = this.tCenterY, n9 = this.tRotation, a10 = this.tScale) : (e9 = this.sCenterX + s11 * this.dCenterX, o9 = this.sCenterY + s11 * this.dCenterY, n9 = this.sRotation + s11 * this.dRotation, a10 = this.sScale + s11 * this.dScale), t11.targetGeometry.x = e9, t11.targetGeometry.y = o9, t11.scale = a10, t11.rotation = n9;
  }
};
var u4 = class extends y {
  constructor(t11) {
    super(t11), this.duration = 200, this.transition = null, this.easing = t5.ease, this.view = null, this.viewpoint = null, this.viewpoint = new u2({ targetGeometry: new j(), scale: 0, rotation: 0 }), this._updateTask = A({ postRender: this._postRender.bind(this) }), this._updateTask.pause();
  }
  destroy() {
    this._updateTask.remove(), this._updateTask = null;
  }
  animate(t11, i9, s11) {
    this.stop();
    const e9 = this.viewpoint;
    Z(e9, i9), this.transition = new m3(this.viewpoint, t11.target, s11 && s11.duration || this.duration, s11 && s11.easing || this.easing);
    const o9 = () => {
      this.animation === t11 && this._updateTask && ("finished" === t11.state && (this.transition.applyRatio(this.viewpoint, 1), this.view.state && (this.view.state.viewpoint = this.viewpoint.clone())), this.animation = null, this.updateFunction = null);
    };
    return t11.when(o9, o9), this._startTime = performance.now(), this._updateTask.resume(), this.animation = t11, t11;
  }
  animateContinous(t11, i9) {
    this.stop(), this.updateFunction = i9, this.viewpoint = t11;
    const s11 = new n4({ target: t11.clone() }), e9 = () => {
      this.animation === s11 && this._updateTask && (this.animation = null, this.updateFunction = null);
    };
    return s11.when(e9, e9), this._startTime = performance.now(), this._updateTask.resume(), this.animation = s11, s11;
  }
  stop() {
    this.animation && (this.animation.stop(), this.animation = null, this.updateFunction = null);
  }
  _postRender(t11) {
    const i9 = this.animation;
    if (i9 && i9.state !== n4.State.STOPPED) {
      if (this.updateFunction)
        this.updateFunction(this.viewpoint, t11.deltaTime);
      else {
        const t12 = (performance.now() - this._startTime) / this.transition.duration, i10 = t12 >= 1;
        this.transition.applyRatio(this.viewpoint, t12), i10 && this.animation.finish();
      }
      this.view.state && (this.view.state.viewpoint = this.viewpoint.clone());
    } else
      this._updateTask.pause();
  }
};
e([d()], u4.prototype, "animation", void 0), e([d()], u4.prototype, "duration", void 0), e([d()], u4.prototype, "transition", void 0), e([d()], u4.prototype, "easing", void 0), e([d()], u4.prototype, "view", void 0), e([d()], u4.prototype, "viewpoint", void 0), u4 = e([n2("esri.views.2d.AnimationManager")], u4);
var d2 = u4;

// node_modules/@arcgis/core/views/2d/FrameTask.js
var s7 = class {
  constructor(t11) {
    this.view = t11, this._frameTaskHandle = null, this._updateRequested = false, this.stationary = true, this.animationInProgress = false, this.prepare = () => {
      this._updateParameters.state = this.view.state, this._updateParameters.stationary = this.view.stationary, this._updateParameters.pixelRatio = window.devicePixelRatio, this._updateParameters.renderingOptions = this.view.renderingOptions;
    }, this.update = () => {
      this._updateRequested = false;
      const { basemapView: t12, graphicsView: a10, labelManager: s11, layerViews: i9, state: { id: r7 } } = this.view;
      t12.baseLayerViews.forEach(this._updateLayerView, this), i9.forEach(this._updateLayerView, this), t12.referenceLayerViews.forEach(this._updateLayerView, this), r(s11) && (s11.lastUpdateId !== r7 && (s11.viewChange(), s11.lastUpdateId = r7), s11.updateRequested && s11.processUpdate(this._updateParameters)), r(a10) && (a10.lastUpdateId !== r7 && (a10.viewChange(), a10.lastUpdateId = r7), a10.updateRequested && a10.processUpdate(this._updateParameters)), this.view.graphicsTileStore.setViewState(this._updateParameters.state), this.animationInProgress || this._updateRequested || this._frameTaskHandle.pause();
    };
  }
  destroy() {
    this.stop();
  }
  start() {
    if (this._frameTaskHandle)
      return;
    const e9 = this.view;
    this.stationary = e9.stationary, this._updateParameters = { state: e9.state, pixelRatio: window.devicePixelRatio, stationary: this.stationary, renderingOptions: e9.renderingOptions }, this._stationaryHandle = l2(() => e9.stationary, (e10) => {
      this.stationary = e10, this.requestFrame();
    }), this._frameTaskHandle = A(this), this.requestUpdate();
  }
  stop() {
    this._frameTaskHandle && (this._updateRequested = false, this._stationaryHandle.remove(), this._frameTaskHandle.remove(), this._updateParameters = this._stationaryHandle = this._frameTaskHandle = null, this.stationary = true, this.animationInProgress = false);
  }
  requestUpdate() {
    this._updateRequested || (this._updateRequested = true, this.requestFrame());
  }
  requestFrame() {
    this._frameTaskHandle && this._frameTaskHandle.resume();
  }
  _updateLayerView(e9) {
    const t11 = this.view.state, a10 = e9.lastUpdateId;
    null != a10 && (this.stationary || e9.moving) || (e9.moving = true, e9.moveStart()), a10 !== t11.id && e9.viewChange(), this.stationary && e9.moving && (e9.moving = false, e9.moveEnd()), e9.lastUpdateId = t11.id, e9.updateRequested && e9.processUpdate(this._updateParameters), "layerViews" in e9 && e9.layerViews.forEach(this._updateLayerView, this);
  }
};

// node_modules/@arcgis/core/views/2d/layerViewModuleImportUtils.js
function s8() {
  return Promise.all([import("./webglDeps-6THCG3ZQ.js"), import("./mapViewDeps-MZZ7MOMX.js")]);
}
var a5 = () => s8().then(() => import("./TileLayerView2D-SAOHHCXK.js"));
var i4 = () => s8().then(() => import("./FeatureLayerView2D-TIJV6UNO.js"));
var o5 = { "base-dynamic": () => s8().then(() => import("./BaseDynamicLayerView2D-73CW34O4.js")), "base-tile": a5, "bing-maps": a5, csv: i4, "geo-rss": () => s8().then(() => import("./GeoRSSLayerView2D-XIRVOJWQ.js")), feature: i4, geojson: i4, graphics: () => s8().then(() => import("./GraphicsLayerView2D-Y767PRGP.js")), group: () => s8().then(() => import("./GroupLayerView2D-D3ZLHC65.js")), imagery: () => s8().then(() => import("./ImageryLayerView2D-4RIQDSAJ.js")), "imagery-tile": () => s8().then(() => import("./ImageryTileLayerView2D-JAPEIAS5.js")), kml: () => s8().then(() => import("./KMLLayerView2D-KZ52J25U.js")), "map-image": () => s8().then(() => import("./MapImageLayerView2D-63APPFDZ.js")), "map-notes": () => s8().then(() => import("./MapNotesLayerView2D-SJZXX6WI.js")), media: () => s8().then(() => import("./MediaLayerView2D-XYBTJ7J4.js")), "ogc-feature": () => s8().then(() => import("./OGCFeatureLayerView2D-C75GHZFG.js")), "open-street-map": a5, route: () => s8().then(() => import("./RouteLayerView2D-Z7ZINXFS.js")), stream: () => s8().then(() => import("./StreamLayerView2D-4G4MFQKR.js")), "subtype-group": () => s8().then(() => import("./SubtypeGroupLayerView2D-IDOLD6ZS.js")), tile: a5, "vector-tile": () => s8().then(() => import("./VectorTileLayerView2D-NT37AQ3U.js")), wcs: () => s8().then(() => import("./ImageryTileLayerView2D-JAPEIAS5.js")), "web-tile": a5, wfs: i4, wms: () => s8().then(() => import("./WMSLayerView2D-CSLREI2I.js")), wmts: () => s8().then(() => import("./WMTSLayerView2D-VFDMTTG4.js")), "line-of-sight": null, "base-elevation": null, "building-scene": null, elevation: null, "integrated-mesh": null, "point-cloud": null, voxel: null, scene: null, unknown: null, unsupported: null };
function l5(r7) {
  const t11 = r7.declaredClass ? r7.declaredClass.slice(r7.declaredClass.lastIndexOf(".") + 1) : "Unknown", s11 = t11.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  return new s2(`${s11}:view-not-supported`, `${t11} is not supported in 2D`);
}
var n6 = { hasLayerViewModule: (e9) => r(o5[e9.type]), importLayerView: (e9) => {
  const r7 = o5[e9.type];
  if (t(r7))
    throw l5(e9);
  return r7(e9);
} };

// node_modules/@arcgis/core/geometry/support/near.js
function o6(o9, m6) {
  const { spatialReference: r7 } = m6, i9 = [m6.x, m6.y];
  let s11 = Number.POSITIVE_INFINITY, x = 0, c9 = 0;
  const a10 = [0, 0], f3 = "extent" === o9.type ? [[[o9.xmin, o9.ymin], [o9.xmin, o9.ymax], [o9.xmax, o9.ymax], [o9.xmax, o9.ymin], [o9.xmin, o9.ymin]]] : o9.rings;
  for (const n9 of f3)
    for (let o10 = 0; o10 < n9.length - 1; o10++) {
      o(a10, i9, n9, o10);
      const m7 = m(i9, a10);
      m7 < s11 && (s11 = m7, x = a10[0], c9 = a10[1]);
    }
  return { coordinate: new j({ x, y: c9, spatialReference: r7 }), distance: s11 };
}

// node_modules/@arcgis/core/views/2d/constraints/GeometryConstraint.js
var p4;
var l6 = s.getLogger("esri.views.MapView");
var y2 = p4 = class extends y {
  constructor(e9) {
    super(e9), this.geometry = null, this.spatialReference = null;
  }
  get normalizedGeometry() {
    if (t(this.geometry) || !this.spatialReference)
      return null;
    if (!this.spatialReference.equals(this.geometry.spatialReference))
      try {
        return rn(this.geometry, this.spatialReference);
      } catch (e9) {
        return l6.error("#constraints.geometry", "could not project the geometry to the view's spatial reference", { geometry: this.geometry, spatialReference: this.spatialReference, error: e9 }), null;
      }
    return this.geometry;
  }
  constrain(e9, r7) {
    if (t(this.normalizedGeometry))
      return e9;
    const t11 = e9.targetGeometry;
    if ("extent" === this.normalizedGeometry.type ? r2(this.normalizedGeometry, t11) : c(this.normalizedGeometry, t11))
      return e9;
    const { coordinate: s11 } = o6(this.normalizedGeometry, t11);
    return s11 ? (e9.targetGeometry = s11, e9) : e9;
  }
  clone() {
    var _a, _b;
    return new p4({ geometry: (_a = this.geometry) == null ? void 0 : _a.clone(), spatialReference: (_b = this.spatialReference) == null ? void 0 : _b.clone() });
  }
};
e([d({ constructOnly: true })], y2.prototype, "geometry", void 0), e([d({ readOnly: true })], y2.prototype, "normalizedGeometry", null), e([d({ constructOnly: true })], y2.prototype, "spatialReference", void 0), y2 = p4 = e([n2("esri.views.2d.constraints.GeometryConstraint")], y2);

// node_modules/@arcgis/core/views/2d/constraints/RotationConstraint.js
var s9;
var a6 = s9 = class extends y {
  constructor() {
    super(...arguments), this.enabled = true, this.rotationEnabled = true;
  }
  constrain(o9, r7) {
    return this.enabled && r7 ? (this.rotationEnabled || (o9.rotation = r7.rotation), o9) : o9;
  }
  clone() {
    return new s9({ enabled: this.enabled, rotationEnabled: this.rotationEnabled });
  }
};
e([d()], a6.prototype, "enabled", void 0), e([d()], a6.prototype, "rotationEnabled", void 0), a6 = s9 = e([n2("esri.views.2d.constraints.RotationConstraint")], a6);
var n7 = a6;

// node_modules/@arcgis/core/views/2d/constraints/ZoomConstraint.js
var i5;
var a7 = i5 = class extends y {
  constructor(e9) {
    super(e9), this._lodByScale = {}, this._scales = [], this.effectiveLODs = null, this.effectiveMinZoom = -1, this.effectiveMaxZoom = -1, this.effectiveMinScale = 0, this.effectiveMaxScale = 0, this.lods = null, this.minZoom = -1, this.maxZoom = -1, this.minScale = 0, this.maxScale = 0, this.snapToZoom = true;
  }
  initialize() {
    let e9, { lods: t11, minScale: o9, maxScale: s11, minZoom: i9, maxZoom: a10 } = this, c9 = -1, r7 = -1, l8 = false, n9 = false;
    if (0 !== o9 && 0 !== s11 && o9 < s11 && ([o9, s11] = [s11, o9]), !t11 || !t11.length)
      return this._set("effectiveMinScale", o9), void this._set("effectiveMaxScale", s11);
    t11 = t11.map((e10) => e10.clone()), t11.sort((e10, t12) => t12.scale - e10.scale), t11.forEach((e10, t12) => e10.level = t12);
    for (const f3 of t11)
      !l8 && o9 > 0 && o9 >= f3.scale && (c9 = f3.level, l8 = true), !n9 && s11 > 0 && s11 >= f3.scale && (r7 = e9 ? e9.level : -1, n9 = true), e9 = f3;
    -1 === i9 && (i9 = 0 === o9 ? 0 : c9), -1 === a10 && (a10 = 0 === s11 ? t11.length - 1 : r7), i9 = Math.max(i9, 0), i9 = Math.min(i9, t11.length - 1), a10 = Math.max(a10, 0), a10 = Math.min(a10, t11.length - 1), i9 > a10 && ([i9, a10] = [a10, i9]), o9 = t11[i9].scale, s11 = t11[a10].scale, t11.splice(0, i9), t11.splice(a10 - i9 + 1, t11.length), t11.forEach((e10, t12) => {
      this._lodByScale[e10.scale] = e10, this._scales[t12] = e10.scale;
    }), this._set("effectiveLODs", t11), this._set("effectiveMinZoom", i9), this._set("effectiveMaxZoom", a10), this._set("effectiveMinScale", o9), this._set("effectiveMaxScale", s11);
  }
  constrain(e9, t11) {
    if (t11 && e9.scale === t11.scale)
      return e9;
    const o9 = this.effectiveMinScale, s11 = this.effectiveMaxScale, i9 = e9.targetGeometry, a10 = t11 && t11.targetGeometry, c9 = 0 !== s11 && e9.scale < s11, r7 = 0 !== o9 && e9.scale > o9;
    if (c9 || r7) {
      const c10 = r7 ? o9 : s11;
      if (a10) {
        const o10 = (c10 - t11.scale) / (e9.scale - t11.scale);
        i9.x = a10.x + (i9.x - a10.x) * o10, i9.y = a10.y + (i9.y - a10.y) * o10;
      }
      e9.scale = c10;
    }
    return this.snapToZoom && this.effectiveLODs && (e9.scale = this._getClosestScale(e9.scale)), e9;
  }
  fit(e9) {
    if (!this.effectiveLODs || !this.snapToZoom)
      return this.constrain(e9, null);
    const t11 = this.scaleToZoom(e9.scale), o9 = Math.abs(t11 - Math.floor(t11));
    return e9.scale = this.zoomToScale(o9 > 0.99 ? Math.round(t11) : Math.floor(t11)), e9;
  }
  zoomToScale(e9) {
    if (!this.effectiveLODs)
      return 0;
    e9 -= this.effectiveMinZoom, e9 = Math.max(0, e9);
    const t11 = this._scales;
    if (e9 <= 0)
      return t11[0];
    if (e9 >= t11.length)
      return t11[t11.length - 1];
    const o9 = Math.round(e9 - 0.5), s11 = Math.round(e9);
    return t11[s11] + (s11 - e9) * (t11[o9] - t11[s11]);
  }
  scaleToZoom(e9) {
    if (!this.effectiveLODs)
      return -1;
    const t11 = this._scales;
    let o9, s11;
    if (e9 >= t11[0])
      return this.effectiveMinZoom;
    if (e9 <= t11[t11.length - 1])
      return this.effectiveMaxZoom;
    for (let i9 = 0; i9 < t11.length - 1; i9++) {
      if (o9 = t11[i9], s11 = t11[i9 + 1], s11 === e9) {
        return i9 + this.effectiveMinZoom + 1;
      }
      if (o9 > e9 && s11 < e9) {
        return i9 + this.effectiveMinZoom + 1 - (e9 - s11) / (o9 - s11);
      }
    }
  }
  snapToClosestScale(e9) {
    if (!this.effectiveLODs)
      return e9;
    const t11 = this.scaleToZoom(e9);
    return this.zoomToScale(Math.round(t11));
  }
  snapToNextScale(e9, t11 = 0.5) {
    if (!this.effectiveLODs)
      return e9 * t11;
    const o9 = Math.round(this.scaleToZoom(e9));
    return this.zoomToScale(o9 + 1);
  }
  snapToPreviousScale(e9, t11 = 2) {
    if (!this.effectiveLODs)
      return e9 * t11;
    const o9 = Math.round(this.scaleToZoom(e9));
    return this.zoomToScale(o9 - 1);
  }
  clone() {
    return new i5({ lods: this.lods, minZoom: this.minZoom, maxZoom: this.maxZoom, minScale: this.minScale, maxScale: this.maxScale });
  }
  _getClosestScale(e9) {
    return this._lodByScale[e9] || (e9 = this._scales.reduce((t11, o9) => Math.abs(o9 - e9) <= Math.abs(t11 - e9) ? o9 : t11, this._scales[0])), this._lodByScale[e9].scale;
  }
};
e([d({ readOnly: true })], a7.prototype, "effectiveLODs", void 0), e([d({ readOnly: true })], a7.prototype, "effectiveMinZoom", void 0), e([d({ readOnly: true })], a7.prototype, "effectiveMaxZoom", void 0), e([d({ readOnly: true })], a7.prototype, "effectiveMinScale", void 0), e([d({ readOnly: true })], a7.prototype, "effectiveMaxScale", void 0), e([d()], a7.prototype, "lods", void 0), e([d()], a7.prototype, "minZoom", void 0), e([d()], a7.prototype, "maxZoom", void 0), e([d()], a7.prototype, "minScale", void 0), e([d()], a7.prototype, "maxScale", void 0), e([d()], a7.prototype, "snapToZoom", void 0), a7 = i5 = e([n2("esri.views.2d.constraints.ZoomConstraint")], a7);
var c5 = a7;

// node_modules/@arcgis/core/views/2d/MapViewConstraints.js
var p5 = { base: null, key: "type", typeMap: { extent: M, polygon: v } };
var c6 = class extends y {
  constructor(o9) {
    super(o9), this.lods = null, this.minScale = 0, this.maxScale = 0, this.minZoom = -1, this.maxZoom = -1, this.rotationEnabled = true, this.snapToZoom = true;
  }
  destroy() {
    this.view = null, this._set("_zoom", null), this._set("_rotation", null), this._set("_geometry", null);
  }
  set geometry(o9) {
    o9 ? this._set("geometry", o9) : this._set("geometry", null);
  }
  get version() {
    return this.commitProperty("_zoom"), this.commitProperty("_rotation"), this.commitProperty("_geometry"), (this._get("version") ?? 0) + 1;
  }
  get _defaultLODs() {
    var _a, _b, _c;
    const o9 = (_b = (_a = this.view) == null ? void 0 : _a.defaultsFromMap) == null ? void 0 : _b.tileInfo, t11 = (_c = this.view) == null ? void 0 : _c.spatialReference;
    return o9 && t11 && o9.spatialReference.equals(t11) ? o9.lods : null;
  }
  get _geometry() {
    var _a;
    return new y2({ geometry: this.geometry, spatialReference: (_a = this.view) == null ? void 0 : _a.spatialReference });
  }
  get _rotation() {
    return new n7({ rotationEnabled: this.rotationEnabled });
  }
  get _zoom() {
    const o9 = this._get("_zoom"), t11 = this.lods || this._defaultLODs, e9 = this.minZoom, r7 = this.maxZoom, s11 = this.minScale, i9 = this.maxScale, n9 = this.snapToZoom;
    return o9 && o9.lods === t11 && o9.minZoom === e9 && o9.maxZoom === r7 && o9.minScale === s11 && o9.maxScale === i9 && o9.snapToZoom === n9 ? o9 : new c5({ lods: t11, minZoom: e9, maxZoom: r7, minScale: s11, maxScale: i9, snapToZoom: n9 });
  }
  canZoomInTo(o9) {
    const t11 = this.effectiveMaxScale;
    return 0 === t11 || o9 >= t11;
  }
  canZoomOutTo(o9) {
    const t11 = this.effectiveMinScale;
    return 0 === t11 || o9 <= t11;
  }
  constrain(o9, t11) {
    return this._zoom.constrain(o9, t11), this._rotation.constrain(o9, t11), this._geometry.constrain(o9, t11), o9;
  }
  constrainByGeometry(o9) {
    return this._geometry.constrain(o9);
  }
  fit(o9) {
    return this._zoom.fit(o9);
  }
  zoomToScale(o9) {
    return this._zoom.zoomToScale(o9);
  }
  scaleToZoom(o9) {
    return this._zoom.scaleToZoom(o9);
  }
  snapScale(o9) {
    return this._zoom.snapToClosestScale(o9);
  }
  snapToNextScale(o9) {
    return this._zoom.snapToNextScale(o9);
  }
  snapToPreviousScale(o9) {
    return this._zoom.snapToPreviousScale(o9);
  }
};
e([d({ readOnly: true, aliasOf: "_zoom.effectiveLODs" })], c6.prototype, "effectiveLODs", void 0), e([d({ readOnly: true, aliasOf: "_zoom.effectiveMinScale" })], c6.prototype, "effectiveMinScale", void 0), e([d({ readOnly: true, aliasOf: "_zoom.effectiveMaxScale" })], c6.prototype, "effectiveMaxScale", void 0), e([d({ readOnly: true, aliasOf: "_zoom.effectiveMinZoom" })], c6.prototype, "effectiveMinZoom", void 0), e([d({ readOnly: true, aliasOf: "_zoom.effectiveMaxZoom" })], c6.prototype, "effectiveMaxZoom", void 0), e([d({ types: p5, value: null })], c6.prototype, "geometry", null), e([d({ type: [p] })], c6.prototype, "lods", void 0), e([d()], c6.prototype, "minScale", void 0), e([d()], c6.prototype, "maxScale", void 0), e([d()], c6.prototype, "minZoom", void 0), e([d()], c6.prototype, "maxZoom", void 0), e([d()], c6.prototype, "rotationEnabled", void 0), e([d()], c6.prototype, "snapToZoom", void 0), e([d()], c6.prototype, "view", void 0), e([d({ readOnly: true })], c6.prototype, "version", null), e([d()], c6.prototype, "_defaultLODs", null), e([d({ type: y2 })], c6.prototype, "_geometry", null), e([d({ type: n7 })], c6.prototype, "_rotation", null), e([d({ readOnly: true, type: c5 })], c6.prototype, "_zoom", null), c6 = e([n2("esri.views.2d.MapViewConstraints")], c6);
var y3 = c6;

// node_modules/@arcgis/core/views/2d/PaddedViewState.js
var l7;
var m4;
var w4 = l7 = class extends y {
  constructor() {
    super(...arguments), this.left = 0, this.top = 0, this.right = 0, this.bottom = 0;
  }
  clone() {
    return new l7({ left: this.left, top: this.top, right: this.right, bottom: this.bottom });
  }
};
e([d()], w4.prototype, "left", void 0), e([d()], w4.prototype, "top", void 0), e([d()], w4.prototype, "right", void 0), e([d()], w4.prototype, "bottom", void 0), w4 = l7 = e([n2("esri.views.2d.PaddedViewState.Padding")], w4);
var u5 = m4 = class extends U2 {
  constructor(...t11) {
    super(...t11), this.paddedViewState = new U2(), this._updateContent = (() => {
      const t12 = n3();
      return () => {
        const e9 = this._get("size"), i9 = this._get("padding");
        if (!e9 || !i9)
          return;
        const o9 = this.paddedViewState;
        r3(t12, i9.left + i9.right, i9.top + i9.bottom), o2(t12, e9, t12), a2(o9.size, t12);
        const s11 = o9.viewpoint;
        s11 && (this.viewpoint = s11);
      };
    })(), this.own(l2(() => [this.size, this.padding], () => this._updateContent(), U)), this.padding = new w4(), this.size = [0, 0];
  }
  set padding(t11) {
    this._set("padding", t11 || new w4());
  }
  set viewpoint(t11) {
    if (t11) {
      const e9 = t11.clone();
      this.paddedViewState.viewpoint = t11, gt(e9, t11, this._get("size"), this._get("padding"));
      const i9 = this._viewpoint2D, o9 = e9.targetGeometry;
      i9.center[0] = o9.x, i9.center[1] = o9.y, i9.rotation = e9.rotation, i9.scale = e9.scale, i9.spatialReference = o9.spatialReference, this._update();
    }
  }
  clone() {
    return new m4({ padding: this.padding.clone(), size: this.size.slice(), viewpoint: this.paddedViewState.viewpoint.clone(), pixelRatio: this.pixelRatio });
  }
};
e([d()], u5.prototype, "paddedViewState", void 0), e([d({ type: w4 })], u5.prototype, "padding", null), e([d()], u5.prototype, "viewpoint", null), u5 = m4 = e([n2("esri.views.2d.PaddedViewState")], u5);
var g4 = u5;

// node_modules/@arcgis/core/views/2d/input/handlers/DoubleClickZoom.js
var a8 = class extends i {
  constructor(t11, i9) {
    super(true), this.view = t11, this.registerIncoming("double-click", i9, (t12) => this._handleDoubleClick(t12, i9));
  }
  _handleDoubleClick(t11, a10) {
    t6(t11.data, "primary") && (t11.stopPropagation(), a10 ? this.view.mapViewNavigation.zoomOut([t11.data.x, t11.data.y]) : this.view.mapViewNavigation.zoomIn([t11.data.x, t11.data.y]));
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/DoubleTapDragZoom.js
var e6 = class extends i {
  constructor(t11, e9, a10) {
    super(true), this.view = t11, this.pointerType = e9, this.registerIncoming("double-tap-drag", a10, (t12) => this._handleDoubleTapDrag(t12));
  }
  _handleDoubleTapDrag(t11) {
    const { data: e9 } = t11, { pointerType: a10 } = e9;
    if (a10 !== this.pointerType)
      return;
    t11.stopPropagation();
    const { action: s11, delta: i9 } = e9, { view: r7 } = this, { mapViewNavigation: n9 } = r7;
    switch (s11) {
      case "begin": {
        const { scale: t12 } = r7;
        this._startScale = t12, this._currentScale = t12, this._previousDelta = i9, n9.begin();
        break;
      }
      case "update": {
        if (this._previousDelta.y === i9.y)
          return;
        this._previousDelta = i9;
        const t12 = 1.015 ** i9.y, e10 = this._startScale * t12, a11 = e10 / this._currentScale;
        n9.setViewpointImmediate(a11), this._currentScale = e10;
        break;
      }
      case "end": {
        const { constraints: t12 } = r7, { effectiveLODs: e10, snapToZoom: a11 } = t12;
        if (!a11 || !e10)
          return void n9.end();
        const s12 = t12.snapScale(this._currentScale), o9 = (i9.y > 0 ? Math.max(s12, t12.snapToPreviousScale(this._startScale)) : Math.min(s12, t12.snapToNextScale(this._startScale))) / this._currentScale;
        n9.zoom(o9);
        break;
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/DragPan.js
var n8 = class extends i {
  constructor(t11, i9, a10) {
    super(true), this.view = t11, this.pointerAction = i9, this.registerIncoming("drag", a10, (t12) => this._handleDrag(t12)), this.registerIncoming("pointer-down", () => this.stopMomentumNavigation());
  }
  onInstall(i9) {
    super.onInstall(i9), this.dragEventSeparator = new t7({ start: (t11, i10) => {
      this.view.mapViewNavigation.pan.begin(this.view, i10.data), i10.stopPropagation();
    }, update: (t11, i10) => {
      this.view.mapViewNavigation.pan.update(this.view, i10.data), i10.stopPropagation();
    }, end: (t11, i10) => {
      this.view.mapViewNavigation.pan.end(this.view, i10.data), i10.stopPropagation();
    }, condition: (t11, i10) => 1 === t11 && t6(i10.data, this.pointerAction) });
  }
  _handleDrag(t11) {
    const i9 = this.view.mapViewNavigation;
    i9.pinch.zoomMomentum || i9.pinch.rotateMomentum ? this.stopMomentumNavigation() : this.dragEventSeparator.handle(t11);
  }
  stopMomentumNavigation() {
    this.view.mapViewNavigation.pan.stopMomentumNavigation();
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/DragRotate.js
var o7 = class extends i {
  constructor(a10, o9, r7) {
    super(true), this.view = a10, this.pointerAction = o9;
    const e9 = this.view.mapViewNavigation;
    this.dragEventSeparator = new t7({ start: (t11, a11) => {
      e9.rotate.begin(this.view, a11.data), a11.stopPropagation();
    }, update: (t11, a11) => {
      e9.rotate.update(this.view, a11.data), a11.stopPropagation();
    }, end: (t11, a11) => {
      e9.rotate.end(), a11.stopPropagation();
    }, condition: (t11, a11) => 1 === t11 && t6(a11.data, this.pointerAction) }), this.registerIncoming("drag", r7, (t11) => this.dragEventSeparator.handle(t11));
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/GamepadNavigation.js
var d3 = class extends i {
  constructor(i9) {
    super(true), this.view = i9, this.frameTask = null, this.watchHandles = new u(), this.currentDevice = null, this.transformation = { translation: [0, 0, 0], heading: 0, tilt: 0, zoom: 0 }, this.handle = this.registerIncoming("gamepad", (t11) => this._handleGamePadEvent(t11)), this.handle.pause();
  }
  onInstall(t11) {
    super.onInstall(t11), this.watchHandles.add([l2(() => {
      var _a;
      return (_a = this.view.navigation.gamepad) == null ? void 0 : _a.enabled;
    }, (t12) => {
      t12 ? (this.handle.resume(), this.frameTask || (this.frameTask = A({ update: (t13) => this._frameUpdate(t13.deltaTime) }))) : (this.handle.pause(), this.frameTask && (this.frameTask.remove(), this.frameTask = null));
    }, h)]);
  }
  onUninstall() {
    this.watchHandles.removeAll(), this.frameTask && (this.frameTask.remove(), this.frameTask = null), super.onUninstall();
  }
  _handleGamePadEvent(t11) {
    const i9 = this.view.navigation.gamepad.device;
    i9 && t11.data.device !== i9 || this.currentDevice && this.currentDevice !== t11.data.device || ("end" === t11.data.action ? (this.currentDevice = null, a3(this.transformation)) : (this.currentDevice = t11.data.device, i2(t11.data, this.view.navigation.gamepad, this.transformation)));
  }
  _frameUpdate(t11) {
    const i9 = this.transformation;
    if (s4(i9))
      return;
    const e9 = this.view.viewpoint.clone(), a10 = this.view.navigation.gamepad.velocityFactor, r7 = c7 * a10 * t11;
    St(e9, e9, [i9.translation[0] * r7, -i9.translation[1] * r7]);
    const o9 = 1 + i9.translation[2] * v2 * t11, h3 = this.view.constraints.rotationEnabled ? -i9.heading * m5 * t11 : 0, d4 = this.view.size, p8 = [d4[0] / 2, d4[1]];
    Gt(e9, e9, o9, h3, p8, d4);
    const f3 = this.view.constraints.constrain(e9, this.view.viewpoint);
    this.view.viewpoint = f3;
  }
};
var m5 = 0.06;
var c7 = 0.7;
var v2 = 6e-4;

// node_modules/@arcgis/core/views/2d/input/handlers/KeyPan.js
var i6 = class extends i {
  constructor(e9, i9, t11) {
    super(true), this.view = e9, this.keys = i9, this._pressed = false, this._keyMap = { [i9.left]: "left", [i9.right]: "right", [i9.up]: "up", [i9.down]: "down" }, this.registerIncoming("key-down", t11, (e10) => this._handleKeyDown(e10)), this.registerIncoming("key-up", t11, (e10) => this._handleKeyUp(e10)), this.registerIncoming("blur", t11, () => this._handleBlur());
  }
  _handleKeyDown(e9) {
    e9.data.repeat || this._handleKey(e9, true);
  }
  _handleKeyUp(e9) {
    this._handleKey(e9, false);
  }
  _handleBlur() {
    this._pressed && (this._pressed = false, this.view.mapViewNavigation.stop());
  }
  _handleKey(e9, i9) {
    const t11 = this._keyMap[e9.data.key];
    if (this._pressed = null != t11, this._pressed) {
      if (i9)
        switch (this.view.mapViewNavigation.begin(), t11) {
          case "left":
            this.view.mapViewNavigation.continousPanLeft();
            break;
          case "right":
            this.view.mapViewNavigation.continousPanRight();
            break;
          case "up":
            this.view.mapViewNavigation.continousPanUp();
            break;
          case "down":
            this.view.mapViewNavigation.continousPanDown();
        }
      else
        this._pressed = false, this.view.mapViewNavigation.stop();
      e9.stopPropagation();
    }
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/KeyRotate.js
var i7 = class extends i {
  constructor(e9, i9, t11) {
    super(true), this.view = e9, this.keys = i9, this._pressed = false, this._keyToDirection = { [i9.clockwiseOption1]: "clockwise", [i9.clockwiseOption2]: "clockwise", [i9.counterClockwiseOption1]: "counterClockwise", [i9.counterClockwiseOption2]: "counterClockwise", [i9.resetOption1]: "reset", [i9.resetOption2]: "reset" }, this.registerIncoming("key-down", t11, (e10) => this._handleKeyDown(e10)), this.registerIncoming("key-up", t11, (e10) => this._handleKeyUp(e10)), this.registerIncoming("blur", t11, () => this._handleBlur());
  }
  _handleKeyDown(e9) {
    e9.data.repeat || this._handleKey(e9, true);
  }
  _handleKeyUp(e9) {
    this._handleKey(e9, false);
  }
  _handleBlur() {
    this._pressed && (this._pressed = false, this.view.mapViewNavigation.stop());
  }
  _handleKey(e9, i9) {
    const t11 = e9.modifiers;
    if (t11.size > 0 && !t11.has("Shift") || !this.view.constraints.rotationEnabled)
      return;
    const s11 = this._keyToDirection[e9.data.key];
    if (this._pressed = null != s11, this._pressed) {
      if (i9)
        switch (this.view.mapViewNavigation.begin(), s11) {
          case "clockwise":
            this.view.mapViewNavigation.continousRotateClockwise();
            break;
          case "counterClockwise":
            this.view.mapViewNavigation.continousRotateCounterclockwise();
            break;
          case "reset":
            this.view.mapViewNavigation.resetRotation();
        }
      else
        this._pressed = false, this.view.mapViewNavigation.stop();
      e9.stopPropagation();
    }
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/KeyZoom.js
var t8;
!function(o9) {
  o9[o9.IN = 0] = "IN", o9[o9.OUT = 1] = "OUT";
}(t8 || (t8 = {}));
var e7 = class extends i {
  constructor(o9, e9, i9) {
    super(true), this.view = o9, this.keys = e9, this._keysToZoomAction = {}, this.registerIncoming("key-down", i9, (o10) => this._handleKeyDown(o10)), e9.zoomIn.forEach((o10) => this._keysToZoomAction[o10] = t8.IN), e9.zoomOut.forEach((o10) => this._keysToZoomAction[o10] = t8.OUT);
  }
  _handleKeyDown(o9) {
    this._handleKey(o9);
  }
  _handleKey(o9) {
    const e9 = o9.modifiers;
    if (e9.size > 0 && !e9.has("Shift"))
      return;
    const { key: i9 } = o9.data;
    if (!(i9 in this._keysToZoomAction))
      return;
    const n9 = this._keysToZoomAction[i9], { mapViewNavigation: s11 } = this.view;
    let r7 = null;
    switch (n9) {
      case t8.IN:
        r7 = s11.zoomIn();
        break;
      case t8.OUT:
        r7 = s11.zoomOut();
        break;
      default:
        return;
    }
    s11.begin(), r7.then(() => s11.end()), o9.stopPropagation();
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/MouseWheelZoom.js
var t9 = 0.6;
var o8 = class extends i {
  constructor(e9, t11) {
    super(true), this.view = e9, this._canZoom = true, this.registerIncoming("mouse-wheel", t11, (e10) => this._handleMouseWheel(e10));
  }
  _handleMouseWheel(e9) {
    if (!this.view.navigation.mouseWheelZoomEnabled)
      return;
    if (e9.preventDefault(), e9.stopPropagation(), !this._canZoom)
      return;
    const o9 = this.view.mapViewNavigation, { x: n9, y: i9, deltaY: s11 } = e9.data, a10 = 1 / t9 ** (1 / 60 * s11), h3 = o9.zoom(a10, [n9, i9]);
    h3 && (this._canZoom = false, h3.catch(() => {
    }).then(() => {
      this._canZoom = true, o9.end();
    }));
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/PinchAction.js
var a9 = class extends i {
  constructor(i9) {
    super(true), this.view = i9, this.registerIncoming("drag", (t11) => this._handleDrag(t11)), this.registerIncoming("pointer-down", () => this._stopMomentumNavigation());
    const a10 = this.view.mapViewNavigation;
    this.dragEventSeparator = new t7({ start: (t11, i10) => {
      a10.pinch.begin(this.view, i10.data), i10.stopPropagation();
    }, update: (t11, i10) => {
      a10.pinch.update(this.view, i10.data), i10.stopPropagation();
    }, end: (t11, i10) => {
      a10.pinch.end(this.view), i10.stopPropagation();
    }, condition: (t11) => t11 >= 2 });
  }
  _handleDrag(t11) {
    this.dragEventSeparator.handle(t11);
  }
  _stopMomentumNavigation() {
    this.view.mapViewNavigation.pinch.stopMomentumNavigation();
  }
};

// node_modules/@arcgis/core/views/input/recognizers/DoubleTapDrag.js
var s10 = class extends i {
  constructor(e9 = s5.maximumDoubleClickDelay, o9 = s5.maximumDoubleClickDistance, n9 = s5.maximumDoubleTouchDelay, s11 = s5.maximumDoubleTouchDistance, u6 = t3) {
    super(false), this.maximumDoubleClickDelay = e9, this.maximumDoubleClickDistance = o9, this.maximumDoubleTouchDelay = n9, this.maximumDoubleTouchDistance = s11, this._clock = u6, this._doubleTapDragReady = false, this._doubleTapDragActive = false, this._dragStartCenter = c2(0, 0), this._pointerState = /* @__PURE__ */ new Map(), this._doubleTapDrag = this.registerOutgoing("double-tap-drag"), this._dragEventSeparator = new t7({ start: (t11, e10) => this._dragStart(t11, e10), update: (t11, e10) => this._dragUpdate(e10), end: (t11, e10) => this._dragEnd(e10) }), this.registerIncoming("drag", (t11) => this._dragEventSeparator.handle(t11)), this.registerIncoming("pointer-down", (t11) => this._handlePointerDown(t11)), this.registerIncoming("pointer-up", () => this._handlePointerUp());
  }
  onUninstall() {
    this._pointerState.forEach((t11) => {
      null != t11.doubleTapTimeout && (t11.doubleTapTimeout.remove(), t11.doubleTapTimeout = null);
    });
  }
  get hasPendingInputs() {
    return n(this._pointerState, (t11) => null != t11.doubleTapTimeout);
  }
  _clearPointerDown(t11) {
    const e9 = this._pointerState.get(t11);
    e9 && (e9.doubleTapTimeout.remove(), e9.doubleTapTimeout = null, this._pointerState.delete(t11), this.refreshHasPendingInputs());
  }
  _createDoubleTapDragData(t11, e9, i9) {
    const { button: a10, buttons: o9, pointer: r7, pointers: n9, pointerType: s11, timestamp: u6 } = i9;
    return { action: t11, delta: e9, button: a10, buttons: o9, pointer: r7, pointers: n9, pointerType: s11, timestamp: u6 };
  }
  _dragStart(t11, e9) {
    if (!this._doubleTapDragReady || 1 !== t11)
      return;
    this._doubleTapDragReady = false, this._doubleTapDragActive = true;
    const { data: a10, modifiers: o9 } = e9, { center: r7 } = a10;
    this._dragStartCenter = r7;
    const n9 = this._createDoubleTapDragData("begin", c2(0, 0), a10);
    this._doubleTapDrag.emit(n9, void 0, o9), e9.stopPropagation();
  }
  _dragUpdate(t11) {
    if (!this._doubleTapDragActive)
      return;
    const { data: e9, modifiers: a10 } = t11, { center: o9 } = e9, r7 = c2(o9.x - this._dragStartCenter.x, o9.y - this._dragStartCenter.y), n9 = this._createDoubleTapDragData("update", r7, e9);
    this._doubleTapDrag.emit(n9, void 0, a10), t11.stopPropagation();
  }
  _dragEnd(t11) {
    if (!this._doubleTapDragActive)
      return;
    const { data: e9, modifiers: a10 } = t11, { center: o9 } = e9, r7 = c2(o9.x - this._dragStartCenter.x, o9.y - this._dragStartCenter.y), n9 = this._createDoubleTapDragData("end", r7, e9);
    this._doubleTapDrag.emit(n9, void 0, a10), this._doubleTapDragActive = false, t11.stopPropagation();
  }
  _handlePointerDown(t11) {
    const { data: e9 } = t11, i9 = this._pointerId(e9), a10 = this._pointerState.get(i9), { pointerType: o9 } = e9.native;
    if (a10) {
      const r7 = "touch" === o9 ? this.maximumDoubleTouchDistance : this.maximumDoubleClickDistance;
      this._clearPointerDown(i9), e5(a10.event.data, e9) > r7 ? this._storePointerDown(t11) : this._doubleTapDragReady = true;
    } else
      this._storePointerDown(t11);
  }
  _handlePointerUp() {
    this._doubleTapDragReady = false;
  }
  _pointerId(t11) {
    const { native: e9 } = t11, { pointerId: i9, button: a10, pointerType: o9 } = e9;
    return "mouse" === o9 ? `${i9}:${a10}` : `${o9}`;
  }
  _storePointerDown(t11) {
    const { data: e9 } = t11, { pointerType: i9 } = e9.native, a10 = this._pointerId(e9), o9 = "touch" === i9 ? this.maximumDoubleTouchDelay : this.maximumDoubleClickDelay, r7 = this._clock.setTimeout(() => this._clearPointerDown(a10), o9);
    this._pointerState.set(a10, { event: t11, doubleTapTimeout: r7 }), this.refreshHasPendingInputs();
  }
};

// node_modules/@arcgis/core/views/2d/input/MapViewInputManager.js
var z = { counter: "Ctrl", pan: { left: "ArrowLeft", right: "ArrowRight", up: "ArrowUp", down: "ArrowDown" }, zoom: { zoomIn: ["=", "+"], zoomOut: ["-", "_"] }, rotate: { clockwiseOption1: "a", clockwiseOption2: "A", counterClockwiseOption1: "d", counterClockwiseOption2: "D", resetOption1: "n", resetOption2: "N" } };
var T = class extends y {
  constructor() {
    super(...arguments), this._handles = new u();
  }
  initialize() {
    const e9 = () => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.ready;
    };
    this._handles.add([f2(() => !e9(), () => this._disconnect()), f2(e9, () => this._connect())]);
  }
  destroy() {
    this._handles && (this._handles.removeAll(), this._handles = null), this._disconnect();
  }
  get latestPointerType() {
    var _a;
    return (_a = this._inputManager) == null ? void 0 : _a.latestPointerType;
  }
  get latestPointerLocation() {
    var _a;
    return (_a = this._inputManager) == null ? void 0 : _a.latestPointerLocation;
  }
  _disconnect() {
    this._inputManager && (this.view.viewEvents.disconnect(), this._inputManager.destroy(), this._inputManager = null, this._source.destroy(), this._source = null);
  }
  _connect() {
    const e9 = this.view.surface, t11 = new u3(e9, this.view.input), o9 = [new n5(), new o4(), new a4(), new s6(this.view.navigation), new s10()], r7 = new c4({ eventSource: t11, recognizers: o9 });
    r7.installHandlers("prevent-context-menu", [new e4()], g2.INTERNAL), r7.installHandlers("navigation", [new a9(this.view), new d3(this.view), new o8(this.view), new a8(this.view), new a8(this.view, [z.counter]), new n8(this.view, "primary"), new i6(this.view, z.pan), new e7(this.view, z.zoom), new i7(this.view, z.rotate), new o7(this.view, "secondary"), new e6(this.view, "touch")], g2.INTERNAL), this.view.viewEvents.connect(r7), this._source = t11, this._inputManager = r7, l2(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.navigation) == null ? void 0 : _b.browserTouchPanEnabled;
    }, (e10) => {
      this._source && (this._source.browserTouchPanningEnabled = !e10);
    }, h);
  }
  get test() {
    return { inputManager: this._inputManager };
  }
};
e([d()], T.prototype, "view", void 0), e([d()], T.prototype, "latestPointerType", null), e([d()], T.prototype, "latestPointerLocation", null), T = e([n2("esri.views.2d.input.MapViewInputManager")], T);
var k = T;

// node_modules/@arcgis/core/views/2d/support/HighlightOptions.js
var p6 = 0;
var i8 = class extends y {
  constructor() {
    super(...arguments), this.color = new l([0, 255, 255]), this.haloOpacity = 1, this.fillOpacity = 0.25;
  }
  get version() {
    return p6++;
  }
};
e([d({ readOnly: true })], i8.prototype, "version", null), e([d({ type: l })], i8.prototype, "color", void 0), e([d({ type: l })], i8.prototype, "haloColor", void 0), e([d()], i8.prototype, "haloOpacity", void 0), e([d()], i8.prototype, "fillOpacity", void 0), i8 = e([n2("esri.views.2d.support.HighlightOptions")], i8);
var c8 = i8;

// node_modules/@arcgis/core/views/support/createScreenshotPlan.js
function t10(t11, h3, i9, e9, d4, l8, n9, o9) {
  let u6;
  t11.ignorePadding && (e9 = { left: 0, right: 0, top: 0, bottom: 0 }), null != t11.width && null != t11.height ? u6 = [t11.width, t11.height] : null == t11.width && null != t11.height ? u6 = [t11.height, t11.height] : null != t11.width && null == t11.height ? u6 = [t11.width, t11.width] : null == t11.width && null == t11.height && (u6 = null);
  const r7 = i9[0] - (e9.left + e9.right), a10 = i9[1] - (e9.top + e9.bottom);
  let g5, w5, c9 = t11.area || { x: 0, y: 0, width: r7, height: a10 };
  if (u6) {
    const t12 = r7 / a10, h4 = u6[0] / u6[1];
    if (h4 > t12) {
      const t13 = c9.width / h4;
      c9 = { x: c9.x, y: Math.round(c9.y + (c9.height - t13) / 2), width: c9.width, height: Math.round(t13) };
    } else {
      const t13 = c9.height * h4;
      c9 = { x: Math.round(c9.x + (c9.width - t13) / 2), y: c9.y, width: Math.round(t13), height: c9.height };
    }
  } else
    u6 = [c9.width, c9.height];
  u6[0] > c9.width ? (g5 = Math.min(u6[0] / c9.width, h3), w5 = u6[0] / c9.width / g5) : (g5 = 1, w5 = u6[0] / c9.width);
  return { resolutionScale: g5, cropArea: { x: Math.round((c9.x + e9.left) * g5), y: Math.round((c9.y + e9.top) * g5), width: Math.round(c9.width * g5), height: Math.round(c9.height * g5) }, outputScale: w5, format: d4, quality: l8, children: n9, rotation: o9 };
}

// node_modules/@arcgis/core/views/ui/2d/DefaultUI2D.js
var e8 = class extends _ {
  constructor(o9) {
    super(o9), this.components = ["attribution", "zoom"];
  }
};
e([d()], e8.prototype, "components", void 0), e8 = e([n2("esri.views.ui.2d.DefaultUI2D")], e8);
var p7 = e8;

// node_modules/@arcgis/core/views/MapView.js
var he = s.getLogger("esri.views.MapView");
var ce;
var de;
var ue;
var me;
var ge;
var fe;
async function ye() {
  const [, { GraphicsView2D: e9, GraphicContainer: t11, LabelManager: i9, MapViewNavigation: s11, MagnifierView2D: r7, Stage: n9 }] = await Promise.all([import("./webglDeps-6THCG3ZQ.js"), import("./mapViewDeps-MZZ7MOMX.js")]);
  de = e9, ue = t11, me = i9, ge = s11, fe = r7, ce = n9;
}
var we = 160;
function _e(e9) {
  return e9 && "esri.Viewpoint" === e9.declaredClass;
}
var ve = class extends w3(g3(p3(G))) {
  constructor(e9) {
    super(e9), this._magnifierView = null, this._stage = null, this._resolveWhenReady = [], this.rootLayerViews = new p2({ getCollections: () => {
      var _a, _b;
      return [(_a = this.basemapView) == null ? void 0 : _a.baseLayerViews, this.layerViews, (_b = this.basemapView) == null ? void 0 : _b.referenceLayerViews];
    }, getChildrenFunction: () => null }), this.featuresTilingScheme = null, this.fullOpacity = 1, this.graphicsView = null, this.labelManager = null, this.mapViewNavigation = null, this.renderingOptions = { samplingMode: "dynamic", edgeLabelsVisible: true, labelsAnimationTime: 125, labelCollisionsEnabled: true }, this.rendering = false, this.supersampleScreenshotsEnabled = false, this.supportsGround = false, this._stationaryTimer = null, this.frameTask = new s7(this), this._pePromise = null, this.floors = new j2(), this.highlightOptions = new c8(), this.inputManager = new k({ view: this }), this.map = null, this.resizeAlign = "center", this.spatialReferenceLocked = false, this.timeline = new e3(), this.type = "2d", this.ui = new p7(), this._pixelFormat = { flipY: true, premultipliedAlpha: true }, this.constraints = new y3(), this.padding = { top: 0, right: 0, bottom: 0, left: 0 }, this.handles.add([l2(() => this.viewpoint, () => {
      this._lastStationaryEventTimestamp = performance.now(), this._flipStationary(we);
    }, U), this.on("resize", (e10) => this._resizeHandler(e10)), l2(() => {
      var _a;
      return (_a = this.animationManager) == null ? void 0 : _a.animation;
    }, (e10) => {
      this.animation = e10;
    })]), c3();
  }
  destroy() {
    this._set("preconditionsReady", false), this._gotoTask = this.frameTask = null, this.rootLayerViews.destroy(), this.inputManager.destroy(), this._set("inputManager", null);
  }
  get graphicsTileStore() {
    return new l4(this.featuresTilingScheme);
  }
  get initialExtentRequired() {
    var _a;
    const { scale: e9, constraints: t11, center: i9, viewpoint: s11, extent: r7 } = this;
    let n9 = this.zoom;
    return !(this.map && "initialViewProperties" in this.map && ((_a = this.map.initialViewProperties) == null ? void 0 : _a.viewpoint)) && (!r7 && ((t11 == null ? void 0 : t11.effectiveLODs) || (n9 = -1), (!i9 || 0 === e9 && -1 === n9) && (!s11 || !r(s11.targetGeometry) || "extent" !== s11.targetGeometry.type && !s11.scale)));
  }
  get resourceManager() {
    return this._stage.resourceManager;
  }
  get textureManager() {
    return this._stage.painter.textureManager;
  }
  get _defaultsFromMapSettings() {
    return { required: { tileInfo: true, heightModelInfo: false, extent: false }, requiresExtentInSpatialReference: this.spatialReferenceLocked };
  }
  get _projectionEngineLoaded() {
    return !!en() || (this._pePromise || (this._pePromise = tn().finally(() => {
      this._pePromise = null;
    })), false);
  }
  get typeSpecificPreconditionsReady() {
    const e9 = this._getDefaultViewpoint();
    if (!e9)
      return false;
    const t11 = this.spatialReference, i9 = e2(e9.targetGeometry);
    return !!An(i9.spatialReference, t11) || this._projectionEngineLoaded;
  }
  set animation(e9) {
    const t11 = this._get("animation");
    if (e9 === t11)
      return;
    if (t11 && t11.stop(), !e9 || e9.isFulfilled())
      return void this._set("animation", null);
    this._set("animation", e9), this.frameTask.animationInProgress = true;
    const i9 = () => {
      e9 === this._get("animation") && (this._set("animation", null), this.frameTask.requestFrame()), this.frameTask.animationInProgress = false;
    };
    e9.when(i9, i9);
  }
  get background() {
    return this.get("map.initialViewProperties.background") || null;
  }
  set background(e9) {
    void 0 === e9 ? this._clearOverride("background") : this._override("background", e9);
  }
  get center() {
    if (!this.ready)
      return this._get("center");
    const { center: e9, spatialReference: t11 } = this.state.paddedViewState;
    return new j({ x: e9[0], y: e9[1], spatialReference: t11 });
  }
  set center(e9) {
    if (null == e9)
      return;
    if (!this.ready)
      return this._set("center", e9), void this.notifyChange("initialExtentRequired");
    let t11;
    try {
      t11 = this._project(e9, this.spatialReference);
    } catch (s11) {
      return void he.error(new s2("mapview:invalid-center", "could not project the value in the view's spatial reference", { input: e9, error: s11 }));
    }
    const i9 = this.viewpoint;
    xt(i9, i9, t11), this.viewpoint = i9;
  }
  set constraints(e9) {
    const t11 = this._get("constraints");
    t11 && (this.handles.remove("map-view-constraints"), t11.destroy()), this._set("constraints", e9), e9 && (e9.view = this, this.ready && (this.state.viewpoint = e9.fit(this.state.paddedViewState.viewpoint)), this.handles.add(l2(() => e9.version, () => {
      this.ready && this.state && (this.state.viewpoint = e9.fit(this.state.paddedViewState.viewpoint));
    }, U), "map-view-constraints"));
  }
  get extent() {
    return this.ready ? this.state.paddedViewState.extent.clone() : this._get("extent");
  }
  set extent(e9) {
    if (null == e9)
      return;
    if (!e9.width || !e9.height)
      return void he.error(new s2("mapview:invalid-extent", "invalid extent size"));
    if (!this.ready)
      return this._set("extent", e9), this._set("center", null), this._set("viewpoint", null), this._set("scale", 0), this._set("zoom", -1), void this.notifyChange("initialExtentRequired");
    let t11;
    try {
      t11 = this._project(e9, this.spatialReference);
    } catch (s11) {
      return void he.error(new s2("mapview:invalid-extent", "could not project the value in the view's spatial reference", { error: s11 }));
    }
    const i9 = this.viewpoint;
    tt(i9, i9, t11, this.size, { constraints: this.constraints }), this.viewpoint = i9;
  }
  get padding() {
    return this.ready ? this.state.padding : this._get("padding");
  }
  set padding(e9) {
    this.ready ? (this.state.padding = e9, this._set("padding", this.state.padding)) : this._set("padding", e9);
  }
  get resolution() {
    return this.state ? this.state.resolution : 0;
  }
  get rotation() {
    return this.ready ? this.state.rotation : this._get("rotation");
  }
  set rotation(e9) {
    if (isNaN(e9))
      return;
    if (!this.ready)
      return void this._set("rotation", e9);
    const t11 = this.viewpoint;
    wt(t11, t11, e9), this.viewpoint = t11;
  }
  get scale() {
    return this.ready ? this.state.scale : this._get("scale");
  }
  set scale(e9) {
    if (!e9 || isNaN(e9))
      return;
    if (!this.ready) {
      this._set("scale", e9), this._set("zoom", -1);
      const t12 = this._get("extent");
      return t12 && (this._set("extent", null), this._set("center", t12.center)), void this.notifyChange("initialExtentRequired");
    }
    const t11 = this.viewpoint;
    jt(t11, t11, e9), this.viewpoint = t11;
  }
  get stationary() {
    return !(this.animation || this.navigating || this.resizing || this._stationaryTimer);
  }
  get updating() {
    return !this.destroyed && (!this.layerViewManager || !this.labelManager || !this.graphicsView || true === this.layerViewManager.updating || true === this.labelManager.updating || true === this.graphicsView.updating || this.allLayerViews.some((e9) => !e9.destroyed && !("layerViews" in e9) && true === e9.updating));
  }
  get viewpoint() {
    if (!this.ready)
      return this._get("viewpoint");
    const e9 = this.state.paddedViewState;
    return e9 && e9.viewpoint.clone();
  }
  set viewpoint(e9) {
    if (null == e9)
      return;
    if (!this.ready)
      return this._set("viewpoint", e9), this._set("extent", null), this._set("center", null), this._set("zoom", -1), this._set("scale", 0), void this.notifyChange("initialExtentRequired");
    let t11, s11;
    try {
      t11 = this._project(e9, this.spatialReference), !e9.scale || isNaN(e9.scale) ? s11 = new s2("mapview:invalid-viewpoint", `invalid scale value of ${e9.scale}`) : t(e9.targetGeometry) && (s11 = new s2("mapview:invalid-viewpoint", "geometry not defined"));
    } catch (a10) {
      s11 = new s2("mapview:invalid-viewpoint", "could not project the value in the view's spatial reference", { error: a10 });
    }
    if (s11)
      return void he.error(s11);
    this._scaleBeforeChangingSpatialReference = null;
    const r7 = new u2({ targetGeometry: new j(), scale: 0, rotation: 0 });
    Z(r7, t11), this.constraints.constrain(r7, this.state.paddedViewState.viewpoint), this.state.viewpoint = r7, this.frameTask.requestFrame(), this._set("viewpoint", r7);
  }
  get zoom() {
    return this.ready ? this.constraints.scaleToZoom(this.scale) : this._get("zoom");
  }
  set zoom(e9) {
    if (null == e9)
      return;
    if (!this.ready) {
      this._set("zoom", e9), this._set("scale", 0);
      const t12 = this._get("extent");
      return t12 && (this._set("extent", null), this._set("center", t12.center)), void this.notifyChange("initialExtentRequired");
    }
    if (!this.constraints.effectiveLODs)
      return void this._set("zoom", -1);
    const t11 = this.viewpoint;
    jt(t11, t11, this.constraints.zoomToScale(e9)), this.viewpoint = t11, this._set("zoom", this.constraints.scaleToZoom(this.scale));
  }
  get navigating() {
    return !(!this.mapViewNavigation || !this.mapViewNavigation.interacting);
  }
  goTo(e9, t11) {
    if (e9)
      return this.animation && (this.animation = null), this._createAnimation(), j3(() => this.ready, t11).then(() => {
        const i9 = { animate: true, ...t11 }, s11 = Y(e9, this);
        return this.animation.update(s11), this._gotoTask = {}, i9.animate ? this._gotoAnimated(s11, i9) : this._gotoImmediate(s11, i9);
      });
    he.error("#goTo()", "target cannot be null or undefined");
  }
  async hitTest(e9, t11) {
    const i9 = o3(e9) ? r6(this, e9) : e9;
    if (!this.ready || isNaN(i9.x) || isNaN(i9.y))
      return { screenPoint: i9, results: [] };
    let s11 = /* @__PURE__ */ new Set(), r7 = false, n9 = null, a10 = null;
    (t11 == null ? void 0 : t11.include) ? Te(t11.include, je(this, (e10) => s11.add(e10), (e10) => {
      n9 || (n9 = /* @__PURE__ */ new Set()), n9.add(e10);
    }, (e10) => s11.add(e10), () => r7 = true)) : (r7 = true, s11 = new Set(this.allLayerViews)), (t11 == null ? void 0 : t11.exclude) && Te(t11.exclude, je(this, (e10) => s11.delete(e10), (e10) => {
      a10 || (a10 = /* @__PURE__ */ new Set()), a10.add(e10);
    }));
    const o9 = this.allLayerViews.filter((e10) => !e10.suspended && s11.has(e10)).reverse(), l8 = this.toMap(i9);
    let h3 = [...r7 ? this.graphicsView.hitTest(l8).map((e10) => ({ type: "graphic", graphic: e10, layer: null, mapPoint: l8 })) : [], ...await Promise.all(o9.map((e10) => e10.hitTest(l8, i9)).toArray())].filter(r).flat().filter(r);
    return n9 && (h3 = h3.filter((e10) => !("graphic" in e10) || !e10.graphic || n9.has(Se(e10.graphic)))), a10 && (h3 = h3.filter((e10) => !("graphic" in e10) || !e10.graphic || a10.has(Se(e10.graphic)))), { screenPoint: i9, results: h3 };
  }
  async takeScreenshot(e9) {
    const t11 = this._createScreenshotPlan(e9), i9 = await this._stage.takeScreenshot(t11);
    return r4(i9, { format: t11.format, quality: t11.quality, rotation: 0, disableDecorations: false }, this._pixelFormat);
  }
  async _takeScreenshot(e9) {
    const t11 = this._createScreenshotPlan(e9), i9 = await this._stage.takeScreenshot(t11);
    return l3(i9, this._pixelFormat);
  }
  _createScreenshotPlan(e9) {
    e9 = e9 || {};
    const t11 = this.supersampleScreenshotsEnabled ? Math.min(4, w2(this.size, Math.min(4096, this._stage.context.parameters.maxTextureSize))) : 1;
    let i9;
    e9.layers ? (i9 = [], e9.layers.forEach((e10) => {
      const t12 = this.allLayerViews.find((t13) => t13.layer.id === e10.id);
      t12 && "container" in t12 && t12.container && i9.push(t12.container);
    })) : i9 = this._stage.children;
    const { format: s11, quality: r7 } = s3(e9.format, e9.quality);
    return t10(e9, t11, this.size, this.padding, s11, r7, i9, e9.rotation);
  }
  get test() {
    return { takeScreenshot: (e9) => this._takeScreenshot(e9) };
  }
  toMap(e9) {
    if (!this.ready)
      return null;
    const t11 = o3(e9) ? r6(this, e9) : e9, i9 = [0, 0], [s11, r7] = this.state.toMap(i9, [t11.x, t11.y]), n9 = this.spatialReference;
    return new j({ x: s11, y: r7, spatialReference: n9 });
  }
  toScreen(e9) {
    if (!this.ready)
      return null;
    const t11 = this._project(e9, this.spatialReference), i9 = [t11.x, t11.y];
    return this.state.toScreen(i9, i9), c2(i9[0], i9[1]);
  }
  on(e9, t11, i9, s11) {
    const r7 = this.inputManager && this.viewEvents.on(e9, t11, i9, s11);
    return r7 || super.on(e9, t11);
  }
  hasEventListener(e9) {
    return super.hasEventListener(e9) || this.viewEvents.hasHandler(e9);
  }
  whenLayerView(e9) {
    return super.whenLayerView(e9);
  }
  graphicChanged(e9) {
    if (this.graphicsView) {
      this.graphicsView.graphicUpdateHandler(e9);
    }
  }
  whenReady() {
    return new Promise((e9) => {
      this.ready ? e9(this) : this._resolveWhenReady.push(e9);
    });
  }
  forceDOMReadyCycle() {
    this.forceReadyCycle();
  }
  getDefaultSpatialReference() {
    var _a, _b, _c;
    return this.map && "initialViewProperties" in this.map && ((_b = (_a = this.map) == null ? void 0 : _a.initialViewProperties) == null ? void 0 : _b.spatialReference) || ((_c = this.defaultsFromMap) == null ? void 0 : _c.spatialReference) || null;
  }
  hasLayerViewModule(e9) {
    return n6.hasLayerViewModule(e9);
  }
  importLayerView(e9) {
    return n6.importLayerView(e9);
  }
  pixelSizeAt() {
    return this.ready ? this.state.resolution : (he.error("#pixelSizeAt()", "Map view cannot be used before it is ready"), null);
  }
  popupHitTest(e9) {
    return this.hitTest(e9).then((t11) => ({ ...t11, mapPoint: this.toMap(e9) }));
  }
  requestUpdate() {
    this.ready && this.frameTask.requestUpdate();
  }
  validate() {
    let e9 = i3(this.type);
    return a("safari") && a("safari") < 9 && (e9 = new s2("mapview:browser-not-supported", "This browser is not supported by MapView (Safari < 9)", { type: "safari", requiredVersion: 9, detectedVersion: a("safari") })), r(e9) ? (he.warn("#validate()", e9.message), Promise.reject(e9)) : ye();
  }
  _createAnimation() {
    return this.animation && !this.animation.done || (this.animation = new n4()), this.animation;
  }
  _cancellableGoTo(e9, t11, i9) {
    const s11 = () => e9 === this._gotoTask, r7 = i9.then(() => {
      s11() && (this.animation = null);
    }).catch((e10) => {
      throw s11() && (this.animation = null, t11.done || (t11.stop(), this.frameTask.animationInProgress = false)), e10;
    }), n9 = new Promise((e10) => e10(r7));
    return t11.when().catch(() => {
      s11() && n9.cancel && n9.cancel();
    }), n9;
  }
  _gotoImmediate(e9, t11) {
    const i9 = this._gotoTask, s11 = this.animation, r7 = e9.then((e10) => {
      if (f(t11), i9 !== this._gotoTask)
        throw new s2("view:goto-interrupted", "Goto was interrupted");
      this.viewpoint = s11.target = e10, s11.finish();
    });
    return this._cancellableGoTo(i9, s11, r7);
  }
  _flipStationary(e9) {
    return null !== this._stationaryTimer || (this._stationaryTimer = setTimeout(() => {
      this._stationaryTimer = null;
      const e10 = performance.now() - this._lastStationaryEventTimestamp;
      e10 < we && (this._stationaryTimer = this._flipStationary(e10));
    }, e9)), this._stationaryTimer;
  }
  _getDefaultViewpoint() {
    var _a, _b, _c, _d;
    const { constraints: e9, initialExtent: t11, map: s11, padding: r7, size: n9 } = this;
    if (!e9)
      return null;
    const a10 = s11 && "initialViewProperties" in s11 && s11.initialViewProperties, o9 = { zoom: this._get("zoom"), scale: this._get("scale"), center: this._get("center"), extent: this._get("extent"), rotation: this._get("rotation"), viewpoint: this._get("viewpoint"), spatialReference: this._userSpatialReference };
    e9.effectiveLODs ? -1 !== o9.zoom && (o9.scale = e9.zoomToScale(o9.zoom)) : o9.zoom = -1;
    let l8 = null, c9 = null, d4 = 0;
    const u6 = o9.viewpoint && o9.viewpoint.rotation, m6 = o9.viewpoint && o9.viewpoint.targetGeometry;
    r(m6) && ("extent" === m6.type ? l8 = m6 : "point" === m6.type && (c9 = m6, d4 = o9.viewpoint.scale));
    const g5 = o9.extent || l8 || ((_b = e2((_a = a10 == null ? void 0 : a10.viewpoint) == null ? void 0 : _a.targetGeometry)) == null ? void 0 : _b.extent) || t11, f3 = o9.center || c9 || (g5 == null ? void 0 : g5.center), y4 = o9.scale || d4 || ((_c = a10 == null ? void 0 : a10.viewpoint) == null ? void 0 : _c.scale) || g5 && H(g5, [n9[0] - r7.left - r7.right, n9[1] - r7.top - r7.bottom]), w5 = o9.rotation || u6 || ((_d = a10 == null ? void 0 : a10.viewpoint) == null ? void 0 : _d.rotation) || 0;
    return f3 && y4 ? new u2({ targetGeometry: f3, scale: y4, rotation: w5 }) : null;
  }
  _gotoAnimated(e9, t11) {
    const i9 = this._gotoTask, s11 = this.animation, r7 = e9.then((e10) => {
      if (f(t11), i9 !== this._gotoTask)
        throw new s2("view:goto-interrupted", "Goto was interrupted");
      return s11.update(e10), this.animationManager.animate(s11, this.viewpoint, t11), s11.when().then(() => {
      }, () => {
      });
    });
    return this._cancellableGoTo(i9, s11, r7);
  }
  _project(e9, t11) {
    var _a;
    const i9 = e9 && e9.targetGeometry || e9;
    if (!t11)
      return e9;
    if (!i9)
      return null;
    if (t11.imageCoordinateSystem || ((_a = i9.spatialReference) == null ? void 0 : _a.imageCoordinateSystem))
      return e9;
    if (E(t11, i9.spatialReference))
      return e9;
    const s11 = rn(i9, t11);
    if (!s11)
      throw new s2("mapview:projection-not-possible", "projecting input geometry to target spatial reference returned a null value", { geometry: i9, spatialReference: t11 });
    return _e(e9) ? (e9.targetGeometry = s11, e9) : s11;
  }
  _resizeHandler(e9) {
    if (!this.ready)
      return;
    const t11 = this.state;
    let i9 = this.state.paddedViewState.viewpoint;
    const s11 = this.state.paddedViewState.size.concat();
    t11.size = [e9.width, e9.height], ht(i9, i9, s11, this.state.paddedViewState.size, this.resizeAlign), i9 = this.constraints.constrain(i9, null), this.state.viewpoint = i9;
  }
  _startup() {
    var _a, _b;
    this.timeline.begin("MapView Startup");
    const e9 = this._getDefaultViewpoint(), t11 = e9.targetGeometry;
    try {
      this._project(e9, this.spatialReference);
    } catch (o9) {
      he.warn(new t4("mapview:startup-projection-error", "projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.", { center: t11.toJSON(), spatialReference: this.spatialReference, error: o9 })), e9.targetGeometry = ((_a = this.defaultsFromMap.extent) == null ? void 0 : _a.center) || new j({ x: 0, y: 0, spatialReference: this.spatialReference });
    }
    (_b = this.constraints) == null ? void 0 : _b.fit(e9), this._set("state", new g4({ padding: this._get("padding"), size: this.size, viewpoint: e9 })), this.graphics.owner = this;
    const i9 = new ce(this.surface, { canvas: this.renderCanvas, supersampleScreenshots: this.supersampleScreenshotsEnabled, contextOptions: { disabledExtensions: this.deactivatedWebGLExtensions, debugWebGLExtensions: this.debugWebGLExtensions }, renderingOptions: this.renderingOptions, timeline: this.timeline });
    this._stage = i9, this._magnifierView = new fe(), this._magnifierView.magnifier = this.magnifier;
    const s11 = new me({ view: this });
    this._set("labelManager", s11);
    const r7 = new d2({ view: this });
    this._set("animationManager", r7);
    const n9 = new ge({ view: this, animationManager: r7 });
    this._set("mapViewNavigation", n9), this._setupSpatialReferenceDependentProperties(), this.handles.add([this.rootLayerViews.on("change", () => this._updateStageChildren()), i9.on("post-render", () => this._set("rendering", i9.renderRequested)), i9.on("will-render", () => this._set("rendering", i9.renderRequested)), i9.on("webgl-error", (e10) => this.fatalError = e10.error), l2(() => this.stationary, (e10) => i9.stationary = e10, w), l2(() => this.background, (e10) => {
      i9.background = e10, this._magnifierView.background = e10;
    }, w), l2(() => this.magnifier, (e10) => this._magnifierView.magnifier = e10, w), l2(() => this.renderingOptions, (e10) => i9.renderingOptions = e10, w), l2(() => this.highlightOptions, (e10) => i9.highlightOptions = e10, w), l2(() => this.state.id, () => i9.state = this.state, w)], "map-view"), this._updateStageChildren();
    const a10 = this._resolveWhenReady;
    this._resolveWhenReady = [], a10.forEach((e10) => e10(this)), this.timeline.end("MapView Startup"), this.frameTask && this.frameTask.start(), this._set("ready", true);
  }
  _teardown() {
    this._destroySpatialReferenceDependentProperties(), this.handles.remove("map-view"), this.mapViewNavigation.destroy(), this._set("mapViewNavigation", null), this.animationManager.destroy(), this._set("animationManager", null), this.layerViewManager.clear(), this.labelManager.destroy(), this._magnifierView.destroy(), this._stage.destroy(), this._stage = null, this._set("graphicsView", null), this._magnifierView = null, this._set("labelManager", null), this._set("mapViewNavigation", null), this.graphics.owner = null, this.frameTask && this.frameTask.stop(), this._stationaryTimer && (clearTimeout(this._stationaryTimer), this._stationaryTimer = null), this._set("ready", false);
    const { center: [e9, t11], spatialReference: i9, rotation: s11, scale: r7 } = this.state.paddedViewState, n9 = new j({ x: e9, y: t11, spatialReference: i9 });
    this._set("viewpoint", null), this._set("extent", null), this._set("center", n9), this._set("zoom", -1), this._set("rotation", s11), this._set("scale", r7), this._set("spatialReference", i9), this._set("state", null), this.animation = null;
  }
  _updateStageChildren() {
    this._stage.removeAllChildren(), this.rootLayerViews.forEach((e10) => {
      this._stage.addChild(e10.container);
    });
    const e9 = this.graphicsView;
    this._stage.addChild(e9.container), this._stage.addChild(this._magnifierView);
  }
  _setupSpatialReferenceDependentProperties() {
    const e9 = new h2(S.create({ spatialReference: this.spatialReference, size: 512, numLODs: 36 }));
    this._set("featuresTilingScheme", e9);
    const t11 = new de({ view: this, graphics: this.graphics, requestUpdateCallback: () => this.requestUpdate(), container: new ue(e9) });
    this.frameTask.graphicsView = t11, this._set("graphicsView", t11);
  }
  _destroySpatialReferenceDependentProperties() {
    const e9 = this.graphicsView;
    this._set("graphicsView", null), this.frameTask.graphicsView = null, e9.destroy(), this._set("featuresTilingScheme", null);
  }
  _spatialReferenceChanged(e9) {
    if (!this.ready)
      return;
    this.frameTask.stop();
    for (const i9 of this.allLayerViews)
      i9.processDetach();
    this._destroySpatialReferenceDependentProperties();
    const t11 = this.state.paddedViewState.clone();
    if (t(this._scaleBeforeChangingSpatialReference))
      this._scaleBeforeChangingSpatialReference = t11.scale;
    else {
      const e10 = t11.viewpoint.clone();
      e10.scale = this._scaleBeforeChangingSpatialReference, t11.viewpoint = e10;
    }
    const s11 = t11.clone(), [r7, n9] = t11.center;
    let o9 = null;
    try {
      o9 = this._project(new j({ x: r7, y: n9, spatialReference: t11.spatialReference }), e9);
    } catch (p8) {
      en() || he.warn(new t4("mapview:spatial-reference-change", "could not project the view's center to the new spatial reference", { center: o9.toJSON(), spatialReference: e9, error: p8 }));
    }
    o9 || (o9 = new j({ x: 0, y: 0, spatialReference: e9 }));
    const l8 = xt(new u2({ targetGeometry: new j(), scale: 0, rotation: 0 }), t11.viewpoint, o9);
    s11.viewpoint = l8;
    try {
      const i9 = 20, r8 = [t11.size[0] / 2, t11.size[1] / 2], n10 = [r8[0] + i9, r8[1]], o10 = t11.toMap([0, 0], n10), { x: p8, y: h3 } = this._project(new j({ x: o10[0], y: o10[1], spatialReference: t11.spatialReference }), e9);
      o10[0] = p8, o10[1] = h3, s11.toScreen(o10, o10);
      const c9 = pt(r8, o10, n10), d4 = Math.hypot(o10[0] - r8[0], o10[1] - r8[1]) / i9;
      !Number.isFinite(d4) || Math.abs(d4) > 4 ? (l8.rotation = 0, l8.targetGeometry = new j({ x: 0, y: 0, spatialReference: e9 })) : (l8.scale *= d4, l8.scale > a("mapview-srswitch-adjust-rotation-scale-threshold") ? l8.rotation = 0 : l8.rotation += Number.isFinite(c9) ? c9 : 0);
    } catch {
    }
    this._get("constraints").constrain(l8, null), this._get("state").viewpoint = l8, this._stage.state = this.state, this._setupSpatialReferenceDependentProperties();
    for (const i9 of this.allLayerViews)
      i9.processAttach();
    this.frameTask.requestFrame(), this.frameTask.start(), this._updateStageChildren();
  }
};
ve.type = "2d", e([d({ readOnly: true })], ve.prototype, "animationManager", void 0), e([d({ constructOnly: true })], ve.prototype, "deactivatedWebGLExtensions", void 0), e([d({ constructOnly: true })], ve.prototype, "debugWebGLExtensions", void 0), e([d({ readOnly: true })], ve.prototype, "featuresTilingScheme", void 0), e([d({ readOnly: true })], ve.prototype, "fullOpacity", void 0), e([d({ readOnly: true })], ve.prototype, "graphicsTileStore", null), e([d()], ve.prototype, "graphicsView", void 0), e([d({ readOnly: true })], ve.prototype, "state", void 0), e([d()], ve.prototype, "initialExtentRequired", null), e([d()], ve.prototype, "labelManager", void 0), e([d({ readOnly: true })], ve.prototype, "resourceManager", null), e([d({ readOnly: true })], ve.prototype, "textureManager", null), e([d({ readOnly: true })], ve.prototype, "mapViewNavigation", void 0), e([d({ constructOnly: true })], ve.prototype, "renderCanvas", void 0), e([d()], ve.prototype, "renderingOptions", void 0), e([d({ readOnly: true })], ve.prototype, "rendering", void 0), e([d({ constructOnly: true })], ve.prototype, "supersampleScreenshotsEnabled", void 0), e([d({ readOnly: true })], ve.prototype, "supportsGround", void 0), e([d()], ve.prototype, "_stationaryTimer", void 0), e([d()], ve.prototype, "_defaultsFromMapSettings", null), e([d()], ve.prototype, "_pePromise", void 0), e([d({ readOnly: true })], ve.prototype, "typeSpecificPreconditionsReady", null), e([d()], ve.prototype, "animation", null), e([d({ type: m2 })], ve.prototype, "background", null), e([d({ value: null, type: j, dependsOn: ["state.id", "ready"] })], ve.prototype, "center", null), e([d({ type: y3 })], ve.prototype, "constraints", null), e([d({ value: null, type: M, dependsOn: ["state.id", "ready"] })], ve.prototype, "extent", null), e([d()], ve.prototype, "floors", void 0), e([d({ type: c8 })], ve.prototype, "highlightOptions", void 0), e([d({ readOnly: true })], ve.prototype, "inputManager", void 0), e([d()], ve.prototype, "map", void 0), e([d({ value: { top: 0, right: 0, bottom: 0, left: 0 }, cast: (e9) => ({ top: 0, right: 0, bottom: 0, left: 0, ...e9 }) })], ve.prototype, "padding", null), e([d()], ve.prototype, "resizeAlign", void 0), e([d({ readOnly: true, dependsOn: ["state.id"] })], ve.prototype, "resolution", null), e([d({ value: 0, type: Number, dependsOn: ["state.id", "ready"] })], ve.prototype, "rotation", null), e([d({ value: 0, type: Number, dependsOn: ["state.id", "ready"] })], ve.prototype, "scale", null), e([d({ constructOnly: true })], ve.prototype, "spatialReferenceLocked", void 0), e([d()], ve.prototype, "stationary", null), e([d({ type: e3, readOnly: true })], ve.prototype, "timeline", void 0), e([d({ readOnly: true })], ve.prototype, "type", void 0), e([d({ readOnly: true })], ve.prototype, "updating", null), e([d({ value: null, type: u2, dependsOn: ["state.id", "ready"] })], ve.prototype, "viewpoint", null), e([d({ value: -1, dependsOn: ["state.id", "ready"] })], ve.prototype, "zoom", null), e([d({ type: Boolean })], ve.prototype, "navigating", null), e([d({ type: p7 })], ve.prototype, "ui", void 0), ve = e([n2("esri.views.MapView")], ve);
var Ve = ve;
function Se(e9) {
  var _a, _b;
  const t11 = e9.getObjectId();
  return t11 ? `${((_a = e9.layer) == null ? void 0 : _a.uid) ?? ((_b = e9.sourceLayer) == null ? void 0 : _b.uid) ?? "MapView"}/${t11}` : `"MapView/${e9.uid}`;
}
function je(e9, i9, s11, r7, n9) {
  return (a10) => {
    if (a10 instanceof g) {
      if (a10.layer === e9)
        n9 == null ? void 0 : n9();
      else {
        const t11 = e9.allLayerViews.find((e10) => e10.layer === a10.layer);
        t11 && (r7 == null ? void 0 : r7(t11));
      }
      s11(Se(a10));
    } else {
      const t11 = e9.allLayerViews.find((e10) => e10.layer === a10);
      t11 && i9(t11);
    }
  };
}
function Te(e9, t11) {
  if (e9)
    if (t2(e9))
      for (const i9 of e9)
        if (t2(i9))
          for (const e10 of i9)
            t11(e10);
        else
          t11(i9);
    else
      t11(e9);
}
export {
  Ve as default
};
//# sourceMappingURL=@arcgis_core_views_MapView.js.map
