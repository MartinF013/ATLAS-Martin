import {
  L as L3,
  V
} from "./chunk-TCYVDK2B.js";
import {
  p as p2
} from "./chunk-2DP653N7.js";
import {
  B,
  d as d3,
  g2,
  p
} from "./chunk-7OZR6JFF.js";
import {
  e as e6,
  o as o6,
  t
} from "./chunk-NXOQBIK7.js";
import {
  E as E4
} from "./chunk-ERNXFM5T.js";
import {
  i
} from "./chunk-6ITXWFMK.js";
import {
  e as e7
} from "./chunk-SV4VP57N.js";
import {
  E as E3
} from "./chunk-5EXPMKQP.js";
import {
  W,
  a as a3,
  c as c2,
  s as s2
} from "./chunk-B7F3T673.js";
import {
  h as h2,
  o as o4
} from "./chunk-TTKSAULB.js";
import {
  o as o3
} from "./chunk-TEJEYVH4.js";
import {
  g
} from "./chunk-EYJ2F5XB.js";
import {
  T
} from "./chunk-3DCTMZI6.js";
import {
  E,
  I,
  R
} from "./chunk-FPMD6IB4.js";
import {
  L as L2,
  d,
  d2,
  f,
  h as h3,
  o as o5
} from "./chunk-EEJIELE6.js";
import {
  E as E2,
  u as u3
} from "./chunk-Y55TYMBP.js";
import {
  O as O3
} from "./chunk-MDCKEJ7B.js";
import {
  O as O2
} from "./chunk-VMF4NMEB.js";
import {
  e as e5
} from "./chunk-NAIF4GWX.js";
import {
  e as e4
} from "./chunk-YFBAFAZ2.js";
import {
  e as e3
} from "./chunk-LUU3J646.js";
import {
  a as a2
} from "./chunk-3NPGGTI6.js";
import {
  a
} from "./chunk-YZNDHJDJ.js";
import {
  l
} from "./chunk-ZN2MGN4S.js";
import {
  n as n3,
  r as r4
} from "./chunk-RTHP2LNT.js";
import {
  n as n2
} from "./chunk-U7B2WKBH.js";
import {
  h
} from "./chunk-ASC3X65B.js";
import {
  u as u2
} from "./chunk-56RHM4A6.js";
import {
  o as o2
} from "./chunk-BPZGJQOB.js";
import {
  L,
  O,
  P,
  e as e2,
  o,
  q,
  r as r3,
  s,
  u,
  x,
  z
} from "./chunk-PKZEO23A.js";
import {
  n,
  r as r2
} from "./chunk-AIRC226G.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  c,
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/core/libs/gl-matrix-2/types/mat4.js
function n4(n5) {
  return n5 instanceof Float32Array && n5.length >= 16;
}
function r5(n5) {
  return Array.isArray(n5) && n5.length >= 16;
}
function t2(t3) {
  return n4(t3) || r5(t3);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HUDMaterialTechnique.js
var g3 = class extends e6 {
  initializeConfiguration(e8, i2) {
    i2.spherical = e8.viewingMode === l.Global;
  }
  initializeProgram(t3) {
    const e8 = g3.shader.get().build(this.configuration);
    return new o6(t3.rctx, e8, E2);
  }
  _setPipelineState(t3) {
    const i2 = this.configuration, r6 = t3 === O3.NONE, n5 = t3 === O3.FrontFace, a4 = this.configuration.hasPolygonOffset && b, l2 = (r6 || n5) && i2.output !== o3.Highlight ? (i2.depthEnabled || i2.output === o3.Occlusion) && a3 : null;
    return W({ blending: i2.output === o3.Color || i2.output === o3.Alpha || i2.output === o3.Highlight ? r6 ? j : E3(t3) : null, depthTest: { func: I.LEQUAL }, depthWrite: l2, colorWrite: c2, polygonOffset: a4 });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
  get primitiveType() {
    return this.configuration.output === o3.Occlusion ? E.POINTS : E.TRIANGLES;
  }
};
g3.shader = new t(V, () => import("./HUDMaterial.glsl-BJZY3KBL.js"));
var b = { factor: 0, units: -4 };
var j = s2(R.ONE, R.ONE_MINUS_SRC_ALPHA);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HUDMaterialTechniqueConfiguration.js
var p3 = class extends i {
  constructor() {
    super(...arguments), this.output = o3.Color, this.screenCenterOffsetUnitsEnabled = p2.World, this.transparencyPassType = O3.NONE, this.spherical = false, this.occlusionTestEnabled = true, this.signedDistanceFieldEnabled = false, this.vvSize = false, this.vvColor = false, this.hasVerticalOffset = false, this.hasScreenSizePerspective = false, this.debugDrawLabelBorder = false, this.binaryHighlightOcclusionEnabled = true, this.hasSlicePlane = false, this.hasPolygonOffset = false, this.depthEnabled = true, this.pixelSnappingEnabled = true, this.isDraped = false, this.hasMultipassGeometry = false, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([e7({ count: o3.COUNT })], p3.prototype, "output", void 0), e([e7({ count: p2.COUNT })], p3.prototype, "screenCenterOffsetUnitsEnabled", void 0), e([e7({ count: O3.COUNT })], p3.prototype, "transparencyPassType", void 0), e([e7()], p3.prototype, "spherical", void 0), e([e7()], p3.prototype, "occlusionTestEnabled", void 0), e([e7()], p3.prototype, "signedDistanceFieldEnabled", void 0), e([e7()], p3.prototype, "vvSize", void 0), e([e7()], p3.prototype, "vvColor", void 0), e([e7()], p3.prototype, "hasVerticalOffset", void 0), e([e7()], p3.prototype, "hasScreenSizePerspective", void 0), e([e7()], p3.prototype, "debugDrawLabelBorder", void 0), e([e7()], p3.prototype, "binaryHighlightOcclusionEnabled", void 0), e([e7()], p3.prototype, "hasSlicePlane", void 0), e([e7()], p3.prototype, "hasPolygonOffset", void 0), e([e7()], p3.prototype, "depthEnabled", void 0), e([e7()], p3.prototype, "pixelSnappingEnabled", void 0), e([e7()], p3.prototype, "isDraped", void 0), e([e7()], p3.prototype, "hasMultipassGeometry", void 0), e([e7()], p3.prototype, "hasMultipassTerrain", void 0), e([e7()], p3.prototype, "cullAboveGround", void 0), e([e7({ constValue: true })], p3.prototype, "hasSliceInVertexProgram", void 0), e([e7({ constValue: false })], p3.prototype, "hasVvInstancing", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/HUDMaterial.js
var J = class extends d2 {
  constructor(e8) {
    super(e8, new Se()), this.techniqueConfig = new p3();
  }
  getConfiguration(e8, t3) {
    return this.techniqueConfig.output = e8, this.techniqueConfig.hasSlicePlane = this.parameters.hasSlicePlane, this.techniqueConfig.hasVerticalOffset = !!this.parameters.verticalOffset, this.techniqueConfig.hasScreenSizePerspective = !!this.parameters.screenSizePerspective, this.techniqueConfig.screenCenterOffsetUnitsEnabled = "screen" === this.parameters.centerOffsetUnits ? p2.Screen : p2.World, this.techniqueConfig.hasPolygonOffset = this.parameters.polygonOffset, this.techniqueConfig.isDraped = this.parameters.isDraped, this.techniqueConfig.occlusionTestEnabled = this.parameters.occlusionTest, this.techniqueConfig.pixelSnappingEnabled = this.parameters.pixelSnappingEnabled, this.techniqueConfig.signedDistanceFieldEnabled = this.parameters.textureIsSignedDistanceField, this.techniqueConfig.vvSize = !!this.parameters.vvSizeEnabled, this.techniqueConfig.vvColor = !!this.parameters.vvColorEnabled, e8 === o3.Color && (this.techniqueConfig.debugDrawLabelBorder = !!this.parameters.debugDrawLabelBorder), e8 === o3.Highlight && (this.techniqueConfig.binaryHighlightOcclusionEnabled = this.parameters.binaryHighlightOcclusion), this.techniqueConfig.depthEnabled = this.parameters.depthEnabled, this.techniqueConfig.transparencyPassType = t3.transparencyPassType, this.techniqueConfig.hasMultipassGeometry = t3.multipassGeometry.enabled, this.techniqueConfig.hasMultipassTerrain = t3.multipassTerrain.enabled, this.techniqueConfig.cullAboveGround = t3.multipassTerrain.cullAboveGround, this.techniqueConfig;
  }
  intersect(e8, s3, i2, r6, n5, a4, o7, c3, l2) {
    r(l2) ? this._intersectDrapedHudGeometry(e8, a4, o7, c3, l2) : this._intersectHudGeometry(e8, s3, i2, r6, o7, c3);
  }
  _intersectDrapedHudGeometry(e8, s3, i2, r6, n5) {
    const a4 = e8.vertexAttributes.get(O2.POSITION), o7 = e8.vertexAttributes.get(O2.SIZE), c3 = this.parameters, l2 = L3(c3);
    let f2 = 1, h4 = 1;
    if (r(r6)) {
      const e9 = r6(pe);
      f2 = e9[0], h4 = e9[5];
    }
    f2 *= e8.screenToWorldRatio, h4 *= e8.screenToWorldRatio;
    const u4 = de * e8.screenToWorldRatio;
    for (let t3 = 0; t3 < a4.data.length / a4.size; t3++) {
      const r7 = t3 * a4.size, p4 = a4.data[r7], m = a4.data[r7 + 1], d4 = t3 * o7.size;
      let g4;
      ge[0] = o7.data[d4] * f2, ge[1] = o7.data[d4 + 1] * h4, c3.textureIsSignedDistanceField && (g4 = c3.outlineSize * e8.screenToWorldRatio / 2), ee(s3, p4, m, ge, u4, g4, c3, l2) && i2(n5.dist, n5.normal, -1, false);
    }
  }
  _intersectHudGeometry(e8, s3, r6, a4, o7, c3) {
    if (!a4.options.selectionMode || !a4.options.hud || u3(s3))
      return;
    const l2 = this.parameters;
    let S = 1, v = 1;
    if (a2(ce, r6), r(c3)) {
      const e9 = c3(pe);
      S = e9[0], v = e9[5], $(ce);
    }
    const A = e8.vertexAttributes.get(O2.POSITION), b2 = e8.vertexAttributes.get(O2.SIZE), x2 = e8.vertexAttributes.get(O2.NORMAL), C = e8.vertexAttributes.get(O2.AUXPOS1);
    e5(A.size >= 3);
    const y = a4.point, I2 = a4.camera, z2 = L3(l2);
    S *= I2.pixelRatio, v *= I2.pixelRatio;
    const T2 = "screen" === this.parameters.centerOffsetUnits;
    for (let t3 = 0; t3 < A.data.length / A.size; t3++) {
      const e9 = t3 * A.size;
      o(ie, A.data[e9], A.data[e9 + 1], A.data[e9 + 2]), L(ie, ie, r6);
      const s4 = t3 * b2.size;
      ge[0] = b2.data[s4] * S, ge[1] = b2.data[s4 + 1] * v, L(ie, ie, I2.viewMatrix);
      const i2 = t3 * C.size;
      if (o(he, C.data[i2 + 0], C.data[i2 + 1], C.data[i2 + 2]), !T2 && (ie[0] += he[0], ie[1] += he[1], 0 !== he[2])) {
        const e10 = he[2];
        z(he, ie), e2(ie, ie, q(he, he, e10));
      }
      const c4 = t3 * x2.size;
      if (o(re, x2.data[c4], x2.data[c4 + 1], x2.data[c4 + 2]), this._normalAndViewAngle(re, ce, I2, ue), this._applyVerticalOffsetTransformationView(ie, ue, I2, te), I2.applyProjection(ie, ne), ne[0] > -1) {
        ne[0] = Math.floor(ne[0]), ne[1] = Math.floor(ne[1]), T2 && (he[0] || he[1]) && (ne[0] += he[0], 0 !== he[1] && (ne[1] += o5(he[1], te.factorAlignment)), I2.unapplyProjection(ne, ie)), ne[0] += this.parameters.screenOffset[0], ne[1] += this.parameters.screenOffset[1], f(ge, te.factor, ge);
        const e10 = me * I2.pixelRatio;
        let t4;
        if (l2.textureIsSignedDistanceField && (t4 = l2.outlineSize * I2.pixelRatio / 2), ee(y, ne[0], ne[1], ge, e10, t4, l2, z2)) {
          const e11 = a4.ray;
          if (L(oe, ie, h(fe, I2.viewMatrix)), ne[0] = y[0], ne[1] = y[1], I2.unprojectFromRenderScreen(ne, ie)) {
            const t5 = n();
            r3(t5, e11.direction);
            const s5 = 1 / s(t5);
            q(t5, t5, s5);
            o7(x(e11.origin, ie) * s5, t5, -1, true, 1, oe);
          }
        }
      }
    }
  }
  computeAttachmentOrigin(e8, t3) {
    const s3 = e8.vertexAttributes;
    if (!s3)
      return false;
    const i2 = s3.get(O2.POSITION), r6 = e8.indices.get(O2.POSITION);
    return g(i2, r6, t3);
  }
  createBufferWriter() {
    return new Ae(this);
  }
  _normalAndViewAngle(e8, t3, s3, r6) {
    return t2(t3) && (t3 = a2(le, t3)), O(r6.normal, e8, t3), L(r6.normal, r6.normal, s3.viewInverseTransposeMatrix), r6.cosAngle = P(ae, Oe), r6;
  }
  _updateScaleInfo(e8, s3, i2) {
    const r6 = this.parameters;
    r(r6.screenSizePerspective) ? d(i2, s3, r6.screenSizePerspective, e8.factor) : (e8.factor.scale = 1, e8.factor.factor = 0, e8.factor.minPixelSize = 0, e8.factor.paddingPixels = 0), r(r6.screenSizePerspectiveAlignment) ? d(i2, s3, r6.screenSizePerspectiveAlignment, e8.factorAlignment) : (e8.factorAlignment.factor = e8.factor.factor, e8.factorAlignment.scale = e8.factor.scale, e8.factorAlignment.minPixelSize = e8.factor.minPixelSize, e8.factorAlignment.paddingPixels = e8.factor.paddingPixels);
  }
  applyShaderOffsetsView(e8, t3, s3, i2, r6, n5, a4) {
    const o7 = this._normalAndViewAngle(t3, s3, r6, ue);
    return this._applyVerticalGroundOffsetView(e8, o7, r6, a4), this._applyVerticalOffsetTransformationView(a4, o7, r6, n5), this._applyPolygonOffsetView(a4, o7, i2[3], r6, a4), this._applyCenterOffsetView(a4, i2, a4), a4;
  }
  applyShaderOffsetsNDC(e8, s3, i2, r6, n5) {
    return this._applyCenterOffsetNDC(e8, s3, i2, r6), r(n5) && r3(n5, r6), this._applyPolygonOffsetNDC(r6, s3, i2, r6), r6;
  }
  _applyPolygonOffsetView(t3, s3, i2, r6, n5) {
    const a4 = r6.aboveGround ? 1 : -1;
    let o7 = Math.sign(i2);
    0 === o7 && (o7 = a4);
    const c3 = a4 * o7;
    if (this.parameters.shaderPolygonOffset <= 0)
      return r3(n5, t3);
    const l2 = o2(Math.abs(s3.cosAngle), 0.01, 1), f2 = 1 - Math.sqrt(1 - l2 * l2) / l2 / r6.viewport[2];
    return q(n5, t3, c3 > 0 ? f2 : 1 / f2), n5;
  }
  _applyVerticalGroundOffsetView(e8, t3, s3, i2) {
    const r6 = s(e8), n5 = s3.aboveGround ? 1 : -1, a4 = 0.5 * s3.computeRenderPixelSizeAtDist(r6), o7 = q(ie, t3.normal, n5 * a4);
    return u(i2, e8, o7), i2;
  }
  _applyVerticalOffsetTransformationView(e8, t3, i2, r6) {
    const n5 = this.parameters;
    if (!n5.verticalOffset || !n5.verticalOffset.screenLength) {
      if (n5.screenSizePerspective || n5.screenSizePerspectiveAlignment) {
        const s3 = s(e8);
        this._updateScaleInfo(r6, s3, t3.cosAngle);
      } else
        r6.factor.scale = 1, r6.factorAlignment.scale = 1;
      return e8;
    }
    const a4 = s(e8), o7 = c(n5.screenSizePerspectiveAlignment, n5.screenSizePerspective), c3 = L2(i2, a4, n5.verticalOffset, t3.cosAngle, o7);
    return this._updateScaleInfo(r6, a4, t3.cosAngle), q(t3.normal, t3.normal, c3), u(e8, e8, t3.normal);
  }
  _applyCenterOffsetView(e8, t3, s3) {
    const i2 = "screen" !== this.parameters.centerOffsetUnits;
    return s3 !== e8 && r3(s3, e8), i2 && (s3[0] += t3[0], s3[1] += t3[1], t3[2] && (z(re, s3), u(s3, s3, q(re, re, t3[2])))), s3;
  }
  _applyCenterOffsetNDC(e8, t3, s3, i2) {
    const r6 = "screen" !== this.parameters.centerOffsetUnits;
    return i2 !== e8 && r3(i2, e8), r6 || (i2[0] += t3[0] / s3.fullWidth * 2, i2[1] += t3[1] / s3.fullHeight * 2), i2;
  }
  _applyPolygonOffsetNDC(e8, t3, s3, i2) {
    const r6 = this.parameters.shaderPolygonOffset;
    if (e8 !== i2 && r3(i2, e8), r6) {
      const e9 = s3.aboveGround ? 1 : -1, n5 = e9 * Math.sign(t3[3]);
      i2[2] -= (n5 || e9) * r6;
    }
    return i2;
  }
  requiresSlot(e8) {
    if (e8 === E4.DRAPED_MATERIAL)
      return true;
    const { drawInSecondSlot: t3, occlusionTest: s3 } = this.parameters;
    return e8 === (t3 ? E4.LABEL_MATERIAL : E4.HUD_MATERIAL) || s3 && e8 === E4.OCCLUSION_PIXELS;
  }
  createGLMaterial(e8) {
    return e8.output === o3.Color || e8.output === o3.Alpha ? new Q(e8) : e8.output === o3.Highlight ? new K(e8) : null;
  }
  calculateRelativeScreenBounds(e8, t3, s3 = u2()) {
    return Y(this.parameters, e8, t3, s3), s3[2] = s3[0] + e8[0], s3[3] = s3[1] + e8[1], s3;
  }
};
var K = class extends h2 {
  constructor(e8) {
    super({ ...e8, ...e8.material.parameters });
  }
  selectProgram(e8) {
    return this.ensureTechnique(g3, e8);
  }
  beginSlot(e8) {
    return this.updateTexture(this._material.parameters.textureId), this._material.setParameters(this.textureBindParameters), this.selectProgram(e8);
  }
};
var Q = class extends K {
  _isOcclusionSlot(e8) {
    return e8.slot === E4.OCCLUSION_PIXELS && this._material.parameters.occlusionTest && (this._output === o3.Color || this._output === o3.Alpha);
  }
  selectProgram(e8) {
    return this.ensureTechnique(g3, e8, this._isOcclusionSlot(e8) ? o3.Occlusion : this._output);
  }
};
function Y(e8, t3, s3, i2 = se) {
  return a(i2, e8.anchorPosition), i2[0] *= -t3[0], i2[1] *= -t3[1], i2[0] += e8.screenOffset[0] * s3, i2[1] += e8.screenOffset[1] * s3, i2;
}
function $(e8) {
  const t3 = e8[0], s3 = e8[1], i2 = e8[2], r6 = e8[3], n5 = e8[4], a4 = e8[5], o7 = e8[6], c3 = e8[7], l2 = e8[8], f2 = 1 / Math.sqrt(t3 * t3 + s3 * s3 + i2 * i2), h4 = 1 / Math.sqrt(r6 * r6 + n5 * n5 + a4 * a4), u4 = 1 / Math.sqrt(o7 * o7 + c3 * c3 + l2 * l2);
  return e8[0] = t3 * f2, e8[1] = s3 * f2, e8[2] = i2 * f2, e8[3] = r6 * h4, e8[4] = n5 * h4, e8[5] = a4 * h4, e8[6] = o7 * u4, e8[7] = c3 * u4, e8[8] = l2 * u4, e8;
}
function ee(e8, s3, i2, r6, n5, a4, o7, c3) {
  let l2 = s3 - n5 - (c3[0] > 0 ? r6[0] * c3[0] : 0), f2 = l2 + r6[0] + 2 * n5, h4 = i2 - n5 - (c3[1] > 0 ? r6[1] * c3[1] : 0), u4 = h4 + r6[1] + 2 * n5;
  const p4 = o7.distanceFieldBoundingBox;
  return o7.textureIsSignedDistanceField && r(p4) && (l2 += r6[0] * p4[0], h4 += r6[1] * p4[1], f2 -= r6[0] * (1 - p4[2]), u4 -= r6[1] * (1 - p4[3]), l2 -= a4, f2 += a4, h4 -= a4, u4 += a4), e8[0] > l2 && e8[0] < f2 && e8[1] > h4 && e8[1] < u4;
}
var te = { factor: { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 }, factorAlignment: { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 } };
var se = n3();
var ie = n();
var re = n();
var ne = n2();
var ae = n();
var oe = n();
var ce = e3();
var le = e3();
var fe = e4();
var he = n();
var ue = { normal: ae, cosAngle: 0 };
var pe = e4();
var me = 1;
var de = 2;
var ge = [0, 0];
var Oe = r2(0, 0, 1);
var Se = class extends o4 {
  constructor() {
    super(...arguments), this.renderOccluded = h3.Occlude, this.color = [1, 1, 1, 1], this.texCoordScale = [1, 1], this.polygonOffset = false, this.anchorPosition = r4(0.5, 0.5), this.screenOffset = [0, 0], this.shaderPolygonOffset = 1e-5, this.textureIsSignedDistanceField = false, this.outlineColor = [1, 1, 1, 1], this.outlineSize = 0, this.vvSizeEnabled = false, this.vvSizeMinSize = [1, 1, 1], this.vvSizeMaxSize = [100, 100, 100], this.vvSizeOffset = [0, 0, 0], this.vvSizeFactor = [1, 1, 1], this.vvColorEnabled = false, this.vvColorValues = [0, 0, 0, 0, 0, 0, 0, 0], this.vvColorColors = [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], this.hasSlicePlane = false, this.pixelSnappingEnabled = true, this.occlusionTest = true, this.binaryHighlightOcclusion = true, this.debugDrawLabelBorder = false, this.centerOffsetUnits = "world", this.drawInSecondSlot = false, this.depthEnabled = true, this.isDraped = false;
  }
};
var ve = T().vec3f(O2.POSITION).vec3f(O2.NORMAL).vec2f(O2.UV0).vec4u8(O2.COLOR).vec2f(O2.SIZE).vec4f(O2.AUXPOS1).vec4f(O2.AUXPOS2);
var Ae = class {
  constructor(e8) {
    this.material = e8, this.vertexBufferLayout = ve;
  }
  allocate(e8) {
    return this.vertexBufferLayout.createBuffer(e8);
  }
  elementCount(e8) {
    return 6 * e8.indices.get(O2.POSITION).length;
  }
  write(e8, t3, s3, i2) {
    p(t3.indices.get(O2.POSITION), t3.vertexAttributes.get(O2.POSITION).data, e8.transformation, s3.position, i2, 6), B(t3.indices.get(O2.NORMAL), t3.vertexAttributes.get(O2.NORMAL).data, e8.invTranspTransformation, s3.normal, i2, 6);
    {
      const e9 = t3.vertexAttributes.get(O2.UV0).data;
      let r6, n5, a4, o7;
      if (null == e9 || e9.length < 4) {
        const e10 = this.material.parameters;
        r6 = 0, n5 = 0, a4 = e10.texCoordScale[0], o7 = e10.texCoordScale[1];
      } else
        r6 = e9[0], n5 = e9[1], a4 = e9[2], o7 = e9[3];
      a4 = Math.min(1.99999, a4 + 1), o7 = Math.min(1.99999, o7 + 1);
      const c3 = t3.indices.get(O2.POSITION).length, l2 = s3.uv0;
      let f2 = i2;
      for (let t4 = 0; t4 < c3; ++t4)
        l2.set(f2, 0, r6), l2.set(f2, 1, n5), f2 += 1, l2.set(f2, 0, a4), l2.set(f2, 1, n5), f2 += 1, l2.set(f2, 0, a4), l2.set(f2, 1, o7), f2 += 1, l2.set(f2, 0, a4), l2.set(f2, 1, o7), f2 += 1, l2.set(f2, 0, r6), l2.set(f2, 1, o7), f2 += 1, l2.set(f2, 0, r6), l2.set(f2, 1, n5), f2 += 1;
    }
    g2(t3.indices.get(O2.COLOR), t3.vertexAttributes.get(O2.COLOR).data, 4, s3.color, i2, 6);
    {
      const e9 = t3.indices.get(O2.SIZE), r6 = t3.vertexAttributes.get(O2.SIZE).data, n5 = e9.length, a4 = s3.size;
      let o7 = i2;
      for (let t4 = 0; t4 < n5; ++t4) {
        const s4 = r6[2 * e9[t4]], i3 = r6[2 * e9[t4] + 1];
        for (let e10 = 0; e10 < 6; ++e10)
          a4.set(o7, 0, s4), a4.set(o7, 1, i3), o7 += 1;
      }
    }
    t3.indices.get(O2.AUXPOS1) && t3.vertexAttributes.get(O2.AUXPOS1) && d3(t3.indices.get(O2.AUXPOS1), t3.vertexAttributes.get(O2.AUXPOS1).data, s3.auxpos1, i2, 6), t3.indices.get(O2.AUXPOS2) && t3.vertexAttributes.get(O2.AUXPOS2) && d3(t3.indices.get(O2.AUXPOS2), t3.vertexAttributes.get(O2.AUXPOS2).data, s3.auxpos2, i2, 6);
  }
};

export {
  J
};
//# sourceMappingURL=chunk-Y7MFFYJY.js.map
