import {
  E,
  l,
  l2,
  t as t2,
  x
} from "./chunk-6UTST6NO.js";
import "./chunk-BYHUWBKS.js";
import "./chunk-IEPHENP2.js";
import {
  n as n2
} from "./chunk-436X6OVY.js";
import "./chunk-XP3NTQW6.js";
import "./chunk-UJS24K6P.js";
import "./chunk-RB2H3SKO.js";
import "./chunk-UKBGUXUQ.js";
import "./chunk-AKNCAMEF.js";
import {
  p as p2
} from "./chunk-WL7AHHN3.js";
import "./chunk-UGLXR5OV.js";
import "./chunk-RGZ7VIMW.js";
import "./chunk-6FQZDXGD.js";
import "./chunk-4V2P7IXX.js";
import "./chunk-SF7Z6XNR.js";
import {
  p
} from "./chunk-TSYXLDAN.js";
import "./chunk-AKQ6VRGN.js";
import "./chunk-HH3D3A65.js";
import "./chunk-YDPQRKY4.js";
import "./chunk-AGO2OES3.js";
import "./chunk-ARI6FRU4.js";
import "./chunk-BBO6WYBO.js";
import "./chunk-TH2ECCFL.js";
import "./chunk-TCBD6DES.js";
import "./chunk-FR7M4UDR.js";
import "./chunk-G2GJVIQC.js";
import "./chunk-ZEIWFXXO.js";
import "./chunk-YXFNNKMT.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-33INAWJA.js";
import "./chunk-FPMD6IB4.js";
import "./chunk-S5PZEGLP.js";
import "./chunk-RIOXX6J2.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-PQO66WZ2.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-4P4OV7G6.js";
import "./chunk-ZUDEVIXR.js";
import "./chunk-IG4CY4XM.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-YL26MZEL.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import {
  a,
  m
} from "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-56RHM4A6.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  f as f2,
  g
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  e as e2,
  f,
  o,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/ResourceManagerProxy.js
var t3 = class {
  constructor(e3) {
    this._remoteClient = e3, this._resourceMap = /* @__PURE__ */ new Map(), this._inFlightResourceMap = /* @__PURE__ */ new Map(), this.geometryEngine = null;
  }
  destroy() {
  }
  async fetchResource(t4, r2) {
    const s2 = this._resourceMap, i = s2.get(t4);
    if (i)
      return i;
    let n3 = this._inFlightResourceMap.get(t4);
    if (n3)
      return n3;
    try {
      n3 = this._remoteClient.invoke("tileRenderer.fetchResource", { url: t4 }, { ...r2 }), this._inFlightResourceMap.set(t4, n3), n3.then((e3) => (this._inFlightResourceMap.delete(t4), s2.set(t4, e3), e3));
    } catch (o2) {
      return g(o2) ? null : { width: 0, height: 0 };
    }
    return n3;
  }
  getResource(e3) {
    return this._resourceMap.get(e3) ?? null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processors/SymbolProcessor.js
function I(e3, t4) {
  return (!e3.minScale || e3.minScale >= t4) && (!e3.maxScale || e3.maxScale <= t4);
}
function v(e3) {
  const t4 = e3.message, s2 = { message: { data: {}, tileKey: t4.tileKey, tileKeyOrigin: t4.tileKeyOrigin, version: t4.version }, transferList: new Array() };
  for (const i in t4.data) {
    const e4 = t4.data[i];
    if (s2.message.data[i] = null, r(e4)) {
      const t5 = e4.stride, a2 = e4.indices.slice(0), o2 = e4.vertices.slice(0), n3 = e4.records.slice(0), l3 = { stride: t5, indices: a2, vertices: o2, records: n3, metrics: o(e4.metrics, (e5) => e5.slice(0)) };
      s2.transferList.push(a2, o2, n3), s2.message.data[i] = l3;
    }
  }
  return s2;
}
s.getLogger("esri.views.2d.layers.features.processors.SymbolProcessor");
var M = class extends p {
  constructor() {
    super(...arguments), this.type = "symbol", this._matchers = { feature: null, aggregate: null }, this._bufferData = /* @__PURE__ */ new Map(), this._bufferIds = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.handles.add([this.tileStore.on("update", this.onTileUpdate.bind(this))]), this._resourceManagerProxy = new t3(this.remoteClient);
  }
  destroy() {
    this._resourceManagerProxy.destroy();
  }
  get supportsTileUpdates() {
    return true;
  }
  forEachBufferId(e3) {
    this._bufferIds.forEach((t4) => {
      t4.forEach(e3);
    });
  }
  async update(e3, t4) {
    const s2 = t4.schema.processors[0];
    if ("symbol" !== s2.type)
      return;
    const r2 = m(this._schema, s2);
    a(r2, "mesh") && (e3.mesh = true, e3.why.mesh.push("Symbology changed"), this._schema = s2, this._factory = this._createFactory(s2), this._factory.update(s2, this.tileStore.tileScheme.tileInfo));
  }
  onTileMessage(e3, t4, s2, r2) {
    return f2(r2), this._onTileData(e3, t4, s2, r2);
  }
  onTileClear(e3) {
    const t4 = { clear: true };
    return this._bufferData.delete(e3.key.id), this._bufferIds.delete(e3.key.id), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e3.id, data: t4 });
  }
  onTileError(e3, t4, s2) {
    const r2 = s2.signal, i = { tileKey: e3.id, error: t4 };
    return this.remoteClient.invoke("tileRenderer.onTileError", i, { signal: r2 });
  }
  onTileUpdate(e3) {
    for (const t4 of e3.removed)
      this._bufferData.has(t4.key.id) && this._bufferData.delete(t4.key.id), this._bufferIds.has(t4.key.id) && this._bufferIds.delete(t4.key.id);
    for (const t4 of e3.added)
      this._bufferData.forEach((e4) => {
        for (const s2 of e4)
          s2.message.tileKey === t4.id && this._updateTileMesh("append", t4, v(s2), [], false, false, null);
      });
  }
  _addBufferData(e3, t4) {
    this._bufferData.has(e3) || this._bufferData.set(e3, []), this._bufferData.get(e3).push(v(t4));
  }
  _createFactory(e3) {
    const { geometryType: t4, objectIdField: s2, fields: i } = this.service, a2 = (e4, t5) => this.remoteClient.invoke("tileRenderer.getMaterialItems", e4, t5), o2 = { geometryType: t4, fields: i, spatialReference: k.fromJSON(this.spatialReference) }, n3 = new x(a2, this.tileStore.tileScheme.tileInfo), { matcher: l3, aggregateMatcher: c } = e3.mesh;
    return this._store = n3, this._matchers.feature = l2(l3, n3, o2, this._resourceManagerProxy), this._matchers.aggregate = o(c, (e4) => l2(e4, n3, o2, this._resourceManagerProxy)), new l(t4, s2, n3);
  }
  async _onTileData(e3, t4, s2, r2) {
    f2(r2);
    const { type: o2, addOrUpdate: n3, remove: c } = t4, d = t4.end, h = !!this._schema.mesh.sortKey;
    if (!n3) {
      const t5 = { type: o2, addOrUpdate: null, remove: c, clear: false, end: d, sort: h };
      return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e3.id, data: t5 }, r2);
    }
    const f3 = this._processFeatures(e3, n3, s2, r2, t4.status.version);
    try {
      const s3 = await f3;
      if (t(s3)) {
        const t5 = { type: o2, addOrUpdate: null, remove: c, clear: false, end: d, sort: h };
        return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e3.id, data: t5 }, r2);
      }
      const n4 = [];
      for (const t5 of s3) {
        let s4 = false;
        const r3 = t5.message.bufferIds, i = e3.key.id, o3 = t5.message.tileKey;
        if (i !== o3 && r(r3)) {
          if (!this.tileStore.get(o3)) {
            this._addBufferData(i, t5), n4.push(t5);
            continue;
          }
          let e4 = this._bufferIds.get(o3);
          e4 || (e4 = /* @__PURE__ */ new Set(), this._bufferIds.set(o3, e4));
          const a2 = Array.from(r3);
          for (const t6 of a2) {
            if (e4.has(t6)) {
              s4 = true;
              break;
            }
            e4.add(t6);
          }
        }
        s4 || (this._addBufferData(i, t5), n4.push(t5));
      }
      await Promise.all(n4.map((s4) => {
        const i = e3.key.id === s4.message.tileKey, a2 = i ? t4.remove : [], n5 = i && t4.end;
        return this._updateTileMesh(o2, e3, s4, a2, n5, t4.clear, r2.signal);
      }));
    } catch (m2) {
      this._handleError(e3, m2, r2);
    }
  }
  async _updateTileMesh(e3, t4, s2, i, a2, o2, c) {
    const d = e3, h = s2.message.tileKey, f3 = !!this._schema.mesh.sortKey;
    h !== t4.key.id && (a2 = false);
    const m2 = o(s2, (e4) => e4.message), u = o(s2, (e4) => e4.transferList) || [], p3 = { type: d, addOrUpdate: m2, remove: i, clear: o2, end: a2, sort: f3 }, g2 = { transferList: e2(u) || [], signal: c };
    return f2(g2), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: h, data: p3 }, g2);
  }
  async _processFeatures(e3, t4, s2, r2, a2) {
    if (t(t4) || !t4.hasFeatures)
      return null;
    const o2 = { transform: e3.transform, hasZ: false, hasM: false }, n3 = this._factory, c = { viewingMode: "", scale: e3.scale }, d = await this._matchers.feature, h = await this._matchers.aggregate;
    f2(r2);
    const f3 = this._getLabelInfos(e3, t4);
    return await n3.analyze(t4.getCursor(), this._resourceManagerProxy, d, h, o2, c), f2(r2), this._writeFeatureSet(e3, t4, o2, f3, n3, s2, a2);
  }
  _writeFeatureSet(e3, t4, s2, r2, i, o2, n3) {
    const l3 = t4.getSize(), c = new E(e3.key.id, { features: l3, records: l3, metrics: 0 }, this._schema.mesh.matcher.symbologyType, o2, true, n3), d = { viewingMode: "", scale: e3.scale }, h = t4.getCursor();
    for (; h.next(); )
      try {
        const t5 = h.getDisplayId(), o3 = r(r2) ? r2.get(t5) : null;
        i.writeCursor(c, h, s2, d, e3.level, o3, this._resourceManagerProxy);
      } catch (m2) {
      }
    const f3 = e3.tileInfoView.tileInfo.isWrappable;
    return c.serialize(f3);
  }
  _handleError(e3, t4, s2) {
    if (!g(t4)) {
      const r2 = { tileKey: e3.id, error: t4.message };
      return this.remoteClient.invoke("tileRenderer.onTileError", r2, { signal: s2.signal });
    }
  }
  _getLabelingSchemaForScale(e3) {
    const t4 = this._schema.mesh.labels;
    if (t(t4))
      return null;
    if ("subtype" === t4.type) {
      const s3 = { type: "subtype", classes: {} };
      let r2 = false;
      for (const i in t4.classes) {
        const a2 = t4.classes[i].filter((t5) => I(t5, e3.scale));
        r2 = r2 || !!a2.length, s3.classes[i] = a2;
      }
      return r2 ? s3 : null;
    }
    const s2 = t4.classes.filter((t5) => I(t5, e3.scale));
    return s2.length ? { type: "simple", classes: s2 } : null;
  }
  _getLabels(e3, t4) {
    if ("subtype" === t4.type) {
      const s2 = this.service.subtypeField, r2 = f(s2, "Expected to find subtype Field"), i = e3.readAttribute(r2);
      return null == i ? [] : t4.classes[i] ?? [];
    }
    return t4.classes;
  }
  _getLabelInfos(e3, s2) {
    const r2 = this._getLabelingSchemaForScale(e3);
    if (t(r2))
      return null;
    const a2 = /* @__PURE__ */ new Map(), o2 = s2.getCursor();
    for (; o2.next(); ) {
      const e4 = o2.getDisplayId(), s3 = [], i = p2(e4), n3 = i && 1 !== o2.readAttribute("cluster_count") ? "aggregate" : "feature", l3 = this._getLabels(o2, r2);
      for (const r3 of l3) {
        if (r3.target !== n3)
          continue;
        const a3 = o2.getStorage(), l4 = i && "feature" === n3 ? a3.getComputedStringAtIndex(o2.readAttribute("referenceId"), r3.fieldIndex) : a3.getComputedStringAtIndex(e4, r3.fieldIndex);
        if (!l4)
          continue;
        const c = n2(l4.toString()), d = c[0], h = c[1];
        this._store.getMosaicItem(r3.symbol, t2(d)).then((e5) => {
          s3[r3.index] = { glyphs: e5.glyphMosaicItems, rtl: h, index: r3.index };
        });
      }
      a2.set(e4, s3);
    }
    return a2;
  }
};
M = e([n("esri.views.2d.layers.features.processors.SymbolProcessor")], M);
var x2 = M;
export {
  x2 as default
};
//# sourceMappingURL=SymbolProcessor-L5OVBW5E.js.map
