import {
  L,
  O as O2,
  T
} from "./chunk-WFUZXUS4.js";
import {
  a as a2,
  f as f2,
  g as g3,
  m,
  w
} from "./chunk-YRLGNAUD.js";
import {
  a,
  l,
  u as u2
} from "./chunk-NCMBCUFA.js";
import {
  u
} from "./chunk-4QVQG5LC.js";
import "./chunk-UQFAHV7T.js";
import {
  Y
} from "./chunk-COK4R22F.js";
import "./chunk-T6XN76GI.js";
import "./chunk-EZ4QR7V3.js";
import "./chunk-25Y2OKSP.js";
import "./chunk-EMETVH63.js";
import "./chunk-V56SVRSV.js";
import {
  f,
  g as g2
} from "./chunk-XZHFGTRH.js";
import "./chunk-2I27THZD.js";
import "./chunk-X64NQ2GK.js";
import "./chunk-NVOCHKIH.js";
import "./chunk-DGELARKE.js";
import "./chunk-WN3KE5M2.js";
import "./chunk-KBCUY3VB.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-CC32E45Q.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import {
  Q,
  W,
  ee,
  ne,
  te
} from "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-CQ47VEUP.js";
import {
  d
} from "./chunk-FU5UMT3R.js";
import "./chunk-F5A4XAOJ.js";
import {
  i
} from "./chunk-JMZLJZMP.js";
import "./chunk-GRILTTJT.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import {
  P
} from "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-HPH3FMVB.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import {
  v
} from "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  E,
  c
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  O,
  g
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/graphics/sources/geojson/GeoJSONSourceWorker.js
var O3 = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: false, supportsSqlExpression: true, supportsDisjointSpatialRel: true } };
var C = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e) => {
      const t = await this._fetch(e);
      return this._createFeatures(t);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = this._fieldsIndex = this._createDefaultAttributes = null;
  }
  async load(e, s3 = {}) {
    this.loadOptions = { url: e.url, customParameters: e.customParameters };
    const i2 = [];
    await this._checkProjection(e.spatialReference);
    let r2 = null;
    e.url && (r2 = await this._fetch(s3 == null ? void 0 : s3.signal));
    const n = T(r2, { geometryType: e.geometryType }), a3 = e.fields || n.fields || [], u3 = null != e.hasZ ? e.hasZ : n.hasZ, l2 = n.geometryType, d2 = e.objectIdField || n.objectIdFieldName || "__OBJECTID", p = e.spatialReference || c;
    let c2 = e.timeInfo;
    a3 === n.fields && n.unknownFields.length > 0 && i2.push({ name: "geojson-layer:unknown-field-types", message: "Some fields types couldn't be inferred from the features and were dropped", details: { unknownFields: n.unknownFields } });
    let y = a3.find((e2) => e2.name === d2);
    y ? ("esriFieldTypeString" !== y.type && (y.type = "esriFieldTypeOID"), y.editable = false, y.nullable = false) : (y = { alias: d2, name: d2, type: "string" === n.objectIdFieldType ? "esriFieldTypeString" : "esriFieldTypeOID", editable: false, nullable: false }, a3.unshift(y));
    const m2 = {};
    for (const o of a3) {
      if (null == o.name && (o.name = o.alias), null == o.alias && (o.alias = o.name), !o.name)
        throw new s2("geojson-layer:invalid-field-name", "field name is missing", { field: o });
      if (!i.jsonValues.includes(o.type))
        throw new s2("geojson-layer:invalid-field-type", `invalid type for field "${o.name}"`, { field: o });
      if (o.name !== y.name) {
        const e2 = P(o);
        void 0 !== e2 && (m2[o.name] = e2);
      }
    }
    this._fieldsIndex = new d(a3);
    const f3 = this._fieldsIndex.requiredFields.indexOf(y);
    if (f3 > -1 && this._fieldsIndex.requiredFields.splice(f3, 1), c2) {
      if (c2.startTimeField) {
        const e2 = this._fieldsIndex.get(c2.startTimeField);
        e2 ? (c2.startTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.startTimeField = null;
      }
      if (c2.endTimeField) {
        const e2 = this._fieldsIndex.get(c2.endTimeField);
        e2 ? (c2.endTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.endTimeField = null;
      }
      if (c2.trackIdField) {
        const e2 = this._fieldsIndex.get(c2.trackIdField);
        e2 ? c2.trackIdField = e2.name : (c2.trackIdField = null, i2.push({ name: "geojson-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: c2 } }));
      }
      c2.startTimeField || c2.endTimeField || (i2.push({ name: "geojson-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing", details: { timeInfo: c2 } }), c2 = null);
    }
    const I = l2 ? u2(l2) : null, j = { warnings: i2, featureErrors: [], layerDefinition: { ...O3, drawingInfo: I, templates: l(m2), extent: null, geometryType: l2, objectIdField: d2, fields: a3, hasZ: !!u3, timeInfo: c2 } };
    this._queryEngine = new Y({ fields: a3, geometryType: l2, hasM: false, hasZ: u3, objectIdField: d2, spatialReference: p, timeInfo: c2, featureStore: new u({ geometryType: l2, hasM: false, hasZ: u3 }), cacheSpatialQueries: true }), this._createDefaultAttributes = a(m2, d2);
    const T2 = await this._createFeatures(r2);
    this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, T2);
    const w2 = this._normalizeFeatures(T2, j.warnings, j.featureErrors);
    if (this._queryEngine.featureStore.addMany(w2), j.layerDefinition.extent = this._queryEngine.fullExtent, j.layerDefinition.timeInfo) {
      const { start: e2, end: t } = this._queryEngine.timeExtent;
      j.layerDefinition.timeInfo.timeExtent = [e2, t];
    }
    return j;
  }
  async applyEdits(e) {
    const { spatialReference: t, geometryType: s3 } = this._queryEngine;
    return await Promise.all([w(t, s3), f(e.adds, t), f(e.updates, t)]), await this._waitSnapshotComplete(), this._applyEdits(e);
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(e) {
    var _a;
    return this.loadOptions.customParameters = e, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = O(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
      this._queryEngine.featureStore.clear(), this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, e2);
      const t = this._normalizeFeatures(e2);
      t && this._queryEngine.featureStore.addMany(t);
    }, (e2) => {
      this._queryEngine.featureStore.clear(), g(e2) || s.getLogger("esri.layers.GeoJSONLayer").error(new s2("geojson-layer:refresh", "An error occurred during refresh", { error: e2 }));
    }), await this._waitSnapshotComplete(), { extent: this._queryEngine.fullExtent, timeExtent: this._queryEngine.timeExtent };
  }
  async _createFeatures(e) {
    const { geometryType: t, hasZ: s3, objectIdField: r2 } = this._queryEngine, n = L(e, { geometryType: t, hasZ: s3, objectIdField: r2 });
    if (!E(this._queryEngine.spatialReference, c))
      for (const a3 of n)
        r(a3.geometry) && (a3.geometry = te(g2(ne(a3.geometry, this._queryEngine.geometryType, this._queryEngine.hasZ, false), c, this._queryEngine.spatialReference)));
    return n;
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t) {
    const { url: s3, customParameters: i2 } = this.loadOptions, r2 = (await U(s3, { responseType: "json", query: { ...i2 }, signal: t })).data;
    return await O2(r2), r2;
  }
  _normalizeFeatures(e, t, s3) {
    const { objectIdField: i2 } = this._queryEngine, r2 = [];
    for (const n of e) {
      const e2 = this._createDefaultAttributes(), a3 = m(this._fieldsIndex, e2, n.attributes, true, t);
      a3 ? s3 == null ? void 0 : s3.push(a3) : (this._assignObjectId(e2, n.attributes, true), n.attributes = e2, n.objectId = e2[i2], r2.push(n));
    }
    return r2;
  }
  _applyEdits(e) {
    const { adds: t, updates: s3, deletes: i2 } = e, r2 = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if (t && t.length && this._applyAddEdits(r2, t), s3 && s3.length && this._applyUpdateEdits(r2, s3), i2 && i2.length) {
      for (const e2 of i2)
        r2.deleteResults.push(f2(e2));
      this._queryEngine.featureStore.removeManyById(i2);
    }
    return { extent: this._queryEngine.fullExtent, timeExtent: this._queryEngine.timeExtent, featureEditResults: r2 };
  }
  _applyAddEdits(e, t) {
    const { addResults: s3 } = e, { geometryType: r2, hasM: n, hasZ: o, objectIdField: u3, spatialReference: l2, featureStore: d2 } = this._queryEngine, c2 = [];
    for (const p of t) {
      if (p.geometry && r2 !== v(p.geometry)) {
        s3.push(a2("Incorrect geometry type."));
        continue;
      }
      const t2 = this._createDefaultAttributes(), n2 = m(this._fieldsIndex, t2, p.attributes);
      if (n2)
        s3.push(n2);
      else {
        if (this._assignObjectId(t2, p.attributes), p.attributes = t2, null != p.uid) {
          const t3 = p.attributes[u3];
          e.uidToObjectId[p.uid] = t3;
        }
        r(p.geometry) && (p.geometry = g2(g3(p.geometry, l2), p.geometry.spatialReference, l2)), c2.push(p), s3.push(f2(p.attributes[u3]));
      }
    }
    d2.addMany(W([], c2, r2, o, n, u3));
  }
  _applyUpdateEdits({ updateResults: e }, t) {
    const { geometryType: s3, hasM: r2, hasZ: n, objectIdField: o, spatialReference: u3, featureStore: l2 } = this._queryEngine;
    for (const d2 of t) {
      const { attributes: t2, geometry: p } = d2, h = t2 && t2[o];
      if (null == h) {
        e.push(a2(`Identifier field ${o} missing`));
        continue;
      }
      if (!l2.has(h)) {
        e.push(a2(`Feature with object id ${h} missing`));
        continue;
      }
      const m2 = ee(l2.getFeature(h), s3, n, r2);
      if (r(p)) {
        if (s3 !== v(p)) {
          e.push(a2("Incorrect geometry type."));
          continue;
        }
        m2.geometry = g2(g3(p, u3), p.spatialReference, u3);
      }
      if (t2) {
        const s4 = m(this._fieldsIndex, m2.attributes, t2);
        if (s4) {
          e.push(s4);
          continue;
        }
      }
      l2.add(Q(m2, s3, n, r2, o)), e.push(f2(h));
    }
  }
  _createObjectIdGenerator(e, t) {
    const s3 = e.fieldsIndex.get(e.objectIdField);
    if ("esriFieldTypeString" === s3.type)
      return () => s3.name + "-" + Date.now().toString(16);
    let i2 = Number.NEGATIVE_INFINITY;
    for (const r2 of t)
      r2.objectId && (i2 = Math.max(i2, r2.objectId));
    return i2 = Math.max(0, i2) + 1, () => i2++;
  }
  _assignObjectId(e, t, s3 = false) {
    const i2 = this._queryEngine.objectIdField;
    e[i2] = s3 && i2 in t ? t[i2] : this._objectIdGenerator();
  }
  async _checkProjection(e) {
    try {
      await f(c, e);
    } catch {
      throw new s2("geojson-layer", "Projection not supported");
    }
  }
};
export {
  C as default
};
//# sourceMappingURL=GeoJSONSourceWorker-OZBX3OMN.js.map
