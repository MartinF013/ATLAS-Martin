import {
  s as s2,
  x
} from "./chunk-DLW46BXD.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  F,
  Q,
  y
} from "./chunk-5N3FSR63.js";
import {
  b
} from "./chunk-23NWA6WL.js";
import {
  r as r2,
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/support/basemapUtils.js
var f = s.getLogger("esri.support.basemapUtils");
function p() {
  return {};
}
function y2(e) {
  for (const r3 in e) {
    const a = e[r3];
    false === (a == null ? void 0 : a.destroyed) && a.destroy(), delete e[r3];
  }
}
function m(a, t2) {
  let n;
  if ("string" == typeof a) {
    if (!(a in s2)) {
      const e = Object.entries(s2).filter(([e2, a2]) => r2.apiKey && !a2.classic || !r2.apiKey && a2.classic && !a2.deprecated).map(([e2]) => `"${e2}"`).join(", ");
      return f.warn(`Unable to find basemap definition for: ${a}. Try one of these: ${e}`), null;
    }
    t2 && (n = t2[a]), n || (n = x.fromId(a), t2 && (t2[a] = n));
  } else
    n = b(x, a);
  return (n == null ? void 0 : n.destroyed) && (f.warn("The provided basemap is already destroyed", { basemap: n }), n = null), n;
}
function L(e, r3) {
  if (e === r3)
    return true;
  return "equal" === M(T(e), T(r3), { mustMatchReferences: true });
}
function v(e) {
  return !!(e == null ? void 0 : e.baseLayers.concat(e.referenceLayers).some(S));
}
function S(e) {
  var _a;
  if (I(e.url))
    return true;
  if ("vector-tile" === e.type)
    for (const r3 in e.sourceNameToSource) {
      if (I((_a = e.sourceNameToSource[r3]) == null ? void 0 : _a.sourceUrl))
        return true;
    }
  return false;
}
function h(e, r3) {
  var _a;
  if (t(r3) || t(e))
    return { spatialReference: null, updating: false };
  if ("not-loaded" === r3.loadStatus)
    return r3.load(), { spatialReference: null, updating: true };
  if (r3.spatialReference)
    return { spatialReference: r3.spatialReference, updating: false };
  if (0 === r3.baseLayers.length)
    return { spatialReference: null, updating: false };
  const a = r3.baseLayers.getItemAt(0);
  switch (a.loadStatus) {
    case "not-loaded":
      a.load();
    case "loading":
      return { spatialReference: null, updating: true };
    case "failed":
      return { spatialReference: null, updating: false };
  }
  const t2 = (("supportedSpatialReferences" in a ? a.supportedSpatialReferences : null) || ["tileInfo" in a ? (_a = a.tileInfo) == null ? void 0 : _a.spatialReference : a.spatialReference]).filter(Boolean);
  return e.spatialReference ? { spatialReference: t2.find((r4) => e.spatialReference.equals(r4)) ?? t2[0] ?? null, updating: false } : { spatialReference: t2[0], updating: false };
}
var R = /^(basemaps|ibasemaps).*-api\.arcgis\.com$/i;
function I(e) {
  if (!e)
    return false;
  const r3 = new y(Q(e));
  return R.test(r3.authority);
}
function T(e) {
  return e ? !e.loaded && e.resourceInfo ? q(e.resourceInfo.data) : { baseLayers: w(e.baseLayers), referenceLayers: w(e.referenceLayers) } : null;
}
function w(e) {
  return (j.isCollection(e) ? e.toArray() : e).map(j2);
}
function j2(e) {
  var _a, _b;
  return { type: e.type, url: A("urlTemplate" in e && e.urlTemplate || e.url || "styleUrl" in e && e.styleUrl), minScale: "minScale" in e && null != e.minScale ? e.minScale : 0, maxScale: "maxScale" in e && null != e.maxScale ? e.maxScale : 0, opacity: null != e.opacity ? e.opacity : 1, visible: null == e.visible || !!e.visible, sublayers: "map-image" !== e.type && "wms" !== e.type || !r(e.sublayers) ? void 0 : (_a = e.sublayers) == null ? void 0 : _a.map((e2) => ({ id: e2.id, visible: e2.visible })), activeLayerId: "wmts" === e.type ? (_b = e.activeLayer) == null ? void 0 : _b.id : void 0 };
}
function q(e) {
  return e ? { baseLayers: x2(e.baseMapLayers.filter((e2) => !e2.isReference)), referenceLayers: x2(e.baseMapLayers.filter((e2) => e2.isReference)) } : null;
}
function x2(e) {
  return e.map((e2) => U(e2));
}
function U(e) {
  let r3;
  switch (e.layerType) {
    case "VectorTileLayer":
      r3 = "vector-tile";
      break;
    case "ArcGISTiledMapServiceLayer":
      r3 = "tile";
      break;
    default:
      r3 = "unknown";
  }
  return { type: r3, url: A(e.templateUrl || e.urlTemplate || e.styleUrl || e.url), minScale: null != e.minScale ? e.minScale : 0, maxScale: null != e.maxScale ? e.maxScale : 0, opacity: null != e.opacity ? e.opacity : 1, visible: null == e.visibility || !!e.visibility, sublayers: void 0, activeLayerId: void 0 };
}
function M(e, r3, a) {
  if (null != e != (null != r3))
    return "not-equal";
  if (!e)
    return "equal";
  if (!k(e.baseLayers, r3.baseLayers))
    return "not-equal";
  return k(e.referenceLayers, r3.referenceLayers) ? "equal" : a.mustMatchReferences ? "not-equal" : "base-layers-equal";
}
function k(e, r3) {
  if (e.length !== r3.length)
    return false;
  for (let a = 0; a < e.length; a++)
    if (!$(e[a], r3[a]))
      return false;
  return true;
}
function $(e, r3) {
  if (e.type !== r3.type || e.url !== r3.url || e.minScale !== r3.minScale || e.maxScale !== r3.maxScale || e.visible !== r3.visible || e.opacity !== r3.opacity)
    return false;
  if (r(e.activeLayerId) || r(r3.activeLayerId))
    return e.activeLayerId === r3.activeLayerId;
  if (r(e.sublayers) || r(r3.sublayers)) {
    if (t(e.sublayers) || t(r3.sublayers) || e.sublayers.length !== r3.sublayers.length)
      return false;
    for (let a = 0; a < e.sublayers.length; a++) {
      const t2 = e.sublayers.at(a), n = r3.sublayers.at(a);
      if (t2.id !== n.id || t2.visible !== n.visible)
        return false;
    }
  }
  return true;
}
function A(e) {
  return e ? F(e).replace(/^\s*https?:/i, "").toLowerCase() : "";
}

export {
  p,
  y2 as y,
  m,
  L,
  v,
  S,
  h
};
//# sourceMappingURL=chunk-24OMPNTT.js.map
