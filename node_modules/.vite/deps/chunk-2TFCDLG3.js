import {
  o as o4
} from "./chunk-UV5UBITC.js";
import {
  o as o3
} from "./chunk-K37I5IIG.js";
import {
  o as o2
} from "./chunk-XEIRRA3E.js";
import {
  a as a2
} from "./chunk-767LZ6IM.js";
import {
  o
} from "./chunk-TEJEYVH4.js";
import {
  u
} from "./chunk-IJHFAZOW.js";
import {
  e as e2
} from "./chunk-46N7XS5M.js";
import {
  a
} from "./chunk-OYAHQ564.js";
import {
  e
} from "./chunk-LGILR4HN.js";
import {
  i2 as i
} from "./chunk-I5UNY2WQ.js";
import {
  n
} from "./chunk-NAB3NF54.js";
import {
  O
} from "./chunk-VMF4NMEB.js";

// node_modules/@arcgis/core/chunks/PointRenderer.glsl.js
function m(m2) {
  const f2 = new i(), g = m2.output === o.Color, u2 = m2.output === o.Depth, v = m2.output === o.Highlight, { vertex: w, fragment: S } = f2;
  return f2.extensions.add("GL_OES_standard_derivatives"), f2.include(u, m2), f2.attributes.add(O.POSITION, "vec3"), f2.attributes.add(O.COLOR, "vec3"), w.uniforms.add(new o2("modelView")), w.uniforms.add(new e2("proj", (e3, i2) => i2.camera.projectionMatrix)), w.uniforms.add(new o3("screenMinMaxSize")), w.uniforms.add(new o3("pointScale")), w.uniforms.add(new o4("clipMin")), w.uniforms.add(new o4("clipMax")), u2 ? (w.uniforms.add(new e("nearFar", (e3, i2) => i2.camera.nearFar)), f2.varyings.add("depth", "float")) : m2.output !== o.Highlight && f2.varyings.add("vColor", "vec3"), w.code.add(n`
    void main(void) {
      // Move clipped points outside of clipspace
      if (position.x < clipMin.x || position.y < clipMin.y || position.z < clipMin.z ||
        position.x > clipMax.x || position.y > clipMax.y || position.z > clipMax.z) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      if (rejectBySlice(position)) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      // Position in camera space
      vec4 camera = modelView * vec4(position, 1.0);

      float pointSize = pointScale.x;
      vec4 position = proj * camera;
     ${m2.drawScreenSize ? n`
      float clampedScreenSize = pointSize;` : n`
      float pointRadius = 0.5 * pointSize;
      vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);
      vec4 positionOffset = proj * cameraOffset;
      float radius = abs(positionOffset.y - position.y);
      float viewHeight = pointScale.y;
      // screen diameter = (2 * r / w) * (h / 2)
      float screenPointSize = (radius / position.w) * viewHeight;
      float clampedScreenSize = clamp(screenPointSize, screenMinMaxSize.x, screenMinMaxSize.y);
      // Shift towards camera, to move rendered point out of terrain i.e. to
      // the camera-facing end of the virtual point when considering it as a
      // 3D sphere.
      camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;
      position = proj * camera;`}

     gl_PointSize = clampedScreenSize;
     gl_Position = position;

     ${u2 ? n`depth = (-camera.z - nearFar[0]) / (nearFar[1] - nearFar[0]);` : ""}
     ${g ? n`vColor = color;` : ""}
    }
  `), S.include(a, m2), v && f2.include(a2), S.code.add(n`
    void main(void) {
      vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);
      float r2 = dot(vOffset, vOffset);

      if (r2 > 0.25) {
        discard;
      }
      ${u2 ? n`gl_FragColor = float2rgba(depth);` : ""}
      ${v ? n`outputHighlight();` : ""}
      ${g ? n`gl_FragColor = vec4(vColor, 1.0);` : ""}
    }
  `), f2;
}
var f = Object.freeze(Object.defineProperty({ __proto__: null, build: m }, Symbol.toStringTag, { value: "Module" }));

export {
  m,
  f
};
//# sourceMappingURL=chunk-2TFCDLG3.js.map
