import {
  E,
  X,
  y
} from "./chunk-24ZW6JTQ.js";
import {
  s as s3
} from "./chunk-6QQDRYUS.js";
import "./chunk-IFZAYQVB.js";
import "./chunk-X57S4DWT.js";
import "./chunk-D7AOY7GH.js";
import "./chunk-HR2OX32D.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-SZPDY7KN.js";
import {
  i
} from "./chunk-Y6YGVGFR.js";
import {
  p
} from "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import {
  o as o2
} from "./chunk-MZX3HN4G.js";
import "./chunk-T47JAOQZ.js";
import {
  d as d2,
  g,
  m
} from "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-TMSBC6BS.js";
import {
  n as n2
} from "./chunk-RIWDMEW4.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  v
} from "./chunk-OG6CQEZJ.js";
import {
  c
} from "./chunk-X5Z3DJQ4.js";
import {
  O
} from "./chunk-BUWXVMJU.js";
import {
  f
} from "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import {
  a as a2
} from "./chunk-D3XXPCBB.js";
import {
  t
} from "./chunk-OWBMOIIV.js";
import {
  b
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import {
  a
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  I,
  Q,
  j
} from "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import {
  s as s2
} from "./chunk-XRL56EGK.js";
import {
  r as r2
} from "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  w
} from "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/TileLayer.js
var W = ["Canvas/World_Dark_Gray_Base", "Canvas/World_Dark_Gray_Reference", "Canvas/World_Light_Gray_Base", "Canvas/World_Light_Gray_Reference", "Elevation/World_Hillshade", "Elevation/World_Hillshade_Dark", "Ocean/World_Ocean_Base", "Ocean/World_Ocean_Reference", "Ocean_Basemap", "Reference/World_Boundaries_and_Places", "Reference/World_Boundaries_and_Places_Alternate", "Reference/World_Transportation", "World_Imagery", "World_Street_Map", "World_Topo_Map"];
var I2 = class extends a2(E(t(c(v(s3(y(p(O(a(n2(i(o2(b))))))))))))) {
  constructor(...e2) {
    super(...e2), this.listMode = "show", this.isReference = null, this.operationalLayerType = "ArcGISTiledMapServiceLayer", this.resampling = true, this.sourceJSON = null, this.spatialReference = null, this.path = null, this.sublayers = null, this.type = "tile", this.url = null;
  }
  normalizeCtorArgs(e2, r3) {
    return "string" == typeof e2 ? { url: e2, ...r3 } : e2;
  }
  load(e2) {
    const r3 = r(e2) ? e2.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Map Service"] }, e2).catch(w).then(() => this._fetchService(r3))), Promise.resolve(this);
  }
  get attributionDataUrl() {
    var _a;
    const e2 = (_a = this.parsedUrl) == null ? void 0 : _a.path.toLowerCase();
    return e2 && this._getDefaultAttribution(this._getMapName(e2));
  }
  readSpatialReference(e2, r3) {
    return (e2 = e2 || r3.tileInfo && r3.tileInfo.spatialReference) && k.fromJSON(e2);
  }
  writeSublayers(e2, r3, t2, s4) {
    if (!this.loaded || !e2)
      return;
    const i2 = e2.slice().reverse().flatten(({ sublayers: e3 }) => e3 && e3.toArray().reverse()).toArray(), o3 = [], a3 = { writeSublayerStructure: false, ...s4 };
    i2.forEach((e3) => {
      const r4 = e3.write({}, a3);
      o3.push(r4);
    });
    o3.some((e3) => Object.keys(e3).length > 1) && (r3.layers = o3);
  }
  get tileServers() {
    return this._getDefaultTileServers(this.parsedUrl.path);
  }
  castTileServers(e2) {
    return Array.isArray(e2) ? e2.map((e3) => j(e3).path) : null;
  }
  fetchTile(e2, t2, s4, i2 = {}) {
    const { signal: o3 } = i2, a3 = this.getTileUrl(e2, t2, s4), l = { responseType: "image", signal: o3, query: { ...this.refreshParameters } };
    return U(a3, l).then((e3) => e3.data);
  }
  getTileUrl(e2, r3, t2) {
    const s4 = !this.tilemapCache && this.supportsBlankTile, i2 = I({ ...this.parsedUrl.query, blankTile: !s4 && null, ...this.customParameters, token: this.apiKey }), o3 = this.tileServers;
    return `${o3 && o3.length ? o3[r3 % o3.length] : this.parsedUrl.path}/tile/${e2}/${r3}/${t2}${i2 ? "?" + i2 : ""}`;
  }
  _fetchService(e2) {
    return new Promise((s4, o3) => {
      if (this.sourceJSON) {
        if (null != this.sourceJSON.bandCount && null != this.sourceJSON.pixelSizeX)
          throw new s("tile-layer:unsupported-url", "use ImageryTileLayer to open a tiled image service");
        return void s4({ data: this.sourceJSON });
      }
      if (!this.parsedUrl)
        throw new s("tile-layer:undefined-url", "layer's url is not defined");
      const a3 = m(this.parsedUrl.path);
      if (r(a3) && "ImageServer" === a3.serverType)
        throw new s("tile-layer:unsupported-url", "use ImageryTileLayer to open a tiled image service");
      U(this.parsedUrl.path, { query: { f: "json", ...this.parsedUrl.query, ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e2 }).then(s4, o3);
    }).then((r3) => {
      if (r3.ssl && (this.url = this.url.replace(/^http:/i, "https:")), this.sourceJSON = r3.data, this.read(r3.data, { origin: "service", url: this.parsedUrl }), 10.1 === this.version && !g(this.url))
        return this._fetchServerVersion(this.url, e2).then((e3) => {
          this.read({ currentVersion: e3 });
        }).catch(() => {
        });
    });
  }
  _fetchServerVersion(e2, s4) {
    if (!d2(e2))
      return Promise.reject();
    const i2 = e2.replace(/(.*\/rest)\/.*/i, "$1") + "/info";
    return U(i2, { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: s4 }).then((e3) => {
      if (e3.data && e3.data.currentVersion)
        return e3.data.currentVersion;
      throw new s("tile-layer:version-not-available");
    });
  }
  _getMapName(e2) {
    const r3 = e2.match(/^(?:https?:)?\/\/(server\.arcgisonline\.com|services\.arcgisonline\.com|ibasemaps-api\.arcgis\.com)\/arcgis\/rest\/services\/([^\/]+(\/[^\/]+)*)\/mapserver/i);
    return r3 && r3[2];
  }
  _getDefaultAttribution(e2) {
    if (!e2)
      return;
    let r3;
    e2 = e2.toLowerCase();
    for (let t2 = 0, s4 = W.length; t2 < s4; t2++)
      if (r3 = W[t2], r3.toLowerCase().includes(e2))
        return Q("//static.arcgis.com/attribution/" + r3);
  }
  _getDefaultTileServers(e2) {
    const r3 = -1 !== e2.search(/^(?:https?:)?\/\/server\.arcgisonline\.com/i), t2 = -1 !== e2.search(/^(?:https?:)?\/\/services\.arcgisonline\.com/i);
    return r3 || t2 ? [e2, e2.replace(r3 ? /server\.arcgisonline/i : /services\.arcgisonline/i, r3 ? "services.arcgisonline" : "server.arcgisonline")] : [];
  }
  get hasOverriddenFetchTile() {
    return !this.fetchTile.__isDefault__;
  }
};
e([d({ readOnly: true })], I2.prototype, "attributionDataUrl", null), e([d({ type: ["show", "hide", "hide-children"] })], I2.prototype, "listMode", void 0), e([d({ json: { read: true, write: true } })], I2.prototype, "blendMode", void 0), e([d({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], I2.prototype, "isReference", void 0), e([d({ readOnly: true, type: ["ArcGISTiledMapServiceLayer"] })], I2.prototype, "operationalLayerType", void 0), e([d({ type: Boolean })], I2.prototype, "resampling", void 0), e([d()], I2.prototype, "sourceJSON", void 0), e([d({ type: k })], I2.prototype, "spatialReference", void 0), e([o("spatialReference", ["spatialReference", "tileInfo"])], I2.prototype, "readSpatialReference", null), e([d({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], I2.prototype, "path", void 0), e([d({ readOnly: true })], I2.prototype, "sublayers", void 0), e([r2("sublayers", { layers: { type: [X] } })], I2.prototype, "writeSublayers", null), e([d({ json: { read: false, write: false } })], I2.prototype, "popupEnabled", void 0), e([d()], I2.prototype, "tileServers", null), e([s2("tileServers")], I2.prototype, "castTileServers", null), e([d({ readOnly: true, json: { read: false } })], I2.prototype, "type", void 0), e([d(f)], I2.prototype, "url", void 0), I2 = e([n("esri.layers.TileLayer")], I2), I2.prototype.fetchTile.__isDefault__ = true;
var C = I2;
export {
  C as default
};
//# sourceMappingURL=@arcgis_core_layers_TileLayer.js.map
