import {
  g,
  h2 as h,
  p
} from "./chunk-SHAETJSZ.js";
import {
  o as o8
} from "./chunk-7WSRILGC.js";
import {
  t
} from "./chunk-GZ6H7JK2.js";
import {
  o as o7
} from "./chunk-UV5UBITC.js";
import {
  r as r4
} from "./chunk-TGUQXVQU.js";
import {
  o as o6
} from "./chunk-3236UEJN.js";
import {
  r as r3
} from "./chunk-HRAEK6P4.js";
import {
  s
} from "./chunk-K6UIDSFF.js";
import {
  r as r2
} from "./chunk-6YT7XVZA.js";
import {
  a as a2,
  m
} from "./chunk-MQLLOFWM.js";
import {
  c2 as c3
} from "./chunk-XNOIZLCR.js";
import {
  c as c4
} from "./chunk-Y5AGUEHG.js";
import {
  l
} from "./chunk-DVE4HUBR.js";
import {
  e as e6
} from "./chunk-YSWURJZW.js";
import {
  a
} from "./chunk-767LZ6IM.js";
import {
  r
} from "./chunk-FCDEMPPS.js";
import {
  o as o2
} from "./chunk-TEJEYVH4.js";
import {
  u
} from "./chunk-IJHFAZOW.js";
import {
  c as c2
} from "./chunk-DMGVDNFD.js";
import {
  o as o4
} from "./chunk-M3GMIUQS.js";
import {
  o as o3
} from "./chunk-BMA2CXVS.js";
import {
  e as e5
} from "./chunk-46N7XS5M.js";
import {
  e as e3
} from "./chunk-4MKQUQD4.js";
import {
  o as o5
} from "./chunk-A3QLZKCF.js";
import {
  e as e4
} from "./chunk-LGILR4HN.js";
import {
  i2 as i
} from "./chunk-I5UNY2WQ.js";
import {
  T
} from "./chunk-PLLZPG4O.js";
import {
  n as n2
} from "./chunk-NAB3NF54.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  e as e2
} from "./chunk-YFBAFAZ2.js";
import {
  c
} from "./chunk-ASC3X65B.js";
import {
  e,
  o,
  z
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js
function e7(e8, t2) {
  e8.varyings.add("tbnTangent", "vec3"), e8.varyings.add("tbnBiTangent", "vec3"), t2.spherical ? e8.vertex.code.add(n2`void forwardVertexTangent(vec3 n) {
tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), n));
tbnBiTangent = normalize(cross(n, tbnTangent));
}`) : e8.vertex.code.add(n2`void forwardVertexTangent(vec3 n) {
tbnTangent = vec3(1.0, 0.0, 0.0);
tbnBiTangent = normalize(cross(n, tbnTangent));
}`), e8.fragment.code.add(n2`mat3 getTBNMatrix(vec3 n) {
return mat3(tbnTangent, tbnBiTangent, n);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js
function i2(i3, d) {
  i3.varyings.add("vtc", "vec2"), i3.vertex.uniforms.add(new o6("texOffsetAndScale")), i3.fragment.uniforms.add(new s("tex")), i3.fragment.uniforms.add(new o7("textureOpacities"));
  const s2 = d.textureFadingEnabled && !d.renderOccluded;
  s2 && (i3.vertex.uniforms.add(new o6("nextTexOffsetAndScale")), i3.varyings.add("nvtc", "vec2"), i3.fragment.uniforms.add(new s("texNext")), i3.fragment.uniforms.add(new o7("nextTexOpacities")), i3.fragment.uniforms.add(new r3("fadeFactor")));
  const l2 = d.tileBlendInput === o8.ColorComposite, f = d.tileBlendInput === o8.GridComposite;
  f && i3.fragment.include(t), l2 && i3.fragment.uniforms.add(new o7("backgroundColor")), i3.vertex.code.add(n2`
  void forwardTextureCoordinates(in vec2 uv) {
    vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;
    ${s2 ? n2`nvtc = uv * nextTexOffsetAndScale.zw + nextTexOffsetAndScale.xy;` : n2``}
  }`), i3.fragment.code.add(n2`
    vec4 applyBaseOpacity(vec4 _color, vec3 _opacities) {
      return _opacities.z <= 0.0 ? _color : _color * _opacities.x;
    }

    vec4 getColor(vec4 color, vec2 uv, vec3 opacities) {
      ${f || l2 ? n2`
              if (opacities.y <= 0.0) {
                return color * opacities.z * opacities.x;
              }
              vec4 bg = ${l2 ? n2`vec4(backgroundColor, 1.0)` : n2`gridColor(uv)`} * opacities.y;
              float alpha = opacities.z * color.a;
              return mix(bg, color, alpha) * opacities.x;` : n2`return color;`}
    }`), s2 ? i3.fragment.code.add(n2`vec4 getTileColor() {
vec4 color = getColor(texture2D(tex, vtc), vtc, textureOpacities);
if (fadeFactor >= 1.0) {
return color;
}
vec4 nextColor = getColor(texture2D(texNext, nvtc), nvtc, nextTexOpacities);
return mix(nextColor, color, fadeFactor);
}`) : i3.fragment.code.add(n2`vec4 getTileColor() {
return getColor(texture2D(tex, vtc), vtc, textureOpacities);
}`);
}

// node_modules/@arcgis/core/chunks/Terrain.glsl.js
var N = class extends g {
};
function $(r5) {
  const n3 = new i();
  n3.include(r2, { name: "Terrain Shader", output: r5.output }), n3.attributes.add(O.POSITION, "vec3"), n3.attributes.add(O.UV0, "vec2"), n3.attributes.add(O.NORMAL, "vec3");
  const { vertex: f, fragment: N2 } = n3;
  if (f.uniforms.add([new e5("proj", (e8, r6) => r6.camera.projectionMatrix), new o4("view", (r6, o9) => c(U, o9.camera.viewMatrix, r6.origin)), new o3("origin", (e8) => e8.origin)]), N2.uniforms.add(new o3("origin", (e8) => e8.origin)), r5.output === o2.Color) {
    n3.include(r), n3.include(r4, r5), n3.include(i2, r5), n3.include(m, r5);
    const t2 = r5.overlayMode !== p.Disabled, c5 = r5.overlayMode === p.EnabledWithWater;
    t2 && n3.include(h, { ...r5, pbrMode: l.Water }), c5 && n3.include(e7, r5), n3.varyings.add("vnormal", "vec3"), n3.varyings.add("vpos", "vec3"), (r5.atmosphere || r5.screenSizePerspective) && f.uniforms.add(new e5("viewNormal", (e8, r6) => r6.camera.viewInverseTransposeMatrix));
    const g2 = r5.receiveShadows && !r5.renderOccluded;
    g2 && n3.varyings.add("linearDepth", "float"), r5.tileBorders && n3.varyings.add("vuv", "vec2"), r5.atmosphere && (f.uniforms.add(new e3("lightingMainDirection", (e8, r6) => r6.lighting.lightingMainDirection)), n3.varyings.add("wnormal", "vec3"), n3.varyings.add("wlight", "vec3")), r5.screenSizePerspective && (n3.varyings.add("screenSizeDistanceToCamera", "float"), n3.varyings.add("screenSizeCosAngle", "float")), f.code.add(n2`
      void main(void) {
        vpos = position;
        vnormal = ${r5.shading ? n2`normal` : n2`getLocalUp(vpos, origin)`};
        vec2 uv = uv0;
        ${r5.atmosphere ? n2`
        wnormal = normalize((viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz);
        wlight = normalize((view  * vec4(lightingMainDirection, 1.0)).xyz);` : ""}
        ${r5.tileBorders ? n2`vuv = uv;` : ""}
        ${r5.screenSizePerspective ? n2`
        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;
        screenSizeDistanceToCamera = length(viewPos);
        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;
        screenSizeCosAngle = abs(viewSpaceNormal.z);` : ""}
        gl_Position = transformPosition(proj, view, vpos);
        ${g2 ? n2`linearDepth = gl_Position.w;` : ""}
        forwardTextureCoordinates(uv);
        ${t2 ? n2`setOverlayVTC(uv);` : ""}
        ${c5 ? n2`forwardVertexTangent(vnormal);` : n2``}
      }
    `), n3.extensions.add("GL_OES_standard_derivatives"), n3.extensions.add("GL_EXT_shader_texture_lod"), n3.include(u, r5), n3.include(m, r5), n3.include(a2, r5), n3.include(c4, r5), N2.uniforms.add([new o3("cameraPosition", (e8, r6) => e(W, r6.camera.eye, e8.origin)), new e3("viewDirection", (e8, r6) => z(W, o(W, r6.camera.viewMatrix[12], r6.camera.viewMatrix[13], r6.camera.viewMatrix[14]))), new o5("lightingGlobalFactor", (e8, r6) => r6.lighting.globalFactor), new e3("lightingMainDirection", (e8, r6) => r6.lighting.lightingMainDirection), new e3("lightingMainIntensity", (e8, r6) => r6.lighting.mainLight.intensity)]), N2.constants.add("ambientBoostFactor", "float", c3), c5 && N2.uniforms.add([new c2("ovWaterTex", (e8, r6) => 0 === r6.overlays.length ? null : r6.overlays[T.INNER].getNormalTexture(e8.overlaySource)), new o4("view", (r6, o9) => c(U, o9.camera.viewMatrix, r6.origin))]), N2.code.add(n2`const float sliceOpacity = 0.2;
float lum(vec3 c) {
return (min(min(c.r, c.g), c.b) + max(max(c.r, c.g), c.b)) * 0.5;
}`), N2.code.add(n2`
      void main() {
        ${g2 ? n2`float shadow = readShadowMap(vpos, linearDepth);` : n2`float shadow = 0.0;`}
        vec3 normal = normalize(vnormal);
        float vndl = dot(normal, lightingMainDirection);
        float ssao = evaluateAmbientOcclusionInverse();
        vec4 tileColor = getTileColor();
        ${t2 ? n2`
            vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);
            vec4 overlayColor = overlayOpacity * overlayColorOpaque;
            vec4 groundColor = tileColor;
            tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;` : ""}
        if (rejectBySlice(vpos)) {
          tileColor *= sliceOpacity;
        }
        ${r5.atmosphere ? n2`
            float ndotl = clamp(vndl, 0.0, 1.0);
            vec3 atm = vec3(clamp(1.0 - dot(-viewDirection, wnormal), 0.0, 1.0));
            atm *= clamp(1.0 - lum(tileColor.rgb) * 1.5, 0.0, 1.0); //avoid atmosphere on bright base maps
            atm *= clamp(ndotl * 2.0, 0.0, 1.0); // avoid atmosphere on dark side of the globe
            atm *= tileColor.a; // premultiply with tile alpha` : ""}

        vec3 albedo = ${r5.atmosphere ? n2`atm + tileColor.rgb;` : n2`tileColor.rgb;`}

        // heuristic shading function used in the old terrain, now used to add ambient lighting
        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl${r5.shading ? "" : n2`*2.5`}, 0.0, 1.0));

        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor ${r5.shading ? "" : n2`* lightingGlobalFactor`};

        gl_FragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);
        ${c5 ? n2`
            vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);
            float waterNormalLength = length(overlayWaterMask);
            if (waterNormalLength > 0.95) {
              mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);
              vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);
              vec4 viewPosition = view*vec4(vpos, 1.0);
              vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - cameraPosition), shadow, vnormal, tbnMatrix, viewPosition.xyz,  vpos + origin);
              vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
              // un-gamma the ground color to mix in linear space
              gl_FragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w);
            }` : ""}
        ${r5.screenSizePerspective ? n2`
          float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, vec4(0.0, 0.0, 0.0, 0.0));
          if (perspectiveScale <= 0.25) {
            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);
          }
          else if (perspectiveScale <= 0.5) {
            gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);
          }
          else if (perspectiveScale >= 0.99) {
            gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);
          }
          else {
            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);
          }` : ""}
        ${r5.tileBorders ? n2`
            vec2 dVuv = fwidth(vuv);
            vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));
            float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);
            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);` : ""}
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
      }
    `);
  }
  return r5.output !== o2.Depth && r5.output !== o2.Shadow || (n3.include(r, { hasModelTransformation: false, linearDepth: true }), n3.include(e6, { output: r5.output }), n3.include(r4, r5), n3.varyings.add("linearDepth", "float"), f.uniforms.add(new e4("nearFar", (e8, r6) => r6.camera.nearFar)), f.code.add(n2`void main(void) {
gl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);
}`), N2.code.add(n2`void main() {
outputDepth(linearDepth);
}`)), r5.output === o2.Normal && (n3.include(r), n3.include(r4, r5), n3.varyings.add("vnormal", "vec3"), n3.varyings.add("vpos", "vec3"), f.uniforms.add(new e5("viewNormal", (e8, r6) => r6.camera.viewInverseTransposeMatrix)), f.code.add(n2`
        void main(void) {
          vec3 normal = ${r5.shading ? n2`normal` : n2`getLocalUp(position, origin)`};
          vpos = position;

          gl_Position = transformPosition(proj, view, vpos);
          vnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);
        }
    `), N2.code.add(n2`void main() {
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) {
normal = -normal;
}
gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);
}`)), r5.output === o2.Highlight && (n3.include(r), n3.include(r4, r5), n3.include(h, r5), f.code.add(n2`void main() {
setOverlayVTC(uv0);
gl_Position = transformPosition(proj, view, position);
}`), n3.include(a), N2.code.add(n2`void main() {
vec4 overlayColor = getCombinedOverlayColor();
if (overlayColor.a == 0.0) {
gl_FragColor = vec4(0.0);
return;
}
outputHighlight();
}`)), n3;
}
var U = e2();
var W = n();
var A = Object.freeze(Object.defineProperty({ __proto__: null, TerrainPassParameters: N, build: $ }, Symbol.toStringTag, { value: "Module" }));

export {
  N,
  $,
  A
};
//# sourceMappingURL=chunk-TBMOOGON.js.map
