import {
  c as c6
} from "./chunk-PR4JSHVD.js";
import {
  f as f4
} from "./chunk-2TFCDLG3.js";
import {
  n as n8
} from "./chunk-WLVMYWO2.js";
import "./chunk-7S6G3GM7.js";
import {
  u as u6
} from "./chunk-6UGZAJSY.js";
import {
  a as a4,
  c as c4,
  d as d3
} from "./chunk-O5HWALWY.js";
import "./chunk-Q2LKCV6V.js";
import "./chunk-UV5UBITC.js";
import {
  A as A3,
  Be,
  D,
  G,
  J,
  K,
  L as L2,
  N,
  P as P2,
  Ue,
  _e
} from "./chunk-RHH23PAT.js";
import {
  x as x2
} from "./chunk-HTS3HEEU.js";
import "./chunk-K37I5IIG.js";
import {
  t as t6
} from "./chunk-LAHCYKZK.js";
import {
  r as r5
} from "./chunk-4GGQTXXY.js";
import "./chunk-7CXXTQLM.js";
import {
  e as e5,
  e2 as e6,
  f as f3,
  o as o4,
  t as t5
} from "./chunk-NXOQBIK7.js";
import {
  A as A2,
  E as E5
} from "./chunk-ERNXFM5T.js";
import {
  i as i2
} from "./chunk-6ITXWFMK.js";
import {
  e as e7
} from "./chunk-SV4VP57N.js";
import {
  W as W2,
  a as a3,
  c as c3
} from "./chunk-B7F3T673.js";
import {
  f as f2
} from "./chunk-FUKESVWQ.js";
import {
  c as c2
} from "./chunk-T3KDRLPE.js";
import "./chunk-VQLKKADV.js";
import "./chunk-XEIRRA3E.js";
import "./chunk-EPNT7GPS.js";
import "./chunk-767LZ6IM.js";
import {
  o as o3
} from "./chunk-TEJEYVH4.js";
import {
  m as m2
} from "./chunk-IJHFAZOW.js";
import "./chunk-DMGVDNFD.js";
import "./chunk-BMA2CXVS.js";
import "./chunk-46N7XS5M.js";
import "./chunk-4MKQUQD4.js";
import "./chunk-OYAHQ564.js";
import "./chunk-LGILR4HN.js";
import "./chunk-I5UNY2WQ.js";
import {
  n as n6
} from "./chunk-KETNREBT.js";
import {
  t as t2
} from "./chunk-33INAWJA.js";
import {
  C as C3,
  E as E3,
  F,
  I
} from "./chunk-FPMD6IB4.js";
import {
  U as U2,
  i as i3,
  t as t7
} from "./chunk-WQLER7IU.js";
import "./chunk-7GTYHKA3.js";
import "./chunk-MOXYEJRV.js";
import {
  E as E4
} from "./chunk-Y55TYMBP.js";
import {
  t as t3
} from "./chunk-NAB3NF54.js";
import "./chunk-MHB3L22D.js";
import {
  u as u5
} from "./chunk-MDCKEJ7B.js";
import {
  n as n7,
  t as t4
} from "./chunk-MLAOYRDT.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import "./chunk-NAIF4GWX.js";
import {
  v as v2
} from "./chunk-SOZCO2CU.js";
import {
  T,
  p2 as p3
} from "./chunk-53KI6WDE.js";
import {
  p as p2
} from "./chunk-W2HLA6I3.js";
import "./chunk-Q6AASANP.js";
import "./chunk-ZYIEYKCD.js";
import "./chunk-DLM6NKXW.js";
import "./chunk-TQLSOIYV.js";
import "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-2EPPX4WN.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-3NPGGTI6.js";
import "./chunk-YZNDHJDJ.js";
import {
  c as c5,
  o as o5,
  r as r4
} from "./chunk-V7M26XZ7.js";
import "./chunk-ZN2MGN4S.js";
import {
  L,
  i
} from "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import "./chunk-RTHP2LNT.js";
import {
  zn
} from "./chunk-PZWU5EHT.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-6GPADSSO.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-U7B2WKBH.js";
import {
  p,
  u
} from "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  a as a2,
  n as n5
} from "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import {
  e as e4
} from "./chunk-5OEHY3VV.js";
import {
  r as r3
} from "./chunk-WKRVG5MO.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  U,
  h,
  l
} from "./chunk-T7BEWVV3.js";
import {
  u as u3,
  x
} from "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import {
  W
} from "./chunk-RN2KRYDN.js";
import {
  g as g2
} from "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import {
  A,
  C as C2,
  E as E2,
  V,
  a,
  b as b2,
  j as j3,
  k
} from "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  b,
  u as u4
} from "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import {
  I as I2
} from "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import {
  j as j2
} from "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import {
  u as u2
} from "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import {
  r as r2
} from "./chunk-ZOKX6UGH.js";
import {
  P,
  e as e3,
  j,
  o as o2,
  q,
  s as s3,
  v
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import {
  n as n4
} from "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d as d2,
  n2 as n,
  n4 as n2,
  n8 as n3
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  C,
  E,
  f,
  g
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s as s2
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  c,
  d,
  e as e2,
  m3 as m,
  o2 as o,
  r,
  s,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/3d/layers/PointCloudWorkerHandle.js
var e8 = class extends n6 {
  constructor(t11) {
    super("PointCloudWorker", "transform", { transform: (t12) => this._getTransferList(t12) }, t11);
  }
  _getTransferList(r8) {
    const e10 = [r8.geometryBuffer];
    if (r(r8.primaryAttributeData) && r8.primaryAttributeData.buffer && e10.push(r8.primaryAttributeData.buffer), r(r8.modulationAttributeData) && r8.modulationAttributeData.buffer && e10.push(r8.modulationAttributeData.buffer), r(r8.filterAttributesData))
      for (const a6 of r8.filterAttributesData)
        r(a6) && a6.buffer && e10.push(a6.buffer);
    for (const t11 of r8.userAttributesData)
      t11.buffer && e10.push(t11.buffer);
    return e10;
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/LoDUtil.js
function t8(e10, t11, g5) {
  for (let n11 = 0; n11 < t11.length; n11++)
    r6[n11] = false, o6[n11] = null;
  for (let r8 = 0; r8 < e10.length; r8++)
    n9[r8] = false, l2[r8] = null;
  for (let n11 = 0; n11 < t11.length; n11++) {
    const o9 = h2(t11[n11], e10, g5);
    o9 >= 0 && (r6[n11] = true, null != l2[o9] ? l2[o9].push(t11[n11]) : l2[o9] = [t11[n11]]);
  }
  for (let l5 = 0; l5 < e10.length; l5++) {
    const r8 = h2(e10[l5], t11, g5);
    r8 >= 0 && (n9[l5] = true, null != o6[r8] ? o6[r8].push(e10[l5]) : o6[r8] = [e10[l5]]);
  }
  const u10 = [];
  for (let r8 = 0; r8 < e10.length; r8++)
    null != l2[r8] || n9[r8] || u10.push({ load: [], remove: [e10[r8]] });
  for (let n11 = 0; n11 < t11.length; n11++)
    null != o6[n11] || r6[n11] || u10.push({ load: [t11[n11]], remove: [] });
  for (let n11 = 0; n11 < t11.length; n11++)
    null != o6[n11] && (o6[n11].length > 1 || o6[n11][0] !== t11[n11]) && u10.push({ load: [t11[n11]], remove: o6[n11] });
  for (let n11 = 0; n11 < e10.length; n11++)
    null != l2[n11] && (l2[n11].length > 1 || l2[n11][0] !== e10[n11]) && u10.push({ load: l2[n11], remove: [e10[n11]] });
  return u10;
}
var n9 = [false];
var l2 = [null];
var r6 = [false];
var o6 = [null];
function h2(e10, t11, n11) {
  let l5 = e10;
  for (; l5 > 0; ) {
    const e11 = t11.indexOf(l5);
    if (e11 >= 0)
      return e11;
    l5 = n11.getParentId(l5);
  }
  return t11.indexOf(l5);
}
function g3(t11, n11, l5) {
  return t11.sort((t12, r8) => {
    if (0 === t12.load.length && 0 === r8.load.length)
      return 0;
    if (0 === t12.load.length)
      return -1;
    if (0 === r8.load.length)
      return 1;
    if (0 === t12.remove.length && 0 === r8.remove.length) {
      const o9 = l5.getRenderCenter(t12.load[0]), h4 = l5.getRenderCenter(r8.load[0]);
      return P(o9, n11) - P(h4, n11);
    }
    if (0 === t12.remove.length)
      return -1;
    if (0 === r8.remove.length)
      return 1;
    if (1 === t12.load.length && 1 === r8.load.length) {
      const o9 = l5.getRenderCenter(t12.load[0]), h4 = l5.getRenderCenter(r8.load[0]);
      return P(o9, n11) - P(h4, n11);
    }
    if (1 === t12.load.length)
      return -1;
    if (1 === r8.load.length)
      return 1;
    {
      const o9 = l5.getRenderCenter(t12.remove[0]), h4 = l5.getRenderCenter(r8.remove[0]);
      return P(o9, n11) - P(h4, n11);
    }
  });
}
function u7(e10, t11, n11) {
  for (let l5 = 0; l5 < e10.length; ++l5) {
    const r8 = e10[l5];
    r8.load.length > t11 && 1 === r8.remove.length && d4(e10, r8, n11);
  }
}
function d4(e10, t11, n11) {
  const l5 = [t11.remove[0]], r8 = [];
  for (; 1 === l5.length; ) {
    const e11 = l5.pop();
    r8.length = 0;
    for (let o9 = 0; o9 < t11.load.length; o9++) {
      let h4 = t11.load[o9], g5 = n11.getParentId(h4);
      for (; g5 !== e11; )
        h4 = g5, g5 = n11.getParentId(h4);
      let u10 = l5.indexOf(h4);
      u10 < 0 && (u10 = l5.length, l5.push(h4), r8.push([])), r8[u10].push(t11.load[o9]);
    }
  }
  t11.load = l5;
  for (let o9 = 0; o9 < l5.length; o9++)
    r8[o9].length > 1 ? e10.push({ remove: [l5[o9]], load: r8[o9] }) : l5[o9] = r8[o9][0];
}

// node_modules/@arcgis/core/views/3d/layers/i3s/PagedNodeIndex.js
var h3 = class {
  constructor(e10, t11, s5) {
    this._pages = [], this.pageSize = 0, this._nodeSR = null, this._renderSR = null, this._nodeSR = e10, this._renderSR = t11, this.pageSize = s5;
  }
  addPage(e10, t11, s5 = 0) {
    for (; this._pages.length < e10; )
      this._pages.push(null);
    const n11 = g4(t11, this._nodeSR, this._renderSR, s5);
    this._pages[e10] = { nodes: t11, renderObbs: n11, parents: new Uint32Array(this.pageSize) }, u8(this._pages, this.pageSize);
  }
  hasPage(e10) {
    return !!this._pages[e10];
  }
  getNode(e10) {
    const t11 = this.pageSize;
    return this._pages[l3(e10, t11)].nodes[c7(e10, t11)];
  }
  getRenderObb(e10) {
    const t11 = this.pageSize;
    return this._pages[l3(e10, t11)].renderObbs[c7(e10, t11)];
  }
  getRenderCenter(e10) {
    return this.getRenderObb(e10).center;
  }
  setRenderObb(e10, t11) {
    const s5 = this.pageSize;
    G(t11, this._pages[l3(e10, s5)].renderObbs[c7(e10, s5)]);
  }
  getParentId(e10) {
    const t11 = this.pageSize;
    return this._pages[l3(e10, t11)].parents[c7(e10, t11)];
  }
  hasNodes(e10, t11) {
    const s5 = l3(e10, this.pageSize), n11 = l3(e10 + t11 - 1, this.pageSize);
    for (let i5 = s5; i5 <= n11; i5++)
      if (null == this._pages[i5])
        return false;
    return true;
  }
  forEachNodeId(e10) {
    for (let t11 = 0; t11 < this._pages.length; t11++) {
      const s5 = this._pages[t11];
      if (s5)
        for (let n11 = 0; n11 < s5.nodes.length; n11++)
          e10(t11 * this.pageSize + n11);
    }
  }
  createVisibilityTraverse() {
    const t11 = { index: this, queue: [], masks: [], tempAabb: a() };
    return (e10, s5) => a5(t11, e10, s5);
  }
};
function a5(e10, n11, i5) {
  const p4 = e10.index;
  if (!p4.hasNodes(0, 1))
    return;
  const h4 = e10.queue;
  h4.length = 0, h4.push(0);
  const a6 = e10.masks;
  for (a6.length = 0, a6.push(0); h4.length > 0; ) {
    const g5 = h4.pop();
    let u10 = a6.pop();
    const c8 = p4.getNode(g5), d5 = p4.getRenderObb(g5);
    let f5 = true;
    if (null != n11.clippingBox) {
      const i6 = 1 << n11.frustum.length;
      if (0 == (u10 & i6)) {
        const o9 = K(d5, e10.tempAabb);
        b2(n11.clippingBox, o9) ? u10 |= i6 : j3(n11.clippingBox, o9) || (f5 = false);
      }
    }
    for (let e11 = 0; e11 < n11.frustum.length && f5; e11++) {
      const t11 = 1 << e11;
      if (0 == (u10 & t11)) {
        const s5 = J(d5, n11.frustum[e11]);
        s5 > 0 ? f5 = false : s5 < 0 && (u10 |= t11);
      }
    }
    if (i5.predicate(g5, c8, f5)) {
      const e11 = c8.firstChild, t11 = c8.childCount;
      let s5 = false;
      const n12 = l3(e11, p4.pageSize), r8 = l3(e11 + t11 - 1, p4.pageSize);
      for (let o9 = n12; o9 <= r8; o9++)
        if (!p4.hasPage(o9)) {
          i5.pageMiss(g5, o9), s5 = true;
          break;
        }
      if (!s5)
        for (let i6 = 0; i6 < t11; i6++)
          h4.push(e11 + i6), a6.push(u10);
    }
  }
}
function g4(e10, t11, s5, i5) {
  const r8 = new D(e10.length);
  for (let o9 = 0; o9 < e10.length; o9++)
    Be(e10[o9].obb, t11, r8.obbs[o9], s5, i5);
  return r8.obbs;
}
function u8(e10, t11) {
  const s5 = [0];
  for (; s5.length; ) {
    const n11 = s5.pop(), i5 = e10[l3(n11, t11)].nodes[c7(n11, t11)];
    for (let r8 = 0; r8 < i5.childCount; r8++) {
      const o9 = i5.firstChild + r8;
      null != e10[l3(o9, t11)] && (e10[l3(o9, t11)].parents[c7(o9, t11)] = n11, s5.push(o9));
    }
  }
}
function l3(e10, t11) {
  return e10 / t11 | 0;
}
function c7(e10, t11) {
  return e10 % t11;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/PointCloudRendererUtil.js
function t9(t11) {
  const e10 = t11.renderer, n11 = e10 && e10.type, o9 = e10 && t11.renderer.toJSON() || null;
  let r8 = null, i5 = false;
  "point-cloud-unique-value" === n11 || "point-cloud-stretch" === n11 || "point-cloud-class-breaks" === n11 ? r8 = u9(t11.attributeStorageInfo, e10.field) : "point-cloud-rgb" === n11 ? (r8 = l4(t11.attributeStorageInfo, e10.field), i5 = null != r8) : (r8 = l4(t11.attributeStorageInfo, "RGB"), i5 = null != r8);
  let a6 = null;
  return e10 && e10.colorModulation && (a6 = u9(t11.attributeStorageInfo, e10.colorModulation.field)), { rendererJSON: o9, isRGBRenderer: i5, primaryAttribute: r8, modulationAttribute: a6 };
}
function e9(t11) {
  const e10 = t11.filters;
  return e10 ? e10.map((e11) => ({ filterJSON: e11.toJSON(), attributeInfo: u9(t11.attributeStorageInfo, e11.field) })) : [];
}
function n10(t11) {
  const e10 = t11 && t11.pointSizeAlgorithm;
  return e10 && "splat" === e10.type ? e10 : null;
}
function o7(t11) {
  const e10 = t11 && t11.pointSizeAlgorithm;
  return e10 && "fixed-size" === e10.type ? e10 : null;
}
function r7(t11) {
  const e10 = t11 && t11.pointSizeAlgorithm;
  return !(!e10 || !e10.type) && "fixed-size" === e10.type;
}
function l4(t11, e10) {
  for (const n11 of t11)
    if (n11.name === e10 && null != n11.attributeValues && "UInt8" === n11.attributeValues.valueType && 3 === n11.attributeValues.valuesPerElement)
      return { name: e10, storageInfo: n11, useElevation: false };
  return null;
}
function u9(t11, e10) {
  for (const n11 of t11)
    if (n11.name === e10) {
      const t12 = "embedded-elevation" === n11.encoding;
      return { name: e10, storageInfo: t12 ? null : n11, useElevation: t12 };
    }
  return "elevation" === e10.toLowerCase() ? { name: e10, storageInfo: null, useElevation: true } : null;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/PointGraphic.js
var t10 = class extends g2 {
  constructor(r8) {
    super(r8);
  }
};
e([d2({ constructOnly: true, clonable: "reference" })], t10.prototype, "pointCloudMetadata", void 0), t10 = e([n3("esri.views.3d.layers.i3s.PointGraphic")], t10);

// node_modules/@arcgis/core/views/3d/layers/i3s/PointHighlights.js
var s4 = class {
  constructor(e10) {
    this._context = e10, this._highlights = /* @__PURE__ */ new Set();
  }
  get hasHighlights() {
    return this._highlights.size > 0;
  }
  destroy() {
    this._highlights = null;
  }
  add(t11) {
    const i5 = new o8(t11);
    return this._highlights.add(i5), this._enableSet(i5), n(() => this._removeSet(i5));
  }
  _removeSet(e10) {
    this._disableSet(e10), this._highlights.delete(e10);
  }
  _enableSet(e10) {
    e10.enabled || (e10.enabled = true, this._context.forEachNode((t11) => this._enableSetForNode(e10, t11)));
  }
  _enableSetForNode(e10, t11) {
    if (!e10.enabled)
      return;
    const i5 = e10.ids.get(t11.id);
    i5 && i5.forEach((i6) => this._context.addHighlight(t11, i6, e10.id));
  }
  _disableSet(e10) {
    e10.enabled && (e10.enabled = false, this._context.forEachNode((t11) => this._disableSetForNode(e10, t11)));
  }
  _disableSetForNode(e10, t11) {
    e10.enabled || this._context.removeHighlight(t11, e10.id);
  }
  nodeAdded(e10) {
    this._highlights.forEach((t11) => this._enableSetForNode(t11, e10));
  }
  nodeRemoved(e10) {
    this._highlights.forEach((t11) => this._disableSetForNode(t11, e10));
  }
  removeAll() {
    this._highlights.forEach((e10) => this._disableSet(e10));
  }
};
var o8 = class {
  constructor(e10) {
    this.id = new r5(u5.Highlight), this.ids = /* @__PURE__ */ new Map(), this.enabled = false;
    for (const i5 of e10)
      r(i5) && this._add(i5.nodeId, i5.pointId);
  }
  _add(e10, t11) {
    const i5 = this.ids.get(e10);
    i5 ? i5.add(t11) : this.ids.set(e10, /* @__PURE__ */ new Set([t11]));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/PointRendererTechnique.js
var m3 = class extends e5 {
  constructor(e10, r8, t11) {
    super(e10, r8, t11);
  }
  initializeProgram(e10) {
    const r8 = m3.shader.get().build(this.configuration);
    return new o4(e10.rctx, r8, E4);
  }
  initializePipeline() {
    return W2({ depthTest: { func: I.LESS }, depthWrite: a3, colorWrite: c3, stencilWrite: this.configuration.hasOccludees ? e6 : null, stencilTest: this.configuration.hasOccludees ? f3 : null });
  }
};
m3.shader = new t5(f4, () => import("./PointRenderer.glsl-LWN7NXPY.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/PointRendererTechniqueConfiguration.js
var i4 = class extends i2 {
  constructor() {
    super(...arguments), this.output = o3.Color, this.hasSlicePlane = false, this.drawScreenSize = false, this.hasOccludees = false;
  }
};
e([e7({ count: o3.COUNT })], i4.prototype, "output", void 0), e([e7()], i4.prototype, "hasSlicePlane", void 0), e([e7()], i4.prototype, "drawScreenSize", void 0), e([e7()], i4.prototype, "hasOccludees", void 0), e([e7({ constValue: true })], i4.prototype, "hasSliceInVertexProgram", void 0);

// node_modules/@arcgis/core/views/3d/layers/i3s/PointRenderer.js
var K2 = { positions: [new t2(O.POSITION, 3, C3.FLOAT, 0, 12)], colors: [new t2(O.COLOR, 3, C3.UNSIGNED_BYTE, 0, 3, true)] };
var Q = class {
  constructor(e10) {
    this._params = e10, this.type = i3.PCL, this.isGround = false, this._highlights = new s4({ forEachNode: (e11) => this.forEachNode(e11), addHighlight: (e11, i5, t11) => this._addHighlight(e11, i5, t11), removeHighlight: (e11, i5) => this._removeHighlight(e11, i5) }), this.canRender = true, this.layerUid = "", this._useFixedSizes = false, this._scaleFactor = 1, this._minSizePx = 0, this._useRealWorldSymbolSizes = false, this._size = 0, this._sizePx = 0, this._slicePlaneEnabled = false, this._clipBox = a(C2), this._techniqueConfig = new i4(), this.tempMatrix4 = e4(), this.tempVec3 = n7(), this.nodes = new n2();
  }
  get needsHighlight() {
    return this._highlights.hasHighlights;
  }
  initializeRenderContext(e10) {
    this._context = e10, this._techniqueRep = this._context.shaderTechniqueRepository, e10.requestRender();
  }
  uninitializeRenderContext() {
  }
  intersect(e10, i5, t11, s5) {
    const n11 = n4(), r8 = n4(), o9 = n4(), h4 = n4(), g5 = p3(), p4 = e10.camera.perScreenPixelRatio / 2, x3 = e10.camera.near, w = this._getSizeParams();
    e3(r8, s5, t11);
    const R = 1 / s3(r8);
    q(r8, r8, R), j(o9, r8), r2(g5, r8[0], r8[1], r8[2], -P(r8, t11));
    const y = new re(), H = new re(), T2 = new Array(), L3 = a(), F2 = a(this._clipBox);
    V(F2, -t11[0], -t11[1], -t11[2], F2), this.nodes.forAll((l5) => {
      const c8 = l5.splatSize * this._scaleFactor;
      let d5 = L2(l5.obb, g5), f5 = N(l5.obb, g5);
      d5 -= ee(c8, d5 + x3, w, p4, l5.isLeaf), f5 -= ee(c8, f5 + x3, w, p4, l5.isLeaf);
      const _ = f5 < 0, S = null != y.dist && null != H.dist && y.dist < d5 * R && H.dist > f5 * R;
      if (_ || S)
        return;
      const A4 = $(c8, f5 + x3, w, p4, l5.isLeaf);
      if (!P2(l5.obb, t11, r8, A4))
        return;
      const q2 = A4 * A4;
      K(l5.obb, L3), V(L3, -t11[0], -t11[1], -t11[2], L3);
      const E6 = !b2(F2, L3);
      e3(h4, l5.origin, t11);
      const V3 = l5.coordinates.length / 3;
      for (let a6 = 0; a6 < V3; a6++) {
        if (n11[0] = h4[0] + l5.coordinates[3 * a6], n11[1] = h4[1] + l5.coordinates[3 * a6 + 1], n11[2] = h4[2] + l5.coordinates[3 * a6 + 2], E6 && !E2(F2, n11))
          continue;
        const d6 = P(n11, r8), g6 = v(n11) - d6 * d6;
        if (g6 > q2)
          continue;
        let f6 = d6 + x3;
        const _2 = ee(c8, f6, w, p4, l5.isLeaf);
        if (d6 - _2 < 0)
          continue;
        f6 -= _2;
        const S2 = $(c8, f6, w, p4, l5.isLeaf);
        if (g6 > S2 * S2)
          continue;
        const z = (d6 - _2) * R, b3 = (e11) => (e11.point = ie(l5, a6, e11.point), e11.dist = z, e11.normal = o9, e11.node = l5, e11.pointId = a6, e11.layerUid = this.layerUid, e11);
        if ((null == y.dist || z < y.dist) && (null == i5 || i5(t11, s5, z)) && b3(y), e10.options.store !== t7.MIN && (null == H.dist || z > H.dist) && (null == i5 || i5(t11, s5, z)) && b3(H), e10.options.store === t7.ALL && (null == i5 || i5(t11, s5, z))) {
          const e11 = new re();
          T2.push(b3(e11));
        }
      }
    });
    const V2 = (e11) => {
      const { layerUid: i6, node: t12, pointId: s6 } = e11;
      return { point: e11.point, layerUid: i6, graphicUid: s6, createGraphic: () => this._params.createGraphic(t12, s6, e11.point) };
    }, U3 = (e11, i6) => {
      const t12 = V2(i6);
      e11.set(this.type, t12, i6.dist, i6.normal);
    };
    if (oe(y)) {
      const i6 = e10.results.min;
      (null == i6.dist || y.dist < i6.dist) && U3(i6, y);
    }
    if (oe(H) && e10.options.store !== t7.MIN) {
      const i6 = e10.results.max;
      (null == i6.dist || H.dist > i6.dist) && U3(i6, H);
    }
    if (e10.options.store === t7.ALL) {
      const i6 = p2(t11, s5);
      for (const t12 of T2) {
        const s6 = U2(i6);
        U3(s6, t12), e10.results.all.push(s6);
      }
    }
  }
  prepareTechnique(e10) {
    if (0 === this.nodes.length || e10.pass !== A2.MATERIAL && e10.pass !== A2.MATERIAL_DEPTH && e10.pass !== A2.MATERIAL_HIGHLIGHT)
      return null;
    this.nodes.forAll((i6) => {
      null == i6.vao && this._initNode(e10, i6);
    });
    const i5 = this._getSizeParams();
    return this._techniqueConfig.drawScreenSize = i5.drawScreenSpace, this._techniqueConfig.hasSlicePlane = this._slicePlaneEnabled, this._techniqueConfig.hasOccludees = e10.bindParameters.hasOccludees, this._techniqueConfig.output = e10.pass === A2.MATERIAL_DEPTH ? o3.Depth : e10.pass === A2.MATERIAL_HIGHLIGHT ? o3.Highlight : o3.Color, this._techniqueRep.releaseAndAcquire(m3, this._techniqueConfig, this._technique);
  }
  render(e10, i5) {
    const t11 = e10.rctx, s5 = t11.bindTechnique(i5, he, e10.bindParameters), n11 = e10.bindParameters.camera, h4 = this._clipBox, a6 = !k(h4, C2, (e11, i6) => e11 === i6);
    a6 || (o2(this.tempVec3, -1 / 0, -1 / 0, -1 / 0), s5.setUniform3fv("clipMin", this.tempVec3), o2(this.tempVec3, 1 / 0, 1 / 0, 1 / 0), s5.setUniform3fv("clipMax", this.tempVec3));
    const l5 = this._getSizeParams(), c8 = n11.pixelRatio;
    l5.drawFixedSize && s5.setUniform2f("pointScale", l5.fixedSize * c8, n11.fullHeight), this.nodes.forAll((d5) => {
      if (0 === d5.coordinates.length || e10.isHighlightPass && !d5.highlights)
        return;
      if (s5.setUniform2f("screenMinMaxSize", l5.screenMinSize * c8, Z(d5.isLeaf) * c8), !l5.drawFixedSize) {
        const e11 = d5.splatSize * this._scaleFactor;
        s5.setUniform2f("pointScale", e11 * c8, n11.fullHeight / c8);
      }
      const u10 = d5.origin;
      a6 && (o2(this.tempVec3, h4[0] - u10[0], h4[1] - u10[1], h4[2] - u10[2]), s5.setUniform3fv("clipMin", this.tempVec3), o2(this.tempVec3, h4[3] - u10[0], h4[4] - u10[1], h4[5] - u10[2]), s5.setUniform3fv("clipMax", this.tempVec3)), x(this.tempMatrix4, u10), u3(this.tempMatrix4, n11.viewMatrix, this.tempMatrix4), s5.setUniformMatrix4fv("modelView", this.tempMatrix4), i5.bindDraw(new m2(u10), e10.bindParameters), t11.bindVAO(d5.vao), e10.isHighlightPass ? this._renderHighlightFragments(t11, d5) : t11.drawArrays(E3.POINTS, 0, d5.coordinates.length / 3);
    });
  }
  _renderHighlightFragments(e10, s5) {
    const n11 = s5.highlights;
    if (t(n11))
      return;
    let r8 = e2(n11[0].component), o9 = r8 + 1;
    for (let i5 = 1; i5 < n11.length; i5++) {
      const s6 = e2(n11[i5].component);
      if (s6 !== o9) {
        const i6 = o9 - r8;
        i6 > 0 && e10.drawArrays(E3.POINTS, r8, i6), r8 = s6;
      }
      o9 = s6 + 1;
    }
    const h4 = o9 - r8;
    h4 > 0 && e10.drawArrays(E3.POINTS, r8, h4);
  }
  set useFixedSizes(e10) {
    this._useFixedSizes !== e10 && (this._useFixedSizes = e10, this._requestRender());
  }
  get useFixedSizes() {
    return this._useFixedSizes;
  }
  set scaleFactor(e10) {
    this._scaleFactor !== e10 && (this._scaleFactor = e10, this._requestRender());
  }
  get scaleFactor() {
    return this._scaleFactor;
  }
  set minSizePx(e10) {
    this._minSizePx !== e10 && (this._minSizePx = e10, this._requestRender());
  }
  get minSizePx() {
    return this._minSizePx;
  }
  set useRealWorldSymbolSizes(e10) {
    this._useRealWorldSymbolSizes !== e10 && (this._useRealWorldSymbolSizes = e10, this._requestRender());
  }
  get useRealWorldSymbolSizes() {
    return this._useRealWorldSymbolSizes;
  }
  set size(e10) {
    this._size !== e10 && (this._size = e10, this._requestRender());
  }
  get size() {
    return this._size;
  }
  set sizePx(e10) {
    this._sizePx !== e10 && (this._sizePx = e10, this._requestRender());
  }
  get sizePx() {
    return this._sizePx;
  }
  set clippingBox(e10) {
    A(this._clipBox, e10 || C2);
  }
  get slicePlaneEnabled() {
    return this._slicePlaneEnabled;
  }
  set slicePlaneEnabled(e10) {
    this._slicePlaneEnabled !== e10 && (this._slicePlaneEnabled = e10, this._requestRender());
  }
  addNode(e10) {
    this.nodes.push(e10), this._highlights.nodeAdded(e10), this._requestRender();
  }
  removeNode(e10) {
    let i5 = null;
    return this.nodes.filterInPlace((t11) => t11.id !== e10 || (i5 = t11, t11.vao = s(t11.vao), this._highlights.nodeRemoved(t11), false)), this._requestRender(), i5;
  }
  forEachNode(e10) {
    this.nodes.forAll(e10);
  }
  removeAll() {
    this.nodes.forAll((e10) => e10.vao = s(e10.vao)), this._highlights.removeAll(), this.nodes.clear(), this._requestRender();
  }
  highlight(e10) {
    return this._highlights.add(e10);
  }
  _addHighlight(e10, i5, t11) {
    e10.highlights = se(e10.highlights, i5, t11), this._requestRender();
  }
  _removeHighlight(e10, i5) {
    e10.highlights = ne(e10.highlights, i5), this._requestRender();
  }
  _initNode(e10, i5) {
    const t11 = e10.rctx;
    i5.vao = new f2(t11, E4, K2, { positions: c2.createVertex(t11, F.STATIC_DRAW, i5.coordinates), colors: c2.createVertex(t11, F.STATIC_DRAW, i5.rgb) });
  }
  _requestRender() {
    this._context && this._context.requestRender();
  }
  _getSizeParams() {
    const e10 = this._useFixedSizes, i5 = e10 && !this._useRealWorldSymbolSizes;
    return { drawScreenSpace: i5, drawFixedSize: e10, fixedSize: i5 ? this._sizePx : this._size, screenMinSize: e10 ? 0 : this._minSizePx };
  }
};
function X(e10) {
  return e10.hasOwnProperty("splatSize");
}
function Z(e10) {
  return e10 ? 256 : 64;
}
function $(e10, i5, t11, s5, n11) {
  if (t11.drawScreenSpace)
    return t11.fixedSize * i5 * s5;
  const r8 = Z(n11) * i5 * s5;
  return t11.drawFixedSize ? Math.min(t11.fixedSize / 2, r8) : t11.screenMinSize > 0 ? Math.min(Math.max(t11.screenMinSize * i5 * s5, e10 / 2), r8) : Math.min(e10 / 2, r8);
}
function ee(e10, i5, t11, s5, n11) {
  return t11.drawScreenSpace ? 0 : $(e10, i5, t11, s5, n11);
}
function ie(e10, t11, s5) {
  return t(s5) && (s5 = n4()), s5[0] = e10.origin[0] + e10.coordinates[3 * t11], s5[1] = e10.origin[1] + e10.coordinates[3 * t11 + 1], s5[2] = e10.origin[2] + e10.coordinates[3 * t11 + 2], s5;
}
function te(i5) {
  return r(i5.component) ? i5.component : -1;
}
function se(e10, t11, s5) {
  t(e10) && (e10 = []);
  const n11 = { component: t11, id: s5 };
  e10.push(n11);
  const r8 = te(n11);
  let o9 = e10.length - 1;
  for (; o9 > 0 && r8 < te(e10[o9 - 1]); )
    [e10[o9 - 1], e10[o9]] = [e10[o9], e10[o9 - 1]], --o9;
  return e10;
}
function ne(e10, t11) {
  if (t(e10))
    return e10;
  const s5 = e10.filter((e11) => e11.id !== t11);
  return 0 === s5.length ? null : s5;
}
var re = class {
  constructor() {
    this.node = null, this.pointId = null, this.point = null, this.dist = null, this.normal = null, this.layerUid = "";
  }
};
function oe(i5) {
  return r(i5.dist) && r(i5.point) && r(i5.pointId) && r(i5.node);
}
var he = new t3();

// node_modules/@arcgis/core/views/3d/layers/PointCloudLayerView3D.js
var ce = s2.getLogger("esri.views.3d.layers.PointCloudLayerView3D");
var _e2 = 8;
var me = p3();
var ge = class extends c6(n8(u6)) {
  constructor() {
    super(...arguments), this.type = "point-cloud-3d", this.maximumPointCount = 4e6, this.slicePlaneEnabled = false, this._renderer = null, this._rendererAdded = false, this._renderedNodes = /* @__PURE__ */ new Set(), this._nodeScales = /* @__PURE__ */ new Map(), this._updateViewNeeded = true, this._lodFactor = 1, this._maxLoggedBoxWarnings = 5, this._pageMultiplier = 1, this._nodeLoadEpoch = 0, this._indexQueue = [], this._workQueue = new Array(), this._idleQueue = new i(), this._indexPagesLoading = /* @__PURE__ */ new Map(), this._loadingNodes = /* @__PURE__ */ new Map(), this._recalcWork = true, this._layerIsVisible = false, this._codedDomainPopulationPromise = null, this._codedDomainPopulationAbortController = null, this._totalWork = 0, this._index = null, this._loadingInitNodePage = false, this._nodeIdArray = [];
  }
  get pointScale() {
    const e10 = n10(this.layer && this.layer.renderer), t11 = 1;
    return e10 && null != e10.scaleFactor ? e10.scaleFactor : t11;
  }
  get useRealWorldSymbolSizes() {
    const e10 = o7(this.layer && this.layer.renderer), t11 = false;
    return e10 && null != e10.useRealWorldSymbolSizes ? e10.useRealWorldSymbolSizes : t11;
  }
  get pointSize() {
    const e10 = o7(this.layer && this.layer.renderer), t11 = 0;
    return e10 && null != e10.size ? e10.size : t11;
  }
  get inverseDensity() {
    const e10 = 96;
    return this.layer && this.layer.renderer ? 1 * e10 / this.layer.renderer.pointsPerInch : 5;
  }
  get availableFields() {
    const e10 = t9(this.layer), t11 = /* @__PURE__ */ new Set();
    e10.primaryAttribute && t11.add(e10.primaryAttribute.name), e10.modulationAttribute && t11.add(e10.primaryAttribute.name);
    const i5 = e9(this.layer);
    if (i5)
      for (const r8 of i5)
        t11.add(r8.attributeInfo.name);
    if (this.layer.outFields)
      for (const r8 of I2(this.layer.fieldsIndex, this.layer.outFields))
        t11.add(r8);
    return Array.from(t11);
  }
  get _clippingBox() {
    if (!this.view || !this.view.clippingArea)
      return null;
    const e10 = a(), t11 = this.view.renderSpatialReference;
    return x2(this.view.clippingArea, e10, t11) ? e10 : null;
  }
  get _elevationOffset() {
    const e10 = this.layer && this.layer.elevationInfo;
    if (e10 && "absolute-height" === e10.mode) {
      const t11 = W(this.layer.spatialReference), i5 = r3(e10.unit);
      return c(e10.offset, 0) * i5 / t11;
    }
    return 0;
  }
  initialize() {
    const e10 = this.view.resourceController;
    this._worker = new e8((t12) => e10.schedule(t12)), this.addResolvingPromise(this._worker.promise), this._tmpPoint = v2(0, 0, 0, this.layer.spatialReference), Ue(this.layer), _e(this.layer, this.view), this._indexRequester = e10.createStreamDataRequester(A3.I3S_INDEX), this._dataRequester = e10.createStreamDataRequester(A3.I3S_DATA), this._initRenderer();
    const t11 = this._initNodePages(), i5 = this.view.resourceController.memoryController;
    this._memCache = i5.newCache(this.layer.uid), this.updatingHandles.add(() => this._clippingBox, () => this._setUpdateViewNeeded(), h), this.updatingHandles.add(() => this._elevationOffset, () => this._elevationOffsetChanged(), h), this.updatingHandles.add(() => this.layer.renderer, () => this._rendererChanged(), h), this.updatingHandles.add(() => this.layer.filters, () => this._reload(), h), this.updatingHandles.add(() => this.layer.outFields, () => this._reload(), h), this.updatingHandles.add(() => this.layer.effectiveScaleRange, () => this._setUpdateViewNeeded()), this.updatingHandles.add(() => this.view.state.contentCamera, () => this._setUpdateViewNeeded()), this.handles.add([this.view.basemapTerrain.on("scale-change", (e11) => this._scaleUpdateHandler(e11)), l(() => i5.memoryFactor, () => this._setUpdateViewNeeded(), U)]), this.addResolvingPromise(t11), this.when(() => {
      this.handles.add([e10.scheduler.registerTask(L.POINT_CLOUD_LAYER, this), e10.scheduler.registerIdleStateCallbacks(() => this._idleBegin(), () => this._idleEnd()), this.updatingHandles.add(() => this.suspended, (e11) => {
        e11 ? this._clearNodeState() : this._setUpdateViewNeeded();
      }, h)]);
    }, () => {
      this.updatingHandles.removeAll(), this.handles.removeAll();
    });
  }
  _setUpdateViewNeeded() {
    this._updateViewNeeded = true, this._updateLoading();
  }
  destroy() {
    this.cancelLoading(), this._worker && (this._worker.destroy(), this._worker = null), this._destroyRenderer(), this._memCache.destroy(), this._memCache = null, this._codedDomainPopulationAbortController && (this._codedDomainPopulationAbortController.abort(), this._codedDomainPopulationAbortController = null), this._codedDomainPopulationPromise = null;
  }
  _initRenderer() {
    this._renderer = new Q({ createGraphic: (e10, t11, i5) => this._createGraphic(e10, t11, i5) }), this._renderer.layerUid = this.layer.uid, this.updatingHandles.add(() => this._clippingBox, (e10) => this._renderer.clippingBox = e10, h), this.updatingHandles.add(() => this.suspended, (e10) => this._setPointsVisible(!e10), h), this.updatingHandles.add(() => this.pointScale, (e10) => this._renderer.scaleFactor = e10, h), this._renderer.minSizePx = Math.sqrt(2), this.updatingHandles.add(() => this.useRealWorldSymbolSizes, (e10) => this._renderer.useRealWorldSymbolSizes = e10, h), this.updatingHandles.add(() => this.pointSize, (e10) => {
      const t11 = u2(e10);
      this._renderer.size = e10, this._renderer.sizePx = t11;
    }, h), this.updatingHandles.add(() => this.slicePlaneEnabled, (e10) => this._renderer.slicePlaneEnabled = e10, h), this.updatingHandles.add(() => this.inverseDensity, () => this._setUpdateViewNeeded(), h), this.updatingHandles.add(() => this.maximumPointCount, () => this._setUpdateViewNeeded(), h), this.updatingHandles.add(() => this.view.qualitySettings.sceneService.pointCloud.lodFactor, (e10) => {
      this._lodFactor = e10, this._setUpdateViewNeeded();
    }, h);
  }
  _destroyRenderer() {
    this._renderer.removeAll(), this._setPointsVisible(false);
  }
  _createGraphic(e10, t11, i5) {
    const r8 = r(e10.pointIdFilterMap) ? e10.pointIdFilterMap[t11] : t11, s5 = this.view.computeMapPointFromVec3d(i5), o9 = this._createGraphicAttributes(e10, r8);
    return new t10({ pointCloudMetadata: { nodeId: e10.id, pointIndexInNode: t11, attributePointIndexInNode: r8, epoch: this._nodeLoadEpoch }, geometry: s5, attributes: o9, layer: this.layer, sourceLayer: this.layer });
  }
  _createGraphicAttributes(e10, t11) {
    const i5 = {};
    for (const r8 of e10.attributes)
      this._encodeGraphicAttribute(r8.attributeInfo, r8.values, t11, i5);
    return i5;
  }
  _encodeGraphicAttribute(e10, t11, i5, r8) {
    const s5 = e10.storageInfo && e10.storageInfo.attributeValues, o9 = s5 ? s5.valuesPerElement : 1;
    if (1 === o9)
      r8[e10.name] = t11[i5];
    else if ("UInt8" === s5.valueType && o9 <= 4) {
      let s6 = 0;
      const n11 = i5 * o9;
      for (let e11 = n11; e11 < n11 + o9; e11++)
        s6 = (s6 << 8) + t11[e11];
      r8[e10.name] = s6;
    } else
      r8[e10.name] = void 0;
  }
  _setPointsVisible(e10) {
    e10 && !this._rendererAdded ? (this.view._stage.addRenderPlugin([E5.OPAQUE_MATERIAL], this._renderer), this._rendererAdded = true) : !e10 && this._rendererAdded && (this.view._stage.removeRenderPlugin(this._renderer), this._rendererAdded = false);
  }
  _rendererChanged() {
    this._renderer.useFixedSizes = r7(this.layer.renderer), this._reload();
  }
  _reload() {
    this._clearNodeState(), this._memCache.clear(), this._setUpdateViewNeeded();
  }
  _elevationOffsetChanged() {
    this._clearNodeState(), this._memCache.clear(), this._initNodePages();
  }
  _scaleUpdateHandler(e10) {
    const t11 = this.layer.effectiveScaleRange;
    o5(t11.minScale, t11.maxScale) ? zn(e10.extent, e10.spatialReference, be, this.layer.spatialReference) && (this._nodeScales.forEach((t12, i5) => {
      if (!this._renderedNodes.has(i5))
        return void this._nodeScales.delete(i5);
      const r8 = this._index.getNode(i5);
      b(be, r8.obb.center) && this._nodeScales.set(i5, e10.scale);
    }), this._setUpdateViewNeeded()) : this._nodeScales.clear();
  }
  _displayNodes(e10) {
    this._workQueue = t8([...this._renderedNodes], e10, this._index), g3(this._workQueue, this.view.state.contentCamera.viewForward, this._index), u7(this._workQueue, _e2, this._index), this._updateQueues(), this._totalWork = this._computeWork(), this._updateLoading(), this._layerIsVisible = e10.length > 0 || this._loadingInitNodePage, this.notifyChange("suspended");
  }
  cancelLoading() {
    this._cancelNodeLoading(), this._cancelIndexLoading();
  }
  _cancelNodeLoading() {
    const e10 = new Array();
    this._loadingNodes.forEach(({ abortController: t11 }) => e10.push(t11)), this._loadingNodes.clear();
    for (const t11 of e10)
      t11.abort();
    this._workQueue = [], this._idleQueue.cancelAll(), this._totalWork = this._computeWork(), this._updateLoading();
  }
  _updateQueues() {
    const e10 = /* @__PURE__ */ new Set();
    this._workQueue.forEach((t12) => t12.load.forEach((t13) => e10.add(t13)));
    const t11 = new Array(), i5 = /* @__PURE__ */ new Map();
    this._loadingNodes.forEach((r8, s5) => {
      e10.has(s5) ? i5.set(s5, r8) : t11.push(r8);
    }), this._loadingNodes = i5;
    for (const { abortController: r8 } of t11)
      r8.abort();
    this._workQueue = this._workQueue.filter((e11) => {
      for (const t12 of e11.load)
        if (this._loadingNodes.has(t12))
          return this._recalcWork = true, false;
      return true;
    }), this._totalWork = this._computeWork(), this._updateLoading();
  }
  _cancelIndexLoading() {
    this._indexQueue = [], this._indexPagesLoading.forEach(({ abortController: e10 }) => e10.abort()), this._indexPagesLoading.clear(), this._totalWork = this._computeWork(), this._updateLoading();
  }
  _clearNodeState() {
    this._nodeLoadEpoch++, this._renderedNodes.forEach((e10) => this._removeFromRenderer(e10)), this._cancelNodeLoading();
  }
  _idleBegin() {
    this._setUpdateViewNeeded();
  }
  _idleEnd() {
    this._setUpdateViewNeeded();
  }
  get running() {
    return this.suspended ? this._updateViewNeeded : this._updateViewNeeded || this._indexQueue.length > 0 || this._workQueue.length > 0 || this._idleQueue.running;
  }
  runTask(e10) {
    if (this.suspended) {
      if (this._updateViewNeeded) {
        this._updateViewNeeded = false;
        const e11 = this._isRootNodeVisible();
        e11 !== this._layerIsVisible && (this._layerIsVisible = e11, this.notifyChange("suspended")), this._updateLoading();
      }
    } else {
      for (e10.run(() => this._updateWorkQueues()); this._indexQueue.length > 0 && e10.run(() => this._processIndexQueue()); )
        ;
      this._processWorkQueue(e10), this._idleQueue.runTask(e10);
    }
  }
  _processIndexQueue() {
    const e10 = this._indexQueue.shift(), t11 = this._loadNodePage(e10);
    return this._indexPagesLoading.set(e10, t11), t11.promise.then((t12) => {
      this._index.addPage(e10, t12, this._elevationOffset), this._setUpdateViewNeeded();
    }).then(() => {
      this._indexPagesLoading.delete(e10);
    }, () => {
      this._indexPagesLoading.delete(e10);
    }), true;
  }
  _processWorkQueue(e10) {
    for (; !e10.done; ) {
      const t11 = this._scheduleWorkEntry();
      if (t(t11))
        return;
      this._processWorkEntry(t11), e10.madeProgress();
    }
  }
  _scheduleWorkEntry() {
    let e10 = this._workQueue.length;
    for (; e10--; ) {
      const e11 = this._workQueue.shift();
      if (!e11.remove.find((e12) => !this._renderedNodes.has(e12)))
        return e11;
      this._workQueue.push(e11);
    }
    return null;
  }
  _processWorkEntry(e10) {
    if (0 !== e10.load.length)
      Promise.all(e10.load.map((e11) => {
        const t11 = new AbortController(), i5 = this._memCache.pop(e11.toString());
        return r(i5) ? this._loadingNodes.set(e11, { abortController: t11, promise: Promise.resolve(i5) }) : this._loadingNodes.has(e11) || this._loadingNodes.set(e11, { abortController: t11, promise: this._loadNode(e11, t11.signal) }), this._loadingNodes.get(e11).promise;
      })).then((t11) => {
        for (let i5 = 0; i5 < e10.load.length; i5++)
          if (t11[i5]) {
            const r8 = this._setupRendererData(e10.load[i5], t11[i5]);
            this._addToRenderer(r8);
          }
        for (const i5 of e10.remove)
          this._removeFromRenderer(i5);
      }).catch(() => {
      }).then(() => {
        for (const t11 of e10.load)
          this._loadingNodes.delete(t11);
        this._updateLoading(), this._recalcWork && !this._idleQueue.running && 0 === this._indexQueue.length && 0 === this._loadingNodes.size && (this._recalcWork = false, this._setUpdateViewNeeded());
      }), this._updateLoading();
    else
      for (const t11 of e10.remove)
        this._removeFromRenderer(t11);
  }
  async _populateClassCodeCodedDomain(e10, i5) {
    const r8 = "CLASS_CODE", s5 = this.layer.fieldsIndex.get(r8);
    if (!s5 || s5.domain)
      return;
    if (!e10.includes(s5.name))
      return;
    const o9 = await a2(this.layer.queryCachedStatistics(r8, { signal: i5 }));
    if (false === o9.ok)
      return;
    const n11 = o9.value, a6 = n11 && n11.labels && n11.labels.labels;
    a6 && Array.isArray(a6) && (s5.domain = new u({ name: "CLASS_CODE", codedValues: a6.map((e11) => new p({ code: e11.value, name: e11.label })) }));
  }
  async prepareFetchPopupFeatures(e10) {
    return this._codedDomainPopulationPromise || (this._codedDomainPopulationAbortController = new AbortController(), this._codedDomainPopulationPromise = this._populateClassCodeCodedDomain(e10, this._codedDomainPopulationAbortController.signal).then(() => {
      this._codedDomainPopulationAbortController = null;
    })), this._codedDomainPopulationPromise;
  }
  async whenGraphicAttributes(e10, t11) {
    const r8 = this._splitGraphicsPerNode(e10), s5 = this.layer.attributeStorageInfo, o9 = t11.map((e11) => u9(s5, e11)), n11 = async (e11, t12) => {
      const r9 = this._index.getNode(t12);
      await n5(o9, async (t13) => {
        const i5 = t13.useElevation ? await this._loadElevationAttributeFromGeometry(r9.resourceId) : await this._loadAndParseAttribute(r9, t13);
        if (i5) {
          for (const r10 of e11)
            if (this._isValidPointGraphic(r10)) {
              const e12 = r10.pointCloudMetadata.attributePointIndexInNode;
              this._encodeGraphicAttribute(t13, i5, e12, r10.attributes);
            }
        }
      });
    }, a6 = [];
    return r8.forEach((e11, t12) => {
      a6.push(n11(e11, t12));
    }), await E(a6), e10;
  }
  _isValidPointGraphic(e10) {
    return e10 instanceof t10 && e10.pointCloudMetadata && e10.pointCloudMetadata.epoch === this._nodeLoadEpoch;
  }
  _splitGraphicsPerNode(e10) {
    const t11 = /* @__PURE__ */ new Map();
    for (const i5 of e10) {
      if (!this._isValidPointGraphic(i5))
        continue;
      const e11 = i5.pointCloudMetadata, r8 = t11.get(e11.nodeId);
      r8 ? r8.push(i5) : t11.set(e11.nodeId, [i5]);
    }
    return t11;
  }
  async _loadAndParseAttribute(e10, t11) {
    const i5 = await this._loadAttribute(e10.resourceId, t11, null);
    return r(i5) ? a4({ attributeInfo: t11, buffer: i5 }, null, e10.vertexCount) : null;
  }
  async _loadElevationAttributeFromGeometry(e10) {
    const t11 = this.layer.store.defaultGeometrySchema, i5 = c4(t11, await this._loadGeometry(e10, null));
    return d3(i5, i5.length / 3);
  }
  highlight(e10) {
    if (!e10)
      return { remove() {
      } };
    const t11 = j2.isCollection(e10) ? e10.toArray() : Array.isArray(e10) ? e10 : [e10];
    return this._renderer.highlight(t11.map((e11) => this._graphicToPointDefinition(e11)));
  }
  _graphicToPointDefinition(e10) {
    if (!this._isValidPointGraphic(e10))
      return null;
    const { nodeId: t11, pointIndexInNode: i5 } = e10.pointCloudMetadata;
    return null != t11 && null != i5 ? { nodeId: t11, pointId: i5 } : null;
  }
  _computeWork() {
    let e10 = 0;
    for (const t11 of this._workQueue)
      e10 += t11.load.length + t11.remove.length;
    return e10 += this._loadingNodes.size, e10 += (this._indexQueue.length + this._indexPagesLoading.size) * this._index.pageSize, e10 += this._loadingInitNodePage ? 100 : 0, e10 += this._updateViewNeeded ? 100 : 0, e10;
  }
  get updatingProgressValue() {
    if (this.suspended)
      return this._updateViewNeeded ? 0 : 1;
    const e10 = this._computeWork();
    return 1 - Math.min(this._totalWork, e10) / this._totalWork;
  }
  _updateLoading() {
    this.notifyChange("updating"), this.notifyChange("updatingProgressValue");
  }
  canResume() {
    return super.canResume() && this._layerIsVisible;
  }
  isUpdating() {
    return this.suspended ? this._updateViewNeeded : this._computeWork() > 0;
  }
  _initNodePages() {
    const e10 = this.layer.store.index, t11 = e10.nodesPerPage || e10.nodePerIndexBlock;
    return this._index = new h3(this.layer.spatialReference, this.view.renderCoordsHelper.spatialReference, t11), this._cancelIndexLoading(), this._traverseVisible = this._index.createVisibilityTraverse(), this._loadingInitNodePage = true, this._layerIsVisible = true, this.notifyChange("suspended"), this._updateLoading(), this._pageMultiplier = null != e10.nodesPerPage ? 1 : e10.nodePerIndexBlock, this._loadNodePage(0).promise.then((e11) => {
      this._index.addPage(0, e11, this._elevationOffset), this._loadingInitNodePage = false, this._setUpdateViewNeeded();
    });
  }
  _loadNodePage(e10) {
    const t11 = new AbortController(), i5 = `${this.baseUrl}/nodepages/${e10 * this._pageMultiplier}`;
    return { promise: this._requestNodePage(i5, t11.signal).then((t12) => t12.nodes.map((t13, i6) => ({ resourceId: null != t13.resourceId ? t13.resourceId : e10 * this._index.pageSize + i6, obb: t13.obb, firstChild: t13.firstChild, childCount: t13.childCount, vertexCount: null != t13.vertexCount ? t13.vertexCount : t13.pointCount, lodThreshold: null != t13.lodThreshold ? t13.lodThreshold : t13.effectiveArea }))), abortController: t11 };
  }
  _updateWorkQueues() {
    if (!this._updateViewNeeded)
      return false;
    let e10 = this.inverseDensity / this._lodFactor * this._getLodMemoryFactor();
    const t11 = this.maximumPointCount * this._lodFactor * this._getLodMemoryFactor();
    let i5 = this._computeNodesForMinimumDensity(e10), r8 = this._computePointCount(i5), s5 = Math.sqrt(r8 / (0.75 * t11));
    for (; r8 > t11; )
      e10 *= s5, i5 = this._computeNodesForMinimumDensity(e10), r8 = this._computePointCount(i5), s5 = Math.sqrt(2);
    return this._displayNodes(i5), this._updateViewNeeded = false, this._updateLoading(), true;
  }
  _computePointCount(e10) {
    let t11 = 0;
    for (let i5 = 0; i5 < e10.length; i5++) {
      const r8 = this._index.getNode(e10[i5]);
      r8 && (t11 += r8.vertexCount);
    }
    return t11;
  }
  _getLodMemoryFactor() {
    return this.view.resourceController.memoryController.memoryFactor;
  }
  _isRootNodeVisible() {
    let e10 = false;
    return this._traverseVisible({ frustum: this.view.state.contentCamera.frustum, clippingBox: this._clippingBox }, { predicate: (t11, i5, r8) => (e10 = r8, false), pageMiss: () => {
    } }), e10;
  }
  _computeNodesForMinimumDensity(e10) {
    const t11 = this.view.state.contentCamera, i5 = t11.frustum, r8 = this._clippingBox, s5 = t11.viewForward, o9 = P(s5, t11.eye), n11 = T(s5, -o9, me), a6 = t11.perScreenPixelRatio / 2, d5 = e10 * e10, l5 = this._nodeIdArray;
    l5.length = 0;
    const { minScale: h4, maxScale: u10 } = r4(this.layer), p4 = 0 === h4 && 0 === u10 ? (e11) => l5.push(e11) : (e11) => {
      const t12 = this._getScale(e11);
      c5(t12, h4, u10) && l5.push(e11);
    };
    return this._traverseVisible({ frustum: i5, clippingBox: r8 }, { predicate: (e11, t12, i6) => {
      if (!i6)
        return false;
      if (0 === t12.childCount)
        return p4(e11), false;
      const r9 = this._index.getRenderObb(e11);
      return !(this._computeAveragePixelArea(r9, t12.lodThreshold, t12.vertexCount, n11, a6) <= d5) || (p4(e11), false);
    }, pageMiss: (e11, t12) => {
      p4(e11), this._indexQueue.includes(t12) || this._indexQueue.push(t12);
    } }), l5;
  }
  _getScale(e10) {
    let t11 = this._nodeScales.get(e10);
    if (null == t11) {
      const i5 = this._index.getNode(e10).obb.center;
      this._tmpPoint.x = i5[0], this._tmpPoint.y = i5[1], this._tmpPoint.z = i5[2], t11 = this.view.basemapTerrain.getScale(this._tmpPoint), this._nodeScales.set(e10, t11);
    }
    return t11;
  }
  _computeAveragePixelArea(e10, t11, i5, r8, s5) {
    const o9 = 1e-7, n11 = Math.max(o9, L2(e10, r8));
    return t11 / (n11 * n11) / (4 * s5 * s5) / i5;
  }
  _loadNode(e10, t11) {
    try {
      return this._loadNodeAsync(e10, t11);
    } catch (i5) {
      throw g(i5) || ce.error(i5), i5;
    }
  }
  async _loadAdditionalUserAttributes(e10, t11, i5) {
    const r8 = this.layer.outFields;
    if (!r8)
      return [];
    const s5 = I2(this.layer.fieldsIndex, r8), o9 = new Set(e10.map((e11) => r(e11) ? e11.name : null)), a6 = this.layer.attributeStorageInfo, l5 = [];
    for (const n11 of s5) {
      if (o9.has(n11))
        continue;
      const e11 = u9(a6, n11);
      e11 && l5.push(t11(e11));
    }
    const h4 = await C(l5);
    return f(i5), d(h4, (e11) => e11);
  }
  async _loadNodeAsync(e10, t11) {
    const i5 = this._index.getNode(e10), r8 = t9(this.layer), s5 = e9(this.layer), o9 = i5.resourceId, d5 = async (e11) => {
      if (t(e11))
        return null;
      if (e11.useElevation)
        return { attributeInfo: e11, buffer: null };
      const i6 = await this._loadAttribute(o9, e11, t11);
      return r(i6) ? { attributeInfo: e11, buffer: i6 } : null;
    };
    return this._idleQueue.push(async () => {
      const i6 = this._loadGeometry(o9, t11), { primaryAttribute: n11, modulationAttribute: a6 } = r8, l5 = d5(n11), h4 = d5(a6), u10 = s5.map((e11) => e11.attributeInfo), c8 = u10.map((e11) => d5(e11)), _ = this._loadAdditionalUserAttributes([n11, a6, ...u10], d5, t11), [m4, g5, f5, y, b3] = await Promise.all([i6, l5, h4, Promise.all(c8), _]);
      f(t11);
      const w = { geometryBuffer: m4, primaryAttributeData: g5, modulationAttributeData: f5, filterAttributesData: y, userAttributesData: b3, schema: this.layer.store.defaultGeometrySchema, rendererInfo: r8, filterInfo: s5, obb: this._index.getRenderObb(e10), elevationOffset: this._elevationOffset, inSR: this.layer.spatialReference.toJSON(), outSR: this.view.renderCoordsHelper.spatialReference.toJSON() };
      return this._worker.invoke(w, t11);
    }, t11);
  }
  async _loadGeometry(e10, t11) {
    return this._requestData(`${this.baseUrl}/nodes/${e10}/geometries/0`, t11);
  }
  async _loadAttribute(e10, t11, i5) {
    if (t(t11) || !t11.storageInfo)
      return null;
    const r8 = t11.storageInfo.key;
    return this._requestData(`${this.baseUrl}/nodes/${e10}/attributes/${r8}`, i5);
  }
  _requestNodePage(e10, t11) {
    const i5 = { f: "json", token: this.layer.apiKey };
    return this._indexRequester.request(e10, "json", { query: i5, signal: t11 });
  }
  _requestData(e10, t11) {
    return this._dataRequester.request(e10, "binary", { query: { token: this.layer.apiKey }, signal: t11 });
  }
  _removeFromRenderer(e10) {
    if (this._renderedNodes.has(e10)) {
      const t11 = this._renderer.removeNode(e10);
      this._renderedNodes.delete(e10), this._nodeScales.delete(e10), this._memCache.put(t11.id.toString(), t11, ye(t11));
    }
  }
  _addToRenderer(e10) {
    this._renderedNodes.has(e10.id) || (this._renderedNodes.add(e10.id), this._renderer.addNode(e10));
  }
  _setupRendererData(e10, t11) {
    const i5 = this._index.getNode(e10), r8 = Math.sqrt(i5.lodThreshold / i5.vertexCount), s5 = this._index.getRenderObb(e10);
    if (X(t11))
      return t11.splatSize = r8, t11.obb = s5, t11.origin = t4(t11.obb.center), t11;
    const o9 = 0.01 * Math.max(s5.halfSize[0], s5.halfSize[1], s5.halfSize[2]);
    if (t11.obb.halfSize[0] > s5.halfSize[0] + o9 || t11.obb.halfSize[1] > s5.halfSize[1] + o9 || t11.obb.halfSize[2] > s5.halfSize[2] + o9) {
      if (this._maxLoggedBoxWarnings > 0) {
        const i6 = (e11) => `[${e11.halfSize[0]}, ${e11.halfSize[1]}, ${e11.halfSize[2]}]`;
        ce.warn(`Node ${e10} reported bounding box too small. got ${i6(s5)} but points cover ${i6(t11.obb)}`), 0 == --this._maxLoggedBoxWarnings && ce.warn("  Too many bounding box errors, stopping reporting for this layer.");
      }
      this._index.setRenderObb(e10, t11.obb);
    }
    return { id: e10, coordinates: t11.points, origin: t4(s5.center), rgb: t11.rgb, attributes: t11.attributes, pointIdFilterMap: t11.pointIdFilterMap, highlights: null, splatSize: r8, obb: s5, isLeaf: 0 === i5.childCount };
  }
  getUsedMemory() {
    let e10 = 0;
    return this._renderer.forEachNode((t11) => {
      e10 += we, e10 += m(t11.coordinates);
      for (const i5 of t11.attributes) {
        const t12 = i5.values;
        o(t12.buffer) && (e10 += m(t12));
      }
    }), e10;
  }
  getUnloadedMemory() {
    const e10 = this._renderedNodes.size;
    if (e10 < 4)
      return 0;
    const t11 = [...this._renderedNodes].reduce((e11, t12) => e11 + this._index.getNode(t12).vertexCount);
    let i5 = this._loadingNodes.size;
    for (let r8 = 0; r8 < this._workQueue.length; r8++)
      i5 += this._workQueue[r8].load.length, i5 -= this._workQueue[r8].remove.length;
    if (i5 < 0)
      return 0;
    return i5 * t11 / e10 * ((this.getUsedMemory() - e10 * we) / t11) + i5 * we;
  }
  ignoresMemoryFactor() {
    return false;
  }
  get performanceInfo() {
    return { nodes: this._renderedNodes.size, displayedNumberOfFeatures: [...this._renderedNodes].reduce((e10, t11) => e10 + this._index.getNode(t11).vertexCount, 0), maximumNumberOfFeatures: this.maximumPointCount, totalNumberOfFeatures: -1, core: null, "Loading Nodes": this._loadingNodes.size, "Index Queue": this._indexQueue.length, "Work Queue": this._workQueue.length, "Idle Queue": this._idleQueue.length };
  }
  get test() {
    return { index: this._index, visibleNodes: this._renderedNodes };
  }
};
e([d2()], ge.prototype, "layer", void 0), e([d2({ readOnly: true, aliasOf: "layer.parsedUrl.path" })], ge.prototype, "baseUrl", void 0), e([d2({ readOnly: true })], ge.prototype, "pointScale", null), e([d2({ readOnly: true })], ge.prototype, "useRealWorldSymbolSizes", null), e([d2({ readOnly: true })], ge.prototype, "pointSize", null), e([d2({ readOnly: true })], ge.prototype, "inverseDensity", null), e([d2()], ge.prototype, "maximumPointCount", void 0), e([d2({ readOnly: true })], ge.prototype, "availableFields", null), e([d2({ readOnly: true })], ge.prototype, "_clippingBox", null), e([d2({ readOnly: true })], ge.prototype, "_elevationOffset", null), e([d2({ type: Boolean })], ge.prototype, "slicePlaneEnabled", void 0), e([d2()], ge.prototype, "updating", void 0), e([d2(t6)], ge.prototype, "updatingProgress", void 0), e([d2({ readOnly: true })], ge.prototype, "updatingProgressValue", null), ge = e([n3("esri.views.3d.layers.PointCloudLayerView3D")], ge);
var fe = ge;
function ye(e10) {
  return 5 * e10.coordinates.length + 128;
}
var be = u4();
var we = 160;
export {
  fe as default
};
//# sourceMappingURL=PointCloudLayerView3D-N3S5BJ6W.js.map
