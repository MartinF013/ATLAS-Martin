import {
  i,
  o,
  r as r3,
  s as s3
} from "./chunk-JNXH4TTS.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  j as j2
} from "./chunk-5N3FSR63.js";
import {
  a,
  d,
  v as v2
} from "./chunk-4PRVTUEZ.js";
import {
  m2 as m
} from "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  R as R2,
  j
} from "./chunk-YPZEGNLG.js";
import {
  R
} from "./chunk-3NMRL5CR.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  r as r2,
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/rest/geometry/cut.js
async function o2(o3, i3, n2, m2) {
  const p = "string" == typeof o3 ? j2(o3) : o3, a2 = i3[0].spatialReference, u = { ...m2, query: { ...p.query, f: "json", sr: JSON.stringify(a2), target: JSON.stringify({ geometryType: v2(i3[0]), geometries: i3 }), cutter: JSON.stringify(n2) } }, c = await U(p.path + "/cut", u), { cutIndexes: f, geometries: g = [] } = c.data;
  return { cutIndexes: f, geometries: g.map((e) => {
    const t2 = d(e);
    return t2.spatialReference = a2, t2;
  }) };
}

// node_modules/@arcgis/core/rest/geometry/simplify.js
async function i2(o3, i3, f) {
  const m2 = "string" == typeof o3 ? j2(o3) : o3, p = i3[0].spatialReference, a2 = v2(i3[0]), u = { ...f, query: { ...m2.query, f: "json", sr: p.wkid ? p.wkid : JSON.stringify(p), geometries: JSON.stringify(s4(i3)) } };
  return n((await U(m2.path + "/simplify", u)).data, a2, p);
}
function s4(r4) {
  return { geometryType: v2(r4[0]), geometries: r4.map((r5) => r5.toJSON()) };
}
function n(r4, t2, e) {
  const i3 = a(t2);
  return r4.map((r5) => {
    const t3 = i3.fromJSON(r5);
    return t3.spatialReference = e, t3;
  });
}

// node_modules/@arcgis/core/geometry/support/normalizeUtils.js
var y = s.getLogger("esri.geometry.support.normalizeUtils");
function x(t2) {
  return "polygon" === t2.type;
}
function d2(t2) {
  return "polygon" === t2[0].type;
}
function w(t2) {
  return "polyline" === t2[0].type;
}
function M(t2, n2) {
  if (!(t2 instanceof m || t2 instanceof v)) {
    const t3 = "straightLineDensify: the input geometry is neither polyline nor polygon";
    throw y.error(t3), new s2(t3);
  }
  const o3 = o(t2), s5 = [];
  for (const e of o3) {
    const t3 = [];
    s5.push(t3), t3.push([e[0][0], e[0][1]]);
    for (let o4 = 0; o4 < e.length - 1; o4++) {
      const s6 = e[o4][0], r4 = e[o4][1], i3 = e[o4 + 1][0], l = e[o4 + 1][1], f = Math.sqrt((i3 - s6) * (i3 - s6) + (l - r4) * (l - r4)), c = (l - r4) / f, p = (i3 - s6) / f, u = f / n2;
      if (u > 1) {
        for (let l2 = 1; l2 <= u - 1; l2++) {
          const e3 = l2 * n2, o6 = p * e3 + s6, i5 = c * e3 + r4;
          t3.push([o6, i5]);
        }
        const e2 = (f + Math.floor(u - 1) * n2) / 2, o5 = p * e2 + s6, i4 = c * e2 + r4;
        t3.push([o5, i4]);
      }
      t3.push([i3, l]);
    }
  }
  return x(t2) ? new v({ rings: s5, spatialReference: t2.spatialReference }) : new m({ paths: s5, spatialReference: t2.spatialReference });
}
function R3(t2, e, n2) {
  if (e) {
    const e2 = M(t2, 1e6);
    t2 = j(e2, true);
  }
  return n2 && (t2 = s3(t2, n2)), t2;
}
function b(t2, e, n2) {
  if (Array.isArray(t2)) {
    const o3 = t2[0];
    if (o3 > e) {
      const n3 = i(o3, e);
      t2[0] = o3 + n3 * (-2 * e);
    } else if (o3 < n2) {
      const e2 = i(o3, n2);
      t2[0] = o3 + e2 * (-2 * n2);
    }
  } else {
    const o3 = t2.x;
    if (o3 > e) {
      const n3 = i(o3, e);
      t2 = t2.clone().offset(n3 * (-2 * e), 0);
    } else if (o3 < n2) {
      const e2 = i(o3, n2);
      t2 = t2.clone().offset(e2 * (-2 * n2), 0);
    }
  }
  return t2;
}
function P(t2, e) {
  let n2 = -1;
  for (let o3 = 0; o3 < e.cutIndexes.length; o3++) {
    const s5 = e.cutIndexes[o3], r4 = e.geometries[o3], i3 = o(r4);
    for (let t3 = 0; t3 < i3.length; t3++) {
      const e2 = i3[t3];
      e2.some((n3) => {
        if (n3[0] < 180)
          return true;
        {
          let n4 = 0;
          for (let t4 = 0; t4 < e2.length; t4++) {
            const o5 = e2[t4][0];
            n4 = o5 > n4 ? o5 : n4;
          }
          n4 = Number(n4.toFixed(9));
          const o4 = -360 * i(n4, 180);
          for (let s6 = 0; s6 < e2.length; s6++) {
            const e3 = r4.getPoint(t3, s6);
            r4.setPoint(t3, s6, e3.clone().offset(o4, 0));
          }
          return true;
        }
      });
    }
    if (s5 === n2) {
      if (d2(t2))
        for (const e2 of o(r4))
          t2[s5] = t2[s5].addRing(e2);
      else if (w(t2))
        for (const e2 of o(r4))
          t2[s5] = t2[s5].addPath(e2);
    } else
      n2 = s5, t2[s5] = r4;
  }
  return t2;
}
async function L(e, n2, l) {
  if (!Array.isArray(e))
    return L([e], n2);
  n2 && "string" != typeof n2 && y.warn("normalizeCentralMeridian()", "The url object is deprecated, use the url string instead");
  const h = "string" == typeof n2 ? n2 : (n2 == null ? void 0 : n2.url) ?? r2.geometryServiceUrl;
  let x2, d3, w2, j3, M2, U2, z2, A, v3 = 0;
  const k = [], C = [];
  for (const t2 of e)
    if (t(t2))
      C.push(t2);
    else if (x2 || (x2 = t2.spatialReference, d3 = R(x2), w2 = x2.isWebMercator, U2 = w2 ? 102100 : 4326, j3 = r3[U2].maxX, M2 = r3[U2].minX, z2 = r3[U2].plus180Line, A = r3[U2].minus180Line), d3)
      if ("mesh" === t2.type)
        C.push(t2);
      else if ("point" === t2.type)
        C.push(b(t2.clone(), j3, M2));
      else if ("multipoint" === t2.type) {
        const e2 = t2.clone();
        e2.points = e2.points.map((t3) => b(t3, j3, M2)), C.push(e2);
      } else if ("extent" === t2.type) {
        const e2 = t2.clone()._normalize(false, false, d3);
        C.push(e2.rings ? new v(e2) : e2);
      } else if (t2.extent) {
        const e2 = t2.extent, n3 = i(e2.xmin, M2) * (2 * j3);
        let o3 = 0 === n3 ? t2.clone() : s3(t2.clone(), n3);
        e2.offset(n3, 0), e2.intersects(z2) && e2.xmax !== j3 ? (v3 = e2.xmax > v3 ? e2.xmax : v3, o3 = R3(o3, w2), k.push(o3), C.push("cut")) : e2.intersects(A) && e2.xmin !== M2 ? (v3 = e2.xmax * (2 * j3) > v3 ? e2.xmax * (2 * j3) : v3, o3 = R3(o3, w2, 360), k.push(o3), C.push("cut")) : C.push(o3);
      } else
        C.push(t2.clone());
    else
      C.push(t2);
  let I = i(v3, j3), X = -90;
  const q = I, D = new m();
  for (; I > 0; ) {
    const t2 = 360 * I - 180;
    D.addPath([[t2, X], [t2, -1 * X]]), X *= -1, I--;
  }
  if (k.length > 0 && q > 0) {
    const t2 = P(k, await o2(h, k, D, l)), n3 = [], o3 = [];
    for (let l2 = 0; l2 < C.length; l2++) {
      const r5 = C[l2];
      if ("cut" !== r5)
        o3.push(r5);
      else {
        const r6 = t2.shift(), i4 = e[l2];
        r(i4) && "polygon" === i4.type && i4.rings && i4.rings.length > 1 && r6.rings.length >= i4.rings.length ? (n3.push(r6), o3.push("simplify")) : o3.push(w2 ? R2(r6) : r6);
      }
    }
    if (!n3.length)
      return o3;
    const r4 = await i2(h, n3, l), i3 = [];
    for (let e2 = 0; e2 < o3.length; e2++) {
      const t3 = o3[e2];
      "simplify" !== t3 ? i3.push(t3) : i3.push(w2 ? R2(r4.shift()) : r4.shift());
    }
    return i3;
  }
  const E = [];
  for (let t2 = 0; t2 < C.length; t2++) {
    const e2 = C[t2];
    if ("cut" !== e2)
      E.push(e2);
    else {
      const t3 = k.shift();
      E.push(true === w2 ? R2(t3) : t3);
    }
  }
  return E;
}
function z(t2, e) {
  const n2 = R(e);
  if (n2) {
    const [e2, o3] = n2.valid, s5 = o3 - e2;
    if (t2 < e2)
      for (; t2 < e2; )
        t2 += s5;
    if (t2 > o3)
      for (; t2 > o3; )
        t2 -= s5;
  }
  return t2;
}

export {
  M,
  L,
  z
};
//# sourceMappingURL=chunk-4I3W4KD5.js.map
