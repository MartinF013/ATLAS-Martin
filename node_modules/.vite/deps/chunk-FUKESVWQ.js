import {
  E,
  R
} from "./chunk-T3KDRLPE.js";
import {
  t
} from "./chunk-FPMD6IB4.js";
import {
  s as s2
} from "./chunk-CVWDM4C7.js";
import {
  r,
  s
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/webgl/VertexArrayObject.js
var o = s2.getLogger("esri.views.webgl.VertexArrayObject");
var f = class {
  constructor(t2, e, i, s3, n = null) {
    this._context = t2, this._locations = e, this._layout = i, this._buffers = s3, this._indexBuffer = n, this._glName = null, this._initialized = false, t2.instanceCounter.increment(t.VertexArrayObject, this);
  }
  get glName() {
    return this._glName;
  }
  get context() {
    return this._context;
  }
  get vertexBuffers() {
    return this._buffers;
  }
  get indexBuffer() {
    return this._indexBuffer;
  }
  get size() {
    return Object.keys(this._buffers).reduce((t2, e) => t2 + this._buffers[e].size, r(this._indexBuffer) ? this._indexBuffer.size : 0);
  }
  get layout() {
    return this._layout;
  }
  get locations() {
    return this._locations;
  }
  dispose(t2 = true) {
    var _a, _b;
    if (!this._context)
      return void ((this._glName || t2 && Object.getOwnPropertyNames(this._buffers).length > 0) && o.warn("Leaked WebGL VAO"));
    if (this._glName) {
      const t3 = (_b = (_a = this._context) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.vao;
      t3 ? (t3.deleteVertexArray(this._glName), this._glName = null) : o.warn("Leaked WebGL VAO");
    }
    if (this._context.getBoundVAO() === this && this._context.bindVAO(null), t2) {
      for (const t3 in this._buffers)
        this._buffers[t3].dispose(), delete this._buffers[t3];
      this._indexBuffer = s(this._indexBuffer);
    }
    this._context.instanceCounter.decrement(t.VertexArrayObject, this), this._context = null;
  }
  initialize() {
    if (this._initialized)
      return;
    const t2 = this._context.capabilities.vao;
    if (t2) {
      const e = t2.createVertexArray();
      t2.bindVertexArray(e), this._bindLayout(), t2.bindVertexArray(null), this._glName = e;
    }
    this._initialized = true;
  }
  bind() {
    this.initialize();
    const t2 = this._context.capabilities.vao;
    t2 ? t2.bindVertexArray(this.glName) : (this._context.bindVAO(null), this._bindLayout());
  }
  _bindLayout() {
    const { _buffers: t2, _layout: i, _indexBuffer: r2 } = this;
    t2 || o.error("Vertex buffer dictionary is empty!");
    const n = this._context.gl;
    for (const e in t2) {
      const r3 = t2[e];
      r3 || o.error("Vertex buffer is uninitialized!");
      const n2 = i[e];
      n2 || o.error("Vertex element descriptor is empty!"), R(this._context, this._locations, r3, n2);
    }
    if (r(r2)) {
      !!this._context.capabilities.vao ? n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, r2.glName) : this._context.bindBuffer(r2);
    }
  }
  unbind() {
    this.initialize();
    const t2 = this._context.capabilities.vao;
    t2 ? t2.bindVertexArray(null) : this._unbindLayout();
  }
  _unbindLayout() {
    const { _buffers: t2, _layout: i } = this;
    t2 || o.error("Vertex buffer dictionary is empty!");
    for (const e in t2) {
      const r2 = t2[e];
      r2 || o.error("Vertex buffer is uninitialized!");
      const s3 = i[e];
      E(this._context, this._locations, r2, s3);
    }
    r(this._indexBuffer) && this._context.unbindBuffer(this._indexBuffer.bufferType);
  }
};

export {
  f
};
//# sourceMappingURL=chunk-FUKESVWQ.js.map
