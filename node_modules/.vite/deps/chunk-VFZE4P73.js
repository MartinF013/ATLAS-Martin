import {
  a
} from "./chunk-HMUUQDIL.js";
import {
  m,
  w
} from "./chunk-6GPADSSO.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  Ut,
  j
} from "./chunk-5N3FSR63.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/support/arcgisLayers.js
async function y(e) {
  var _a;
  const r2 = (_a = e.properties) == null ? void 0 : _a.customParameters, a2 = await f(e.url, r2), t2 = { ...e.properties, url: e.url };
  if (!a2.sublayerIds)
    return null != a2.layerOrTableId && (t2.layerId = a2.layerOrTableId, t2.sourceJSON = a2.sourceJSON), new a2.Constructor(t2);
  const s2 = new (0, (await import("./@arcgis_core_layers_GroupLayer.js")).default)({ title: a2.parsedUrl.title });
  return c(s2, a2, t2), s2;
}
function i(e, r2) {
  return e ? e.find((e2) => e2.id === r2) : null;
}
function c(e, r2, a2) {
  function s2(e2, s3) {
    const n = { ...a2, layerId: e2, sublayerTitleMode: "service-name" };
    return r(s3) && (n.sourceJSON = s3), new r2.Constructor(n);
  }
  r2.sublayerIds.forEach((a3) => {
    const t2 = s2(a3, i(r2.sublayerInfos, a3));
    e.add(t2);
  }), r2.tableIds.forEach((a3) => {
    const t2 = s2(a3, i(r2.tableInfos, a3));
    e.tables.add(t2);
  });
}
async function f(e, t2) {
  let s2 = m(e);
  if (t(s2) && (s2 = await d(e, t2)), t(s2))
    throw new s("arcgis-layers:url-mismatch", "The url '${url}' is not a valid arcgis resource", { url: e });
  const { serverType: n, sublayer: o } = s2;
  let u;
  const y2 = { FeatureServer: "FeatureLayer", StreamServer: "StreamLayer", VectorTileServer: "VectorTileLayer" };
  switch (n) {
    case "MapServer":
      u = null != o ? "FeatureLayer" : w2(e, t2).then((e2) => e2 ? "TileLayer" : "MapImageLayer");
      break;
    case "ImageServer":
      u = h(e, { customParameters: t2 }).then((e2) => {
        const r2 = e2.tileInfo && e2.tileInfo.format;
        return e2.tileInfo ? "LERC" !== (r2 == null ? void 0 : r2.toUpperCase()) || e2.cacheType && "elevation" !== e2.cacheType.toLowerCase() ? "ImageryTileLayer" : "ElevationLayer" : "ImageryLayer";
      });
      break;
    case "SceneServer":
      u = h(s2.url.path, { customParameters: t2 }).then((e2) => {
        var _a;
        if (e2) {
          if ("Voxel" === (e2 == null ? void 0 : e2.layerType))
            return "VoxelLayer";
          if ((e2 == null ? void 0 : e2.layers) && Array.isArray(e2.layers) && e2.layers.length > 0) {
            const r2 = { Point: "SceneLayer", "3DObject": "SceneLayer", IntegratedMesh: "IntegratedMeshLayer", PointCloud: "PointCloudLayer", Building: "BuildingSceneLayer" }, a2 = (_a = e2.layers[0]) == null ? void 0 : _a.layerType;
            if (null != r2[a2])
              return r2[a2];
          }
        }
        return "SceneLayer";
      });
      break;
    default:
      u = y2[n];
  }
  const i2 = { FeatureLayer: true, SceneLayer: true }, c2 = "FeatureServer" === n, f2 = { parsedUrl: s2, Constructor: null, layerOrTableId: c2 ? o : null, sublayerIds: null, tableIds: null }, m3 = await u;
  if (i2[m3] && null == o) {
    const r2 = await p(e, n, t2);
    c2 && (f2.sublayerInfos = r2.layerInfos, f2.tableInfos = r2.tableInfos);
    1 !== r2.layerIds.length + r2.tableIds.length ? (f2.sublayerIds = r2.layerIds, f2.tableIds = r2.tableIds) : c2 && (f2.layerOrTableId = r2.layerIds[0] ?? r2.tableIds[0], f2.sourceJSON = r2.layerInfos[0] ?? r2.tableInfos[0]);
  }
  return f2.Constructor = await S(m3), f2;
}
async function d(e, r2) {
  var _a;
  const a2 = await h(e, { customParameters: r2 });
  let l = null, u = null;
  const y2 = a2.type;
  if ("Feature Layer" === y2 || "Table" === y2 ? (l = "FeatureServer", u = a2.id) : "indexedVector" === y2 ? l = "VectorTileServer" : a2.hasOwnProperty("mapName") ? l = "MapServer" : a2.hasOwnProperty("bandCount") && a2.hasOwnProperty("pixelSizeX") ? l = "ImageServer" : a2.hasOwnProperty("maxRecordCount") && a2.hasOwnProperty("allowGeometryUpdates") ? l = "FeatureServer" : a2.hasOwnProperty("streamUrls") ? l = "StreamServer" : m2(a2) ? (l = "SceneServer", u = a2.id) : a2.hasOwnProperty("layers") && m2((_a = a2.layers) == null ? void 0 : _a[0]) && (l = "SceneServer"), !l)
    return null;
  const i2 = null != u ? w(e) : null;
  return { title: r(i2) && a2.name || Ut(e), serverType: l, sublayer: u, url: { path: r(i2) ? i2.serviceUrl : j(e).path } };
}
function m2(e) {
  return (e == null ? void 0 : e.hasOwnProperty("store")) && e.hasOwnProperty("id") && "number" == typeof e.id;
}
async function p(e, r2, a2) {
  let t2, s2 = false;
  if ("FeatureServer" === r2) {
    const r3 = await b(e, { customParameters: a2 });
    s2 = !!r3.layersJSON, t2 = r3.layersJSON || r3.serviceJSON;
  } else
    t2 = await h(e, { customParameters: a2 });
  const n = t2 == null ? void 0 : t2.layers, l = t2 == null ? void 0 : t2.tables;
  return { layerIds: (n == null ? void 0 : n.map((e2) => e2.id).reverse()) || [], tableIds: (l == null ? void 0 : l.map((e2) => e2.id).reverse()) || [], layerInfos: s2 ? n : [], tableInfos: s2 ? l : [] };
}
function I(e) {
  return !e.type || "Feature Layer" === e.type;
}
async function b(e, r2) {
  var _a, _b;
  let a2 = await h(e, r2);
  a2 = a2 || {}, a2.layers = ((_a = a2.layers) == null ? void 0 : _a.filter(I)) || [];
  const t2 = { serviceJSON: a2 };
  if (a2.currentVersion < 10.5)
    return t2;
  const s2 = await h(e + "/layers", r2);
  return t2.layersJSON = { layers: ((_b = s2 == null ? void 0 : s2.layers) == null ? void 0 : _b.filter(I)) || [], tables: (s2 == null ? void 0 : s2.tables) || [] }, t2;
}
async function S(e) {
  return (0, a[e])();
}
async function w2(e, r2) {
  return (await h(e, { customParameters: r2 })).tileInfo;
}
async function h(r2, a2) {
  return (await U(r2, { responseType: "json", query: { f: "json", ...a2 == null ? void 0 : a2.customParameters, token: a2 == null ? void 0 : a2.apiKey } })).data;
}

export {
  y,
  b
};
//# sourceMappingURL=chunk-VFZE4P73.js.map
