import {
  c as c3,
  u as u3
} from "./chunk-T3KDRLPE.js";
import {
  u as u2
} from "./chunk-EJ7RFMRW.js";
import {
  c as c2,
  u
} from "./chunk-VQLKKADV.js";
import {
  A,
  B,
  D,
  F,
  G,
  L,
  M,
  P,
  U,
  V,
  Y,
  c,
  f,
  n,
  t as t2
} from "./chunk-FPMD6IB4.js";
import {
  o
} from "./chunk-MV2XZ5BA.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/webgl/Renderbuffer.js
var r2 = class {
  constructor(r3, s2) {
    this._context = r3, this._desc = s2, this.type = "renderbuffer", this._context.instanceCounter.increment(t2.Renderbuffer, this);
    const i = this._context.gl;
    this.glName = i.createRenderbuffer(), this._context.bindRenderbuffer(this);
    const { width: n2, height: h, internalFormat: o2, multisampled: a } = s2;
    if (a) {
      if (this._context.type !== o.WEBGL2)
        throw new Error("Multisampled renderbuffers are not supported in WebGL1!");
      i.renderbufferStorageMultisample(i.RENDERBUFFER, this.samples, o2, n2, h);
    } else
      i.renderbufferStorage(i.RENDERBUFFER, o2, n2, h);
  }
  get descriptor() {
    return this._desc;
  }
  get samples() {
    const e = this._desc.samples, t3 = this._context.parameters.maxSamples;
    return e ? Math.min(e, t3) : t3;
  }
  resize(e, t3) {
    const r3 = this._desc;
    if (r3.width === e && r3.height === t3)
      return;
    r3.width = e, r3.height = t3;
    const s2 = this._context.gl;
    if (this._context.bindRenderbuffer(this), r3.multisampled) {
      s2.renderbufferStorageMultisample(s2.RENDERBUFFER, this.samples, r3.internalFormat, r3.width, r3.height);
    } else
      s2.renderbufferStorage(s2.RENDERBUFFER, r3.internalFormat, r3.width, r3.height);
  }
  dispose() {
    this._context && (this._context.gl.deleteRenderbuffer(this.glName), this._context.instanceCounter.decrement(t2.Renderbuffer, this), this._context = null);
  }
};

// node_modules/@arcgis/core/views/webgl/FramebufferObject.js
var b = s.getLogger("esri.views.webgl.FrameBufferObject");
var D2 = class {
  constructor(t3, i, r3 = null, s2 = null) {
    if (this._context = t3, this._glName = null, this._depthAttachment = null, this._stencilAttachment = null, this._colorAttachments = /* @__PURE__ */ new Map(), this._initialized = false, this._desc = { ...i }, t3.instanceCounter.increment(t2.FramebufferObject, this), r(r3)) {
      Array.isArray(r3) || (r3 = [r3]);
      for (let t4 = 0; t4 < r3.length; ++t4) {
        const e = r3[t4], i2 = f.COLOR_ATTACHMENT0 + t4;
        let s3;
        U2(e) ? (C(e) ? (s3 = e.descriptor, this._colorAttachments.set(i2, e)) : (s3 = e, this._colorAttachments.set(i2, new u2(this._context, s3))), P2(s3, this._desc)) : (S(e) ? (s3 = e.descriptor, this._colorAttachments.set(i2, e)) : (s3 = e, this._colorAttachments.set(i2, new r2(this._context, s3))), B2(s3, this._desc)), this._validateColorAttachmentPoint(i2);
      }
    }
    if (r(s2)) {
      let t4, e;
      if (U2(s2))
        this._context.capabilities.depthTexture || console.error("Setting the depth/stencil texture as an attachment requires WEBGL_depth_texture or WebGL2"), C(s2) ? (e = s2.descriptor, this._depthStencilTexture = s2) : (e = s2, this._depthStencilTexture = new u2(this._context, e)), P2(e, this._desc);
      else {
        S(s2) ? (e = s2.descriptor, t4 = s2) : (e = s2, t4 = new r2(this._context, e));
        const i2 = this._desc.depthStencilTarget ?? V.DEPTH_STENCIL_RENDER_BUFFER;
        i2 === V.STENCIL_RENDER_BUFFER ? this._stencilAttachment = t4 : i2 === V.DEPTH_RENDER_BUFFER || i2 === V.DEPTH_STENCIL_RENDER_BUFFER ? this._depthAttachment = t4 : console.error('If a Renderbuffer is provided, "depthStencilTarget" must be one of STENCIL_RENDER_BUFFER, DEPTH_RENDER_BUFFER or DEPTH_STENCIL_RENDER_BUFFER'), B2(e, this._desc);
      }
    }
  }
  dispose() {
    if (!this._desc)
      return;
    const t3 = this._context.getBoundFramebufferObject();
    if (this._disposeColorAttachments(), this._disposeDepthStencilAttachments(), this._glName) {
      this._context.gl.deleteFramebuffer(this._glName), this._glName = null;
    }
    this._context.bindFramebuffer(t3), this._context.instanceCounter.decrement(t2.FramebufferObject, this), this._desc = null;
  }
  get glName() {
    return this._glName;
  }
  get descriptor() {
    return this._desc;
  }
  get colorTexture() {
    const t3 = this._colorAttachments.get(f.COLOR_ATTACHMENT0);
    return t3 && C(t3) ? t3 : null;
  }
  get colorAttachment() {
    return this._colorAttachments.get(f.COLOR_ATTACHMENT0);
  }
  get depthStencilAttachment() {
    return this._depthStencilTexture || this._depthAttachment || this._stencilAttachment;
  }
  get depthStencilTexture() {
    return this._depthStencilTexture;
  }
  get width() {
    return this._desc.width;
  }
  get height() {
    return this._desc.height;
  }
  get gpuMemoryUsage() {
    return [...this._colorAttachments].reduce((t3, [e, i]) => t3 + u3(i), 0) + u3(this.depthStencilAttachment);
  }
  getColorTexture(t3) {
    const e = this._colorAttachments.get(t3);
    return e && C(e) ? e : null;
  }
  attachColorTexture(t3, e = f.COLOR_ATTACHMENT0) {
    if (!t3)
      return;
    this._validateColorAttachmentPoint(e);
    P2(t3.descriptor, this._desc), this._disposeColorAttachments(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t3.glName, e)), this._colorAttachments.set(e, t3);
  }
  detachColorTexture(t3 = f.COLOR_ATTACHMENT0) {
    const e = this._colorAttachments.get(t3);
    if (C(e)) {
      const i = e;
      return this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3)), this._colorAttachments.delete(t3), i;
    }
  }
  setColorTextureTarget(t3, e = f.COLOR_ATTACHMENT0) {
    const i = this._colorAttachments.get(e);
    C(i) && this._framebufferTexture2D(i.glName, e, t3);
  }
  attachDepthStencilTexture(t3) {
    if (t(t3))
      return;
    const e = t3.descriptor;
    e.pixelFormat !== P.DEPTH_STENCIL && console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"), e.dataType !== G.UNSIGNED_INT_24_8 && console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"), this._context.capabilities.depthTexture || console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"), P2(e, this._desc), this._desc.depthStencilTarget && this._desc.depthStencilTarget !== V.DEPTH_STENCIL_TEXTURE && (this._desc.depthStencilTarget = V.DEPTH_STENCIL_TEXTURE), this._disposeDepthStencilAttachments(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t3.glName, c)), this._depthStencilTexture = t3;
  }
  detachDepthStencilTexture() {
    const t3 = this._depthStencilTexture;
    return t3 && this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, c)), this._depthStencilTexture = null, t3;
  }
  attachDepthStencilBuffer(t3) {
    if (t(t3))
      return;
    const e = t3.descriptor;
    if (e.internalFormat !== B.DEPTH_STENCIL && e.internalFormat !== B.DEPTH_COMPONENT16 && console.error("Depth/Stencil buffer must have correct internalFormat"), B2(e, this._desc), this._disposeDepthStencilAttachments(), this._desc.depthStencilTarget = e.internalFormat === B.DEPTH_STENCIL ? V.DEPTH_STENCIL_RENDER_BUFFER : V.DEPTH_RENDER_BUFFER, this._initialized) {
      this._context.bindFramebuffer(this);
      const e2 = this._context.gl, i = this._desc.depthStencilTarget === V.DEPTH_RENDER_BUFFER ? e2.DEPTH_ATTACHMENT : e2.DEPTH_STENCIL_ATTACHMENT;
      e2.framebufferRenderbuffer(n.FRAMEBUFFER, i, e2.RENDERBUFFER, t3.glName);
    }
    this._depthAttachment = t3;
  }
  detachDepthStencilBuffer() {
    const t3 = this._context.gl, e = this._depthAttachment;
    if (e && this._initialized) {
      this._context.bindFramebuffer(this);
      const e2 = this._desc.depthStencilTarget === V.DEPTH_RENDER_BUFFER ? t3.DEPTH_ATTACHMENT : t3.DEPTH_STENCIL_ATTACHMENT;
      t3.framebufferRenderbuffer(n.FRAMEBUFFER, e2, t3.RENDERBUFFER, null);
    }
    return this._depthAttachment = null, e;
  }
  detachAll() {
    this._colorAttachments.forEach((t3, e) => this._detachColorAttachment(e)), this.detachDepthStencilBuffer(), this.detachDepthStencilTexture();
  }
  copyToTexture(t3, e, i, r3, s2, h, n2) {
    (t3 < 0 || e < 0 || s2 < 0 || h < 0) && console.error("Offsets cannot be negative!"), (i <= 0 || r3 <= 0) && console.error("Copy width and height must be greater than zero!");
    const c4 = this._desc, o2 = n2.descriptor;
    n2.descriptor.target !== M.TEXTURE_2D && console.error("Texture target must be TEXTURE_2D!"), (t3 + i > c4.width || e + r3 > c4.height || s2 + i > o2.width || h + r3 > o2.height) && console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");
    const _ = this._context, a = _.bindTexture(n2, u2.TEXTURE_UNIT_FOR_UPDATES);
    _.setActiveTexture(u2.TEXTURE_UNIT_FOR_UPDATES), _.bindFramebuffer(this), _.gl.copyTexSubImage2D(M.TEXTURE_2D, 0, s2, h, t3, e, i, r3), _.bindTexture(a, u2.TEXTURE_UNIT_FOR_UPDATES);
  }
  readPixels(t3, e, i, r3, s2, h, n2) {
    (i <= 0 || r3 <= 0) && console.error("Copy width and height must be greater than zero!"), n2 || console.error("Target memory is not initialized!"), this._context.bindFramebuffer(this);
    this._context.gl.readPixels(t3, e, i, r3, s2, h, n2);
  }
  async readPixelsAsync(t3, e, i, h, c4, o2, _) {
    if (this._context.type !== o.WEBGL2)
      return u() && console.warn("Attempting to read pixels using pixel buffer object without WebGL2"), void this.readPixels(t3, e, i, h, c4, o2, _);
    const a = this._context.gl, l = c3.createPixelPack(this._context, F.STREAM_READ, _.byteLength);
    this._context.bindBuffer(l), this._context.bindFramebuffer(this), a.readPixels(t3, e, i, h, c4, o2, 0), this._context.unbindBuffer(A.PIXEL_PACK_BUFFER), await l.getSubDataAsync(_), l.dispose();
  }
  resize(t3, e) {
    const i = this._desc;
    if (i.width !== t3 || i.height !== e) {
      if (!this._initialized)
        return i.width = t3, i.height = e, this._colorAttachments.forEach((i2) => {
          i2 && i2.resize(t3, e);
        }), void (this._depthStencilTexture && this._depthStencilTexture.resize(t3, e));
      i.width = t3, i.height = e, this._colorAttachments.forEach((i2) => {
        i2 && i2.resize(t3, e);
      }), null != this._depthStencilTexture ? this._depthStencilTexture.resize(t3, e) : (this._depthAttachment || this._stencilAttachment) && (this._depthAttachment && this._depthAttachment.resize(t3, e), this._stencilAttachment && this._stencilAttachment.resize(t3, e)), this._context.getBoundFramebufferObject() === this && this._context.bindFramebuffer(null), this._initialized = false;
    }
  }
  initializeAndBind(t3 = n.FRAMEBUFFER) {
    const e = this._context.gl;
    if (this._initialized)
      return void e.bindFramebuffer(t3, this.glName);
    this._glName && e.deleteFramebuffer(this._glName);
    const i = this._context, r3 = e.createFramebuffer(), s2 = this._desc, n2 = s2.colorTarget ?? Y.RENDER_BUFFER, c4 = s2.width ?? 1, T = s2.height ?? 1;
    if (e.bindFramebuffer(t3, r3), 0 === this._colorAttachments.size)
      if (n2 === Y.TEXTURE || n2 === Y.CUBEMAP)
        this._colorAttachments.set(f.COLOR_ATTACHMENT0, H(i, s2, this.descriptor.colorTarget === Y.CUBEMAP ? M.TEXTURE_CUBE_MAP : M.TEXTURE_2D));
      else {
        const t4 = new r2(i, { internalFormat: U.RGBA4, width: c4, height: T });
        this._colorAttachments.set(f.COLOR_ATTACHMENT0, t4);
      }
    this._colorAttachments.forEach((i2, r4) => {
      i2 && (C(i2) ? this._framebufferTexture2D(i2.glName, r4, M2(i2), t3) : e.framebufferRenderbuffer(t3, r4, e.RENDERBUFFER, i2.glName));
    });
    const f2 = s2.depthStencilTarget ?? V.NONE;
    switch (f2) {
      case V.DEPTH_RENDER_BUFFER:
      case V.DEPTH_STENCIL_RENDER_BUFFER: {
        this._depthAttachment || (this._depthAttachment = new r2(i, { internalFormat: s2.depthStencilTarget === V.DEPTH_RENDER_BUFFER ? B.DEPTH_COMPONENT16 : B.DEPTH_STENCIL, width: c4, height: T }));
        const r4 = f2 === V.DEPTH_RENDER_BUFFER ? e.DEPTH_ATTACHMENT : e.DEPTH_STENCIL_ATTACHMENT;
        e.framebufferRenderbuffer(t3, r4, e.RENDERBUFFER, this._depthAttachment.glName);
        break;
      }
      case V.STENCIL_RENDER_BUFFER:
        this._stencilAttachment || (this._stencilAttachment = new r2(i, { internalFormat: B.STENCIL_INDEX8, width: c4, height: T })), e.framebufferRenderbuffer(t3, e.STENCIL_ATTACHMENT, e.RENDERBUFFER, this._stencilAttachment.glName);
        break;
      case V.DEPTH_STENCIL_TEXTURE:
        if (!this._depthStencilTexture) {
          i.capabilities.depthTexture || console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!");
          const t4 = { target: M.TEXTURE_2D, pixelFormat: P.DEPTH_STENCIL, dataType: G.UNSIGNED_INT_24_8, samplingMode: L.NEAREST, wrapMode: D.CLAMP_TO_EDGE, width: c4, height: T };
          this._depthStencilTexture = new u2(i, t4);
        }
        this._framebufferTexture2D(this._depthStencilTexture.glName, e.DEPTH_STENCIL_ATTACHMENT, M2(this._depthStencilTexture), t3);
    }
    if (c2()) {
      e.checkFramebufferStatus(t3) !== e.FRAMEBUFFER_COMPLETE && console.error("Framebuffer is incomplete!");
    }
    this._glName = r3, this._initialized = true;
  }
  _framebufferTexture2D(t3, e = f.COLOR_ATTACHMENT0, i = M.TEXTURE_2D, r3 = n.FRAMEBUFFER, s2 = 0) {
    this._context.gl.framebufferTexture2D(r3, e, i, t3, s2);
  }
  _detachColorAttachment(t3) {
    u() && console.warn("Detaching an FBO attachment can be a slow due to invalidating framebuffer completeness!");
    const e = this._context.gl, i = this._colorAttachments.get(t3);
    return C(i) ? this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3)) : this._initialized && (this._context.bindFramebuffer(this), e.framebufferRenderbuffer(n.FRAMEBUFFER, t3, e.RENDERBUFFER, null)), this._colorAttachments.delete(t3), i;
  }
  _disposeColorAttachments() {
    this._colorAttachments.forEach((t3, e) => {
      this._detachColorAttachment(e), t3.dispose();
    }), this._colorAttachments.clear();
  }
  _disposeDepthStencilAttachments() {
    const t3 = this._context.gl;
    if (this._depthAttachment) {
      if (this._initialized) {
        this._context.bindFramebuffer(this);
        const e = this._desc.depthStencilTarget === V.DEPTH_RENDER_BUFFER ? t3.DEPTH_ATTACHMENT : t3.DEPTH_STENCIL_ATTACHMENT;
        t3.framebufferRenderbuffer(n.FRAMEBUFFER, e, t3.RENDERBUFFER, null);
      }
      this._depthAttachment.dispose(), this._depthAttachment = null;
    }
    this._stencilAttachment && (this._initialized && (this._context.bindFramebuffer(this), t3.framebufferRenderbuffer(n.FRAMEBUFFER, t3.STENCIL_ATTACHMENT, t3.RENDERBUFFER, null)), this._stencilAttachment.dispose(), this._stencilAttachment = null), this._depthStencilTexture && (this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3.DEPTH_STENCIL_ATTACHMENT)), this._depthStencilTexture.dispose(), this._depthStencilTexture = null);
  }
  _validateColorAttachmentPoint(t3) {
    if (-1 === D2._MAX_COLOR_ATTACHMENTS) {
      const t4 = this._context.capabilities.drawBuffers;
      if (t4) {
        const e2 = this._context.gl;
        D2._MAX_COLOR_ATTACHMENTS = e2.getParameter(t4.MAX_COLOR_ATTACHMENTS);
      } else
        D2._MAX_COLOR_ATTACHMENTS = 1;
    }
    const e = t3 - f.COLOR_ATTACHMENT0;
    e + 1 > D2._MAX_COLOR_ATTACHMENTS && b.error("esri.FrameBufferObject", `illegal attachment point for color attachment: ${e + 1}. Implementation supports up to ${D2._MAX_COLOR_ATTACHMENTS} color attachments`);
  }
};
function C(t3) {
  return "type" in t3 && "texture" === t3.type;
}
function S(t3) {
  return "type" in t3 && "renderbuffer" === t3.type;
}
function U2(t3) {
  return C(t3) || "pixelFormat" in t3;
}
function H(t3, e, i) {
  return new u2(t3, { target: i, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, wrapMode: D.CLAMP_TO_EDGE, width: e.width, height: e.height });
}
function P2(t3, e) {
  t3.target !== M.TEXTURE_2D && t3.target !== M.TEXTURE_CUBE_MAP && console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"), void 0 !== e.width && e.width >= 0 && void 0 !== e.height && e.height >= 0 ? e.width === t3.width && e.height === t3.height || console.error("Color attachment texture must match the framebuffer's!") : (e.width = t3.width, e.height = t3.height);
}
function B2(t3, e) {
  void 0 !== e.width && e.width >= 0 && void 0 !== e.height && e.height >= 0 ? e.width === t3.width && e.height === t3.height || console.error("Renderbuffer dimensions must match the framebuffer's!") : (e.width = t3.width, e.height = t3.height);
}
function M2(t3) {
  return t3.descriptor.target === M.TEXTURE_CUBE_MAP ? M.TEXTURE_CUBE_MAP_POSITIVE_X : M.TEXTURE_2D;
}
D2._MAX_COLOR_ATTACHMENTS = -1;

export {
  r2 as r,
  D2 as D
};
//# sourceMappingURL=chunk-Z7AZMEL6.js.map
