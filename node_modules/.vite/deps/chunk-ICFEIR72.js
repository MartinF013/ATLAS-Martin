import {
  a as a2
} from "./chunk-JERZLQLG.js";
import {
  i as i2
} from "./chunk-JWKDNFWF.js";
import {
  ge
} from "./chunk-UGLXR5OV.js";
import {
  I
} from "./chunk-6FQZDXGD.js";
import {
  D as D2,
  M2 as M4,
  S
} from "./chunk-I2XAFJCJ.js";
import {
  a
} from "./chunk-RVR2DEVB.js";
import {
  f as f3
} from "./chunk-FUKESVWQ.js";
import {
  c
} from "./chunk-T3KDRLPE.js";
import {
  u as u2
} from "./chunk-EJ7RFMRW.js";
import {
  t as t2
} from "./chunk-33INAWJA.js";
import {
  C,
  D,
  E,
  F,
  G,
  L,
  P,
  R
} from "./chunk-FPMD6IB4.js";
import {
  e as e2
} from "./chunk-MEW2XKT2.js";
import {
  t as t3
} from "./chunk-RB3LJE4I.js";
import {
  M as M3,
  b,
  f as f2,
  h,
  i,
  l as l2,
  r as r2
} from "./chunk-3NPGGTI6.js";
import {
  d as d2
} from "./chunk-JJRJ6TV3.js";
import {
  l
} from "./chunk-T7BEWVV3.js";
import {
  g as g2
} from "./chunk-BLINZ65M.js";
import {
  u
} from "./chunk-NWRK6QLX.js";
import {
  M as M2
} from "./chunk-BPZGJQOB.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  f,
  g
} from "./chunk-U3PSONS6.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/engine/flow/utils.js
function n2(e4) {
  const n3 = i3(a3(e4)), o2 = n3, s5 = true, r4 = Math.max(n3 / 2, 5), l6 = Math.round(u(e4.maxPathLength) / r4) + 1, u7 = 10, { density: c4 } = e4;
  return { smoothing: u(e4.smoothing), interpolate: true, velocityScale: "flow-from" === e4.flowRepresentation ? 1 : -1, verticesPerLine: l6, minSpeedThreshold: 1e-3, segmentLength: r4, maxTurnAngle: 1, collisions: s5, lineCollisionWidth: o2, lineSpacing: u7, density: c4 };
}
function i3(e4) {
  return "constant" === e4.kind ? e4.value[0] : e4.values[e4.values.length - 1];
}
function o(e4) {
  const t6 = e4.toRgba();
  return [t6[0] / 255, t6[1] / 255, t6[2] / 255, t6[3]];
}
function s2(e4) {
  return { kind: "constant", value: [0.1, 0.1, 0.1, 1] };
}
function a3(e4) {
  if (!e4.hasVisualVariables("size"))
    return { kind: "constant", value: [u(e4.trailWidth)] };
  const n3 = e4.getVisualVariablesForType("size")[0], i4 = [], o2 = [];
  let s5;
  if (n3.stops) {
    for (const e5 of n3.stops)
      i4.push(e5.value), o2.push(u(e5.size));
    s5 = n3.stops.length;
  } else
    i4.push(n3.minDataValue, n3.maxDataValue), o2.push(u(n3.minSize), u(n3.maxSize)), s5 = 2;
  return { kind: "ramp", stops: i4, values: o2, count: s5 };
}
function r3(e4) {
  if (!e4.hasVisualVariables("color"))
    return { kind: "constant", value: o(e4.color) };
  const t6 = e4.getVisualVariablesForType("color")[0], n3 = [], i4 = [];
  for (const s5 of t6.stops)
    n3.push(s5.value), Array.prototype.push.apply(i4, o(s5.color));
  return { kind: "ramp", stops: n3, values: i4, count: t6.stops.length };
}
function l3(e4) {
  if (!e4.hasVisualVariables("opacity"))
    return { kind: "constant", value: [1] };
  const t6 = e4.getVisualVariablesForType("opacity")[0], n3 = [], i4 = [];
  for (const o2 of t6.stops)
    n3.push(o2.value), i4.push(o2.opacity);
  return { kind: "ramp", stops: n3, values: i4, count: t6.stops.length };
}
function u3(e4, t6, n3, i4) {
  switch (t6) {
    case "int":
      e4.setUniform1iv(n3, i4);
      break;
    case "float":
      e4.setUniform1fv(n3, i4);
      break;
    case "vec2":
      e4.setUniform2fv(n3, i4);
      break;
    case "vec3":
      e4.setUniform3fv(n3, i4);
      break;
    case "vec4":
      e4.setUniform4fv(n3, i4);
  }
}
function c2(e4, t6, n3, i4) {
  "constant" === i4.kind ? u3(e4, n3, `u_${t6}`, i4.value) : (u3(e4, "float", `u_${t6}_stops`, i4.stops), u3(e4, n3, `u_${t6}_values`, i4.values), e4.setUniform1i(`u_${t6}_count`, i4.count));
}
function p(e4, t6) {
  let n3 = true;
  return n3 = n3 && e4.collisions === t6.collisions, n3 = n3 && e4.density === t6.density, n3 = n3 && e4.interpolate === t6.interpolate, n3 = n3 && e4.lineCollisionWidth === t6.lineCollisionWidth, n3 = n3 && e4.lineSpacing === t6.lineSpacing, n3 = n3 && e4.maxTurnAngle === t6.maxTurnAngle, n3 = n3 && e4.minSpeedThreshold === t6.minSpeedThreshold, n3 = n3 && e4.segmentLength === t6.segmentLength, n3 = n3 && e4.smoothing === t6.smoothing, n3 = n3 && e4.velocityScale === t6.velocityScale, n3 = n3 && e4.verticesPerLine === t6.verticesPerLine, n3;
}
function f4(t6, n3) {
  return t6 === n3 || !(!r(t6) || !r(n3)) && t6.equals(n3);
}
function m(e4, t6) {
  if (!p(e4.simulationSettings, t6.simulationSettings))
    return false;
  if (!f4(e4.timeExtent, t6.timeExtent))
    return false;
  let n3 = true;
  return n3 = n3 && e4.loadImagery === t6.loadImagery, n3 = n3 && e4.createFlowMesh === t6.createFlowMesh, n3 = n3 && e4.color.kind === t6.color.kind, n3 = n3 && e4.opacity.kind === t6.opacity.kind, n3 = n3 && e4.size.kind === t6.size.kind, n3;
}

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Imagery.js
var d3 = class {
  constructor(t6) {
    this._params = t6, this.animated = false;
  }
  isCompatible(t6) {
    if (!(t6 instanceof d3))
      return false;
    if (!f4(this._params.timeExtent, t6._params.timeExtent))
      return false;
    let e4 = true;
    return e4 = e4 && this._params.loadImagery === t6._params.loadImagery, e4 = e4 && this._params.color.kind === t6._params.color.kind, e4 = e4 && this._params.opacity.kind === t6._params.opacity.kind, e4;
  }
  async load(a4, e4) {
    const { extent: r4, size: s5 } = a4;
    f(e4);
    const i4 = await this._params.loadImagery(r4, s5[0], s5[1], this._params.timeExtent, e4);
    return new g3(i4, { color: this._params.color, opacity: this._params.opacity });
  }
  render(t6, a4, r4) {
    const { context: s5 } = t6, { program: n3 } = r4;
    s5.setFaceCullingEnabled(false), s5.setBlendingEnabled(true), s5.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), s5.useProgram(n3), n3.setUniformMatrix3fv("u_dvsMat3", a4.dvsMat3), s5.bindTexture(r4.texture, 0), n3.setUniform1i("u_texture", 0), n3.setUniform1f("u_Min", r4.min), n3.setUniform1f("u_Max", r4.max), c2(n3, "color", "vec4", this._params.color), c2(n3, "opacity", "float", this._params.opacity), s5.bindVAO(r4.vertexArray), s5.drawArrays(E.TRIANGLE_STRIP, 0, 4);
  }
};
var u4 = /* @__PURE__ */ new Map();
u4.set("a_position", 0), u4.set("a_texcoord", 1);
var w = { geometry: [new t2("a_position", 2, C.UNSIGNED_SHORT, 0, 8), new t2("a_texcoord", 2, C.UNSIGNED_SHORT, 4, 8)] };
var x = { vsPath: "raster/flow/imagery", fsPath: "raster/flow/imagery", attributes: u4 };
var g3 = class {
  constructor(t6, a4) {
    this._flowData = t6, this._values = a4;
  }
  attach(t6) {
    const { context: a4 } = t6, { width: e4, height: s5 } = this._flowData, i4 = c.createVertex(a4, F.STATIC_DRAW, new Uint16Array([0, 0, 0, 1, e4, 0, 1, 1, 0, s5, 0, 0, e4, s5, 1, 0])), o2 = new f3(a4, u4, w, { geometry: i4 }), f9 = [];
    "ramp" === this._values.color.kind && f9.push("vvColor"), "ramp" === this._values.opacity.kind && f9.push("vvOpacity");
    const d7 = t6.painter.materialManager.getProgram(x, f9);
    let g6 = 1e6, y5 = -1e6;
    for (let r4 = 0; r4 < s5; r4++)
      for (let t7 = 0; t7 < e4; t7++)
        if (0 !== this._flowData.mask[r4 * e4 + t7]) {
          const a5 = this._flowData.data[2 * (r4 * e4 + t7) + 0], s6 = this._flowData.data[2 * (r4 * e4 + t7) + 1], i5 = Math.sqrt(a5 * a5 + s6 * s6);
          g6 = Math.min(g6, i5), y5 = Math.max(y5, i5);
        }
    const A = new Uint8Array(4 * e4 * s5);
    for (let r4 = 0; r4 < s5; r4++)
      for (let t7 = 0; t7 < e4; t7++)
        if (0 !== this._flowData.mask[r4 * e4 + t7]) {
          const a5 = this._flowData.data[2 * (r4 * e4 + t7) + 0], s6 = this._flowData.data[2 * (r4 * e4 + t7) + 1], i5 = (Math.sqrt(a5 * a5 + s6 * s6) - g6) / (y5 - g6);
          A[4 * (r4 * e4 + t7) + 0] = 255 * i5, A[4 * (r4 * e4 + t7) + 1] = 0, A[4 * (r4 * e4 + t7) + 2] = 0, A[4 * (r4 * e4 + t7) + 3] = 255;
        } else
          A[4 * (r4 * e4 + t7) + 0] = 0, A[4 * (r4 * e4 + t7) + 1] = 0, A[4 * (r4 * e4 + t7) + 2] = 0, A[4 * (r4 * e4 + t7) + 3] = 0;
    const E2 = new u2(a4, { pixelFormat: P.RGBA, internalFormat: P.RGBA, samplingMode: L.LINEAR, dataType: G.UNSIGNED_BYTE, wrapMode: D.CLAMP_TO_EDGE, flipped: true, width: e4, height: s5 }, A);
    this.vertexArray = o2, this.program = d7, this.texture = E2, this.min = g6, this.max = y5, this._flowData = null;
  }
  detach() {
    this.vertexArray.dispose(), this.texture.dispose();
  }
  get ready() {
    return this.program.isCompiled;
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Particles.js
var _ = class {
  constructor(t6) {
    this._params = t6;
  }
  get animated() {
    return this._params.flowSpeed > 0;
  }
  isCompatible(t6) {
    return t6 instanceof _ && m(this._params, t6._params);
  }
  async load(e4, a4) {
    const { extent: s5, size: r4 } = e4;
    f(a4);
    const i4 = await this._params.loadImagery(s5, r4[0], r4[1], this._params.timeExtent, a4), { vertexData: o2, indexData: n3 } = await this._params.createFlowMesh("Particles", this._params.simulationSettings, i4, a4);
    return new c3(o2, n3, { color: this._params.color, opacity: this._params.opacity, size: this._params.size });
  }
  render(t6, e4, s5) {
    const { context: n3 } = t6, { program: m3 } = s5;
    n3.setFaceCullingEnabled(false), n3.setBlendingEnabled(true), n3.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), n3.useProgram(m3), m3.setUniform1f("u_time", e4.time), m3.setUniform1f("u_trailLength", this._params.trailLength), m3.setUniform1f("u_flowSpeed", this._params.flowSpeed), m3.setUniform1f("u_featheringSize", this._params.featheringSize), m3.setUniform1f("u_featheringOffset", this._params.featheringOffset), m3.setUniform1f("u_introFade", this._params.introFade ? 1 : 0), m3.setUniform1f("u_fadeToZero", this._params.fadeToZero ? 1 : 0), m3.setUniform1f("u_decayRate", this._params.decayRate), m3.setUniformMatrix3fv("u_dvsMat3", e4.dvsMat3), m3.setUniformMatrix3fv("u_displayViewMat3", e4.displayViewMat3), c2(m3, "color", "vec4", this._params.color), c2(m3, "opacity", "float", this._params.opacity), c2(m3, "size", "float", this._params.size), n3.bindVAO(s5.vertexArray), n3.drawElements(E.TRIANGLES, s5.indexCount, C.UNSIGNED_INT, 0);
  }
};
var l4 = /* @__PURE__ */ new Map();
l4.set("a_xyts0", 0), l4.set("a_xyts1", 1), l4.set("a_typeIdDurationSeed", 2), l4.set("a_extrudeInfo", 3);
var h2 = { geometry: [new t2("a_xyts0", 4, C.FLOAT, 0, 64), new t2("a_xyts1", 4, C.FLOAT, 16, 64), new t2("a_typeIdDurationSeed", 4, C.FLOAT, 32, 64), new t2("a_extrudeInfo", 4, C.FLOAT, 48, 64)] };
var f5 = { vsPath: "raster/flow/particles", fsPath: "raster/flow/particles", attributes: l4 };
var c3 = class {
  constructor(t6, e4, a4) {
    this._vertexData = t6, this._indexData = e4, this._values = a4;
  }
  attach(t6) {
    const { context: e4 } = t6, a4 = c.createVertex(e4, F.STATIC_DRAW, this._vertexData), r4 = c.createIndex(e4, F.STATIC_DRAW, this._indexData), i4 = new f3(e4, l4, h2, { geometry: a4 }, r4), o2 = [];
    "ramp" === this._values.color.kind && o2.push("vvColor"), "ramp" === this._values.opacity.kind && o2.push("vvOpacity"), "ramp" === this._values.size.kind && o2.push("vvSize");
    const p3 = t6.painter.materialManager.getProgram(f5, o2);
    this.vertexArray = i4, this.program = p3, this.indexCount = this._indexData.length, this._vertexData = null, this._indexData = null;
  }
  detach() {
    this.vertexArray.dispose();
  }
  get ready() {
    return this.program.isCompiled;
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Stack.js
var t4 = class {
  constructor(t6) {
    this._styles = t6;
  }
  get animated() {
    return this._styles.reduce((t6, s5) => t6 || s5.animated, false);
  }
  isCompatible(s5) {
    if (!(s5 instanceof t4))
      return false;
    if (this._styles.length !== s5._styles.length)
      return false;
    const e4 = this._styles.length;
    for (let t6 = 0; t6 < e4; t6++)
      if (!this._styles[t6].isCompatible(s5._styles[t6]))
        return false;
    return true;
  }
  async load(t6, e4) {
    const r4 = await Promise.all(this._styles.map((s5) => s5.load(t6, e4)));
    return new s3(r4);
  }
  render(t6, s5, e4) {
    for (let r4 = 0; r4 < this._styles.length; r4++)
      this._styles[r4].render(t6, s5, e4.resources[r4]);
  }
};
var s3 = class {
  constructor(t6) {
    this.resources = t6;
  }
  attach(t6) {
    for (const s5 of this.resources)
      s5.attach(t6);
  }
  detach() {
    for (const t6 of this.resources)
      t6.detach();
  }
  get ready() {
    return this.resources.reduce((t6, s5) => t6 && s5.ready, true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Streamlines.js
var _2 = class {
  constructor(t6) {
    this._params = t6;
  }
  get animated() {
    return this._params.flowSpeed > 0;
  }
  isCompatible(t6) {
    return t6 instanceof _2 && m(this._params, t6._params);
  }
  async load(e4, a4) {
    const { extent: s5, size: r4 } = e4;
    f(a4);
    const i4 = await this._params.loadImagery(s5, r4[0], r4[1], this._params.timeExtent, a4), { vertexData: o2, indexData: n3 } = await this._params.createFlowMesh("Streamlines", this._params.simulationSettings, i4, a4);
    return new d4(o2, n3, { color: this._params.color, opacity: this._params.opacity, size: this._params.size });
  }
  render(t6, e4, s5) {
    const { context: n3 } = t6, { program: m3 } = s5;
    n3.setFaceCullingEnabled(false), n3.setBlendingEnabled(true), n3.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), n3.useProgram(m3), m3.setUniform1f("u_time", e4.time), m3.setUniform1f("u_trailLength", this._params.trailLength), m3.setUniform1f("u_flowSpeed", this._params.flowSpeed), m3.setUniform1f("u_featheringSize", this._params.featheringSize), m3.setUniform1f("u_featheringOffset", this._params.featheringOffset), m3.setUniform1f("u_introFade", this._params.introFade ? 1 : 0), m3.setUniform1f("u_fadeToZero", this._params.fadeToZero ? 1 : 0), m3.setUniform1f("u_decayRate", this._params.decayRate), m3.setUniformMatrix3fv("u_dvsMat3", e4.dvsMat3), m3.setUniformMatrix3fv("u_displayViewMat3", e4.displayViewMat3), c2(m3, "color", "vec4", this._params.color), c2(m3, "opacity", "float", this._params.opacity), c2(m3, "size", "float", this._params.size), n3.bindVAO(s5.vertexArray), n3.drawElements(E.TRIANGLES, s5.indexCount, C.UNSIGNED_INT, 0);
  }
};
var l5 = /* @__PURE__ */ new Map();
l5.set("a_positionAndSide", 0), l5.set("a_timeInfo", 1), l5.set("a_extrude", 2), l5.set("a_speed", 3);
var h3 = { geometry: [new t2("a_positionAndSide", 3, C.FLOAT, 0, 36), new t2("a_timeInfo", 3, C.FLOAT, 12, 36), new t2("a_extrude", 2, C.FLOAT, 24, 36), new t2("a_speed", 1, C.FLOAT, 32, 36)] };
var f6 = { vsPath: "raster/flow/streamlines", fsPath: "raster/flow/streamlines", attributes: l5 };
var d4 = class {
  constructor(t6, e4, a4) {
    this._vertexData = t6, this._indexData = e4, this._values = a4;
  }
  attach(t6) {
    const { context: e4 } = t6, a4 = c.createVertex(e4, F.STATIC_DRAW, this._vertexData), r4 = c.createIndex(e4, F.STATIC_DRAW, this._indexData), i4 = new f3(e4, l5, h3, { geometry: a4 }, r4), o2 = [];
    "ramp" === this._values.color.kind && o2.push("vvColor"), "ramp" === this._values.opacity.kind && o2.push("vvOpacity"), "ramp" === this._values.size.kind && o2.push("vvSize");
    const p3 = t6.painter.materialManager.getProgram(f6, o2);
    this.vertexArray = i4, this.program = p3, this.indexCount = this._indexData.length, this._vertexData = null, this._indexData = null;
  }
  detach() {
    this.vertexArray.dispose();
  }
  get ready() {
    return this.program.isCompiled;
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/createFlowStyle.js
var f7 = 4;
var p2 = 1;
var u5 = 0.5;
var y2 = true;
var d5 = true;
var g4 = 2.3;
function w2(w3, h6) {
  const { flowSpeed: j2, trailLength: v } = w3, S2 = n2(w3);
  let k = null;
  const x2 = { opacity: l3(w3), size: a3(w3) };
  let I2 = r3(w3);
  if ("none" === w3.background)
    x2.color = I2;
  else {
    "constant" === I2.kind && (I2 = { kind: "ramp", stops: [0, 1], values: [0, 0, 0, 1, I2.value[0], I2.value[1], I2.value[2], I2.value[3]], count: 2 });
    const e4 = { loadImagery: h6.loadImagery, timeExtent: h6.timeExtent, color: I2, opacity: { kind: "constant", value: [1] } };
    k = new d3(e4), x2.color = s2();
  }
  const z = { loadImagery: h6.loadImagery, createFlowMesh: h6.createFlowMesh, simulationSettings: S2, timeExtent: h6.timeExtent, trailLength: v, flowSpeed: j2, featheringSize: p2, featheringOffset: u5, introFade: y2, fadeToZero: d5, decayRate: g4, color: x2.color, opacity: x2.opacity, size: x2.size }, E2 = "butt" === w3.trailCap || i3(a3(w3)) <= f7 ? new _2(z) : new _(z);
  return r(k) ? new t4([k, E2]) : E2;
}

// node_modules/@arcgis/core/views/2d/engine/flow/FlowContainer.js
var t5 = class extends a2 {
  constructor() {
    super(...arguments), this.flowStyle = null;
  }
  get requiresDedicatedFBO() {
    return false;
  }
  doRender(e4) {
    super.doRender(e4);
  }
  prepareRenderPasses(s5) {
    const t6 = s5.registerRenderPass({ name: "flow", brushes: [i2], target: () => this.children, drawPhase: I.MAP });
    return [...super.prepareRenderPasses(s5), t6];
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowDisplayData.js
var e3 = s.getLogger("esri.views.2d.engine.flow.FlowDisplayData");
var s4 = class {
  constructor(t6, e4, s5, a4) {
    this.state = { name: "created" }, this.flowStyle = t6, this.extent = e4, this.size = s5, this.pixelRatio = a4;
  }
  async load() {
    const t6 = new AbortController();
    this.state = { name: "loading", abortController: t6 };
    const e4 = { extent: this.extent, size: this.size, pixelRatio: this.pixelRatio }, s5 = await this.flowStyle.load(e4, t6.signal);
    this.state = { name: "loaded", resources: s5 };
  }
  attach(t6) {
    if ("loaded" !== this.state.name)
      return void e3.error("Only loaded resources can be attached.");
    const s5 = this.state.resources;
    s5.attach(t6), this.state = { name: "attached", resources: s5 };
  }
  detach() {
    if ("loading" === this.state.name)
      return this.state.abortController.abort(), void (this.state = { name: "detached" });
    "attached" === this.state.name && (this.state.resources.detach(), this.state = { name: "detached" });
  }
  update(t6) {
    if (!this.flowStyle.isCompatible(t6.flowStyle))
      return false;
    return !(!this.extent.equals(t6.extent) || this.size[0] !== t6.size[0] || this.size[1] !== t6.size[1] || this.pixelRatio !== t6.pixelRatio) && (this.flowStyle = t6.flowStyle, true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowDisplayObject.js
var m2 = class extends a {
  constructor() {
    super(...arguments), this._displayData = null;
  }
  get displayData() {
    return this._displayData;
  }
  set displayData(t6) {
    this._displayData = t6, this.requestRender();
  }
  clear() {
    r(this._displayData) && (this._displayData.detach(), this._displayData = null, this.requestRender());
  }
  setTransform(s5) {
    const { displayData: n3 } = this;
    if (t(n3))
      return;
    const l6 = n3.extent.xmin, m3 = n3.extent.ymax, p3 = [0, 0];
    s5.toScreen(p3, [l6, m3]);
    const c4 = (n3.extent.xmax - n3.extent.xmin) / n3.size[0] / s5.resolution, d7 = M2(s5.rotation), { dvs: h6 } = this.transforms;
    l2(h6, [-1, 1, 0]), f2(h6, h6, [2 / (s5.size[0] * s5.pixelRatio), -2 / (s5.size[1] * s5.pixelRatio), 1]), M3(h6, h6, [p3[0], p3[1], 0]), h(h6, h6, d7), f2(h6, h6, [c4 * s5.pixelRatio, c4 * s5.pixelRatio, 1]);
  }
  _createTransforms() {
    return { dvs: e2() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowStrategy.js
var h4 = 1.15;
var y3 = s.getLogger("esri.views.2d.engine.flow.FlowStrategy");
var f8 = class extends y {
  constructor(t6) {
    super(t6), this._flowDisplayObject = new m2(), this._loading = null;
  }
  initialize() {
    this.flowContainer.addChild(this._flowDisplayObject);
  }
  destroy() {
    this._clear(), this.flowContainer.removeAllChildren();
  }
  get updating() {
    return null != this._loading;
  }
  update(t6) {
    const { flowStyle: o2 } = this.flowContainer;
    if (t(o2))
      return void this._clear();
    const { extent: e4, rotation: i4, resolution: l6, pixelRatio: n3 } = t6.state, p3 = g5(e4, i4);
    p3.expand(h4);
    const m3 = [Math.round((p3.xmax - p3.xmin) / l6), Math.round((p3.ymax - p3.ymin) / l6)], d7 = new s4(o2, p3, m3, n3);
    if (r(this._loading)) {
      if (this._loading.update(d7))
        return;
      this._loading.detach(), this._loading = null;
    }
    !t(this._flowDisplayObject.displayData) && this._flowDisplayObject.displayData.update(d7) || (d7.load().then(() => {
      this._flowDisplayObject.clear(), this._flowDisplayObject.displayData = this._loading, this._loading = null;
    }, (t7) => {
      g(t7) || (y3.error("A resource failed to load.", t7), this._loading = null);
    }), this._loading = d7);
  }
  _clear() {
    this._flowDisplayObject.clear(), r(this._loading) && (this._loading.detach(), this._loading = null);
  }
};
e([d()], f8.prototype, "_loading", void 0), e([d()], f8.prototype, "flowContainer", void 0), e([d()], f8.prototype, "updating", null), f8 = e([n("esri.views.2d.engine.flow.FlowStrategy")], f8);
var u6 = f8;
function g5(t6, o2) {
  const e4 = new j({ x: (t6.xmax + t6.xmin) / 2, y: (t6.ymax + t6.ymin) / 2, spatialReference: t6.spatialReference }), r4 = t6.xmax - t6.xmin, s5 = t6.ymax - t6.ymin, a4 = Math.abs(Math.cos(M2(o2))), l6 = Math.abs(Math.sin(M2(o2))), n3 = a4 * r4 + l6 * s5, c4 = l6 * r4 + a4 * s5, m3 = new M({ xmin: e4.x - n3 / 2, ymin: e4.y - c4 / 2, xmax: e4.x + n3 / 2, ymax: e4.y + c4 / 2, spatialReference: t6.spatialReference });
  return m3.centerAt(e4), m3;
}

// node_modules/@arcgis/core/views/2d/engine/flow/FlowView2D.js
var h5 = class extends d2 {
  constructor() {
    super(...arguments), this._loadImagery = (t6, e4, i4, r4, o2) => M4(this.layer, t6, e4, i4, r4, o2), this._createFlowMesh = (t6, e4, i4, r4) => this.layer.createFlowMesh({ meshType: t6, flowData: i4, simulationSettings: e4 }, { signal: r4 }), this.attached = false, this.container = null, this.layer = null, this.type = "flow", this.timeExtent = null, this.redrawOrRefetch = async () => {
      this._updateVisualization();
    };
  }
  get updating() {
    return !this._strategy || this._strategy.updating;
  }
  attach() {
    const { layer: t6 } = this, e4 = () => {
      this._loadImagery = (e5, i4, r4, o2, s5) => M4(t6, e5, i4, r4, o2, s5), this._updateVisualization();
    };
    "multidimensionalDefinition" in t6 ? this.handles.add(l(() => t6.multidimensionalDefinition, e4)) : this.handles.add([l(() => t6.mosaicRule, e4), l(() => t6.renderingRule, e4), l(() => t6.definitionExpression, e4)]), this.container = new t5(), this._strategy = new u6({ flowContainer: this.container }), this._updateVisualization();
  }
  detach() {
    this._strategy.destroy(), this.container.removeAllChildren(), this.container = null, this.handles.removeAll();
  }
  update(t6) {
    t6.stationary ? this._strategy.update(t6) : this.layerView.requestUpdate();
  }
  hitTest(t6) {
    return new g2({ attributes: {}, geometry: t6.clone(), layer: this.layer });
  }
  moveEnd() {
  }
  async doRefresh() {
  }
  _updateVisualization() {
    const { renderer: t6 } = this.layer;
    if ("flow" !== t6.type)
      return;
    const e4 = w2(t6, { loadImagery: this._loadImagery, createFlowMesh: this._createFlowMesh, timeExtent: this.timeExtent });
    this.container.flowStyle = e4, this.layerView.requestUpdate();
  }
};
e([d()], h5.prototype, "_strategy", void 0), e([d()], h5.prototype, "attached", void 0), e([d()], h5.prototype, "container", void 0), e([d()], h5.prototype, "layer", void 0), e([d()], h5.prototype, "layerView", void 0), e([d()], h5.prototype, "type", void 0), e([d()], h5.prototype, "updating", null), e([d()], h5.prototype, "timeExtent", void 0), h5 = e([n("esri.views.2d.engine.flow.FlowView2D")], h5);
var d6 = h5;

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFDisplayObject.js
var y4 = class extends a {
  constructor(t6 = null) {
    super(), this._source = null, this._symbolizerParameters = null, this._vaoInvalidated = true, this.coordScale = [1, 1], this.height = null, this.stencilRef = 0, this.resolution = null, this.pixelRatio = 1, this.x = 0, this.y = 0, this.rotation = 0, this.rawPixelData = null, this.width = null, this.source = t6;
  }
  destroy() {
    var _a, _b;
    r(this.vaoData) && ((_a = this.vaoData.magdir) == null ? void 0 : _a.vao.dispose(), (_b = this.vaoData.scalar) == null ? void 0 : _b.vao.dispose(), this.vaoData = null);
  }
  get symbolizerParameters() {
    return this._symbolizerParameters;
  }
  set symbolizerParameters(t6) {
    JSON.stringify(this._symbolizerParameters) !== JSON.stringify(t6) && (this._symbolizerParameters = t6, this.invalidateVAO());
  }
  get source() {
    return this._source;
  }
  set source(t6) {
    this._source = t6, this.invalidateVAO();
  }
  invalidateVAO() {
    var _a, _b;
    !this._vaoInvalidated && r(this.vaoData) && ((_a = this.vaoData.magdir) == null ? void 0 : _a.vao.dispose(), (_b = this.vaoData.scalar) == null ? void 0 : _b.vao.dispose(), this.vaoData = null, this._vaoInvalidated = true, this.requestRender());
  }
  updateVectorFieldVAO(s5) {
    if (this._vaoInvalidated) {
      if (this._vaoInvalidated = false, r(this.source) && t(this.vaoData)) {
        const { style: t6 } = this.symbolizerParameters;
        switch (t6) {
          case "beaufort_ft":
          case "beaufort_km":
          case "beaufort_kn":
          case "beaufort_m":
          case "beaufort_mi":
          case "classified_arrow":
          case "ocean_current_kn":
          case "ocean_current_m":
          case "single_arrow":
            {
              const t7 = D2(this.source, this.symbolizerParameters), e4 = this._createVectorFieldVAO(s5.context, t7);
              this.vaoData = { magdir: e4 };
            }
            break;
          case "simple_scalar":
            {
              const t7 = S(this.source, this.symbolizerParameters), e4 = this._createVectorFieldVAO(s5.context, t7);
              this.vaoData = { scalar: e4 };
            }
            break;
          case "wind_speed": {
            const t7 = D2(this.source, this.symbolizerParameters), e4 = this._createVectorFieldVAO(s5.context, t7), a4 = S(this.source, this.symbolizerParameters), r4 = this._createVectorFieldVAO(s5.context, a4);
            this.vaoData = { magdir: e4, scalar: r4 };
          }
        }
      }
      this.ready(), this.requestRender();
    }
  }
  _createTransforms() {
    return { dvs: e2() };
  }
  setTransform(t6) {
    const e4 = r2(this.transforms.dvs), [n3, l6] = t6.toScreenNoRotation([0, 0], [this.x, this.y]), h6 = this.resolution / this.pixelRatio / t6.resolution, m3 = h6 * this.width, u7 = h6 * this.height, d7 = Math.PI * this.rotation / 180;
    M3(e4, e4, t3(n3, l6)), M3(e4, e4, t3(m3 / 2, u7 / 2)), h(e4, e4, -d7), M3(e4, e4, t3(-m3 / 2, -u7 / 2)), b(e4, e4, t3(m3, u7)), i(this.transforms.dvs, t6.displayViewMat3, e4);
  }
  onAttach() {
    this.invalidateVAO();
  }
  onDetach() {
    this.invalidateVAO();
  }
  _createVectorFieldVAO(t6, e4) {
    const { vertexData: s5, indexData: a4 } = e4, r4 = c.createVertex(t6, F.STATIC_DRAW, new Float32Array(s5)), i4 = c.createIndex(t6, F.STATIC_DRAW, new Uint32Array(a4)), o2 = ge("vector-field", { geometry: [{ location: 0, name: "a_pos", count: 2, type: C.FLOAT, normalized: false }, { location: 1, name: "a_offset", count: 2, type: C.FLOAT, normalized: false }, { location: 2, name: "a_vv", count: 2, type: C.FLOAT, normalized: false }] });
    return { vao: new f3(t6, o2.attributes, o2.bufferLayouts, { geometry: r4 }, i4), elementCount: a4.length };
  }
};

export {
  d6 as d,
  y4 as y
};
//# sourceMappingURL=chunk-ICFEIR72.js.map
