import {
  C,
  t as t5
} from "./chunk-RB2H3SKO.js";
import {
  e as e4,
  t as t3
} from "./chunk-AKNCAMEF.js";
import {
  w as w2
} from "./chunk-RGZ7VIMW.js";
import {
  n as n3
} from "./chunk-SF7Z6XNR.js";
import {
  dt,
  f as f2,
  j
} from "./chunk-HH3D3A65.js";
import {
  A,
  B,
  C as C2,
  K,
  O,
  P,
  R,
  U as U2,
  X,
  Y,
  Z,
  a,
  ie,
  k,
  l as l3,
  m as m3,
  ne,
  o as o2,
  oe,
  u as u3,
  w,
  y as y2
} from "./chunk-YDPQRKY4.js";
import {
  o as o4
} from "./chunk-YXFNNKMT.js";
import {
  n as n2,
  t as t4
} from "./chunk-RB3LJE4I.js";
import {
  r as r2,
  z
} from "./chunk-YZNDHJDJ.js";
import {
  a as a2,
  n
} from "./chunk-4P4OV7G6.js";
import {
  e as e5,
  h,
  i,
  o as o3
} from "./chunk-ZUDEVIXR.js";
import {
  M,
  f as f3
} from "./chunk-IG4CY4XM.js";
import {
  m as m2,
  o,
  u as u2
} from "./chunk-56RHM4A6.js";
import {
  e as e3,
  u
} from "./chunk-NWRK6QLX.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  c as c2,
  f,
  l,
  s as s3,
  y
} from "./chunk-4PRVTUEZ.js";
import {
  l as l2
} from "./chunk-FVPTCNCX.js";
import {
  c as c3
} from "./chunk-BPZGJQOB.js";
import {
  c,
  e as e2
} from "./chunk-VLCG72SW.js";
import {
  e
} from "./chunk-5EQKHR4M.js";
import {
  g
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  r,
  t,
  t2
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/core/BidiText.js
var i2 = new C();
function n4(r17) {
  if (!i2.hasBidiChar(r17))
    return [r17, false];
  let n16;
  return n16 = "rtl" === i2.checkContextual(r17) ? "IDNNN" : "ICNNN", [i2.bidiTransform(r17, n16, "VLYSN"), true];
}

// node_modules/@arcgis/core/symbols/cim/CIMResourceManager.js
var o5 = ";base64,";
var s4 = class {
  constructor() {
    this._resourceMap = /* @__PURE__ */ new Map(), this._inFlightResourceMap = /* @__PURE__ */ new Map(), this.geometryEngine = null;
  }
  destroy() {
    this._inFlightResourceMap.clear(), this._resourceMap.clear();
  }
  getResource(e10) {
    return this._resourceMap.get(e10) ?? null;
  }
  async fetchResource(e10, r17) {
    const t8 = { width: 0, height: 0 }, o10 = this._resourceMap, s10 = o10.get(e10);
    if (s10)
      return t8.width = s10.width, t8.height = s10.height, t8;
    let c9 = this._inFlightResourceMap.get(e10);
    return c9 || (c9 = i3(e10, r17), this._inFlightResourceMap.set(e10, c9), c9 = c9.then((r18) => {
      if (this._inFlightResourceMap.delete(e10), r18.ok) {
        o10.set(e10, r18.value);
        const s11 = r18.value;
        return t8.width = s11.width, t8.height = s11.height, t8;
      }
      return t8;
    }), c9);
  }
  deleteResource(e10) {
    this._inFlightResourceMap.delete(e10), this._resourceMap.delete(e10);
  }
};
function i3(s10, i8) {
  if (s10.includes(o5)) {
    const e10 = new Image();
    return e10.src = s10, e10.decode().then(() => ({ ok: true, value: e10 })).catch((e11) => g(e11) ? { ok: false, error: e11 } : { ok: false, error: new s2("invalid-resource", `Could not fetch requested resource at ${s10}`) });
  }
  return U(s10, { responseType: "image", ...i8 }).then((e10) => ({ ok: true, value: e10.data })).catch((e10) => g(e10) ? { ok: false, error: e10 } : { ok: false, error: new s2("invalid-resource", `Could not fetch requested resource at ${s10}`) });
}

// node_modules/@arcgis/core/symbols/cim/TextRasterizer.js
function e6(t8) {
  return `rgb(${t8.slice(0, 3).toString()})`;
}
function i4(t8) {
  return `rgba(${t8.slice(0, 3).toString()},${t8[3]})`;
}
var s5 = class {
  rasterizeText(t8, s10) {
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const r17 = this._textRasterizationCanvas, o10 = r17.getContext("2d");
    this._setFontProperties(o10, s10), this.parameters = s10, this.textLines = t8.split(/\r?\n/), this.lineHeight = this._computeLineHeight();
    const h6 = this._computeTextWidth(o10, s10), { decoration: a10, weight: l8 } = s10.font;
    this.lineThroughWidthOffset = a10 && "line-through" === a10 ? 0.1 * this.lineHeight : 0;
    const d2 = this.lineHeight * this.textLines.length;
    r17.width = h6 + 2 * this.lineThroughWidthOffset, r17.height = d2, this.renderedLineHeight = Math.round(this.lineHeight * s10.pixelRatio), this.renderedHaloSize = s10.halo.size * s10.pixelRatio, this.renderedWidth = h6 * s10.pixelRatio, this.renderedHeight = d2 * s10.pixelRatio, this.lineThroughWidthOffset *= s10.pixelRatio, this.fillStyle = i4(s10.color), this.haloStyle = e6(s10.halo.color);
    const c9 = this.renderedLineHeight, g5 = this.renderedHaloSize;
    this._setFontProperties(o10, s10);
    const f7 = n5(o10.textAlign, this.renderedWidth) + g5, u9 = g5, p3 = g5 > 0;
    let x3 = this.lineThroughWidthOffset, m7 = 0;
    p3 && this._renderHalo(o10, f7, u9, x3, m7, s10), m7 += u9, x3 += f7;
    for (const e10 of this.textLines)
      o10.globalCompositeOperation = "destination-out", o10.fillStyle = "rgb(0, 0, 0)", o10.fillText(e10, x3, m7), o10.globalCompositeOperation = "source-over", o10.fillStyle = this.fillStyle, o10.fillText(e10, x3, m7), a10 && "none" !== a10 && this._renderDecoration(o10, x3, m7, a10, l8), m7 += c9;
    const _4 = this.renderedWidth + 2 * this.lineThroughWidthOffset, H3 = this.renderedHeight, z3 = o10.getImageData(0, 0, _4, H3), w4 = new Uint8Array(z3.data);
    if (s10.premultiplyColors) {
      let t9;
      for (let e10 = 0; e10 < w4.length; e10 += 4)
        t9 = w4[e10 + 3] / 255, w4[e10] = w4[e10] * t9, w4[e10 + 1] = w4[e10 + 1] * t9, w4[e10 + 2] = w4[e10 + 2] * t9;
    }
    return { size: [_4, H3], image: new Uint32Array(w4.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0 };
  }
  _renderHalo(t8, e10, i8, s10, n16, r17) {
    const o10 = this.renderedWidth, h6 = this.renderedHeight;
    this._haloRasterizationCanvas || (this._haloRasterizationCanvas = document.createElement("canvas")), this._haloRasterizationCanvas.width = o10, this._haloRasterizationCanvas.height = h6;
    const a10 = this._haloRasterizationCanvas, l8 = a10.getContext("2d");
    l8.clearRect(0, 0, o10, h6), this._setFontProperties(l8, r17);
    const { decoration: d2, weight: c9 } = r17.font;
    l8.fillStyle = this.haloStyle, l8.strokeStyle = this.haloStyle;
    const g5 = this.renderedHaloSize < 3;
    l8.lineJoin = g5 ? "miter" : "round", g5 ? this._renderHaloEmulated(l8, e10, i8, d2, c9) : this._renderHaloNative(l8, e10, i8, d2, c9), t8.globalAlpha = this.parameters.halo.color[3], t8.drawImage(a10, 0, 0, o10, h6, s10, n16, o10, h6), t8.globalAlpha = 1;
  }
  _renderHaloEmulated(t8, e10, i8, s10, n16) {
    const o10 = this.renderedLineHeight, h6 = this.renderedHaloSize;
    for (const a10 of this.textLines) {
      for (const [s11, n17] of r3)
        t8.fillText(a10, e10 + h6 * s11, i8 + h6 * n17);
      s10 && "none" !== s10 && this._renderDecoration(t8, e10, i8, s10, n16), i8 += o10;
    }
  }
  _renderHaloNative(t8, e10, i8, s10, n16) {
    const r17 = this.renderedLineHeight, o10 = this.renderedHaloSize;
    for (const h6 of this.textLines) {
      const a10 = 2 * o10, l8 = 5, d2 = 0.1;
      for (let r18 = 0; r18 < l8; r18++) {
        const o11 = 1 - (l8 - 1) * d2 + r18 * d2;
        t8.lineWidth = o11 * a10, t8.strokeText(h6, e10, i8), s10 && "none" !== s10 && this._renderDecoration(t8, e10, i8, s10, n16);
      }
      i8 += r17;
    }
  }
  _setFontProperties(e10, i8) {
    const s10 = i8.font, n16 = `${s10.style} ${s10.weight} ${u(i8.size * i8.pixelRatio)}px ${s10.family}, sans-serif`;
    let r17;
    switch (e10.font = n16, e10.textBaseline = "top", i8.horizontalAlignment) {
      case "left":
      default:
        r17 = "left";
        break;
      case "right":
        r17 = "right";
        break;
      case "center":
        r17 = "center";
    }
    e10.textAlign = r17;
  }
  computeTextSize(t8, e10) {
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const i8 = this._textRasterizationCanvas, s10 = i8.getContext("2d");
    this._setFontProperties(s10, e10), this.parameters = e10, this.textLines = t8.split(/\r?\n/), this.lineHeight = this._computeLineHeight();
    const n16 = this._computeTextWidth(s10, e10), r17 = this.lineHeight * this.textLines.length;
    return i8.width = n16, i8.height = r17, [n16 * e10.pixelRatio, r17 * e10.pixelRatio];
  }
  _computeTextWidth(t8, e10) {
    let i8 = 0;
    for (const n16 of this.textLines)
      i8 = Math.max(i8, t8.measureText(n16).width);
    const s10 = e10.font;
    return ("italic" === s10.style || "oblique" === s10.style || "string" == typeof s10.weight && ("bold" === s10.weight || "bolder" === s10.weight) || "number" == typeof s10.weight && s10.weight > 600) && (i8 += 0.3 * t8.measureText("w").width), i8 += 2 * this.parameters.halo.size, Math.round(i8);
  }
  _computeLineHeight() {
    let t8 = 1.275 * this.parameters.size;
    const e10 = this.parameters.font.decoration;
    return e10 && "underline" === e10 && (t8 *= 1.3), Math.round(t8 + 2 * this.parameters.halo.size);
  }
  _renderDecoration(t8, e10, i8, s10, n16) {
    const r17 = 0.9 * this.lineHeight, o10 = "bold" === n16 ? 0.06 : "bolder" === n16 ? 0.09 : 0.04;
    switch (t8.textAlign) {
      case "center":
        e10 -= this.renderedWidth / 2;
        break;
      case "right":
        e10 -= this.renderedWidth;
    }
    const h6 = t8.textBaseline;
    if ("underline" === s10)
      switch (h6) {
        case "top":
          i8 += r17;
          break;
        case "middle":
          i8 += r17 / 2;
      }
    else if ("line-through" === s10)
      switch (h6) {
        case "top":
          i8 += r17 / 1.5;
          break;
        case "middle":
          i8 += r17 / 3;
      }
    t8.save(), t8.beginPath(), t8.strokeStyle = t8.fillStyle, t8.lineWidth = Math.ceil(r17 * o10), t8.moveTo(e10 - this.lineThroughWidthOffset, i8), t8.lineTo(e10 + this.renderedWidth + 2 * this.lineThroughWidthOffset, i8), t8.stroke(), t8.restore();
  }
};
function n5(t8, e10) {
  return "center" === t8 ? 0.5 * e10 : "right" === t8 ? e10 : 0;
}
var r3 = [];
{
  const t8 = 16;
  for (let e10 = 0; e10 < 360; e10 += 360 / t8)
    r3.push([Math.cos(Math.PI * e10 / 180), Math.sin(Math.PI * e10 / 180)]);
}

// node_modules/@arcgis/core/symbols/cim/Rect.js
var t6 = class {
  constructor(t8 = 0, h6 = 0, i8 = 0, s10 = 0) {
    this.x = t8, this.y = h6, this.width = i8, this.height = s10;
  }
  get isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }
  union(t8) {
    this.x = Math.min(this.x, t8.x), this.y = Math.min(this.y, t8.y), this.width = Math.max(this.width, t8.width), this.height = Math.max(this.height, t8.height);
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMPlacements.js
var t7 = class {
  constructor() {
    this.setIdentity();
  }
  getAngle() {
    return (null == this.rz || 0 === this.rz && 1 !== this.rz_c && 0 !== this.rz_s) && (this.rz = Math.atan2(this.rz_s, this.rz_c)), this.rz;
  }
  setIdentity() {
    this.tx = 0, this.ty = 0, this.tz = 0, this.s = 1, this.rx = 0, this.ry = 0, this.rz = 0, this.rz_c = 1, this.rz_s = 0;
  }
  setTranslate(t8, s10) {
    this.tx = t8, this.ty = s10;
  }
  setTranslateZ(t8) {
    this.tz = t8;
  }
  setRotateCS(t8, s10) {
    this.rz = void 0, this.rz_c = t8, this.rz_s = s10;
  }
  setRotate(t8) {
    this.rz = t8, this.rz_c = void 0, this.rz_s = void 0;
  }
  setRotateY(t8) {
    this.ry = t8;
  }
  setScale(t8) {
    this.s = t8;
  }
  setMeasure(t8) {
    this.m = t8;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMEffects.js
var r4 = class {
  constructor(t8) {
    this._geometry = t8;
  }
  next() {
    const t8 = this._geometry;
    return this._geometry = null, t8;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMCursor.js
function a3(i8) {
  const n16 = m(i8);
  return P2(n16), n16;
}
function r5(t8) {
  if (!t8)
    return null;
  l(t8) ? t8.y = -t8.y : c2(t8) ? l4(t8.rings) : y(t8) ? l4(t8.paths) : f(t8) && u4(t8.points);
}
function u4(t8) {
  if (t8) {
    const i8 = t8.length;
    for (let n16 = 0; n16 < i8; n16++)
      t8[n16][1] = -t8[n16][1];
  }
}
function l4(t8) {
  if (t8)
    for (const i8 of t8)
      u4(i8);
}
function c4(t8) {
  if (t8) {
    for (let i8 = t8.length - 1; i8 > 0; --i8)
      t8[i8][0] -= t8[i8 - 1][0], t8[i8][1] -= t8[i8 - 1][1];
  }
}
function f4(t8) {
  if (t8)
    for (const i8 of t8)
      c4(i8);
}
function p(t8) {
  if (t8) {
    const i8 = t8.length;
    for (let n16 = 1; n16 < i8; ++n16)
      t8[n16][0] += t8[n16 - 1][0], t8[n16][1] += t8[n16 - 1][1];
  }
}
function m4(t8) {
  if (t8)
    for (const i8 of t8)
      p(i8);
}
function P2(t8) {
  t8 && (c2(t8) ? m4(t8.rings) : y(t8) ? m4(t8.paths) : f(t8) && p(t8.points), r5(t8));
}
function x(t8) {
  t8 && (r5(t8), c2(t8) ? f4(t8.rings) : y(t8) ? f4(t8.paths) : f(t8) && c4(t8.points));
}
function g2(t8) {
  if (t8)
    for (const i8 of t8)
      d(i8);
}
function d(t8) {
  t8 && t8.reverse();
}
function y3(t8, i8, n16) {
  return [t8[0] + (i8[0] - t8[0]) * n16, t8[1] + (i8[1] - t8[1]) * n16];
}
function C3(t8) {
  return !(!t8 || 0 === t8.length) && (t8[0][0] === t8[t8.length - 1][0] && t8[0][1] === t8[t8.length - 1][1]);
}
function I(t8) {
  return t8[4];
}
function j2(t8, i8) {
  t8[4] = i8;
}
var G = class {
  constructor(t8, s10, e10, a10) {
    this.acceptPolygon = s10, this.acceptPolyline = e10, this.geomUnitsPerPoint = a10, this.pathCount = -1, this.pathIndex = -1, this.iteratePath = false, t8 && (c2(t8) ? s10 && (this.multiPath = t8.rings, this.isClosed = true) : y(t8) ? e10 && (this.multiPath = t8.paths, this.isClosed = false) : s3(t8) && s10 && (this.multiPath = b(t8).rings, this.isClosed = true), this.multiPath && (this.pathCount = this.multiPath.length)), this.internalPlacement = new t7();
  }
  next() {
    if (!this.multiPath)
      return null;
    for (; this.iteratePath || this.pathIndex < this.pathCount - 1; ) {
      this.iteratePath || this.pathIndex++;
      const t8 = this.processPath(this.multiPath[this.pathIndex]);
      if (t8)
        return t8;
    }
    return this.pathCount = -1, this.pathIndex = -1, this.multiPath = null, null;
  }
};
var U3 = class {
  constructor(t8, i8, n16, s10) {
    this.inputGeometries = t8, this.acceptPolygon = i8, this.acceptPolyline = n16, this.geomUnitsPerPoint = s10, this.pathCount = -1, this.pathIndex = -1, this.iteratePath = false;
  }
  next() {
    for (; ; ) {
      if (!this.multiPath) {
        let t8 = this.inputGeometries.next();
        for (; t8; ) {
          if (c2(t8) ? this.acceptPolygon && (this.multiPath = t8.rings, this.isClosed = true) : y(t8) ? this.acceptPolyline && (this.multiPath = t8.paths, this.isClosed = false) : s3(t8) && this.acceptPolygon && (this.multiPath = b(t8).rings, this.isClosed = true), this.multiPath) {
            this.pathCount = this.multiPath.length, this.pathIndex = -1;
            break;
          }
          t8 = this.inputGeometries.next();
        }
        if (!this.multiPath)
          return null;
      }
      for (; this.iteratePath || this.pathIndex < this.pathCount - 1; ) {
        this.iteratePath || this.pathIndex++;
        const t8 = this.processPath(this.multiPath[this.pathIndex]);
        if (t8)
          return t8;
      }
      this.pathCount = -1, this.pathIndex = -1, this.multiPath = null;
    }
  }
};
function b(t8) {
  return { rings: [[[t8.xmin, t8.ymin], [t8.xmin, t8.ymax], [t8.xmax, t8.ymax], [t8.xmax, t8.ymin], [t8.xmin, t8.ymin]]] };
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectAddControlPoints.js
var o6 = class {
  static local() {
    return null === o6.instance && (o6.instance = new o6()), o6.instance;
  }
  execute(s10, t8, e10, i8) {
    return new r6(s10, t8, e10);
  }
};
o6.instance = null;
var r6 = class {
  constructor(s10, t8, e10) {
    this._inputGeometries = s10, this._angleTolerance = void 0 !== t8.angleTolerance ? t8.angleTolerance : 120, this._maxCosAngle = Math.cos((1 - Math.abs(this._angleTolerance) / 180) * Math.PI);
  }
  next() {
    let n16 = this._inputGeometries.next();
    for (; n16; ) {
      if (c2(n16)) {
        this._isClosed = true;
        const t8 = m(n16);
        return this._processMultipath(t8.rings), t8;
      }
      if (y(n16)) {
        this._isClosed = false;
        const t8 = m(n16);
        return this._processMultipath(t8.paths), t8;
      }
      if (s3(n16)) {
        if (this._maxCosAngle)
          return n16;
        this._isClosed = true;
        const s10 = [[n16.xmin, n16.ymin], [n16.xmin, n16.ymax], [n16.xmax, n16.ymax], [n16.xmax, n16.ymin], [n16.xmin, n16.ymin]];
        return this._processPath(s10), { rings: [s10] };
      }
      n16 = this._inputGeometries.next();
    }
    return null;
  }
  _processMultipath(s10) {
    if (s10)
      for (const t8 of s10)
        this._processPath(t8);
  }
  _processPath(s10) {
    if (s10) {
      let t8, e10, i8, o10, r17, l8, a10 = s10.length, h6 = s10[0];
      this._isClosed && ++a10;
      for (let c9 = 1; c9 < a10; ++c9) {
        let m7;
        m7 = this._isClosed && c9 === a10 - 1 ? s10[0] : s10[c9];
        const _4 = m7[0] - h6[0], u9 = m7[1] - h6[1], p3 = Math.sqrt(_4 * _4 + u9 * u9);
        if (c9 > 1 && p3 > 0 && i8 > 0) {
          (t8 * _4 + e10 * u9) / p3 / i8 <= this._maxCosAngle && j2(h6, 1);
        }
        1 === c9 && (o10 = _4, r17 = u9, l8 = p3), p3 > 0 && (h6 = m7, t8 = _4, e10 = u9, i8 = p3);
      }
      if (this._isClosed && i8 > 0 && l8 > 0) {
        (t8 * o10 + e10 * r17) / l8 / i8 <= this._maxCosAngle && j2(s10[0], 1);
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CurveHelper.js
var e7 = 0.03;
var s6 = class {
  constructor() {
    this._path = [];
  }
  path() {
    return this._path;
  }
  addPath(t8, e10) {
    e10 || t8.reverse(), Array.prototype.push.apply(this._path, t8), e10 || t8.reverse();
  }
  static mergePath(t8, e10) {
    e10 && Array.prototype.push.apply(t8, e10);
  }
  startPath(t8) {
    this._path.push(t8);
  }
  lineTo(t8) {
    this._path.push(t8);
  }
  close() {
    const t8 = this._path;
    t8.length > 1 && (t8[0][0] === t8[t8.length - 1][0] && t8[0][1] === t8[t8.length - 1][1] || t8.push([t8[0][0], t8[0][1]]));
  }
};
var n6 = class {
  constructor(t8 = 0, e10 = false) {
  }
  normalize(t8) {
    const e10 = Math.sqrt(t8[0] * t8[0] + t8[1] * t8[1]);
    0 !== e10 && (t8[0] /= e10, t8[1] /= e10);
  }
  calculateLength(t8, e10) {
    const s10 = e10[0] - t8[0], n16 = e10[1] - t8[1];
    return Math.sqrt(s10 * s10 + n16 * n16);
  }
  calculateSegLength(t8, e10) {
    return this.calculateLength(t8[e10], t8[e10 + 1]);
  }
  calculatePathLength(t8) {
    let e10 = 0;
    const s10 = t8 ? t8.length : 0;
    for (let n16 = 0; n16 < s10 - 1; ++n16)
      e10 += this.calculateSegLength(t8, n16);
    return e10;
  }
  calculatePathArea(t8) {
    let e10 = 0;
    const s10 = t8 ? t8.length : 0;
    for (let n16 = 0; n16 < s10 - 1; ++n16)
      e10 += (t8[n16 + 1][0] - t8[n16][0]) * (t8[n16 + 1][1] + t8[n16][1]);
    return e10 / 2;
  }
  getCoord2D(t8, e10, s10) {
    return [t8[0] + (e10[0] - t8[0]) * s10, t8[1] + (e10[1] - t8[1]) * s10];
  }
  getSegCoord2D(t8, e10, s10) {
    return this.getCoord2D(t8[e10], t8[e10 + 1], s10);
  }
  getAngle(t8, e10, s10) {
    const n16 = e10[0] - t8[0], r17 = e10[1] - t8[1];
    return Math.atan2(r17, n16);
  }
  getSegAngle(t8, e10, s10) {
    return this.getAngle(t8[e10], t8[e10 + 1], s10);
  }
  getAngleCS(t8, e10, s10) {
    const n16 = e10[0] - t8[0], r17 = e10[1] - t8[1], h6 = Math.sqrt(n16 * n16 + r17 * r17);
    return h6 > 0 ? [n16 / h6, r17 / h6] : [1, 0];
  }
  getSegAngleCS(t8, e10, s10) {
    return this.getAngleCS(t8[e10], t8[e10 + 1], s10);
  }
  cut(t8, e10, s10, n16) {
    return [s10 <= 0 ? t8[e10] : this.getSegCoord2D(t8, e10, s10), n16 >= 1 ? t8[e10 + 1] : this.getSegCoord2D(t8, e10, n16)];
  }
  addSegment(t8, e10, s10) {
    s10 && t8.push(e10[0]), t8.push(e10[1]);
  }
  getSubCurve(t8, e10, s10) {
    const n16 = [];
    return this.appendSubCurve(n16, t8, e10, s10) ? n16 : null;
  }
  appendSubCurve(t8, e10, s10, n16) {
    const r17 = e10 ? e10.length - 1 : 0;
    let h6 = 0, l8 = true, o10 = 0;
    for (; o10 < r17; ) {
      const r18 = this.calculateSegLength(e10, o10);
      if (0 !== r18) {
        if (l8) {
          if (h6 + r18 > s10) {
            const a10 = (s10 - h6) / r18;
            let u9 = 1, c9 = false;
            h6 + r18 >= n16 && (u9 = (n16 - h6) / r18, c9 = true);
            const i8 = this.cut(e10, o10, a10, u9);
            if (i8 && this.addSegment(t8, i8, l8), c9)
              break;
            l8 = false;
          }
        } else {
          if (h6 + r18 > n16) {
            const s11 = this.cut(e10, o10, 0, (n16 - h6) / r18);
            s11 && this.addSegment(t8, s11, l8);
            break;
          }
          this.addSegment(t8, [e10[o10], e10[o10 + 1]], l8);
        }
        h6 += r18, ++o10;
      } else
        ++o10;
    }
    return true;
  }
  getCIMPointAlong(t8, e10) {
    const s10 = t8 ? t8.length - 1 : 0;
    let n16 = 0, r17 = -1;
    for (; r17 < s10; ) {
      ++r17;
      const s11 = this.calculateSegLength(t8, r17);
      if (0 !== s11) {
        if (n16 + s11 > e10) {
          const h6 = (e10 - n16) / s11;
          return this.getCoord2D(t8[r17], t8[r17 + 1], h6);
        }
        n16 += s11;
      }
    }
    return null;
  }
  isEmpty(t8, e10) {
    if (!t8 || t8.length <= 1)
      return true;
    const s10 = t8 ? t8.length - 1 : 0;
    let n16 = -1;
    for (; n16 < s10; ) {
      if (++n16, t8[n16 + 1][0] !== t8[n16][0] || t8[n16 + 1][1] !== t8[n16][1])
        return false;
      if (e10 && t8[n16 + 1][2] !== t8[n16][2])
        return false;
    }
    return true;
  }
  offset(e10, s10, n16, r17, h6) {
    if (!e10 || e10.length < 2)
      return null;
    let l8 = 0, o10 = e10[l8++], a10 = l8;
    for (; l8 < e10.length; ) {
      const t8 = e10[l8];
      t8[0] === o10[0] && t8[1] === o10[1] || (l8 !== a10 && (e10[a10] = e10[l8]), o10 = e10[a10++]), l8++;
    }
    const u9 = e10[0][0] === e10[a10 - 1][0] && e10[0][1] === e10[a10 - 1][1];
    if (u9 && --a10, a10 < (u9 ? 3 : 2))
      return null;
    const c9 = [];
    o10 = u9 ? e10[a10 - 1] : null;
    let i8 = e10[0];
    for (let g5 = 0; g5 < a10; g5++) {
      const h7 = g5 === a10 - 1 ? u9 ? e10[0] : null : e10[g5 + 1];
      if (o10)
        if (h7) {
          const e11 = [h7[0] - i8[0], h7[1] - i8[1]];
          this.normalize(e11);
          const l9 = [i8[0] - o10[0], i8[1] - o10[1]];
          this.normalize(l9);
          const a11 = l9[0] * e11[1] - l9[1] * e11[0], u10 = l9[0] * e11[0] + l9[1] * e11[1];
          if (0 === a11 && 1 === u10) {
            i8 = h7;
            continue;
          }
          if (a11 >= 0 == s10 <= 0) {
            if (u10 < 1) {
              const t8 = [e11[0] - l9[0], e11[1] - l9[1]];
              this.normalize(t8);
              const n17 = Math.sqrt((1 + u10) / 2);
              if (n17 > 1 / r17) {
                const e12 = -Math.abs(s10) / n17;
                c9.push([i8[0] - t8[0] * e12, i8[1] - t8[1] * e12]);
              }
            }
          } else
            switch (n16) {
              case O.Mitered: {
                const t8 = Math.sqrt((1 + u10) / 2);
                if (t8 > 0 && 1 / t8 < r17) {
                  const n17 = [e11[0] - l9[0], e11[1] - l9[1]];
                  this.normalize(n17);
                  const r18 = Math.abs(s10) / t8;
                  c9.push([i8[0] - n17[0] * r18, i8[1] - n17[1] * r18]);
                  break;
                }
              }
              case O.Bevelled:
                c9.push([i8[0] + l9[1] * s10, i8[1] - l9[0] * s10]), c9.push([i8[0] + e11[1] * s10, i8[1] - e11[0] * s10]);
                break;
              case O.Rounded:
                if (u10 < 1) {
                  c9.push([i8[0] + l9[1] * s10, i8[1] - l9[0] * s10]);
                  const t8 = Math.floor(2.5 * (1 - u10));
                  if (t8 > 0) {
                    const n17 = 1 / t8;
                    let r18 = n17;
                    for (let h8 = 1; h8 < t8; h8++, r18 += n17) {
                      const t9 = [l9[1] * (1 - r18) + e11[1] * r18, -l9[0] * (1 - r18) - e11[0] * r18];
                      this.normalize(t9), c9.push([i8[0] + t9[0] * s10, i8[1] + t9[1] * s10]);
                    }
                  }
                  c9.push([i8[0] + e11[1] * s10, i8[1] - e11[0] * s10]);
                }
                break;
              case O.Square:
              default:
                if (a11 < 0)
                  c9.push([i8[0] + (l9[1] + l9[0]) * s10, i8[1] + (l9[1] - l9[0]) * s10]), c9.push([i8[0] + (e11[1] - e11[0]) * s10, i8[1] - (e11[0] + e11[1]) * s10]);
                else {
                  const t8 = Math.sqrt((1 + Math.abs(u10)) / 2), n17 = [e11[0] - l9[0], e11[1] - l9[1]];
                  this.normalize(n17);
                  const r18 = s10 / t8;
                  c9.push([i8[0] - n17[0] * r18, i8[1] - n17[1] * r18]);
                }
            }
        } else {
          const t8 = [i8[0] - o10[0], i8[1] - o10[1]];
          this.normalize(t8), c9.push([i8[0] + t8[1] * s10, i8[1] - t8[0] * s10]);
        }
      else {
        const t8 = [h7[0] - i8[0], h7[1] - i8[1]];
        this.normalize(t8), c9.push([i8[0] + t8[1] * s10, i8[1] - t8[0] * s10]);
      }
      o10 = i8, i8 = h7;
    }
    return c9.length < (u9 ? 3 : 2) ? null : (u9 && c9.push([c9[0][0], c9[0][1]]), c9);
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectArrow.js
var l5 = 1.7320508075688772;
var c5 = 5;
var u5 = P.OpenEnded;
var h2 = class {
  static local() {
    return null === h2.instance && (h2.instance = new h2()), h2.instance;
  }
  execute(t8, e10, r17, n16) {
    return new a4(t8, e10, r17);
  }
};
h2.instance = null;
var a4 = class extends U3 {
  constructor(t8, e10, o10) {
    super(t8, false, true), this._curveHelper = new n6(), this._width = (void 0 !== e10.width ? e10.width : c5) * o10, this._arrowType = void 0 !== e10.geometricEffectArrowType ? e10.geometricEffectArrowType : void 0 !== e10.arrowType ? e10.arrowType : u5, this._offsetFlattenError = e7 * o10;
  }
  processPath(t8) {
    switch (this._arrowType) {
      case P.OpenEnded:
      default:
        return this._constructSimpleArrow(t8, true);
      case P.Block:
        return this._constructSimpleArrow(t8, false);
      case P.Crossed:
        return this._constructCrossedArrow(t8);
    }
  }
  _constructSimpleArrow(t8, e10) {
    const r17 = this._curveHelper.calculatePathLength(t8);
    let n16 = this._width;
    r17 < 2 * n16 && (n16 = r17 / 2);
    const s10 = this._curveHelper.getSubCurve(t8, 0, r17 - n16);
    if (!s10)
      return null;
    const i8 = n16 / 2;
    if (this._curveHelper.isEmpty(s10, false))
      return null;
    const l8 = this._constructOffset(s10, -i8);
    if (!l8)
      return null;
    const c9 = this._constructOffset(s10, i8);
    if (!c9)
      return null;
    const u9 = this._constructArrowBasePoint(l8, -i8 / 2);
    if (!u9)
      return null;
    const h6 = this._constructArrowBasePoint(c9, i8 / 2);
    if (!h6)
      return null;
    const a10 = t8[t8.length - 1];
    e10 || (this._makeControlPoint(c9, true), this._makeControlPoint(l8, true));
    const _4 = new s6();
    return _4.addPath(c9, true), _4.lineTo(h6), this._makeControlPoint(_4.path()), _4.lineTo(a10), this._makeControlPoint(_4.path()), _4.lineTo(u9), this._makeControlPoint(_4.path()), _4.addPath(l8, false), e10 ? { paths: [_4.path()] } : (_4.close(), { rings: [_4.path()] });
  }
  _constructCrossedArrow(t8) {
    const e10 = this._curveHelper.calculatePathLength(t8);
    let r17 = this._width;
    e10 < r17 * (1 + l5 + 1) && (r17 = e10 / (1 + l5 + 1));
    const n16 = this._curveHelper.getSubCurve(t8, 0, e10 - r17 * (1 + l5));
    if (!n16)
      return null;
    const s10 = r17 / 2;
    if (this._curveHelper.isEmpty(n16, false))
      return null;
    const i8 = this._constructOffset(n16, s10);
    if (!i8)
      return null;
    const c9 = this._constructOffset(n16, -s10);
    if (!c9)
      return null;
    const u9 = this._curveHelper.getSubCurve(t8, 0, e10 - r17);
    if (!u9)
      return null;
    if (this._curveHelper.isEmpty(u9, false))
      return null;
    const h6 = this._constructOffset(u9, s10);
    if (!h6)
      return null;
    const a10 = this._constructOffset(u9, -s10);
    if (!a10)
      return null;
    const _4 = h6[h6.length - 1], f7 = this._constructArrowBasePoint(h6, s10 / 2);
    if (!f7)
      return null;
    const p3 = a10[a10.length - 1], m7 = this._constructArrowBasePoint(a10, -s10 / 2);
    if (!m7)
      return null;
    const d2 = t8[t8.length - 1];
    this._makeControlPoint(i8, false), this._makeControlPoint(c9, false);
    const w4 = new s6();
    return w4.addPath(i8, true), this._makeControlPoint(w4.path()), w4.lineTo(p3), w4.lineTo(m7), this._makeControlPoint(w4.path()), w4.lineTo(d2), this._makeControlPoint(w4.path()), w4.lineTo(f7), this._makeControlPoint(w4.path()), w4.lineTo(_4), this._makeControlPoint(w4.path()), w4.addPath(c9, false), { paths: [w4.path()] };
  }
  _constructOffset(t8, e10) {
    return this._curveHelper.offset(t8, e10, O.Rounded, 4, this._offsetFlattenError);
  }
  _constructArrowBasePoint(t8, e10) {
    if (!t8 || t8.length < 2)
      return null;
    const r17 = t8[t8.length - 2], n16 = t8[t8.length - 1], o10 = [n16[0] - r17[0], n16[1] - r17[1]];
    return this._curveHelper.normalize(o10), [n16[0] + o10[1] * e10, n16[1] - o10[0] * e10];
  }
  _makeControlPoint(t8, r17 = false) {
    j2(r17 ? t8[0] : t8[t8.length - 1], 1);
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectBuffer.js
var f5 = class {
  static local() {
    return null === f5.instance && (f5.instance = new f5()), f5.instance;
  }
  execute(e10, t8, s10, i8) {
    return new h3(e10, t8, s10, i8);
  }
};
f5.instance = null;
var h3 = class {
  constructor(e10, t8, s10, i8) {
    this._inputGeometries = e10, this._curveHelper = new n6(), this._size = (void 0 !== t8.size ? t8.size : 1) * s10, this._offsetFlattenError = e7 * s10;
  }
  next() {
    let n16 = this._inputGeometries.next();
    for (; n16; ) {
      if (s3(n16))
        if (this._size > 0) {
          const e10 = [[n16.xmin, n16.ymin], [n16.xmin, n16.ymax], [n16.xmax, n16.ymax], [n16.xmax, n16.ymin], [n16.xmin, n16.ymin]], t8 = this._curveHelper.offset(e10, this._size, O.Rounded, 4, this._offsetFlattenError);
          if (t8)
            return { rings: [t8] };
        } else {
          if (!(this._size < 0))
            return n16;
          if (Math.min(n16.xmax - n16.xmin, n16.ymax - n16.ymin) + 2 * this._size > 0)
            return { xmin: n16.xmin - this._size, xmax: n16.xmax + this._size, ymin: n16.ymin - this._size, ymax: n16.ymax + this._size };
        }
      if (c2(n16)) {
        if (0 === this._size)
          return n16;
        const e10 = [];
        for (const t8 of n16.rings) {
          const s10 = this._curveHelper.offset(t8, this._size, O.Rounded, 4, this._offsetFlattenError);
          s10 && e10.push(s10);
        }
        if (e10.length)
          return { rings: e10 };
      }
      if (y(n16) && this._size > 0) {
        const e10 = [];
        for (const t8 of n16.paths)
          if (t8 && t8.length > 1) {
            const s10 = this._curveHelper.offset(t8, this._size, O.Rounded, 4, this._offsetFlattenError), i8 = this._curveHelper.offset(t8, -this._size, O.Rounded, 4, this._offsetFlattenError);
            if (s10 && i8) {
              for (let e11 = i8.length - 1; e11 >= 0; e11--)
                s10.push(i8[e11]);
              s10.push([s10[0][0], s10[0][1]]), e10.push(s10);
            }
          }
        if (e10.length)
          return { rings: e10 };
      }
      l(n16) && this._size, n16 = this._inputGeometries.next();
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectControlMeasureLine.js
var _ = class {
  static local() {
    return null === _.instance && (_.instance = new _()), _.instance;
  }
  execute(s10, t8, i8, h6) {
    return new c6(s10, t8, i8);
  }
};
_.instance = null;
var c6 = class {
  constructor(s10, t8, i8) {
    this._default_point_size = 20, this._inputGeometries = s10, this._geomUnitsPerPoint = i8, this._rule = t8.rule ?? R.FullGeometry, this._default_size = this._default_point_size * i8;
  }
  next() {
    let e10;
    for (; e10 = this._inputGeometries.next(); ) {
      let r17;
      if (l(e10) ? r17 = this._processGeom([[[e10.x, e10.y]]]) : f(e10) ? r17 = this._processGeom([e10.points]) : y(e10) ? r17 = this._processGeom(e10.paths) : c2(e10) && (r17 = this._processGeom(e10.rings)), r17 && r17.length)
        return { paths: r17 };
    }
    return null;
  }
  _clone(s10) {
    return [s10[0], s10[1]];
  }
  _mid(s10, t8) {
    return [(s10[0] + t8[0]) / 2, (s10[1] + t8[1]) / 2];
  }
  _mix(s10, t8, i8, h6) {
    return [s10[0] * t8 + i8[0] * h6, s10[1] * t8 + i8[1] * h6];
  }
  _add(s10, t8) {
    return [s10[0] + t8[0], s10[1] + t8[1]];
  }
  _add2(s10, t8, i8) {
    return [s10[0] + t8, s10[1] + i8];
  }
  _sub(s10, t8) {
    return [s10[0] - t8[0], s10[1] - t8[1]];
  }
  _dist(s10, t8) {
    return Math.sqrt((s10[0] - t8[0]) * (s10[0] - t8[0]) + (s10[1] - t8[1]) * (s10[1] - t8[1]));
  }
  _norm(s10) {
    return Math.sqrt(s10[0] * s10[0] + s10[1] * s10[1]);
  }
  _normalize(s10, t8 = 1) {
    const i8 = t8 / this._norm(s10);
    s10[0] *= i8, s10[1] *= i8;
  }
  _leftPerpendicular(s10) {
    const t8 = -s10[1], i8 = s10[0];
    s10[0] = t8, s10[1] = i8;
  }
  _leftPerp(s10) {
    return [-s10[1], s10[0]];
  }
  _rightPerpendicular(s10) {
    const t8 = s10[1], i8 = -s10[0];
    s10[0] = t8, s10[1] = i8;
  }
  _rightPerp(s10) {
    return [s10[1], -s10[0]];
  }
  _dotProduct(s10, t8) {
    return s10[0] * t8[0] + s10[1] * t8[1];
  }
  _crossProduct(s10, t8) {
    return s10[0] * t8[1] - s10[1] * t8[0];
  }
  _rotateDirect(s10, t8, i8) {
    const h6 = s10[0] * t8 - s10[1] * i8, e10 = s10[0] * i8 + s10[1] * t8;
    s10[0] = h6, s10[1] = e10;
  }
  _makeCtrlPt(s10) {
    const t8 = [s10[0], s10[1]];
    return j2(t8, 1), t8;
  }
  _addAngledTicks(s10, t8, i8, h6) {
    const e10 = this._sub(i8, t8);
    this._normalize(e10);
    const r17 = this._crossProduct(e10, this._sub(h6, t8));
    let _4;
    _4 = r17 > 0 ? this._rightPerp(e10) : this._leftPerp(e10);
    const c9 = Math.abs(r17) / 2, u9 = [];
    u9.push([t8[0] + (_4[0] - e10[0]) * c9, t8[1] + (_4[1] - e10[1]) * c9]), u9.push(t8), u9.push(i8), u9.push([i8[0] + (_4[0] + e10[0]) * c9, i8[1] + (_4[1] + e10[1]) * c9]), s10.push(u9);
  }
  _addBezier2(s10, t8, i8, h6, e10) {
    if (0 == e10--)
      return void s10.push(h6);
    const r17 = this._mid(t8, i8), _4 = this._mid(i8, h6), c9 = this._mid(r17, _4);
    this._addBezier2(s10, t8, r17, c9, e10), this._addBezier2(s10, c9, _4, h6, e10);
  }
  _addBezier3(s10, t8, i8, h6, e10, r17) {
    if (0 == r17--)
      return void s10.push(e10);
    const _4 = this._mid(t8, i8), c9 = this._mid(i8, h6), u9 = this._mid(h6, e10), o10 = this._mid(_4, c9), n16 = this._mid(c9, u9), a10 = this._mid(o10, n16);
    this._addBezier3(s10, t8, _4, o10, a10, r17), this._addBezier3(s10, a10, n16, u9, e10, r17);
  }
  _add90DegArc(s10, t8, i8, h6, e10) {
    const r17 = e10 ?? this._crossProduct(this._sub(i8, t8), this._sub(h6, t8)) > 0, _4 = this._mid(t8, i8), c9 = this._sub(_4, t8);
    r17 ? this._leftPerpendicular(c9) : this._rightPerpendicular(c9), _4[0] += c9[0], _4[1] += c9[1], this._addBezier3(s10, t8, this._mix(t8, 0.33333, _4, 0.66667), this._mix(i8, 0.33333, _4, 0.66667), i8, 4);
  }
  _addArrow(s10, t8, i8) {
    const h6 = t8[0], e10 = t8[1], r17 = t8[t8.length - 1], _4 = this._sub(h6, e10);
    this._normalize(_4);
    const c9 = this._crossProduct(_4, this._sub(r17, e10)), u9 = 0.5 * c9, o10 = this._leftPerp(_4), n16 = [r17[0] - o10[0] * c9, r17[1] - o10[1] * c9], a10 = t8.length - 1, p3 = [];
    p3.push(i8 ? [-o10[0], -o10[1]] : o10);
    let l8 = [-_4[0], -_4[1]];
    for (let d2 = 1; d2 < a10 - 1; d2++) {
      const s11 = this._sub(t8[d2 + 1], t8[d2]);
      this._normalize(s11);
      const i9 = this._dotProduct(s11, l8), h7 = this._crossProduct(s11, l8), e11 = Math.sqrt((1 + i9) / 2), r18 = this._sub(s11, l8);
      this._normalize(r18), r18[0] /= e11, r18[1] /= e11, p3.push(h7 < 0 ? [-r18[0], -r18[1]] : r18), l8 = s11;
    }
    p3.push(this._rightPerp(l8));
    for (let d2 = p3.length - 1; d2 > 0; d2--)
      s10.push([t8[d2][0] + p3[d2][0] * u9, t8[d2][1] + p3[d2][1] * u9]);
    s10.push([n16[0] + p3[0][0] * u9, n16[1] + p3[0][1] * u9]), s10.push([n16[0] + p3[0][0] * c9, n16[1] + p3[0][1] * c9]), s10.push(h6), s10.push([n16[0] - p3[0][0] * c9, n16[1] - p3[0][1] * c9]), s10.push([n16[0] - p3[0][0] * u9, n16[1] - p3[0][1] * u9]);
    for (let d2 = 1; d2 < p3.length; d2++)
      s10.push([t8[d2][0] - p3[d2][0] * u9, t8[d2][1] - p3[d2][1] * u9]);
  }
  _cp2(s10, t8, i8) {
    return s10.length >= 2 ? s10[1] : this._add2(s10[0], t8 * this._default_size, i8 * this._default_size);
  }
  _cp3(s10, t8, i8, h6) {
    if (s10.length >= 3)
      return s10[2];
    const e10 = this._mix(s10[0], 1 - i8, t8, i8), r17 = this._sub(t8, s10[0]);
    return this._normalize(r17), this._rightPerpendicular(r17), [e10[0] + r17[0] * h6 * this._default_size, e10[1] + r17[1] * h6 * this._default_size];
  }
  _arrowPath(s10) {
    if (s10.length > 2)
      return s10;
    const t8 = s10[0], i8 = this._cp2(s10, -4, 0), h6 = this._sub(t8, i8);
    this._normalize(h6);
    const e10 = this._rightPerp(h6);
    return [t8, i8, [t8[0] + (e10[0] - h6[0]) * this._default_size, t8[1] + (e10[1] - h6[1]) * this._default_size]];
  }
  _arrowLastSeg(s10) {
    const t8 = s10[0], i8 = this._cp2(s10, -4, 0);
    let h6;
    if (s10.length >= 3)
      h6 = s10[s10.length - 1];
    else {
      const s11 = this._sub(t8, i8);
      this._normalize(s11);
      const e10 = this._rightPerp(s11);
      h6 = [t8[0] + (e10[0] - s11[0]) * this._default_size, t8[1] + (e10[1] - s11[1]) * this._default_size];
    }
    return [i8, h6];
  }
  _processGeom(s10) {
    if (!s10)
      return null;
    const t8 = [];
    for (const i8 of s10) {
      if (!i8 || 0 === i8.length)
        continue;
      const s11 = i8.length;
      let h6 = i8[0];
      switch (this._rule) {
        case R.PerpendicularFromFirstSegment: {
          const s12 = this._cp2(i8, 0, -1), e10 = this._cp3(i8, s12, 0.5, 4), r17 = [];
          r17.push(e10), r17.push(this._mid(h6, s12)), t8.push(r17);
          break;
        }
        case R.ReversedFirstSegment: {
          const s12 = this._cp2(i8, 0, -1);
          t8.push([s12, h6]);
          break;
        }
        case R.PerpendicularToSecondSegment: {
          const s12 = this._cp2(i8, -4, 1), e10 = this._cp3(i8, s12, 0.882353, -1.94), r17 = [];
          r17.push(this._mid(s12, e10)), r17.push(h6), t8.push(r17);
          break;
        }
        case R.SecondSegmentWithTicks: {
          const s12 = this._cp2(i8, -4, 1), e10 = this._cp3(i8, s12, 0.882353, -1.94), r17 = this._sub(e10, s12);
          let _4;
          _4 = this._crossProduct(r17, this._sub(h6, s12)) > 0 ? this._rightPerp(_4) : this._leftPerp(r17);
          const c9 = [];
          c9.push([s12[0] + (_4[0] - r17[0]) / 3, s12[1] + (_4[1] - r17[1]) / 3]), c9.push(s12), c9.push(e10), c9.push([e10[0] + (_4[0] + r17[0]) / 3, e10[1] + (_4[1] + r17[1]) / 3]), t8.push(c9);
          break;
        }
        case R.DoublePerpendicular: {
          const s12 = this._cp2(i8, 0, -1), e10 = this._cp3(i8, s12, 0.5, 3), r17 = this._mid(h6, s12), _4 = this._sub(r17, e10);
          this._normalize(_4);
          const c9 = this._crossProduct(_4, this._sub(h6, e10));
          this._leftPerpendicular(_4);
          const u9 = [];
          u9.push(h6), u9.push([e10[0] + _4[0] * c9, e10[1] + _4[1] * c9]), t8.push(u9);
          const o10 = [];
          o10.push([e10[0] - _4[0] * c9, e10[1] - _4[1] * c9]), o10.push(s12), t8.push(o10);
          break;
        }
        case R.OppositeToFirstSegment: {
          const s12 = this._cp2(i8, 0, -1), e10 = this._cp3(i8, s12, 0.5, 3), r17 = this._mid(h6, s12), _4 = this._sub(r17, e10);
          this._normalize(_4);
          const c9 = this._crossProduct(_4, this._sub(h6, e10));
          this._leftPerpendicular(_4);
          const u9 = [];
          u9.push([e10[0] + _4[0] * c9, e10[1] + _4[1] * c9]), u9.push([e10[0] - _4[0] * c9, e10[1] - _4[1] * c9]), t8.push(u9);
          break;
        }
        case R.TriplePerpendicular: {
          const s12 = this._cp2(i8, 0, -1), e10 = this._cp3(i8, s12, 0.5, 4), r17 = this._mid(h6, s12), _4 = this._sub(r17, e10);
          this._normalize(_4);
          const c9 = this._crossProduct(_4, this._sub(h6, e10));
          this._leftPerpendicular(_4);
          const u9 = [];
          u9.push([e10[0] + _4[0] * c9 * 0.8, e10[1] + _4[1] * c9 * 0.8]), u9.push([r17[0] + 0.8 * (h6[0] - r17[0]), r17[1] + 0.8 * (h6[1] - r17[1])]), t8.push(u9), t8.push([e10, r17]);
          const o10 = [];
          o10.push([e10[0] - _4[0] * c9 * 0.8, e10[1] - _4[1] * c9 * 0.8]), o10.push([r17[0] + 0.8 * (s12[0] - r17[0]), r17[1] + 0.8 * (s12[1] - r17[1])]), t8.push(o10);
          break;
        }
        case R.HalfCircleFirstSegment: {
          const s12 = this._cp2(i8, 0, -1), e10 = this._cp3(i8, s12, 0.5, 4), r17 = this._mid(h6, s12);
          let _4 = this._sub(s12, h6);
          const c9 = Math.cos(Math.PI / 18), u9 = Math.sin(Math.PI / 18), o10 = Math.sqrt((1 + c9) / 2), n16 = Math.sqrt((1 - c9) / 2), a10 = [];
          let p3;
          this._crossProduct(_4, this._sub(e10, h6)) > 0 ? (a10.push(h6), _4 = this._sub(h6, r17), p3 = s12) : (a10.push(s12), _4 = this._sub(s12, r17), p3 = h6), this._rotateDirect(_4, o10, n16), _4[0] /= o10, _4[1] /= o10;
          for (let t9 = 1; t9 <= 18; t9++)
            a10.push(this._add(r17, _4)), this._rotateDirect(_4, c9, u9);
          a10.push(p3), t8.push(a10);
          break;
        }
        case R.HalfCircleSecondSegment: {
          const s12 = this._cp2(i8, 0, -1), e10 = this._cp3(i8, s12, 1, -1);
          let r17 = this._sub(h6, s12);
          this._normalize(r17);
          const _4 = this._crossProduct(r17, this._sub(e10, s12)) / 2;
          this._leftPerpendicular(r17);
          const c9 = [s12[0] + r17[0] * _4, s12[1] + r17[1] * _4];
          r17 = this._sub(s12, c9);
          const u9 = Math.cos(Math.PI / 18);
          let o10 = Math.sin(Math.PI / 18);
          _4 > 0 && (o10 = -o10);
          const n16 = [s12];
          for (let t9 = 1; t9 <= 18; t9++)
            this._rotateDirect(r17, u9, o10), n16.push(this._add(c9, r17));
          t8.push(n16);
          break;
        }
        case R.HalfCircleExtended: {
          const e10 = this._cp2(i8, 0, -2), r17 = this._cp3(i8, e10, 1, -1);
          let _4;
          if (s11 >= 4)
            _4 = i8[3];
          else {
            const s12 = this._sub(h6, e10);
            _4 = this._add(r17, s12);
          }
          const c9 = this._dist(e10, r17) / 2 / 0.75, u9 = this._sub(e10, h6);
          this._normalize(u9, c9);
          const o10 = this._sub(r17, _4);
          this._normalize(o10, c9);
          const n16 = [_4, r17];
          t8.push(n16);
          const a10 = [this._clone(r17)];
          this._addBezier3(a10, r17, this._add(r17, o10), this._add(e10, u9), e10, 4), a10.push(h6), t8.push(a10);
          break;
        }
        case R.OpenCircle: {
          const s12 = this._cp2(i8, -2, 0), e10 = this._sub(s12, h6), r17 = Math.cos(Math.PI / 18), _4 = -Math.sin(Math.PI / 18), c9 = [s12];
          for (let t9 = 1; t9 <= 33; t9++)
            this._rotateDirect(e10, r17, _4), c9.push(this._add(h6, e10));
          t8.push(c9);
          break;
        }
        case R.CoverageEdgesWithTicks: {
          const e10 = this._cp2(i8, 0, -1);
          let r17, _4;
          if (s11 >= 3)
            r17 = i8[2];
          else {
            const s12 = this._sub(e10, h6), t9 = this._leftPerp(s12);
            r17 = [h6[0] + t9[0] - 0.25 * s12[0], h6[1] + t9[1] - 0.25 * s12[1]];
          }
          if (s11 >= 4)
            _4 = i8[3];
          else {
            const s12 = this._mid(h6, e10), t9 = this._sub(h6, e10);
            this._normalize(t9), this._leftPerpendicular(t9);
            const i9 = this._crossProduct(t9, this._sub(r17, s12));
            this._rightPerpendicular(t9), _4 = [r17[0] + t9[0] * i9 * 2, r17[1] + t9[1] * i9 * 2];
          }
          const c9 = this._sub(e10, h6);
          let u9, o10;
          u9 = this._crossProduct(c9, this._sub(r17, h6)) > 0 ? this._rightPerp(c9) : this._leftPerp(c9), o10 = [], o10.push(r17), o10.push(h6), o10.push([h6[0] + (u9[0] - c9[0]) / 3, h6[1] + (u9[1] - c9[1]) / 3]), t8.push(o10), u9 = this._crossProduct(c9, this._sub(_4, e10)) > 0 ? this._rightPerp(u9) : this._leftPerp(c9), o10 = [], o10.push([e10[0] + (u9[0] + c9[0]) / 3, e10[1] + (u9[1] + c9[1]) / 3]), o10.push(e10), o10.push(_4), t8.push(o10);
          break;
        }
        case R.GapExtentWithDoubleTicks: {
          const e10 = this._cp2(i8, 0, 2), r17 = this._cp3(i8, e10, 0, 1);
          let _4;
          if (s11 >= 4)
            _4 = i8[3];
          else {
            const s12 = this._sub(e10, h6);
            _4 = this._add(r17, s12);
          }
          this._addAngledTicks(t8, h6, e10, this._mid(r17, _4)), this._addAngledTicks(t8, r17, _4, this._mid(h6, e10));
          break;
        }
        case R.GapExtentMidline: {
          const e10 = this._cp2(i8, 2, 0), r17 = this._cp3(i8, e10, 0, 1);
          let _4;
          if (s11 >= 4)
            _4 = i8[3];
          else {
            const s12 = this._sub(e10, h6);
            _4 = this._add(r17, s12);
          }
          const c9 = [];
          c9.push(this._mid(h6, r17)), c9.push(this._mid(e10, _4)), t8.push(c9);
          break;
        }
        case R.Chevron: {
          const e10 = this._cp2(i8, -1, -1);
          let r17;
          if (s11 >= 3)
            r17 = i8[2];
          else {
            const s12 = this._sub(e10, h6);
            this._leftPerpendicular(s12), r17 = this._add(h6, s12);
          }
          t8.push([e10, this._makeCtrlPt(h6), r17]);
          break;
        }
        case R.PerpendicularWithArc: {
          const s12 = this._cp2(i8, 0, -2), e10 = this._cp3(i8, s12, 0.5, -1);
          let r17 = this._sub(s12, h6);
          const _4 = this._norm(r17);
          r17[0] /= _4, r17[1] /= _4;
          const c9 = this._crossProduct(r17, this._sub(e10, h6));
          let u9 = this._dotProduct(r17, this._sub(e10, h6));
          u9 < 0.05 * _4 ? u9 = 0.05 * _4 : u9 > 0.95 * _4 && (u9 = 0.95 * _4);
          const o10 = [h6[0] + r17[0] * u9, h6[1] + r17[1] * u9];
          this._leftPerpendicular(r17);
          let n16 = [];
          n16.push([o10[0] - r17[0] * c9, o10[1] - r17[1] * c9]), n16.push([o10[0] + r17[0] * c9, o10[1] + r17[1] * c9]), t8.push(n16);
          const a10 = [s12[0] + r17[0] * c9, s12[1] + r17[1] * c9];
          r17 = this._sub(s12, a10);
          const p3 = Math.cos(Math.PI / 18);
          let l8 = Math.sin(Math.PI / 18);
          c9 < 0 && (l8 = -l8), n16 = [h6, s12];
          for (let t9 = 1; t9 <= 9; t9++)
            this._rotateDirect(r17, p3, l8), n16.push(this._add(a10, r17));
          t8.push(n16);
          break;
        }
        case R.ClosedHalfCircle: {
          const s12 = this._cp2(i8, 2, 0), e10 = this._mid(h6, s12), r17 = this._sub(s12, e10), _4 = Math.cos(Math.PI / 18), c9 = Math.sin(Math.PI / 18), u9 = [h6, s12];
          for (let t9 = 1; t9 <= 18; t9++)
            this._rotateDirect(r17, _4, c9), u9.push(this._add(e10, r17));
          t8.push(u9);
          break;
        }
        case R.TripleParallelExtended: {
          const s12 = this._cp2(i8, 0, -2), r17 = this._cp3(i8, s12, 1, -2), _4 = this._mid(h6, s12), c9 = this._sub(r17, s12);
          this._normalize(c9);
          const u9 = Math.abs(this._crossProduct(c9, this._sub(_4, s12))) / 2, o10 = this._dist(s12, r17), n16 = [s12, h6];
          n16.push([h6[0] + c9[0] * o10 * 0.5, h6[1] + c9[1] * o10 * 0.5]), t8.push(n16);
          const a10 = [];
          a10.push([_4[0] - c9[0] * u9, _4[1] - c9[1] * u9]), a10.push([_4[0] + c9[0] * o10 * 0.375, _4[1] + c9[1] * o10 * 0.375]), j2(a10[a10.length - 1], 1), a10.push([_4[0] + c9[0] * o10 * 0.75, _4[1] + c9[1] * o10 * 0.75]), t8.push(a10);
          const p3 = [s12, r17];
          t8.push(p3);
          break;
        }
        case R.ParallelWithTicks: {
          const s12 = this._cp2(i8, 3, 0), e10 = this._cp3(i8, s12, 0.5, -1), r17 = this._sub(e10, s12);
          this._normalize(r17);
          const _4 = this._crossProduct(r17, this._sub(e10, h6));
          this._leftPerpendicular(r17), this._addAngledTicks(t8, h6, s12, e10), this._addAngledTicks(t8, this._mix(h6, 1, r17, _4), this._mix(s12, 1, r17, _4), this._mid(h6, s12));
          break;
        }
        case R.Parallel: {
          const s12 = this._cp2(i8, 3, 0), e10 = this._cp3(i8, s12, 0.5, -1), r17 = this._sub(s12, h6);
          this._normalize(r17);
          const _4 = this._leftPerp(r17), c9 = this._crossProduct(r17, this._sub(e10, h6));
          let u9 = [h6, s12];
          t8.push(u9), u9 = [], u9.push([h6[0] + _4[0] * c9, h6[1] + _4[1] * c9]), u9.push([s12[0] + _4[0] * c9, s12[1] + _4[1] * c9]), t8.push(u9);
          break;
        }
        case R.PerpendicularToFirstSegment: {
          const s12 = this._cp2(i8, 3, 0), e10 = this._cp3(i8, s12, 0.5, -1), r17 = this._mid(h6, s12), _4 = this._sub(s12, h6);
          this._normalize(_4);
          const c9 = this._crossProduct(_4, this._sub(e10, h6));
          this._leftPerpendicular(_4);
          const u9 = [];
          u9.push([r17[0] - _4[0] * c9 * 0.25, r17[1] - _4[1] * c9 * 0.25]), u9.push([r17[0] + _4[0] * c9 * 1.25, r17[1] + _4[1] * c9 * 1.25]), t8.push(u9);
          break;
        }
        case R.ParallelOffset: {
          const s12 = this._cp2(i8, 3, 0), e10 = this._cp3(i8, s12, 0.5, -1), r17 = this._sub(s12, h6);
          this._normalize(r17);
          const _4 = this._crossProduct(r17, this._sub(e10, h6));
          this._leftPerpendicular(r17);
          const c9 = [];
          c9.push([h6[0] - r17[0] * _4, h6[1] - r17[1] * _4]), c9.push([s12[0] - r17[0] * _4, s12[1] - r17[1] * _4]), t8.push(c9);
          const u9 = [];
          u9.push([h6[0] + r17[0] * _4, h6[1] + r17[1] * _4]), u9.push([s12[0] + r17[0] * _4, s12[1] + r17[1] * _4]), t8.push(u9);
          break;
        }
        case R.OffsetOpposite: {
          const s12 = this._cp2(i8, 3, 0), e10 = this._cp3(i8, s12, 0.5, -1), r17 = this._sub(s12, h6);
          this._normalize(r17);
          const _4 = this._crossProduct(r17, this._sub(e10, h6));
          this._leftPerpendicular(r17);
          const c9 = [];
          c9.push([h6[0] - r17[0] * _4, h6[1] - r17[1] * _4]), c9.push([s12[0] - r17[0] * _4, s12[1] - r17[1] * _4]), t8.push(c9);
          break;
        }
        case R.OffsetSame: {
          const s12 = this._cp2(i8, 3, 0), e10 = this._cp3(i8, s12, 0.5, -1), r17 = this._sub(s12, h6);
          this._normalize(r17);
          const _4 = this._crossProduct(r17, this._sub(e10, h6));
          this._leftPerpendicular(r17);
          const c9 = [];
          c9.push([h6[0] + r17[0] * _4, h6[1] + r17[1] * _4]), c9.push([s12[0] + r17[0] * _4, s12[1] + r17[1] * _4]), t8.push(c9);
          break;
        }
        case R.CircleWithArc: {
          let r17 = this._cp2(i8, 3, 0);
          const _4 = this._cp3(i8, r17, 0.5, -1);
          let c9, u9;
          if (s11 >= 4)
            c9 = i8[3], u9 = this._crossProduct(this._sub(c9, r17), this._sub(_4, r17)) > 0;
          else {
            c9 = r17, u9 = this._crossProduct(this._sub(c9, h6), this._sub(_4, h6)) > 0;
            const s12 = 24 * this._geomUnitsPerPoint, t9 = this._sub(c9, h6);
            this._normalize(t9, s12);
            const i9 = Math.sqrt(2) / 2;
            this._rotateDirect(t9, i9, u9 ? i9 : -i9), r17 = this._add(h6, t9);
          }
          const o10 = this._sub(r17, h6), n16 = Math.cos(Math.PI / 18), a10 = Math.sin(Math.PI / 18), p3 = [r17];
          for (let s12 = 1; s12 <= 36; s12++)
            this._rotateDirect(o10, n16, a10), p3.push(this._add(h6, o10));
          this._add90DegArc(p3, r17, c9, _4, u9), j2(p3[p3.length - 8], 1), t8.push(p3);
          break;
        }
        case R.DoubleJog: {
          let e10, r17, _4 = this._cp2(i8, -3, 1);
          if (e10 = s11 >= 3 ? i8[2] : this._add(h6, this._sub(h6, _4)), s11 >= 4)
            r17 = i8[3];
          else {
            const s12 = h6;
            h6 = _4, r17 = e10;
            const t9 = this._dist(h6, s12), i9 = this._dist(r17, s12);
            let c10 = 30 * this._geomUnitsPerPoint;
            0.5 * t9 < c10 && (c10 = 0.5 * t9), 0.5 * i9 < c10 && (c10 = 0.5 * i9), _4 = this._mix(h6, c10 / t9, s12, (t9 - c10) / t9), e10 = this._mix(r17, c10 / i9, s12, (i9 - c10) / i9);
          }
          const c9 = this._mid(h6, _4), u9 = this._mid(r17, e10), o10 = this._dist(h6, _4), n16 = this._dist(e10, r17);
          let a10 = Math.min(o10, n16) / 8;
          a10 = Math.min(a10, 24 * this._geomUnitsPerPoint);
          const p3 = Math.cos(Math.PI / 4);
          let l8 = this._sub(h6, _4);
          this._normalize(l8, a10), this._crossProduct(l8, this._sub(r17, _4)) > 0 ? this._rotateDirect(l8, p3, -p3) : this._rotateDirect(l8, p3, p3);
          let d2 = [];
          d2.push(_4), d2.push(this._add(c9, l8)), d2.push(this._sub(c9, l8)), d2.push(h6), t8.push(d2), l8 = this._sub(r17, e10), this._normalize(l8, a10), this._crossProduct(l8, this._sub(h6, e10)) < 0 ? this._rotateDirect(l8, p3, p3) : this._rotateDirect(l8, p3, -p3), d2 = [], d2.push(e10), d2.push(this._add(u9, l8)), d2.push(this._sub(u9, l8)), d2.push(r17), t8.push(d2);
          break;
        }
        case R.PerpendicularOffset: {
          const s12 = this._cp2(i8, -4, 1), e10 = this._cp3(i8, s12, 0.882353, -1.94), r17 = this._sub(e10, s12);
          this._crossProduct(r17, this._sub(h6, s12)) > 0 ? this._rightPerpendicular(r17) : this._leftPerpendicular(r17);
          const _4 = [r17[0] / 8, r17[1] / 8], c9 = this._sub(this._mid(s12, e10), _4);
          t8.push([c9, h6]);
          break;
        }
        case R.LineExcludingLastSegment: {
          const s12 = this._arrowPath(i8), h7 = [];
          let e10 = s12.length - 2;
          for (; e10--; )
            h7.push(s12[e10]);
          t8.push(h7);
          break;
        }
        case R.MultivertexArrow: {
          const s12 = this._arrowPath(i8), h7 = [];
          this._addArrow(h7, s12, false), t8.push(h7);
          break;
        }
        case R.CrossedArrow: {
          const s12 = this._arrowPath(i8), h7 = [];
          this._addArrow(h7, s12, true), t8.push(h7);
          break;
        }
        case R.ChevronArrow: {
          const [s12, e10] = this._arrowLastSeg(i8), r17 = 10 * this._geomUnitsPerPoint, _4 = this._sub(h6, s12);
          this._normalize(_4);
          const c9 = this._crossProduct(_4, this._sub(e10, s12)), u9 = this._leftPerp(_4), o10 = [e10[0] - u9[0] * c9 * 2, e10[1] - u9[1] * c9 * 2], n16 = [];
          n16.push([e10[0] + _4[0] * r17, e10[1] + _4[1] * r17]), n16.push(h6), n16.push([o10[0] + _4[0] * r17, o10[1] + _4[1] * r17]), t8.push(n16);
          break;
        }
        case R.ChevronArrowOffset: {
          const [s12, e10] = this._arrowLastSeg(i8), r17 = this._sub(h6, s12);
          this._normalize(r17);
          const _4 = this._crossProduct(r17, this._sub(e10, s12));
          this._leftPerpendicular(r17);
          const c9 = [e10[0] - r17[0] * _4, e10[1] - r17[1] * _4], u9 = [];
          u9.push([c9[0] + r17[0] * _4 * 0.5, c9[1] + r17[1] * _4 * 0.5]), u9.push(this._mid(c9, h6)), u9.push([c9[0] - r17[0] * _4 * 0.5, c9[1] - r17[1] * _4 * 0.5]), t8.push(u9);
          break;
        }
        case R.PartialFirstSegment: {
          const [s12, e10] = this._arrowLastSeg(i8), r17 = this._sub(h6, s12);
          this._normalize(r17);
          const _4 = this._crossProduct(r17, this._sub(e10, s12));
          this._leftPerpendicular(r17);
          const c9 = [e10[0] - r17[0] * _4, e10[1] - r17[1] * _4];
          t8.push([s12, c9]);
          break;
        }
        case R.Arch: {
          const s12 = this._cp2(i8, 0, -1), e10 = this._cp3(i8, s12, 0.5, 1), r17 = this._sub(h6, s12), _4 = this._mix(e10, 1, r17, 0.55), c9 = this._mix(e10, 1, r17, -0.55), u9 = [h6];
          this._addBezier2(u9, h6, _4, e10, 4), this._addBezier2(u9, e10, c9, s12, 4), t8.push(u9);
          break;
        }
        case R.CurvedParallelTicks: {
          const s12 = this._cp2(i8, -4, 1), e10 = this._cp3(i8, s12, 0.882353, -1.94), r17 = this._sub(e10, s12);
          this._crossProduct(r17, this._sub(h6, s12)) > 0 ? this._rightPerpendicular(r17) : this._leftPerpendicular(r17);
          const _4 = [r17[0] / 8, r17[1] / 8], c9 = this._sub(this._mid(s12, e10), _4), u9 = this._sub(this._mix(s12, 0.75, e10, 0.25), _4), o10 = this._sub(this._mix(s12, 0.25, e10, 0.75), _4), n16 = [s12];
          this._addBezier2(n16, s12, u9, c9, 3), this._addBezier2(n16, c9, o10, e10, 3), t8.push(n16);
          for (let i9 = 0; i9 < 8; i9++) {
            const s13 = n16[2 * i9 + 1], h7 = [this._clone(s13)];
            h7.push(this._add(s13, [r17[0] / 4, r17[1] / 4])), t8.push(h7);
          }
          break;
        }
        case R.Arc90Degrees: {
          const s12 = this._cp2(i8, 0, -1), e10 = this._cp3(i8, s12, 0.5, 1), r17 = [s12];
          this._add90DegArc(r17, s12, h6, e10), t8.push(r17);
          break;
        }
        case R.FullGeometry:
        default:
          t8.push(i8);
      }
    }
    return t8;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectCut.js
var u6 = class {
  static local() {
    return null === u6.instance && (u6.instance = new u6()), u6.instance;
  }
  execute(e10, t8, u9, i8) {
    return new s7(e10, t8, u9);
  }
};
u6.instance = null;
var s7 = class extends U3 {
  constructor(e10, u9, s10) {
    super(e10, true, true), this._curveHelper = new n6(), this._beginCut = (void 0 !== u9.beginCut ? u9.beginCut : 1) * s10, this._endCut = (void 0 !== u9.endCut ? u9.endCut : 1) * s10, this._middleCut = (void 0 !== u9.middleCut ? u9.middleCut : 0) * s10, this._invert = void 0 !== u9.invert && u9.invert, this._beginCut < 0 && (this._beginCut = 0), this._endCut < 0 && (this._endCut = 0), this._middleCut < 0 && (this._middleCut = 0);
  }
  processPath(e10) {
    const t8 = this._beginCut, u9 = this._endCut, s10 = this._middleCut, i8 = this._curveHelper.calculatePathLength(e10), r17 = [];
    if (this._invert)
      if (0 === t8 && 0 === u9 && 0 === s10)
        ;
      else if (t8 + u9 + s10 >= i8)
        r17.push(e10);
      else {
        let n16 = this._curveHelper.getSubCurve(e10, 0, t8);
        n16 && r17.push(n16), n16 = this._curveHelper.getSubCurve(e10, 0.5 * (i8 - s10), 0.5 * (i8 + s10)), n16 && r17.push(n16), n16 = this._curveHelper.getSubCurve(e10, i8 - u9, u9), n16 && r17.push(n16);
      }
    else if (0 === t8 && 0 === u9 && 0 === s10)
      r17.push(e10);
    else if (t8 + u9 + s10 >= i8)
      ;
    else if (0 === s10) {
      const s11 = this._curveHelper.getSubCurve(e10, t8, i8 - u9);
      s11 && r17.push(s11);
    } else {
      let n16 = this._curveHelper.getSubCurve(e10, t8, 0.5 * (i8 - s10));
      n16 && r17.push(n16), n16 = this._curveHelper.getSubCurve(e10, 0.5 * (i8 + s10), i8 - u9), n16 && r17.push(n16);
    }
    return 0 === r17.length ? null : { paths: r17 };
  }
};

// node_modules/@arcgis/core/symbols/cim/GeometryWalker.js
var i5 = 1e-7;
var n7 = class {
  constructor() {
    this._values = [], this.extPtGap = 0, this.ctrlPtGap = 0, this._length = 0, this._currentValue = 0;
  }
  isEmpty() {
    return 0 === this._values.length;
  }
  size() {
    return this._values.length;
  }
  init(t8, s10, e10 = true) {
    if (this._setEmpty(), !t8 || 0 === t8.length)
      return false;
    for (let n16 = 0; n16 < t8.length; n16++) {
      let s11 = Math.abs(t8[n16]);
      e10 && s11 < i5 && (s11 = i5), this._values.push(s11), this._length += s11;
    }
    return s10 && 1 & t8.length && (this._length *= 2), 0 !== this._length && (this.ctrlPtGap = this.extPtGap = 0, this._currentValue = -1, true);
  }
  scale(t8) {
    const s10 = this._values ? this._values.length : 0;
    for (let e10 = 0; e10 < s10; ++e10)
      this._values[e10] *= t8;
    this._length *= t8, this.extPtGap *= t8, this.ctrlPtGap *= t8;
  }
  addValue(t8) {
    this._length += t8, this._values.push(t8);
  }
  firstValue() {
    return this._values[0];
  }
  lastValue() {
    return this._values[this._values.length - 1];
  }
  nextValue() {
    return this._currentValue++, this._currentValue === this._values.length && (this._currentValue = 0), this._values[this._currentValue];
  }
  reset() {
    this._currentValue = -1;
  }
  length() {
    return this._length;
  }
  _setEmpty() {
    this.extPtGap = this.ctrlPtGap = this._length = 0, this._currentValue = -1, this._values.length = 0;
  }
};
var h4;
!function(t8) {
  t8[t8.FAIL = 0] = "FAIL", t8[t8.END = 1] = "END", t8[t8.CONTINUE = 2] = "CONTINUE";
}(h4 || (h4 = {}));
var r7 = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.segment = -1, this.segmentLength = 0, this.abscissa = 0, this.isPathEnd = false, this.isPartEnd = false;
  }
  isValid() {
    return -1 !== this.segment;
  }
  copyTo(t8) {
    t8.segment = this.segment, t8.segmentLength = this.segmentLength, t8.abscissa = this.abscissa, t8.isPathEnd = this.isPathEnd, t8.isPartEnd = this.isPartEnd;
  }
};
var a5 = class extends n6 {
  constructor(t8 = 0, s10 = false) {
    super(t8, s10), this._tolerance = e7, this._currentPosition = new r7();
  }
  updateTolerance(t8) {
    this._tolerance = e7 * t8;
  }
  init(t8, s10, e10 = true) {
    return e10 ? (this._patternLength = s10.length(), this._partExtPtGap = s10.extPtGap, this._partCtrlPtGap = s10.ctrlPtGap) : (this._patternLength = 0, this._partExtPtGap = 0, this._partCtrlPtGap = 0), this._currentPosition.reset(), this._partSegCount = 0, this._path = t8, this._seg = -1, this._setPosAtNextPart();
  }
  curPositionIsValid() {
    return this._currentPosition.isValid();
  }
  nextPosition(t8, s10 = h4.FAIL) {
    const e10 = new r7();
    return !!this._nextPosition(t8, e10, null, s10) && (e10.copyTo(this._currentPosition), true);
  }
  curPointAndAngle(t8) {
    t8.pt = this._getPoint(this._currentPosition);
    const [s10, e10] = this._getAngle(this._currentPosition);
    t8.ca = s10, t8.sa = e10;
  }
  nextPointAndAngle(t8, s10, e10 = h4.FAIL) {
    const i8 = new r7();
    if (!this._nextPosition(t8, i8, null, e10))
      return false;
    i8.copyTo(this._currentPosition), s10.pt = this._getPoint(i8);
    const [n16, a10] = this._getAngle(i8);
    return s10.ca = n16, s10.sa = a10, true;
  }
  nextCurve(t8) {
    if (0 === t8)
      return null;
    const s10 = [], e10 = new r7();
    return this._nextPosition(t8, e10, s10, h4.END) ? (e10.copyTo(this._currentPosition), s10) : null;
  }
  isPathEnd() {
    return this._currentPosition.isPathEnd;
  }
  getPathEnd() {
    if (-1 === this._currentPosition.segment)
      throw new Error("missing segment");
    return this._path[this._currentPosition.segment + 1];
  }
  _nextPosition(t8, s10, e10, i8) {
    if (this._currentPosition.isPathEnd)
      return false;
    let n16 = this._currentPosition.abscissa;
    for (this._currentPosition.segmentLength > 0 && (n16 /= this._currentPosition.segmentLength), this._currentPosition.copyTo(s10); s10.abscissa + t8 * this._partLengthRatio > s10.segmentLength + this._tolerance; ) {
      if (e10) {
        if (0 === e10.length)
          if (0 === n16) {
            const t10 = this._path[s10.segment];
            e10.push([t10[0], t10[1]]);
          } else
            e10.push(this.getSegCoord2D(this._path, s10.segment, n16));
        const t9 = this._path[s10.segment + 1];
        e10.push([t9[0], t9[1]]);
      }
      if (n16 = 0, t8 -= (s10.segmentLength - s10.abscissa) / this._partLengthRatio, this._partSegCount)
        s10.segment = this._nextSegment(), s10.segmentLength = this.calculateSegLength(this._path, s10.segment), s10.abscissa = 0, this._partSegCount--;
      else {
        if (!this._setPosAtNextPart())
          return i8 !== h4.FAIL && (s10.segmentLength = this.calculateSegLength(this._path, s10.segment), s10.isPartEnd = true, i8 === h4.END ? (s10.abscissa = s10.segmentLength, s10.isPathEnd = true) : s10.abscissa = s10.segmentLength + t8, true);
        this._currentPosition.copyTo(s10);
      }
    }
    if (s10.abscissa += t8 * this._partLengthRatio, e10) {
      if (0 === e10.length)
        if (0 === n16) {
          const t10 = this._path[s10.segment];
          e10.push([t10[0], t10[1]]);
        } else
          e10.push(this.getSegCoord2D(this._path, s10.segment, n16));
      const t9 = s10.abscissa / s10.segmentLength;
      if (1 === t9) {
        const t10 = this._path[s10.segment + 1];
        e10.push([t10[0], t10[1]]);
      } else
        e10.push(this.getSegCoord2D(this._path, s10.segment, t9));
    }
    return this._partSegCount || Math.abs(s10.abscissa - s10.segmentLength) < this._tolerance && (s10.isPathEnd = this._partIsLast, s10.isPartEnd = true), true;
  }
  _getPoint(t8) {
    if (-1 === t8.segment)
      throw new Error("missing segment");
    const s10 = t8.segmentLength <= 0 ? 0 : t8.abscissa / t8.segmentLength;
    return this.getSegCoord2D(this._path, t8.segment, s10);
  }
  _getAngle(t8) {
    if (-1 === t8.segment)
      throw new Error("missing segment");
    const s10 = t8.segmentLength <= 0 ? 0 : t8.abscissa / t8.segmentLength;
    return this.getSegAngleCS(this._path, t8.segment, s10);
  }
  _setPosAtNextPart() {
    for (; this._partSegCount; )
      this._hasNextSegment() && this._nextSegment(), this._partSegCount--;
    if (!this._hasNextSegment())
      return false;
    for (this._partLength = 0, this._partIsLast = true, this._partSegCount = 0; this._hasNextSegment(); )
      if (this._partLength += this.calculateSegLength(this._path, this._nextSegment()), this._partSegCount++, 1 === I(this._path[this._getEndPointIndex()])) {
        this._partIsLast = !this._hasNextSegment();
        break;
      }
    let s10 = this._partSegCount;
    for (; s10; )
      this._previousSegment(), --s10;
    this._currentPosition.segment = this._nextSegment(), this._currentPosition.segmentLength = this.calculateSegLength(this._path, this._currentPosition.segment), this._currentPosition.abscissa = 0, this._currentPosition.isPathEnd = this._currentPosition.isPartEnd = false, --this._partSegCount;
    const e10 = this._getStartPointIndex();
    this._ctrlPtBegin = 1 === I(this._path[e10]);
    let i8 = e10 + this._partSegCount + 1;
    if (i8 >= this._path.length && (i8 = 0), this._ctrlPtEnd = 1 === I(this._path[i8]), this._patternLength > 0) {
      const t8 = this._ctrlPtBegin ? this._partCtrlPtGap : this._partExtPtGap, s11 = this._ctrlPtEnd ? this._partCtrlPtGap : this._partExtPtGap;
      let e11 = Math.round((this._partLength - (t8 + s11)) / this._patternLength);
      e11 <= 0 && (e11 = t8 + s11 > 0 ? 0 : 1), this._partLengthRatio = this._partLength / (t8 + s11 + e11 * this._patternLength), this._partLengthRatio < 0.01 && (this._partLengthRatio = 1);
    } else
      this._partLengthRatio = 1;
    return true;
  }
  _hasNextSegment() {
    return this._seg < this._path.length - 2;
  }
  _previousSegment() {
    return --this._seg;
  }
  _nextSegment() {
    return ++this._seg;
  }
  _getStartPointIndex() {
    return this._seg;
  }
  _getEndPointIndex() {
    return this._seg + 1;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDashes.js
var r8 = class {
  static local() {
    return null === r8.instance && (r8.instance = new r8()), r8.instance;
  }
  execute(t8, e10, s10, a10) {
    return new n8(t8, e10, s10);
  }
};
r8.instance = null;
var n8 = class extends U3 {
  constructor(t8, e10, s10) {
    super(t8, true, true), this._walker = new a5(), this._walker.updateTolerance(s10), this._endings = e10.lineDashEnding, this._customDashPos = -(e10.offsetAlongLine ?? 0) * s10, this._offsetAtEnd = (e10.customEndingOffset ?? 0) * s10, this._pattern = new n7(), this._pattern.init(e10.dashTemplate, true), this._pattern.scale(s10);
  }
  processPath(t8) {
    if (0 === this._pattern.length())
      return this.iteratePath = false, { paths: [t8] };
    if (!this.iteratePath) {
      let e10 = true;
      switch (this._endings) {
        case k.HalfPattern:
        case k.HalfGap:
        default:
          this._pattern.extPtGap = 0;
          break;
        case k.FullPattern:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.firstValue());
          break;
        case k.FullGap:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.lastValue());
          break;
        case k.NoConstraint:
          this.isClosed || (e10 = false);
          break;
        case k.Custom:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._offsetAtEnd);
      }
      const a11 = this._walker.calculatePathLength(t8);
      if (this._pattern.isEmpty() || a11 < 0.1 * this._pattern.length())
        return { paths: [t8] };
      if (!this._walker.init(t8, this._pattern, e10))
        return { paths: [t8] };
    }
    let a10;
    if (this.iteratePath)
      a10 = this._pattern.nextValue();
    else {
      let t9;
      switch (this._endings) {
        case k.HalfPattern:
        default:
          t9 = 0.5 * this._pattern.firstValue();
          break;
        case k.HalfGap:
          t9 = 0.5 * -this._pattern.lastValue();
          break;
        case k.FullGap:
          t9 = -this._pattern.lastValue();
          break;
        case k.FullPattern:
          t9 = 0;
          break;
        case k.NoConstraint:
        case k.Custom:
          t9 = -this._customDashPos;
      }
      let e10 = t9 / this._pattern.length();
      e10 -= Math.floor(e10), t9 = e10 * this._pattern.length(), this._pattern.reset(), a10 = this._pattern.nextValue();
      let i9 = false;
      for (; t9 >= a10; )
        t9 -= a10, a10 = this._pattern.nextValue(), i9 = !i9;
      a10 -= t9, i9 ? (this._walker.nextPosition(a10), a10 = this._pattern.nextValue()) : this.isClosed && (this._firstCurve = this._walker.nextCurve(a10), a10 = this._pattern.nextValue(), this._walker.nextPosition(a10), a10 = this._pattern.nextValue());
    }
    let i8 = this._walker.nextCurve(a10);
    return i8 ? this._walker.isPathEnd() ? (this.iteratePath = false, this._firstCurve && (this._firstCurve.splice(0, 1), s6.mergePath(i8, this._firstCurve), this._firstCurve = null)) : (a10 = this._pattern.nextValue(), !this._walker.nextPosition(a10) || this._walker.isPathEnd() ? (this.iteratePath = false, this._firstCurve && (i8 = this._firstCurve, this._firstCurve = null)) : this.iteratePath = true) : (this.iteratePath = false, i8 = this._firstCurve, this._firstCurve = null), { paths: [i8] };
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDonut.js
var r9 = class {
  static local() {
    return null === r9.instance && (r9.instance = new r9()), r9.instance;
  }
  execute(t8, i8, e10, s10) {
    return new m5(t8, i8, e10);
  }
};
r9.instance = null;
var m5 = class {
  constructor(t8, i8, r17) {
    switch (this._inputGeometries = t8, this._curveHelper = new n6(), this._width = (void 0 !== i8.width ? i8.width : 2) * r17, i8.method) {
      case B.Mitered:
      default:
        this._method = O.Mitered;
        break;
      case B.Bevelled:
        this._method = O.Bevelled;
        break;
      case B.Rounded:
      case B.TrueBuffer:
        this._method = O.Rounded;
        break;
      case B.Square:
        this._method = O.Square;
    }
    this._option = i8.option, this._offsetFlattenError = e7 * r17;
  }
  next() {
    let e10 = this._inputGeometries.next();
    for (; e10; ) {
      if (s3(e10) && this._width > 0) {
        if (Math.min(e10.xmax - e10.xmin, e10.ymax - e10.ymin) - 2 * this._width < 0)
          return e10;
        const t8 = [];
        return t8.push([[e10.xmin, e10.ymin], [e10.xmin, e10.ymax], [e10.xmax, e10.ymax], [e10.xmax, e10.ymin], [e10.xmin, e10.ymin]]), t8.push([[e10.xmin + this._width, e10.ymin + this._width], [e10.xmax - this._width, e10.ymin + this._width], [e10.xmax - this._width, e10.ymax - this._width], [e10.xmin + this._width, e10.ymax - this._width], [e10.xmin + this._width, e10.ymin + this._width]]), { rings: t8 };
      }
      if (c2(e10) && this._width > 0) {
        const t8 = [];
        for (const i8 of e10.rings) {
          const e11 = this._curveHelper.calculatePathLength(i8), s10 = this._curveHelper.offset(i8, this._width, this._method, 4, this._offsetFlattenError);
          s10 && (e11 < 0 && s10.reverse(), t8.push(s10));
        }
        if (t8.length)
          return { rings: t8 };
      }
      e10 = this._inputGeometries.next();
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectJog.js
var s8 = class {
  static local() {
    return null === s8.instance && (s8.instance = new s8()), s8.instance;
  }
  execute(t8, i8, s10, n16) {
    return new e8(t8, i8, s10);
  }
};
s8.instance = null;
var e8 = class extends U3 {
  constructor(t8, s10, e10) {
    super(t8, false, true), this._curveHelper = new n6(), this._length = (void 0 !== s10.length ? s10.length : 20) * e10, this._angle = void 0 !== s10.angle ? s10.angle : 225, this._position = void 0 !== s10.position ? s10.position : 50, this._length < 0 && (this._length = -this._length), this._position < 20 && (this._position = 20), this._position > 80 && (this._position = 80), this._mirror = false;
  }
  processPath(t8) {
    if (this._curveHelper.isEmpty(t8, false))
      return null;
    const i8 = t8[0], s10 = t8[t8.length - 1], e10 = [s10[0] - i8[0], s10[1] - i8[1]];
    this._curveHelper.normalize(e10);
    const n16 = [i8[0] + (s10[0] - i8[0]) * this._position / 100, i8[1] + (s10[1] - i8[1]) * this._position / 100], h6 = Math.cos((90 - this._angle) / 180 * Math.PI);
    let r17 = Math.sin((90 - this._angle) / 180 * Math.PI);
    this._mirror && (r17 = -r17), this._mirror = !this._mirror;
    return { paths: [[i8, [n16[0] - this._length / 2 * h6, n16[1] - this._length / 2 * r17], [n16[0] + this._length / 2 * h6, n16[1] + this._length / 2 * r17], s10]] };
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectMove.js
var n9 = class {
  static local() {
    return null === n9.instance && (n9.instance = new n9()), n9.instance;
  }
  execute(t8, s10, e10, i8) {
    return new r10(t8, s10, e10);
  }
};
n9.instance = null;
var r10 = class {
  constructor(t8, s10, e10) {
    this._inputGeometries = t8, this._offsetX = void 0 !== s10.offsetX ? s10.offsetX * e10 : 0, this._offsetY = void 0 !== s10.offsetY ? -s10.offsetY * e10 : 0;
  }
  next() {
    let n16 = this._inputGeometries.next();
    for (; n16; ) {
      if (s3(n16))
        return { xmin: n16.xmin + this._offsetX, xmax: n16.xmax + this._offsetX, ymin: n16.ymin + this._offsetY, ymax: n16.ymax + this._offsetY };
      if (c2(n16)) {
        const s10 = m(n16);
        return this._moveMultipath(s10.rings, this._offsetX, this._offsetY), s10;
      }
      if (y(n16)) {
        const s10 = m(n16);
        return this._moveMultipath(s10.paths, this._offsetX, this._offsetY), s10;
      }
      if (f(n16)) {
        const s10 = m(n16);
        return this._movePath(s10.points, this._offsetX, this._offsetY), s10;
      }
      if (l(n16))
        return { x: n16.x + this._offsetX, y: n16.y + this._offsetY };
      n16 = this._inputGeometries.next();
    }
    return null;
  }
  _moveMultipath(t8, s10, e10) {
    if (t8)
      for (const i8 of t8)
        this._movePath(i8, s10, e10);
  }
  _movePath(t8, s10, e10) {
    if (t8)
      for (const i8 of t8)
        i8[0] += s10, i8[1] += e10;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectOffset.js
var r11 = class {
  static local() {
    return null === r11.instance && (r11.instance = new r11()), r11.instance;
  }
  execute(t8, e10, s10, i8) {
    return new f6(t8, e10, s10);
  }
};
r11.instance = null;
var f6 = class {
  constructor(t8, e10, s10) {
    this._inputGeometries = t8, this._curveHelper = new n6(), this._offset = (e10.offset ?? 1) * s10, this._method = e10.method, this._option = e10.option, this._offsetFlattenError = e7 * s10;
  }
  next() {
    let i8 = this._inputGeometries.next();
    for (; i8; ) {
      if (0 === this._offset)
        return i8;
      if (s3(i8)) {
        if (this._method === O.Rounded && this._offset > 0) {
          const t8 = [[i8.xmin, i8.ymin], [i8.xmin, i8.ymax], [i8.xmax, i8.ymax], [i8.xmax, i8.ymin], [i8.xmin, i8.ymin]], e10 = this._curveHelper.offset(t8, -this._offset, this._method, 4, this._offsetFlattenError);
          return e10 ? { rings: [e10] } : null;
        }
        if (Math.min(i8.xmax - i8.xmin, i8.ymax - i8.ymin) + 2 * this._offset > 0)
          return { xmin: i8.xmin - this._offset, xmax: i8.xmax + this._offset, ymin: i8.ymin - this._offset, ymax: i8.ymax + this._offset };
      }
      if (c2(i8)) {
        const t8 = [];
        for (const e10 of i8.rings) {
          const s10 = this._curveHelper.offset(e10, -this._offset, this._method, 4, this._offsetFlattenError);
          s10 && t8.push(s10);
        }
        if (t8.length)
          return { rings: t8 };
      }
      if (y(i8)) {
        const t8 = [];
        for (const e10 of i8.paths) {
          const s10 = this._curveHelper.offset(e10, -this._offset, this._method, 4, this._offsetFlattenError);
          s10 && t8.push(s10);
        }
        if (t8.length)
          return { paths: t8 };
      }
      i8 = this._inputGeometries.next();
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectReverse.js
var s9 = class {
  static local() {
    return null === s9.instance && (s9.instance = new s9()), s9.instance;
  }
  execute(e10, t8, r17, s10) {
    return new n10(e10, t8, r17);
  }
};
s9.instance = null;
var n10 = class {
  constructor(e10, t8, r17) {
    this._inputGeometries = e10, this._reverse = void 0 === t8.reverse || t8.reverse;
  }
  next() {
    let s10 = this._inputGeometries.next();
    for (; s10; ) {
      if (!this._reverse)
        return s10;
      if (y(s10)) {
        const t8 = m(s10);
        return g2(t8.paths), t8;
      }
      s10 = this._inputGeometries.next();
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectRotate.js
var u7 = class {
  static local() {
    return null === u7.instance && (u7.instance = new u7()), u7.instance;
  }
  execute(t8, n16, e10, r17) {
    return new c7(t8, n16, e10);
  }
};
u7.instance = null;
var c7 = class {
  constructor(t8, n16, e10) {
    this._inputGeometries = t8, this._rotateAngle = void 0 !== n16.angle ? n16.angle * Math.PI / 180 : 0;
  }
  next() {
    let u9 = this._inputGeometries.next();
    for (; u9; ) {
      if (0 === this._rotateAngle)
        return u9;
      const c9 = u2();
      c(c9, u9);
      const l8 = (c9[2] + c9[0]) / 2, m7 = (c9[3] + c9[1]) / 2;
      if (s3(u9)) {
        const t8 = { rings: [[[u9.xmin, u9.ymin], [u9.xmin, u9.ymax], [u9.xmax, u9.ymax], [u9.xmax, u9.ymin], [u9.xmin, u9.ymin]]] };
        return this._rotateMultipath(t8.rings, l8, m7), t8;
      }
      if (c2(u9)) {
        const n16 = m(u9);
        return this._rotateMultipath(n16.rings, l8, m7), n16;
      }
      if (y(u9)) {
        const n16 = m(u9);
        return this._rotateMultipath(n16.paths, l8, m7), n16;
      }
      if (f(u9)) {
        const n16 = m(u9);
        return this._rotatePath(n16.points, l8, m7), n16;
      }
      if (l(u9))
        return u9;
      u9 = this._inputGeometries.next();
    }
    return null;
  }
  _rotateMultipath(t8, n16, e10) {
    if (t8)
      for (const r17 of t8)
        this._rotatePath(r17, n16, e10);
  }
  _rotatePath(t8, n16, e10) {
    if (t8) {
      const r17 = Math.cos(this._rotateAngle), i8 = Math.sin(this._rotateAngle);
      for (const o10 of t8) {
        const t9 = o10[0] - n16, s10 = o10[1] - e10;
        o10[0] = n16 + t9 * r17 - s10 * i8, o10[1] = e10 + t9 * i8 + s10 * r17;
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectScale.js
var c8 = class {
  static local() {
    return null === c8.instance && (c8.instance = new c8()), c8.instance;
  }
  execute(t8, s10, i8, r17) {
    return new l6(t8, s10, i8);
  }
};
c8.instance = null;
var l6 = class {
  constructor(t8, s10, i8) {
    this._inputGeometries = t8, this._xFactor = void 0 !== s10.xScaleFactor ? s10.xScaleFactor : 1.15, this._yFactor = void 0 !== s10.yScaleFactor ? s10.yScaleFactor : 1.15;
  }
  next() {
    let c9 = this._inputGeometries.next();
    for (; c9; ) {
      if (1 === this._xFactor && 1 === this._yFactor)
        return c9;
      const l8 = u2();
      c(l8, c9);
      const u9 = (l8[2] + l8[0]) / 2, m7 = (l8[3] + l8[1]) / 2;
      if (s3(c9)) {
        const t8 = { rings: [[[c9.xmin, c9.ymin], [c9.xmin, c9.ymax], [c9.xmax, c9.ymax], [c9.xmax, c9.ymin], [c9.xmin, c9.ymin]]] };
        return this._scaleMultipath(t8.rings, u9, m7), t8;
      }
      if (c2(c9)) {
        const s10 = m(c9);
        return this._scaleMultipath(s10.rings, u9, m7), s10;
      }
      if (y(c9)) {
        const s10 = m(c9);
        return this._scaleMultipath(s10.paths, u9, m7), s10;
      }
      if (f(c9)) {
        const s10 = m(c9);
        return this._scalePath(s10.points, u9, m7), s10;
      }
      if (l(c9))
        return c9;
      c9 = this._inputGeometries.next();
    }
    return null;
  }
  _scaleMultipath(t8, s10, i8) {
    if (t8)
      for (const r17 of t8)
        this._scalePath(r17, s10, i8);
  }
  _scalePath(t8, s10, i8) {
    if (t8)
      for (const r17 of t8) {
        const t9 = (r17[0] - s10) * this._xFactor, n16 = (r17[1] - i8) * this._yFactor;
        r17[0] = s10 + t9, r17[1] = i8 + n16;
      }
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectWave.js
var r12 = class {
  static local() {
    return null === r12.instance && (r12.instance = new r12()), r12.instance;
  }
  execute(t8, e10, i8, s10) {
    return new a6(t8, e10, i8);
  }
};
r12.instance = null;
var a6 = class {
  constructor(t8, e10, i8) {
    this._inputGeometries = t8, this._height = (void 0 !== e10.amplitude ? e10.amplitude : 2) * i8, this._period = (void 0 !== e10.period ? e10.period : 3) * i8, this._style = e10.waveform, this._height <= 0 && (this._height = Math.abs(this._height)), this._period <= 0 && (this._period = Math.abs(this._period)), this._pattern = new n7(), this._pattern.addValue(this._period), this._pattern.addValue(this._period), this._walker = new a5(), this._walker.updateTolerance(i8);
  }
  next() {
    let i8 = this._inputGeometries.next();
    for (; i8; ) {
      if (0 === this._height || 0 === this._period)
        return i8;
      if (y(i8)) {
        const t8 = this._processGeom(i8.paths);
        if (t8.length)
          return { paths: t8 };
      }
      if (c2(i8)) {
        const t8 = this._processGeom(i8.rings);
        if (t8.length)
          return { rings: t8 };
      }
      i8 = this._inputGeometries.next();
    }
    return null;
  }
  _processGeom(t8) {
    const e10 = [];
    for (const i8 of t8)
      if (this._walker.init(i8, this._pattern))
        switch (this._style) {
          case A.Sinus:
          default:
            e10.push(this._constructCurve(i8, false));
            break;
          case A.Square:
            e10.push(this._constructSquare(i8));
            break;
          case A.Triangle:
            e10.push(this._constructTriangle(i8));
            break;
          case A.Random:
            e10.push(this._constructCurve(i8, true));
        }
      else
        e10.push(i8);
    return e10;
  }
  _constructCurve(t8, e10) {
    const s10 = new s6(), h6 = this._walker.calculatePathLength(t8);
    let n16 = Math.round(h6 / this._period);
    0 === n16 && (n16 = 1);
    const r17 = n16 * 16 + 1, a10 = h6 / n16, o10 = this._period / 16, l8 = 1 / r17, _4 = 2 * Math.PI * h6 / a10, c9 = 2 * Math.PI * Math.random(), p3 = 2 * Math.PI * Math.random(), u9 = 2 * Math.PI * Math.random(), d2 = 0.75 - Math.random() / 2, g5 = 0.75 - Math.random() / 2, w4 = {};
    this._walker.curPointAndAngle(w4), s10.startPath(w4.pt);
    let f7 = 0;
    for (; ; ) {
      if (!this._walker.nextPointAndAngle(o10, w4)) {
        s10.lineTo(t8[t8.length - 1]);
        break;
      }
      {
        const t9 = f7;
        let i8;
        if (f7 += l8, e10) {
          const e11 = this._height / 2 * (1 + 0.3 * Math.sin(d2 * _4 * t9 + c9));
          i8 = e11 * Math.sin(_4 * t9 + p3), i8 += e11 * Math.sin(g5 * _4 * t9 + u9), i8 /= 2;
        } else
          i8 = 0.5 * this._height * Math.sin(0.5 * _4 * t9);
        s10.lineTo([w4.pt[0] - i8 * w4.sa, w4.pt[1] + i8 * w4.ca]);
      }
    }
    return s10.path();
  }
  _constructSquare(t8) {
    const e10 = new s6(), s10 = this._walker.calculatePathLength(t8);
    Math.round(s10 / this._period);
    let h6 = true;
    for (; ; ) {
      let t9 = false;
      if (this._walker.curPositionIsValid()) {
        const i8 = {};
        this._walker.curPointAndAngle(i8);
        const s11 = {};
        if (this._walker.nextPointAndAngle(this._period, s11)) {
          const n16 = {};
          this._walker.nextPointAndAngle(this._period, n16) && (h6 ? (e10.startPath(i8.pt), h6 = false) : e10.lineTo(i8.pt), e10.lineTo([i8.pt[0] - this._height / 2 * i8.sa, i8.pt[1] + this._height / 2 * i8.ca]), e10.lineTo([s11.pt[0] - this._height / 2 * s11.sa, s11.pt[1] + this._height / 2 * s11.ca]), e10.lineTo([s11.pt[0] + this._height / 2 * s11.sa, s11.pt[1] - this._height / 2 * s11.ca]), e10.lineTo([n16.pt[0] + this._height / 2 * n16.sa, n16.pt[1] - this._height / 2 * n16.ca]), t9 = true);
        }
      }
      if (!t9) {
        e10.lineTo(this._walker.getPathEnd());
        break;
      }
    }
    return e10.path();
  }
  _constructTriangle(t8) {
    const e10 = new s6(), s10 = this._walker.calculatePathLength(t8);
    Math.round(s10 / this._period);
    let h6 = true;
    for (; ; ) {
      let t9 = false;
      if (this._walker.curPositionIsValid()) {
        const i8 = {};
        this._walker.curPointAndAngle(i8);
        const s11 = {};
        if (this._walker.nextPointAndAngle(this._period / 2, s11)) {
          const n16 = {};
          this._walker.nextPointAndAngle(this._period, n16) && (this._walker.nextPosition(this._period / 2) && (h6 ? (e10.startPath(i8.pt), h6 = false) : e10.lineTo(i8.pt), e10.lineTo([s11.pt[0] - this._height / 2 * s11.sa, s11.pt[1] + this._height / 2 * s11.ca]), e10.lineTo([n16.pt[0] + this._height / 2 * n16.sa, n16.pt[1] - this._height / 2 * n16.ca])), t9 = true);
        }
      }
      if (!t9) {
        e10.lineTo(this._walker.getPathEnd());
        break;
      }
    }
    return e10.path();
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAlongLineSameSize.js
var n11 = class {
  static local() {
    return null === n11.instance && (n11.instance = new n11()), n11.instance;
  }
  execute(t8, e10, s10, i8) {
    return new a7(t8, e10, s10);
  }
};
n11.instance = null;
var a7 = class extends G {
  constructor(t8, e10, n16) {
    super(t8, true, true), this._geometryWalker = new a5(), this._geometryWalker.updateTolerance(n16), this._angleToLine = e10.angleToLine ?? true, this._offset = (e10.offset ? e10.offset : 0) * n16, this._originalEndings = e10.endings, this._offsetAtEnd = (e10.customEndingOffset ? e10.customEndingOffset : 0) * n16, this._position = -(e10.offsetAlongLine ? e10.offsetAlongLine : 0) * n16, this._pattern = new n7(), this._pattern.init(e10.placementTemplate, false), this._pattern.scale(n16), this._endings = this._originalEndings;
  }
  processPath(t8) {
    if (this._pattern.isEmpty())
      return null;
    let s10;
    if (this.iteratePath)
      s10 = this._pattern.nextValue();
    else {
      this._originalEndings === X.WithFullGap && this.isClosed ? this._endings = X.WithMarkers : this._endings = this._originalEndings, this._pattern.extPtGap = 0;
      let i9, n16 = true;
      switch (this._endings) {
        case X.NoConstraint:
          i9 = -this._position, i9 = this._adjustPosition(i9), n16 = false;
          break;
        case X.WithHalfGap:
        default:
          i9 = -this._pattern.lastValue() / 2;
          break;
        case X.WithFullGap:
          i9 = -this._pattern.lastValue(), this._pattern.extPtGap = this._pattern.lastValue();
          break;
        case X.WithMarkers:
          i9 = 0;
          break;
        case X.Custom:
          i9 = -this._position, i9 = this._adjustPosition(i9), this._pattern.extPtGap = 0.5 * this._offsetAtEnd;
      }
      if (!this._geometryWalker.init(t8, this._pattern, n16))
        return null;
      this._pattern.reset();
      let a10 = 0;
      for (; i9 > a10; )
        i9 -= a10, a10 = this._pattern.nextValue();
      a10 -= i9, s10 = a10, this.iteratePath = true;
    }
    const i8 = {};
    return this._geometryWalker.nextPointAndAngle(s10, i8) ? this._endings === X.WithFullGap && this._geometryWalker.isPathEnd() ? (this.iteratePath = false, null) : this._endings === X.WithMarkers && this._geometryWalker.isPathEnd() && (this.iteratePath = false, this.isClosed) ? null : (this.internalPlacement.setTranslate(i8.pt[0] - this._offset * i8.sa, i8.pt[1] + this._offset * i8.ca), this._angleToLine && this.internalPlacement.setRotateCS(i8.ca, i8.sa), this.internalPlacement) : (this.iteratePath = false, null);
  }
  _adjustPosition(t8) {
    let e10 = t8 / this._pattern.length();
    return e10 -= Math.floor(e10), e10 * this._pattern.length();
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtExtremities.js
var n12 = class {
  static local() {
    return null === n12.instance && (n12.instance = new n12()), n12.instance;
  }
  execute(t8, e10, s10, i8) {
    return new r13(t8, e10, s10);
  }
};
n12.instance = null;
var r13 = class extends G {
  constructor(t8, e10, i8) {
    super(t8, false, true), this._curveHelper = new n6(), this._angleToLine = void 0 === e10.angleToLine || e10.angleToLine, this._offset = void 0 !== e10.offset ? e10.offset * i8 : 0, this._type = e10.extremityPlacement, this._position = void 0 !== e10.offsetAlongLine ? e10.offsetAlongLine * i8 : 0, this._beginProcessed = false;
  }
  processPath(t8) {
    let e10;
    switch (this._type) {
      case o2.Both:
      default:
        this._beginProcessed ? (e10 = this._atExtremities(t8, this._position, false), this._beginProcessed = false, this.iteratePath = false) : (e10 = this._atExtremities(t8, this._position, true), this._beginProcessed = true, this.iteratePath = true);
        break;
      case o2.JustBegin:
        e10 = this._atExtremities(t8, this._position, true);
        break;
      case o2.JustEnd:
        e10 = this._atExtremities(t8, this._position, false);
      case o2.None:
    }
    return e10;
  }
  _atExtremities(t8, s10, i8) {
    const n16 = t8.length;
    if (n16 < 2)
      return null;
    const r17 = i8 ? 1 : n16 - 2, o10 = i8 ? n16 : -1, a10 = i8 ? 1 : -1;
    let l8, h6 = 0, c9 = i8 ? t8[0] : t8[n16 - 1];
    for (let _4 = r17; _4 !== o10; _4 += a10) {
      l8 = c9, c9 = t8[_4];
      const i9 = this._curveHelper.calculateLength(l8, c9);
      if (h6 + i9 > s10) {
        const t9 = (s10 - h6) / i9, [n17, r18] = this._curveHelper.getAngleCS(l8, c9, t9), o11 = y3(l8, c9, t9);
        return this.internalPlacement.setTranslate(o11[0] - this._offset * r18, o11[1] + this._offset * n17), this._angleToLine && this.internalPlacement.setRotateCS(-n17, -r18), this.internalPlacement;
      }
      h6 += i9;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtRatioPositions.js
var n13 = class {
  static local() {
    return null === n13.instance && (n13.instance = new n13()), n13.instance;
  }
  execute(t8, i8, s10, e10) {
    return new a8(t8, i8, s10);
  }
};
n13.instance = null;
var a8 = class extends G {
  constructor(t8, e10, n16) {
    super(t8, true, true), this._walker = new a5(), this._walker.updateTolerance(n16), this._angleToLine = void 0 === e10.angleToLine || e10.angleToLine, this._offset = void 0 !== e10.offset ? e10.offset * n16 : 0, this._beginGap = void 0 !== e10.beginPosition ? e10.beginPosition * n16 : 0, this._endGap = void 0 !== e10.endPosition ? e10.endPosition * n16 : 0, this._flipFirst = void 0 === e10.flipFirst || e10.flipFirst, this._pattern = new n7(), this._pattern.init(e10.positionArray, false, false), this._subPathLen = 0, this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0;
  }
  processPath(t8) {
    if (this._pattern.isEmpty())
      return null;
    let i8;
    if (this.iteratePath) {
      const t9 = this._pattern.nextValue() * this._subPathLen, s11 = this._beginGap + t9;
      i8 = s11 - this._prevPos, this._prevPos = s11;
    } else {
      if (this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0, this._subPathLen = this._walker.calculatePathLength(t8) - this._beginGap - this._endGap, this._subPathLen < 0)
        return this.iteratePath = false, null;
      if (!this._walker.init(t8, this._pattern, false))
        return null;
      this._pattern.reset();
      const s11 = this._pattern.nextValue() * this._subPathLen, e10 = this._beginGap + s11;
      i8 = e10 - this._prevPos, this._prevPos = e10, this.iteratePath = true;
    }
    const s10 = {};
    if (!this._walker.nextPointAndAngle(i8, s10, h4.END))
      return this.iteratePath = false, null;
    this.internalPlacement.setTranslate(s10.pt[0] - this._offset * s10.sa, s10.pt[1] + this._offset * s10.ca);
    const n16 = this._isFirst && this._flipFirst;
    let a10, r17;
    return this._angleToLine ? (a10 = s10.ca, r17 = s10.sa) : (a10 = 1, r17 = 0), n16 && (a10 = -a10, r17 = -r17), this.internalPlacement.setRotateCS(a10, r17), this._isFirst = false, this._posCount--, 0 === this._posCount && (this.iteratePath = false), this.internalPlacement;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementInsidePolygon.js
function h5(t8) {
  return void 0 !== t8.rings;
}
var e9 = class {
  static local() {
    return null === e9.instance && (e9.instance = new e9()), e9.instance;
  }
  execute(t8, s10, i8, h6) {
    return new n14(t8, s10, i8, h6);
  }
};
e9.instance = null;
var n14 = class {
  constructor(e10, n16, _4, r17) {
    if (this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, this._currentX = 0, this._currentY = 0, this._stepX = Math.abs(n16.stepX ?? 16) * _4, this._stepY = Math.abs(n16.stepY ?? 16) * _4, 0 !== this._stepX && 0 !== this._stepY && e10 && h5(e10) && e10.rings) {
      if (this._gridType = n16.gridType ?? Y.Fixed, this._gridType === Y.Random) {
        const s10 = n16.seed ?? 13, i8 = 1;
        this._randomLCG = new t2(s10 * i8), this._randomness = (n16.randomness ?? 100) / 100, this._gridAngle = 0, this._shiftOddRows = false, this._cosAngle = 1, this._sinAngle = 0, this._offsetX = 0, this._offsetY = 0;
      } else {
        if (this._randomness = 0, this._gridAngle = n16.gridAngle ?? 0, this._shiftOddRows = n16.shiftOddRows ?? false, this._offsetX = (n16.offsetX ?? 0) * _4, this._offsetY = (n16.offsetY ?? 0) * _4, this._cosAngle = Math.cos(this._gridAngle / 180 * Math.PI), this._sinAngle = -Math.sin(this._gridAngle / 180 * Math.PI), this._stepX)
          if (this._offsetX < 0)
            for (; this._offsetX < -0.5 * this._stepX; )
              this._offsetX += this._stepX;
          else
            for (; this._offsetX >= 0.5 * this._stepX; )
              this._offsetX -= this._stepX;
        if (this._stepY)
          if (this._offsetY < 0)
            for (; this._offsetY < -0.5 * this._stepY; )
              this._offsetY += this._stepY;
          else
            for (; this._offsetY >= 0.5 * this._stepY; )
              this._offsetY -= this._stepY;
      }
      this._graphicOriginX = 0, this._graphicOriginY = 0, this._internalPlacement = new t7(), this._calculateMinMax(e10), this._geometry = e10;
    }
  }
  next() {
    return this._geometry ? this._nextInside() : null;
  }
  _calculateMinMax(t8) {
    let s10, i8, h6, e10, n16, _4, r17, o10;
    this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, n16 = _4 = Number.MAX_VALUE, r17 = o10 = -Number.MAX_VALUE;
    for (const a10 of t8.rings) {
      const t9 = a10 ? a10.length : 0;
      for (let f7 = 0; f7 < t9; ++f7)
        s10 = a10[f7][0] - this._graphicOriginX - this._offsetX, i8 = a10[f7][1] - this._graphicOriginY - this._offsetY, h6 = this._cosAngle * s10 - this._sinAngle * i8, e10 = this._sinAngle * s10 + this._cosAngle * i8, n16 = Math.min(n16, h6), r17 = Math.max(r17, h6), _4 = Math.min(_4, e10), o10 = Math.max(o10, e10);
    }
    n16 += this._graphicOriginX, r17 += this._graphicOriginX, _4 += this._graphicOriginY, o10 += this._graphicOriginY, this._xMin = Math.round(n16 / this._stepX), this._xMax = Math.round(r17 / this._stepX), this._yMin = Math.round(_4 / this._stepY), this._yMax = Math.round(o10 / this._stepY), this._currentX = this._xMax + 1, this._currentY = this._yMin - 1;
  }
  _nextInside() {
    for (; ; ) {
      if (this._currentX > this._xMax) {
        if (this._currentY++, this._currentY > this._yMax)
          return null;
        this._currentX = this._xMin, this._shiftOddRows && this._currentY % 2 && this._currentX--;
      }
      let t8 = this._currentX * this._stepX + this._offsetX;
      this._shiftOddRows && this._currentY % 2 && (t8 += 0.5 * this._stepX);
      const s10 = this._currentY * this._stepY + this._offsetY;
      let h6, e10;
      return this._currentX++, this._gridType === Y.Random ? (h6 = this._graphicOriginX + t8 + this._stepX * this._randomness * (0.5 - this._randomLCG.getFloat()) * 2 / 3, e10 = this._graphicOriginY + s10 + this._stepY * this._randomness * (0.5 - this._randomLCG.getFloat()) * 2 / 3) : (h6 = this._graphicOriginX + this._cosAngle * t8 + this._sinAngle * s10, e10 = this._graphicOriginY - this._sinAngle * t8 + this._cosAngle * s10), this._internalPlacement.setTranslate(h6, e10), this._internalPlacement;
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnLine.js
var r14 = 1e-3;
var l7 = class {
  static local() {
    return null === l7.instance && (l7.instance = new l7()), l7.instance;
  }
  execute(e10, t8, n16, i8) {
    return new o7(e10, t8, n16);
  }
};
l7.instance = null;
var o7 = class extends G {
  constructor(e10, t8, n16) {
    super(e10, true, true), this._curveHelper = new n6(), this._angleToLine = void 0 === t8.angleToLine || t8.angleToLine, this._offset = void 0 !== t8.offset ? t8.offset * n16 : 0, this._relativeTo = t8.relativeTo, this._position = void 0 !== t8.startPointOffset ? t8.startPointOffset * n16 : 0, this._epsilon = r14 * n16;
  }
  processPath(e10) {
    const i8 = this._position;
    if (this._relativeTo === Z.SegmentMidpoint) {
      for (this.iteratePath || (this._segmentCount = e10.length, this._curSegment = 1, this.iteratePath = true); this._curSegment < this._segmentCount; ) {
        const n16 = this._curSegment;
        this._curSegment++;
        const i9 = e10[n16 - 1], s10 = e10[n16], r18 = this._curveHelper.calculateLength(i9, s10);
        if (r18 < this._epsilon)
          continue;
        const l8 = 0.5 + this._position / r18, [o10, a10] = this._curveHelper.getAngleCS(i9, s10, l8), h6 = y3(i9, s10, l8);
        return this.internalPlacement.setTranslate(h6[0] - this._offset * a10, h6[1] + this._offset * o10), this._angleToLine && this.internalPlacement.setRotateCS(o10, a10), this.internalPlacement;
      }
      return this.iteratePath = false, null;
    }
    this._relativeTo === Z.LineEnd && d(e10);
    const r17 = this.onLine(e10, i8);
    return this._relativeTo === Z.LineEnd && d(e10), r17;
  }
  onLine(e10, n16) {
    let i8, r17 = false;
    switch (this._relativeTo) {
      case Z.LineMiddle:
      default:
        i8 = this._curveHelper.calculatePathLength(e10) / 2 + n16;
        break;
      case Z.LineBeginning:
        i8 = n16;
        break;
      case Z.LineEnd:
        i8 = n16, r17 = true;
    }
    const l8 = e10.length;
    let o10, a10 = 0, h6 = e10[0];
    for (let s10 = 1; s10 < l8; ++s10) {
      o10 = h6, h6 = e10[s10];
      const n17 = this._curveHelper.calculateLength(o10, h6);
      if (a10 + n17 > i8) {
        const e11 = (i8 - a10) / n17, [s11, l9] = this._curveHelper.getAngleCS(o10, h6, e11), c9 = y3(o10, h6, e11), u9 = r17 ? -this._offset : this._offset;
        return this.internalPlacement.setTranslate(c9[0] - u9 * l9, c9[1] + u9 * s11), this._angleToLine && (r17 ? this.internalPlacement.setRotateCS(-s11, -l9) : this.internalPlacement.setRotateCS(s11, l9)), this.internalPlacement;
      }
      a10 += n17;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnVertices.js
var n15 = class {
  static local() {
    return null === n15.instance && (n15.instance = new n15()), n15.instance;
  }
  execute(t8, s10, e10, i8) {
    return new a9(t8, s10, e10);
  }
};
n15.instance = null;
var r15 = 1e-15;
var a9 = class extends G {
  constructor(t8, s10, e10) {
    super(t8, true, true), this._curveHelper = new n6(), this._angleToLine = void 0 === s10.angleToLine || s10.angleToLine, this._offset = void 0 !== s10.offset ? s10.offset * e10 : 0, this._endPoints = void 0 === s10.placeOnEndPoints || s10.placeOnEndPoints, this._controlPoints = void 0 === s10.placeOnControlPoints || s10.placeOnControlPoints, this._regularVertices = void 0 === s10.placeOnRegularVertices || s10.placeOnRegularVertices, this._tags = [], this._tagIterator = 0;
  }
  processPath(t8) {
    if (this.iteratePath || (this._preparePath(t8), this.iteratePath = true), this._tagIterator >= this._tags.length)
      return this._tags.length = 0, this._tagIterator = 0, this.iteratePath = false, null;
    const s10 = this._tags[this._tagIterator];
    this._angleToLine && this.internalPlacement.setRotate(s10[2]);
    let e10 = s10[0], i8 = s10[1];
    if (0 !== this._offset) {
      const t9 = Math.cos(s10[2]), n16 = Math.sin(s10[2]);
      e10 -= this._offset * n16, i8 += this._offset * t9;
    }
    return this.internalPlacement.setTranslate(e10, i8), this._tagIterator++, this.internalPlacement;
  }
  _preparePath(t8) {
    this._tags.length = 0, this._tagIterator = 0;
    const i8 = C3(t8), n16 = t8.length - 1;
    let r17, a10, h6 = 0, l8 = 0, _4 = 0, c9 = 0, g5 = 0;
    for (; h6 < n16; ) {
      h6++, r17 = t8[h6 - 1], a10 = t8[h6];
      const s10 = I(r17), u9 = I(a10);
      (this._angleToLine || 0 !== this._offset) && (c9 = this._curveHelper.getAngle(r17, a10, 0)), 1 === h6 ? i8 ? (l8 = c9, _4 = s10) : (this._endPoints || this._controlPoints && 1 === s10) && this._tags.push([r17[0], r17[1], c9]) : 1 === s10 ? this._controlPoints && this._tags.push([r17[0], r17[1], o8(g5, c9)]) : this._regularVertices && this._tags.push([r17[0], r17[1], o8(g5, c9)]), (this._angleToLine || 0 !== this._offset) && (g5 = this._curveHelper.getAngle(r17, a10, 1)), h6 === n16 && (i8 ? 1 === u9 || 1 === _4 ? this._controlPoints && this._tags.push([a10[0], a10[1], o8(g5, l8)]) : this._regularVertices && this._tags.push([a10[0], a10[1], o8(g5, l8)]) : (this._endPoints || this._controlPoints && 1 === u9) && this._tags.push([a10[0], a10[1], g5]));
    }
    this._tagIterator = 0;
  }
};
function o8(t8, s10) {
  const e10 = Math.PI;
  for (; Math.abs(s10 - t8) > e10 + 2 * r15; )
    s10 - t8 > e10 ? s10 -= 2 * e10 : s10 += 2 * e10;
  return (t8 + s10) / 2;
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementPolygonCenter.js
function o9(t8) {
  return void 0 !== t8.rings;
}
var r16 = class {
  static local() {
    return null === r16.instance && (r16.instance = new r16()), r16.instance;
  }
  execute(t8, e10, n16, s10) {
    return new i6(t8, e10, n16);
  }
};
r16.instance = null;
var i6 = class {
  constructor(t8, e10, o10) {
    this._geometry = t8, this._offsetX = void 0 !== e10.offsetX ? e10.offsetX * o10 : 0, this._offsetY = void 0 !== e10.offsetY ? e10.offsetY * o10 : 0, this._method = void 0 !== e10.method ? e10.method : K.OnPolygon, this._internalPlacement = new t7();
  }
  next() {
    const t8 = this._geometry;
    return this._geometry = null, t8 && o9(t8) ? this._polygonCenter(t8) : null;
  }
  _polygonCenter(n16) {
    let o10 = false;
    switch (this._method) {
      case K.OnPolygon:
      default:
      case K.CenterOfMass:
      case K.BoundingBoxCenter: {
        const s10 = u2();
        c(s10, n16), this._internalPlacement.setTranslate((s10[2] + s10[0]) / 2 + this._offsetX, (s10[3] + s10[1]) / 2 + this._offsetY), o10 = true;
        break;
      }
    }
    return o10 ? this._internalPlacement : null;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMOperators.js
function A2(p3) {
  if (!p3)
    return null;
  switch (p3.type) {
    case "CIMGeometricEffectAddControlPoints":
      return o6.local();
    case "CIMGeometricEffectArrow":
      return h2.local();
    case "CIMGeometricEffectBuffer":
      return f5.local();
    case "CIMGeometricEffectControlMeasureLine":
      return _.local();
    case "CIMGeometricEffectCut":
      return u6.local();
    case "CIMGeometricEffectDashes":
      return r8.local();
    case "CIMGeometricEffectDonut":
      return r9.local();
    case "CIMGeometricEffectJog":
      return s8.local();
    case "CIMGeometricEffectMove":
      return n9.local();
    case "CIMGeometricEffectOffset":
      return r11.local();
    case "CIMGeometricEffectReverse":
      return s9.local();
    case "CIMGeometricEffectRotate":
      return u7.local();
    case "CIMGeometricEffectScale":
      return c8.local();
    case "CIMGeometricEffectWave":
      return r12.local();
  }
  return null;
}
function g3(e10) {
  if (!e10)
    return null;
  switch (e10.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
      return n11.local();
    case "CIMMarkerPlacementAtExtremities":
      return n12.local();
    case "CIMMarkerPlacementAtRatioPositions":
      return n13.local();
    case "CIMMarkerPlacementInsidePolygon":
      return e9.local();
    case "CIMMarkerPlacementOnLine":
      return l7.local();
    case "CIMMarkerPlacementOnVertices":
      return n15.local();
    case "CIMMarkerPlacementPolygonCenter":
      return r16.local();
  }
  return null;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/BoundingBox.js
var i7 = class {
  constructor(i8, e10, s10, r17) {
    this.center = t4(i8, e10), this.centerT = n2(), this.halfWidth = s10 / 2, this.halfHeight = r17 / 2, this.width = s10, this.height = r17;
  }
  get x() {
    return this.center[0];
  }
  get y() {
    return this.center[1];
  }
  get blX() {
    return this.center[0] + this.halfWidth;
  }
  get blY() {
    return this.center[1] + this.halfHeight;
  }
  get trX() {
    return this.center[0] - this.halfWidth;
  }
  get trY() {
    return this.center[1] - this.halfHeight;
  }
  get xmin() {
    return this.x - this.halfWidth;
  }
  get xmax() {
    return this.x + this.halfWidth;
  }
  get ymin() {
    return this.y - this.halfHeight;
  }
  get ymax() {
    return this.y + this.halfHeight;
  }
  set x(t8) {
    this.center[0] = t8;
  }
  set y(t8) {
    this.center[1] = t8;
  }
  clone() {
    return new i7(this.x, this.y, this.width, this.height);
  }
  serialize(t8) {
    return t8.writeF32(this.center[0]), t8.writeF32(this.center[1]), t8.push(this.width), t8.push(this.height), t8;
  }
  findCollisionDelta(t8, h6 = 4) {
    const i8 = Math.abs(t8.centerT[0] - this.centerT[0]), e10 = Math.abs(t8.centerT[1] - this.centerT[1]), s10 = (t8.halfWidth + this.halfWidth + h6) / i8, r17 = (t8.halfHeight + this.halfHeight + h6) / e10, n16 = Math.min(s10, r17);
    return Math.log2(n16);
  }
  extend(t8) {
    const h6 = Math.min(this.xmin, t8.xmin), i8 = Math.min(this.ymin, t8.ymin), e10 = Math.max(this.xmax, t8.xmax) - h6, s10 = Math.max(this.ymax, t8.ymax) - i8, r17 = h6 + e10 / 2, n16 = i8 + s10 / 2;
    this.width = e10, this.height = s10, this.halfWidth = e10 / 2, this.halfHeight = s10 / 2, this.x = r17, this.y = n16;
  }
  static deserialize(t8) {
    const h6 = t8.readF32(), e10 = t8.readF32(), s10 = t8.readInt32(), r17 = t8.readInt32();
    return new i7(h6, e10, s10, r17);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/shapingUtils.js
var m6 = 26;
var u8 = 4;
var g4 = m6 + u8;
var _2 = m6 - 6;
var p2 = 3;
var x2 = 8;
var w3 = Math.PI / 180;
var y4 = class {
  constructor(t8, s10, e10, i8) {
    this._rotationT = n(), this._xBounds = 0, this._yBounds = 0, this.minZoom = 0, this.maxZoom = 255, this._bounds = null;
    const n16 = e10.rect, o10 = new Float32Array(8);
    t8 *= i8, s10 *= i8;
    const r17 = e10.code ? n16.width * i8 : e10.metrics.width, a10 = e10.code ? n16.height * i8 : e10.metrics.height;
    o10[0] = t8, o10[1] = s10, o10[2] = t8 + r17, o10[3] = s10, o10[4] = t8, o10[5] = s10 + a10, o10[6] = t8 + r17, o10[7] = s10 + a10, this._data = o10, this._setTextureCoords(n16), this._scale = i8, this._mosaic = e10, this.x = t8, this.y = s10, this.maxOffset = Math.max(t8 + r17, s10 + a10);
  }
  get width() {
    return this._mosaic.metrics.width * this._scale;
  }
  get mosaic() {
    return this._mosaic;
  }
  set angle(s10) {
    this._angle = s10, h(this._rotationT, -s10), this._setOffsets(this._data);
  }
  get angle() {
    return this._angle;
  }
  get xTopLeft() {
    return this._data[0];
  }
  get yTopLeft() {
    return this._data[1];
  }
  get xBottomRight() {
    return this._data[6];
  }
  get yBottomRight() {
    return this._data[7];
  }
  get texcoords() {
    return this._texcoords;
  }
  get textureBinding() {
    return this._mosaic.textureBinding;
  }
  get offsets() {
    return this._offsets || this._setOffsets(this._data), this._offsets;
  }
  get char() {
    return String.fromCharCode(this._mosaic.code);
  }
  get code() {
    return this._mosaic.code;
  }
  get bounds() {
    if (!this._bounds) {
      const { height: t8, width: e10 } = this._mosaic.metrics, i8 = e10 * this._scale, o10 = Math.abs(t8) * this._scale, r17 = new Float32Array(8);
      r17[0] = this.x, r17[1] = this.y, r17[2] = this.x + i8, r17[3] = this.y, r17[4] = this.x, r17[5] = this.y + o10, r17[6] = this.x + i8, r17[7] = this.y + o10;
      const a10 = o3(n(), this._rotationT, this._T);
      a2(r17, r17, a10);
      let c9 = 1 / 0, d2 = 1 / 0, f7 = 0, m7 = 0;
      for (let s10 = 0; s10 < 4; s10++) {
        const t9 = r17[2 * s10], e11 = r17[2 * s10 + 1];
        c9 = Math.min(c9, t9), d2 = Math.min(d2, e11), f7 = Math.max(f7, t9), m7 = Math.max(m7, e11);
      }
      const u9 = f7 - c9, g5 = m7 - d2, _4 = c9 + u9 / 2, p3 = d2 + g5 / 2;
      this._bounds = new i7(_4, p3, u9, g5);
    }
    return this._bounds;
  }
  setTransform(t8) {
    this._T = t8, this._offsets = null;
  }
  _setOffsets(t8) {
    this._offsets || (this._offsets = { upperLeft: 0, upperRight: 0, lowerLeft: 0, lowerRight: 0 });
    const e10 = this._offsets, i8 = new Float32Array(8), o10 = o3(n(), this._rotationT, this._T);
    a2(i8, t8, o10), e10.upperLeft = w2(i8[0] * x2, i8[1] * x2), e10.upperRight = w2(i8[2] * x2, i8[3] * x2), e10.lowerLeft = w2(i8[4] * x2, i8[5] * x2), e10.lowerRight = w2(i8[6] * x2, i8[7] * x2);
  }
  _setTextureCoords({ x: t8, y: s10, width: e10, height: i8 }) {
    this._texcoords = { upperLeft: w2(t8, s10), upperRight: w2(t8 + e10, s10), lowerLeft: w2(t8, s10 + i8), lowerRight: w2(t8 + e10, s10 + i8) };
  }
};
var M2 = (t8, s10) => ({ code: 0, page: 0, sdf: true, rect: new t5(0, 0, 11, 8), textureBinding: s10, metrics: { advance: 0, height: 4, width: t8, left: 0, top: 0 } });
var T = class {
  constructor(t8, s10, e10) {
    this._rotation = 0, this._decorate(t8, s10, e10), this.glyphs = t8, this.bounds = this._createBounds(t8), this.isMultiline = s10.length > 1, this._hasRotation = 0 !== e10.angle, this._T = this._createGlyphTransform(this.bounds, e10);
    for (const i8 of t8)
      i8.setTransform(this._T);
  }
  setRotation(e10) {
    if (0 === e10 && 0 === this._rotation)
      return;
    this._rotation = e10;
    const i8 = this._T, n16 = h(n(), e10);
    o3(i8, n16, i8);
    for (const t8 of this.glyphs)
      t8.setTransform(this._T);
  }
  _decorate(t8, s10, e10) {
    if (!e10.decoration || "none" === e10.decoration || !t8.length)
      return;
    const i8 = e10.scale, h6 = "underline" === e10.decoration ? g4 : _2, n16 = t8[0].textureBinding;
    for (const o10 of s10) {
      const s11 = o10.startX * i8, e11 = o10.startY * i8, r17 = (o10.width + o10.glyphWidthEnd) * i8;
      t8.push(new y4(s11, e11 + h6 * i8, M2(r17, n16), 1));
    }
  }
  get boundsT() {
    const t8 = this.bounds, s10 = r2(n2(), t8.x, t8.y);
    if (z(s10, s10, this._T), this._hasRotation) {
      const e10 = Math.max(t8.width, t8.height);
      return new i7(s10[0], s10[1], e10, e10);
    }
    return new i7(s10[0], s10[1], t8.width, t8.height);
  }
  _createBounds(t8) {
    let s10 = 1 / 0, e10 = 1 / 0, i8 = 0, h6 = 0;
    for (const r17 of t8)
      s10 = Math.min(s10, r17.xTopLeft), e10 = Math.min(e10, r17.yTopLeft), i8 = Math.max(i8, r17.xTopLeft + r17.width), h6 = Math.max(h6, r17.yBottomRight);
    const n16 = i8 - s10, o10 = h6 - e10;
    return new i7(s10 + n16 / 2, e10 + o10 / 2, n16, o10);
  }
  _createGlyphTransform(t8, s10) {
    const n16 = w3 * s10.angle, r17 = n(), c9 = n2();
    return i(r17, r17, r2(c9, s10.xOffset, -s10.yOffset)), s10.isCIM ? e5(r17, r17, n16) : (i(r17, r17, r2(c9, t8.x, t8.y)), e5(r17, r17, n16), i(r17, r17, r2(c9, -t8.x, -t8.y))), r17;
  }
};
var B2 = class {
  constructor(t8, s10, e10, i8, h6, n16) {
    this.glyphWidthEnd = 0, this.startX = 0, this.startY = 0, this.start = Math.max(0, Math.min(s10, e10)), this.end = Math.max(0, Math.max(s10, e10)), this.end < t8.length && (this.glyphWidthEnd = t8[this.end].metrics.width), this.width = i8, this.yMin = h6, this.yMax = n16;
  }
};
var R2 = (t8) => 10 === t8;
var b2 = (t8) => 32 === t8;
function L(t8, s10, e10) {
  const i8 = new Array(), h6 = 1 / e10.scale, n16 = e10.maxLineWidth * h6, o10 = s10 ? t8.length - 1 : 0, r17 = s10 ? -1 : t8.length, a10 = s10 ? -1 : 1;
  let c9 = o10, d2 = 0, f7 = 0, l8 = c9, m7 = l8, u9 = 0, g5 = 1 / 0, _4 = 0;
  for (; c9 !== r17; ) {
    const { code: s11, metrics: e11 } = t8[c9], h7 = Math.abs(e11.top);
    if (R2(s11) || b2(s11) || (g5 = Math.min(g5, h7), _4 = Math.max(_4, h7 + e11.height)), R2(s11))
      c9 !== o10 && (i8.push(new B2(t8, l8, c9 - a10, d2, g5, _4)), g5 = 1 / 0, _4 = 0), d2 = 0, l8 = c9 + a10, m7 = c9 + a10, f7 = 0;
    else if (b2(s11))
      m7 = c9 + a10, f7 = 0, u9 = e11.advance, d2 += e11.advance;
    else if (d2 > n16) {
      if (m7 !== l8) {
        const s12 = m7 - 2 * a10;
        d2 -= u9, i8.push(new B2(t8, l8, s12, d2 - f7, g5, _4)), g5 = 1 / 0, _4 = 0, l8 = m7, d2 = f7;
      } else
        i8.push(new B2(t8, l8, c9 - a10, d2, g5, _4)), g5 = 1 / 0, _4 = 0, l8 = c9, m7 = c9, d2 = 0;
      d2 += e11.advance, f7 += e11.advance;
    } else
      d2 += e11.advance, f7 += e11.advance;
    c9 += a10;
  }
  const p3 = new B2(t8, l8, c9 - a10, d2, g5, _4);
  return p3.start >= 0 && p3.end < t8.length && i8.push(p3), i8;
}
function v(t8, s10) {
  let e10 = 0;
  for (let n16 = 0; n16 < t8.length; n16++) {
    const { width: s11 } = t8[n16];
    e10 = Math.max(s11, e10);
  }
  const i8 = "underline" === s10.decoration ? u8 : 0, h6 = t8[0].yMin;
  return { x: 0, y: h6, height: t8[t8.length - 1].yMax + s10.lineHeight * (t8.length - 1) + i8 - h6, width: e10 };
}
function j3(t8, s10, e10) {
  const i8 = e10.scale, h6 = new Array(), n16 = L(t8, s10, e10), o10 = v(n16, e10), { vAlign: r17, hAlign: a10 } = e10, d2 = r17 === t3.Baseline ? 1 : 0, f7 = d2 ? 0 : r17 - 1, l8 = (1 - d2) * -o10.y + f7 * (o10.height / 2) + (d2 ? 1 : 0) * -m6;
  for (let c9 = 0; c9 < n16.length; c9++) {
    const { start: s11, end: o11, width: r18 } = n16[c9];
    let d3 = -1 * (a10 + 1) * (r18 / 2) - p2;
    const f8 = c9 * e10.lineHeight + l8 - p2;
    n16[c9].startX = d3, n16[c9].startY = f8;
    for (let e11 = s11; e11 <= o11; e11++) {
      const s12 = t8[e11];
      if (R2(s12.code))
        continue;
      const n17 = new y4(d3 + s12.metrics.left, f8 - s12.metrics.top, s12, i8);
      d3 += s12.metrics.advance, h6.push(n17);
    }
  }
  return new T(h6, n16, e10);
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolDrawHelper.js
var I2 = Math.PI / 180;
var v2 = 10;
var L2 = s.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");
var z2 = class {
  constructor(t8) {
    this._t = t8;
  }
  static createIdentity() {
    return new z2([1, 0, 0, 0, 1, 0]);
  }
  clone() {
    const t8 = this._t;
    return new z2(t8.slice());
  }
  transform(t8) {
    const e10 = this._t;
    return [e10[0] * t8[0] + e10[1] * t8[1] + e10[2], e10[3] * t8[0] + e10[4] * t8[1] + e10[5]];
  }
  static createScale(t8, e10) {
    return new z2([t8, 0, 0, 0, e10, 0]);
  }
  scale(t8, e10) {
    const s10 = this._t;
    return s10[0] *= t8, s10[1] *= t8, s10[2] *= t8, s10[3] *= e10, s10[4] *= e10, s10[5] *= e10, this;
  }
  scaleRatio() {
    return Math.sqrt(this._t[0] * this._t[0] + this._t[1] * this._t[1]);
  }
  static createTranslate(t8, e10) {
    return new z2([0, 0, t8, 0, 0, e10]);
  }
  translate(t8, e10) {
    const s10 = this._t;
    return s10[2] += t8, s10[5] += e10, this;
  }
  static createRotate(t8) {
    const e10 = Math.cos(t8), s10 = Math.sin(t8);
    return new z2([e10, -s10, 0, s10, e10, 0]);
  }
  rotate(t8) {
    return z2.multiply(this, z2.createRotate(t8), this);
  }
  static multiply(t8, e10, s10) {
    const i8 = t8._t, r17 = e10._t, n16 = i8[0] * r17[0] + i8[3] * r17[1], o10 = i8[1] * r17[0] + i8[4] * r17[1], a10 = i8[2] * r17[0] + i8[5] * r17[1] + r17[2], h6 = i8[0] * r17[3] + i8[3] * r17[4], l8 = i8[1] * r17[3] + i8[4] * r17[4], c9 = i8[2] * r17[3] + i8[5] * r17[4] + r17[5], m7 = s10._t;
    return m7[0] = n16, m7[1] = o10, m7[2] = a10, m7[3] = h6, m7[4] = l8, m7[5] = c9, s10;
  }
  invert() {
    const t8 = this._t;
    let e10 = t8[0] * t8[4] - t8[1] * t8[3];
    if (0 === e10)
      return new z2([0, 0, 0, 0, 0, 0]);
    e10 = 1 / e10;
    const s10 = (t8[1] * t8[5] - t8[2] * t8[4]) * e10, i8 = (t8[2] * t8[3] - t8[0] * t8[5]) * e10, r17 = t8[4] * e10, n16 = -t8[1] * e10, o10 = -t8[3] * e10, a10 = t8[0] * e10;
    return new z2([r17, n16, s10, o10, a10, i8]);
  }
};
var F = class {
  constructor(t8, e10) {
    this._transfos = [], this._sizeTransfos = [], this._geomUnitsPerPoint = 1, this._placementPool = new e(t7, null, null, 100), this._earlyReturn = false, this._mapRotation = 0, this._resourceManager = t8 || new s4(), this._transfos.push(e10 || z2.createIdentity()), this._sizeTransfos.push(e10 ? e10.scaleRatio() : 1);
  }
  setTransform(t8, e10) {
    this._transfos = [t8 || z2.createIdentity()], this._sizeTransfos = [e10 || (t8 ? t8.scaleRatio() : 1)];
  }
  setGeomUnitsPerPoint(t8) {
    this._geomUnitsPerPoint = t8;
  }
  transformPt(t8) {
    return this._transfos[this._transfos.length - 1].transform(t8);
  }
  transformSize(t8) {
    return t8 * this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformPt(t8) {
    return this._transfos[this._transfos.length - 1].invert().transform(t8);
  }
  reverseTransformSize(t8) {
    return t8 / this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  geomUnitsPerPoint() {
    return this.isEmbedded() ? 1 : this._geomUnitsPerPoint;
  }
  isEmbedded() {
    return this._transfos.length > 1;
  }
  back() {
    return this._transfos[this._transfos.length - 1];
  }
  push(t8, e10) {
    const s10 = e10 ? t8.scaleRatio() : 1;
    z2.multiply(t8, this.back(), t8), this._transfos.push(t8), this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length - 1] * s10);
  }
  pop() {
    this._transfos.splice(-1, 1), this._sizeTransfos.splice(-1, 1);
  }
  drawSymbol(t8, e10) {
    if (t8)
      switch (t8.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          this.drawMultiLayerSymbol(t8, e10);
          break;
        case "CIMTextSymbol":
          this.drawTextSymbol(t8, e10);
      }
  }
  drawMultiLayerSymbol(t8, e10) {
    if (!t8)
      return;
    const s10 = t8.symbolLayers;
    if (!s10)
      return;
    const i8 = t8.effects;
    if (i8 && i8.length > 0) {
      const t9 = this.executeEffects(i8, e10);
      if (t9) {
        let e11 = t9.next();
        for (; e11; )
          this.drawSymbolLayers(s10, e11), e11 = t9.next();
      }
    } else
      this.drawSymbolLayers(s10, e10);
  }
  executeEffects(t8, e10) {
    const s10 = this._resourceManager.geometryEngine;
    let i8 = new r4(e10);
    for (const r17 of t8) {
      const t9 = A2(r17);
      t9 && (i8 = t9.execute(i8, r17, this.geomUnitsPerPoint(), s10));
    }
    return i8;
  }
  drawSymbolLayers(t8, e10) {
    let s10 = t8.length;
    for (; s10--; ) {
      const i8 = t8[s10];
      if (!i8 || false === i8.enable)
        continue;
      const r17 = i8.effects;
      if (r17 && r17.length > 0) {
        const t9 = this.executeEffects(r17, e10);
        if (t9) {
          let e11 = null;
          for (; (e11 = t9.next()) && (this.drawSymbolLayer(i8, e11), !this._earlyReturn); )
            ;
        }
      } else
        this.drawSymbolLayer(i8, e10);
      if (this._earlyReturn)
        return;
    }
  }
  drawSymbolLayer(t8, e10) {
    switch (t8.type) {
      case "CIMSolidFill":
        this.drawSolidFill(e10, t8.color);
        break;
      case "CIMHatchFill":
        this.drawHatchFill(e10, t8);
        break;
      case "CIMPictureFill":
        this.drawPictureFill(e10, t8);
        break;
      case "CIMGradientFill":
        this.drawGradientFill(e10, t8);
        break;
      case "CIMSolidStroke":
        this.drawSolidStroke(e10, t8.color, t8.width, t8.capStyle, t8.joinStyle, t8.miterLimit);
        break;
      case "CIMPictureStroke":
        this.drawPictureStroke(e10, t8);
        break;
      case "CIMGradientStroke":
        this.drawGradientStroke(e10, t8);
        break;
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        this.drawMarkerLayer(t8, e10);
    }
  }
  drawHatchFill(t8, e10) {
    const s10 = this._buildHatchPolyline(e10, t8, this.geomUnitsPerPoint());
    s10 && (this.pushClipPath(t8), this.drawMultiLayerSymbol(e10.lineSymbol, s10), this.popClipPath());
  }
  drawPictureFill(t8, e10) {
  }
  drawGradientFill(t8, e10) {
  }
  drawPictureStroke(t8, e10) {
  }
  drawGradientStroke(t8, e10) {
  }
  drawMarkerLayer(t8, e10) {
    const s10 = t8.markerPlacement;
    if (s10) {
      const i8 = g3(s10);
      if (i8) {
        const r17 = "CIMMarkerPlacementInsidePolygon" === s10.type;
        r17 && this.pushClipPath(e10);
        const n16 = i8.execute(e10, s10, this.geomUnitsPerPoint(), this._resourceManager.geometryEngine);
        if (n16) {
          let e11 = null;
          for (; (e11 = n16.next()) && (this.drawMarker(t8, e11), !this._earlyReturn); )
            ;
        }
        r17 && this.popClipPath();
      }
    } else {
      const s11 = this._placementPool.acquire();
      if (l(e10))
        s11.tx = e10.x, s11.ty = e10.y, this.drawMarker(t8, s11);
      else if (c2(e10))
        [s11.tx, s11.ty] = e2(e10), this.drawMarker(t8, s11);
      else
        for (const i8 of e10.points)
          if (s11.tx = i8[0], s11.ty = i8[1], this.drawMarker(t8, s11), this._earlyReturn)
            break;
      this._placementPool.release(s11);
    }
  }
  drawMarker(t8, e10) {
    switch (t8.type) {
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
        this.drawPictureMarker(t8, e10);
        break;
      case "CIMVectorMarker":
        this.drawVectorMarker(t8, e10);
    }
  }
  drawPictureMarker(t8, e10) {
    if (!t8)
      return;
    const i8 = this._resourceManager.getResource(t8.url), r17 = t8.size ?? 10;
    if (t(i8) || r17 <= 0)
      return;
    const n16 = i8.width, o10 = i8.height;
    if (!n16 || !o10)
      return;
    const a10 = n16 / o10, h6 = t8.scaleX ?? 1, l8 = z2.createIdentity(), c9 = t8.anchorPoint;
    if (c9) {
      let e11 = c9.x, s10 = c9.y;
      "Absolute" !== t8.anchorPointUnits && (e11 *= r17 * a10 * h6, s10 *= r17), l8.translate(-e11, -s10);
    }
    let m7 = t8.rotation ?? 0;
    t8.rotateClockwise && (m7 = -m7), this._mapRotation && (m7 += this._mapRotation), m7 && l8.rotate(m7 * I2);
    let f7 = t8.offsetX ?? 0, u9 = t8.offsetY ?? 0;
    if (f7 || u9) {
      if (this._mapRotation) {
        const t9 = I2 * this._mapRotation, e11 = Math.cos(t9), s10 = Math.sin(t9), i9 = f7 * s10 + u9 * e11;
        f7 = f7 * e11 - u9 * s10, u9 = i9;
      }
      l8.translate(f7, u9);
    }
    const _4 = this.geomUnitsPerPoint();
    1 !== _4 && l8.scale(_4, _4);
    const d2 = e10.getAngle();
    d2 && l8.rotate(d2), l8.translate(e10.tx, e10.ty), this.push(l8, false), this.drawImage(t8.url, r17, t8.scaleX), this.pop();
  }
  drawVectorMarker(t8, e10) {
    if (!t8)
      return;
    const s10 = t8.markerGraphics;
    if (!s10)
      return;
    const i8 = t8.size ?? 10, r17 = t8.frame, n16 = r17 ? r17.ymax - r17.ymin : 0, o10 = i8 && n16 ? i8 / n16 : 1, a10 = z2.createIdentity();
    r17 && a10.translate(0.5 * -(r17.xmax + r17.xmin), 0.5 * -(r17.ymax + r17.ymin));
    const h6 = t8.anchorPoint;
    if (h6) {
      let e11 = h6.x, s11 = h6.y;
      "Absolute" !== t8.anchorPointUnits ? r17 && (e11 *= r17.xmax - r17.xmin, s11 *= r17.ymax - r17.ymin) : (e11 /= o10, s11 /= o10), a10.translate(-e11, -s11);
    }
    1 !== o10 && a10.scale(o10, o10);
    let l8 = t8.rotation ?? 0;
    t8.rotateClockwise && (l8 = -l8), this._mapRotation && (l8 += this._mapRotation), l8 && a10.rotate(l8 * I2);
    let c9 = t8.offsetX ?? 0, m7 = t8.offsetY ?? 0;
    if (c9 || m7) {
      if (this._mapRotation) {
        const t9 = I2 * this._mapRotation, e11 = Math.cos(t9), s11 = Math.sin(t9), i9 = c9 * s11 + m7 * e11;
        c9 = c9 * e11 - m7 * s11, m7 = i9;
      }
      a10.translate(c9, m7);
    }
    const f7 = this.geomUnitsPerPoint();
    1 !== f7 && a10.scale(f7, f7);
    const u9 = e10.getAngle();
    u9 && a10.rotate(u9), a10.translate(e10.tx, e10.ty), this.push(a10, t8.scaleSymbolsProportionally);
    for (const _4 of s10)
      if (_4 && _4.symbol && _4.geometry || L2.error("Invalid marker graphic", _4), this.drawSymbol(_4.symbol, _4.geometry), this._earlyReturn)
        break;
    this.pop();
  }
  drawTextSymbol(t8, e10) {
    if (!t8)
      return;
    if (!l(e10))
      return;
    if ((t8.height ?? 10) <= 0)
      return;
    const s10 = z2.createIdentity();
    let i8 = t8.angle ?? 0;
    i8 = -i8, i8 && s10.rotate(i8 * I2);
    const r17 = t8.offsetX ?? 0, n16 = t8.offsetY ?? 0;
    (r17 || n16) && s10.translate(r17, n16);
    const o10 = this.geomUnitsPerPoint();
    1 !== o10 && s10.scale(o10, o10), s10.translate(e10.x, e10.y), this.push(s10, false), this.drawText(t8), this.pop();
  }
  _buildHatchPolyline(t8, e10, s10) {
    let i8 = (void 0 !== t8.separation ? t8.separation : 4) * s10, r17 = void 0 !== t8.rotation ? t8.rotation : 0;
    if (0 === i8)
      return null;
    i8 < 0 && (i8 = -i8);
    let n16 = 0;
    const a10 = 0.5 * i8;
    for (; n16 > a10; )
      n16 -= i8;
    for (; n16 < -a10; )
      n16 += i8;
    const l8 = u2();
    c(l8, e10), l8[0] -= a10, l8[1] -= a10, l8[2] += a10, l8[3] += a10;
    const c9 = [[l8[0], l8[1]], [l8[0], l8[3]], [l8[2], l8[3]], [l8[2], l8[1]]];
    for (; r17 > 180; )
      r17 -= 180;
    for (; r17 < 0; )
      r17 += 180;
    const m7 = Math.cos(r17 * I2), f7 = Math.sin(r17 * I2), u9 = -i8 * f7, _4 = i8 * m7;
    let d2, p3, y5, g5;
    n16 = (void 0 !== t8.offsetX ? t8.offsetX * s10 : 0) * f7 - (void 0 !== t8.offsetY ? t8.offsetY * s10 : 0) * m7, d2 = y5 = Number.MAX_VALUE, p3 = g5 = -Number.MAX_VALUE;
    for (const o10 of c9) {
      const t9 = o10[0], e11 = o10[1], s11 = m7 * t9 + f7 * e11, i9 = -f7 * t9 + m7 * e11;
      d2 = Math.min(d2, s11), y5 = Math.min(y5, i9), p3 = Math.max(p3, s11), g5 = Math.max(g5, i9);
    }
    y5 = Math.floor(y5 / i8) * i8;
    let P3 = m7 * d2 - f7 * y5 - u9 * n16 / i8, x3 = f7 * d2 + m7 * y5 - _4 * n16 / i8, w4 = m7 * p3 - f7 * y5 - u9 * n16 / i8, M3 = f7 * p3 + m7 * y5 - _4 * n16 / i8;
    const b3 = 1 + Math.round((g5 - y5) / i8), S = [];
    for (let o10 = 0; o10 < b3; o10++)
      P3 += u9, x3 += _4, w4 += u9, M3 += _4, S.push([[P3, x3], [w4, M3]]);
    return { paths: S };
  }
};
var U4 = class extends F {
  constructor(t8, e10) {
    super(t8, e10), this.reset();
  }
  reset() {
    this._xmin = this._ymin = 1 / 0, this._xmax = this._ymax = -1 / 0, this._clipCount = 0;
  }
  envelope() {
    return new t6(this._xmin, this._ymin, this._xmax - this._xmin, this._ymax - this._ymin);
  }
  bounds() {
    return o(this._xmin, this._ymin, this._xmax, this._ymax);
  }
  drawSolidFill(t8) {
    if (t8 && !(this._clipCount > 0))
      if (c2(t8))
        this._processPath(t8.rings, 0);
      else if (y(t8))
        this._processPath(t8.paths, 0);
      else if (s3(t8)) {
        const e10 = G2(t8);
        e10 && this._processPath(e10.rings, 0);
      } else
        console.error("drawSolidFill Unexpected geometry type!");
  }
  drawSolidStroke(t8, e10, s10) {
    if (!t8 || this._clipCount > 0)
      return;
    const i8 = 0.5 * this.transformSize(s10);
    if (c2(t8))
      this._processPath(t8.rings, i8);
    else if (y(t8))
      this._processPath(t8.paths, i8);
    else if (s3(t8)) {
      const e11 = G2(t8);
      e11 && this._processPath(e11.rings, i8);
    } else
      console.error("drawSolidStroke unexpected geometry type!");
  }
  pushClipPath(t8) {
    this.drawSolidFill(t8), ++this._clipCount;
  }
  popClipPath() {
    --this._clipCount;
  }
  drawImage(t8, e10, s10) {
    let r17 = s10 * e10, n16 = e10;
    const o10 = this._resourceManager.getResource(t8);
    !e10 && r(o10) && (r17 = s10 * o10.width, n16 = o10.height), this._merge(this.transformPt([-r17 / 2, -n16 / 2]), 0), this._merge(this.transformPt([-r17 / 2, n16 / 2]), 0), this._merge(this.transformPt([r17 / 2, -n16 / 2]), 0), this._merge(this.transformPt([r17 / 2, n16 / 2]), 0);
  }
  drawText(t8) {
    this._textRasterizer || (this._textRasterizer = new s5());
  }
  _processPath(t8, e10) {
    if (t8)
      for (const s10 of t8) {
        const t9 = s10 ? s10.length : 0;
        if (t9 > 1) {
          this._merge(this.transformPt(s10[0]), e10);
          for (let i8 = 1; i8 < t9; ++i8)
            this._merge(this.transformPt(s10[i8]), e10);
        }
      }
  }
  _merge(t8, e10) {
    t8[0] - e10 < this._xmin && (this._xmin = t8[0] - e10), t8[0] + e10 > this._xmax && (this._xmax = t8[0] + e10), t8[1] - e10 < this._ymin && (this._ymin = t8[1] - e10), t8[1] + e10 > this._ymax && (this._ymax = t8[1] + e10);
  }
};
var j4 = class extends F {
  constructor() {
    super(...arguments), this._searchPoint = [0, 0], this._searchDistPoint = 0;
  }
  hitTest(t8, e10, s10, i8, r17, o10) {
    const a10 = o10 * u(1);
    this.setTransform(), this.setGeomUnitsPerPoint(a10), this._searchPoint = [(t8[0] + t8[2]) / 2, (t8[1] + t8[3]) / 2], this._searchDistPoint = (t8[2] - t8[0]) / 2 / a10, this._textInfo = i8;
    const h6 = e10 && ("CIMPointSymbol" === e10.type && "Map" !== e10.angleAlignment || "CIMTextSymbol" === e10.type);
    return this._mapRotation = h6 ? r17 : 0, this._earlyReturn = false, this.drawSymbol(e10, s10), this._earlyReturn;
  }
  drawSolidFill(t8, e10) {
    this._hitTestFill(t8);
  }
  drawHatchFill(t8, e10) {
    this._hitTestFill(t8);
  }
  drawPictureFill(t8, e10) {
    this._hitTestFill(t8);
  }
  drawGradientFill(t8, e10) {
    this._hitTestFill(t8);
  }
  drawSolidStroke(t8, e10, s10, i8, r17, n16) {
    this._hitTestStroke(t8, s10);
  }
  drawPictureStroke(t8, e10) {
    this._hitTestStroke(t8, e10.width);
  }
  drawGradientStroke(t8, e10) {
    this._hitTestStroke(t8, e10.width);
  }
  drawMarkerLayer(t8, e10) {
    t8.markerPlacement && "CIMMarkerPlacementInsidePolygon" === t8.markerPlacement.type ? this._hitTestFill(e10) : super.drawMarkerLayer(t8, e10);
  }
  pushClipPath(t8) {
  }
  popClipPath() {
  }
  drawImage(t8, e10, i8) {
    const r17 = this._resourceManager.getResource(t8);
    if (t(r17) || 0 === r17.height || 0 === e10)
      return;
    const n16 = e10 * this.geomUnitsPerPoint(), o10 = n16 * i8 * (r17.width / r17.height), a10 = this.reverseTransformPt(this._searchPoint), h6 = this._searchDistPoint;
    Math.abs(a10[0]) < o10 / 2 + h6 && Math.abs(a10[1]) < n16 / 2 + h6 && (this._earlyReturn = true);
  }
  drawText(e10) {
    const s10 = this._textInfo;
    if (!s10)
      return;
    const i8 = s10.get(e10);
    if (!i8)
      return;
    const { text: r17, mosaicItem: n16 } = i8;
    if (!n16 || 0 === n16.glyphMosaicItems.length)
      return;
    const o10 = e10.height ?? v2, a10 = B3(e10.lineGapType, e10.lineGap ?? 0, o10), h6 = n4(r17)[1], l8 = n16.glyphMosaicItems, c9 = j3(l8, h6, { scale: o10 / j, angle: 0, xOffset: 0, yOffset: 0, hAlign: E(e10.horizontalAlignment), vAlign: H(e10.verticalAlignment), maxLineWidth: 512, lineHeight: f2 * Math.max(0.25, Math.min(a10 || 1, 4)), decoration: e10.font.decoration || "none", isCIM: true }), m7 = this.reverseTransformPt(this._searchPoint), f7 = m7[0], u9 = m7[1];
    for (const t8 of c9.glyphs)
      if (f7 > t8.xTopLeft && f7 < t8.xBottomRight && u9 > -t8.yBottomRight && u9 < -t8.yTopLeft) {
        this._earlyReturn = true;
        break;
      }
  }
  _hitTestFill(t8) {
    let e10 = null;
    if (s3(t8)) {
      const s11 = t8;
      e10 = [[[s11.xmin, s11.ymin], [s11.xmin, s11.ymax], [s11.xmax, s11.ymax], [s11.xmax, s11.ymin], [s11.xmin, s11.ymin]]];
    } else if (c2(t8))
      e10 = t8.rings;
    else {
      if (!y(t8))
        return;
      e10 = t8.paths;
    }
    const s10 = this.reverseTransformPt(this._searchPoint);
    if (this._pointInPolygon(s10, e10) && (this._earlyReturn = true), !this._earlyReturn) {
      const t9 = this.reverseTransformSize(this._searchDistPoint) * this.geomUnitsPerPoint();
      this._nearLine(s10, e10, t9) && (this._earlyReturn = true);
    }
  }
  _hitTestStroke(t8, e10) {
    let s10 = null;
    if (s3(t8)) {
      const e11 = t8;
      s10 = [[[e11.xmin, e11.ymin], [e11.xmin, e11.ymax], [e11.xmax, e11.ymax], [e11.xmax, e11.ymin], [e11.xmin, e11.ymin]]];
    } else if (c2(t8))
      s10 = t8.rings;
    else {
      if (!y(t8))
        return;
      s10 = t8.paths;
    }
    const i8 = this.reverseTransformPt(this._searchPoint), r17 = e10 * this.geomUnitsPerPoint(), n16 = this.reverseTransformSize(this._searchDistPoint) * this.geomUnitsPerPoint();
    this._nearLine(i8, s10, r17 / 2 + n16) && (this._earlyReturn = true);
  }
  _pointInPolygon(t8, e10) {
    let s10 = 0;
    for (const i8 of e10) {
      const e11 = i8.length;
      for (let r17 = 1; r17 < e11; ++r17) {
        const e12 = i8[r17 - 1], n16 = i8[r17];
        if (e12[1] > t8[1] == n16[1] > t8[1])
          continue;
        (n16[0] - e12[0]) * (t8[1] - e12[1]) - (n16[1] - e12[1]) * (t8[0] - e12[0]) > 0 ? s10++ : s10--;
      }
    }
    return 0 !== s10;
  }
  _nearLine(t8, e10, s10) {
    for (const i8 of e10) {
      const e11 = i8.length;
      for (let r17 = 1; r17 < e11; ++r17) {
        const e12 = i8[r17 - 1], n16 = i8[r17];
        let o10 = (n16[0] - e12[0]) * (n16[0] - e12[0]) + (n16[1] - e12[1]) * (n16[1] - e12[1]);
        if (0 === o10)
          continue;
        o10 = Math.sqrt(o10);
        const a10 = ((n16[0] - e12[0]) * (t8[1] - e12[1]) - (n16[1] - e12[1]) * (t8[0] - e12[0])) / o10;
        if (Math.abs(a10) < s10) {
          const i9 = ((n16[0] - e12[0]) * (t8[0] - e12[0]) + (n16[1] - e12[1]) * (t8[1] - e12[1])) / o10;
          if (i9 > -s10 && i9 < o10 + s10)
            return true;
        }
      }
    }
    return false;
  }
};
var A3 = class extends F {
  constructor(t8, e10, s10) {
    super(e10, s10), this._ctx = t8;
  }
  drawSolidFill(t8, e10) {
    if (!t8)
      return;
    if (c2(t8))
      this._buildPath(t8.rings, true);
    else if (y(t8))
      this._buildPath(t8.paths, true);
    else if (s3(t8))
      this._buildPath(G2(t8).rings, true);
    else {
      if (!f(t8))
        return;
      console.log("CanvasDrawHelper.drawSolidFill - No implementation!");
    }
    const s10 = this._ctx;
    s10.fillStyle = "string" == typeof e10 ? e10 : "rgba(" + Math.round(e10[0]) + "," + Math.round(e10[1]) + "," + Math.round(e10[2]) + "," + e10[3] / 255 + ")", s10.fill("evenodd");
  }
  drawSolidStroke(t8, e10, s10, i8, r17, n16) {
    if (!t8 || !e10 || 0 === s10)
      return;
    if (c2(t8))
      this._buildPath(t8.rings, true);
    else if (y(t8))
      this._buildPath(t8.paths, false);
    else {
      if (!s3(t8))
        return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");
      this._buildPath(G2(t8).rings, true);
    }
    const o10 = this._ctx;
    o10.strokeStyle = "string" == typeof e10 ? e10 : "rgba(" + Math.round(e10[0]) + "," + Math.round(e10[1]) + "," + Math.round(e10[2]) + "," + e10[3] / 255 + ")", o10.lineWidth = this.transformSize(s10) + 0.5, this._setCapStyle(i8), this._setJoinStyle(r17), o10.miterLimit = n16, o10.stroke();
  }
  pushClipPath(t8) {
    if (this._ctx.save(), c2(t8))
      this._buildPath(t8.rings, true);
    else if (y(t8))
      this._buildPath(t8.paths, true);
    else {
      if (!s3(t8))
        return;
      this._buildPath(G2(t8).rings, true);
    }
    this._ctx.clip("evenodd");
  }
  popClipPath() {
    this._ctx.restore();
  }
  drawImage(t8, e10, i8) {
    const r17 = this._resourceManager.getResource(t8);
    if (t(r17))
      return;
    const n16 = this._ctx, o10 = n16.canvas.width, a10 = n16.canvas.height;
    let h6 = e10 * i8 * (r17.width / r17.height), l8 = i8 * e10;
    e10 || (h6 = i8 * r17.width, l8 = i8 * r17.height);
    const c9 = this.transformPt([0, 0]), m7 = this.transformSize(h6), f7 = this.transformSize(l8);
    this._ctx.drawImage(r17, 0, 0, r17.width, r17.height, c9[0] - m7 / 2, c9[1] - f7 / 2, Math.min(m7, o10), Math.min(f7, a10));
  }
  drawText(t8) {
    this._textRasterizer || (this._textRasterizer = new s5());
  }
  _buildPath(t8, e10) {
    const s10 = this._ctx;
    if (s10.beginPath(), t8)
      for (const i8 of t8) {
        const t9 = i8 ? i8.length : 0;
        if (t9 > 1) {
          let r17 = this.transformPt(i8[0]);
          s10.moveTo(r17[0], r17[1]);
          for (let e11 = 1; e11 < t9; ++e11)
            r17 = this.transformPt(i8[e11]), s10.lineTo(r17[0], r17[1]);
          e10 && s10.closePath();
        }
      }
  }
  _setCapStyle(t8) {
    switch (t8) {
      case U2.Butt:
        this._ctx.lineCap = "butt";
        break;
      case U2.Round:
        this._ctx.lineCap = "round";
        break;
      case U2.Square:
        this._ctx.lineCap = "square";
    }
  }
  _setJoinStyle(t8) {
    switch (t8) {
      case w.Bevel:
        this._ctx.lineJoin = "bevel";
        break;
      case w.Round:
        this._ctx.lineJoin = "round";
        break;
      case w.Miter:
        this._ctx.lineJoin = "miter";
    }
  }
};
var G2 = (t8) => t8 ? { spatialReference: t8.spatialReference, rings: [[[t8.xmin, t8.ymin], [t8.xmin, t8.ymax], [t8.xmax, t8.ymax], [t8.xmax, t8.ymin], [t8.xmin, t8.ymin]]] } : null;
var E = (t8) => {
  switch (t8) {
    case "Left":
      return e4.Left;
    case "Right":
      return e4.Right;
    case "Center":
      return e4.Center;
    case "Justify":
      return L2.warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."), e4.Center;
  }
};
var H = (t8) => {
  switch (t8) {
    case "Top":
      return t3.Top;
    case "Center":
      return t3.Center;
    case "Bottom":
      return t3.Bottom;
    case "Baseline":
      return t3.Baseline;
  }
};
var B3 = (t8, e10, s10) => {
  switch (t8) {
    case "ExtraLeading":
      return 1 + e10 / s10;
    case "Multiple":
      return e10;
    case "Exact":
      return e10 / s10;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMSymbolHelper.js
var V = Math.PI;
var B4 = V / 2;
var X2 = 4;
var U5 = 10;
var _3 = 96 / 72;
var H2 = Math.PI / 180;
var Y2 = s.getLogger("esri.symbols.cim.CIMSymbolHelper");
function q(e10) {
  if (!e10 || !e10.type)
    return null;
  let t8;
  switch (e10.type) {
    case "cim":
      return e10.data;
    case "web-style":
      return e10;
    case "simple-marker":
      t8 = Z2.fromSimpleMarker(e10);
      break;
    case "picture-marker":
      t8 = Z2.fromPictureMarker(e10);
      break;
    case "simple-line":
      t8 = Z2.fromSimpleLineSymbol(e10);
      break;
    case "simple-fill":
      t8 = Z2.fromSimpleFillSymbol(e10);
      break;
    case "picture-fill":
      t8 = Z2.fromPictureFillSymbol(e10);
      break;
    case "text":
      t8 = Z2.fromTextSymbol(e10);
  }
  return { type: "CIMSymbolReference", symbol: t8 };
}
function W(e10, t8) {
  switch (t8.type) {
    case "CIMSymbolReference":
      return W(e10, t8.symbol);
    case "CIMPointSymbol": {
      const r17 = { x: 0, y: 0 };
      e10.drawSymbol(t8, r17);
      break;
    }
    case "CIMLineSymbol": {
      const r17 = { paths: [[[0, 0], [0, 1]]] };
      e10.drawSymbol(t8, r17);
      break;
    }
    case "CIMPolygonSymbol": {
      const r17 = { rings: [[[0, 0], [0, 1], [0, 0]]] };
      e10.drawSymbol(t8, r17);
      break;
    }
    case "CIMTextSymbol": {
      const r17 = { x: 0, y: 0 };
      e10.drawSymbol(t8, r17);
      break;
    }
    case "CIMVectorMarker": {
      const r17 = new t7();
      e10.drawMarker(t8, r17);
      break;
    }
  }
  return e10.envelope();
}
function $(e10) {
  if (!e10)
    return 0;
  switch (e10.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAtExtremities":
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementAtRatioPositions":
    case "CIMMarkerPlacementOnLine":
    case "CIMMarkerPlacementOnVertices":
      return Math.abs(e10.offset);
    default:
      return 0;
  }
}
function J(e10) {
  if (!e10)
    return 0;
  switch (e10.type) {
    case "CIMGeometricEffectArrow":
      return Math.abs(0.5 * e10.width);
    case "CIMGeometricEffectBuffer":
      return Math.abs(e10.size);
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectRadial":
      return Math.abs(e10.length);
    case "CIMGeometricEffectJog":
      return Math.abs(0.5 * e10.length);
    case "CIMGeometricEffectMove":
      return Math.max(Math.abs(M(e10.offsetX)), Math.abs(M(e10.offsetY)));
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      return Math.abs(e10.offset);
    case "CIMGeometricEffectRegularPolygon":
      return Math.abs(e10.radius);
    case "CIMGeometricEffectRotate":
    case "CIMGeometricEffectScale":
    default:
      return 0;
    case "CIMGeometricEffectTaperedPolygon":
      return 0.5 * Math.max(Math.abs(e10.fromWidth), Math.abs(e10.toWidth));
    case "CIMGeometricEffectWave":
      return Math.abs(e10.amplitude);
  }
}
function K2(e10) {
  if (!e10)
    return 0;
  let t8 = 0;
  for (const r17 of e10)
    t8 += J(r17);
  return t8;
}
var Q = class {
  getSymbolInflateSize(e10, t8, r17, o10, a10) {
    return e10 || (e10 = [0, 0, 0, 0]), t8 ? this._getInflateSize(e10, t8, r17, o10, a10) : e10;
  }
  static safeSize(e10) {
    const t8 = Math.max(Math.abs(e10[0]), Math.abs(e10[2])), r17 = Math.max(Math.abs(e10[1]), Math.abs(e10[3]));
    return Math.sqrt(t8 * t8 + r17 * r17);
  }
  _vectorMarkerBounds(e10, t8, r17, o10) {
    let a10 = true;
    const i8 = u2();
    if (t8 && t8.markerGraphics)
      for (const s10 of t8.markerGraphics) {
        const t9 = [0, 0, 0, 0];
        s10.geometry && (c(i8, s10.geometry), t9[0] = 0, t9[1] = 0, t9[2] = 0, t9[3] = 0, this.getSymbolInflateSize(t9, s10.symbol, r17, 0, o10), i8[0] += t9[0], i8[1] += t9[1], i8[2] += t9[2], i8[3] += t9[3], a10 ? (e10[0] = i8[0], e10[1] = i8[1], e10[2] = i8[2], e10[3] = i8[3], a10 = false) : (e10[0] = Math.min(e10[0], i8[0]), e10[1] = Math.min(e10[1], i8[1]), e10[2] = Math.max(e10[2], i8[2]), e10[3] = Math.max(e10[3], i8[3])));
      }
    return e10;
  }
  _getInflateSize(e10, t8, r17, o10, a10) {
    if (fe(t8)) {
      const i8 = this._getLayersInflateSize(e10, t8.symbolLayers, r17, o10, a10), s10 = K2(t8.effects);
      return s10 > 0 && (i8[0] -= s10, i8[1] -= s10, i8[2] += s10, i8[3] += s10), i8;
    }
    return this._getTextInflatedSize(e10, t8, a10);
  }
  _getLayersInflateSize(e10, t8, r17, o10, a10) {
    let i8 = true;
    if (!t8)
      return e10;
    for (const n16 of t8) {
      if (!n16)
        continue;
      let t9 = [0, 0, 0, 0];
      switch (n16.type) {
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke": {
          const e11 = n16;
          let r18 = e11.width;
          e11.capStyle === U2.Square || e11.joinStyle === w.Miter ? r18 /= 1.4142135623730951 : r18 /= 2, t9[0] = -r18, t9[1] = -r18, t9[2] = r18, t9[3] = r18;
          break;
        }
        case "CIMCharacterMarker":
        case "CIMVectorMarker":
        case "CIMPictureMarker": {
          const e11 = n16;
          if ("CIMVectorMarker" === n16.type) {
            const e12 = n16;
            if (t9 = this._vectorMarkerBounds(t9, e12, r17, a10), e12.frame) {
              const r18 = (e12.frame.xmin + e12.frame.xmax) / 2, o11 = (e12.frame.ymin + e12.frame.ymax) / 2;
              t9[0] -= r18, t9[1] -= o11, t9[2] -= r18, t9[3] -= o11;
              const a11 = e12.size / (e12.frame.ymax - e12.frame.ymin);
              t9[0] *= a11, t9[1] *= a11, t9[2] *= a11, t9[3] *= a11;
            }
          } else if ("CIMPictureMarker" === n16.type) {
            const o11 = n16, a11 = r17.getResource(o11.url);
            let i10 = 1;
            r(a11) && a11.height && (i10 = a11.width / a11.height);
            const l10 = e11.size / 2, c10 = e11.size * i10 * o11.scaleX / 2;
            t9 = [-c10, -l10, c10, l10];
          } else {
            const r18 = e11.size / 2;
            t9 = [-r18, -r18, r18, r18];
          }
          if (e11.anchorPoint) {
            let r18, o11;
            "Absolute" === e11.anchorPointUnits ? (r18 = e11.anchorPoint.x, o11 = e11.anchorPoint.y) : (r18 = e11.anchorPoint.x * (t9[2] - t9[0]), o11 = e11.anchorPoint.y * (t9[3] - t9[1])), t9[0] -= r18, t9[1] -= o11, t9[2] -= r18, t9[3] -= o11;
          }
          let i9 = M(e11.rotation);
          if (e11.rotateClockwise && (i9 = -i9), o10 && (i9 -= o10), i9) {
            const e12 = H2 * i9, r18 = Math.cos(e12), o11 = Math.sin(e12), a11 = u2([n3, n3, -n3, -n3]);
            m2(a11, [t9[0] * r18 - t9[1] * o11, t9[0] * o11 + t9[1] * r18]), m2(a11, [t9[0] * r18 - t9[3] * o11, t9[0] * o11 + t9[3] * r18]), m2(a11, [t9[2] * r18 - t9[1] * o11, t9[2] * o11 + t9[1] * r18]), m2(a11, [t9[2] * r18 - t9[3] * o11, t9[2] * o11 + t9[3] * r18]), t9 = a11;
          }
          let l9 = M(e11.offsetX), c9 = M(e11.offsetY);
          if (o10) {
            const e12 = H2 * o10, t10 = Math.cos(e12), r18 = Math.sin(e12), a11 = l9 * r18 + c9 * t10;
            l9 = l9 * t10 - c9 * r18, c9 = a11;
          }
          t9[0] += l9, t9[1] += c9, t9[2] += l9, t9[3] += c9;
          const m7 = $(e11.markerPlacement);
          m7 > 0 && (t9[0] -= m7, t9[1] -= m7, t9[2] += m7, t9[3] += m7);
          break;
        }
      }
      const l8 = K2(n16.effects);
      l8 > 0 && (t9[0] -= l8, t9[1] -= l8, t9[2] += l8, t9[3] += l8), i8 ? (e10[0] = t9[0], e10[1] = t9[1], e10[2] = t9[2], e10[3] = t9[3], i8 = false) : (e10[0] = Math.min(e10[0], t9[0]), e10[1] = Math.min(e10[1], t9[1]), e10[2] = Math.max(e10[2], t9[2]), e10[3] = Math.max(e10[3], t9[3]));
    }
    return e10;
  }
  _getTextInflatedSize(e10, r17, o10) {
    const a10 = r17.height ?? U5;
    if (e10[0] = -a10 / 2, e10[1] = -a10 / 2, e10[2] = a10 / 2, e10[3] = a10 / 2, !o10)
      return e10;
    const i8 = o10.get(r17);
    if (!i8)
      return e10;
    const { text: s10, mosaicItem: n16 } = i8;
    if (!n16 || 0 === n16.glyphMosaicItems.length)
      return e10;
    const l8 = B3(r17.lineGapType, r17.lineGap ?? 0, a10), c9 = n4(s10)[1], m7 = n16.glyphMosaicItems, f7 = j3(m7, c9, { scale: a10 / j, angle: M(r17.angle), xOffset: M(r17.offsetX), yOffset: M(r17.offsetY), hAlign: E(r17.horizontalAlignment), vAlign: H(r17.verticalAlignment), maxLineWidth: 512, lineHeight: f2 * Math.max(0.25, Math.min(l8 || 1, 4)), decoration: r17.font.decoration || "none", isCIM: true }).boundsT;
    return e10[0] = f7.x - f7.halfWidth, e10[1] = -f7.y - f7.halfHeight, e10[2] = f7.x + f7.halfWidth, e10[3] = -f7.y + f7.halfHeight, e10;
  }
};
var Z2 = class {
  static getEnvelope(e10, t8) {
    const r17 = new U4(t8);
    if (Array.isArray(e10)) {
      let t9;
      for (const o10 of e10)
        t9 ? t9.union(W(r17, o10)) : t9 = W(r17, o10);
      return t9;
    }
    return W(r17, e10);
  }
  static getTextureAnchor(e10, t8) {
    const r17 = this.getEnvelope(e10, t8);
    if (!r17)
      return [0, 0, 0];
    const o10 = (r17.x + 0.5 * r17.width) * _3, a10 = -(r17.y + 0.5 * r17.height) * _3, i8 = r17.width * _3 + 2, s10 = r17.height * _3 + 2;
    return [o10 / i8, a10 / s10, s10];
  }
  static rasterize(e10, t8, r17, o10, a10 = true) {
    const i8 = r17 || this.getEnvelope(t8, o10);
    if (!i8)
      return [null, 0, 0, 0, 0];
    const s10 = (i8.x + 0.5 * i8.width) * _3, n16 = (i8.y + 0.5 * i8.height) * _3;
    e10.width = i8.width * _3, e10.height = i8.height * _3, r17 || (e10.width += 2, e10.height += 2);
    const l8 = e10.getContext("2d"), c9 = z2.createScale(_3, -_3);
    c9.translate(0.5 * e10.width - s10, 0.5 * e10.height + n16);
    const m7 = new A3(l8, o10, c9);
    switch (t8.type) {
      case "CIMPointSymbol": {
        const e11 = { type: "point", x: 0, y: 0 };
        m7.drawSymbol(t8, e11);
        break;
      }
      case "CIMVectorMarker": {
        const e11 = new t7();
        m7.drawMarker(t8, e11);
        break;
      }
    }
    const f7 = l8.getImageData(0, 0, e10.width, e10.height), y5 = new Uint8Array(f7.data);
    if (a10) {
      let e11;
      for (let t9 = 0; t9 < y5.length; t9 += 4)
        e11 = y5[t9 + 3] / 255, y5[t9] = y5[t9] * e11, y5[t9 + 1] = y5[t9 + 1] * e11, y5[t9 + 2] = y5[t9 + 2] * e11;
    }
    return [y5, e10.width, e10.height, -s10 / e10.width, -n16 / e10.height];
  }
  static fromTextSymbol(e10) {
    const { angle: r17, color: o10, font: a10, haloColor: i8, haloSize: s10, horizontalAlignment: n16, kerning: l8, text: c9, verticalAlignment: m7, xoffset: f7, yoffset: y5 } = e10;
    let h6, M3, p3, u9, S;
    a10 && (h6 = a10.family, M3 = a10.style, p3 = a10.weight, u9 = a10.size, S = a10.decoration);
    let d2 = false;
    if (c9) {
      d2 = n4(c9)[1];
    }
    return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, anchorPointUnits: "Relative", dominantSizeAxis3D: "Y", size: 10, billboardMode3D: "FaceNearPlane", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: { type: "CIMTextSymbol", angle: r17, blockProgression: C2.BTT, depth3D: 1, extrapolateBaselines: true, fontEffects: l3.Normal, fontEncoding: a.Unicode, fontFamilyName: h6 || "Arial", fontStyleName: ne2(M3, p3), fontType: u3.Unspecified, haloSize: s10, height: u9, hinting: y2.Default, horizontalAlignment: ae(n16 ?? "center"), kerning: l8, letterWidth: 100, ligatures: true, lineGapType: "Multiple", offsetX: M(f7), offsetY: M(y5), strikethrough: "line-through" === S, underline: "underline" === S, symbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: se(o10) }] }, haloSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: se(i8) }] }, shadowColor: [0, 0, 0, 255], shadowOffsetX: 1, shadowOffsetY: 1, textCase: "Normal", textDirection: d2 ? ne.RTL : ne.LTR, verticalAlignment: ie2(m7 ?? "baseline"), verticalGlyphOrientation: oe.Right, wordSpacing: 100, billboardMode3D: m3.FaceNearPlane }, textString: c9 }], scaleSymbolsProportionally: true, respectFrame: true }], scaleX: 1, angleAlignment: "Display" };
  }
  static fromPictureFillSymbol(e10) {
    const { height: t8, outline: r17, width: o10, xoffset: a10, xscale: i8, yoffset: s10, yscale: n16 } = e10, l8 = [], c9 = { type: "CIMPolygonSymbol", symbolLayers: l8 };
    if (r17) {
      const { cap: e11, join: t9, miterLimit: o11, width: a11 } = r17;
      l8.push({ type: "CIMSolidStroke", color: se(r17.color), capStyle: re(e11), joinStyle: oe2(t9), miterLimit: o11, width: a11 });
    }
    let m7 = e10.url;
    "esriPFS" === e10.type && e10.imageData && (m7 = e10.imageData);
    const f7 = "angle" in e10 ? e10.angle : 0, y5 = o10 * (i8 || 1), h6 = t8 * (n16 || 1);
    return l8.push({ type: "CIMPictureFill", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: m7, height: h6, width: y5, offsetX: M(a10), offsetY: M(s10), rotation: M(-f7), colorSubstitutions: null }), c9;
  }
  static fromSimpleFillSymbol(e10) {
    const { color: t8, style: r17, outline: a10 } = e10, s10 = [], n16 = { type: "CIMPolygonSymbol", symbolLayers: s10 };
    let l8 = null;
    if (a10) {
      const { cap: e11, join: t9, style: r18 } = a10;
      "solid" !== r18 && "none" !== r18 && "esriSLSSolid" !== r18 && "esriSLSNull" !== r18 && (l8 = [{ type: "CIMGeometricEffectDashes", dashTemplate: me(r18, e11), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]), s10.push({ type: "CIMSolidStroke", color: se(a10.color), capStyle: re(e11), joinStyle: oe2(t9), miterLimit: a10.miterLimit, width: a10.width, effects: l8 });
    }
    if (r17 && "solid" !== r17 && "none" !== r17 && "esriSFSSolid" !== r17 && "esriSFSNull" !== r17) {
      const e11 = { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", color: se(t8), capStyle: U2.Butt, joinStyle: w.Miter, width: 0.75 }] };
      let a11 = 0;
      const n17 = c3(Math.ceil(window.devicePixelRatio)), l9 = he(r17) ? 8 * n17 : 10 * n17;
      switch (r17) {
        case "vertical":
        case "esriSFSVertical":
          a11 = 90;
          break;
        case "forward-diagonal":
        case "esriSFSForwardDiagonal":
        case "diagonal-cross":
        case "esriSFSDiagonalCross":
          a11 = -45;
          break;
        case "backward-diagonal":
        case "esriSFSBackwardDiagonal":
          a11 = 45;
          break;
        case "cross":
        case "esriSFSCross":
          a11 = 0;
      }
      s10.push({ type: "CIMHatchFill", lineSymbol: e11, offsetX: 0, offsetY: 0, rotation: a11, separation: l9 }), "cross" === r17 || "esriSFSCross" === r17 ? s10.push({ type: "CIMHatchFill", lineSymbol: m(e11), offsetX: 0, offsetY: 0, rotation: 90, separation: l9 }) : "diagonal-cross" !== r17 && "esriSFSDiagonalCross" !== r17 || s10.push({ type: "CIMHatchFill", lineSymbol: m(e11), offsetX: 0, offsetY: 0, rotation: 45, separation: l9 });
    } else
      !r17 || "solid" !== r17 && "esriSFSSolid" !== r17 || s10.push({ type: "CIMSolidFill", enable: true, color: se(t8) });
    return n16;
  }
  static fromSimpleLineSymbol(e10) {
    const { cap: t8, color: r17, join: o10, marker: a10, miterLimit: i8, style: s10, width: n16 } = e10;
    let l8 = null;
    "solid" !== s10 && "none" !== s10 && "esriSLSSolid" !== s10 && "esriSLSNull" !== s10 && (l8 = [{ type: "CIMGeometricEffectDashes", dashTemplate: me(s10, t8), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]);
    const c9 = [];
    if (a10) {
      let e11;
      switch (a10.placement) {
        case "begin-end":
          e11 = o2.Both;
          break;
        case "begin":
          e11 = o2.JustBegin;
          break;
        case "end":
          e11 = o2.JustEnd;
          break;
        default:
          e11 = o2.None;
      }
      const t9 = Z2.fromSimpleMarker(a10, n16, r17).symbolLayers[0];
      t9.markerPlacement = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: e11, offsetAlongLine: 0 }, c9.push(t9);
    }
    return "none" !== s10 && "esriSLSNull" !== s10 && c9.push({ type: "CIMSolidStroke", color: se(r17), capStyle: re(t8), joinStyle: oe2(o10), miterLimit: i8, width: n16, effects: l8 }), { type: "CIMLineSymbol", symbolLayers: c9 };
  }
  static fromPictureMarker(e10) {
    const { angle: t8, height: r17, width: o10, xoffset: a10, yoffset: i8 } = e10;
    let s10 = e10.url;
    return "esriPMS" === e10.type && e10.imageData && (s10 = e10.imageData), { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: s10, size: r17, width: o10, offsetX: M(a10), offsetY: M(i8), rotation: M(-t8) }] };
  }
  static fromSimpleMarker(e10, t8, r17) {
    const { style: o10 } = e10, a10 = e10.color ?? r17;
    if ("path" === o10) {
      const t9 = [];
      if ("outline" in e10 && e10.outline) {
        const r19 = e10.outline;
        t9.push({ type: "CIMSolidStroke", enable: true, width: u(Math.round(e3(r19.width))), color: se(r19.color) });
      }
      t9.push({ type: "CIMSolidFill", enable: true, color: se(a10), path: e10.path });
      const [r18, o11] = ye("square");
      return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: M(-e10.angle), size: M(e10.size || 6), offsetX: M(e10.xoffset), offsetY: M(e10.yoffset), frame: r18, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: o11, symbol: { type: "CIMPolygonSymbol", symbolLayers: t9 } }] }] };
    }
    const [i8, s10] = ye(o10);
    let n16;
    if (s10 && i8) {
      const r18 = [];
      if ("outline" in e10 && e10.outline) {
        const t9 = e10.outline;
        r18.push({ type: "CIMSolidStroke", enable: true, width: t9.width > 0.667 ? u(Math.round(e3(t9.width))) : t9.width, color: se(t9.color) });
      } else
        !t8 || "line-marker" !== e10.type || "cross" !== e10.style && "x" !== e10.style || r18.push({ type: "CIMSolidStroke", enable: true, width: t8, color: se(a10) });
      r18.push({ type: "CIMSolidFill", enable: true, color: se(a10) });
      const o11 = { type: "CIMPolygonSymbol", symbolLayers: r18 };
      n16 = { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: M(-e10.angle), size: M(e10.size || 6 * t8), offsetX: M(e10.xoffset), offsetY: M(e10.yoffset), frame: i8, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: s10, symbol: o11 }] }] };
    }
    return n16;
  }
  static fromCIMHatchFill(e10) {
    const t8 = e10.separation ?? X2, r17 = t8 / 2, o10 = 4, a10 = e10.lineSymbol;
    let i8 = this._getLineSymbolPeriod(e10.lineSymbol) || o10;
    for (; i8 < o10; )
      i8 *= 2;
    const s10 = i8 / 2;
    return { type: "CIMVectorMarker", frame: { xmin: -s10, xmax: s10, ymin: -r17, ymax: r17 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { paths: [[[-s10, 0], [s10, 0]]] }, symbol: a10 }], size: t8 };
  }
  static _getLineSymbolPeriod(e10) {
    if (e10) {
      const t8 = this._getEffectsRepeat(e10.effects);
      if (t8)
        return t8;
      if (e10.symbolLayers) {
        for (const r17 of e10.symbolLayers)
          if (r17) {
            const e11 = this._getEffectsRepeat(r17.effects);
            if (e11)
              return e11;
            switch (r17.type) {
              case "CIMCharacterMarker":
              case "CIMPictureMarker":
              case "CIMVectorMarker":
              case "CIMObjectMarker3D":
              case "CIMglTFMarker3D": {
                const e12 = this._getPlacementRepeat(r17.markerPlacement);
                if (e12)
                  return e12;
              }
            }
          }
      }
    }
    return 0;
  }
  static _getEffectsRepeat(e10) {
    if (e10) {
      for (const t8 of e10)
        if (t8)
          switch (t8.type) {
            case "CIMGeometricEffectDashes": {
              const e11 = t8.dashTemplate;
              if (e11 && e11.length) {
                let t9 = 0;
                for (const r17 of e11)
                  t9 += r17;
                return 1 & e11.length && (t9 *= 2), t9;
              }
              break;
            }
            case "CIMGeometricEffectWave":
              return t8.period;
            default:
              Y2.error(`unsupported geometric effect type ${t8.type}`);
          }
    }
    return 0;
  }
  static _getPlacementRepeat(e10) {
    if (e10)
      switch (e10.type) {
        case "CIMMarkerPlacementAlongLineSameSize":
        case "CIMMarkerPlacementAlongLineRandomSize":
        case "CIMMarkerPlacementAlongLineVariableSize": {
          const t8 = e10.placementTemplate;
          if (t8 && t8.length) {
            let e11 = 0;
            for (const r17 of t8)
              e11 += r17;
            return 1 & t8.length && (e11 *= 2), e11;
          }
          break;
        }
      }
    return 0;
  }
  static fromCIMInsidePolygon(e10) {
    const t8 = e10.markerPlacement, r17 = { type: e10.type, ...e10 };
    r17.markerPlacement = null, r17.anchorPoint = null;
    const o10 = Math.abs(t8.stepX), a10 = Math.abs(t8.stepY), i8 = (t8.randomness ?? 100) / 100;
    let s10, n16, c9, f7;
    if ("Random" === t8.gridType) {
      const e11 = e3(dt), r18 = Math.max(Math.floor(e11 / o10), 1), y5 = Math.max(Math.floor(e11 / a10), 1);
      s10 = r18 * o10 / 2, n16 = y5 * a10 / 2, c9 = 2 * n16;
      const h6 = new t2(t8.seed), M3 = i8 * o10 / 1.5, p3 = i8 * a10 / 1.5;
      f7 = [];
      for (let t9 = 0; t9 < r18; t9++)
        for (let e12 = 0; e12 < y5; e12++) {
          const r19 = t9 * o10 - s10 + M3 * (0.5 - h6.getFloat()), i9 = e12 * a10 - n16 + p3 * (0.5 - h6.getFloat());
          f7.push({ x: r19, y: i9 }), 0 === t9 && f7.push({ x: r19 + 2 * s10, y: i9 }), 0 === e12 && f7.push({ x: r19, y: i9 + 2 * n16 });
        }
    } else
      true === t8.shiftOddRows ? (s10 = o10 / 2, n16 = a10, c9 = 2 * a10, f7 = [{ x: -s10, y: 0 }, { x: s10, y: 0 }, { x: 0, y: n16 }, { x: 0, y: -n16 }]) : (s10 = o10 / 2, n16 = a10 / 2, c9 = a10, f7 = [{ x: 0, y: 0 }]);
    return { type: "CIMVectorMarker", frame: { xmin: -s10, xmax: s10, ymin: -n16, ymax: n16 }, markerGraphics: f7.map((e11) => ({ type: "CIMMarkerGraphic", geometry: e11, symbol: { type: "CIMPointSymbol", symbolLayers: [r17] } })), size: c9 };
  }
  static getFillColor(e10) {
    if (!e10)
      return null;
    switch (e10.type) {
      case "CIMPolygonSymbol":
        if (e10.symbolLayers)
          for (const t8 of e10.symbolLayers) {
            const e11 = Z2.getFillColor(t8);
            if (null != e11)
              return e11;
          }
        break;
      case "CIMTextSymbol":
        return Z2.getFillColor(e10.symbol);
      case "CIMSolidFill":
        return e10.color;
    }
  }
  static getStrokeColor(e10) {
    if (e10)
      switch (e10.type) {
        case "CIMPolygonSymbol":
        case "CIMLineSymbol":
          if (e10.symbolLayers)
            for (const t8 of e10.symbolLayers) {
              const e11 = Z2.getStrokeColor(t8);
              if (void 0 !== e11)
                return e11;
            }
          break;
        case "CIMTextSymbol":
          return Z2.getStrokeColor(e10.symbol);
        case "CIMSolidStroke":
          return e10.color;
      }
  }
  static getStrokeWidth(e10) {
    if (e10)
      switch (e10.type) {
        case "CIMPolygonSymbol":
        case "CIMLineSymbol":
          if (e10.symbolLayers)
            for (const t8 of e10.symbolLayers) {
              const e11 = Z2.getStrokeWidth(t8);
              if (void 0 !== e11)
                return e11;
            }
          break;
        case "CIMTextSymbol":
          return Z2.getStrokeWidth(e10.symbol);
        case "CIMSolidStroke":
        case "CIMGradientStroke":
        case "CIMPictureStroke":
          return e10.width;
      }
  }
  static getSize(e10) {
    if (e10)
      switch (e10.type) {
        case "CIMTextSymbol":
          return e10.height;
        case "CIMPointSymbol": {
          let t8 = 0;
          if (e10.symbolLayers) {
            for (const r17 of e10.symbolLayers)
              if (r17)
                switch (r17.type) {
                  case "CIMCharacterMarker":
                  case "CIMPictureMarker":
                  case "CIMVectorMarker":
                  case "CIMObjectMarker3D":
                  case "CIMglTFMarker3D": {
                    const e11 = r17.size;
                    e11 > t8 && (t8 = e11);
                    break;
                  }
                }
          }
          return t8;
        }
        case "CIMLineSymbol":
        case "CIMPolygonSymbol": {
          let t8 = 0;
          if (e10.symbolLayers) {
            for (const r17 of e10.symbolLayers)
              if (r17)
                switch (r17.type) {
                  case "CIMSolidStroke":
                  case "CIMPictureStroke":
                  case "CIMGradientStroke": {
                    const e11 = r17.width;
                    e11 > t8 && (t8 = e11);
                    break;
                  }
                  case "CIMCharacterMarker":
                  case "CIMPictureMarker":
                  case "CIMVectorMarker":
                  case "CIMObjectMarker3D":
                  case "CIMglTFMarker3D":
                    if (f3(r17.markerPlacement)) {
                      const e11 = r17.size;
                      e11 > t8 && (t8 = e11);
                    }
                }
          }
          return t8;
        }
      }
  }
  static getMarkerScaleRatio(e10) {
    if (e10 && "CIMVectorMarker" === e10.type) {
      if (false !== e10.scaleSymbolsProportionally && e10.frame) {
        const t8 = e10.frame.ymax - e10.frame.ymin;
        return e10.size / t8;
      }
    }
    return 1;
  }
};
var ee = class {
  static rasterizeSimpleFill(e10, t8, r17) {
    "solid" !== t8 && "none" !== t8 && "esriSFSSolid" !== t8 && "esriSFSNull" !== t8 || console.error("Unexpected: style does not require rasterization");
    const o10 = c3(Math.ceil(r17)), a10 = he(t8) ? 8 * o10 : 16 * o10, s10 = 2 * o10;
    e10.width = a10, e10.height = a10;
    const n16 = e10.getContext("2d");
    n16.strokeStyle = "#FFFFFF", n16.lineWidth = o10, n16.beginPath(), "vertical" !== t8 && "cross" !== t8 && "esriSFSCross" !== t8 && "esriSFSVertical" !== t8 || (n16.moveTo(a10 / 2, -s10), n16.lineTo(a10 / 2, a10 + s10)), "horizontal" !== t8 && "cross" !== t8 && "esriSFSCross" !== t8 && "esriSFSHorizontal" !== t8 || (n16.moveTo(-s10, a10 / 2), n16.lineTo(a10 + s10, a10 / 2)), "forward-diagonal" !== t8 && "diagonal-cross" !== t8 && "esriSFSDiagonalCross" !== t8 && "esriSFSForwardDiagonal" !== t8 || (n16.moveTo(-s10, -s10), n16.lineTo(a10 + s10, a10 + s10), n16.moveTo(a10 - s10, -s10), n16.lineTo(a10 + s10, s10), n16.moveTo(-s10, a10 - s10), n16.lineTo(s10, a10 + s10)), "backward-diagonal" !== t8 && "diagonal-cross" !== t8 && "esriSFSBackwardDiagonal" !== t8 && "esriSFSDiagonalCross" !== t8 || (n16.moveTo(a10 + s10, -s10), n16.lineTo(-s10, a10 + s10), n16.moveTo(s10, -s10), n16.lineTo(-s10, s10), n16.moveTo(a10 + s10, a10 - s10), n16.lineTo(a10 - s10, a10 + s10)), n16.stroke();
    const l8 = n16.getImageData(0, 0, e10.width, e10.height), c9 = new Uint8Array(l8.data);
    let m7;
    for (let i8 = 0; i8 < c9.length; i8 += 4)
      m7 = c9[i8 + 3] / 255, c9[i8] = c9[i8] * m7, c9[i8 + 1] = c9[i8 + 1] * m7, c9[i8 + 2] = c9[i8 + 2] * m7;
    return [c9, e10.width, e10.height];
  }
  static rasterizeSimpleLine(e10, t8) {
    return this.rasterizeDash(e10, t8);
  }
  static rasterizeDash(e10, t8) {
    const o10 = "Butt" === t8, a10 = "Square" === t8, i8 = !o10 && !a10;
    e10.length % 2 == 1 && (e10 = [...e10, ...e10]);
    const s10 = 15.5, n16 = 2 * s10;
    let l8 = 0;
    for (const r17 of e10)
      l8 += r17;
    const c9 = Math.round(l8 * s10), m7 = new Float32Array(c9 * n16), f7 = 0.5 * s10;
    let y5 = 0, h6 = 0, M3 = 0.5, p3 = true;
    for (const r17 of e10) {
      for (y5 = h6, h6 += r17 * s10; M3 <= h6; ) {
        let e11 = 0.5;
        for (; e11 < n16; ) {
          const t9 = (e11 - 0.5) * c9 + M3 - 0.5, r18 = i8 ? (e11 - s10) * (e11 - s10) : Math.abs(e11 - s10);
          m7[t9] = p3 ? o10 ? Math.max(Math.max(y5 + f7 - M3, r18), Math.max(M3 - h6 + f7, r18)) : r18 : i8 ? Math.min((M3 - y5) * (M3 - y5) + r18, (M3 - h6) * (M3 - h6) + r18) : a10 ? Math.min(Math.max(M3 - y5, r18), Math.max(h6 - M3, r18)) : Math.min(Math.max(M3 - y5 + f7, r18), Math.max(h6 + f7 - M3, r18)), e11++;
        }
        M3++;
      }
      p3 = !p3;
    }
    const u9 = m7.length, S = new Uint8Array(4 * u9);
    for (let d2 = 0; d2 < u9; ++d2) {
      const e11 = (i8 ? Math.sqrt(m7[d2]) : m7[d2]) / s10;
      o4(e11, S, 4 * d2);
    }
    return [S, c9, n16];
  }
};
var te = class {
  static findApplicableOverrides(e10, t8, r17) {
    if (e10 && t8) {
      if (e10.primitiveName) {
        let o10 = false;
        for (const t9 of r17)
          if (t9.primitiveName === e10.primitiveName) {
            o10 = true;
            break;
          }
        if (!o10)
          for (const a10 of t8)
            a10.primitiveName === e10.primitiveName && r17.push(a10);
      }
      switch (e10.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          if (e10.effects)
            for (const o10 of e10.effects)
              te.findApplicableOverrides(o10, t8, r17);
          if (e10.symbolLayers)
            for (const o10 of e10.symbolLayers)
              te.findApplicableOverrides(o10, t8, r17);
          break;
        case "CIMTextSymbol":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke":
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
        case "CIMVectorMarker":
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
          if (e10.effects)
            for (const o10 of e10.effects)
              te.findApplicableOverrides(o10, t8, r17);
          if (e10.markerPlacement && te.findApplicableOverrides(e10.markerPlacement, t8, r17), "CIMVectorMarker" === e10.type) {
            if (e10.markerGraphics)
              for (const o10 of e10.markerGraphics)
                te.findApplicableOverrides(o10, t8, r17), te.findApplicableOverrides(o10.symbol, t8, r17);
          } else
            "CIMCharacterMarker" === e10.type ? te.findApplicableOverrides(e10.symbol, t8, r17) : "CIMHatchFill" === e10.type ? te.findApplicableOverrides(e10.lineSymbol, t8, r17) : "CIMPictureMarker" === e10.type && te.findApplicableOverrides(e10.animatedSymbolProperties, t8, r17);
      }
    }
  }
  static findEffectOverrides(e10, t8, r17) {
    var _a;
    if (!t8 || !e10)
      return;
    const o10 = e10.length;
    for (let a10 = 0; a10 < o10; a10++) {
      const o11 = (_a = e10[a10]) == null ? void 0 : _a.primitiveName;
      if (o11) {
        let e11 = false;
        for (const t9 of r17)
          if (t9.primitiveName === o11) {
            e11 = true;
            break;
          }
        if (!e11)
          for (const a11 of t8)
            a11.primitiveName === o11 && r17.push(a11);
      }
    }
  }
  static applyOverrides(e10, t8, r17, o10) {
    if (!t8)
      return;
    const a10 = (e11) => e11 ? e11.charAt(0).toLowerCase() + e11.substr(1) : e11;
    if (e10.primitiveName) {
      for (const i8 of t8)
        if (i8.primitiveName === e10.primitiveName) {
          const t9 = a10(i8.propertyName);
          if (o10 && o10.push({ cim: e10, nocapPropertyName: t9, value: e10[t9] }), i8.expression && (i8.value = te.toValue(i8.propertyName, i8.expression)), r17) {
            let t10 = false;
            for (const o11 of r17)
              o11.primitiveName === e10.primitiveName && (t10 = true);
            t10 || r17.push(i8);
          }
          e10[t9] = i8.value;
        }
    }
    switch (e10.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        if (e10.effects)
          for (const a11 of e10.effects)
            te.applyOverrides(a11, t8, r17, o10);
        if (e10.symbolLayers)
          for (const a11 of e10.symbolLayers)
            te.applyOverrides(a11, t8, r17, o10);
        break;
      case "CIMTextSymbol":
        break;
      case "CIMSolidStroke":
      case "CIMSolidFill":
      case "CIMVectorMarker":
        if (e10.effects)
          for (const a11 of e10.effects)
            te.applyOverrides(a11, t8, r17, o10);
        if ("CIMVectorMarker" === e10.type && e10.markerGraphics)
          for (const a11 of e10.markerGraphics)
            te.applyOverrides(a11, t8, r17, o10), te.applyOverrides(a11.symbol, t8, r17, o10);
    }
  }
  static restoreOverrides(e10) {
    for (const t8 of e10)
      t8.cim[t8.nocapPropertyName] = t8.value;
  }
  static buildOverrideKey(e10) {
    let t8 = "";
    for (const r17 of e10)
      void 0 !== r17.value && (t8 += `${r17.primitiveName}${r17.propertyName}${JSON.stringify(r17.value)}`);
    return t8;
  }
  static toValue(t8, r17) {
    if ("DashTemplate" === t8)
      return r17.split(" ").map((e10) => Number(e10));
    if ("Color" === t8) {
      const t9 = new l2(r17).toRgba();
      return t9[3] *= 255, t9;
    }
    return r17;
  }
};
var re = (e10) => {
  if (!e10)
    return U2.Butt;
  switch (e10) {
    case "butt":
      return U2.Butt;
    case "square":
      return U2.Square;
    case "round":
      return U2.Round;
  }
};
var oe2 = (e10) => {
  if (!e10)
    return w.Miter;
  switch (e10) {
    case "miter":
      return w.Miter;
    case "round":
      return w.Round;
    case "bevel":
      return w.Bevel;
  }
};
var ae = (e10) => {
  if (t(e10))
    return "Center";
  switch (e10) {
    case "left":
      return "Left";
    case "right":
      return "Right";
    case "center":
      return "Center";
  }
};
var ie2 = (e10) => {
  if (t(e10))
    return "Center";
  switch (e10) {
    case "baseline":
      return "Baseline";
    case "top":
      return "Top";
    case "middle":
      return "Center";
    case "bottom":
      return "Bottom";
  }
};
var se = (e10) => {
  if (!e10)
    return [0, 0, 0, 0];
  const { r: t8, g: r17, b: o10, a: a10 } = e10;
  return [t8, r17, o10, 255 * a10];
};
var ne2 = (e10, t8) => {
  const r17 = le(t8), o10 = ce(e10);
  return r17 && o10 ? `${r17}-${o10}` : `${r17}${o10}`;
};
var le = (e10) => {
  if (!e10)
    return "";
  switch (e10.toLowerCase()) {
    case "bold":
    case "bolder":
      return "bold";
  }
  return "";
};
var ce = (e10) => {
  if (!e10)
    return "";
  switch (e10.toLowerCase()) {
    case "italic":
    case "oblique":
      return "italic";
  }
  return "";
};
var me = (e10, t8) => {
  const r17 = "butt" === t8;
  switch (e10) {
    case "dash":
    case "esriSLSDash":
      return r17 ? [4, 3] : [3, 4];
    case "dash-dot":
    case "esriSLSDashDot":
      return r17 ? [4, 3, 1, 3] : [3, 4, 0, 4];
    case "dot":
    case "esriSLSDot":
      return r17 ? [1, 3] : [0, 4];
    case "long-dash":
    case "esriSLSLongDash":
      return r17 ? [8, 3] : [7, 4];
    case "long-dash-dot":
    case "esriSLSLongDashDot":
      return r17 ? [8, 3, 1, 3] : [7, 4, 0, 4];
    case "long-dash-dot-dot":
    case "esriSLSDashDotDot":
      return r17 ? [8, 3, 1, 3, 1, 3] : [7, 4, 0, 4, 0, 4];
    case "short-dash":
    case "esriSLSShortDash":
      return r17 ? [4, 1] : [3, 2];
    case "short-dash-dot":
    case "esriSLSShortDashDot":
      return r17 ? [4, 1, 1, 1] : [3, 2, 0, 2];
    case "short-dash-dot-dot":
    case "esriSLSShortDashDotDot":
      return r17 ? [4, 1, 1, 1, 1, 1] : [3, 2, 0, 2, 0, 2];
    case "short-dot":
    case "esriSLSShortDot":
      return r17 ? [1, 1] : [0, 2];
    case "solid":
    case "esriSLSSolid":
    case "none":
      return Y2.error("Unexpected: style does not require rasterization"), [0, 0];
    default:
      return Y2.error(`Tried to rasterize SLS, but found an unexpected style: ${e10}!`), [0, 0];
  }
};
function fe(e10) {
  return void 0 !== e10.symbolLayers;
}
var ye = (e10) => {
  const t8 = 100, r17 = 50;
  let o10, a10;
  const i8 = e10;
  if ("circle" === i8 || "esriSMSCircle" === i8) {
    const e11 = 0.25;
    let t9 = Math.acos(1 - e11 / r17), i9 = Math.ceil(V / t9 / 4);
    0 === i9 && (i9 = 1), t9 = B4 / i9, i9 *= 4;
    const s10 = [];
    s10.push([r17, 0]);
    for (let o11 = 1; o11 < i9; o11++)
      s10.push([r17 * Math.cos(o11 * t9), -r17 * Math.sin(o11 * t9)]);
    s10.push([r17, 0]), o10 = { rings: [s10] }, a10 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  } else if ("cross" === i8 || "esriSMSCross" === i8) {
    const e11 = 0;
    o10 = { rings: [[[e11, r17], [e11, e11], [r17, e11], [r17, -e11], [e11, -e11], [e11, -r17], [-e11, -r17], [-e11, -e11], [-r17, -e11], [-r17, e11], [-e11, e11], [-e11, r17], [e11, r17]]] }, a10 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  } else if ("diamond" === i8 || "esriSMSDiamond" === i8)
    o10 = { rings: [[[-r17, 0], [0, r17], [r17, 0], [0, -r17], [-r17, 0]]] }, a10 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  else if ("square" === i8 || "esriSMSSquare" === i8)
    o10 = { rings: [[[-r17, -r17], [-r17, r17], [r17, r17], [r17, -r17], [-r17, -r17]]] }, a10 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  else if ("x" === i8 || "esriSMSX" === i8) {
    const e11 = 0;
    o10 = { rings: [[[0, e11], [r17 - e11, r17], [r17, r17 - e11], [e11, 0], [r17, e11 - r17], [r17 - e11, -r17], [0, -e11], [e11 - r17, -r17], [-r17, e11 - r17], [-e11, 0], [-r17, r17 - e11], [e11 - r17, r17], [0, e11]]] }, a10 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 };
  } else if ("triangle" === i8 || "esriSMSTriangle" === i8) {
    const e11 = t8 * 0.5773502691896257, r18 = -e11, i9 = 2 / 3 * t8, s10 = i9 - t8;
    o10 = { rings: [[[r18, s10], [0, i9], [e11, s10], [r18, s10]]] }, a10 = { xmin: r18, ymin: s10, xmax: e11, ymax: i9 };
  } else
    "arrow" === i8 && (o10 = { rings: [[[-50, 50], [50, 0], [-50, -50], [-33, -20], [-33, 20], [-50, 50]]] }, a10 = { xmin: -r17, ymin: -r17, xmax: r17, ymax: r17 });
  return [a10, o10];
};
var he = (e10) => "vertical" === e10 || "horizontal" === e10 || "cross" === e10 || "esriSFSCross" === e10 || "esriSFSVertical" === e10 || "esriSFSHorizontal" === e10;

export {
  n4 as n,
  a3 as a,
  x,
  A2 as A,
  g3 as g,
  j3 as j,
  r4 as r,
  s4 as s,
  t6 as t,
  s5 as s2,
  j4 as j2,
  q,
  Q,
  Z2 as Z,
  ee,
  te,
  me
};
//# sourceMappingURL=chunk-436X6OVY.js.map
