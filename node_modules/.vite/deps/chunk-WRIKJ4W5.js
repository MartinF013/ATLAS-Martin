import {
  t as t2
} from "./chunk-GZ6H7JK2.js";
import {
  c
} from "./chunk-DMGVDNFD.js";
import {
  e
} from "./chunk-4MKQUQD4.js";
import {
  o
} from "./chunk-A3QLZKCF.js";
import {
  e as e2
} from "./chunk-LGILR4HN.js";
import {
  i2 as i
} from "./chunk-I5UNY2WQ.js";
import {
  n,
  t
} from "./chunk-NAB3NF54.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  f
} from "./chunk-RTHP2LNT.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/BlendOptions.js
var t3;
var e3;
!function(t4) {
  t4[t4.OneMinusSourceAlpha = 0] = "OneMinusSourceAlpha", t4[t4.SourceAlpha = 1] = "SourceAlpha", t4[t4.COUNT = 2] = "COUNT";
}(t3 || (t3 = {})), function(t4) {
  t4[t4.Normal = 0] = "Normal", t4[t4.Average = 1] = "Average", t4[t4.Lighten = 2] = "Lighten", t4[t4.Lighter = 3] = "Lighter", t4[t4.Plus = 4] = "Plus", t4[t4.Screen = 5] = "Screen", t4[t4.ColorDodge = 6] = "ColorDodge", t4[t4.Darken = 7] = "Darken", t4[t4.Multiply = 8] = "Multiply", t4[t4.ColorBurn = 9] = "ColorBurn", t4[t4.Overlay = 10] = "Overlay", t4[t4.SoftLight = 11] = "SoftLight", t4[t4.HardLight = 12] = "HardLight", t4[t4.VividLight = 13] = "VividLight", t4[t4.Hue = 14] = "Hue", t4[t4.Saturation = 15] = "Saturation", t4[t4.Luminosity = 16] = "Luminosity", t4[t4.Color = 17] = "Color", t4[t4.DestinationOver = 18] = "DestinationOver", t4[t4.DestinationAtop = 19] = "DestinationAtop", t4[t4.DestinationIn = 20] = "DestinationIn", t4[t4.DestinationOut = 21] = "DestinationOut", t4[t4.SourceAtop = 22] = "SourceAtop", t4[t4.SourceIn = 23] = "SourceIn", t4[t4.SourceOut = 24] = "SourceOut", t4[t4.Xor = 25] = "Xor", t4[t4.Difference = 26] = "Difference", t4[t4.Exclusion = 27] = "Exclusion", t4[t4.Minus = 28] = "Minus", t4[t4.Invert = 29] = "Invert", t4[t4.Reflect = 30] = "Reflect", t4[t4.COUNT = 31] = "COUNT";
}(e3 || (e3 = {}));
var o2 = { normal: e3.Normal, average: e3.Average, lighten: e3.Lighten, lighter: e3.Lighter, screen: e3.Screen, plus: e3.Plus, "color-dodge": e3.ColorDodge, darken: e3.Darken, multiply: e3.Multiply, "color-burn": e3.ColorBurn, overlay: e3.Overlay, "soft-light": e3.SoftLight, "hard-light": e3.HardLight, "vivid-light": e3.VividLight, hue: e3.Hue, saturation: e3.Saturation, luminosity: e3.Luminosity, color: e3.Color, difference: e3.Difference, exclusion: e3.Exclusion, minus: e3.Minus, invert: e3.Invert, reflect: e3.Reflect, "destination-over": e3.DestinationOver, "destination-atop": e3.DestinationAtop, "destination-in": e3.DestinationIn, "destination-out": e3.DestinationOut, "source-atop": e3.SourceAtop, "source-in": e3.SourceIn, "source-out": e3.SourceOut, xor: e3.Xor };
function i2(t4) {
  return t4 === e3.DestinationOver || t4 === e3.DestinationAtop || t4 === e3.DestinationIn || t4 === e3.DestinationOut || t4 === e3.SourceAtop || t4 === e3.SourceIn || t4 === e3.SourceOut || t4 === e3.Xor;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TileComposite.glsl.js
var i3 = class extends t {
  constructor() {
    super(...arguments), this.scale = 1, this.offset = f;
  }
};
function d(s) {
  s.attributes.add(O.POSITION, "vec2"), s.attributes.add(O.UV0, "vec2"), s.vertex.uniforms.add(new o("scale", (s2) => s2.scale)), s.vertex.uniforms.add(new e2("offset", (s2) => s2.offset)), s.varyings.add("uv", "vec2"), s.varyings.add("vuv", "vec2"), s.vertex.code.add(n`void main(void) {
gl_Position = vec4(position, 0.0, 1.0);
uv = uv0 * scale + offset;
vuv = uv0;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/BlendModes.glsl.js
function l(l2, b) {
  const e4 = b.blendMode;
  e4 !== e3.Normal && (e4 === e3.Reflect && l2.code.add(n`float reflectBlend(in float cb, in float cl) {
return (cl == 1.0) ? cl : min(cb * cb / (1.0 - cl), 1.0);
}`), e4 !== e3.ColorDodge && e4 !== e3.VividLight || l2.code.add(n`float colorDodge(in float cb, in float cl) {
return (cb == 0.0) ? 0.0 : (cl == 1.0) ? 1.0 : min(1.0, cb / (1.0 - cl));
}`), e4 !== e3.ColorBurn && e4 !== e3.VividLight || l2.code.add(n`float colorBurn(in float cb, in float cl) {
return (cb == 1.0) ? 1.0 : (cl == 0.0) ? 0.0 : 1.0 - min(1.0, (1.0 - cb) / cl);
}`), e4 === e3.Overlay && l2.code.add(n`float overlay(in float cb, in float cl) {
return (1.0 - step(0.5, cl)) * (1.0 - 2.0 * (1.0 - cl ) * (1.0 - cb)) + step(0.5, cl) * (2.0 * cl * cb);
}`), e4 === e3.HardLight && l2.code.add(n`float hardLight(in float cb, in float cl) {
return (1.0 - step(0.5, cl)) * (2.0 * cl * cb) + step(0.5, cl) * (1.0 - 2.0 * (1.0 - cl) * (1.0 - cb));
}`), e4 === e3.SoftLight && l2.code.add(n`float softLight(in float cb, in float cl) {
if (cl <= 0.5) {
return cb - (1.0 - 2.0 * cl) * cb * (1.0 - cb);
}
if (cb <= 0.25) {
return cb + (2.0 * cl - 1.0) * cb * ((16.0 * cb - 12.0) * cb + 3.0);
}
return cb + (2.0 * cl - 1.0) * (sqrt(cb) - cb);
}`), e4 === e3.VividLight && l2.code.add(n`float vividLight(in float cb, in float cl) {
return (1.0 - step(0.5, cl)) * colorBurn(cb, 2.0 * cl) + step(0.5, cl) * colorDodge(cb, (2.0 * (cl - 0.5)));
}`), e4 !== e3.Hue && e4 !== e3.Saturation && e4 !== e3.Color && e4 !== e3.Luminosity || (l2.code.add(n`float minv3(in vec3 c) {
return min(min(c.r, c.g), c.b);
}
float maxv3(in vec3 c) {
return max(max(c.r, c.g), c.b);
}
float lumv3(in vec3 c) {
return dot(c, vec3(0.3, 0.59, 0.11));
}
vec3 clipColor(vec3 color) {
float lum = lumv3(color);
float mincol = minv3(color);
float maxcol = maxv3(color);
if (mincol < 0.0) {
color = lum + ((color - lum) * lum) / (lum - mincol);
}
if (maxcol > 1.0) {
color = lum + ((color - lum) * (1.0 - lum)) / (maxcol - lum);
}
return color;
}
vec3 setLum(vec3 cbase, vec3 clum) {
return clipColor(cbase + vec3(lumv3(clum) - lumv3(cbase)));
}`), e4 !== e3.Hue && e4 !== e3.Saturation || l2.code.add(n`float satv3(vec3 c) {
return maxv3(c) - minv3(c);
}
vec3 setLumSat(vec3 cbase, vec3 csat, vec3 clum)
{
float minbase = minv3(cbase);
float sbase = satv3(cbase);
float ssat = satv3(csat);
return setLum(sbase > 0.0 ? (cbase - minbase) * ssat / sbase : vec3(0.0), clum);
}`)), l2.code.add(n`
    vec4 applyBlendMode(vec3 cl, float ol, vec3 cb, float ob) {
      ${e4 === e3.Multiply ? n`return vec4(cl * ol * cb * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Average ? n`return vec4((cb + cl) * 0.5 * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Lighten ? n`return vec4(max(cb, cl) * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Darken ? n`return vec4(min(cl, cb) * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Lighter ? n`return vec4(cl * ol + cb * ob, ol + ob);` : e4 === e3.Plus ? n`return clamp(vec4(cl.rgb + cb.rgb, ol + ob), 0.0, 1.0);` : e4 === e3.Minus ? n`return vec4(clamp(vec3(cb.rgb - cl.rgb), 0.0, 1.0), ob * ol);` : e4 === e3.Screen ? n`return vec4((cl + cb - cl * cb) * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Difference ? n`return vec4(abs(cb - cl) * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Invert ? n`return vec4((1.0 - cb) * ol * ob + cb * ob * (1.0 - ol), ob);` : e4 === e3.DestinationOver ? n`return vec4(cl * ol * (1.0 - ob) + cb * ob, ol + ob - ol * ob);` : e4 === e3.DestinationAtop ? n`return vec4(cl * ol * (1.0 - ob) + cb * ob * ol, ol);` : e4 === e3.DestinationOut ? n`return vec4(cb * ob * (1.0 - ol), ob * (1.0 - ol));` : e4 === e3.SourceAtop ? n`return vec4(cl * ol * ob + cb * ob * (1.0 - ol), ob);` : e4 === e3.SourceOut ? n`return vec4(cl * ol * (1.0 - ob), ol * (1.0 - ob));` : e4 === e3.Xor ? n`return vec4(cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), ol * (1.0 - ob) + ob * (1.0 - ol));` : e4 === e3.DestinationIn ? n`return vec4(cb * ob * ol, ol * ob);` : e4 === e3.SourceIn ? n`return vec4(cl * ol * ob, ol * ob);` : e4 === e3.Hue ? n`
          vec3 f = setLumSat(cl, cb, cb);
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Saturation ? n`
          vec3 f = setLumSat(cb, cl, cb);
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Color ? n`
          vec3 f = setLum(cl, cb);
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Luminosity ? n`
          vec3 f = setLum(cb, cl);
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Exclusion ? n`
          vec3 f = cl + cb - 2.0 * cl * cb;
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Reflect ? n`
          vec3 f = vec3(reflectBlend(cb.r, cl.r), reflectBlend(cb.g, cl.g), reflectBlend(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.ColorDodge ? n`
          vec3 f = vec3(colorDodge(cb.r, cl.r), colorDodge(cb.g, cl.g), colorDodge(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.ColorBurn ? n`
          vec3 f = vec3(colorBurn(cb.r, cl.r), colorBurn(cb.g, cl.g), colorBurn(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.Overlay ? n`
          vec3 f = vec3(overlay(cb.r, cl.r), overlay(cb.g, cl.g), overlay(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.SoftLight ? n`
          vec3 f = vec3(softLight(cb.r, cl.r), softLight(cb.g, cl.g), softLight(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.HardLight ? n`
          vec3 f = vec3(hardLight(cb.r, cl.r), hardLight(cb.g, cl.g), hardLight(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : e4 === e3.VividLight ? n`
          vec3 f = vec3(vividLight(cb.r, cl.r), vividLight(cb.g, cl.g), vividLight(cb.b, cl.b));
          return vec4(f * ol * ob + cl * ol * (1.0 - ob) + cb * ob * (1.0 - ol), mix(ob, 1.0, ol));` : n``}
    }
  `));
}

// node_modules/@arcgis/core/chunks/BlendLayers.glsl.js
var c2;
var g;
function m(m2) {
  const u2 = new i(), p = m2.output === c2.GridOnly, b = m2.output === c2.GridComposite, f2 = b || p, y = m2.output === c2.ColorOnly, C = m2.output === c2.ColorComposite, O2 = C || y, v = b || C;
  if (u2.include(d), O2 && u2.fragment.uniforms.add(new e("backgroundColor", (e4) => e4.backgroundColor)), m2.baseOpacityMode !== g.One && u2.fragment.uniforms.add(new o("baseOpacity", (e4) => e4.baseOpacity)), f2 && (u2.extensions.add("GL_OES_standard_derivatives"), u2.fragment.include(t2)), p || y)
    return u2.fragment.code.add(n`
    void main() {
      gl_FragColor = ${y ? n`vec4(backgroundColor, 1.0)` : n`gridColor(uv)`};
    }
  `), u2;
  const w = m2.blendMode !== e3.Normal, x = m2.baseOpacityMode === g.OnBaseLayer, L = m2.baseOpacityMode === g.OnBackground || m2.baseOpacityMode === g.OnBaseLayer;
  return u2.fragment.uniforms.add(new c("tex", (e4) => e4.texture)), u2.fragment.uniforms.add(new o("opacity", (e4) => e4.opacity)), (w || x) && (u2.fragment.uniforms.add(new c("fboColor", (e4) => e4.fboTexture)), u2.fragment.uniforms.add(new o("tileSize", (o3) => r(o3.fboTexture) ? o3.fboTexture.descriptor.width : 1))), u2.fragment.include(l, m2), u2.fragment.code.add(n`
    void main() {
      ${v || x ? n`
      vec4 bgColor = ${x ? n`texture2D(fboColor, gl_FragCoord.xy / tileSize)` : C ? n`vec4(backgroundColor, 1.0)` : n`gridColor(uv)`};
      ${L ? n`bgColor *= baseOpacity;` : ""}` : ""}
      vec4 colorLayer = texture2D(tex, uv);
      ${w ? n`
          vec4 fboTex = ${v ? n`bgColor;` : n`texture2D(fboColor, gl_FragCoord.xy / tileSize) ${x ? " * baseOpacity" : ""};`}
          vec3 Cb = fboTex.a == 0.0 ? fboTex.rgb : vec3(fboTex.rgb * fboTex.a);
          gl_FragColor = applyBlendMode(colorLayer.rgb, colorLayer.a * opacity, Cb, fboTex.a);` : n`
          vec4 pmColorLayer = vec4(colorLayer.xyz, 1.0);
          float composeAlpha = colorLayer.a * opacity;
          gl_FragColor = ${v || x ? m2.premultipliedSource ? n`bgColor * (1.0 - composeAlpha) + colorLayer * opacity;` : n`mix(bgColor, pmColorLayer, composeAlpha);` : n`pmColorLayer * composeAlpha;`}`}
    }
  `), u2;
}
!function(e4) {
  e4[e4.Composite = 0] = "Composite", e4[e4.ColorOnly = 1] = "ColorOnly", e4[e4.GridOnly = 2] = "GridOnly", e4[e4.ColorComposite = 3] = "ColorComposite", e4[e4.GridComposite = 4] = "GridComposite", e4[e4.COUNT = 5] = "COUNT";
}(c2 || (c2 = {})), function(e4) {
  e4[e4.One = 0] = "One", e4[e4.OnBackground = 1] = "OnBackground", e4[e4.OnBaseLayer = 2] = "OnBaseLayer", e4[e4.COUNT = 3] = "COUNT";
}(g || (g = {}));
var u = Object.freeze(Object.defineProperty({ __proto__: null, get BlendLayersOutput() {
  return c2;
}, get BaseOpacityMode() {
  return g;
}, build: m }, Symbol.toStringTag, { value: "Module" }));

export {
  e3 as e,
  o2 as o,
  i2 as i,
  i3 as i2,
  d,
  l,
  c2 as c,
  g,
  m,
  u
};
//# sourceMappingURL=chunk-WRIKJ4W5.js.map
