import {
  l
} from "./chunk-EYJ2F5XB.js";
import {
  c as c3,
  e as e2,
  r as r3,
  u as u3
} from "./chunk-5WOO2FX6.js";
import {
  C,
  D,
  E as E2,
  L as L2
} from "./chunk-FPMD6IB4.js";
import {
  e as e5
} from "./chunk-MOZ4GR2L.js";
import {
  A,
  B,
  E,
  F,
  L,
  O,
  V,
  c as c2,
  d,
  g as g2,
  i as i3,
  q,
  u as u2,
  w as w2,
  x
} from "./chunk-MQBVOUKB.js";
import {
  x as x2
} from "./chunk-DLM6NKXW.js";
import {
  e as e4
} from "./chunk-TQLSOIYV.js";
import {
  e as e3,
  r as r4
} from "./chunk-YFBAFAZ2.js";
import {
  r as r5
} from "./chunk-D7AOY7GH.js";
import {
  a
} from "./chunk-QKRZMDWG.js";
import {
  c,
  f as f2,
  g,
  i as i2,
  u
} from "./chunk-ASC3X65B.js";
import {
  n
} from "./chunk-P6G64ARX.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  Q,
  X,
  Y,
  nt
} from "./chunk-5N3FSR63.js";
import {
  f,
  w
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  r as r2
} from "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  e2 as e,
  i3 as i,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/chunks/vec42.js
function t2(t11, r10, f8) {
  if (t11.count !== r10.count)
    return void e5.error("source and destination buffers need to have the same number of elements");
  const o6 = t11.count, n7 = f8[0], u6 = f8[1], d4 = f8[2], s4 = f8[3], c7 = f8[4], i6 = f8[5], a3 = f8[6], p2 = f8[7], y = f8[8], B2 = f8[9], m2 = f8[10], l4 = f8[11], S = f8[12], h2 = f8[13], b = f8[14], M2 = f8[15], v = t11.typedBuffer, g3 = t11.typedBufferStride, _ = r10.typedBuffer, j = r10.typedBufferStride;
  for (let e10 = 0; e10 < o6; e10++) {
    const t12 = e10 * g3, r11 = e10 * j, f9 = _[r11], o7 = _[r11 + 1], z2 = _[r11 + 2], O2 = _[r11 + 3];
    v[t12] = n7 * f9 + c7 * o7 + y * z2 + S * O2, v[t12 + 1] = u6 * f9 + i6 * o7 + B2 * z2 + h2 * O2, v[t12 + 2] = d4 * f9 + a3 * o7 + m2 * z2 + b * O2, v[t12 + 3] = s4 * f9 + p2 * o7 + l4 * z2 + M2 * O2;
  }
}
function r6(t11, r10, f8) {
  if (t11.count !== r10.count)
    return void e5.error("source and destination buffers need to have the same number of elements");
  const o6 = t11.count, n7 = f8[0], u6 = f8[1], d4 = f8[2], s4 = f8[3], c7 = f8[4], i6 = f8[5], a3 = f8[6], p2 = f8[7], y = f8[8], B2 = t11.typedBuffer, m2 = t11.typedBufferStride, l4 = r10.typedBuffer, S = r10.typedBufferStride;
  for (let e10 = 0; e10 < o6; e10++) {
    const t12 = e10 * m2, r11 = e10 * S, f9 = l4[r11], o7 = l4[r11 + 1], h2 = l4[r11 + 2], b = l4[r11 + 3];
    B2[t12] = n7 * f9 + s4 * o7 + a3 * h2, B2[t12 + 1] = u6 * f9 + c7 * o7 + p2 * h2, B2[t12 + 2] = d4 * f9 + i6 * o7 + y * h2, B2[t12 + 3] = b;
  }
}
function f3(e10, t11) {
  const r10 = Math.min(e10.count, t11.count), f8 = e10.typedBuffer, o6 = e10.typedBufferStride, n7 = t11.typedBuffer, u6 = t11.typedBufferStride;
  for (let d4 = 0; d4 < r10; d4++) {
    const e11 = d4 * o6, t12 = d4 * u6, r11 = n7[t12], s4 = n7[t12 + 1], c7 = n7[t12 + 2], i6 = r11 * r11 + s4 * s4 + c7 * c7;
    if (i6 > 0) {
      const t13 = 1 / Math.sqrt(i6);
      f8[e11] = t13 * r11, f8[e11 + 1] = t13 * s4, f8[e11 + 2] = t13 * c7;
    }
  }
}
function o(e10, t11, r10) {
  const f8 = Math.min(e10.count, t11.count), o6 = e10.typedBuffer, n7 = e10.typedBufferStride, u6 = t11.typedBuffer, d4 = t11.typedBufferStride;
  for (let s4 = 0; s4 < f8; s4++) {
    const e11 = s4 * n7, t12 = s4 * d4;
    o6[e11] = r10 * u6[t12], o6[e11 + 1] = r10 * u6[t12 + 1], o6[e11 + 2] = r10 * u6[t12 + 2], o6[e11 + 3] = r10 * u6[t12 + 3];
  }
}
function n2(e10, t11, r10) {
  const f8 = Math.min(e10.count, t11.count), o6 = e10.typedBuffer, n7 = e10.typedBufferStride, u6 = t11.typedBuffer, d4 = t11.typedBufferStride;
  for (let s4 = 0; s4 < f8; s4++) {
    const e11 = s4 * n7, t12 = s4 * d4;
    o6[e11] = u6[t12] >> r10, o6[e11 + 1] = u6[t12 + 1] >> r10, o6[e11 + 2] = u6[t12 + 2] >> r10, o6[e11 + 3] = u6[t12 + 3] >> r10;
  }
}
var u4 = Object.freeze(Object.defineProperty({ __proto__: null, transformMat4: t2, transformMat3: r6, normalize: f3, scale: o, shiftRight: n2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec22.js
function f4(e10, t11, r10) {
  const f8 = e10.typedBuffer, n7 = e10.typedBufferStride, d4 = t11.typedBuffer, o6 = t11.typedBufferStride, u6 = r10 ? r10.count : t11.count;
  let s4 = (r10 && r10.dstIndex ? r10.dstIndex : 0) * n7, c7 = (r10 && r10.srcIndex ? r10.srcIndex : 0) * o6;
  for (let p2 = 0; p2 < u6; ++p2)
    f8[s4] = d4[c7], f8[s4 + 1] = d4[c7 + 1], s4 += n7, c7 += o6;
}
function n3(n7, d4, o6) {
  const u6 = n7.typedBuffer, s4 = n7.typedBufferStride, c7 = d4.typedBuffer, p2 = d4.typedBufferStride, l4 = o6 ? o6.count : d4.count;
  let y = (o6 && o6.dstIndex ? o6.dstIndex : 0) * s4, i6 = (o6 && o6.srcIndex ? o6.srcIndex : 0) * p2;
  if (c3(d4.elementType)) {
    const e10 = u3(d4.elementType);
    if (r3(d4.elementType))
      for (let t11 = 0; t11 < l4; ++t11)
        u6[y] = Math.max(c7[i6] / e10, -1), u6[y + 1] = Math.max(c7[i6 + 1] / e10, -1), y += s4, i6 += p2;
    else
      for (let t11 = 0; t11 < l4; ++t11)
        u6[y] = c7[i6] / e10, u6[y + 1] = c7[i6 + 1] / e10, y += s4, i6 += p2;
  } else
    f4(n7, d4, o6);
  return n7;
}
function d2(e10, t11, r10, f8) {
  const n7 = e10.typedBuffer, d4 = e10.typedBufferStride, o6 = (f8 == null ? void 0 : f8.count) ?? e10.count;
  let u6 = ((f8 == null ? void 0 : f8.dstIndex) ?? 0) * d4;
  for (let s4 = 0; s4 < o6; ++s4)
    n7[u6] = t11, n7[u6 + 1] = r10, u6 += d4;
}
var o2 = Object.freeze(Object.defineProperty({ __proto__: null, copy: f4, normalizeIntegerBuffer: n3, fill: d2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec43.js
function e6(e10, t11, f8) {
  const d4 = e10.typedBuffer, n7 = e10.typedBufferStride, o6 = t11.typedBuffer, r10 = t11.typedBufferStride, c7 = f8 ? f8.count : t11.count;
  let u6 = (f8 && f8.dstIndex ? f8.dstIndex : 0) * n7, l4 = (f8 && f8.srcIndex ? f8.srcIndex : 0) * r10;
  for (let s4 = 0; s4 < c7; ++s4)
    d4[u6] = o6[l4], d4[u6 + 1] = o6[l4 + 1], d4[u6 + 2] = o6[l4 + 2], d4[u6 + 3] = o6[l4 + 3], u6 += n7, l4 += r10;
}
function t3(e10, t11, f8, d4, n7, o6) {
  const r10 = e10.typedBuffer, c7 = e10.typedBufferStride, u6 = (o6 == null ? void 0 : o6.count) ?? e10.count;
  let l4 = ((o6 == null ? void 0 : o6.dstIndex) ?? 0) * c7;
  for (let s4 = 0; s4 < u6; ++s4)
    r10[l4] = t11, r10[l4 + 1] = f8, r10[l4 + 2] = d4, r10[l4 + 3] = n7, l4 += c7;
}
var f5 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e6, fill: t3 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat32.js
function e7(e10, t11, r10) {
  const o6 = e10.typedBuffer, d4 = e10.typedBufferStride, f8 = t11.typedBuffer, n7 = t11.typedBufferStride, c7 = r10 ? r10.count : t11.count;
  let u6 = (r10 && r10.dstIndex ? r10.dstIndex : 0) * d4, l4 = (r10 && r10.srcIndex ? r10.srcIndex : 0) * n7;
  for (let p2 = 0; p2 < c7; ++p2) {
    for (let e11 = 0; e11 < 9; ++e11)
      o6[u6 + e11] = f8[l4 + e11];
    u6 += d4, l4 += n7;
  }
}
var t4 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e7 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat42.js
function e8(e10, t11, r10) {
  const o6 = e10.typedBuffer, d4 = e10.typedBufferStride, f8 = t11.typedBuffer, n7 = t11.typedBufferStride, c7 = r10 ? r10.count : t11.count;
  let u6 = (r10 && r10.dstIndex ? r10.dstIndex : 0) * d4, l4 = (r10 && r10.srcIndex ? r10.srcIndex : 0) * n7;
  for (let p2 = 0; p2 < c7; ++p2) {
    for (let e11 = 0; e11 < 16; ++e11)
      o6[u6 + e11] = f8[l4 + e11];
    u6 += d4, l4 += n7;
  }
}
var t5 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e8 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/scalar.js
function e9(e10, t11, r10) {
  const n7 = e10.typedBuffer, o6 = e10.typedBufferStride, c7 = t11.typedBuffer, d4 = t11.typedBufferStride, f8 = r10 ? r10.count : t11.count;
  let u6 = (r10 && r10.dstIndex ? r10.dstIndex : 0) * o6, s4 = (r10 && r10.srcIndex ? r10.srcIndex : 0) * d4;
  for (let p2 = 0; p2 < f8; ++p2)
    n7[u6] = c7[s4], u6 += o6, s4 += d4;
}
function t6(e10, t11) {
  const r10 = e10.count;
  t11 || (t11 = new e10.TypedArrayConstructor(r10));
  for (let n7 = 0; n7 < r10; n7++)
    t11[n7] = e10.get(n7);
  return t11;
}
var r7 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e9, makeDense: t6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/geometry/support/buffer/utils.js
function r8(s4, r10) {
  return new s4(new ArrayBuffer(r10 * s4.ElementCount * e2(s4.ElementType)));
}

// node_modules/@arcgis/core/views/3d/glTF/DefaultLoadingContext.js
var n4 = class {
  constructor(r10) {
    this.streamDataRequester = r10;
  }
  async loadJSON(r10, e10) {
    return this._load("json", r10, e10);
  }
  async loadBinary(r10, e10) {
    return X(r10) ? (f(e10), Y(r10)) : this._load("binary", r10, e10);
  }
  async loadImage(r10, e10) {
    return this._load("image", r10, e10);
  }
  async _load(t11, i6, m2) {
    if (t(this.streamDataRequester))
      return (await U(i6, { responseType: c4[t11] })).data;
    const n7 = await a(this.streamDataRequester.request(i6, t11, m2));
    if (true === n7.ok)
      return n7.value;
    throw w(n7.error), new s2("", `Request for resource failed: ${n7.error}`);
  }
};
var c4 = { image: "image", binary: "array-buffer", json: "json" };

// node_modules/@arcgis/core/views/3d/glTF/DefaultErrorContext.js
var o3 = s.getLogger("esri.views.3d.glTF");
var t7 = class {
  error(e10) {
    throw new s2("gltf-loader-error", e10);
  }
  errorUnsupported(e10) {
    throw new s2("gltf-loader-unsupported-feature", e10);
  }
  errorUnsupportedIf(r10, e10) {
    r10 && this.errorUnsupported(e10);
  }
  assert(r10, e10) {
    r10 || this.error(e10);
  }
  warn(r10) {
    o3.warn(r10);
  }
  warnUnsupported(r10) {
    this.warn("[Unsupported Feature] " + r10);
  }
  warnUnsupportedIf(r10, e10) {
    r10 && this.warnUnsupported(e10);
  }
};

// node_modules/@arcgis/core/views/3d/glTF/LoaderResult.js
function t8(e10 = {}) {
  return { color: [1, 1, 1], opacity: 1, alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false, castShadows: true, receiveShadows: true, receiveAmbientOcclustion: true, textureColor: null, textureNormal: null, textureOcclusion: null, textureEmissive: null, textureMetallicRoughness: null, emissiveFactor: [0, 0, 0], metallicFactor: 1, roughnessFactor: 1, colorMixMode: "multiply", ...e10 };
}
function l2(t11, l4 = {}) {
  return { data: t11, parameters: { wrap: { s: D.REPEAT, t: D.REPEAT, ...l4.wrap }, noUnpackFlip: true, mipmap: false, ...l4 } };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/BinaryStreamReader.js
var t9 = class {
  constructor(t11) {
    this.data = t11, this.offset4 = 0, this.dataUint32 = new Uint32Array(this.data, 0, Math.floor(this.data.byteLength / 4));
  }
  readUint32() {
    const t11 = this.offset4;
    return this.offset4 += 1, this.dataUint32[t11];
  }
  readUint8Array(t11) {
    const s4 = 4 * this.offset4;
    return this.offset4 += t11 / 4, new Uint8Array(this.data, s4, t11);
  }
  remainingBytes() {
    return this.data.byteLength - 4 * this.offset4;
  }
};

// node_modules/@arcgis/core/views/3d/glTF/internal/enums.js
var A2;
var E3;
!function(A3) {
  A3.SCALAR = "SCALAR", A3.VEC2 = "VEC2", A3.VEC3 = "VEC3", A3.VEC4 = "VEC4", A3.MAT2 = "MAT2", A3.MAT3 = "MAT3", A3.MAT4 = "MAT4";
}(A2 || (A2 = {})), function(A3) {
  A3[A3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", A3[A3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(E3 || (E3 = {}));

// node_modules/@arcgis/core/views/3d/glTF/internal/fillDefaults.js
var t10 = { baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1 };
var a2 = { pbrMetallicRoughness: t10, emissiveFactor: [0, 0, 0], alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false };
var l3 = { ESRI_externalColorMixMode: "tint" };
var i4 = (e10 = {}) => {
  const o6 = { ...t10, ...e10.pbrMetallicRoughness }, r10 = s3({ ...l3, ...e10.extras });
  return { ...a2, ...e10, pbrMetallicRoughness: o6, extras: r10 };
};
function s3(o6) {
  switch (o6.ESRI_externalColorMixMode) {
    case "multiply":
    case "tint":
    case "ignore":
    case "replace":
      break;
    default:
      n(o6.ESRI_externalColorMixMode), o6.ESRI_externalColorMixMode = "tint";
  }
  return o6;
}
var n5 = { magFilter: L2.LINEAR, minFilter: L2.LINEAR_MIPMAP_LINEAR, wrapS: D.REPEAT, wrapT: D.REPEAT };
var c5 = (e10) => ({ ...n5, ...e10 });

// node_modules/@arcgis/core/views/3d/glTF/internal/pathUtils.js
function r9(r10) {
  let e10, t11;
  return r10.replace(/^(.*\/)?([^/]*)$/, (r11, a3, i6) => (e10 = a3 || "", t11 = i6 || "", "")), { dirPart: e10, filePart: t11 };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/Resource.js
var M = { MAGIC: 1179937895, CHUNK_TYPE_JSON: 1313821514, CHUNK_TYPE_BIN: 5130562, MIN_HEADER_LENGTH: 20 };
var F2 = class {
  constructor(e10, t11, r10, s4, n7) {
    this.context = e10, this.errorContext = t11, this.uri = r10, this.json = s4, this.glbBuffer = n7, this.bufferLoaders = /* @__PURE__ */ new Map(), this.textureLoaders = /* @__PURE__ */ new Map(), this.textureCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map(), this.nodeParentMap = /* @__PURE__ */ new Map(), this.nodeTransformCache = /* @__PURE__ */ new Map(), this.baseUri = r9(this.uri).dirPart, this._checkVersionSupported(), this._checkRequiredExtensionsSupported(), t11.errorUnsupportedIf(null == s4.scenes, "Scenes must be defined."), t11.errorUnsupportedIf(null == s4.meshes, "Meshes must be defined"), t11.errorUnsupportedIf(null == s4.nodes, "Nodes must be defined."), this._computeNodeParents();
  }
  static async load(e10, t11, o6, a3) {
    if (X(o6)) {
      const r10 = nt(o6);
      if ("model/gltf-binary" !== r10.mediaType)
        try {
          const s4 = JSON.parse(r10.isBase64 ? atob(r10.data) : r10.data);
          return new F2(e10, t11, o6, s4);
        } catch {
        }
      const a4 = Y(o6);
      if (F2._isGLBData(a4))
        return this._fromGLBData(e10, t11, o6, a4);
    }
    if (o6.endsWith(".gltf")) {
      const r10 = await e10.loadJSON(o6, a3);
      return new F2(e10, t11, o6, r10);
    }
    const i6 = await e10.loadBinary(o6, a3);
    if (F2._isGLBData(i6))
      return this._fromGLBData(e10, t11, o6, i6);
    const u6 = await e10.loadJSON(o6, a3);
    return new F2(e10, t11, o6, u6);
  }
  static _isGLBData(e10) {
    const t11 = new t9(e10);
    return t11.remainingBytes() >= 4 && t11.readUint32() === M.MAGIC;
  }
  static async _fromGLBData(e10, t11, r10, s4) {
    const n7 = await F2._parseGLBData(t11, s4);
    return new F2(e10, t11, r10, n7.json, n7.binaryData);
  }
  static async _parseGLBData(e10, t11) {
    const r10 = new t9(t11);
    e10.assert(r10.remainingBytes() >= 12, "GLB binary data is insufficiently large.");
    const s4 = r10.readUint32(), n7 = r10.readUint32(), o6 = r10.readUint32();
    e10.assert(s4 === M.MAGIC, "Magic first 4 bytes do not fit to expected GLB value."), e10.assert(t11.byteLength >= o6, "GLB binary data is smaller than header specifies."), e10.errorUnsupportedIf(2 !== n7, "An unsupported GLB container version was detected. Only version 2 is supported.");
    let a3, i6, u6 = 0;
    for (; r10.remainingBytes() >= 8; ) {
      const t12 = r10.readUint32(), s5 = r10.readUint32();
      0 === u6 ? (e10.assert(s5 === M.CHUNK_TYPE_JSON, "First GLB chunk must be JSON."), e10.assert(t12 >= 0, "No JSON data found."), a3 = await q2(r10.readUint8Array(t12))) : 1 === u6 ? (e10.errorUnsupportedIf(s5 !== M.CHUNK_TYPE_BIN, "Second GLB chunk expected to be BIN."), i6 = r10.readUint8Array(t12)) : e10.warnUnsupported("More than 2 GLB chunks detected. Skipping."), u6 += 1;
    }
    return a3 || e10.error("No GLB JSON chunk detected."), { json: a3, binaryData: i6 };
  }
  async getBuffer(e10, t11) {
    const r10 = this.json.buffers[e10], s4 = this.errorContext;
    if (null == r10.uri)
      return s4.assert(null != this.glbBuffer, "GLB buffer not present"), this.glbBuffer;
    const n7 = await this._getBufferLoader(e10, t11);
    return s4.assert(n7.byteLength === r10.byteLength, "Buffer byte lengths should match."), n7;
  }
  async _getBufferLoader(e10, t11) {
    const r10 = this.bufferLoaders.get(e10);
    if (r10)
      return r10;
    const s4 = this.json.buffers[e10], n7 = this.context.loadBinary(this._resolveUri(s4.uri), t11).then((e11) => new Uint8Array(e11));
    return this.bufferLoaders.set(e10, n7), n7;
  }
  async getAccessor(e10, t11) {
    const r10 = this.errorContext;
    r10.errorUnsupportedIf(!this.json.accessors, "Accessors missing.");
    const s4 = this.json.accessors[e10];
    r10.errorUnsupportedIf(null == (s4 == null ? void 0 : s4.bufferView), "Some accessor does not specify a bufferView."), r10.errorUnsupportedIf(s4.type in [A2.MAT2, A2.MAT3, A2.MAT4], `AttributeType ${s4.type} is not supported`);
    const n7 = this.json.bufferViews[s4.bufferView], o6 = await this.getBuffer(n7.buffer, t11), a3 = H[s4.type], i6 = Y2[s4.componentType], u6 = a3 * i6, c7 = n7.byteStride || u6;
    return { raw: o6.buffer, byteStride: c7, byteOffset: o6.byteOffset + (n7.byteOffset || 0) + (s4.byteOffset || 0), entryCount: s4.count, isDenselyPacked: c7 === u6, componentCount: a3, componentByteSize: i6, componentType: s4.componentType, min: s4.min, max: s4.max, normalized: !!s4.normalized };
  }
  async getIndexData(e10, t11) {
    if (null == e10.indices)
      return null;
    const r10 = await this.getAccessor(e10.indices, t11);
    if (r10.isDenselyPacked)
      switch (r10.componentType) {
        case C.UNSIGNED_BYTE:
          return new Uint8Array(r10.raw, r10.byteOffset, r10.entryCount);
        case C.UNSIGNED_SHORT:
          return new Uint16Array(r10.raw, r10.byteOffset, r10.entryCount);
        case C.UNSIGNED_INT:
          return new Uint32Array(r10.raw, r10.byteOffset, r10.entryCount);
      }
    else
      switch (r10.componentType) {
        case C.UNSIGNED_BYTE:
          return t6(this._wrapAccessor(d, r10));
        case C.UNSIGNED_SHORT:
          return t6(this._wrapAccessor(g2, r10));
        case C.UNSIGNED_INT:
          return t6(this._wrapAccessor(B, r10));
      }
  }
  async getPositionData(e10, t11) {
    const r10 = this.errorContext;
    r10.errorUnsupportedIf(null == e10.attributes.POSITION, "No POSITION vertex data found.");
    const s4 = await this.getAccessor(e10.attributes.POSITION, t11);
    return r10.errorUnsupportedIf(s4.componentType !== C.FLOAT, "Expected type FLOAT for POSITION vertex attribute, but found " + X2[s4.componentType]), r10.errorUnsupportedIf(3 !== s4.componentCount, "POSITION vertex attribute must have 3 components, but found " + s4.componentCount.toFixed()), this._wrapAccessor(i3, s4);
  }
  async getNormalData(e10, t11) {
    const r10 = this.errorContext;
    r10.assert(null != e10.attributes.NORMAL, "No NORMAL vertex data found.");
    const s4 = await this.getAccessor(e10.attributes.NORMAL, t11);
    return r10.errorUnsupportedIf(s4.componentType !== C.FLOAT, "Expected type FLOAT for NORMAL vertex attribute, but found " + X2[s4.componentType]), r10.errorUnsupportedIf(3 !== s4.componentCount, "NORMAL vertex attribute must have 3 components, but found " + s4.componentCount.toFixed()), this._wrapAccessor(i3, s4);
  }
  async getTangentData(e10, t11) {
    const r10 = this.errorContext;
    r10.assert(null != e10.attributes.TANGENT, "No TANGENT vertex data found.");
    const s4 = await this.getAccessor(e10.attributes.TANGENT, t11);
    return r10.errorUnsupportedIf(s4.componentType !== C.FLOAT, "Expected type FLOAT for TANGENT vertex attribute, but found " + X2[s4.componentType]), r10.errorUnsupportedIf(4 !== s4.componentCount, "TANGENT vertex attribute must have 4 components, but found " + s4.componentCount.toFixed()), new c2(s4.raw, s4.byteOffset, s4.byteStride, s4.byteOffset + s4.byteStride * s4.entryCount);
  }
  async getTextureCoordinates(e10, t11) {
    const r10 = this.errorContext;
    r10.assert(null != e10.attributes.TEXCOORD_0, "No TEXCOORD_0 vertex data found.");
    const s4 = await this.getAccessor(e10.attributes.TEXCOORD_0, t11);
    return r10.errorUnsupportedIf(2 !== s4.componentCount, "TEXCOORD_0 vertex attribute must have 2 components, but found " + s4.componentCount.toFixed()), s4.componentType === C.FLOAT ? this._wrapAccessor(u2, s4) : (r10.errorUnsupportedIf(!s4.normalized, "Integer component types are only supported for a normalized accessor for TEXCOORD_0."), J(s4));
  }
  async getVertexColors(e10, t11) {
    const r10 = this.errorContext;
    r10.assert(null != e10.attributes.COLOR_0, "No COLOR_0 vertex data found.");
    const s4 = await this.getAccessor(e10.attributes.COLOR_0, t11);
    if (r10.errorUnsupportedIf(4 !== s4.componentCount && 3 !== s4.componentCount, "COLOR_0 attribute must have 3 or 4 components, but found " + s4.componentCount.toFixed()), 4 === s4.componentCount) {
      if (s4.componentType === C.FLOAT)
        return this._wrapAccessor(c2, s4);
      if (s4.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(x, s4);
      if (s4.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(L, s4);
    } else if (3 === s4.componentCount) {
      if (s4.componentType === C.FLOAT)
        return this._wrapAccessor(i3, s4);
      if (s4.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(O, s4);
      if (s4.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(E, s4);
    }
    r10.errorUnsupported("Unsupported component type for COLOR_0 attribute: " + X2[s4.componentType]);
  }
  hasPositions(e10) {
    return void 0 !== e10.attributes.POSITION;
  }
  hasNormals(e10) {
    return void 0 !== e10.attributes.NORMAL;
  }
  hasVertexColors(e10) {
    return void 0 !== e10.attributes.COLOR_0;
  }
  hasTextureCoordinates(e10) {
    return void 0 !== e10.attributes.TEXCOORD_0;
  }
  hasTangents(e10) {
    return void 0 !== e10.attributes.TANGENT;
  }
  async getMaterial(e10, t11, r10) {
    let s4 = this.materialCache.get(e10.material);
    if (!s4) {
      const n7 = null != e10.material ? i4(this.json.materials[e10.material]) : i4(), o6 = n7.pbrMetallicRoughness, a3 = this.hasVertexColors(e10), i6 = this.getTexture(o6.baseColorTexture, t11), u6 = this.getTexture(n7.normalTexture, t11), c7 = r10 ? this.getTexture(n7.occlusionTexture, t11) : null, p2 = r10 ? this.getTexture(n7.emissiveTexture, t11) : null, f8 = r10 ? this.getTexture(o6.metallicRoughnessTexture, t11) : null, d4 = null != e10.material ? e10.material : -1;
      s4 = { alphaMode: n7.alphaMode, alphaCutoff: n7.alphaCutoff, color: o6.baseColorFactor, doubleSided: !!n7.doubleSided, colorTexture: await i6, normalTexture: await u6, name: n7.name, id: d4, occlusionTexture: await c7, emissiveTexture: await p2, emissiveFactor: n7.emissiveFactor, metallicFactor: o6.metallicFactor, roughnessFactor: o6.roughnessFactor, metallicRoughnessTexture: await f8, hasVertexColors: a3, ESRI_externalColorMixMode: n7.extras.ESRI_externalColorMixMode };
    }
    return s4;
  }
  async getTexture(e10, r10) {
    if (!e10)
      return null;
    this.errorContext.errorUnsupportedIf(0 !== (e10.texCoord || 0), "Only TEXCOORD with index 0 is supported.");
    const s4 = e10.index, n7 = this.errorContext, o6 = this.json.textures[s4], a3 = c5(null != o6.sampler ? this.json.samplers[o6.sampler] : {});
    n7.errorUnsupportedIf(null == o6.source, "Source is expected to be defined for a texture.");
    const i6 = this.json.images[o6.source], u6 = await this._loadTextureImageData(s4, o6, r10);
    return r2(this.textureCache, s4, () => {
      const e11 = (e12) => 33071 === e12 || 33648 === e12 || 10497 === e12, t11 = (e12) => (n7.error(`Unexpected TextureSampler WrapMode: ${e12}. Using default REPEAT(10497).`), 10497);
      return { data: u6, wrapS: e11(a3.wrapS) ? a3.wrapS : t11(a3.wrapS), wrapT: e11(a3.wrapT) ? a3.wrapT : t11(a3.wrapT), minFilter: a3.minFilter, name: i6.name, id: s4 };
    });
  }
  getNodeTransform(e10) {
    if (void 0 === e10)
      return V2;
    let t11 = this.nodeTransformCache.get(e10);
    if (!t11) {
      const r10 = this.getNodeTransform(this._getNodeParent(e10)), s4 = this.json.nodes[e10];
      s4.matrix ? t11 = u(e3(), r10, s4.matrix) : s4.translation || s4.rotation || s4.scale ? (t11 = r4(r10), s4.translation && c(t11, t11, s4.translation), s4.rotation && (k[3] = x2(k, s4.rotation), f2(t11, t11, k[3], k)), s4.scale && i2(t11, t11, s4.scale)) : t11 = r10, this.nodeTransformCache.set(e10, t11);
    }
    return t11;
  }
  _wrapAccessor(e10, t11) {
    return new e10(t11.raw, t11.byteOffset, t11.byteStride, t11.byteOffset + t11.byteStride * (t11.entryCount - 1) + t11.componentByteSize * t11.componentCount);
  }
  _resolveUri(e10) {
    return Q(e10, this.baseUri);
  }
  _getNodeParent(e10) {
    return this.nodeParentMap.get(e10);
  }
  _checkVersionSupported() {
    const e10 = r5.parse(this.json.asset.version, "glTF");
    P.validate(e10);
  }
  _checkRequiredExtensionsSupported() {
    const e10 = this.json, t11 = this.errorContext;
    e10.extensionsRequired && 0 !== e10.extensionsRequired.length && t11.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: " + e10.extensionsRequired.join(", "));
  }
  _computeNodeParents() {
    this.json.nodes.forEach((e10, t11) => {
      e10.children && e10.children.forEach((e11) => {
        this.nodeParentMap.set(e11, t11);
      });
    });
  }
  async _loadTextureImageData(e10, t11, r10) {
    const s4 = this.textureLoaders.get(e10);
    if (s4)
      return s4;
    const n7 = this._createTextureLoader(t11, r10);
    return this.textureLoaders.set(e10, n7), n7;
  }
  async _createTextureLoader(e10, t11) {
    const r10 = this.json.images[e10.source];
    if (r10.uri)
      return this.context.loadImage(this._resolveUri(r10.uri), t11);
    const s4 = this.errorContext;
    s4.errorUnsupportedIf(null == r10.bufferView, "Image bufferView must be defined."), s4.errorUnsupportedIf(null == r10.mimeType, "Image mimeType must be defined.");
    const n7 = this.json.bufferViews[r10.bufferView], o6 = await this.getBuffer(n7.buffer, t11);
    return s4.errorUnsupportedIf(null != n7.byteStride, "byteStride not supported for image buffer"), z(new Uint8Array(o6.buffer, o6.byteOffset + (n7.byteOffset || 0), n7.byteLength), r10.mimeType);
  }
};
var P = new r5(2, 0, "glTF");
var V2 = g(e3(), Math.PI / 2);
var k = e4();
var H = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4 };
var Y2 = { [C.BYTE]: 1, [C.UNSIGNED_BYTE]: 1, [C.SHORT]: 2, [C.UNSIGNED_SHORT]: 2, [C.FLOAT]: 4, [C.UNSIGNED_INT]: 4 };
function J(t11) {
  switch (t11.componentType) {
    case C.BYTE:
      return new V(t11.raw, t11.byteOffset, t11.byteStride, t11.byteOffset + t11.byteStride * t11.entryCount);
    case C.UNSIGNED_BYTE:
      return new A(t11.raw, t11.byteOffset, t11.byteStride, t11.byteOffset + t11.byteStride * t11.entryCount);
    case C.SHORT:
      return new q(t11.raw, t11.byteOffset, t11.byteStride, t11.byteOffset + t11.byteStride * t11.entryCount);
    case C.UNSIGNED_SHORT:
      return new w2(t11.raw, t11.byteOffset, t11.byteStride, t11.byteOffset + t11.byteStride * t11.entryCount);
    case C.UNSIGNED_INT:
      return new F(t11.raw, t11.byteOffset, t11.byteStride, t11.byteOffset + t11.byteStride * t11.entryCount);
    case C.FLOAT:
      return new u2(t11.raw, t11.byteOffset, t11.byteStride, t11.byteOffset + t11.byteStride * t11.entryCount);
    default:
      return void n(t11.componentType);
  }
}
async function q2(e10) {
  return new Promise((t11, r10) => {
    const s4 = new Blob([e10]), n7 = new FileReader();
    n7.onload = () => {
      const e11 = n7.result;
      t11(JSON.parse(e11));
    }, n7.onerror = (e11) => {
      r10(e11);
    }, n7.readAsText(s4);
  });
}
async function z(e10, t11) {
  return new Promise((r10, s4) => {
    const n7 = new Blob([e10], { type: t11 }), o6 = URL.createObjectURL(n7), a3 = new Image();
    a3.addEventListener("load", () => {
      URL.revokeObjectURL(o6), "decode" in a3 ? a3.decode().then(() => r10(a3), () => r10(a3)) : r10(a3);
    }), a3.addEventListener("error", (e11) => {
      URL.revokeObjectURL(o6), s4(e11);
    }), a3.src = o6;
  });
}
var X2 = { 5120: "BYTE", 5121: "UNSIGNED_BYTE", 5122: "SHORT", 5123: "UNSIGNED_SHORT", 5125: "UNSIGNED_INT", 5126: "FLOAT" };

// node_modules/@arcgis/core/views/3d/glTF/loader.js
var u5 = 0;
async function c6(s4, r10, a3 = {}, i6 = true) {
  const c7 = await F2.load(s4, x3, r10, a3), p2 = "gltf_" + u5++, h2 = { lods: [], materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), meta: m(c7) }, I = !(!c7.json.asset.extras || "symbolResource" !== c7.json.asset.extras.ESRI_type), R = /* @__PURE__ */ new Map();
  await d3(c7, async (s5, r11, n7, u6) => {
    const m2 = R.get(n7) ?? 0;
    R.set(n7, m2 + 1);
    const d4 = void 0 !== s5.mode ? s5.mode : E2.TRIANGLES, I2 = d4 === E2.TRIANGLES || d4 === E2.TRIANGLE_STRIP || d4 === E2.TRIANGLE_FAN ? d4 : null;
    if (t(I2))
      return void x3.warnUnsupported("Unsupported primitive mode (" + T[d4] + "). Skipping primitive.");
    if (!c7.hasPositions(s5))
      return void x3.warn("Skipping primitive without POSITION vertex attribute.");
    const E4 = c7.getPositionData(s5, a3), S = c7.getMaterial(s5, a3, i6), _ = c7.hasNormals(s5) ? c7.getNormalData(s5, a3) : null, g3 = c7.hasTangents(s5) ? c7.getTangentData(s5, a3) : null, w3 = c7.hasTextureCoordinates(s5) ? c7.getTextureCoordinates(s5, a3) : null, N = c7.hasVertexColors(s5) ? c7.getVertexColors(s5, a3) : null, v = c7.getIndexData(s5, a3), M2 = { transform: r4(r11), attributes: { position: await E4, normal: _ ? await _ : null, texCoord0: w3 ? await w3 : null, color: N ? await N : null, tangent: g3 ? await g3 : null }, indices: await v, primitiveType: I2, material: f7(h2, await S, p2) };
    let A3 = null;
    r(h2.meta) && r(h2.meta.ESRI_lod) && "screenSpaceRadius" === h2.meta.ESRI_lod.metric && (A3 = h2.meta.ESRI_lod.thresholds[n7]), h2.lods[n7] = h2.lods[n7] || { parts: [], name: u6, lodThreshold: A3 }, h2.lods[n7].parts[m2] = M2;
  });
  for (const e10 of h2.lods)
    e10.parts = e10.parts.filter((e11) => !!e11);
  return { model: h2, meta: { isEsriSymbolResource: I, uri: c7.uri }, customMeta: {} };
}
function m(t11) {
  const o6 = t11.json;
  let s4 = null;
  return o6.nodes.forEach((t12) => {
    const o7 = t12.extras;
    r(o7) && (o7.ESRI_proxyEllipsoid || o7.ESRI_lod) && (s4 = o7);
  }), s4;
}
async function d3(e10, t11) {
  const o6 = e10.json, s4 = o6.scenes[o6.scene || 0].nodes, r10 = s4.length > 1, a3 = [];
  for (const i6 of s4) {
    const e11 = o6.nodes[i6];
    if (a3.push(n7(i6, 0)), p(e11) && !r10) {
      e11.extensions.MSFT_lod.ids.forEach((e12, t12) => n7(e12, t12 + 1));
    }
  }
  async function n7(s5, r11) {
    const i6 = o6.nodes[s5], l4 = e10.getNodeTransform(s5);
    if (x3.warnUnsupportedIf(null != i6.weights, "Morph targets are not supported."), null != i6.mesh) {
      const e11 = o6.meshes[i6.mesh];
      for (const o7 of e11.primitives)
        a3.push(t11(o7, l4, r11, e11.name));
    }
    for (const e11 of i6.children || [])
      a3.push(n7(e11, r11));
  }
  await Promise.all(a3);
}
function p(e10) {
  return e10.extensions && e10.extensions.MSFT_lod && Array.isArray(e10.extensions.MSFT_lod.ids);
}
function f7(e10, t11, o6) {
  const s4 = (t12) => {
    const s5 = `${o6}_tex_${t12 && t12.id}${t12 && t12.name ? "_" + t12.name : ""}`;
    if (t12 && !e10.textures.has(s5)) {
      const o7 = l2(t12.data, { wrap: { s: t12.wrapS, t: t12.wrapT }, mipmap: h.includes(t12.minFilter), noUnpackFlip: true });
      e10.textures.set(s5, o7);
    }
    return s5;
  }, n7 = `${o6}_mat_${t11.id}_${t11.name}`;
  if (!e10.materials.has(n7)) {
    const o7 = t8({ color: [t11.color[0], t11.color[1], t11.color[2]], opacity: t11.color[3], alphaMode: t11.alphaMode, alphaCutoff: t11.alphaCutoff, doubleSided: t11.doubleSided, colorMixMode: t11.ESRI_externalColorMixMode, textureColor: t11.colorTexture ? s4(t11.colorTexture) : void 0, textureNormal: t11.normalTexture ? s4(t11.normalTexture) : void 0, textureOcclusion: t11.occlusionTexture ? s4(t11.occlusionTexture) : void 0, textureEmissive: t11.emissiveTexture ? s4(t11.emissiveTexture) : void 0, textureMetallicRoughness: t11.metallicRoughnessTexture ? s4(t11.metallicRoughnessTexture) : void 0, emissiveFactor: [t11.emissiveFactor[0], t11.emissiveFactor[1], t11.emissiveFactor[2]], metallicFactor: t11.metallicFactor, roughnessFactor: t11.roughnessFactor });
    e10.materials.set(n7, o7);
  }
  return n7;
}
var x3 = new t7();
var h = [L2.LINEAR_MIPMAP_LINEAR, L2.LINEAR_MIPMAP_NEAREST];
var T = ["POINTS", "LINES", "LINE_LOOP", "LINE_STRIP", "TRIANGLES", "TRIANGLE_STRIP", "TRIANGLE_FAN"];

// node_modules/@arcgis/core/views/3d/glTF/internal/indexUtils.js
function n6(n7, o6 = l) {
  return "number" == typeof n7 ? o6(n7) : i(n7) || e(n7) ? new Uint32Array(n7) : n7;
}
function o4(t11) {
  const e10 = "number" == typeof t11 ? t11 : t11.length;
  if (e10 < 3)
    return new Uint16Array(0);
  const r10 = e10 - 2, n7 = r10 <= 65536 ? new Uint16Array(3 * r10) : new Uint32Array(3 * r10);
  if ("number" == typeof t11) {
    let t12 = 0;
    for (let e11 = 0; e11 < r10; e11 += 1)
      e11 % 2 == 0 ? (n7[t12++] = e11, n7[t12++] = e11 + 1, n7[t12++] = e11 + 2) : (n7[t12++] = e11 + 1, n7[t12++] = e11, n7[t12++] = e11 + 2);
  } else {
    let e11 = 0;
    for (let o6 = 0; o6 < r10; o6 += 1)
      if (o6 % 2 == 0) {
        const r11 = t11[o6], i6 = t11[o6 + 1], f8 = t11[o6 + 2];
        n7[e11++] = r11, n7[e11++] = i6, n7[e11++] = f8;
      } else {
        const r11 = t11[o6 + 1], i6 = t11[o6], f8 = t11[o6 + 2];
        n7[e11++] = r11, n7[e11++] = i6, n7[e11++] = f8;
      }
  }
  return n7;
}
function i5(t11) {
  const e10 = "number" == typeof t11 ? t11 : t11.length;
  if (e10 < 3)
    return new Uint16Array(0);
  const r10 = e10 - 2, n7 = r10 <= 65536 ? new Uint16Array(3 * r10) : new Uint32Array(3 * r10);
  if ("number" == typeof t11) {
    let t12 = 0;
    for (let e11 = 0; e11 < r10; ++e11)
      n7[t12++] = 0, n7[t12++] = e11 + 1, n7[t12++] = e11 + 2;
    return n7;
  }
  {
    const e11 = t11[0];
    let o6 = t11[1], i6 = 0;
    for (let f8 = 0; f8 < r10; ++f8) {
      const r11 = t11[f8 + 2];
      n7[i6++] = e11, n7[i6++] = o6, n7[i6++] = r11, o6 = r11;
    }
    return n7;
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial_COLOR_GAMMA.js
var o5 = 2.1;

export {
  r6 as r,
  f3 as f,
  o,
  n2 as n,
  n3 as n2,
  d2 as d,
  e6 as e,
  t3 as t,
  r8 as r2,
  n4 as n3,
  c6 as c,
  n6 as n4,
  o4 as o2,
  i5 as i,
  o5 as o3
};
//# sourceMappingURL=chunk-GKICNYWA.js.map
