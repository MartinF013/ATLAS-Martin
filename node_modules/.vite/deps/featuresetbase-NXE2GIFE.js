import {
  A,
  C,
  D,
  E as E3,
  I as I2,
  S,
  S2,
  b,
  e,
  e2,
  g,
  h,
  m as m2,
  q,
  s as s2,
  s2 as s3,
  v,
  w as w2,
  y as y2
} from "./chunk-7NEDGCOF.js";
import "./chunk-Z34NAJDO.js";
import {
  E as E2,
  a3 as a
} from "./chunk-CEJQPREK.js";
import {
  d as d2,
  s
} from "./chunk-WC3LL63J.js";
import "./chunk-U7LREOA7.js";
import {
  l
} from "./chunk-Q3ZGS5K7.js";
import {
  d
} from "./chunk-3BCNCVBY.js";
import "./chunk-GXI3XMFU.js";
import "./chunk-7DMYZG6H.js";
import {
  m
} from "./chunk-X64NQ2GK.js";
import "./chunk-MR6FXIW4.js";
import {
  E,
  F2 as F,
  G,
  I,
  J,
  L,
  M,
  N,
  X,
  Y,
  n,
  ne,
  oe,
  t,
  t2,
  w,
  xe
} from "./chunk-LBBA3SFR.js";
import "./chunk-2KZBVPWA.js";
import "./chunk-22YODLVL.js";
import "./chunk-TB42IUV7.js";
import "./chunk-ZWMYDR2G.js";
import "./chunk-ZZY5IDKU.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-6FKG7JUE.js";
import {
  Ke
} from "./chunk-7LOJJ46D.js";
import "./chunk-VNR743PA.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-SWCA522B.js";
import "./chunk-YPIBZ3CH.js";
import "./chunk-XLCZFN6R.js";
import "./chunk-OMNBM2E4.js";
import "./chunk-WKHS6QIX.js";
import "./chunk-6O7ZZEV7.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-OBCAVCXI.js";
import "./chunk-RFOZTYJH.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-L2YBXQTH.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-4XBERLPX.js";
import "./chunk-SZPDY7KN.js";
import "./chunk-Y6YGVGFR.js";
import "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import "./chunk-MZX3HN4G.js";
import "./chunk-T47JAOQZ.js";
import "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-RIWDMEW4.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import {
  y
} from "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-OG6CQEZJ.js";
import "./chunk-X5Z3DJQ4.js";
import "./chunk-BUWXVMJU.js";
import "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import "./chunk-D3XXPCBB.js";
import "./chunk-OWBMOIIV.js";
import "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  k
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/arcade/functions/featuresetbase.js
function _(e3, t3, n2, r) {
  if (1 === r.length) {
    if (L(r[0]))
      return l(e3, r[0], -1);
    if (E(r[0]))
      return l(e3, r[0].toArray(), -1);
  }
  return l(e3, r, -1);
}
async function J2(e3, t3, n2) {
  const r = e3.getVariables();
  if (r.length > 0) {
    const i = [];
    for (let e4 = 0; e4 < r.length; e4++) {
      const a3 = { name: r[e4] };
      i.push(await t3.evaluateIdentifier(n2, a3));
    }
    const a2 = {};
    for (let e4 = 0; e4 < r.length; e4++)
      a2[r[e4]] = i[e4];
    return e3.parameters = a2, e3;
  }
  return e3;
}
function q2(e3, t3, n2 = null) {
  for (const r in e3)
    if (r.toLowerCase() === t3.toLowerCase())
      return e3[r];
  return n2;
}
function K(e3) {
  if (null === e3)
    return null;
  const t3 = { type: q2(e3, "type", ""), name: q2(e3, "name", "") };
  if ("range" === t3.type)
    t3.range = q2(e3, "range", []);
  else {
    t3.codedValues = [];
    for (const n2 of q2(e3, "codedValues", []))
      t3.codedValues.push({ name: q2(n2, "name", ""), code: q2(n2, "code", null) });
  }
  return t3;
}
function Y2(e3) {
  if (null === e3)
    return null;
  const t3 = {}, n2 = q2(e3, "wkt", null);
  null !== n2 && (t3.wkt = n2);
  const r = q2(e3, "wkid", null);
  return null !== r && (t3.wkid = r), t3;
}
function Z(e3) {
  if (null === e3)
    return null;
  const t3 = { hasZ: q2(e3, "hasz", false), hasM: q2(e3, "hasm", false) }, n2 = q2(e3, "spatialreference", null);
  n2 && (t3.spatialReference = Y2(n2));
  const r = q2(e3, "x", null);
  if (null !== r)
    return t3.x = r, t3.y = q2(e3, "y", null), t3;
  const i = q2(e3, "rings", null);
  if (null !== i)
    return t3.rings = i, t3;
  const a2 = q2(e3, "paths", null);
  if (null !== a2)
    return t3.paths = a2, t3;
  const s4 = q2(e3, "points", null);
  if (null !== s4)
    return t3.points = s4, t3;
  for (const o of ["xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"]) {
    const n3 = q2(e3, o, null);
    null !== n3 && (t3[o] = n3);
  }
  return t3;
}
function Q(e3, t3) {
  for (const n2 of t3)
    if (n2 === e3)
      return true;
  return false;
}
function X2(e3) {
  return !!e3.layerDefinition && (!!e3.featureSet && (false !== Q(e3.layerDefinition.geometryType, ["", "esriGeometryPoint", "esriGeometryPolyline", "esriGeometryPolygon", "esriGeometryMultipoint", "esriGeometryEnvelope"]) && (null !== e3.layerDefinition.objectIdField && "" !== e3.layerDefinition.objectIdField && (false !== L(e3.layerDefinition.fields) && false !== L(e3.featureSet.features)))));
}
function ee(V) {
  "async" === V.mode && (V.functions.getuser = function(n2, r) {
    return V.standardFunctionAsync(n2, r, async (r2, s4, o) => {
      G(o, 1, 2);
      let l2 = I(o[1], ""), f = true === l2;
      if (l2 = true === l2 || false === l2 ? "" : X(l2), o[0] instanceof s) {
        let e3 = null;
        n2.services && n2.services.portal && (e3 = n2.services.portal), e3 = E3(o[0], e3);
        const r3 = await b(e3, l2, f);
        if (r3) {
          const e4 = JSON.parse(JSON.stringify(r3));
          for (const t3 of ["lastLogin", "created", "modified"])
            void 0 !== e4[t3] && null !== e4[t3] && (e4[t3] = new Date(e4[t3]));
          return d.convertObjectToArcadeDictionary(e4);
        }
        return null;
      }
      let u = null;
      if (J(o[0]) && (u = o[0]), u) {
        if (f = false, l2)
          return null;
        await u.load();
        const r3 = await u.getOwningSystemUrl();
        if (!r3) {
          if (!l2) {
            const e3 = await u.getIdentityUser();
            return e3 ? d.convertObjectToArcadeDictionary({ username: e3 }) : null;
          }
          return null;
        }
        let s5 = null;
        n2.services && n2.services.portal && (s5 = n2.services.portal), s5 = E3(new s(r3), s5);
        const o2 = await b(s5, l2, f);
        if (o2) {
          const e3 = JSON.parse(JSON.stringify(o2));
          for (const t3 of ["lastLogin", "created", "modified"])
            void 0 !== e3[t3] && null !== e3[t3] && (e3[t3] = new Date(e3[t3]));
          return d.convertObjectToArcadeDictionary(e3);
        }
        return null;
      }
      throw new Error("Invalid Parameter");
    });
  }, V.signatures.push({ name: "getuser", min: "1", max: "2" }), V.functions.featuresetbyid = function(e3, t3) {
    return V.standardFunctionAsync(e3, t3, (e4, t4, n2) => {
      if (G(n2, 2, 4), n2[0] instanceof e) {
        const e5 = X(n2[1]);
        let t5 = I(n2[2], null);
        const r = oe(I(n2[3], true));
        if (null === t5 && (t5 = ["*"]), false === L(t5))
          throw new Error("Invalid Parameter");
        return n2[0].featureSetById(e5, r, t5);
      }
      throw new Error("Invalid Parameter");
    });
  }, V.signatures.push({ name: "featuresetbyid", min: "2", max: "4" }), V.functions.getfeatureset = function(e3, t3) {
    return V.standardFunctionAsync(e3, t3, (t4, n2, r) => {
      if (G(r, 1, 2), Y(r[0])) {
        let t5 = I(r[1], "datasource");
        return null === t5 && (t5 = "datasource"), t5 = X(t5).toLowerCase(), D(r[0].fullSchema(), t5, e3.lrucache, e3.interceptor, e3.spatialReference);
      }
      throw new Error("Invalid Parameter");
    });
  }, V.signatures.push({ name: "getfeatureset", min: "1", max: "2" }), V.functions.featuresetbyportalitem = function(t3, n2) {
    return V.standardFunctionAsync(t3, n2, (n3, r, a2) => {
      if (G(a2, 2, 5), null === a2[0])
        throw new Error("Portal is required");
      if (a2[0] instanceof s) {
        const e3 = X(a2[1]), n4 = X(a2[2]);
        let r2 = I(a2[3], null);
        const s5 = oe(I(a2[4], true));
        if (null === r2 && (r2 = ["*"]), false === L(r2))
          throw new Error("Invalid Parameter");
        let l3 = null;
        return t3.services && t3.services.portal && (l3 = t3.services.portal), l3 = E3(a2[0], l3), q(e3, n4, t3.spatialReference, r2, s5, l3, t3.lrucache, t3.interceptor);
      }
      if (false === w(a2[0]))
        throw new Error("Portal is required");
      const s4 = X(a2[0]), l2 = X(a2[1]);
      let f = I(a2[2], null);
      const u = oe(I(a2[3], true));
      if (null === f && (f = ["*"]), false === L(f))
        throw new Error("Invalid Parameter");
      if (t3.services && t3.services.portal)
        return q(s4, l2, t3.spatialReference, f, u, t3.services.portal, t3.lrucache, t3.interceptor);
      throw new Error("Portal is required");
    });
  }, V.signatures.push({ name: "featuresetbyportalitem", min: "2", max: "5" }), V.functions.featuresetbyname = function(e3, t3) {
    return V.standardFunctionAsync(e3, t3, (e4, t4, n2) => {
      if (G(n2, 2, 4), n2[0] instanceof e) {
        const e5 = X(n2[1]);
        let t5 = I(n2[2], null);
        const r = oe(I(n2[3], true));
        if (null === t5 && (t5 = ["*"]), false === L(t5))
          throw new Error("Invalid Parameter");
        return n2[0].featureSetByName(e5, r, t5);
      }
      throw new Error("Invalid Parameter");
    });
  }, V.signatures.push({ name: "featuresetbyname", min: "2", max: "4" }), V.functions.featureset = function(e3, n2) {
    return V.standardFunction(e3, n2, (n3, r, i) => {
      G(i, 1, 1);
      let a2 = i[0];
      const s4 = { layerDefinition: { geometryType: "", objectIdField: "", globalIdField: "", typeIdField: "", fields: [] }, featureSet: { geometryType: "", features: [] } };
      if (w(a2))
        a2 = JSON.parse(a2), void 0 !== a2.layerDefinition ? (s4.layerDefinition = a2.layerDefinition, s4.featureSet = a2.featureSet, a2.layerDefinition.spatialReference && (s4.layerDefinition.spatialReference = a2.layerDefinition.spatialReference)) : (s4.featureSet.features = a2.features, s4.featureSet.geometryType = a2.geometryType, s4.layerDefinition.geometryType = s4.featureSet.geometryType, s4.layerDefinition.objectIdField = a2.objectIdFieldName, s4.layerDefinition.typeIdField = a2.typeIdFieldName, s4.layerDefinition.globalIdField = a2.globalIdFieldName, s4.layerDefinition.fields = a2.fields, a2.spatialReference && (s4.layerDefinition.spatialReference = a2.spatialReference));
      else {
        if (!(i[0] instanceof d))
          throw new Error("Invalid Parameter");
        {
          a2 = JSON.parse(i[0].castToText());
          const e4 = q2(a2, "layerdefinition");
          if (null !== e4) {
            s4.layerDefinition.geometryType = q2(e4, "geometrytype", ""), s4.featureSet.geometryType = s4.layerDefinition.geometryType, s4.layerDefinition.globalIdField = q2(e4, "globalidfield", ""), s4.layerDefinition.objectIdField = q2(e4, "objectidfield", ""), s4.layerDefinition.typeIdField = q2(e4, "typeidfield", "");
            const t3 = q2(e4, "spatialreference", null);
            t3 && (s4.layerDefinition.spatialReference = Y2(t3));
            for (const r2 of q2(e4, "fields", [])) {
              const e5 = { name: q2(r2, "name", ""), alias: q2(r2, "alias", ""), type: q2(r2, "type", ""), nullable: q2(r2, "nullable", true), editable: q2(r2, "editable", true), length: q2(r2, "length", null), domain: K(q2(r2, "domain")) };
              s4.layerDefinition.fields.push(e5);
            }
            const n4 = q2(a2, "featureset", null);
            if (n4) {
              const e5 = {};
              for (const t4 of s4.layerDefinition.fields)
                e5[t4.name.toLowerCase()] = t4.name;
              for (const t4 of q2(n4, "features", [])) {
                const n5 = {}, r2 = q2(t4, "attributes", {});
                for (const t5 in r2)
                  n5[e5[t5.toLowerCase()]] = r2[t5];
                s4.featureSet.features.push({ attributes: n5, geometry: Z(q2(t4, "geometry", null)) });
              }
            }
          } else {
            s4.layerDefinition.geometryType = q2(a2, "geometrytype", ""), s4.featureSet.geometryType = s4.layerDefinition.geometryType, s4.layerDefinition.objectIdField = q2(a2, "objectidfieldname", ""), s4.layerDefinition.typeIdField = q2(a2, "typeidfieldname", "");
            const e5 = q2(a2, "spatialreference", null);
            e5 && (s4.layerDefinition.spatialReference = Y2(e5));
            for (const n4 of q2(a2, "fields", [])) {
              const e6 = { name: q2(n4, "name", ""), alias: q2(n4, "alias", ""), type: q2(n4, "type", ""), nullable: q2(n4, "nullable", true), editable: q2(n4, "editable", true), length: q2(n4, "length", null), domain: K(q2(n4, "domain")) };
              s4.layerDefinition.fields.push(e6);
            }
            const t3 = {};
            for (const n4 of s4.layerDefinition.fields)
              t3[n4.name.toLowerCase()] = n4.name;
            for (const n4 of q2(a2, "features", [])) {
              const e6 = {}, r2 = q2(n4, "attributes", {});
              for (const n5 in r2)
                e6[t3[n5.toLowerCase()]] = r2[n5];
              s4.featureSet.features.push({ attributes: e6, geometry: Z(q2(n4, "geometry", null)) });
            }
          }
        }
      }
      if (false === X2(s4))
        throw new Error("Invalid Parameter");
      return y2.create(s4, e3.spatialReference);
    });
  }, V.signatures.push({ name: "featureset", min: "1", max: "1" }), V.functions.filter = function(e3, t3) {
    return V.standardFunctionAsync(e3, t3, async (t4, n2, r) => {
      if (G(r, 2, 2), L(r[0]) || E(r[0])) {
        const t5 = [];
        let n3 = r[0];
        n3 instanceof t && (n3 = n3.toArray());
        let i = null;
        if (r[1] instanceof t2)
          i = V.arcadeCustomFunctionHandler(r[1]);
        else if (r[1] instanceof N)
          i = (...t6) => r[1].fn(e3, { preparsed: true, arguments: t6 });
        else {
          if (!(r[1] instanceof M))
            throw new Error("Invalid Parameter");
          i = (...e4) => {
            if (e4.length !== r[1].paramCount)
              throw new Error("Invalid parameters");
            return r[1].fn(...e4);
          };
        }
        for (const e4 of n3) {
          const n4 = i(e4);
          k(n4) ? true === await n4 && t5.push(e4) : true === n4 && t5.push(e4);
        }
        return t5;
      }
      if (J(r[0])) {
        const t5 = await r[0].load(), n3 = m.create(r[1], t5.getFieldsIndex()), i = n3.getVariables();
        if (i.length > 0) {
          const t6 = [];
          for (let n4 = 0; n4 < i.length; n4++) {
            const r2 = { name: i[n4] };
            t6.push(await V.evaluateIdentifier(e3, r2));
          }
          const a2 = {};
          for (let e4 = 0; e4 < i.length; e4++)
            a2[i[e4]] = t6[e4];
          return n3.parameters = a2, new h({ parentfeatureset: r[0], whereclause: n3 });
        }
        return new h({ parentfeatureset: r[0], whereclause: n3 });
      }
      throw new Error("Filter cannot accept this parameter type");
    });
  }, V.signatures.push({ name: "filter", min: "2", max: "2" }), V.functions.orderby = function(e3, t3) {
    return V.standardFunctionAsync(e3, t3, async (e4, t4, n2) => {
      if (G(n2, 2, 2), J(n2[0])) {
        const e5 = new e2(n2[1]);
        return new s2({ parentfeatureset: n2[0], orderbyclause: e5 });
      }
      throw new Error("Order cannot accept this parameter type");
    });
  }, V.signatures.push({ name: "orderby", min: "2", max: "2" }), V.functions.top = function(e3, t3) {
    return V.standardFunctionAsync(e3, t3, async (e4, t4, n2) => {
      if (G(n2, 2, 2), J(n2[0]))
        return new s3({ parentfeatureset: n2[0], topnum: n2[1] });
      if (L(n2[0]))
        return ne(n2[1]) >= n2[0].length ? n2[0].slice(0) : n2[0].slice(0, ne(n2[1]));
      if (E(n2[0]))
        return ne(n2[1]) >= n2[0].length() ? n2[0].slice(0) : n2[0].slice(0, ne(n2[1]));
      throw new Error("Top cannot accept this parameter type");
    });
  }, V.signatures.push({ name: "top", min: "2", max: "2" }), V.functions.first = function(e3, t3) {
    return V.standardFunctionAsync(e3, t3, async (e4, t4, r) => {
      if (G(r, 1, 1), J(r[0])) {
        const t5 = await r[0].first(e4.abortSignal);
        if (null !== t5) {
          const e5 = d2.createFromGraphicLikeObject(t5.geometry, t5.attributes, r[0]);
          return e5._underlyingGraphic = t5, e5;
        }
        return t5;
      }
      return L(r[0]) ? 0 === r[0].length ? null : r[0][0] : E(r[0]) ? 0 === r[0].length() ? null : r[0].get(0) : null;
    });
  }, V.signatures.push({ name: "first", min: "1", max: "1" }), V.functions.attachments = function(e3, n2) {
    return V.standardFunctionAsync(e3, n2, async (n3, r, i) => {
      G(i, 1, 2);
      const a2 = { minsize: -1, maxsize: -1, types: null, returnMetadata: false };
      if (i.length > 1) {
        if (i[1] instanceof d) {
          if (i[1].hasField("minsize") && (a2.minsize = ne(i[1].field("minsize"))), i[1].hasField("metadata") && (a2.returnMetadata = oe(i[1].field("metadata"))), i[1].hasField("maxsize") && (a2.maxsize = ne(i[1].field("maxsize"))), i[1].hasField("types")) {
            const e4 = xe(i[1].field("types"), false);
            e4.length > 0 && (a2.types = e4);
          }
        } else if (null !== i[1])
          throw new Error("Invalid Parameter");
      }
      if (Y(i[0])) {
        let t3 = i[0]._layer;
        return t3 instanceof Ke && (t3 = S2(t3, e3.spatialReference, ["*"], true, e3.lrucache, e3.interceptor)), null === t3 ? [] : false === J(t3) ? [] : (await t3.load(), t3.queryAttachments(i[0].field(t3.objectIdField), a2.minsize, a2.maxsize, a2.types, a2.returnMetadata));
      }
      if (null === i[0])
        return [];
      throw new Error("Invalid Parameter");
    });
  }, V.signatures.push({ name: "attachments", min: "1", max: "2" }), V.functions.featuresetbyrelationshipname = function(e3, t3) {
    return V.standardFunctionAsync(e3, t3, async (t4, n2, r) => {
      G(r, 2, 4);
      const i = r[0], a2 = X(r[1]);
      let s4 = I(r[2], null);
      const o = oe(I(r[3], true));
      if (null === s4 && (s4 = ["*"]), false === L(s4))
        throw new Error("Invalid Parameter");
      if (null === r[0])
        return null;
      if (!Y(r[0]))
        throw new Error("Invalid Parameter");
      let c = i._layer;
      if (c instanceof Ke && (c = S2(c, e3.spatialReference, ["*"], true, e3.lrucache, e3.interceptor)), null === c)
        return null;
      if (false === J(c))
        return null;
      c = await c.load();
      const d3 = c.relationshipMetaData().filter((e4) => e4.name === a2);
      if (0 === d3.length)
        return null;
      if (void 0 !== d3[0].relationshipTableId && null !== d3[0].relationshipTableId && d3[0].relationshipTableId > -1)
        return A(c, d3[0], i.field(c.objectIdField), c.spatialReference, s4, o, e3.lrucache, e3.interceptor);
      let m3 = c.serviceUrl();
      if (!m3)
        return null;
      m3 = "/" === m3.charAt(m3.length - 1) ? m3 + d3[0].relatedTableId.toString() : m3 + "/" + d3[0].relatedTableId.toString();
      const I3 = await I2(m3, c.spatialReference, s4, o, e3.lrucache, e3.interceptor);
      await I3.load();
      let D2 = I3.relationshipMetaData();
      if (D2 = D2.filter((e4) => e4.id === d3[0].id), false === i.hasField(d3[0].keyField) || null === i.field(d3[0].keyField)) {
        const e4 = await c.getFeatureByObjectId(i.field(c.objectIdField), [d3[0].keyField]);
        if (e4) {
          const t5 = m.create(D2[0].keyField + "= @id", I3.getFieldsIndex());
          return t5.parameters = { id: e4.attributes[d3[0].keyField] }, I3.filter(t5);
        }
        return new a({ parentfeatureset: I3 });
      }
      const b2 = m.create(D2[0].keyField + "= @id", I3.getFieldsIndex());
      return b2.parameters = { id: i.field(d3[0].keyField) }, I3.filter(b2);
    });
  }, V.signatures.push({ name: "featuresetbyrelationshipname", min: "2", max: "4" }), V.functions.featuresetbyassociation = function(e3, t3) {
    return V.standardFunctionAsync(e3, t3, async (t4, n2, r) => {
      G(r, 2, 3);
      const i = r[0], a2 = X(I(r[1], "")).toLowerCase(), s4 = w(r[2]) ? X(r[2]) : null;
      if (null === r[0])
        return null;
      if (!Y(r[0]))
        throw new Error("Invalid Parameter");
      let o = i._layer;
      if (o instanceof Ke && (o = S2(o, e3.spatialReference, ["*"], true, e3.lrucache, e3.interceptor)), null === o)
        return null;
      if (false === J(o))
        return null;
      await o.load();
      const f = o.serviceUrl(), u = await g(f, e3.spatialReference);
      let d3 = null, m3 = null, h2 = false;
      if (null !== s4 && "" !== s4 && void 0 !== s4) {
        for (const e4 of u.terminals)
          e4.terminalName === s4 && (m3 = e4.terminalId);
        null === m3 && (h2 = true);
      }
      const E4 = u.associations.getFieldsIndex(), D2 = E4.get("TOGLOBALID").name, b2 = E4.get("FROMGLOBALID").name, A2 = E4.get("TOTERMINALID").name, N2 = E4.get("FROMTERMINALID").name, x = E4.get("FROMNETWORKSOURCEID").name, O = E4.get("TONETWORKSOURCEID").name, C2 = E4.get("ASSOCIATIONTYPE").name, R = E4.get("ISCONTENTVISIBLE").name, M2 = E4.get("OBJECTID").name;
      for (const e4 of o.fields)
        if ("global-id" === e4.type) {
          d3 = i.field(e4.name);
          break;
        }
      let P = null, k2 = new v(new y({ name: "percentalong", alias: "percentalong", type: "double" }), m.create("0", u.associations.getFieldsIndex())), B = new v(new y({ name: "side", alias: "side", type: "string" }), m.create("''", u.associations.getFieldsIndex()));
      const V2 = "globalid", H = "globalId", _2 = {};
      for (const e4 in u.lkp)
        _2[e4] = u.lkp[e4].sourceId;
      const J3 = new m2(new y({ name: "classname", alias: "classname", type: "string" }), null, _2);
      let q3 = "";
      switch (a2) {
        case "midspan": {
          q3 = `((${D2}='${d3}') OR ( ${b2}='${d3}')) AND (${C2} IN (5))`, J3.codefield = m.create(`CASE WHEN (${D2}='${d3}') THEN ${x} ELSE ${O} END`, u.associations.getFieldsIndex());
          const e4 = n(C.findField(u.associations.fields, b2));
          e4.name = V2, e4.alias = V2, P = new v(e4, m.create(`CASE WHEN (${b2}='${d3}') THEN ${D2} ELSE ${b2} END`, u.associations.getFieldsIndex())), k2 = u.unVersion >= 4 ? new S(C.findField(u.associations.fields, E4.get("PERCENTALONG").name)) : new v(new y({ name: "percentalong", alias: "percentalong", type: "double" }), m.create("0", u.associations.getFieldsIndex()));
          break;
        }
        case "junctionedge": {
          q3 = `((${D2}='${d3}') OR ( ${b2}='${d3}')) AND (${C2} IN (4,6))`, J3.codefield = m.create(`CASE WHEN (${D2}='${d3}') THEN ${x} ELSE ${O} END`, u.associations.getFieldsIndex());
          const e4 = n(C.findField(u.associations.fields, b2));
          e4.name = V2, e4.alias = V2, P = new v(e4, m.create(`CASE WHEN (${b2}='${d3}') THEN ${D2} ELSE ${b2} END`, u.associations.getFieldsIndex())), B = new v(new y({ name: "side", alias: "side", type: "string" }), m.create(`CASE WHEN (${C2}=4) THEN 'from' ELSE 'to' END`, u.associations.getFieldsIndex()));
          break;
        }
        case "connected": {
          let e4 = `${D2}='@T'`, t5 = `${b2}='@T'`;
          null !== m3 && (e4 += ` AND ${A2}=@A`, t5 += ` AND ${N2}=@A`), q3 = "((" + e4 + ") OR (" + t5 + "))", q3 = F(q3, "@T", d3), e4 = F(e4, "@T", d3), null !== m3 && (e4 = F(e4, "@A", m3.toString()), q3 = F(q3, "@A", m3.toString())), J3.codefield = m.create("CASE WHEN " + e4 + ` THEN ${x} ELSE ${O} END`, u.associations.getFieldsIndex());
          const n3 = n(C.findField(u.associations.fields, b2));
          n3.name = V2, n3.alias = V2, P = new v(n3, m.create("CASE WHEN " + e4 + ` THEN ${b2} ELSE ${D2} END`, u.associations.getFieldsIndex()));
          break;
        }
        case "container":
          q3 = `${D2}='${d3}' AND ${C2} = 2`, null !== m3 && (q3 += ` AND ${A2} = ` + m3.toString()), J3.codefield = x, q3 = "( " + q3 + " )", P = new w2(C.findField(u.associations.fields, b2), V2, V2);
        case "content":
          q3 = `(${b2}='${d3}' AND ${C2} = 2)`, null !== m3 && (q3 += ` AND ${N2} = ` + m3.toString()), J3.codefield = O, q3 = "( " + q3 + " )", P = new w2(C.findField(u.associations.fields, D2), V2, V2);
          break;
        case "structure":
          q3 = `(${D2}='${d3}' AND ${C2} = 3)`, null !== m3 && (q3 += ` AND ${A2} = ` + m3.toString()), J3.codefield = x, q3 = "( " + q3 + " )", P = new w2(C.findField(u.associations.fields, b2), V2, H);
          break;
        case "attached":
          q3 = `(${b2}='${d3}' AND ${C2} = 3)`, null !== m3 && (q3 += ` AND ${N2} = ` + m3.toString()), J3.codefield = O, q3 = "( " + q3 + " )", P = new w2(C.findField(u.associations.fields, D2), V2, H);
          break;
        default:
          throw new Error("Invalid Parameter");
      }
      h2 && (q3 = "1 <> 1");
      return new C({ parentfeatureset: u.associations, adaptedFields: [new S(C.findField(u.associations.fields, M2)), new S(C.findField(u.associations.fields, R)), P, B, J3, k2], extraFilter: q3 ? m.create(q3, u.associations.getFieldsIndex()) : null });
    });
  }, V.signatures.push({ name: "featuresetbyassociation", min: "2", max: "6" }), V.functions.groupby = function(e3, n2) {
    return V.standardFunctionAsync(e3, n2, async (n3, r, i) => {
      if (G(i, 3, 3), !J(i[0]))
        throw new Error("Illegal Value: GroupBy");
      const a2 = await i[0].load(), s4 = [], o = [];
      let l2 = false, f = [];
      if (w(i[1]))
        f.push(i[1]);
      else if (i[1] instanceof d)
        f.push(i[1]);
      else if (L(i[1]))
        f = i[1];
      else {
        if (!E(i[1]))
          throw new Error("Illegal Value: GroupBy");
        f = i[1].toArray();
      }
      for (const e4 of f)
        if (w(e4)) {
          const t3 = m.create(X(e4), a2.getFieldsIndex()), n4 = true === E2(t3) ? X(e4) : "%%%%FIELDNAME";
          s4.push({ name: n4, expression: t3 }), "%%%%FIELDNAME" === n4 && (l2 = true);
        } else {
          if (!(e4 instanceof d))
            throw new Error("Illegal Value: GroupBy");
          {
            const t3 = e4.hasField("name") ? e4.field("name") : "%%%%FIELDNAME", n4 = e4.hasField("expression") ? e4.field("expression") : "";
            if ("%%%%FIELDNAME" === t3 && (l2 = true), !t3)
              throw new Error("Illegal Value: GroupBy");
            s4.push({ name: t3, expression: m.create(n4 || t3, a2.getFieldsIndex()) });
          }
        }
      if (f = [], w(i[2]))
        f.push(i[2]);
      else if (L(i[2]))
        f = i[2];
      else if (E(i[2]))
        f = i[2].toArray();
      else {
        if (!(i[2] instanceof d))
          throw new Error("Illegal Value: GroupBy");
        f.push(i[2]);
      }
      for (const e4 of f) {
        if (!(e4 instanceof d))
          throw new Error("Illegal Value: GroupBy");
        {
          const t3 = e4.hasField("name") ? e4.field("name") : "", n4 = e4.hasField("statistic") ? e4.field("statistic") : "", r2 = e4.hasField("expression") ? e4.field("expression") : "";
          if (!t3 || !n4 || !r2)
            throw new Error("Illegal Value: GroupBy");
          o.push({ name: t3, statistic: n4.toLowerCase(), expression: m.create(r2, a2.getFieldsIndex()) });
        }
      }
      if (l2) {
        const e4 = {};
        for (const n4 of a2.fields)
          e4[n4.name.toLowerCase()] = 1;
        for (const n4 of s4)
          "%%%%FIELDNAME" !== n4.name && (e4[n4.name.toLowerCase()] = 1);
        for (const n4 of o)
          "%%%%FIELDNAME" !== n4.name && (e4[n4.name.toLowerCase()] = 1);
        let t3 = 0;
        for (const n4 of s4)
          if ("%%%%FIELDNAME" === n4.name) {
            for (; 1 === e4["field_" + t3.toString()]; )
              t3++;
            e4["field_" + t3.toString()] = 1, n4.name = "FIELD_" + t3.toString();
          }
      }
      for (const t3 of s4)
        await J2(t3.expression, V, e3);
      for (const t3 of o)
        await J2(t3.expression, V, e3);
      return i[0].groupby(s4, o);
    });
  }, V.signatures.push({ name: "groupby", min: "3", max: "3" }), V.functions.distinct = function(e3, n2) {
    return V.standardFunctionAsync(e3, n2, async (n3, r, i) => {
      if (J(i[0])) {
        G(i, 2, 2);
        const n4 = await i[0].load(), r2 = [];
        let a2 = [];
        if (w(i[1]))
          a2.push(i[1]);
        else if (i[1] instanceof d)
          a2.push(i[1]);
        else if (L(i[1]))
          a2 = i[1];
        else {
          if (!E(i[1]))
            throw new Error("Illegal Value: GroupBy");
          a2 = i[1].toArray();
        }
        let s4 = false;
        for (const e4 of a2)
          if (w(e4)) {
            const t3 = m.create(X(e4), n4.getFieldsIndex()), i2 = true === E2(t3) ? X(e4) : "%%%%FIELDNAME";
            r2.push({ name: i2, expression: t3 }), "%%%%FIELDNAME" === i2 && (s4 = true);
          } else {
            if (!(e4 instanceof d))
              throw new Error("Illegal Value: GroupBy");
            {
              const t3 = e4.hasField("name") ? e4.field("name") : "%%%%FIELDNAME", i2 = e4.hasField("expression") ? e4.field("expression") : "";
              if ("%%%%FIELDNAME" === t3 && (s4 = true), !t3)
                throw new Error("Illegal Value: GroupBy");
              r2.push({ name: t3, expression: m.create(i2 || t3, n4.getFieldsIndex()) });
            }
          }
        if (s4) {
          const e4 = {};
          for (const r3 of n4.fields)
            e4[r3.name.toLowerCase()] = 1;
          for (const n5 of r2)
            "%%%%FIELDNAME" !== n5.name && (e4[n5.name.toLowerCase()] = 1);
          let t3 = 0;
          for (const n5 of r2)
            if ("%%%%FIELDNAME" === n5.name) {
              for (; 1 === e4["field_" + t3.toString()]; )
                t3++;
              e4["field_" + t3.toString()] = 1, n5.name = "FIELD_" + t3.toString();
            }
        }
        for (const t3 of r2)
          await J2(t3.expression, V, e3);
        return i[0].groupby(r2, []);
      }
      return _("distinct", n3, r, i);
    });
  });
}
export {
  ee as registerFunctions
};
//# sourceMappingURL=featuresetbase-NXE2GIFE.js.map
