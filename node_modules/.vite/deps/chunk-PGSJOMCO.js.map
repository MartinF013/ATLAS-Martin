{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/layers/support/markerUtils.js", "../../@arcgis/core/chunks/LineMarker.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{isSome as r}from\"../../../../core/maybe.js\";import{createTexture as t}from\"../graphics/sdfPrimitives.js\";const n=64,o=n/2,i=o/5;function e(t,n){return r(n)?m(t,f(n.style)):null}function m(r,e){return r.fromData(e,(()=>t(e,n,o,i)))}function f(r){return\"diamond\"===r?\"kite\":r}export{o as MARKER_SYMBOL_SIZE,n as MARKER_TEXTURE_SIZE,i as MARKER_THICKNESS,f as parseLineMarkerStyle,e as prepareMarkerResources};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{MARKER_TEXTURE_SIZE as e,MARKER_THICKNESS as r}from\"../views/3d/layers/support/markerUtils.js\";import{ShaderOutput as o}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js\";import{SliceDraw as i}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{RibbonVertexPosition as t}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";import{OutputDepth as a}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{multipassTerrainTest as s}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";import{symbolAlphaCutoff as n}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{ColorConversion as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{RgbaFloatEncoding as c}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{addProjViewLocalOrigin as p}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float2PassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as v}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as f}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as h}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{TransparencyPassType as w}from\"../views/3d/webgl-engine/lib/basicInterfaces.js\";import{VertexAttribute as y}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function b(b){const x=new h,P=b.hasMultipassTerrain&&(b.output===o.Color||b.output===o.Alpha);x.include(t,b),b.output===o.Depth&&x.include(a,b);const{vertex:S,fragment:j}=x;return j.include(c),p(x,b),x.attributes.add(y.POSITION,\"vec3\"),x.attributes.add(y.UV0,\"vec2\"),x.attributes.add(y.AUXPOS1,\"vec3\"),x.varyings.add(\"vColor\",\"vec4\"),x.varyings.add(\"vpos\",\"vec3\"),x.varyings.add(\"vUV\",\"vec2\"),x.varyings.add(\"vSize\",\"float\"),x.varyings.add(\"linearDepth\",\"float\"),P&&x.varyings.add(\"depth\",\"float\"),S.code.add(f`#define PERPENDICULAR(v) vec2(v.y, -v.x)\nfloat interp(float ncp, vec4 a, vec4 b) {\nreturn (-ncp - a.z) / (b.z - a.z);\n}`),S.uniforms.add([new d(\"nearFar\",((e,r)=>r.camera.nearFar)),new v(\"viewport\",((e,r)=>r.camera.fullViewport))]),S.code.add(f`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`),S.code.add(f`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nprev = mix(pos, prev, interp(vnp, pos, prev));\n}\n}`),b.draped||(S.uniforms.add(new m(\"inverseProjectionMatrix\",((e,r)=>r.camera.inverseProjectionMatrix))),S.code.add(f`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`),S.code.add(f`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`),S.uniforms.add(new g(\"perScreenPixelRatio\",((e,r)=>r.camera.perScreenPixelRatio))),S.code.add(f`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${b.hasCap?\"\\n                if(prev.z > posLeft.z) {\\n                  vec2 diff = posLeft.xy - posRight.xy;\\n                  planeOrigin.xy += PERPENDICULAR(diff) / 2.0;\\n                }\\n              \":\"\"};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)),S.uniforms.add(new g(\"pixelRatio\",((e,r)=>r.camera.pixelRatio))),S.code.add(f`\n    void main(void) {\n      float coverage = 1.0;\n\n      // Check for special value of uv0.y which is used by the Renderer when graphics\n      // are removed before the VBO is recompacted. If this is the case, then we just\n      // project outside of clip space.\n      if (uv0.y == 0.0) {\n        // Project out of clip space\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      }\n      else {\n        float lineSize = getSize();\n        float lineWidth = max(lineSize, 1.0) * pixelRatio;\n\n        vec4 pos  = view * vec4(position.xyz, 1.0);\n        vec4 prev = view * vec4(auxpos1.xyz, 1.0);\n        clip(pos, prev);\n\n        vec4 posScreen = projectAndScale(pos);\n        vec4 prevScreen = projectAndScale(prev);\n\n        vec2 segment = posScreen.xy - prevScreen.xy;\n\n        // normalize vector along line segment\n        float segmentLen = length(segment);\n        segment = (segmentLen > 0.001) ? segment / segmentLen : vec2(0.0, 0.0);\n\n        // displace according to position in the texture\n        vec2 displacementDirU = PERPENDICULAR(segment);\n        vec2 displacementDirV = segment;\n\n        float displacementLen = ${f.float(e/r)} * lineWidth;\n\n        vec4 displacedPosScreen = posScreen;\n        displacedPosScreen.xy += uv0.x * displacementDirU * displacementLen + uv0.y * displacementDirV * displacementLen;\n  `),b.draped||S.code.add(f`vec3 posRight = inverseProject(posScreen + vec4(displacementDirU.xy, 0.0, 0.0) * lineWidth);\nvec3 posLeft = pos.xyz + (pos.xyz - posRight);\npos = toFront(displacedPosScreen, posLeft, posRight, prev.xyz, lineWidth);\ndisplacedPosScreen = projectAndScale(pos);`),S.code.add(f`\n        ${P?\"depth = pos.z;\":\"\"}\n        linearDepth = (-pos.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n\n        // Convert back into NDC\n        displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n        // Convert texture coordinate into [0,1] and cancel out perspective correct interpolation\n        vUV = (uv0 + 1.0) / 2.0;\n        vUV *= displacedPosScreen.w;\n\n        vSize = displacementLen;\n\n        vColor = getColor();\n        vColor.a *= coverage;\n\n        // Use camera space for slicing\n        vpos = pos.xyz;\n\n        gl_Position = displacedPosScreen;\n      }\n    }\n  `),P&&x.include(s,b),x.include(i,b),j.uniforms.add([new v(\"intrinsicColor\",(e=>e.color)),new u(\"tex\",(e=>e.texture))]),j.include(l),j.code.add(f`\n  void main() {\n    discardBySlice(vpos);\n    ${P?\"terrainDepthTest(gl_FragCoord, depth);\":\"\"}\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    // Offset texture coordinate s.t. we sample texel centers\n    float texelSize = ${f.float(1/e)};\n    vec2 samplePos = vUV * gl_FragCoord.w + vec2(0.5, -0.5) * texelSize;\n\n    // Evaluate sdf\n    float sdf = rgba2float(texture2D(tex, samplePos)) - 0.5;\n    float distance = sdf * vSize;\n\n    // Grow by a halfpixel to make sure the line is fully covered by the cross marker\n    // (otherwise there will be a halo if they are different colours)\n    distance -= 0.5;\n\n    finalColor.a *= clamp(0.5 - distance, 0.0, 1.0);\n\n    if (finalColor.a < ${f.float(n)}) {\n      discard;\n    }\n\n    ${b.output===o.Alpha?f`gl_FragColor = vec4(finalColor.a);`:\"\"}\n    ${b.output===o.Color?f`gl_FragColor = highlightSlice(finalColor, vpos);`:\"\"}\n    ${b.output===o.Color&&b.transparencyPassType===w.Color?\"gl_FragColor = premultiplyAlpha(gl_FragColor);\":\"\"}\n    ${b.output===o.Highlight?f`gl_FragColor = vec4(1.0);`:\"\"}\n    ${b.output===o.Depth?f`outputDepth(linearDepth);`:\"\"}\n  }\n  `),x}const x=Object.freeze(Object.defineProperty({__proto__:null,build:b},Symbol.toStringTag,{value:\"Module\"}));export{x as L,b};\n"],
  "mappings": "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",
  "names": ["n", "o", "i", "e", "t", "r", "b", "x", "e", "r", "o", "n", "i", "O"]
}
