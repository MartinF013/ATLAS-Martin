import {
  o
} from "./chunk-SXVJRHUR.js";
import {
  b as b2
} from "./chunk-VFZE4P73.js";
import "./chunk-HMUUQDIL.js";
import {
  i as i2
} from "./chunk-WRJQ7542.js";
import "./chunk-QFYBIFWB.js";
import {
  a as a2,
  c,
  f,
  i
} from "./chunk-7USXBUJ4.js";
import "./chunk-PZWU5EHT.js";
import {
  a,
  l
} from "./chunk-CQSGZXR7.js";
import {
  Ke
} from "./chunk-7LOJJ46D.js";
import "./chunk-VNR743PA.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-SWCA522B.js";
import "./chunk-YPIBZ3CH.js";
import "./chunk-XLCZFN6R.js";
import "./chunk-OMNBM2E4.js";
import "./chunk-WKHS6QIX.js";
import "./chunk-6O7ZZEV7.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-OBCAVCXI.js";
import "./chunk-RFOZTYJH.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-L2YBXQTH.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-4XBERLPX.js";
import "./chunk-SZPDY7KN.js";
import "./chunk-Y6YGVGFR.js";
import "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import "./chunk-MZX3HN4G.js";
import "./chunk-T47JAOQZ.js";
import {
  m
} from "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-RIWDMEW4.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-OG6CQEZJ.js";
import "./chunk-X5Z3DJQ4.js";
import "./chunk-BUWXVMJU.js";
import "./chunk-JT3LXQ47.js";
import {
  b
} from "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import "./chunk-D3XXPCBB.js";
import "./chunk-OWBMOIIV.js";
import "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import {
  B
} from "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  E,
  x
} from "./chunk-U3PSONS6.js";
import {
  s2 as s3
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s as s2
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  r,
  s2 as s,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/save/featureLayerUtils.js
var I = s2.getLogger("esri.layers.FeatureLayer");
var S = "Feature Service";
function g(e, t2) {
  return `Layer (title: ${e.title}, id: ${e.id}) of type '${e.declaredClass}' ${t2}`;
}
function j(e, a3) {
  if (a3.type !== S)
    throw new s3("feature-layer:portal-item-wrong-type", g(e, `should have portal item of type "${S}"`));
}
async function L(e) {
  if (await e.load(), a(e))
    throw new s3("feature-layer:save", g(e, "using an in-memory source cannot be saved to a portal item"));
}
function P(e, a3) {
  let r2 = e.messages.filter(({ type: e2 }) => "error" === e2).map(({ name: e2, message: a4, details: r3 }) => new s3(e2, a4, r3));
  if ((a3 == null ? void 0 : a3.ignoreUnsupported) && (r2 = r2.filter(({ name: e2 }) => "layer:unsupported" !== e2 && "symbol:unsupported" !== e2 && "symbol-layer:unsupported" !== e2 && "property:unsupported" !== e2 && "url:unsupported" !== e2)), r2.length > 0)
    throw new s3("feature-layer:save", "Failed to save feature layer due to unsupported or invalid content. See 'details.errors' for more detailed information", { errors: r2 });
}
async function J(e, t2, a3) {
  "beforeSave" in e && "function" == typeof e.beforeSave && await e.beforeSave();
  const r2 = e.write({}, t2);
  return P(t2, a3), r2;
}
function N(e) {
  const { layer: t2, layerJSON: a3 } = e;
  return t2.isTable ? { layers: [], tables: [a3] } : { layers: [a3], tables: [] };
}
function O(e) {
  i(e, f.JSAPI), e.typeKeywords && (e.typeKeywords = e.typeKeywords.filter((e2, t2, a3) => a3.indexOf(e2) === t2));
}
function E2(e) {
  const a3 = e.portalItem;
  if (!a3)
    throw I.error("save: requires the portalItem property to be set"), new s3("feature-layer:portal-item-not-set", g(e, "requires the portalItem property to be set"));
  if (!a3.loaded)
    throw new s3("feature-layer:portal-item-not-loaded", g(e, "cannot be saved to a portal item that does not exist or is inaccessible"));
  j(e, a3);
}
async function T(e, t2) {
  return /\/\d+\/?$/.test(e.url) ? N(t2[0]) : $(e, t2);
}
async function $(e, t2) {
  const { layer: { url: a3, customParameters: r2, apiKey: o2 } } = t2[0];
  let s4 = await e.fetchData("json");
  s4 && null != s4.layers && null != s4.tables || (s4 = await x2(s4, { url: a3, customParameters: r2, apiKey: o2 }, t2.map((e2) => e2.layer.layerId)));
  for (const l2 of t2)
    K(l2.layer, l2.layerJSON, s4);
  return s4;
}
async function x2(e, t2, a3) {
  var r2, o2;
  e || (e = {}), (r2 = e).layers || (r2.layers = []), (o2 = e).tables || (o2.tables = []);
  const { url: s4, customParameters: l2, apiKey: i3 } = t2, { serviceJSON: n, layersJSON: p } = await b2(s4, { customParameters: l2, apiKey: i3 }), c2 = A(e.layers, n.layers, a3), y = A(e.tables, n.tables, a3);
  e.layers = c2.itemResources, e.tables = y.itemResources;
  const d = [...c2.added, ...y.added], m2 = p ? [...p.layers, ...p.tables] : [];
  return await U(e, d, s4, m2), e;
}
function A(t2, a3, r2) {
  const o2 = s(t2, a3, (e, t3) => e.id === t3.id);
  t2 = t2.filter((e) => !o2.removed.some((t3) => t3.id === e.id));
  const s4 = o2.added.map(({ id: e }) => ({ id: e }));
  return s4.forEach(({ id: e }) => {
    t2.push({ id: e });
  }), { itemResources: t2, added: s4.filter(({ id: e }) => !r2.includes(e)) };
}
async function U(e, t2, a3, o2) {
  const s4 = t2.map(({ id: e2 }) => new Ke({ url: a3, layerId: e2, sourceJSON: o2.find(({ id: t3 }) => t3 === e2) }));
  await E(s4.map((e2) => e2.load())), s4.forEach((t3) => {
    const { layerId: a4, loaded: o3, defaultPopupTemplate: s5 } = t3;
    if (!o3 || t(s5))
      return;
    K(t3, { id: a4, popupInfo: s5.toJSON() }, e);
  });
}
function K(e, t2, a3) {
  e.isTable ? F(a3.tables, t2) : F(a3.layers, t2);
}
function F(e, t2) {
  const a3 = e.findIndex(({ id: e2 }) => e2 === t2.id);
  -1 === a3 ? e.push(t2) : e[a3] = t2;
}
function R(e) {
  const { portalItem: t2 } = e;
  return l(e) && !e.dynamicDataSource && !!(t2 == null ? void 0 : t2.loaded) && t2.type === S;
}
async function D(e) {
  if (!(e == null ? void 0 : e.length))
    throw new s3("feature-layer-utils-saveall:missing-parameters", "'layers' array should contain at least one feature layer");
  await Promise.all(e.map((e2) => e2.load()));
  for (const o2 of e)
    if (!R(o2))
      throw new s3("feature-layer-utils-saveall:invalid-parameters", `'layers' array should only contain layers or tables in a feature service loaded from 'Feature Service' item. ${g(o2, "does not conform")}`, { layer: o2 });
  const a3 = e.map((e2) => e2.portalItem.id);
  if (new Set(a3).size > 1)
    throw new s3("feature-layer-utils-saveall:invalid-parameters", "All layers in the 'layers' array should be loaded from the same portal item");
  const r2 = e.map((e2) => e2.layerId);
  if (new Set(r2).size !== r2.length)
    throw new s3("feature-layer-utils-saveall:invalid-parameters", "'layers' array should contain only one instance each of layer or table in a feature service");
}
function _(e, t2) {
  var a3, r2;
  let o2 = b.from(t2);
  return o2.id && (o2 = o2.clone(), o2.id = null), (a3 = o2).type ?? (a3.type = S), (r2 = o2).portal ?? (r2.portal = B.getDefault()), j(e, o2), o2;
}
async function q(e, t2) {
  const { url: a3, layerId: r2, title: s4, fullExtent: l2, isTable: i3 } = e, n = m(a3), u = r(n) && "FeatureServer" === n.serverType;
  t2.url = u ? a3 : `${a3}/${r2}`, t2.title || (t2.title = s4), t2.extent = null, !i3 && r(l2) && (t2.extent = await a2(l2)), c(t2, f.METADATA), c(t2, f.MULTI_LAYER), i(t2, f.SINGLE_LAYER), i3 && i(t2, f.TABLE), O(t2);
}
async function z(e, t2, a3) {
  const r2 = e.portal;
  await r2._signIn(), await r2.user.addItem({ item: e, data: t2, folder: a3 == null ? void 0 : a3.folder });
}
var C = x(M);
async function M(e, t2) {
  await L(e), E2(e);
  const a3 = e.portalItem, r2 = o(a3), o2 = await J(e, r2, t2), s4 = await T(a3, [{ layer: e, layerJSON: o2 }]);
  return O(a3), await a3.update({ data: s4 }), i2(r2), a3;
}
var Y = x(async (e, t2) => {
  await D(e);
  const a3 = e[0].portalItem, r2 = o(a3), o2 = await Promise.all(e.map((e2) => J(e2, r2, t2))), s4 = await T(a3, e.map((e2, t3) => ({ layer: e2, layerJSON: o2[t3] })));
  return O(a3), await a3.update({ data: s4 }), await Promise.all(e.slice(1).map((e2) => e2.portalItem.reload())), i2(r2), a3.clone();
});
var B2 = x(G);
async function G(e, t2, a3) {
  await L(e);
  const r2 = _(e, t2), o2 = o(r2), s4 = N({ layer: e, layerJSON: await J(e, o2, a3) });
  return await q(e, r2), await z(r2, s4, a3), e.portalItem = r2, i2(o2), r2;
}
export {
  C as save,
  Y as saveAll,
  B2 as saveAs
};
//# sourceMappingURL=featureLayerUtils-KERTFHZR.js.map
