{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{s as e}from\"../../../../../../chunks/vec4.js\";import{c as o}from\"../../../../../../chunks/vec4f64.js\";import{Float4PassUniform as r}from\"../../shaderModules/Float4PassUniform.js\";import{glsl as t}from\"../../shaderModules/interfaces.js\";import{Texture2DPassUniform as s}from\"../../shaderModules/Texture2DPassUniform.js\";function a(o,a){const l=o.fragment;a.receiveAmbientOcclusion?(l.uniforms.add([new s(\"ssaoTex\",((e,o)=>o.ssaoHelper.colorTexture)),new r(\"viewportPixelSz\",((o,r)=>e(i,r.camera.fullViewport[0],r.camera.fullViewport[1],1/r.ssaoHelper.width,1/r.ssaoHelper.height)))]),l.code.add(t`float evaluateAmbientOcclusion() {\nreturn 1.0 - texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n}\nfloat evaluateAmbientOcclusionInverse() {\nreturn texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n}`)):l.code.add(t`float evaluateAmbientOcclusion() { return 0.0; }\nfloat evaluateAmbientOcclusionInverse() { return 1.0; }`)}const i=o();export{a as EvaluateAmbientOcclusion};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{EvaluateAmbientLighting as i}from\"./EvaluateAmbientLighting.glsl.js\";import{EvaluateAmbientOcclusion as n}from\"./EvaluateAmbientOcclusion.glsl.js\";import{MainLighting as t}from\"./MainLighting.glsl.js\";import{PhysicallyBasedRendering as o}from\"./PhysicallyBasedRendering.glsl.js\";import{PBRMode as e}from\"./PhysicallyBasedRenderingParameters.glsl.js\";import{PiUtils as a}from\"./PiUtils.glsl.js\";import{BooleanPassUniform as r}from\"../../shaderModules/BooleanPassUniform.js\";import{Float3PassUniform as l}from\"../../shaderModules/Float3PassUniform.js\";import{FloatPassUniform as d}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as c}from\"../../shaderModules/interfaces.js\";import{ambientBoost as s}from\"../../../lighting/SceneLighting.js\";function m(m,g){const h=m.fragment;m.include(n,g),g.pbrMode!==e.Disabled&&m.include(o,g),m.include(i,g),h.constants.add(\"ambientBoostFactor\",\"float\",s),m.include(a),h.code.add(c`\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${g.pbrMode===e.Disabled?\"\":\"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `),h.uniforms.add(new l(\"lightingMainDirection\",((i,n)=>n.lighting.lightingMainDirection))),h.code.add(c`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${g.spherical?c`normalize(vPosWorld)`:c`vec3(0.0, 0.0, 1.0)`}, lightingMainDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `),h.uniforms.add([new d(\"lightingGlobalFactor\",((i,n)=>n.lighting.globalFactor)),new l(\"lightingMainIntensity\",((i,n)=>n.lighting.mainLight.intensity))]),h.code.add(c`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n}`),g.pbrMode===e.Disabled||g.pbrMode===e.WaterOnIntegratedMesh?(m.include(t,g),h.code.add(c`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)\n{\nvec3 mainLighting = evaluateMainLighting(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`)):g.pbrMode!==e.Normal&&g.pbrMode!==e.Schematic||(h.code.add(c`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 mainLightDirection = lightingMainDirection;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\ninputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`),h.code.add(c`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`),g.useFillLights?h.uniforms.add(new r(\"hasFillLights\",((i,n)=>n.enableFillLights))):h.constants.add(\"hasFillLights\",\"bool\",!1),h.code.add(c`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;\nvec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`),h.uniforms.add([new d(\"lightingSpecularStrength\",((i,n)=>n.lighting.mainLight.specularStrength)),new d(\"lightingEnvironmentStrength\",((i,n)=>n.lighting.mainLight.environmentStrength))]),h.code.add(c`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nvec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;\ninputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\ninputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`),h.code.add(c`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${g.pbrMode===e.Schematic?c`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`:c`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `))}export{m as EvaluateSceneLighting};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIsU,SAAS,EAAEA,IAAEC,IAAE;AAAC,QAAMC,KAAEF,GAAE;AAAS,EAAAC,GAAE,2BAAyBC,GAAE,SAAS,IAAI,CAAC,IAAI,EAAE,WAAW,CAACC,IAAEH,OAAIA,GAAE,WAAW,YAAa,GAAE,IAAIG,GAAE,mBAAmB,CAACH,IAAEI,OAAI,EAAE,GAAEA,GAAE,OAAO,aAAa,CAAC,GAAEA,GAAE,OAAO,aAAa,CAAC,GAAE,IAAEA,GAAE,WAAW,OAAM,IAAEA,GAAE,WAAW,MAAM,CAAE,CAAC,CAAC,GAAEF,GAAE,KAAK,IAAIG;AAAA;AAAA;AAAA;AAAA;AAAA,EAKvlB,KAAGH,GAAE,KAAK,IAAIG;AAAA,wDACwC;AAAC;AAAC,IAAM,IAAE,EAAE;;;ACN+qB,SAASC,GAAEA,IAAE,GAAE;AAAC,QAAM,IAAEA,GAAE;AAAS,EAAAA,GAAE,QAAQ,GAAE,CAAC,GAAE,EAAE,YAAU,EAAE,YAAUA,GAAE,QAAQC,IAAE,CAAC,GAAED,GAAE,QAAQ,GAAE,CAAC,GAAE,EAAE,UAAU,IAAI,sBAAqB,SAAQE,EAAC,GAAEF,GAAE,QAAQ,CAAC,GAAE,EAAE,KAAK,IAAIC;AAAA;AAAA;AAAA,MAG75B,EAAE,YAAU,EAAE,WAAS,KAAG;AAAA,GAC7B,GAAE,EAAE,SAAS,IAAI,IAAI,EAAE,yBAAyB,CAACE,IAAEF,OAAIA,GAAE,SAAS,qBAAsB,CAAC,GAAE,EAAE,KAAK,IAAIA;AAAA;AAAA,yBAEhF,EAAE,YAAUA,2BAAwBA;AAAA;AAAA;AAAA,GAG1D,GAAE,EAAE,SAAS,IAAI,CAAC,IAAI,EAAE,wBAAwB,CAACE,IAAEF,OAAIA,GAAE,SAAS,YAAa,GAAE,IAAI,EAAE,yBAAyB,CAACE,IAAEF,OAAIA,GAAE,SAAS,UAAU,SAAU,CAAC,CAAC,GAAE,EAAE,KAAK,IAAIA;AAAA;AAAA;AAAA,EAGtK,GAAE,EAAE,YAAU,EAAE,YAAU,EAAE,YAAU,EAAE,yBAAuBD,GAAE,QAAQI,IAAE,CAAC,GAAE,EAAE,KAAK,IAAIH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASzF,KAAG,EAAE,YAAU,EAAE,UAAQ,EAAE,YAAU,EAAE,cAAY,EAAE,KAAK,IAAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wDAmBR,GAAE,EAAE,KAAK,IAAIA;AAAA;AAAA,gGAE2B,GAAE,EAAE,gBAAc,EAAE,SAAS,IAAI,IAAI,EAAE,iBAAiB,CAACE,IAAEF,OAAIA,GAAE,gBAAiB,CAAC,IAAE,EAAE,UAAU,IAAI,iBAAgB,QAAO,KAAE,GAAE,EAAE,KAAK,IAAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yJAOlF,GAAE,EAAE,SAAS,IAAI,CAAC,IAAI,EAAE,4BAA4B,CAACE,IAAEF,OAAIA,GAAE,SAAS,UAAU,gBAAiB,GAAE,IAAI,EAAE,+BAA+B,CAACE,IAAEF,OAAIA,GAAE,SAAS,UAAU,mBAAoB,CAAC,CAAC,GAAE,EAAE,KAAK,IAAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oGAQ5P,GAAE,EAAE,KAAK,IAAIA;AAAA;AAAA;AAAA;AAAA;AAAA,UAKvG,EAAE,YAAU,EAAE,YAAUA,yHAAsHA;AAAA;AAAA;AAAA,KAGnJ;AAAE;",
  "names": ["o", "a", "l", "e", "r", "n", "m", "n", "c", "i", "o"]
}
