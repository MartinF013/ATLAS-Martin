import {
  n as n2
} from "./chunk-5SHHATAH.js";
import {
  u
} from "./chunk-6UGZAJSY.js";
import {
  An,
  en,
  rn,
  tn
} from "./chunk-PZWU5EHT.js";
import {
  d as d2
} from "./chunk-JJRJ6TV3.js";
import {
  j
} from "./chunk-T7BEWVV3.js";
import {
  I,
  V,
  j as j2,
  y as y2
} from "./chunk-5Z5455ZY.js";
import {
  d,
  g,
  n8 as n,
  s4 as s2,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  c,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/attributeEditing.js
var o = { setAttribute() {
}, rollback() {
}, commit() {
} };
var s3;
function i(e2, r2) {
  const i4 = r2.attributes[e2.objectIdField], a2 = e2.sessions.get(i4);
  if (a2)
    return a2;
  const u3 = m(r2.attributes), c6 = /* @__PURE__ */ new Set();
  if (null == i4)
    return o;
  const f2 = e2.attributeOverrides.createInteractiveEditSession(i4), l2 = /* @__PURE__ */ new Map(), d5 = (t2, e3) => {
    const n3 = l2.get(t2);
    if (null == n3) {
      const n4 = e3.indexOf(i4);
      return l2.set(t2, n4), n4;
    }
    return n3;
  };
  let I3 = s3.EDITING;
  const b = { setAttribute(t2, o2) {
    if (I3 !== s3.EDITING)
      return;
    const i5 = e2.fieldsIndex.get(t2);
    if (t(i5))
      return;
    const a3 = e2.attributeStorageInfo.findIndex((t3) => t3.name === i5.name);
    if (a3 < 0)
      return;
    f2.set(a3, o2);
    const u4 = e2.attributeStorageInfo[a3];
    let l3 = false;
    c6.add(t2), e2.forEachNode((t3, n3) => {
      const s4 = d5(t3, n3);
      if (-1 === s4)
        return;
      const i6 = e2.getAttributeData(t3.index);
      if (i6) {
        const n4 = i6[u4.name];
        n4 && (n4[s4] = o2, e2.setAttributeData(t3.index, i6, r2), l3 = true);
      }
    }), l3 && e2.clearMemCache();
  }, rollback() {
    if (I3 === s3.EDITING) {
      for (const t2 of c6)
        this.setAttribute(t2, u3[t2]);
      f2.rollback(), I3 = s3.ROLLED_BACK, e2.sessions.delete(i4);
    }
  }, commit() {
    I3 === s3.EDITING && (f2.commit(), I3 = s3.COMMITTED, e2.sessions.delete(i4));
  } };
  return e2.sessions.set(i4, b), b;
}
function a(t2, n3) {
  const r2 = u2(t2, n3);
  if (0 === r2.size)
    return;
  const o2 = /* @__PURE__ */ new Map();
  for (let e2 = 0; e2 < t2.attributeStorageInfo.length; e2++)
    o2.set(t2.attributeStorageInfo[e2].name, e2);
  let s4 = false;
  r2.forEach((n4, r3) => {
    const i4 = t2.getAttributeData(r3);
    let a2 = false;
    n4.forEach((n5, r4) => {
      const u3 = r(i4) ? i4[r4] : null, c6 = o2.get(r4);
      for (const { featureIndex: e2, value: o3, featureId: i5 } of n5)
        u3 && (u3[e2] = o3, a2 = true, s4 = true), t2.attributeOverrides.updateValue(i5, c6, o3);
    }), a2 && t2.setAttributeData(r3, i4, null);
  }), s4 && t2.clearMemCache();
}
function u2(t2, e2) {
  const n3 = e2.edits.updateFeatures;
  if (!n3 || 0 === n3.length)
    return new I2();
  const o2 = l(e2), s4 = new I2(), i4 = /* @__PURE__ */ new Map();
  for (let r2 = 0; r2 < t2.attributeStorageInfo.length; r2++)
    i4.set(t2.attributeStorageInfo[r2].name, r2);
  const a2 = t2.fieldsIndex, u3 = t2.objectIdField, f2 = n3.filter((t3) => {
    const e3 = n2(a2, t3.attributes, u3);
    return o2.has(e3);
  });
  return t2.forEachNode((e3, n4) => {
    const o3 = new Set(n4);
    for (const i5 of f2) {
      const f3 = n2(a2, i5.attributes, u3);
      if (!o3.has(f3))
        continue;
      const l2 = n4.indexOf(f3);
      for (const n5 in i5.attributes) {
        const r2 = t2.fieldsIndex.normalizeFieldName(n5), o4 = c2(s4, e3.index, r2), a3 = i5.attributes[n5];
        o4.push({ featureIndex: l2, featureId: f3, value: a3 });
      }
    }
  }), s4;
}
function c2(t2, e2, n3) {
  const r2 = f(t2, e2), o2 = r2.get(n3);
  if (o2)
    return o2;
  const s4 = new Array();
  return r2.set(n3, s4), s4;
}
function f(t2, e2) {
  const n3 = t2.get(e2);
  if (n3)
    return n3;
  const r2 = new d3();
  return t2.set(e2, r2), r2;
}
function l(t2) {
  const e2 = /* @__PURE__ */ new Set();
  if (!t2.updatedFeatures)
    return e2;
  for (const n3 of t2.updatedFeatures)
    null != n3.objectId && null == n3.error && e2.add(n3.objectId);
  return e2;
}
!function(t2) {
  t2[t2.EDITING = 0] = "EDITING", t2[t2.ROLLED_BACK = 1] = "ROLLED_BACK", t2[t2.COMMITTED = 2] = "COMMITTED";
}(s3 || (s3 = {}));
var d3 = Map;
var I2 = Map;

// node_modules/@arcgis/core/views/3d/layers/support/fieldProperties.js
function i2() {
  return { requiredFields: { type: [String], readOnly: true }, availableFields: { type: [String], readOnly: true, get: function() {
    const { layer: i4, layer: { fieldsIndex: t2 }, requiredFields: l2 } = this;
    return i4.outFields ? y2(t2, [...I(t2, i4.outFields), ...l2]) : y2(t2, l2);
  } } };
}

// node_modules/@arcgis/core/core/AsyncUpdate.js
var i3 = (e2) => {
  let a2 = class extends e2 {
    constructor() {
      super(...arguments), this._numUpdating = 0, this.asyncUpdateState = /* @__PURE__ */ new Map();
    }
    get updating() {
      return this._numUpdating > 0;
    }
    autoUpdateAsync(t2, e3) {
      return p((e4) => this._updateAsync(t2, e4), e3);
    }
    async _updateAsync(t2, e3) {
      if (!this._startAsyncUpdate(t2)) {
        try {
          const s4 = await e3();
          this._set(t2, s4);
        } catch (a3) {
          s.getLogger(this.declaredClass).warn(`Async update of "${String(t2)}" failed. Async update functions should not throw exceptions.`);
        }
        this._endAsyncUpdate(t2) && this._updateAsync(t2, e3);
      }
    }
    _startAsyncUpdate(t2) {
      const e3 = this.asyncUpdateState.get(t2) ?? c3.None;
      return e3 & c3.Updating ? (this.asyncUpdateState.set(t2, e3 | c3.Invalidated), true) : (++this._numUpdating, this.asyncUpdateState.set(t2, e3 | c3.Updating), false);
    }
    _endAsyncUpdate(t2) {
      --this._numUpdating;
      const e3 = (this.asyncUpdateState.get(t2) ?? c3.None) & ~c3.Updating;
      return e3 & c3.Invalidated ? (this.asyncUpdateState.set(t2, e3 & ~c3.Invalidated), true) : (this.asyncUpdateState.set(t2, e3), false);
    }
  };
  return e([d({ readOnly: true })], a2.prototype, "updating", null), e([d()], a2.prototype, "_numUpdating", void 0), a2 = e([n("esri.core.AsyncUpdate")], a2), a2;
};
var c3;
function p(t2, e2) {
  const s4 = () => {
    i4 && !c6 && t2(n3);
  }, n3 = () => {
    if (!i4 || c6)
      return e2();
    i4.clear(), c6 = true;
    const t3 = g(i4, e2);
    return c6 = false, t3;
  }, r2 = () => {
    i4 && (i4.destroy(), i4 = null);
  };
  let i4 = new s2(s4), c6 = false;
  return t2(n3), { remove: r2 };
}
!function(t2) {
  t2[t2.None = 0] = "None", t2[t2.Updating = 1] = "Updating", t2[t2.Invalidated = 2] = "Invalidated";
}(c3 || (c3 = {}));
var d4 = class extends i3(y) {
};
d4 = e([n("esri.core.AsyncUpdate")], d4);

// node_modules/@arcgis/core/views/3d/layers/support/SceneLayerViewRequiredFields.js
var p2 = s.getLogger("esri.views.3d.layers.support.SceneLayerViewRequiredFields");
var c4 = class extends i3(d2) {
  constructor(e2) {
    super(e2);
  }
  get requiredFields() {
    const { layerView: { layer: { fieldsIndex: e2 }, definitionExpressionFields: r2 }, rendererFields: s4, labelingFields: t2, viewFilterFields: o2 } = this;
    return y2(e2, [...c(r2, []), ...c(s4, []), ...c(t2, []), ...c(o2, [])]);
  }
  initialize() {
    const e2 = this.layerView.layer;
    this.layer = e2, this.handles.add([this.autoUpdateAsync("rendererFields", () => {
      const { fieldsIndex: e3, renderer: r2 } = this.layer;
      return r2 ? y3((s4) => r2.collectRequiredFields(s4, e3)) : null;
    }), this.autoUpdateAsync("labelingFields", () => {
      const { layer: e3 } = this;
      return e3.labelsVisible ? y3((r2) => j2(r2, e3)) : null;
    }), this.autoUpdateAsync("viewFilterFields", () => {
      const { layer: e3, filter: r2 } = this.layerView;
      return y3((s4) => V(s4, e3, r2));
    })]);
  }
};
async function y3(e2) {
  const r2 = /* @__PURE__ */ new Set();
  try {
    return await e2(r2), Array.from(r2).sort();
  } catch (s4) {
    return p2.error(s4), null;
  }
}
e([d()], c4.prototype, "layerView", void 0), e([d()], c4.prototype, "layer", void 0), e([d()], c4.prototype, "requiredFields", null), e([d()], c4.prototype, "rendererFields", void 0), e([d()], c4.prototype, "labelingFields", void 0), e([d()], c4.prototype, "viewFilterFields", void 0), c4 = e([n("esri.views.3d.layers.support.SceneLayerViewRequiredFields")], c4);

// node_modules/@arcgis/core/views/layers/SceneLayerView.js
var c5 = s.getLogger("esri.views.layers.SceneLayerView");
var g2 = class extends u {
  constructor() {
    super(...arguments), this.layer = null, this.filter = null, this._geometryEngine = null, this._projectionEngineLoaded = false;
  }
  get availableFields() {
    return [];
  }
  get maximumNumberOfFeatures() {
    return 0;
  }
  set maximumNumberOfFeatures(e2) {
    throw new Error("Not implemented");
  }
  get maximumNumberOfFeaturesExceeded() {
    return false;
  }
  get layerFilter() {
    const e2 = this.layer.filter;
    if (t(e2) || e2.geometries.length < 1)
      return null;
    const r2 = this._geometryEngine;
    if (t(r2) || !this._projectionEngineLoaded && this._filterNeedsProjectionEngine)
      return null;
    try {
      let t2 = r2.simplify(e2.geometries.getItemAt(0));
      const o2 = t2.spatialReference;
      for (let i4 = 1; i4 < e2.geometries.length; i4++) {
        let n3 = r2.simplify(e2.geometries.getItemAt(i4));
        n3.spatialReference.equals(o2) || (n3 = rn(n3, o2)), t2 = r2.union(t2, n3);
      }
      return { spatialRelationship: e2.spatialRelationship, geometry: t2 };
    } catch {
      return c5.warnOncePerTick("Failed to merge scene filter geometries. Layer mask will be ignored."), null;
    }
  }
  get _filterNeedsProjectionEngine() {
    const e2 = this.layer.filter;
    if (t(e2) || e2.geometries.length <= 1)
      return false;
    const r2 = e2.geometries.getItemAt(0).spatialReference;
    return e2.geometries.some(({ spatialReference: e3 }) => !e3.equals(r2) && !An(e3, r2));
  }
  get layerFilterUpdating() {
    return r(this.layer.filter) && this.layer.filter.geometries.length && (!this._geometryEngine || !this._projectionEngineLoaded && this._filterNeedsProjectionEngine);
  }
  initialize() {
    j(() => !this._geometryEngine && r(this.layer.filter) && this.layer.filter.geometries.length).then(async () => this._geometryEngine = await import("./@arcgis_core_geometry_geometryEngine.js")), this._projectionEngineLoaded = en(), j(() => !this._projectionEngineLoaded && this._filterNeedsProjectionEngine).then(async () => {
      await tn(), this._projectionEngineLoaded = true;
    });
  }
  highlight(e2) {
    throw new Error("Not implemented");
  }
  queryFeatures(e2, r2) {
    throw new Error("Not implemented");
  }
  queryObjectIds(e2, r2) {
    throw new Error("Not implemented");
  }
  queryFeatureCount(e2, r2) {
    throw new Error("Not implemented");
  }
  createQuery() {
    throw new Error("Not implemented");
  }
  queryExtent(e2, r2) {
    throw new Error("Not implemented");
  }
};
e([d()], g2.prototype, "layer", void 0), e([d()], g2.prototype, "availableFields", null), e([d()], g2.prototype, "maximumNumberOfFeatures", null), e([d({ readOnly: true })], g2.prototype, "maximumNumberOfFeaturesExceeded", null), e([d()], g2.prototype, "filter", void 0), e([d({ readOnly: true })], g2.prototype, "layerFilter", null), e([d()], g2.prototype, "_geometryEngine", void 0), e([d()], g2.prototype, "_projectionEngineLoaded", void 0), e([d()], g2.prototype, "_filterNeedsProjectionEngine", null), e([d()], g2.prototype, "layerFilterUpdating", null);

export {
  i,
  a,
  i2,
  c4 as c,
  g2 as g
};
//# sourceMappingURL=chunk-BIG2N653.js.map
