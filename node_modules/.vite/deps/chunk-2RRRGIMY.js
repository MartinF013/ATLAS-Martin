import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";

// node_modules/@arcgis/core/libs/maquette/h.js
var e2 = (e3) => ({ vnodeSelector: "", properties: void 0, children: void 0, text: e3.toString(), domNode: null });
var r = (t2, o, n3) => {
  for (let l2 = 0, i = o.length; l2 < i; l2++) {
    let i2 = o[l2];
    Array.isArray(i2) ? r(t2, i2, n3) : null != i2 && false !== i2 && ("string" == typeof i2 && (i2 = e2(i2)), n3.push(i2));
  }
};
function t(e3, t2, o) {
  if (Array.isArray(t2))
    o = t2, t2 = void 0;
  else if (t2 && ("string" == typeof t2 || t2.hasOwnProperty("vnodeSelector")) || o && ("string" == typeof o || o.hasOwnProperty("vnodeSelector")))
    throw new Error("h called with invalid arguments");
  let n3, l2;
  return o && 1 === o.length && "string" == typeof o[0] ? n3 = o[0] : o && (l2 = [], r(e3, o, l2), 0 === l2.length && (l2 = void 0)), { vnodeSelector: e3, properties: t2, children: l2, text: "" === n3 ? void 0 : n3, domNode: null };
}

// node_modules/@arcgis/core/views/overlay/TextOverlayItem.js
var s = { bottom: "esri-text-overlay-item-anchor-bottom", "bottom-right": "esri-text-overlay-item-anchor-bottom-right", "bottom-left": "esri-text-overlay-item-anchor-bottom-left", top: "esri-text-overlay-item-anchor-top", "top-right": "esri-text-overlay-item-anchor-top-right", "top-left": "esri-text-overlay-item-anchor-top-left", center: "esri-text-overlay-item-anchor-center", right: "esri-text-overlay-item-anchor-right", left: "esri-text-overlay-item-anchor-left" };
var l = class extends y {
  constructor(t2) {
    super(t2), this.x = 0, this.y = 0, this.text = "-", this.fontSize = 14, this.anchor = "center", this.visible = true, this._backgroundColor = "rgba(0, 0, 0, 0.6)", this._textColor = "white", this._textShadowColor = [0, 0, 0], this._textShadowSize = 1;
  }
  get position() {
    return [this.x, this.y];
  }
  set position(t2) {
    this._set("x", t2[0]), this._set("y", t2[1]);
  }
  get _textShadow() {
    const [t2, e3, o] = this._textColor;
    return `0 0 ${this._textShadowSize}px rgb(${t2}, ${e3}, ${o})`;
  }
  get _padding() {
    return 0.5 * this.fontSize;
  }
  get _borderRadius() {
    return this._padding;
  }
  render() {
    return t("div", { classes: this._cssClasses(), styles: { left: Math.floor(this.x) + "px", top: Math.floor(this.y) + "px", visibility: this.visible ? "visible" : "hidden", fontSize: this.fontSize + "px", lineHeight: this.fontSize + "px", backgroundColor: this._backgroundColor, color: this._textColor, padding: this._padding + "px", borderRadius: this._borderRadius + "px", textShadow: this._textShadow } }, [this.text]);
  }
  renderCanvas(t2) {
    if (!this.visible)
      return;
    const e3 = t2.font.replace(/^(.*?)px/, "");
    t2.font = `${this.fontSize}px ${e3}`;
    const o = this._padding, i = this._borderRadius, r2 = t2.measureText(this.text).width, s2 = this.fontSize, l2 = n2[this.anchor];
    t2.textAlign = "center", t2.textBaseline = "middle";
    const h2 = r2 + 2 * o, a2 = s2 + 2 * o, x = this.x + l2.x * h2, p = this.y + l2.y * a2;
    this._roundedRect(t2, x, p, h2, a2, i), t2.fillStyle = this._backgroundColor, t2.fill();
    const d2 = this.x + (l2.x + 0.5) * h2, c = this.y + (l2.y + 0.5) * a2;
    this._renderTextShadow(t2, this.text, d2, c), t2.fillStyle = this._textColor, t2.fillText(this.text, d2, c);
  }
  _renderTextShadow(t2, e3, o, i) {
    t2.lineJoin = "miter", t2.fillStyle = `rgba(${this._textShadowColor[0]}, ${this._textShadowColor[1]}, ${this._textShadowColor[2]}, ${1 / h.length})`;
    const r2 = this._textShadowSize;
    for (const [s2, l2] of h)
      t2.fillText(e3, o + r2 * s2, i + r2 * l2);
  }
  _roundedRect(t2, e3, o, i, r2, s2) {
    t2.beginPath(), t2.moveTo(e3, o + s2), t2.arcTo(e3, o, e3 + s2, o, s2), t2.lineTo(e3 + i - s2, o), t2.arcTo(e3 + i, o, e3 + i, o + s2, s2), t2.lineTo(e3 + i, o + r2 - s2), t2.arcTo(e3 + i, o + r2, e3 + i - s2, o + r2, s2), t2.lineTo(e3 + s2, o + r2), t2.arcTo(e3, o + r2, e3, o + r2 - s2, s2), t2.closePath();
  }
  _cssClasses() {
    const t2 = { "esri-text-overlay-item": true };
    for (const e3 in s)
      t2[s[e3]] = this.anchor === e3;
    return t2;
  }
};
e([d()], l.prototype, "x", void 0), e([d()], l.prototype, "y", void 0), e([d()], l.prototype, "position", null), e([d()], l.prototype, "text", void 0), e([d()], l.prototype, "fontSize", void 0), e([d()], l.prototype, "anchor", void 0), e([d()], l.prototype, "visible", void 0), e([d()], l.prototype, "_backgroundColor", void 0), e([d()], l.prototype, "_textColor", void 0), e([d()], l.prototype, "_textShadowColor", void 0), e([d()], l.prototype, "_textShadowSize", void 0), e([d()], l.prototype, "_textShadow", null), e([d()], l.prototype, "_padding", null), e([d()], l.prototype, "_borderRadius", null), l = e([n("esri.views.overlay.TextOverlayItem")], l);
var n2 = { bottom: { x: -0.5, y: -1, textAlign: "center", textBaseline: "bottom" }, "bottom-left": { x: 0, y: -1, textAlign: "left", textBaseline: "bottom" }, "bottom-right": { x: -1, y: -1, textAlign: "right", textBaseline: "bottom" }, center: { x: -0.5, y: -0.5, textAlign: "center", textBaseline: "middle" }, left: { x: 0, y: -0.5, textAlign: "left", textBaseline: "middle" }, right: { x: -1, y: -0.5, textAlign: "right", textBaseline: "middle" }, top: { x: -0.5, y: 0, textAlign: "center", textBaseline: "top" }, "top-left": { x: 0, y: 0, textAlign: "left", textBaseline: "top" }, "top-right": { x: -1, y: 0, textAlign: "right", textBaseline: "top" } };
var h = [];
{
  const t2 = 16;
  for (let e3 = 0; e3 < 360; e3 += 360 / t2)
    h.push([Math.cos(Math.PI * e3 / 180), Math.sin(Math.PI * e3 / 180)]);
}
var a = l;

export {
  t,
  a
};
//# sourceMappingURL=chunk-2RRRGIMY.js.map
