import {
  s as s2
} from "./chunk-PZFKIJU3.js";
import {
  e as e3
} from "./chunk-2A3F5J6D.js";
import {
  i,
  n as n3,
  o as o3
} from "./chunk-B3IXFXV6.js";
import {
  i as i2
} from "./chunk-ODYLXHP4.js";
import {
  d
} from "./chunk-OYNEZ5VG.js";
import {
  e as e4
} from "./chunk-R67CDTDF.js";
import {
  s
} from "./chunk-ZV3LDRB3.js";
import {
  e as e5
} from "./chunk-YSWURJZW.js";
import {
  a
} from "./chunk-767LZ6IM.js";
import {
  r as r2
} from "./chunk-FCDEMPPS.js";
import {
  o as o2
} from "./chunk-TEJEYVH4.js";
import {
  u
} from "./chunk-IJHFAZOW.js";
import {
  c
} from "./chunk-DMGVDNFD.js";
import {
  d as d2
} from "./chunk-YAQGRU5B.js";
import {
  o as o4
} from "./chunk-BMA2CXVS.js";
import {
  e as e2
} from "./chunk-46N7XS5M.js";
import {
  e
} from "./chunk-LGILR4HN.js";
import {
  U
} from "./chunk-EEJIELE6.js";
import {
  n as n2
} from "./chunk-NAB3NF54.js";
import {
  o as o5,
  r
} from "./chunk-MHB3L22D.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  o
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function e6(e7) {
  e7.vertex.code.add(n2`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js
function m(r3, m2) {
  m2.instanced && m2.instancedDoublePrecision && (r3.attributes.add(O.MODELORIGINHI, "vec3"), r3.attributes.add(O.MODELORIGINLO, "vec3"), r3.attributes.add(O.MODEL, "mat3"), r3.attributes.add(O.MODELNORMAL, "mat3"));
  const u2 = r3.vertex;
  m2.instancedDoublePrecision && (u2.include(i2, m2), u2.uniforms.add(new o4("viewOriginHi", (r4, i4) => o5(o(l, i4.camera.viewInverseTransposeMatrix[3], i4.camera.viewInverseTransposeMatrix[7], i4.camera.viewInverseTransposeMatrix[11]), l))), u2.uniforms.add(new o4("viewOriginLo", (r4, i4) => r(o(l, i4.camera.viewInverseTransposeMatrix[3], i4.camera.viewInverseTransposeMatrix[7], i4.camera.viewInverseTransposeMatrix[11]), l)))), u2.code.add(n2`
    vec3 calculateVPos() {
      ${m2.instancedDoublePrecision ? "return model * localPosition().xyz;" : "return localPosition().xyz;"}
    }
    `), u2.code.add(n2`
    vec3 subtractOrigin(vec3 _pos) {
      ${m2.instancedDoublePrecision ? n2`
          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);
          return _pos - originDelta;` : "return vpos;"}
    }
    `), u2.code.add(n2`
    vec3 dpNormal(vec4 _normal) {
      ${m2.instancedDoublePrecision ? "return normalize(modelNormal * _normal.xyz);" : "return normalize(_normal.xyz);"}
    }
    `), m2.output === o2.Normal && (u2.uniforms.add(new e2("viewNormal", (e7, r4) => r4.camera.viewInverseTransposeMatrix)), u2.code.add(n2`
    vec3 dpNormalView(vec4 _normal) {
      ${m2.instancedDoublePrecision ? "return normalize((viewNormal * vec4(modelNormal * _normal.xyz, 1.0)).xyz);" : "return normalize((viewNormal * _normal).xyz);"}
    }
    `)), m2.hasVertexTangents && u2.code.add(n2`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${m2.instancedDoublePrecision ? "return vec4(modelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}

    }
    `);
}
var l = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i3(i4, t) {
  t.hasSymbolColors ? (i4.include(e3), i4.attributes.add(O.SYMBOLCOLOR, "vec4"), i4.varyings.add("colorMixMode", "mediump float"), i4.vertex.code.add(n2`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`)) : (i4.fragment.uniforms.add(new e4("colorMixMode", (o6) => U[o6.colorMixMode])), i4.vertex.code.add(n2`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function f(f2, h) {
  const g = f2.vertex.code, x = f2.fragment.code, j = h.hasModelTransformation;
  h.output !== o2.Depth && h.output !== o2.Shadow || (d2(f2, h), f2.include(r2, { linearDepth: true, hasModelTransformation: j }), f2.include(d, h), f2.include(s, h), f2.include(e5, h), f2.include(u, h), f2.vertex.uniforms.add(new e("nearFar", (o6, r3) => r3.camera.nearFar)), f2.varyings.add("depth", "float"), h.hasColorTexture && f2.fragment.uniforms.add(new c("tex", (o6) => o6.texture)), g.add(n2`
      void main(void) {
        vpos = calculateVPos();
        vpos = subtractOrigin(vpos);
        vpos = addVerticalOffset(vpos, localOrigin);
        gl_Position = transformPositionWithDepth(proj, view, ${j ? "model," : ""} vpos, nearFar, depth);
        forwardTextureCoordinates();
      }
    `), f2.include(s2, h), x.add(n2`
      void main(void) {
        discardBySlice(vpos);
        ${h.hasColorTexture ? n2`
        vec4 texColor = texture2D(tex, vuv0);
        discardOrAdjustAlpha(texColor);` : ""}
        outputDepth(depth);
      }
    `)), h.output === o2.Normal && (d2(f2, h), f2.include(r2, { linearDepth: false, hasModelTransformation: j }), f2.include(o3, h), f2.include(n3, h), f2.include(d, h), f2.include(s, h), h.hasColorTexture && f2.fragment.uniforms.add(new c("tex", (o6) => o6.texture)), f2.varyings.add("vPositionView", "vec3"), g.add(n2`
      void main(void) {
        vpos = calculateVPos();
        vpos = subtractOrigin(vpos);
        ${h.normalType === i.Attribute ? n2`
        vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));` : ""}
        vpos = addVerticalOffset(vpos, localOrigin);
        gl_Position = transformPosition(proj, view, ${j ? "model," : ""} vpos);
        forwardTextureCoordinates();
      }
    `), f2.include(u, h), f2.include(s2, h), x.add(n2`
      void main() {
        discardBySlice(vpos);
        ${h.hasColorTexture ? n2`
        vec4 texColor = texture2D(tex, vuv0);
        discardOrAdjustAlpha(texColor);` : ""}

        ${h.normalType === i.ScreenDerivative ? n2`
            vec3 normal = screenDerivativeNormal(vPositionView);` : n2`
            vec3 normal = normalize(vNormalWorld);
            if (gl_FrontFacing == false) normal = -normal;`}
        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
      }
    `)), h.output === o2.Highlight && (d2(f2, h), f2.include(r2, { linearDepth: false, hasModelTransformation: j }), f2.include(d, h), f2.include(s, h), h.hasColorTexture && f2.fragment.uniforms.add(new c("tex", (o6) => o6.texture)), g.add(n2`
      void main(void) {
        vpos = calculateVPos();
        vpos = subtractOrigin(vpos);
        vpos = addVerticalOffset(vpos, localOrigin);
        gl_Position = transformPosition(proj, view, ${j ? "model," : ""} vpos);
        forwardTextureCoordinates();
      }
    `), f2.include(u, h), f2.include(s2, h), f2.include(a), x.add(n2`
      void main() {
        discardBySlice(vpos);
        ${h.hasColorTexture ? n2`
        vec4 texColor = texture2D(tex, vuv0);
        discardOrAdjustAlpha(texColor);` : ""}
        outputHighlight();
      }
    `));
}

export {
  e6 as e,
  m,
  i3 as i,
  f
};
//# sourceMappingURL=chunk-PZHH54V6.js.map
