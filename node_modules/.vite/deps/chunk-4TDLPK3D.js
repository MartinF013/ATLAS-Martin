import {
  n
} from "./chunk-U7B2WKBH.js";
import {
  e,
  u
} from "./chunk-NWRK6QLX.js";
import {
  o
} from "./chunk-BPZGJQOB.js";
import {
  j
} from "./chunk-ZOKX6UGH.js";

// node_modules/@arcgis/core/renderers/support/heatmapUtils.js
var a = 2.4;
function i(t) {
  return e(t * a);
}
function f(t) {
  return u(t) / a;
}
function c(r, n2, e2, a2) {
  let { color: i2, ratio: f2 } = n2, { color: c2, ratio: s2 } = e2;
  if (s2 === f2) {
    const t = 1e-6;
    1 === s2 ? f2 -= t : s2 += t;
  }
  const u2 = o((a2 - f2) / (s2 - f2), 0, 1);
  j(r, i2.toArray(), c2.toArray(), u2);
}
function s(t) {
  const r = 512, n2 = new Uint8ClampedArray(4 * r);
  if (t = t.filter(({ ratio: t2 }) => t2 >= 0 && t2 <= 1).sort((t2, r2) => t2.ratio - r2.ratio).map(({ color: t2, ratio: r2 }) => ({ color: t2, ratio: Math.max(r2, 1e-3) })), t.length < 1)
    return n2;
  let o2 = t[0], a2 = t[0], i2 = 1;
  const f2 = n();
  for (let e2 = 0; e2 < r; e2++) {
    const s2 = (e2 + 0.5) / r;
    for (; s2 > a2.ratio && i2 < t.length; )
      o2 = a2, a2 = t[i2++];
    c(f2, o2, a2, s2), n2.set(f2, 4 * e2);
  }
  return n2;
}
function l(t, r, o2, e2) {
  const { radius: a2, fieldOffset: i2, field: f2 } = r, c2 = Math.round(u(a2)), s2 = new Float64Array(o2 * e2);
  let u2, l2 = Number.NEGATIVE_INFINITY;
  const m2 = x(f2, i2), h2 = /* @__PURE__ */ new Set();
  for (const n2 of t) {
    const t2 = n2.getCursor();
    for (; t2.next(); ) {
      const r2 = t2.getObjectId();
      if (h2.has(r2))
        continue;
      h2.add(r2);
      const n3 = t2.readLegacyPointGeometry(), a3 = 128;
      if (n3.x < -a3 || n3.x >= o2 + a3 || n3.y < -a3 || n3.y > e2 + a3)
        continue;
      const i3 = +m2(t2), f3 = Math.max(0, Math.round(n3.x) - c2), d2 = Math.max(0, Math.round(n3.y) - c2), x2 = Math.min(e2, Math.round(n3.y) + c2), M = Math.min(o2, Math.round(n3.x) + c2);
      for (let t3 = d2; t3 < x2; t3++)
        for (let r3 = f3; r3 < M; r3++) {
          const e3 = t3 * o2 + r3, a4 = y(n3.x - r3, n3.y - t3, c2);
          u2 = s2[e3] += a4 * i3, u2 > l2 && (l2 = u2);
        }
    }
  }
  return { matrix: s2.buffer, max: l2 };
}
function m(t, r, n2, o2, e2, a2) {
  t.canvas.width = t.canvas.height = r, t.clearRect(0, 0, r, r);
  const i2 = t.getImageData(0, 0, r, r);
  n2 && o2 && i2.data.set(new Uint8ClampedArray(h(r, n2, o2, e2, a2))), t.putImageData(i2, 0, 0);
}
function h(r, n2, o2, e2, a2) {
  const i2 = new Uint32Array(r * r), f2 = "buffer" in n2 ? n2 : new Float64Array(n2), c2 = "buffer" in o2 ? new Uint32Array(o2.buffer) : new Uint32Array(new Uint8Array(o2).buffer), s2 = c2.length / (a2 - e2);
  for (let u2 = 0; u2 < f2.length; u2++) {
    const r2 = f2[u2], n3 = Math.floor((r2 - e2) * s2);
    i2[u2] = c2[o(n3, 0, c2.length - 1)];
  }
  return i2.buffer;
}
function y(t, r, n2) {
  const o2 = Math.sqrt(t ** 2 + r ** 2) / n2;
  return o2 > 1 ? 0 : 3 / (Math.PI * n2 ** 2) * (1 - o2 ** 2) ** 2;
}
function d(t, r) {
  return "function" == typeof t ? t : t ? "string" == typeof r ? (r2) => -1 * +r2[t] : (n2) => +n2[t] + r : () => 1;
}
function x(t, r) {
  return null != t ? "string" == typeof r ? (r2) => -1 * +r2.readAttribute(t) : (n2) => +n2.readAttribute(t) + r : (t2) => 1;
}

export {
  a,
  i,
  f,
  s,
  l,
  m,
  y,
  d
};
//# sourceMappingURL=chunk-4TDLPK3D.js.map
