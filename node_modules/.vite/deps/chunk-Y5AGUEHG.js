import {
  e
} from "./chunk-R67CDTDF.js";
import {
  e as e2
} from "./chunk-AALA53RH.js";
import {
  c
} from "./chunk-DMGVDNFD.js";
import {
  o
} from "./chunk-A3QLZKCF.js";
import {
  a as a2
} from "./chunk-OYAHQ564.js";
import {
  a,
  i
} from "./chunk-I5UNY2WQ.js";
import {
  n as n2,
  t
} from "./chunk-NAB3NF54.js";
import {
  n
} from "./chunk-AIRC226G.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sUniform.js
var e3 = class extends i {
  constructor(r, e4, t2, i2) {
    switch (e4) {
      case a.Pass:
        return void super(r, "mat4", e4, (s, e5, i3) => s.setUniformMatrix4fv(r, t2(e5, i3)), i2);
      case a.Draw:
        return void super(r, "mat4", e4, (s, e5, i3) => s.setUniformMatrix4fv(r, t2(e5, i3)), i2);
    }
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js
var n3 = class extends t {
  constructor() {
    super(...arguments), this.origin = n();
  }
};
function h(e4, a3) {
  a3.receiveShadows && (e4.fragment.uniforms.add(new e3("shadowMapMatrix", a.Pass, (e5, a4) => a4.shadowMap.getShadowMapMatrices(e5.origin), 4)), v(e4));
}
function c2(e4, a3) {
  a3.receiveShadows && (e4.fragment.uniforms.add(new e3("shadowMapMatrix", a.Draw, (e5, a4) => a4.shadowMap.getShadowMapMatrices(e5.origin), 4)), v(e4));
}
function v(e4) {
  const i2 = e4.fragment;
  i2.include(a2), i2.uniforms.add([new c("shadowMapTex", (e5, a3) => a3.shadowMap.depthTexture), new e("numCascades", (e5, a3) => a3.shadowMap.numCascades), new e2("cascadeDistances", (e5, a3) => a3.shadowMap.cascadeDistances), new o("depthHalfPixelSz", (e5, a3) => 0.5 / a3.shadowMap.textureSize)]), i2.code.add(n2`int chooseCascade(float depth, out mat4 mat) {
vec4 distance = cascadeDistances;
int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;
mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];
return i;
}
vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
vec4 lv = mat * vec4(_vpos, 1.0);
lv.xy /= lv.w;
return 0.5 * lv.xyz + vec3(0.5);
}
vec2 cascadeCoordinates(int i, vec3 lvpos) {
return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;
}
float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {
return rgba2float(texture2D(_depthTex, uv));
}
float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {
return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;
}
float filterShadow(vec2 uv, vec3 lvpos, float halfPixelSize, sampler2D _depthTex) {
float texSize = 0.5 / halfPixelSize;
vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);
float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);
float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);
float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);
float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);
return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);
}
float readShadowMap(const in vec3 _vpos, float _linearDepth) {
mat4 mat;
int i = chooseCascade(_linearDepth, mat);
if (i >= numCascades) { return 0.0; }
vec3 lvpos = lightSpacePosition(_vpos, mat);
if (lvpos.z >= 1.0) { return 0.0; }
if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }
vec2 uv = cascadeCoordinates(i, lvpos);
return filterShadow(uv, lvpos, depthHalfPixelSz, shadowMapTex);
}`);
}

export {
  n3 as n,
  h,
  c2 as c
};
//# sourceMappingURL=chunk-Y5AGUEHG.js.map
