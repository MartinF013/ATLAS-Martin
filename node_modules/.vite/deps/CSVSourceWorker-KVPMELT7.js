import {
  a as a2,
  u as u2
} from "./chunk-NCMBCUFA.js";
import {
  u
} from "./chunk-4QVQG5LC.js";
import "./chunk-UQFAHV7T.js";
import {
  Y
} from "./chunk-COK4R22F.js";
import "./chunk-T6XN76GI.js";
import "./chunk-EZ4QR7V3.js";
import "./chunk-25Y2OKSP.js";
import "./chunk-EMETVH63.js";
import "./chunk-V56SVRSV.js";
import {
  f
} from "./chunk-XZHFGTRH.js";
import "./chunk-2I27THZD.js";
import "./chunk-X64NQ2GK.js";
import "./chunk-NVOCHKIH.js";
import "./chunk-DGELARKE.js";
import {
  t as t2
} from "./chunk-WN3KE5M2.js";
import "./chunk-KBCUY3VB.js";
import "./chunk-Z7BSDVJ3.js";
import {
  a
} from "./chunk-2KZBVPWA.js";
import "./chunk-CC32E45Q.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import {
  s as s3,
  t
} from "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import {
  ln
} from "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-CQ47VEUP.js";
import {
  d
} from "./chunk-FU5UMT3R.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-GRILTTJT.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import {
  P
} from "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-Y7FSCP47.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  Ut,
  j
} from "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import {
  y
} from "./chunk-YPZEGNLG.js";
import {
  E,
  c,
  k,
  k2
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  O,
  g
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/graphics/sources/csv/csv.js
var n = /^\s*"([\S\s]*)"\s*$/;
var t3 = /""/g;
var e = "\n";
var o = [",", " ", ";", "|", "	"];
function* c2(n3, t4, e2) {
  let o3 = 0;
  for (; o3 <= n3.length; ) {
    const c3 = n3.indexOf(t4, o3), i3 = n3.substring(o3, c3 > -1 ? c3 : void 0);
    o3 += i3.length + t4.length, e2 && !i3.trim() || (yield i3);
  }
}
function i(n3) {
  const t4 = n3.includes("\r\n") ? "\r\n" : e;
  return c2(n3, t4, true);
}
function r(n3, t4) {
  return c2(n3, t4, false);
}
function f2(n3) {
  const t4 = n3.trim();
  let e2 = 0, c3 = "";
  for (const i3 of o) {
    const n4 = t4.split(i3).length;
    n4 > e2 && (e2 = n4, c3 = i3);
  }
  return "" === c3 ? null : c3;
}
function* l(o3, c3, i3, f3 = () => /* @__PURE__ */ Object.create(null)) {
  let l3 = "", u4 = "", d3 = 0, g2 = f3(), x = 0;
  n:
    for (const h of o3) {
      const o4 = r(h, i3);
      for (const e2 of o4)
        if (l3 += u4 + e2, u4 = "", d3 += s4(e2), d3 % 2 == 0) {
          if (d3 > 0) {
            const e3 = n.exec(l3);
            if (!e3) {
              g2 = f3(), x = 0, l3 = "", d3 = 0;
              continue n;
            }
            g2[c3[x]] = e3[1].replace(t3, '"'), x++;
          } else
            g2[c3[x]] = l3, x++;
          l3 = "", d3 = 0;
        } else
          u4 = i3;
      0 === d3 ? (yield g2, g2 = f3(), x = 0) : u4 = e;
    }
}
function s4(n3) {
  let t4 = 0, e2 = 0;
  for (e2 = n3.indexOf('"', e2); e2 >= 0; )
    t4++, e2 = n3.indexOf('"', e2 + 1);
  return t4;
}

// node_modules/@arcgis/core/layers/graphics/sources/support/inferenceUtils.js
function r2(e2) {
  const t4 = e2.map((e3) => e3.toLowerCase());
  return { longitudeFieldName: e2[t4.indexOf(d2.find((e3) => t4.includes(e3)))], latitudeFieldName: e2[t4.indexOf(s5.find((e3) => t4.includes(e3)))] };
}
function n2(e2, r3, n3, l3) {
  const o3 = [], a4 = l(e2, n3, r3), u4 = [];
  for (const t4 of a4) {
    if (10 === u4.length)
      break;
    u4.push(t4);
  }
  for (const t4 of n3)
    if (t4 === l3.longitudeFieldName || t4 === l3.latitudeFieldName)
      o3.push({ name: t4, type: "esriFieldTypeDouble", alias: t4 });
    else {
      const e3 = i2(u4.map((e4) => e4[t4])), r4 = { name: t4, type: null, alias: t4 };
      switch (e3) {
        case "integer":
          r4.type = "esriFieldTypeInteger";
          break;
        case "double":
          r4.type = "esriFieldTypeDouble";
          break;
        case "date":
          r4.type = "esriFieldTypeDate", r4.length = 36;
          break;
        default:
          r4.type = "esriFieldTypeString", r4.length = 255;
      }
      o3.push(r4);
    }
  return o3;
}
function i2(e2) {
  if (!e2.length)
    return "string";
  const t4 = /[^+-.,0-9]/;
  return e2.map((e3) => {
    let r3 = false;
    if ("" !== e3) {
      if (t4.test(e3))
        r3 = true;
      else {
        let t5 = o2(e3);
        if (!isNaN(t5))
          return /[.,]/.test(e3) || !Number.isInteger(t5) || t5 > 214783647 || t5 < -214783648 ? "double" : "integer";
        if (e3.includes("E")) {
          if (t5 = Number(e3), !isNaN(t5))
            return "double";
          if (e3.includes(",")) {
            if (e3 = e3.replace(",", "."), t5 = Number(e3), !isNaN(t5))
              return "double";
            r3 = true;
          } else
            r3 = true;
        } else
          r3 = true;
      }
      if (r3) {
        if (!/^[-]?\d*[.,]?\d*$/.test(e3)) {
          return l2(new Date(e3), e3) ? "date" : "string";
        }
        return "string";
      }
      return "string";
    }
  }).reduce((e3, t5) => void 0 === e3 || e3 === t5 ? t5 : "string" === e3 || "string" === t5 ? "string" : "double" === e3 || "double" === t5 ? "double" : void 0);
}
function l2(e2, t4) {
  if (!e2 || "[object Date]" !== Object.prototype.toString.call(e2) || isNaN(e2.getTime()))
    return false;
  let r3 = true;
  if (!u3 && /\d+\W*$/.test(t4)) {
    const e3 = t4.match(/[a-zA-Z]{2,}/);
    if (e3) {
      let t5 = false, n3 = 0;
      for (; !t5 && n3 <= e3.length; )
        t5 = !a3.test(e3[n3]), n3++;
      r3 = !t5;
    }
  }
  return r3;
}
var o2 = function() {
  const t4 = a(), r3 = new RegExp("^" + t4.regexp + "$"), n3 = new RegExp("[" + t4.group + "\\s\\xa0]", "g"), i3 = t4.factor;
  return (e2) => {
    const l3 = r3.exec(e2);
    if (t4.factor = i3, !l3)
      return NaN;
    let o3 = l3[1];
    if (!l3[1]) {
      if (!l3[2])
        return NaN;
      o3 = l3[2], t4.factor *= -1;
    }
    return o3 = o3.replace(n3, "").replace(t4.decimal, "."), +o3 * t4.factor;
  };
}();
var a3 = /^((jan(uary)?)|(feb(ruary)?)|(mar(ch)?)|(apr(il)?)|(may)|(jun(e)?)|(jul(y)?)|(aug(ust)?)|(sep(tember)?)|(oct(ober)?)|(nov(ember)?)|(dec(ember)?)|(am)|(pm)|(gmt)|(utc))$/i;
var u3 = Number.isNaN((/* @__PURE__ */ new Date("technology 10")).getTime());
var s5 = ["lat", "latitude", "latitude83", "latdecdeg", "lat_dd", "y", "ycenter", "point-y"];
var d2 = ["lon", "lng", "long", "longitude", "longitude83", "longdecdeg", "long_dd", "x", "xcenter", "point-x"];

// node_modules/@arcgis/core/layers/graphics/sources/support/CSVSourceWorker.js
var b = u2("esriGeometryPoint");
var v = ["csv"];
var D = [0, 0];
var O2 = class {
  constructor(e2, t4) {
    this.x = e2, this.y = t4;
  }
};
var k3 = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e2) => {
      const t4 = await this._fetch(e2);
      return this._createFeatures(t4);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e2, t4 = {}) {
    var _a;
    this.loadOptions = e2;
    const [i3] = await Promise.all([this._fetch(t4.signal), this._checkProjection((_a = e2 == null ? void 0 : e2.parsingOptions) == null ? void 0 : _a.spatialReference)]), n3 = P2(i3, e2);
    this.locationInfo = n3.locationInfo, this.delimiter = n3.delimiter, this._queryEngine = this._createQueryEngine(n3);
    const r3 = await this._createFeatures(i3);
    if (this._queryEngine.featureStore.addMany(r3), n3.layerDefinition.extent = this._queryEngine.fullExtent, n3.layerDefinition.timeInfo) {
      const { start: e3, end: t5 } = this._queryEngine.timeExtent;
      n3.layerDefinition.timeInfo.timeExtent = [e3, t5];
    }
    return n3;
  }
  async applyEdits() {
    throw new s2("csv-layer:editing-not-supported", "applyEdits() is not supported on CSVLayer");
  }
  async queryFeatures(e2 = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e2, t4.signal);
  }
  async queryFeatureCount(e2 = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e2, t4.signal);
  }
  async queryObjectIds(e2 = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e2, t4.signal);
  }
  async queryExtent(e2 = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e2, t4.signal);
  }
  async querySnapping(e2, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e2, t4.signal);
  }
  async refresh(e2) {
    var _a;
    return this.loadOptions.customParameters = e2, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = O(this._snapshotFeatures), this._snapshotTask.promise.then((e3) => {
      this._queryEngine.featureStore.clear(), e3 && this._queryEngine.featureStore.addMany(e3);
    }, (e3) => {
      this._queryEngine.featureStore.clear(), g(e3) || s.getLogger("esri.layers.CSVLayer").error(new s2("csv-layer:refresh", "An error occurred during refresh", { error: e3 }));
    }), await this._waitSnapshotComplete(), { extent: this._queryEngine.fullExtent, timeExtent: this._queryEngine.timeExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(i3) {
    const { url: n3, customParameters: r3 } = this.loadOptions;
    if (!n3)
      throw new s2("csv-layer:invalid-source", "url not defined");
    const o3 = j(n3);
    return (await U(o3.path, { query: { ...o3.query, ...r3 }, responseType: "text", signal: i3 })).data;
  }
  _createQueryEngine(e2) {
    const { objectIdField: t4, fields: i3, extent: n3, timeInfo: r3 } = e2.layerDefinition, s6 = new u({ geometryType: "esriGeometryPoint", hasM: false, hasZ: false });
    return new Y({ fields: i3, geometryType: "esriGeometryPoint", hasM: false, hasZ: false, timeInfo: r3, objectIdField: t4, spatialReference: n3.spatialReference || { wkid: 4326 }, cacheSpatialQueries: true, featureStore: s6 });
  }
  async _createFeatures(e2) {
    const { latitudeFieldName: t4, longitudeFieldName: i3 } = this.locationInfo, { objectIdField: n3, fieldsIndex: r3, spatialReference: s6 } = this._queryEngine;
    let o3 = [];
    const u4 = [], y2 = r3.fields.filter((e3) => e3.name !== n3).map((e3) => e3.name);
    let h = 0;
    const g2 = i(e2);
    g2.next();
    const I = {};
    for (const a4 of r3.fields)
      if ("esriFieldTypeOID" !== a4.type && "esriFieldTypeGlobalID" !== a4.type) {
        const e3 = P(a4);
        void 0 !== e3 && (I[a4.name] = e3);
      }
    const E2 = l(g2, y2, this.delimiter, a2(I, n3));
    for (const a4 of E2) {
      const e3 = this._parseCoordinateValue(a4[t4]), s7 = this._parseCoordinateValue(a4[i3]);
      if (null != s7 && null != e3 && !isNaN(e3) && !isNaN(s7)) {
        a4[t4] = e3, a4[i3] = s7;
        for (const e4 in a4)
          if (e4 !== t4 && e4 !== i3) {
            if (r3.isDateField(e4)) {
              const t5 = new Date(a4[e4]);
              a4[e4] = l2(t5, a4[e4]) ? t5.getTime() : null;
            } else if (r3.isNumericField(e4)) {
              const t5 = o2(a4[e4]);
              isNaN(t5) ? a4[e4] = null : a4[e4] = t5;
            }
          }
        a4[n3] = h, h++, o3.push(new O2(s7, e3)), u4.push(a4);
      }
    }
    if (!E({ wkid: 4326 }, s6))
      if (k(s6))
        for (const a4 of o3)
          [a4.x, a4.y] = y(a4.x, a4.y, D);
      else
        o3 = ln(t2, o3, k2.WGS84, s6, null, null);
    const N = [];
    for (let a4 = 0; a4 < o3.length; a4++) {
      const { x: e3, y: t5 } = o3[a4], i4 = u4[a4];
      i4[n3] = a4 + 1, N.push(new s3(new t([], [e3, t5]), i4, null, i4[n3]));
    }
    return N;
  }
  _parseCoordinateValue(e2) {
    if (null == e2 || "" === e2)
      return null;
    let t4 = o2(e2);
    return (isNaN(t4) || Math.abs(t4) > 181) && (t4 = parseFloat(e2)), t4;
  }
  async _checkProjection(e2) {
    try {
      await f(c, e2);
    } catch {
      throw new s2("csv-layer:projection-not-supported", "Projection not supported");
    }
  }
};
function P2(e2, i3) {
  const n3 = i3.parsingOptions || {}, r3 = { delimiter: n3.delimiter, layerDefinition: null, locationInfo: { latitudeFieldName: n3.latitudeField, longitudeFieldName: n3.longitudeField } }, s6 = i(e2);
  let a4 = s6.next().value;
  if (!a4)
    throw new s2("csv-layer:empty-csv", "CSV is empty", { csv: e2 });
  if (a4 = a4.trim(), !n3.delimiter) {
    const e3 = f2(a4);
    if (!e3)
      throw new s2("csv-layer:invalid-delimiter", "Unable to detect the delimiter from CSV");
    r3.delimiter = e3;
  }
  const l3 = a4.split(r3.delimiter).filter((e3) => !!e3), d3 = r3.layerDefinition = { name: Ut(i3.url, v) || "csv", drawingInfo: b, geometryType: "esriGeometryPoint", objectIdField: null, fields: [], timeInfo: n3.timeInfo, extent: { xmin: Number.POSITIVE_INFINITY, ymin: Number.POSITIVE_INFINITY, xmax: Number.NEGATIVE_INFINITY, ymax: Number.NEGATIVE_INFINITY, spatialReference: n3.spatialReference || { wkid: 102100 } } };
  if (!n3.latitudeField || !n3.longitudeField) {
    const e3 = r2(l3);
    if (!n3.longitudeField && !e3.longitudeFieldName || !n3.latitudeField && !e3.latitudeFieldName)
      throw new s2("csv-layer:location-fields-not-found", "Unable to identify latitude and longitude fields from the CSV file");
    r3.locationInfo = { longitudeFieldName: n3.longitudeField || e3.longitudeFieldName, latitudeFieldName: n3.latitudeField || e3.latitudeFieldName };
  }
  const m = n2(s6, r3.delimiter, l3, r3.locationInfo);
  if (n3.fields && n3.fields.length) {
    const e3 = /* @__PURE__ */ new Map();
    for (const t4 of n3.fields)
      e3.set(t4.name.toLowerCase(), t4);
    for (const t4 of m) {
      const i4 = e3.get(t4.name.toLowerCase());
      if (i4) {
        const e4 = t4.name;
        Object.assign(t4, i4), t4.name = e4;
      }
    }
  }
  d3.fields = m;
  if (!d3.fields.some((e3) => "esriFieldTypeOID" === e3.type && (d3.objectIdField = e3.name, true))) {
    const e3 = { name: "__OBJECTID", alias: "__OBJECTID", type: "esriFieldTypeOID", editable: false, nullable: false };
    d3.objectIdField = e3.name, d3.fields.unshift(e3);
  }
  if (d3.timeInfo) {
    const e3 = new d(d3.fields), t4 = d3.timeInfo;
    if (t4.startTimeField) {
      const i4 = e3.get(t4.startTimeField);
      i4 ? (t4.startTimeField = i4.name, i4.type = "esriFieldTypeDate") : t4.startTimeField = null;
    }
    if (t4.endTimeField) {
      const i4 = e3.get(t4.endTimeField);
      i4 ? (t4.endTimeField = i4.name, i4.type = "esriFieldTypeDate") : t4.endTimeField = null;
    }
    if (t4.trackIdField) {
      const i4 = e3.get(t4.trackIdField);
      t4.trackIdField = i4 ? i4.name : null;
    }
    t4.startTimeField || t4.endTimeField || (d3.timeInfo = null);
  }
  return r3;
}
export {
  k3 as default
};
//# sourceMappingURL=CSVSourceWorker-KVPMELT7.js.map
