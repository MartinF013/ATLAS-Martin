import {
  sn
} from "./chunk-ONYLHXHO.js";
import {
  I,
  N as N2,
  O as O2,
  P as P2,
  S,
  b,
  f,
  m as m3,
  o,
  p as p2,
  r,
  u,
  y
} from "./chunk-LKISLLXN.js";
import {
  d as d2,
  s
} from "./chunk-WC3LL63J.js";
import {
  e
} from "./chunk-U7LREOA7.js";
import "./chunk-Q3ZGS5K7.js";
import {
  d
} from "./chunk-3BCNCVBY.js";
import "./chunk-GXI3XMFU.js";
import "./chunk-RO2QI6Y3.js";
import "./chunk-7DMYZG6H.js";
import {
  A,
  D2 as D,
  E,
  G,
  J,
  L,
  N,
  Ne,
  O,
  P2 as P,
  Q,
  R,
  W,
  X,
  Y,
  _,
  h,
  i,
  j as j2,
  k as k2,
  ne,
  se,
  t2 as t,
  v2,
  w,
  z
} from "./chunk-LBBA3SFR.js";
import "./chunk-2KZBVPWA.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import {
  m,
  m2
} from "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j,
  p
} from "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/arcade/arcadeAsyncRuntime.js
function J2(e2) {
  return e2 && "function" == typeof e2.then;
}
var Q2 = 100;
async function $(e2, t2) {
  const r2 = [];
  for (let n = 0; n < t2.arguments.length; n++)
    r2.push(await re(e2, t2.arguments[n]));
  return r2;
}
async function ee(e2, t2, r2) {
  if (true === t2.preparsed)
    return r2(e2, null, t2.arguments);
  return r2(e2, t2, await $(e2, t2));
}
async function te(e2, t2, r2) {
  if (true === t2.preparsed) {
    const n2 = r2(e2, null, t2.arguments);
    return J2(n2), n2;
  }
  const n = r2(e2, t2, await $(e2, t2));
  return J2(n), n;
}
async function re(e2, t2, r2) {
  if (t2.breakpoint && true !== r2) {
    const r3 = t2.breakpoint();
    return await r3, re(e2, t2, true);
  }
  switch (t2.type) {
    case "VariableDeclarator":
      return Re(e2, t2);
    case "VariableDeclaration":
      return be(e2, t2, 0);
    case "BlockStatement":
      return ve(e2, t2);
    case "FunctionDeclaration":
      return Se(e2, t2);
    case "ReturnStatement":
      return Te(e2, t2);
    case "IfStatement":
      return Ne2(e2, t2);
    case "ExpressionStatement":
      return ye(e2, t2);
    case "UpdateExpression":
      return me(e2, t2);
    case "AssignmentExpression":
      return Ee(e2, t2);
    case "ForStatement":
      return ce(e2, t2);
    case "ForInStatement":
      return de(e2, t2);
    case "BreakStatement":
      return A;
    case "EmptyStatement":
      return j2;
    case "ContinueStatement":
      return R;
    case "TemplateElement":
      return je(e2, t2);
    case "TemplateLiteral":
      return Le(e2, t2);
    case "Identifier":
      return Pe(e2, t2);
    case "MemberExpression":
      return Ue(e2, t2);
    case "Literal":
      return t2.value;
    case "CallExpression":
      return De(e2, t2);
    case "UnaryExpression":
      return Ce(e2, t2);
    case "BinaryExpression":
      return xe(e2, t2);
    case "LogicalExpression":
      return Me(e2, t2);
    case "ArrayExpression":
      return Fe(e2, t2);
    case "ObjectExpression":
      return ne2(e2, t2);
    case "Property":
      return oe(e2, t2);
    default:
      throw new Error(b(t2, "RUNTIME", "UNREOGNISED"));
  }
}
async function ne2(e2, t2) {
  const n = [];
  for (let r2 = 0; r2 < t2.properties.length; r2++)
    n[r2] = await re(e2, t2.properties[r2]);
  const o2 = {};
  for (let r2 = 0; r2 < n.length; r2++) {
    const e3 = n[r2];
    if (v2(e3.value))
      throw new Error("Illegal Argument");
    if (false === w(e3.key))
      throw new Error("Illegal Argument");
    e3.value === j2 ? o2[e3.key.toString()] = null : o2[e3.key.toString()] = e3.value;
  }
  const a = new d(o2);
  return a.immutable = false, a;
}
async function oe(e2, t2) {
  const r2 = await re(e2, t2.value);
  if ("Identifier" === t2.key.type)
    return { key: t2.key.name, value: r2 };
  return { key: await re(e2, t2.key), value: r2 };
}
async function ae(e2, t2, r2) {
  const n = await re(e2, t2.body);
  return r2.lastAction = n, r2.lastAction === A || r2.lastAction instanceof D ? (r2.testResult = false, r2) : null !== t2.update ? (await re(e2, t2.update), r2) : r2;
}
async function ie(e2, t2, r2) {
  if (null !== t2.test) {
    const n = await re(e2, t2.test);
    if (true === e2.abortSignal.aborted)
      throw new Error("Cancelled");
    if (r2.testResult = n, false === r2.testResult)
      return r2;
    if (true !== r2.testResult)
      throw new Error(b(t2, "RUNTIME", "CANNOT_USE_NONBOOLEAN_IN_CONDITION"));
    return ae(e2, t2, r2);
  }
  return ae(e2, t2, r2);
}
function se2(e2, t2, r2, n, o2, a) {
  try {
    ie(e2, t2, r2).then(() => {
      try {
        true === r2.testResult ? ++a > Q2 ? (a = 0, setTimeout(() => {
          se2(e2, t2, r2, n, o2, a);
        }, 0)) : se2(e2, t2, r2, n, o2, a) : r2.lastAction instanceof D ? n(r2.lastAction) : n(j2);
      } catch (i2) {
        o2(i2);
      }
    }, (e3) => {
      o2(e3);
    });
  } catch (i2) {
    o2(i2);
  }
}
function ce(e2, t2) {
  try {
    return null !== t2.init ? re(e2, t2.init).then(() => new Promise((r2, n) => {
      se2(e2, t2, { testResult: true, lastAction: j2 }, (e3) => {
        r2(e3);
      }, (e3) => {
        n(e3);
      }, 0);
    })) : new Promise((r2, n) => {
      se2(e2, t2, { testResult: true, lastAction: j2 }, (e3) => {
        r2(e3);
      }, (e3) => {
        n(e3);
      }, 0);
    });
  } catch (r2) {
    return Promise.reject(r2);
  }
}
function le(e2, t2, r2, n, o2, a, i2, s2, c, l) {
  try {
    if (n <= a)
      return void s2(j2);
    o2.value = "k" === i2 ? r2[a] : a, re(e2, t2.body).then((u2) => {
      try {
        u2 instanceof D ? s2(u2) : u2 === A ? s2(j2) : ++l > Q2 ? (l = 0, setTimeout(() => {
          le(e2, t2, r2, n, o2, a + 1, i2, s2, c, l);
        }, 0)) : le(e2, t2, r2, n, o2, a + 1, i2, s2, c, l);
      } catch (f2) {
        c(f2);
      }
    }, (e3) => {
      c(e3);
    });
  } catch (u2) {
    c(u2);
  }
}
function ue(e2, t2, r2, n, o2, a, i2, s2, c) {
  try {
    if (r2.length() <= o2)
      return void i2(j2);
    n.value = "k" === a ? r2.get(o2) : o2, re(e2, t2.body).then((l) => {
      l instanceof D ? i2(l) : l === A ? i2(j2) : ++c > Q2 ? (c = 0, setTimeout(() => {
        ue(e2, t2, r2, n, o2 + 1, a, i2, s2, c);
      }, 0)) : ue(e2, t2, r2, n, o2 + 1, a, i2, s2, c);
    }, (e3) => {
      s2(e3);
    });
  } catch (l) {
    s2(l);
  }
}
function fe(e2, t2, r2, n, o2, a) {
  try {
    if (void 0 === a && (a = "i"), 0 === r2.length)
      return void n.resolve(j2);
    le(e2, t2, r2, r2.length, o2, 0, a, (e3) => {
      n.resolve(e3);
    }, (e3) => {
      n.reject(e3);
    }, 0);
  } catch (i2) {
    n.reject(i2);
  }
}
function pe(e2, t2, r2, n, o2, a) {
  try {
    if (void 0 === a && (a = "i"), 0 === r2.length)
      return void n.resolve(j2);
    ue(e2, t2, r2, o2, 0, a, (e3) => {
      n.resolve(e3);
    }, (e3) => {
      n.reject(e3);
    }, 0);
  } catch (i2) {
    n.reject(i2);
  }
}
function we(e2, t2, r2, n, o2) {
  try {
    fe(e2, t2, r2.keys(), n, o2, "k");
  } catch (a) {
    n.reject(a);
  }
}
function he(e2, t2, r2, o2, a, i2, s2, c) {
  try {
    e2.next().then((l) => {
      try {
        if (null === l)
          i2(j2);
        else {
          const u2 = d2.createFromGraphicLikeObject(l.geometry, l.attributes, o2);
          u2._underlyingGraphic = l, a.value = u2;
          re(t2, r2.body).then((n) => {
            try {
              n === A ? i2(j2) : n instanceof D ? i2(n) : ++c > Q2 ? (c = 0, setTimeout(() => {
                he(e2, t2, r2, o2, a, i2, s2, c);
              }, 0)) : he(e2, t2, r2, o2, a, i2, s2, c);
            } catch (l2) {
              s2(l2);
            }
          }, (e3) => {
            s2(e3);
          });
        }
      } catch (u2) {
        s2(u2);
      }
    }, (e3) => {
      s2(e3);
    });
  } catch (l) {
    s2(l);
  }
}
async function de(e2, t2) {
  return new Promise((n, o2) => {
    re(e2, t2.right).then((a) => {
      try {
        let i2 = null;
        i2 = "VariableDeclaration" === t2.left.type ? re(e2, t2.left) : Promise.resolve(), i2.then(() => {
          try {
            let i3 = "";
            if ("VariableDeclaration" === t2.left.type) {
              const e3 = t2.left.declarations[0].id;
              "Identifier" === e3.type && (i3 = e3.name);
            } else
              "Identifier" === t2.left.type && (i3 = t2.left.name);
            if (!i3)
              throw new Error(b(t2, "RUNTIME", "INVALIDVARIABLE"));
            i3 = i3.toLowerCase();
            let s2 = null;
            if (null !== e2.localScope && void 0 !== e2.localScope[i3] && (s2 = e2.localScope[i3]), null === s2 && void 0 !== e2.globalScope[i3] && (s2 = e2.globalScope[i3]), null === s2)
              return void o2(new Error(b(t2, "RUNTIME", "VARIABLENOTDECLARED")));
            L(a) || w(a) ? fe(e2, t2, a, { reject: o2, resolve: n }, s2) : E(a) ? pe(e2, t2, a, { reject: o2, resolve: n }, s2) : a instanceof d || Y(a) ? we(e2, t2, a, { reject: o2, resolve: n }, s2) : J(a) ? he(a.iterator(e2.abortSignal), e2, t2, a, s2, (e3) => {
              n(e3);
            }, (e3) => {
              o2(e3);
            }, 0) : fe(e2, t2, [], { reject: o2, resolve: n }, s2);
          } catch (i3) {
            o2(i3);
          }
        }, o2);
      } catch (i2) {
        o2(i2);
      }
    }, o2);
  });
}
async function me(e2, t2) {
  const n = t2.argument;
  if ("MemberExpression" === n.type) {
    const o3 = { t: null }, a2 = await re(e2, n.object);
    let i2 = null;
    o3.t = a2, true === n.computed ? i2 = await re(e2, n.property) : "Identifier" === n.property.type && (i2 = n.property.name);
    const s2 = o3.t;
    let c;
    if (L(s2)) {
      if (!O(i2))
        throw new Error("Invalid Parameter");
      if (i2 < 0 && (i2 = s2.length + i2), i2 < 0 || i2 >= s2.length)
        throw new Error("Assignment outside of array bounds");
      c = ne(s2[i2]), s2[i2] = "++" === t2.operator ? c + 1 : c - 1;
    } else if (s2 instanceof d) {
      if (false === w(i2))
        throw new Error("Dictionary accessor must be a string");
      if (true !== s2.hasField(i2))
        throw new Error("Invalid Parameter");
      c = ne(s2.field(i2)), s2.setField(i2, "++" === t2.operator ? c + 1 : c - 1);
    } else {
      if (!Y(s2))
        throw E(s2) ? new Error("Array is Immutable") : new Error("Invalid Parameter");
      if (false === w(i2))
        throw new Error("Feature accessor must be a string");
      if (true !== s2.hasField(i2))
        throw new Error("Invalid Parameter");
      c = ne(s2.field(i2)), s2.setField(i2, "++" === t2.operator ? c + 1 : c - 1);
    }
    return false === t2.prefix ? c : "++" === t2.operator ? c + 1 : c - 1;
  }
  const o2 = "Identifier" === t2.argument.type ? t2.argument.name.toLowerCase() : "";
  if (!o2)
    throw new Error("Invalid identifier");
  let a;
  if (null !== e2.localScope && void 0 !== e2.localScope[o2])
    return a = ne(e2.localScope[o2].value), e2.localScope[o2] = { value: "++" === t2.operator ? a + 1 : a - 1, valueset: true, node: t2 }, false === t2.prefix ? a : "++" === t2.operator ? a + 1 : a - 1;
  if (void 0 !== e2.globalScope[o2])
    return a = ne(e2.globalScope[o2].value), e2.globalScope[o2] = { value: "++" === t2.operator ? a + 1 : a - 1, valueset: true, node: t2 }, false === t2.prefix ? a : "++" === t2.operator ? a + 1 : a - 1;
  throw new Error("Variable not recognised");
}
function ge(e2, t2, r2, n) {
  switch (t2) {
    case "=":
      return e2 === j2 ? null : e2;
    case "/=":
      return ne(r2) / ne(e2);
    case "*=":
      return ne(r2) * ne(e2);
    case "-=":
      return ne(r2) - ne(e2);
    case "+=":
      return w(r2) || w(e2) ? X(r2) + X(e2) : ne(r2) + ne(e2);
    case "%=":
      return ne(r2) % ne(e2);
    default:
      throw new Error(b(n, "RUNTIME", "OPERATORNOTRECOGNISED"));
  }
}
async function Ee(e2, t2) {
  const n = t2.left;
  if ("MemberExpression" === n.type) {
    const o3 = await re(e2, t2.right), a = await re(e2, n.object);
    let i2 = null;
    if (true === n.computed)
      i2 = await re(e2, n.property);
    else {
      if ("Identifier" !== n.property.type)
        throw new Error("Expected computed or identifier for assignemnt target");
      i2 = n.property.name;
    }
    if (L(a)) {
      if (!O(i2))
        throw new Error("Invalid Parameter");
      if (i2 < 0 && (i2 = a.length + i2), i2 < 0 || i2 > a.length)
        throw new Error("Assignment outside of array bounds");
      if (i2 === a.length) {
        if ("=" !== t2.operator)
          throw new Error("Invalid Parameter");
        a[i2] = ge(o3, t2.operator, a[i2], t2);
      } else
        a[i2] = ge(o3, t2.operator, a[i2], t2);
    } else if (a instanceof d) {
      if (false === w(i2))
        throw new Error("Dictionary accessor must be a string");
      if (true === a.hasField(i2))
        a.setField(i2, ge(o3, t2.operator, a.field(i2), t2));
      else {
        if ("=" !== t2.operator)
          throw new Error("Invalid Parameter");
        a.setField(i2, ge(o3, t2.operator, null, t2));
      }
    } else {
      if (!Y(a))
        throw E(a) ? new Error("Array is Immutable") : new Error("Invalid Parameter");
      if (false === w(i2))
        throw new Error("Feature accessor must be a string");
      if (true === a.hasField(i2))
        a.setField(i2, ge(o3, t2.operator, a.field(i2), t2));
      else {
        if ("=" !== t2.operator)
          throw new Error("Invalid Parameter");
        a.setField(i2, ge(o3, t2.operator, null, t2));
      }
    }
    return j2;
  }
  const o2 = n.name.toLowerCase();
  if (null !== e2.localScope && void 0 !== e2.localScope[o2]) {
    const r2 = await re(e2, t2.right);
    return e2.localScope[o2] = { value: ge(r2, t2.operator, e2.localScope[o2].value, t2), valueset: true, node: t2.right }, j2;
  }
  if (void 0 !== e2.globalScope[o2]) {
    const r2 = await re(e2, t2.right);
    return e2.globalScope[o2] = { value: ge(r2, t2.operator, e2.globalScope[o2].value, t2), valueset: true, node: t2.right }, j2;
  }
  throw new Error("Cannot assign undeclared variable");
}
async function ye(e2, t2) {
  if ("AssignmentExpression" === t2.expression.type)
    return re(e2, t2.expression);
  if ("CallExpression" === t2.expression.type) {
    const r3 = await re(e2, t2.expression);
    return r3 === j2 ? j2 : new k2(r3);
  }
  const r2 = await re(e2, t2.expression);
  return r2 === j2 ? j2 : new k2(r2);
}
async function Ne2(e2, t2) {
  if ("AssignmentExpression" === t2.test.type || "UpdateExpression" === t2.test.type)
    throw new Error(b(t2.test, "RUNTIME", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"));
  const r2 = await re(e2, t2.test);
  if (true === r2)
    return re(e2, t2.consequent);
  if (false === r2)
    return null !== t2.alternate ? re(e2, t2.alternate) : j2;
  throw new Error(b(t2.test, "RUNTIME", "CANNOT_USE_NONBOOLEAN_IN_CONDITION"));
}
async function ve(e2, t2) {
  return Ie(e2, t2, 0);
}
async function Ie(e2, t2, r2) {
  if (r2 >= t2.body.length)
    return j2;
  const n = await re(e2, t2.body[r2]);
  return n instanceof D || n === A || n === R || r2 === t2.body.length - 1 ? n : Ie(e2, t2, r2 + 1);
}
async function Te(e2, t2) {
  if (null === t2.argument)
    return new D(j2);
  const r2 = await re(e2, t2.argument);
  return new D(r2);
}
async function Se(e2, t2) {
  const r2 = t2.id.name.toLowerCase();
  return e2.globalScope[r2] = { valueset: true, node: null, value: new t(t2, e2) }, j2;
}
async function be(e2, t2, r2) {
  return r2 >= t2.declarations.length ? j2 : (await re(e2, t2.declarations[r2]), r2 === t2.declarations.length - 1 || await be(e2, t2, r2 + 1), j2);
}
async function Re(e2, t2) {
  let r2 = null;
  if (r2 = null === t2.init ? null : await re(e2, t2.init), null !== e2.localScope) {
    if (r2 === j2 && (r2 = null), "Identifier" !== t2.id.type)
      throw new Error("Can only assign a regular variable");
    const n2 = t2.id.name.toLowerCase();
    return e2.localScope[n2] = { value: r2, valueset: true, node: t2.init }, j2;
  }
  if ("Identifier" !== t2.id.type)
    throw new Error("Can only assign a regular variable");
  const n = t2.id.name.toLowerCase();
  return r2 === j2 && (r2 = null), e2.globalScope[n] = { value: r2, valueset: true, node: t2.init }, j2;
}
var Oe = 0;
function Ae(e2, t2, n, o2) {
  let s2;
  switch (t2 = t2.toLowerCase()) {
    case "hasz": {
      const t3 = e2.hasZ;
      return void 0 !== t3 && t3;
    }
    case "hasm": {
      const t3 = e2.hasM;
      return void 0 !== t3 && t3;
    }
    case "spatialreference": {
      let t3 = e2.spatialReference._arcadeCacheId;
      if (void 0 === t3) {
        let r2 = true;
        Object.freeze && Object.isFrozen(e2.spatialReference) && (r2 = false), r2 && (Oe++, e2.spatialReference._arcadeCacheId = Oe, t3 = Oe);
      }
      const n2 = new d({ wkt: e2.spatialReference.wkt, wkid: e2.spatialReference.wkid });
      return void 0 !== t3 && (n2._arcadeCacheId = "SPREF" + t3.toString()), n2;
    }
  }
  switch (e2.type) {
    case "extent":
      switch (t2) {
        case "xmin":
        case "xmax":
        case "ymin":
        case "ymax":
        case "zmin":
        case "zmax":
        case "mmin":
        case "mmax": {
          const r2 = e2[t2];
          return void 0 !== r2 ? r2 : null;
        }
        case "type":
          return "Extent";
      }
      break;
    case "polygon":
      switch (t2) {
        case "rings":
          s2 = e2.cache._arcadeCacheId, void 0 === s2 && (Oe++, s2 = Oe, e2.cache._arcadeCacheId = s2);
          return new h(e2.rings, e2.spatialReference, true === e2.hasZ, true === e2.hasM, s2);
        case "type":
          return "Polygon";
      }
      break;
    case "point":
      switch (t2) {
        case "x":
        case "y":
        case "z":
        case "m":
          return void 0 !== e2[t2] ? e2[t2] : null;
        case "type":
          return "Point";
      }
      break;
    case "polyline":
      switch (t2) {
        case "paths":
          s2 = e2.cache._arcadeCacheId, void 0 === s2 && (Oe++, s2 = Oe, e2.cache._arcadeCacheId = s2);
          return new h(e2.paths, e2.spatialReference, true === e2.hasZ, true === e2.hasM, s2);
        case "type":
          return "Polyline";
      }
      break;
    case "multipoint":
      switch (t2) {
        case "points":
          s2 = e2.cache._arcadeCacheId, void 0 === s2 && (Oe++, s2 = Oe, e2.cache._arcadeCacheId = s2);
          return new i(e2.points, e2.spatialReference, true === e2.hasZ, true === e2.hasM, s2, 1);
        case "type":
          return "Multipoint";
      }
  }
  throw new Error(b(o2, "RUNTIME", "PROPERTYNOTFOUND"));
}
async function Ue(e2, t2) {
  const n = await re(e2, t2.object);
  if (null === n)
    throw new Error(b(t2, "RUNTIME", "NOTFOUND"));
  if (false === t2.computed) {
    if ("Identifier" === t2.property.type) {
      if (n instanceof d || Y(n))
        return n.field(t2.property.name);
      if (n instanceof p)
        return Ae(n, t2.property.name, e2, t2);
      throw new Error(b(t2, "RUNTIME", "INVALIDTYPE"));
    }
    throw new Error(b(t2, "RUNTIME", "INVALIDTYPE"));
  }
  let o2 = await re(e2, t2.property);
  if (n instanceof d || Y(n)) {
    if (w(o2))
      return n.field(o2);
    throw new Error(b(t2, "RUNTIME", "INVALIDTYPE"));
  }
  if (n instanceof p) {
    if (w(o2))
      return Ae(n, o2, e2, t2);
    throw new Error(b(t2, "RUNTIME", "INVALIDTYPE"));
  }
  if (L(n)) {
    if (O(o2) && isFinite(o2) && Math.floor(o2) === o2) {
      if (o2 < 0 && (o2 = n.length + o2), o2 >= n.length || o2 < 0)
        throw new Error(b(t2, "RUNTIME", "OUTOFBOUNDS"));
      return n[o2];
    }
    throw new Error(b(t2, "RUNTIME", "INVALIDTYPE"));
  }
  if (E(n)) {
    if (O(o2) && isFinite(o2) && Math.floor(o2) === o2) {
      if (o2 < 0 && (o2 = n.length() + o2), o2 >= n.length() || o2 < 0)
        throw new Error(b(t2, "RUNTIME", "OUTOFBOUNDS"));
      return n.get(o2);
    }
    throw new Error(b(t2, "RUNTIME", "INVALIDTYPE"));
  }
  if (w(n)) {
    if (O(o2) && isFinite(o2) && Math.floor(o2) === o2) {
      if (o2 < 0 && (o2 = n.length + o2), o2 >= n.length || o2 < 0)
        throw new Error(b(t2, "RUNTIME", "OUTOFBOUNDS"));
      return n[o2];
    }
    throw new Error(b(t2, "RUNTIME", "INVALIDTYPE"));
  }
  throw new Error(b(t2, "RUNTIME", "INVALIDTYPE"));
}
async function Ce(e2, t2) {
  const r2 = await re(e2, t2.argument);
  if (_(r2)) {
    if ("!" === t2.operator)
      return !r2;
    if ("-" === t2.operator)
      return -1 * ne(r2);
    if ("+" === t2.operator)
      return 1 * ne(r2);
    if ("~" === t2.operator)
      return ~ne(r2);
    throw new Error(b(t2, "RUNTIME", "NOTSUPPORTEDUNARYOPERATOR"));
  }
  if ("-" === t2.operator)
    return -1 * ne(r2);
  if ("+" === t2.operator)
    return 1 * ne(r2);
  if ("~" === t2.operator)
    return ~ne(r2);
  throw new Error(b(t2, "RUNTIME", "NOTSUPPORTEDUNARYOPERATOR"));
}
async function Fe(e2, t2) {
  const r2 = [];
  for (let n = 0; n < t2.elements.length; n++)
    r2.push(await re(e2, t2.elements[n]));
  for (let n = 0; n < r2.length; n++) {
    if (v2(r2[n]))
      throw new Error(b(t2, "RUNTIME", "FUNCTIONCONTEXTILLEGAL"));
    r2[n] === j2 && (r2[n] = null);
  }
  return r2;
}
async function xe(e2, t2) {
  const r2 = [];
  r2[0] = await re(e2, t2.left), r2[1] = await re(e2, t2.right);
  const n = r2[0], o2 = r2[1];
  switch (t2.operator) {
    case "|":
    case "<<":
    case ">>":
    case ">>>":
    case "^":
    case "&":
      return Ne(ne(n), ne(o2), t2.operator);
    case "==":
      return Q(n, o2);
    case "!=":
      return !Q(n, o2);
    case "<":
    case ">":
    case "<=":
    case ">=":
      return W(n, o2, t2.operator);
    case "+":
      return w(n) || w(o2) ? X(n) + X(o2) : ne(n) + ne(o2);
    case "-":
      return ne(n) - ne(o2);
    case "*":
      return ne(n) * ne(o2);
    case "/":
      return ne(n) / ne(o2);
    case "%":
      return ne(n) % ne(o2);
    default:
      throw new Error(b(t2, "RUNTIME", "OPERATORNOTRECOGNISED"));
  }
}
async function Me(e2, t2) {
  if ("AssignmentExpression" === t2.left.type || "UpdateExpression" === t2.left.type)
    throw new Error(b(t2.left, "RUNTIME", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"));
  if ("AssignmentExpression" === t2.right.type || "UpdateExpression" === t2.right.type)
    throw new Error(b(t2.right, "RUNTIME", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"));
  const r2 = await re(e2, t2.left);
  let n = null;
  if (!_(r2))
    throw new Error(b(t2, "RUNTIME", "ONLYBOOLEAN"));
  switch (t2.operator) {
    case "||":
      if (true === r2)
        return r2;
      if (n = await re(e2, t2.right), _(n))
        return n;
      throw new Error(b(t2, "RUNTIME", "ONLYORORAND"));
    case "&&":
      if (false === r2)
        return r2;
      if (n = await re(e2, t2.right), _(n))
        return n;
      throw new Error(b(t2, "RUNTIME", "ONLYORORAND"));
    default:
      throw new Error(b(t2, "RUNTIME", "ONLYORORAND"));
  }
}
async function Pe(e2, t2) {
  const r2 = t2.name.toLowerCase();
  if (null !== e2.localScope && void 0 !== e2.localScope[r2]) {
    const t3 = e2.localScope[r2];
    if (true === t3.valueset)
      return t3.value;
    if (null !== t3.d)
      return t3.d;
    t3.d = re(e2, t3.node);
    const n = await t3.d;
    return t3.value = n, t3.valueset = true, n;
  }
  if (void 0 !== e2.globalScope[r2]) {
    const t3 = e2.globalScope[r2];
    if (true === t3.valueset)
      return t3.value;
    if (null !== t3.d)
      return t3.d;
    t3.d = re(e2, t3.node);
    const n = await t3.d;
    return t3.value = n, t3.valueset = true, n;
  }
  throw new Error(b(t2, "RUNTIME", "VARIABLENOTFOUND"));
}
async function De(e2, t2) {
  if ("Identifier" !== t2.callee.type)
    throw new Error(b(t2, "RUNTIME", "ONLYNODESSUPPORTED"));
  if (null !== e2.localScope && void 0 !== e2.localScope[t2.callee.name.toLowerCase()]) {
    const r2 = e2.localScope[t2.callee.name.toLowerCase()];
    if (r2.value instanceof N)
      return r2.value.fn(e2, t2);
    if (r2.value instanceof t)
      return Ze(e2, t2, r2.value.definition);
    throw new Error(b(t2, "RUNTIME", "NOTAFUNCTION"));
  }
  if (void 0 !== e2.globalScope[t2.callee.name.toLowerCase()]) {
    const r2 = e2.globalScope[t2.callee.name.toLowerCase()];
    if (r2.value instanceof N)
      return r2.value.fn(e2, t2);
    if (r2.value instanceof t)
      return Ze(e2, t2, r2.value.definition);
    throw new Error(b(t2, "RUNTIME", "NOTAFUNCTION"));
  }
  throw new Error(b(t2, "RUNTIME", "NOTFOUND"));
}
async function je(e2, t2) {
  return t2.value ? t2.value.cooked : "";
}
async function Le(e2, t2) {
  const r2 = [];
  for (let a = 0; a < t2.expressions.length; a++) {
    const n2 = await re(e2, t2.expressions[a]);
    r2[a] = X(n2);
  }
  let n = "", o2 = 0;
  for (const a of t2.quasis)
    if (n += a.value ? a.value.cooked : "", false === a.tail) {
      n += r2[o2] ? r2[o2] : "", o2++;
    }
  return n;
}
var ke = {};
function _e(n) {
  return null === n ? "" : L(n) || E(n) ? "Array" : z(n) ? "Date" : w(n) ? "String" : _(n) ? "Boolean" : O(n) ? "Number" : n instanceof e ? "Attachment" : n instanceof s ? "Portal" : n instanceof d ? "Dictionary" : Y(n) ? "Feature" : n instanceof j ? "Point" : n instanceof v ? "Polygon" : n instanceof m2 ? "Polyline" : n instanceof m ? "Multipoint" : n instanceof M ? "Extent" : v2(n) ? "Function" : J(n) ? "FeatureSet" : P(n) ? "FeatureSetCollection" : n === j2 ? "" : "number" == typeof n && isNaN(n) ? "Number" : "Unrecognised Type";
}
async function Ve(e2, t2, r2, n) {
  const o2 = await re(e2, t2.arguments[r2]);
  if (Q(o2, n))
    return re(e2, t2.arguments[r2 + 1]);
  const a = t2.arguments.length - r2;
  return 1 === a ? re(e2, t2.arguments[r2]) : 2 === a ? null : 3 === a ? re(e2, t2.arguments[r2 + 2]) : Ve(e2, t2, r2 + 2, n);
}
async function Ye(e2, t2, r2, n) {
  if (true === n)
    return re(e2, t2.arguments[r2 + 1]);
  if (3 === t2.arguments.length - r2)
    return re(e2, t2.arguments[r2 + 2]);
  const o2 = await re(e2, t2.arguments[r2 + 2]);
  if (false === _(o2))
    throw new Error("WHEN needs boolean test conditions");
  return Ye(e2, t2, r2 + 2, o2);
}
async function Be(e2, t2) {
  const r2 = e2.length, n = Math.floor(r2 / 2);
  if (0 === r2)
    return [];
  if (1 === r2)
    return [e2[0]];
  const o2 = [Be(e2.slice(0, n), t2), Be(e2.slice(n, r2), t2)], a = await Promise.all(o2);
  return Ge(a[0], a[1], t2, []);
}
async function Ge(e2, t2, r2, n) {
  const o2 = n;
  if (!(e2.length > 0 || t2.length > 0))
    return n;
  if (e2.length > 0 && t2.length > 0) {
    let a = await r2(e2[0], t2[0]);
    return isNaN(a) && (a = 1), a <= 0 ? (o2.push(e2[0]), e2 = e2.slice(1)) : (o2.push(t2[0]), t2 = t2.slice(1)), Ge(e2, t2, r2, n);
  }
  return e2.length > 0 ? (o2.push(e2[0]), Ge(e2 = e2.slice(1), t2, r2, n)) : t2.length > 0 ? (o2.push(t2[0]), Ge(e2, t2 = t2.slice(1), r2, n)) : void 0;
}
function ze(e2, t2) {
  const r2 = e2.length, n = Math.floor(r2 / 2);
  return t2 || (t2 = function(e3, t3) {
    return e3 < t3 ? -1 : e3 === t3 ? 0 : 1;
  }), 0 === r2 ? [] : 1 === r2 ? [e2[0]] : qe(ze(e2.slice(0, n), t2), ze(e2.slice(n, r2), t2), t2);
}
function qe(e2, t2, r2) {
  const n = [];
  for (; e2.length > 0 || t2.length > 0; )
    if (e2.length > 0 && t2.length > 0) {
      let o2 = r2(e2[0], t2[0]);
      isNaN(o2) && (o2 = 1), o2 <= 0 ? (n.push(e2[0]), e2 = e2.slice(1)) : (n.push(t2[0]), t2 = t2.slice(1));
    } else
      e2.length > 0 ? (n.push(e2[0]), e2 = e2.slice(1)) : t2.length > 0 && (n.push(t2[0]), t2 = t2.slice(1));
  return n;
}
async function He(e2, t2, r2) {
  const n = e2.body;
  if (r2.length !== e2.params.length)
    throw new Error("Invalid Parameter calls to function.");
  for (let a = 0; a < r2.length; a++) {
    const n2 = e2.params[a];
    "Identifier" === n2.type && (t2.localScope[n2.name.toLowerCase()] = { d: null, value: r2[a], valueset: true, node: null });
  }
  const o2 = await re(t2, n);
  if (o2 instanceof D)
    return o2.value;
  if (o2 === A)
    throw new Error("Cannot Break from a Function");
  if (o2 === R)
    throw new Error("Cannot Continue from a Function");
  return o2 instanceof k2 ? o2.value : o2;
}
function Ze(e2, t2, r2) {
  return te(e2, t2, function(t3, n, o2) {
    const a = { spatialReference: e2.spatialReference, services: e2.services, console: e2.console, lrucache: e2.lrucache, interceptor: e2.interceptor, localScope: {}, abortSignal: e2.abortSignal, globalScope: e2.globalScope, depthCounter: e2.depthCounter + 1 };
    if (a.depthCounter > 64)
      throw new Error("Exceeded maximum function depth");
    return He(r2, a, o2);
  });
}
function We(e2) {
  const t2 = function() {
    const t3 = { abortSignal: e2.context.abortSignal, spatialReference: e2.context.spatialReference, console: e2.context.console, lrucache: e2.context.lrucache, interceptor: e2.context.interceptor, services: e2.context.services, localScope: {}, globalScope: e2.context.globalScope, depthCounter: e2.context.depthCounter + 1 };
    if (t3.depthCounter > 64)
      throw new Error("Exceeded maximum function depth");
    return He(e2.definition, t3, arguments);
  };
  return t2;
}
y(ke, ee), O2(ke, ee), N2(ke, ee), P2(ke, ee), o(ke, ee), sn({ functions: ke, compiled: false, signatures: null, evaluateIdentifier: null, arcadeCustomFunctionHandler: null, mode: "async", standardFunction: ee, standardFunctionAsync: te }), ke.typeof = function(e2, t2) {
  return ee(e2, t2, function(e3, t3, r2) {
    G(r2, 1, 1);
    const n = _e(r2[0]);
    if ("Unrecognised Type" === n)
      throw new Error("Unrecognised Type");
    return n;
  });
}, ke.iif = async function(e2, t2) {
  G(null === t2.arguments ? [] : t2.arguments, 3, 3);
  const r2 = await re(e2, t2.arguments[0]);
  if (false === _(r2))
    throw new Error("IF Function must have a boolean test condition");
  const n = [];
  return n[0] = await re(e2, t2.arguments[1]), n[1] = await re(e2, t2.arguments[2]), r2 ? n[0] : n[1];
}, ke.decode = async function(e2, t2) {
  if (t2.arguments.length < 2)
    throw new Error("Missing Parameters");
  if (2 === t2.arguments.length)
    return re(e2, t2.arguments[1]);
  if ((t2.arguments.length - 1) % 2 == 0)
    throw new Error("Must have a default value result.");
  return Ve(e2, t2, 1, await re(e2, t2.arguments[0]));
}, ke.when = async function(e2, t2) {
  if (t2.arguments.length < 3)
    throw new Error("Missing Parameters");
  if (t2.arguments.length % 2 == 0)
    throw new Error("Must have a default value result.");
  const r2 = await re(e2, t2.arguments[0]);
  if (false === _(r2))
    throw new Error("WHEN needs boolean test conditions");
  return Ye(e2, t2, 0, r2);
}, ke.sort = function(e2, t2) {
  return te(e2, t2, async function(e3, t3, r2) {
    G(r2, 1, 2);
    let n = r2[0];
    if (E(n) && (n = n.toArray()), false === L(n))
      throw new Error("Illegal Argument");
    if (r2.length > 1) {
      if (false === v2(r2[1]))
        throw new Error("Illegal Argument");
      return Be(n, We(r2[1]));
    }
    let o2 = n;
    if (0 === o2.length)
      return [];
    const a = {};
    for (let s2 = 0; s2 < o2.length; s2++) {
      const e4 = _e(o2[s2]);
      "" !== e4 && (a[e4] = true);
    }
    if (true === a.Array || true === a.Dictionary || true === a.Feature || true === a.Point || true === a.Polygon || true === a.Polyline || true === a.Multipoint || true === a.Extent || true === a.Function)
      return o2.slice(0);
    let i2 = 0, c = "";
    for (const s2 in a)
      i2++, c = s2;
    return i2 > 1 || "String" === c ? o2 = ze(o2, function(e4, t4) {
      if (null == e4 || e4 === j2)
        return null == t4 || t4 === j2 ? 0 : 1;
      if (null == t4 || t4 === j2)
        return -1;
      const r3 = X(e4), n2 = X(t4);
      return r3 < n2 ? -1 : r3 === n2 ? 0 : 1;
    }) : "Number" === c ? o2 = ze(o2, function(e4, t4) {
      return e4 - t4;
    }) : "Boolean" === c ? o2 = ze(o2, function(e4, t4) {
      return e4 === t4 ? 0 : t4 ? -1 : 1;
    }) : "Date" === c && (o2 = ze(o2, function(e4, t4) {
      return t4 - e4;
    })), o2;
  });
};
var Ke = { fixSpatialReference: se, parseArguments: $, standardFunction: ee, standardFunctionAsync: te, evaluateIdentifier: Pe, arcadeCustomFunction: We };
for (const st in ke)
  ke[st] = { value: new N(ke[st]), valueset: true, node: null };
var Xe = function() {
};
function Je(e2, t2) {
  const o2 = new Xe();
  null == e2 && (e2 = {}), null == t2 && (t2 = {});
  const a = new d({ newline: "\n", tab: "	", singlequote: "'", doublequote: '"', forwardslash: "/", backwardslash: "\\" });
  a.immutable = false, o2.textformatting = { value: a, valueset: true, node: null };
  for (const r2 in t2)
    o2[r2] = { value: new N(t2[r2]), native: true, valueset: true, node: null };
  for (const r2 in e2)
    e2[r2] && "esri.Graphic" === e2[r2].declaredClass ? o2[r2] = { value: d2.createFromGraphic(e2[r2]), valueset: true, node: null } : o2[r2] = { value: e2[r2], valueset: true, node: null };
  return o2;
}
function Qe(e2) {
  console.log(e2);
}
Xe.prototype = ke, Xe.prototype.infinity = { value: Number.POSITIVE_INFINITY, valueset: true, node: null }, Xe.prototype.pi = { value: Math.PI, valueset: true, node: null };
var $e = Ke;
function et(e2) {
  const t2 = { mode: "async", compiled: false, functions: {}, signatures: [], standardFunction: ee, standardFunctionAsync: te, evaluateIdentifier: Pe, arcadeCustomFunctionHandler: We };
  for (let r2 = 0; r2 < e2.length; r2++)
    e2[r2].registerFunctions(t2);
  for (const r2 in t2.functions)
    ke[r2] = { value: new N(t2.functions[r2]), valueset: true, node: null }, Xe.prototype[r2] = ke[r2];
  for (let r2 = 0; r2 < t2.signatures.length; r2++)
    r(t2.signatures[r2], "async");
}
async function tt(e2, t2) {
  let r2 = t2.spatialReference;
  null == r2 && (r2 = new k({ wkid: 102100 }));
  const n = Je(t2.vars, t2.customfunctions), a = { spatialReference: r2, services: t2.services, abortSignal: void 0 === t2.abortSignal || null === t2.abortSignal ? { aborted: false } : t2.abortSignal, globalScope: n, console: t2.console ? t2.console : Qe, lrucache: t2.lrucache, interceptor: t2.interceptor, localScope: null, depthCounter: 1 };
  let i2 = await re(a, e2.body[0].body);
  if (i2 instanceof D && (i2 = i2.value), i2 instanceof k2 && (i2 = i2.value), i2 === j2 && (i2 = null), i2 === A)
    throw new Error("Cannot return BREAK");
  if (i2 === R)
    throw new Error("Cannot return CONTINUE");
  if (i2 instanceof N)
    throw new Error("Cannot return FUNCTION");
  if (i2 instanceof t)
    throw new Error("Cannot return FUNCTION");
  return i2;
}
function rt(e2, t2) {
  return f(e2);
}
function nt(e2, t2) {
  return S(e2, t2, "full");
}
function ot(e2, t2) {
  return p2(e2, t2);
}
function at(e2, t2) {
  return u(e2, t2);
}
function it(e2) {
  return I(e2);
}
et([m3]);
export {
  tt as executeScript,
  et as extend,
  rt as extractFieldLiterals,
  it as findFunctionCalls,
  $e as functionHelper,
  at as referencesFunction,
  ot as referencesMember,
  nt as validateScript
};
//# sourceMappingURL=arcadeAsyncRuntime-SWU57VX7.js.map
