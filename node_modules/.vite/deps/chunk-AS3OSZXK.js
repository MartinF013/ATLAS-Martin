import {
  c as c2
} from "./chunk-VQLKKADV.js";
import {
  H,
  t as t2
} from "./chunk-FPMD6IB4.js";
import {
  o
} from "./chunk-MV2XZ5BA.js";
import {
  c2 as c,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/webgl/reservedWordsGLSL3.js
var e = ["layout", "centroid", "smooth", "case", "mat2x2", "mat2x3", "mat2x4", "mat3x2", "mat3x3", "mat3x4", "mat4x2", "mat4x3", "mat4x4", "uint", "uvec2", "uvec3", "uvec4", "samplerCubeShadow", "sampler2DArray", "sampler2DArrayShadow", "isampler2D", "isampler3D", "isamplerCube", "isampler2DArray", "usampler2D", "usampler3D", "usamplerCube", "usampler2DArray", "coherent", "restrict", "readonly", "writeonly", "resource", "atomic_uint", "noperspective", "patch", "sample", "subroutine", "common", "partition", "active", "filter", "image1D", "image2D", "image3D", "imageCube", "iimage1D", "iimage2D", "iimage3D", "iimageCube", "uimage1D", "uimage2D", "uimage3D", "uimageCube", "image1DArray", "image2DArray", "iimage1DArray", "iimage2DArray", "uimage1DArray", "uimage2DArray", "image1DShadow", "image2DShadow", "image1DArrayShadow", "image2DArrayShadow", "imageBuffer", "iimageBuffer", "uimageBuffer", "sampler1DArray", "sampler1DArrayShadow", "isampler1D", "isampler1DArray", "usampler1D", "usampler1DArray", "isampler2DRect", "usampler2DRect", "samplerBuffer", "isamplerBuffer", "usamplerBuffer", "sampler2DMS", "isampler2DMS", "usampler2DMS", "sampler2DMSArray", "isampler2DMSArray", "usampler2DMSArray", "trunc", "round", "roundEven", "isnan", "isinf", "floatBitsToInt", "floatBitsToUint", "intBitsToFloat", "uintBitsToFloat", "packSnorm2x16", "unpackSnorm2x16", "packUnorm2x16", "unpackUnorm2x16", "packHalf2x16", "unpackHalf2x16", "outerProduct", "transpose", "determinant", "inverse", "texture", "textureSize", "textureProj", "textureLod", "textureOffset", "texelFetch", "texelFetchOffset", "textureProjOffset", "textureLodOffset", "textureProjLod", "textureProjLodOffset", "textureGrad", "textureGradOffset", "textureProjGrad", "textureProjGradOffset"];

// node_modules/@arcgis/core/views/webgl/testUtils.js
var e2 = { enableCache: false };

// node_modules/@arcgis/core/views/webgl/ShaderTranspiler.js
var o2;
var n = { exports: {} };
void 0 !== (o2 = ["precision", "highp", "mediump", "lowp", "attribute", "const", "uniform", "varying", "break", "continue", "do", "for", "while", "if", "else", "in", "out", "inout", "float", "int", "void", "bool", "true", "false", "discard", "return", "mat2", "mat3", "mat4", "vec2", "vec3", "vec4", "ivec2", "ivec3", "ivec4", "bvec2", "bvec3", "bvec4", "sampler1D", "sampler2D", "sampler3D", "samplerCube", "sampler1DShadow", "sampler2DShadow", "struct", "asm", "class", "union", "enum", "typedef", "template", "this", "packed", "goto", "switch", "default", "inline", "noinline", "volatile", "public", "static", "extern", "external", "interface", "long", "short", "double", "half", "fixed", "unsigned", "input", "output", "hvec2", "hvec3", "hvec4", "dvec2", "dvec3", "dvec4", "fvec2", "fvec3", "fvec4", "sampler2DRect", "sampler3DRect", "sampler2DRectShadow", "sizeof", "cast", "namespace", "using"]) && (n.exports = o2);
var i = n.exports;
var l;
var s = { exports: {} };
l = s, function(e3) {
  var t3 = ["<<=", ">>=", "++", "--", "<<", ">>", "<=", ">=", "==", "!=", "&&", "||", "+=", "-=", "*=", "/=", "%=", "&=", "^^", "^=", "|=", "(", ")", "[", "]", ".", "!", "~", "*", "/", "%", "+", "-", "<", ">", "&", "^", "|", "?", ":", "=", ",", ";", "{", "}"];
  void 0 !== t3 && (l.exports = t3);
}();
var c3 = s.exports;
var d = { exports: {} };
!function(e3) {
  !function(t3) {
    var r2 = function() {
      return ["abs", "acos", "all", "any", "asin", "atan", "ceil", "clamp", "cos", "cross", "dFdx", "dFdy", "degrees", "distance", "dot", "equal", "exp", "exp2", "faceforward", "floor", "fract", "gl_BackColor", "gl_BackLightModelProduct", "gl_BackLightProduct", "gl_BackMaterial", "gl_BackSecondaryColor", "gl_ClipPlane", "gl_ClipVertex", "gl_Color", "gl_DepthRange", "gl_DepthRangeParameters", "gl_EyePlaneQ", "gl_EyePlaneR", "gl_EyePlaneS", "gl_EyePlaneT", "gl_Fog", "gl_FogCoord", "gl_FogFragCoord", "gl_FogParameters", "gl_FragColor", "gl_FragCoord", "gl_FragData", "gl_FragDepth", "gl_FragDepthEXT", "gl_FrontColor", "gl_FrontFacing", "gl_FrontLightModelProduct", "gl_FrontLightProduct", "gl_FrontMaterial", "gl_FrontSecondaryColor", "gl_LightModel", "gl_LightModelParameters", "gl_LightModelProducts", "gl_LightProducts", "gl_LightSource", "gl_LightSourceParameters", "gl_MaterialParameters", "gl_MaxClipPlanes", "gl_MaxCombinedTextureImageUnits", "gl_MaxDrawBuffers", "gl_MaxFragmentUniformComponents", "gl_MaxLights", "gl_MaxTextureCoords", "gl_MaxTextureImageUnits", "gl_MaxTextureUnits", "gl_MaxVaryingFloats", "gl_MaxVertexAttribs", "gl_MaxVertexTextureImageUnits", "gl_MaxVertexUniformComponents", "gl_ModelViewMatrix", "gl_ModelViewMatrixInverse", "gl_ModelViewMatrixInverseTranspose", "gl_ModelViewMatrixTranspose", "gl_ModelViewProjectionMatrix", "gl_ModelViewProjectionMatrixInverse", "gl_ModelViewProjectionMatrixInverseTranspose", "gl_ModelViewProjectionMatrixTranspose", "gl_MultiTexCoord0", "gl_MultiTexCoord1", "gl_MultiTexCoord2", "gl_MultiTexCoord3", "gl_MultiTexCoord4", "gl_MultiTexCoord5", "gl_MultiTexCoord6", "gl_MultiTexCoord7", "gl_Normal", "gl_NormalMatrix", "gl_NormalScale", "gl_ObjectPlaneQ", "gl_ObjectPlaneR", "gl_ObjectPlaneS", "gl_ObjectPlaneT", "gl_Point", "gl_PointCoord", "gl_PointParameters", "gl_PointSize", "gl_Position", "gl_ProjectionMatrix", "gl_ProjectionMatrixInverse", "gl_ProjectionMatrixInverseTranspose", "gl_ProjectionMatrixTranspose", "gl_SecondaryColor", "gl_TexCoord", "gl_TextureEnvColor", "gl_TextureMatrix", "gl_TextureMatrixInverse", "gl_TextureMatrixInverseTranspose", "gl_TextureMatrixTranspose", "gl_Vertex", "greaterThan", "greaterThanEqual", "inversesqrt", "length", "lessThan", "lessThanEqual", "log", "log2", "matrixCompMult", "max", "min", "mix", "mod", "normalize", "not", "notEqual", "pow", "radians", "reflect", "refract", "sign", "sin", "smoothstep", "sqrt", "step", "tan", "texture2D", "texture2DLod", "texture2DProj", "texture2DProjLod", "textureCube", "textureCubeLod", "texture2DLodEXT", "texture2DProjLodEXT", "textureCubeLodEXT", "texture2DGradEXT", "texture2DProjGradEXT", "textureCubeGradEXT"];
    }();
    void 0 !== r2 && (e3.exports = r2);
  }();
}(d);
var u = d.exports;
var g = 999;
var p = 9999;
var f = 0;
var _ = 1;
var h = 2;
var x = 3;
var m = 4;
var y = 5;
var w = 6;
var M = 7;
var v = 8;
var T = 9;
var b = 10;
var P = 11;
var E = ["block-comment", "line-comment", "preprocessor", "operator", "integer", "float", "ident", "builtin", "keyword", "whitespace", "eof", "integer"];
function C() {
  var e3, t3, r2, a2 = 0, o3 = 0, n2 = g, l3 = [], s2 = [], d2 = 1, C2 = 0, k2 = 0, j2 = false, D2 = false, F2 = "";
  return function(e4) {
    return s2 = [], null !== e4 ? S2(e4.replace ? e4.replace(/\r\n/g, "\n") : e4) : R2();
  };
  function L2(e4) {
    e4.length && s2.push({ type: E[n2], data: e4, position: k2, line: d2, column: C2 });
  }
  function S2(t4) {
    var i2;
    for (a2 = 0, r2 = (F2 += t4).length; e3 = F2[a2], a2 < r2; ) {
      switch (i2 = a2, n2) {
        case f:
          a2 = I2();
          break;
        case _:
          a2 = G2();
          break;
        case h:
          a2 = A2();
          break;
        case x:
          a2 = O2();
          break;
        case m:
          a2 = B();
          break;
        case P:
          a2 = q2();
          break;
        case y:
          a2 = H2();
          break;
        case p:
          a2 = N();
          break;
        case T:
          a2 = X2();
          break;
        case g:
          a2 = V2();
      }
      if (i2 !== a2)
        if ("\n" === F2[i2])
          C2 = 0, ++d2;
        else
          ++C2;
    }
    return o3 += a2, F2 = F2.slice(a2), s2;
  }
  function R2(e4) {
    return l3.length && L2(l3.join("")), n2 = b, L2("(eof)"), s2;
  }
  function V2() {
    return l3 = l3.length ? [] : l3, "/" === t3 && "*" === e3 ? (k2 = o3 + a2 - 1, n2 = f, t3 = e3, a2 + 1) : "/" === t3 && "/" === e3 ? (k2 = o3 + a2 - 1, n2 = _, t3 = e3, a2 + 1) : "#" === e3 ? (n2 = h, k2 = o3 + a2, a2) : /\s/.test(e3) ? (n2 = T, k2 = o3 + a2, a2) : (j2 = /\d/.test(e3), D2 = /[^\w_]/.test(e3), k2 = o3 + a2, n2 = j2 ? m : D2 ? x : p, a2);
  }
  function X2() {
    return /[^\s]/g.test(e3) ? (L2(l3.join("")), n2 = g, a2) : (l3.push(e3), t3 = e3, a2 + 1);
  }
  function A2() {
    return "\r" !== e3 && "\n" !== e3 || "\\" === t3 ? (l3.push(e3), t3 = e3, a2 + 1) : (L2(l3.join("")), n2 = g, a2);
  }
  function G2() {
    return A2();
  }
  function I2() {
    return "/" === e3 && "*" === t3 ? (l3.push(e3), L2(l3.join("")), n2 = g, a2 + 1) : (l3.push(e3), t3 = e3, a2 + 1);
  }
  function O2() {
    if ("." === t3 && /\d/.test(e3))
      return n2 = y, a2;
    if ("/" === t3 && "*" === e3)
      return n2 = f, a2;
    if ("/" === t3 && "/" === e3)
      return n2 = _, a2;
    if ("." === e3 && l3.length) {
      for (; U2(l3); )
        ;
      return n2 = y, a2;
    }
    if (";" === e3 || ")" === e3 || "(" === e3) {
      if (l3.length)
        for (; U2(l3); )
          ;
      return L2(e3), n2 = g, a2 + 1;
    }
    var r3 = 2 === l3.length && "=" !== e3;
    if (/[\w_\d\s]/.test(e3) || r3) {
      for (; U2(l3); )
        ;
      return n2 = g, a2;
    }
    return l3.push(e3), t3 = e3, a2 + 1;
  }
  function U2(e4) {
    for (var t4, r3, a3 = 0; ; ) {
      if (t4 = c3.indexOf(e4.slice(0, e4.length + a3).join("")), r3 = c3[t4], -1 === t4) {
        if (a3-- + e4.length > 0)
          continue;
        r3 = e4.slice(0, 1).join("");
      }
      return L2(r3), k2 += r3.length, (l3 = l3.slice(r3.length)).length;
    }
  }
  function q2() {
    return /[^a-fA-F0-9]/.test(e3) ? (L2(l3.join("")), n2 = g, a2) : (l3.push(e3), t3 = e3, a2 + 1);
  }
  function B() {
    return "." === e3 || /[eE]/.test(e3) ? (l3.push(e3), n2 = y, t3 = e3, a2 + 1) : "x" === e3 && 1 === l3.length && "0" === l3[0] ? (n2 = P, l3.push(e3), t3 = e3, a2 + 1) : /[^\d]/.test(e3) ? (L2(l3.join("")), n2 = g, a2) : (l3.push(e3), t3 = e3, a2 + 1);
  }
  function H2() {
    return "f" === e3 && (l3.push(e3), t3 = e3, a2 += 1), /[eE]/.test(e3) || "-" === e3 && /[eE]/.test(t3) ? (l3.push(e3), t3 = e3, a2 + 1) : /[^\d]/.test(e3) ? (L2(l3.join("")), n2 = g, a2) : (l3.push(e3), t3 = e3, a2 + 1);
  }
  function N() {
    if (/[^\d\w_]/.test(e3)) {
      var r3 = l3.join("");
      return n2 = i.indexOf(r3) > -1 ? v : u.indexOf(r3) > -1 ? M : w, L2(l3.join("")), n2 = g, a2;
    }
    return l3.push(e3), t3 = e3, a2 + 1;
  }
}
function k(e3) {
  var t3 = C(), r2 = [];
  return r2 = (r2 = r2.concat(t3(e3))).concat(t3(null));
}
function j(e3) {
  return k(e3);
}
function D(e3) {
  return e3.map((e4) => "eof" !== e4.type ? e4.data : "").join("");
}
var F = ["GL_OES_standard_derivatives", "GL_EXT_frag_depth", "GL_EXT_draw_buffers", "GL_EXT_shader_texture_lod"];
function L(e3, t3 = "100", r2 = "300 es") {
  const a2 = /^\s*\#version\s+([0-9]+(\s+[a-zA-Z]+)?)\s*/;
  for (const o3 of e3)
    if ("preprocessor" === o3.type) {
      const e4 = a2.exec(o3.data);
      if (e4) {
        const a3 = e4[1].replace(/\s\s+/g, " ");
        if (a3 === r2)
          return a3;
        if (a3 === t3)
          return o3.data = "#version " + r2, t3;
        throw new Error("unknown glsl version: " + a3);
      }
    }
  return e3.splice(0, 0, { type: "preprocessor", data: "#version " + r2 }, { type: "whitespace", data: "\n" }), null;
}
function S(e3, t3) {
  for (let r2 = t3 - 1; r2 >= 0; r2--) {
    const t4 = e3[r2];
    if ("whitespace" !== t4.type && "block-comment" !== t4.type) {
      if ("keyword" !== t4.type)
        break;
      if ("attribute" === t4.data || "in" === t4.data)
        return true;
    }
  }
  return false;
}
function R(e3, t3, r2, a2) {
  a2 = a2 || r2;
  for (const o3 of e3)
    if ("ident" === o3.type && o3.data === r2) {
      a2 in t3 ? t3[a2]++ : t3[a2] = 0;
      return R(e3, t3, a2 + "_" + t3[a2], a2);
    }
  return r2;
}
function V(e3, t3, r2 = "afterVersion") {
  function a2(e4, t4) {
    for (let r3 = t4; r3 < e4.length; r3++) {
      const t5 = e4[r3];
      if ("operator" === t5.type && ";" === t5.data)
        return r3;
    }
    return null;
  }
  function o3(e4) {
    let t4 = -1, o4 = 0, n3 = -1;
    for (let i3 = 0; i3 < e4.length; i3++) {
      const l4 = e4[i3];
      if ("preprocessor" === l4.type && (l4.data.match(/\#(if|ifdef|ifndef)\s+.+/) ? ++o4 : l4.data.match(/\#endif\s*.*/) && --o4), "afterVersion" !== r2 && "afterPrecision" !== r2 || "preprocessor" === l4.type && /^#version/.test(l4.data) && (n3 = Math.max(n3, i3)), "afterPrecision" === r2 && "keyword" === l4.type && "precision" === l4.data) {
        const t5 = a2(e4, i3);
        if (null === t5)
          throw new Error("precision statement not followed by any semicolons!");
        n3 = Math.max(n3, t5);
      }
      t4 < n3 && 0 === o4 && (t4 = i3);
    }
    return t4 + 1;
  }
  const n2 = { data: "\n", type: "whitespace" }, i2 = (t4) => t4 < e3.length && /[^\r\n]$/.test(e3[t4].data);
  let l3 = o3(e3);
  i2(l3 - 1) && e3.splice(l3++, 0, n2);
  for (const s2 of t3)
    e3.splice(l3++, 0, s2);
  i2(l3 - 1) && i2(l3) && e3.splice(l3, 0, n2);
}
function X(e3, t3, r2, a2 = "lowp") {
  V(e3, [{ type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: a2 }, { type: "whitespace", data: " " }, { type: "keyword", data: r2 }, { type: "whitespace", data: " " }, { type: "ident", data: t3 }, { type: "operator", data: ";" }], "afterPrecision");
}
function A(e3, t3, r2, a2, o3 = "lowp") {
  V(e3, [{ type: "keyword", data: "layout" }, { type: "operator", data: "(" }, { type: "keyword", data: "location" }, { type: "whitespace", data: " " }, { type: "operator", data: "=" }, { type: "whitespace", data: " " }, { type: "integer", data: a2.toString() }, { type: "operator", data: ")" }, { type: "whitespace", data: " " }, { type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: o3 }, { type: "whitespace", data: " " }, { type: "keyword", data: r2 }, { type: "whitespace", data: " " }, { type: "ident", data: t3 }, { type: "operator", data: ";" }], "afterPrecision");
}
function G(e3, t3) {
  let r2, a2, o3 = -1;
  for (let n2 = t3; n2 < e3.length; n2++) {
    const t4 = e3[n2];
    if ("operator" === t4.type && ("[" === t4.data && (r2 = n2), "]" === t4.data)) {
      a2 = n2;
      break;
    }
    "integer" === t4.type && (o3 = parseInt(t4.data, 10));
  }
  return r2 && a2 && e3.splice(r2, a2 - r2 + 1), o3;
}
function I(a2, o3) {
  const n2 = U(a2);
  if (r(n2))
    return n2;
  const i2 = j(a2);
  if ("300 es" === L(i2, "100", "300 es"))
    return a2;
  let l3 = null, s2 = null;
  const c5 = {}, d2 = {};
  for (let e3 = 0; e3 < i2.length; ++e3) {
    const a3 = i2[e3];
    switch (a3.type) {
      case "keyword":
        o3 === H.VERTEX_SHADER && "attribute" === a3.data ? a3.data = "in" : "varying" === a3.data && (a3.data = o3 === H.VERTEX_SHADER ? "out" : "in");
        break;
      case "builtin":
        if (/^texture(2D|Cube)(Proj)?(Lod|Grad)?(EXT)?$/.test(a3.data.trim()) && (a3.data = a3.data.replace(/(2D|Cube|EXT)/g, "")), o3 === H.FRAGMENT_SHADER && "gl_FragColor" === a3.data && (l3 || (l3 = R(i2, c5, "fragColor"), X(i2, l3, "vec4")), a3.data = l3), o3 === H.FRAGMENT_SHADER && "gl_FragData" === a3.data) {
          const t3 = G(i2, e3 + 1), r2 = R(i2, c5, "fragData");
          A(i2, r2, "vec4", t3, "mediump"), a3.data = r2;
        } else
          o3 === H.FRAGMENT_SHADER && "gl_FragDepthEXT" === a3.data && (s2 || (s2 = R(i2, c5, "gl_FragDepth")), a3.data = s2);
        break;
      case "ident":
        if (e.includes(a3.data)) {
          if (o3 === H.VERTEX_SHADER && S(i2, e3))
            throw new Error("attribute in vertex shader uses a name that is a reserved word in glsl 300 es");
          a3.data in d2 || (d2[a3.data] = R(i2, c5, a3.data)), a3.data = d2[a3.data];
        }
    }
  }
  for (let e3 = i2.length - 1; e3 >= 0; --e3) {
    const t3 = i2[e3];
    if ("preprocessor" === t3.type) {
      const r2 = t3.data.match(/\#extension\s+(.*)\:/);
      if (r2 && r2[1] && F.includes(r2[1].trim())) {
        const t4 = i2[e3 + 1];
        i2.splice(e3, t4 && "whitespace" === t4.type ? 2 : 1);
      }
      const a3 = t3.data.match(/\#ifdef\s+(.*)/);
      a3 && a3[1] && F.includes(a3[1].trim()) && (t3.data = "#if 1");
      const o4 = t3.data.match(/\#ifndef\s+(.*)/);
      o4 && o4[1] && F.includes(o4[1].trim()) && (t3.data = "#if 0");
    }
  }
  return q(a2, D(i2));
}
var O = /* @__PURE__ */ new Map();
function U(e3) {
  return e2.enableCache ? O.get(e3) : null;
}
function q(e3, t3) {
  return e2.enableCache && O.set(e3, t3), t3;
}

// node_modules/@arcgis/core/views/webgl/Program.js
var a = 4294967295;
var h2 = class {
  constructor(t3, o3, i2, a2, h3 = /* @__PURE__ */ new Map()) {
    this._context = t3, this._locations = a2, this._uniformBlockBindings = h3, this._refCount = 1, this._compiled = false, this._nameToUniformLocation = {}, this._nameToUniform1 = {}, this._nameToUniform1v = /* @__PURE__ */ new Map(), this._nameToUniform2 = /* @__PURE__ */ new Map(), this._nameToUniform3 = /* @__PURE__ */ new Map(), this._nameToUniform4 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix3 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix4 = /* @__PURE__ */ new Map(), t3 || console.error("RenderingContext isn't initialized!"), 0 === o3.length && console.error("Shaders source should not be empty!"), this._context.type === o.WEBGL2 && (o3 = I(o3, H.VERTEX_SHADER), i2 = I(i2, H.FRAGMENT_SHADER)), this._vShader = f2(this._context, H.VERTEX_SHADER, o3), this._fShader = f2(this._context, H.FRAGMENT_SHADER, i2), this._vShader && this._fShader || console.error("Error loading shaders!"), this._context.instanceCounter.increment(t2.Shader, this), c2() && (this.vertexShader = o3, this.fragmentShader = i2);
  }
  get glName() {
    if (r(this._glName))
      return this._glName;
    if (t(this._vShader))
      return null;
    const t3 = this._context.gl, r2 = t3.createProgram();
    if (t3.attachShader(r2, this._vShader), t3.attachShader(r2, this._fShader), this._locations.forEach((o3, i2) => t3.bindAttribLocation(r2, o3, i2)), t3.linkProgram(r2), c2() && !t3.getProgramParameter(r2, t3.LINK_STATUS) && console.error(`Could not link shader
validated: ${t3.getProgramParameter(r2, t3.VALIDATE_STATUS)}, gl error ${t3.getError()}, vertex: ${t3.getShaderParameter(this._vShader, t3.COMPILE_STATUS)}, fragment: ${t3.getShaderParameter(this._fShader, t3.COMPILE_STATUS)}, info log: ${t3.getProgramInfoLog(r2)}, vertex source: ${this.vertexShader}, fragment source: ${this.fragmentShader}`), this._context.type === o.WEBGL2) {
      const o3 = t3;
      for (const [t4, i2] of this._uniformBlockBindings) {
        const e3 = o3.getUniformBlockIndex(r2, t4);
        e3 < a && o3.uniformBlockBinding(r2, e3, i2);
      }
    }
    return this._glName = r2, this._context.instanceCounter.increment(t2.Program, this), r2;
  }
  get hasGLName() {
    return r(this._glName);
  }
  get isCompiled() {
    if (this._compiled)
      return true;
    const t3 = this._context.gl.getExtension("KHR_parallel_shader_compile");
    return null == t3 ? (this._compiled = true, true) : (this._compiled = !!this._context.gl.getProgramParameter(this.glName, t3.COMPLETION_STATUS_KHR), this._compiled);
  }
  dispose() {
    if (--this._refCount > 0)
      return;
    const t3 = this._context.gl;
    this._vShader && (t3.deleteShader(this._vShader), this._vShader = null, this._context.instanceCounter.decrement(t2.Shader, this)), this._fShader && (t3.deleteShader(this._fShader), this._fShader = null), this._glName && (t3.deleteProgram(this._glName), this._glName = null, this._context.instanceCounter.decrement(t2.Program, this));
  }
  ref() {
    ++this._refCount;
  }
  _getUniformLocation(t3) {
    return void 0 === this._nameToUniformLocation[t3] && (++l2.numUniforms, this._nameToUniformLocation[t3] = this._context.gl.getUniformLocation(this.glName, t3)), this._nameToUniformLocation[t3];
  }
  hasUniform(t3) {
    return null !== this._getUniformLocation(t3);
  }
  setUniform1i(t3, o3) {
    const i2 = this._nameToUniform1[t3];
    void 0 !== i2 && o3 === i2 || (this._context.gl.uniform1i(this._getUniformLocation(t3), o3), this._nameToUniform1[t3] = o3);
  }
  setUniform1iv(t3, o3) {
    g2(this._nameToUniform1v, t3, o3) && this._context.gl.uniform1iv(this._getUniformLocation(t3), o3);
  }
  setUniform2iv(t3, o3) {
    g2(this._nameToUniform2, t3, o3) && this._context.gl.uniform2iv(this._getUniformLocation(t3), o3);
  }
  setUniform3iv(t3, o3) {
    g2(this._nameToUniform3, t3, o3) && this._context.gl.uniform3iv(this._getUniformLocation(t3), o3);
  }
  setUniform4iv(t3, o3) {
    g2(this._nameToUniform4, t3, o3) && this._context.gl.uniform4iv(this._getUniformLocation(t3), o3);
  }
  setUniform1f(t3, o3) {
    const i2 = this._nameToUniform1[t3];
    void 0 !== i2 && o3 === i2 || (this._context.gl.uniform1f(this._getUniformLocation(t3), o3), this._nameToUniform1[t3] = o3);
  }
  setUniform1fv(t3, o3) {
    g2(this._nameToUniform1v, t3, o3) && this._context.gl.uniform1fv(this._getUniformLocation(t3), o3);
  }
  setUniform2f(t3, o3, i2) {
    const e3 = this._nameToUniform2.get(t3);
    void 0 === e3 ? (this._context.gl.uniform2f(this._getUniformLocation(t3), o3, i2), this._nameToUniform2.set(t3, [o3, i2])) : o3 === e3[0] && i2 === e3[1] || (this._context.gl.uniform2f(this._getUniformLocation(t3), o3, i2), e3[0] = o3, e3[1] = i2);
  }
  setUniform2fv(t3, o3) {
    g2(this._nameToUniform2, t3, o3) && this._context.gl.uniform2fv(this._getUniformLocation(t3), o3);
  }
  setUniform3f(t3, o3, i2, e3) {
    const n2 = this._nameToUniform3.get(t3);
    void 0 === n2 ? (this._context.gl.uniform3f(this._getUniformLocation(t3), o3, i2, e3), this._nameToUniform3[t3] = [o3, i2, e3]) : o3 === n2[0] && i2 === n2[1] && e3 === n2[2] || (this._context.gl.uniform3f(this._getUniformLocation(t3), o3, i2, e3), n2[0] = o3, n2[1] = i2, n2[2] = e3);
  }
  setUniform3fv(t3, o3) {
    g2(this._nameToUniform3, t3, o3) && this._context.gl.uniform3fv(this._getUniformLocation(t3), o3);
  }
  setUniform4f(t3, o3, i2, e3, n2) {
    const r2 = this._nameToUniform4.get(t3);
    void 0 === r2 ? (this._context.gl.uniform4f(this._getUniformLocation(t3), o3, i2, e3, n2), this._nameToUniform4.set(t3, [o3, i2, e3, n2])) : void 0 !== r2 && o3 === r2[0] && i2 === r2[1] && e3 === r2[2] && n2 === r2[3] || (this._context.gl.uniform4f(this._getUniformLocation(t3), o3, i2, e3, n2), r2[0] = o3, r2[1] = i2, r2[2] = e3, r2[3] = n2);
  }
  setUniform4fv(t3, o3) {
    g2(this._nameToUniform4, t3, o3) && this._context.gl.uniform4fv(this._getUniformLocation(t3), o3);
  }
  setUniformMatrix3fv(t3, o3, i2 = false) {
    g2(this._nameToUniformMatrix3, t3, o3) && this._context.gl.uniformMatrix3fv(this._getUniformLocation(t3), i2, o3);
  }
  setUniformMatrix4fv(t3, o3, i2 = false) {
    g2(this._nameToUniformMatrix4, t3, o3) && this._context.gl.uniformMatrix4fv(this._getUniformLocation(t3), i2, o3);
  }
  stop() {
  }
};
function f2(t3, o3, i2) {
  const n2 = t3.gl, s2 = n2.createShader(o3);
  return n2.shaderSource(s2, i2), n2.compileShader(s2), c2() && !n2.getShaderParameter(s2, n2.COMPILE_STATUS) && (console.error("Compile error in ".concat(o3 === H.VERTEX_SHADER ? "vertex" : "fragment", " shader")), console.error(n2.getShaderInfoLog(s2)), console.error(_2(i2))), l2.enabled && (l2.compiledLOC += i2.match(/\n/g).length + 1), s2;
}
function _2(t3) {
  let o3 = 2;
  return t3.replace(/\n/g, () => "\n" + c4(o3++) + ":");
}
function c4(t3) {
  return t3 >= 1e3 ? t3.toString() : ("  " + t3).slice(-3);
}
function g2(o3, i2, e3) {
  const n2 = o3.get(i2);
  return n2 ? c(n2, e3) : (o3.set(i2, Array.from(e3)), true);
}
var l2 = { compiledLOC: 0, numUniforms: 0, enabled: false };

export {
  h2 as h
};
//# sourceMappingURL=chunk-AS3OSZXK.js.map
