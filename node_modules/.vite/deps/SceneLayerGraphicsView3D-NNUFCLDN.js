import {
  a,
  c as c3,
  g as g2,
  i,
  i2
} from "./chunk-BIG2N653.js";
import {
  c as c2
} from "./chunk-PR4JSHVD.js";
import {
  p
} from "./chunk-5XRPB3CU.js";
import {
  f,
  s2,
  te
} from "./chunk-XVC34HIT.js";
import {
  F,
  l as l3
} from "./chunk-IHCVEO7N.js";
import "./chunk-L6YDAPZR.js";
import "./chunk-5SHHATAH.js";
import "./chunk-3ITGQWSQ.js";
import {
  n as n4
} from "./chunk-WLVMYWO2.js";
import "./chunk-7S6G3GM7.js";
import "./chunk-6UGZAJSY.js";
import "./chunk-23E5E222.js";
import "./chunk-UQFAHV7T.js";
import "./chunk-COK4R22F.js";
import "./chunk-T6XN76GI.js";
import "./chunk-EZ4QR7V3.js";
import "./chunk-25Y2OKSP.js";
import "./chunk-DJFBTMGM.js";
import "./chunk-QJN4GT4E.js";
import "./chunk-E452MYWA.js";
import "./chunk-EMETVH63.js";
import "./chunk-V56SVRSV.js";
import "./chunk-XZHFGTRH.js";
import "./chunk-2I27THZD.js";
import "./chunk-X64NQ2GK.js";
import "./chunk-NVOCHKIH.js";
import "./chunk-DGELARKE.js";
import "./chunk-WN3KE5M2.js";
import "./chunk-KBCUY3VB.js";
import "./chunk-PMQUXI6L.js";
import {
  H,
  Me,
  Se,
  ie,
  ze
} from "./chunk-RHH23PAT.js";
import "./chunk-HU4BCST4.js";
import "./chunk-PUR7HIYZ.js";
import "./chunk-O2JKFSHC.js";
import "./chunk-76A4CWFG.js";
import "./chunk-KYD2B4O6.js";
import "./chunk-Y7MFFYJY.js";
import "./chunk-KW6WHTET.js";
import "./chunk-PUU4QXN5.js";
import "./chunk-EHWEX2VK.js";
import {
  c
} from "./chunk-HPO2NV7P.js";
import "./chunk-22O7HU3A.js";
import "./chunk-Y75V5CF3.js";
import "./chunk-PQM6RARY.js";
import "./chunk-2Y5KPYOJ.js";
import "./chunk-BBUIX72C.js";
import "./chunk-5ZS6RUSM.js";
import "./chunk-HTS3HEEU.js";
import "./chunk-CYT6A5IX.js";
import "./chunk-R3PFJUIG.js";
import "./chunk-QWEWSWF7.js";
import "./chunk-7LH2XNVI.js";
import "./chunk-PXOPYXIX.js";
import "./chunk-WSQIVEW5.js";
import "./chunk-ZTFWVZTL.js";
import "./chunk-ELZC3DZT.js";
import "./chunk-TGUQXVQU.js";
import "./chunk-4LQ6NAOX.js";
import "./chunk-K37I5IIG.js";
import "./chunk-GKYJJGE3.js";
import "./chunk-AWIG2DGF.js";
import "./chunk-3236UEJN.js";
import "./chunk-KSOWE6GO.js";
import "./chunk-TCYVDK2B.js";
import "./chunk-PGSJOMCO.js";
import "./chunk-ZLORWBMB.js";
import "./chunk-LJAT5UYW.js";
import "./chunk-OZAI2STL.js";
import "./chunk-CNL2CHF7.js";
import "./chunk-HRAEK6P4.js";
import "./chunk-K6UIDSFF.js";
import {
  t as t2
} from "./chunk-LAHCYKZK.js";
import "./chunk-52W4YMC2.js";
import "./chunk-MHEQOIKQ.js";
import {
  t2 as t3
} from "./chunk-AIONJO5O.js";
import "./chunk-YLSPLHY5.js";
import "./chunk-4GGQTXXY.js";
import "./chunk-MCSRSOMA.js";
import "./chunk-2DP653N7.js";
import "./chunk-QZCFKQOH.js";
import "./chunk-QMP4VG7M.js";
import "./chunk-5RP42VZJ.js";
import "./chunk-7CXXTQLM.js";
import "./chunk-XEWFCJLT.js";
import "./chunk-ZEDAE7EU.js";
import "./chunk-ZEIWFXXO.js";
import "./chunk-YXFNNKMT.js";
import "./chunk-X7CKOX5Z.js";
import "./chunk-7OZR6JFF.js";
import "./chunk-NXOQBIK7.js";
import "./chunk-ERNXFM5T.js";
import "./chunk-6ITXWFMK.js";
import "./chunk-SV4VP57N.js";
import "./chunk-5LWMNFCG.js";
import "./chunk-PWYPPSAW.js";
import "./chunk-5EXPMKQP.js";
import "./chunk-B7F3T673.js";
import "./chunk-QXYW5CVF.js";
import "./chunk-Z7AZMEL6.js";
import "./chunk-FUKESVWQ.js";
import "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-SQ4XLXZO.js";
import "./chunk-6YT7XVZA.js";
import "./chunk-444THZYK.js";
import "./chunk-E3V32BOJ.js";
import "./chunk-VQLKKADV.js";
import "./chunk-D764DGF2.js";
import "./chunk-XEIRRA3E.js";
import "./chunk-PZHH54V6.js";
import "./chunk-PZFKIJU3.js";
import "./chunk-2A3F5J6D.js";
import "./chunk-B3IXFXV6.js";
import "./chunk-EPNT7GPS.js";
import "./chunk-MQLLOFWM.js";
import "./chunk-XNOIZLCR.js";
import "./chunk-PMOPLTRU.js";
import "./chunk-I22L7HNU.js";
import "./chunk-44UD36FH.js";
import "./chunk-ODYLXHP4.js";
import "./chunk-Y5AGUEHG.js";
import "./chunk-DVE4HUBR.js";
import "./chunk-RC6OMMF6.js";
import "./chunk-AWPZQDE5.js";
import "./chunk-OYNEZ5VG.js";
import "./chunk-R67CDTDF.js";
import "./chunk-UCWSHVC4.js";
import "./chunk-DHZ2TSD5.js";
import "./chunk-ZV3LDRB3.js";
import "./chunk-FAF3GP2W.js";
import "./chunk-YSWURJZW.js";
import "./chunk-5JKCNCL2.js";
import "./chunk-2YDCEMEJ.js";
import "./chunk-O7YSDCZE.js";
import "./chunk-767LZ6IM.js";
import "./chunk-TTKSAULB.js";
import "./chunk-WJDUBZ7S.js";
import "./chunk-DNPZNIDB.js";
import "./chunk-WW7VYUQW.js";
import "./chunk-FCDEMPPS.js";
import "./chunk-TEJEYVH4.js";
import "./chunk-HEZ2ATGC.js";
import "./chunk-ECNFP4CF.js";
import "./chunk-AALA53RH.js";
import "./chunk-BOVIIQLB.js";
import "./chunk-IJHFAZOW.js";
import "./chunk-DMGVDNFD.js";
import "./chunk-YAQGRU5B.js";
import "./chunk-M3GMIUQS.js";
import "./chunk-BMA2CXVS.js";
import "./chunk-46N7XS5M.js";
import "./chunk-4MKQUQD4.js";
import "./chunk-A3QLZKCF.js";
import "./chunk-OYAHQ564.js";
import "./chunk-LGILR4HN.js";
import "./chunk-I5UNY2WQ.js";
import {
  n as n3
} from "./chunk-KETNREBT.js";
import "./chunk-GKICNYWA.js";
import "./chunk-EYJ2F5XB.js";
import "./chunk-5EPJG7SL.js";
import "./chunk-XXEJXJP4.js";
import "./chunk-MFOJFHT7.js";
import "./chunk-TR3U55RZ.js";
import "./chunk-3DCTMZI6.js";
import "./chunk-33INAWJA.js";
import "./chunk-5WOO2FX6.js";
import "./chunk-FPMD6IB4.js";
import "./chunk-J73IXFNW.js";
import "./chunk-FFHGE66H.js";
import "./chunk-MOZ4GR2L.js";
import "./chunk-MQBVOUKB.js";
import "./chunk-S5PZEGLP.js";
import "./chunk-PLLZPG4O.js";
import "./chunk-WQLER7IU.js";
import "./chunk-7GTYHKA3.js";
import "./chunk-MOXYEJRV.js";
import "./chunk-EEJIELE6.js";
import "./chunk-Y55TYMBP.js";
import "./chunk-NAB3NF54.js";
import "./chunk-MHB3L22D.js";
import {
  o as o2
} from "./chunk-MDCKEJ7B.js";
import "./chunk-MLAOYRDT.js";
import "./chunk-VMF4NMEB.js";
import "./chunk-NAIF4GWX.js";
import "./chunk-72PB636Q.js";
import "./chunk-RIOXX6J2.js";
import {
  A,
  v
} from "./chunk-SOZCO2CU.js";
import "./chunk-53KI6WDE.js";
import "./chunk-W2HLA6I3.js";
import "./chunk-Q6AASANP.js";
import "./chunk-ZYIEYKCD.js";
import "./chunk-DLM6NKXW.js";
import "./chunk-TQLSOIYV.js";
import "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-2EPPX4WN.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-MZ4JF5C6.js";
import "./chunk-3NPGGTI6.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-NMRWU44S.js";
import "./chunk-RRFFPL7N.js";
import "./chunk-JYR7GBAU.js";
import "./chunk-IG4CY4XM.js";
import "./chunk-CC32E45Q.js";
import "./chunk-V7M26XZ7.js";
import "./chunk-ZN2MGN4S.js";
import {
  L
} from "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import {
  Bn,
  Un,
  zn
} from "./chunk-PZWU5EHT.js";
import "./chunk-JJ7VMWJT.js";
import {
  y
} from "./chunk-OMNBM2E4.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import {
  o
} from "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-4XBERLPX.js";
import "./chunk-D7AOY7GH.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  h,
  l as l2
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  u as u2
} from "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import {
  u
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import {
  n as n2,
  r as r2
} from "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  e as e3
} from "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  M,
  e as e2,
  l,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/3d/layers/I3SPointsWorkerHandle.js
var r3 = class extends n3 {
  constructor(e4) {
    super("SceneLayerWorker", "dracoDecompressPointCloudData", { dracoDecompressPointCloudData: (e5) => [e5.geometryBuffer] }, e4, { hasInitialize: true });
  }
};

// node_modules/@arcgis/core/views/3d/layers/SceneLayerGraphicsView3D.js
var Z = s.getLogger("esri.views.3d.layers.SceneLayerGraphicsView3D");
var Y = i2();
var J = class extends p(c2(n4(g2))) {
  constructor() {
    super(...arguments), this.type = "scene-layer-graphics-3d", this._nodesAddedToStage = /* @__PURE__ */ new Map(), this._queryEngine = null, this._memCache = null, this._interactiveEditingSessions = /* @__PURE__ */ new Map(), this.loadedGraphics = new s2(), this.holeFilling = "always", this.progressiveLoadFactor = 1, this.supportsHeightUnitConversion = true, this._coordinatesOutsideExtentErrors = 0, this._maxCoordinatesOutsideExtentErrors = 20;
  }
  initialize() {
    var _a, _b;
    const e4 = this.layer;
    this.addResolvingPromise(e4.indexInfo), this._attributeOverrides = new f(this.layer, (_a = this.view.resourceController) == null ? void 0 : _a.memoryController), ze(e4, this.view.spatialReference, this.view.viewingMode), this.fieldsHelper = new c3({ layerView: this }), this.updatingHandles.add(() => e4.rangeInfos, (e5) => this._rangeInfosChanged(e5), h), this.updatingHandles.add(() => e4.renderer, (e5, t4) => this._rendererChange(e5, t4)), this.updatingHandles.add(() => [this.parsedDefinitionExpression, this.excludeObjectIdsSorted], () => this._filterChange()), this.updatingHandles.add(() => this.view.floors, () => r(this.processor.filterVisibility) && this.processor.filterVisibility.filterChanged()), this.handles.add(l2(() => t3.I3S_TREE_SHOW_TILES, (e5) => {
      if (e5 && !this._treeDebugger) {
        const e6 = this._controller.crsIndex;
        import("./I3STreeDebugger-6WIFAK4L.js").then(({ I3STreeDebugger: t4 }) => {
          !this._treeDebugger && t3.I3S_TREE_SHOW_TILES && (this._treeDebugger = new t4({ lv: this, view: this.view, nodeSR: e6 }));
        });
      } else
        e5 || !this._treeDebugger || t3.I3S_TREE_SHOW_TILES || (this._treeDebugger.destroy(), this._treeDebugger = null);
    }, h)), this._set("processor", new F({ owner: this, preferredUpdatePolicy: o2.ASYNC, scaleVisibilityEnabled: true, filterVisibilityEnabled: true, timeExtentEnabled: false, frustumVisibilityEnabled: false, elevationAlignmentEnabled: true, elevationFeatureExpressionEnabled: false, dataExtent: e4.fullExtent, updateClippingExtent: (e5) => this._updateClippingExtent(e5) })), (_b = this.processor.elevationAlignment) == null ? void 0 : _b.events.on("invalidate-elevation", (e5) => this._invalidateElevation(e5)), this.supportsHeightUnitConversion && (this._verticalScale = o("point", e4.spatialReference, this.view.spatialReference)), this.addResolvingPromise(this.processor.setup()), this._memCache = this.view.resourceController.memoryController.newCache(e4.uid), this._controller = new te({ layerView: this, scaleVisibilityEnabled: false }), ie(this.layer.geometryDefinitions) && (this._worker = new r3((e5) => this.view.resourceController.schedule(e5))), this.handles.add(this.layer.on("apply-edits", (e5) => this.updatingHandles.addPromise(e5.result))), this.handles.add(this.layer.on("edits", (e5) => this._handleEdits(e5))), this.when(() => {
      this._queryEngine = new l3({ layerView: this, priority: L.FEATURE_QUERY_ENGINE }), this.updatingHandles.add(() => this.maximumNumberOfFeatures, (e5) => this._controller.featureTarget = e5, h), this.updatingHandles.add(() => this.suspended, (e5) => {
        e5 && this._removeAllNodeData();
      });
    });
  }
  destroy() {
    this._treeDebugger = l(this._treeDebugger), this._attributeOverrides = l(this._attributeOverrides), this._set("processor", l(this.processor)), this._controller = l(this._controller), this._queryEngine = l(this._queryEngine), this._worker = l(this._worker), this._memCache = l(this._memCache), this._nodesAddedToStage.clear(), this.fieldsHelper = l(this.fieldsHelper);
  }
  get requiredFields() {
    var _a;
    return ((_a = this.fieldsHelper) == null ? void 0 : _a.requiredFields) ?? [];
  }
  get maximumNumberOfFeatures() {
    var _a, _b;
    const e4 = (_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.displayFeatureLimit;
    return (e4 == null ? void 0 : e4.maximumNumberOfFeatures) ?? 0;
  }
  set maximumNumberOfFeatures(e4) {
    null != e4 ? (this._override("maximumNumberOfFeatures", e4), this._controller.fixedFeatureTarget = true) : (this._clearOverride("maximumNumberOfFeatures"), this._controller.fixedFeatureTarget = false);
  }
  get maximumNumberOfFeaturesExceeded() {
    var _a;
    return !this.suspended && (!!((_a = this._controller) == null ? void 0 : _a.useMaximumNumberOfFeatures) && !this._controller.leavesReached);
  }
  get excludeObjectIdsSorted() {
    const e4 = this.layer.excludeObjectIds;
    return e4.length ? e4.toArray().sort((e5, t4) => e5 - t4) : null;
  }
  get lodFactor() {
    return "Labels" === this.layer.semantic ? 1 : this.view.qualitySettings.sceneService.point.lodFactor;
  }
  get hasM() {
    return false;
  }
  get hasZ() {
    return true;
  }
  async whenGraphicAttributes(e4, t4) {
    return Se(this.layer, e4, this._getObjectIdField(), t4, () => [...this._nodesAddedToStage.values()]);
  }
  getHit(e4) {
    if (!this.loadedGraphics)
      return null;
    const t4 = c(this.loadedGraphics.find((t5) => t5.uid === e4), this.layer), r4 = this._getObjectIdField();
    return t4 && t4.attributes && t4.attributes[r4] ? (t4.layer = this.layer, t4.sourceLayer = this.layer, { type: "graphic", graphic: t4, layer: t4.layer }) : null;
  }
  whenGraphicBounds(e4, t4) {
    return this.processor.whenGraphicBounds(e4, t4);
  }
  computeAttachmentOrigin(e4, t4) {
    return this.processor.computeAttachmentOrigin(e4, t4);
  }
  canResume() {
    return super.canResume() && (!this._controller || this._controller.rootNodeVisible);
  }
  isUpdating() {
    var _a, _b, _c;
    return !!(((_a = this._controller) == null ? void 0 : _a.updating) || ((_b = this.processor) == null ? void 0 : _b.updating) || ((_c = this.fieldsHelper) == null ? void 0 : _c.updating) || this.layerFilterUpdating);
  }
  highlight(e4) {
    return this.processor.highlight(e4, this.layer.objectIdField);
  }
  get updatePolicy() {
    return this.processor.graphicsCore.effectiveUpdatePolicy;
  }
  createInteractiveEditSession(e4) {
    return i(this.attributeEditingContext, e4);
  }
  async _extractBinaryPointData(e4, t4) {
    const r4 = { geometryBuffer: e4.geometryBuffer };
    return t(this._worker) && (this._worker = new r3((e5) => this.view.resourceController.schedule(e5))), this._worker.invoke(r4, t4).then((e5) => {
      if (r(e5)) {
        return { positionData: e5.positions, featureIds: e5.featureIds };
      }
      throw new Error("Failed to decompress Draco point data");
    });
  }
  _checkExtent(e4, t4) {
    e4 && !e3(e4, t4) && (this._coordinatesOutsideExtentErrors < this._maxCoordinatesOutsideExtentErrors && Z.error("Service Error: Coordinates outside of layer extent"), this._coordinatesOutsideExtentErrors + 1 === this._maxCoordinatesOutsideExtentErrors && Z.error("Maximum number of errors reached. Further errors are ignored."), this._coordinatesOutsideExtentErrors++);
  }
  async addNode(e4, t4, r4) {
    if (!ee(t4) && !X(t4))
      throw new Error();
    if (this._nodesAddedToStage.has(e4.index))
      return void Z.error("I3S node " + e4.id + " already added");
    const i3 = r(this.layer.fullExtent) ? re(this.layer.fullExtent.clone(), 0.5) : null, o3 = this._controller.crsVertex, a2 = [], n5 = { graphics: null, featureIds: null, attributeInfo: t4.attributeDataInfo, node: e4 };
    if (ee(t4) ? await this._addNodeBinaryPointData(e4, n5, t4, i3, a2, r4) : X(t4) && this._addNodeLegacyPointData(e4, n5, t4, i3, a2), await this._attributeOverrides.apply(n5.featureIds, t4.attributeDataInfo, r4), e4.numFeatures = n5.graphics.length, this._updateNodeMemory(e4), te2(n5), a2.length > 0 && (this._computeObb(e4, a2, o3), this._controller.updateVisibility(e4.index)), this._controller.isGeometryVisible(e4)) {
      if (r(this._verticalScale))
        for (const e5 of n5.graphics)
          this._verticalScale(e5.geometry);
      this._nodesAddedToStage.set(e4.index, n5), this.loadedGraphics.addMany(n5.graphics), this._controller.updateLoadStatus(e4.index, true), this._filterNode(n5), this._treeDebugger && this._treeDebugger.update();
    } else
      this._cacheNodeData(n5);
  }
  _computeObb(e4, t4, r4) {
    const i3 = this._controller.crsIndex, s3 = i3.isGeographic ? this.view.renderSpatialReference : i3;
    Un(t4, r4, 0, t4, s3, 0, t4.length / 3);
    const o3 = { data: t4, size: 3 };
    e4.serviceObb = H(o3), i3.isGeographic && Bn(e4.serviceObb.center, s3, e4.serviceObb.center, i3);
  }
  isNodeLoaded(e4) {
    return this._nodesAddedToStage.has(e4);
  }
  isNodeReloading() {
    return false;
  }
  updateNodeState() {
  }
  async _addNodeBinaryPointData(e4, r4, i3, o3, a2, d2) {
    const l4 = await this._extractBinaryPointData(i3, d2);
    if (null == l4)
      throw new Error();
    const h2 = this._getObjectIdField(), u3 = this._controller.crsVertex, g3 = this.view.spatialReference, y2 = this.processor.graphicsCore, { positionData: f2, featureIds: _ } = l4, b2 = 3, v2 = f2.length / b2, x = new Array();
    for (let I = 0; I < v2; I++) {
      const r5 = r(e4.serviceObb) ? e4.serviceObb.center : [0, 0, 0], i4 = I * b2, d3 = r2(f2[i4 + 0], f2[i4 + 1], f2[i4 + 2]);
      u(d3, d3, r5), e4.serviceObb || a2.push(d3[0], d3[1], d3[2]), r(o3) && this._checkExtent(o3, d3);
      const l5 = _[I], v3 = {};
      null != l5 && (v3[h2] = l5);
      const S = null == l5 ? g.generateUID() : l5;
      Un(d3, u3, 0, se, g3, 0, 1);
      const w = v(se[0], se[1], se[2], g3), D = this.loadedGraphics.get(S);
      if (r(D))
        D.level < e4.level && (oe.property = "geometry", oe.graphic = D, oe.oldValue = e2(D.geometry), oe.newValue = w, D.geometry = w, y2.graphicUpdateHandler(oe)), x.push(D);
      else {
        const r6 = g.generateUID();
        x.push({ objectId: S, uid: r6, geometry: w, attributes: v3, visible: true, level: e4.level });
      }
    }
    r4.graphics = x, r4.featureIds = Array.from(_);
  }
  _addNodeLegacyPointData(e4, r4, i3, o3, a2) {
    const n5 = this._getObjectIdField(), d2 = this._controller.crsVertex, l4 = this.view.spatialReference, h2 = [0, 0, 0], u3 = new Array(), c4 = new Array();
    for (const p2 of i3.pointData) {
      const r5 = p2.featureDataPosition, i4 = r5.length, g3 = p2.geometries && p2.geometries[0] || ie2[i4], y2 = p2.featureIds[0];
      if ("points" !== g3.params.type)
        continue;
      r(o3) && this._checkExtent(o3, r5);
      const f2 = {};
      null != y2 && (f2[n5] = y2);
      const _ = null == y2 ? g.generateUID() : y2;
      let b2;
      "Embedded" === g3.type && (b2 = g3.params.vertexAttributes.position);
      for (let o4 = 0; o4 < b2.length; o4 += i4) {
        for (let e5 = 0; e5 < i4; e5++)
          h2[e5] = r5[e5] + b2[o4 + e5];
        const n6 = 3 === i4;
        e4.serviceObb || a2.push(h2[0], h2[1], n6 ? h2[2] : 0), Un(h2, d2, 0, se, l4, 0, 1);
        const u4 = v(se[0], se[1], n6 ? se[2] : void 0, l4), p3 = this.loadedGraphics.get(_);
        r(p3) ? c4.push(p3) : c4.push({ objectId: _, uid: g.generateUID(), geometry: u4, attributes: f2, visible: true });
      }
      u3.push(y2);
    }
    r4.graphics = c4, r4.featureIds = u3;
  }
  _updateNodeMemory(e4) {
    e4.memory = 4096 + (r(e4.numFeatures) ? e4.numFeatures * this.processor.graphicsCore.usedMemoryPerGraphic : 0);
  }
  _cacheNodeData(e4) {
    const t4 = e4.graphics.reduce((e5, t5) => A(t5) + e5, 512 + 8 * e4.featureIds.length + 1024);
    this._memCache.put(this._getMemCacheKey(e4.node), e4, t4);
  }
  _getMemCacheKey(e4) {
    return `${e4.index}`;
  }
  _removeAllNodeData() {
    this._nodesAddedToStage.forEach((e4, t4) => {
      if (e4) {
        const t5 = e4.node;
        this._updateNodeMemory(t5), this._cacheNodeData(e4);
      }
      this._controller.updateLoadStatus(t4, false);
    }), this._nodesAddedToStage.clear(), this._treeDebugger && this._treeDebugger.update(), this.loadedGraphics.clear();
  }
  removeNode(e4) {
    const t4 = this._removeNodeStageData(e4);
    t4 && (this._updateNodeMemory(t4.node), this._cacheNodeData(t4));
  }
  _removeNodeStageData(e4) {
    const t4 = this._nodesAddedToStage.get(e4);
    return t4 ? (this._controller.updateLoadStatus(e4, false), this.loadedGraphics.removeMany(t4.graphics), this._nodesAddedToStage.delete(e4), this._treeDebugger && this._treeDebugger.update(), t4) : null;
  }
  async loadCachedNodeData(e4) {
    return this._memCache.pop(this._getMemCacheKey(e4));
  }
  async addCachedNodeData(e4, t4, r4, i3) {
    this._nodesAddedToStage.has(e4.index) ? Z.error("I3S node " + e4.id + " already added") : (this.loadedGraphics.addMany(t4.graphics), this._nodesAddedToStage.set(e4.index, t4), this._controller.updateLoadStatus(e4.index, true), this._updateNodeMemory(e4), await this.updateAttributes(e4.index, r4, i3), this._filterNode(t4), this._treeDebugger && this._treeDebugger.update());
  }
  getLoadedNodeIds() {
    const e4 = [];
    return this._nodesAddedToStage.forEach((t4) => e4.push(t4.node.id)), e4.sort();
  }
  getVisibleNodes() {
    const e4 = new Array();
    return this._nodesAddedToStage.forEach((t4) => e4.push(t4.node)), e4;
  }
  getLoadedNodeIndices(e4) {
    this._nodesAddedToStage.forEach((t4, r4) => e4.push(r4));
  }
  getLoadedAttributes(e4) {
    const t4 = this._nodesAddedToStage.get(e4);
    if (t4 && r(t4.attributeInfo))
      return t4.attributeInfo.loadedAttributes;
  }
  getAttributeData(e4) {
    const t4 = this._nodesAddedToStage.get(e4);
    if (t4 && r(t4.attributeInfo))
      return t4.attributeInfo.attributeData;
  }
  _setAttributeData(e4, t4) {
    const r4 = this._nodesAddedToStage.get(e4);
    r4 && !t(r4.attributeInfo) && (r4.attributeInfo.attributeData = t4, this._attributeValuesChanged(r4));
  }
  async updateAttributes(e4, t4, r4) {
    const i3 = this._nodesAddedToStage.get(e4);
    i3 && (await this._attributeOverrides.apply(i3.featureIds, t4, r4), i3.attributeInfo = t4, this._attributeValuesChanged(i3));
  }
  _attributeValuesChanged(e4) {
    if (te2(e4), this._filterNode(e4), this.processor.graphicsCore.labelsEnabled) {
      const t4 = e4.graphics.map((e5) => e5.uid);
      this.processor.graphicsCore.updateLabelingInfo(t4);
    }
  }
  _updateClippingExtent(e4) {
    return this._controller && this._controller.updateClippingArea(e4), false;
  }
  _getObjectIdField() {
    return this.layer.objectIdField || "OBJECTID";
  }
  async _rendererChange(e4, t4) {
    const { layer: { fieldsIndex: r4 } } = this, i3 = /* @__PURE__ */ new Set();
    let s3, o3;
    e4 ? (await e4.collectRequiredFields(i3, r4), s3 = Array.from(i3).sort()) : s3 = [], i3.clear(), t4 ? (await t4.collectRequiredFields(i3, r4), o3 = Array.from(i3).sort()) : o3 = [], s3.length === o3.length && s3.every((e5, t5) => s3[t5] === o3[t5]) || this._reloadAllNodes();
  }
  _rangeInfosChanged(e4) {
    null != e4 && e4.length > 0 && Z.warn("Unsupported property: rangeInfos are currently only serialized to and from web scenes but do not affect rendering.");
  }
  _filterChange() {
    this._nodesAddedToStage.forEach((e4) => this._filterNode(e4));
  }
  _reloadAllNodes() {
    this._removeAllNodeData(), this._controller && this._controller.restartNodeLoading();
  }
  _filterNode(e4) {
    const t4 = this.parsedDefinitionExpression, i3 = this.excludeObjectIdsSorted, s3 = this._getObjectIdField();
    for (const o3 of e4.graphics) {
      const e5 = o3.visible, n5 = !t4 || this._evaluateClause(t4, o3), d2 = t(i3) || M(i3, o3.attributes[s3]) < 0;
      o3.visible = n5 && d2, e5 !== o3.visible && (oe.graphic = o3, oe.property = "visible", oe.oldValue = e5, oe.newValue = o3.visible, this.processor.graphicsCore.graphicUpdateHandler(oe));
    }
  }
  _invalidateElevation(e4) {
    const t4 = this._controller.crsIndex;
    zn(e4.extent, e4.spatialReference, ae, t4), this._controller.updateElevationChanged(ae, t4);
  }
  createQuery() {
    const e4 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
    return r(this.filter) ? this.filter.createQuery(e4) : new b(e4);
  }
  queryFeatures(e4, t4) {
    return this._queryEngine.executeQuery(this._ensureQuery(e4), t4 == null ? void 0 : t4.signal);
  }
  queryObjectIds(e4, t4) {
    return this._queryEngine.executeQueryForIds(this._ensureQuery(e4), t4 == null ? void 0 : t4.signal);
  }
  queryFeatureCount(e4, t4) {
    return this._queryEngine.executeQueryForCount(this._ensureQuery(e4), t4 == null ? void 0 : t4.signal);
  }
  queryExtent(e4, t4) {
    return this._queryEngine.executeQueryForExtent(this._ensureQuery(e4), t4 == null ? void 0 : t4.signal);
  }
  _ensureQuery(e4) {
    return this._addDefinitionExpressionToQuery(t(e4) ? this.createQuery() : b.from(e4));
  }
  getUsedMemory() {
    var _a, _b;
    return ((_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.usedMemory) ?? 0;
  }
  getUnloadedMemory() {
    var _a, _b, _c;
    return 0.8 * ((((_a = this._controller) == null ? void 0 : _a.unloadedMemoryEstimate) ?? 0) + (((_c = (_b = this.processor) == null ? void 0 : _b.graphicsCore) == null ? void 0 : _c.unprocessedMemoryEstimate) ?? 0));
  }
  ignoresMemoryFactor() {
    return this._controller && this._controller.fixedFeatureTarget;
  }
  _handleEdits(e4) {
    a(this.attributeEditingContext, e4);
  }
  get attributeEditingContext() {
    const e4 = this._getObjectIdField();
    return { sessions: this._interactiveEditingSessions, fieldsIndex: this.layer.fieldsIndex, objectIdField: e4, forEachNode: (e5) => this._nodesAddedToStage.forEach((t4) => e5(t4.node, t4.featureIds)), attributeStorageInfo: this.i3slayer.attributeStorageInfo, attributeOverrides: this._attributeOverrides, getAttributeData: (e5) => this.getAttributeData(e5), setAttributeData: (t4, r4, i3) => {
      this._setAttributeData(t4, r4);
      const o3 = this._nodesAddedToStage.get(t4);
      if (r(i3)) {
        const t5 = this.loadedGraphics.get(i3.attributes[e4]);
        r(t5) && this.processor.graphicsCore.recreateGraphics([t5]);
      } else
        r(o3) && this.processor.graphicsCore.recreateGraphics(o3.graphics);
    }, clearMemCache: () => {
    } };
  }
  get performanceInfo() {
    const e4 = { displayedNumberOfFeatures: this.loadedGraphics.length, maximumNumberOfFeatures: this.maximumNumberOfFeatures, totalNumberOfFeatures: -1, nodes: this._nodesAddedToStage.size, core: this.processor.graphicsCore.performanceInfo };
    return this._controller && this._controller.updateStats(e4), e4;
  }
  get test() {
    return { controller: this._controller, numNodes: this._nodesAddedToStage.size, loadedGraphics: this.loadedGraphics };
  }
};
e([d()], J.prototype, "processor", void 0), e([d({ type: y })], J.prototype, "filter", void 0), e([d()], J.prototype, "loadedGraphics", void 0), e([d({ aliasOf: "layer" })], J.prototype, "i3slayer", void 0), e([d()], J.prototype, "_controller", void 0), e([d()], J.prototype, "updating", void 0), e([d()], J.prototype, "suspended", void 0), e([d()], J.prototype, "holeFilling", void 0), e([d(t2)], J.prototype, "updatingProgress", void 0), e([d({ aliasOf: "_controller.updatingProgress" })], J.prototype, "updatingProgressValue", void 0), e([d(Y.requiredFields)], J.prototype, "requiredFields", null), e([d(Y.availableFields)], J.prototype, "availableFields", void 0), e([d()], J.prototype, "fieldsHelper", void 0), e([d({ type: Number })], J.prototype, "maximumNumberOfFeatures", null), e([d({ readOnly: true })], J.prototype, "maximumNumberOfFeaturesExceeded", null), e([d()], J.prototype, "excludeObjectIdsSorted", null), e([d({ readOnly: true })], J.prototype, "lodFactor", null), e([d({ readOnly: true })], J.prototype, "hasM", null), e([d({ readOnly: true })], J.prototype, "hasZ", null), J = e([n("esri.views.3d.layers.SceneLayerGraphicsView3D")], J);
var $ = J;
function X(e4) {
  return "pointData" in e4;
}
function ee(e4) {
  return "geometryBuffer" in e4 && null !== e4.geometryBuffer;
}
function te2(e4) {
  const t4 = e4.attributeInfo;
  for (let r4 = 0; r4 < e4.graphics.length; r4++) {
    const i3 = e4.graphics[r4];
    if (i3.attributes || (i3.attributes = {}), r(t4) && r(t4.loadedAttributes))
      for (const { name: e5 } of t4.loadedAttributes)
        t4.attributeData[e5] && (i3.attributes[e5] = Me(t4.attributeData[e5], r4));
  }
}
function re(e4, t4) {
  return e4.xmin -= t4, e4.ymin -= t4, e4.xmax += t4, e4.ymax += t4, e4.hasZ && (e4.zmin -= t4, e4.zmax += t4), e4.hasM && (e4.mmin -= t4, e4.mmax += t4), e4;
}
var ie2 = { 2: { type: "Embedded", params: { type: "points", vertexAttributes: { position: [0, 0] } } }, 3: { type: "Embedded", params: { type: "points", vertexAttributes: { position: [0, 0, 0] } } } };
var se = n2();
var oe = { graphic: null, property: null, oldValue: null, newValue: null };
var ae = u2();
export {
  $ as default
};
//# sourceMappingURL=SceneLayerGraphicsView3D-NNUFCLDN.js.map
