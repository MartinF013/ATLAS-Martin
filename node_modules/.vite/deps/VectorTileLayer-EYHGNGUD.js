import {
  l
} from "./chunk-57NDR3D3.js";
import "./chunk-PNNMRFHO.js";
import "./chunk-4V2P7IXX.js";
import "./chunk-SF7Z6XNR.js";
import {
  e as e4
} from "./chunk-SXVJRHUR.js";
import "./chunk-HH3D3A65.js";
import "./chunk-YDPQRKY4.js";
import "./chunk-CMKLTW5X.js";
import "./chunk-YSQDB5AA.js";
import "./chunk-33INAWJA.js";
import "./chunk-FPMD6IB4.js";
import {
  l as l2
} from "./chunk-6EODZIDR.js";
import "./chunk-MV2XZ5BA.js";
import {
  e as e3
} from "./chunk-PQO66WZ2.js";
import "./chunk-HB4HVKJV.js";
import {
  s as s3
} from "./chunk-6QQDRYUS.js";
import {
  n as n2,
  z
} from "./chunk-IFZAYQVB.js";
import {
  S
} from "./chunk-HR2OX32D.js";
import "./chunk-7ZPDA3EC.js";
import {
  i
} from "./chunk-Y6YGVGFR.js";
import {
  p
} from "./chunk-GKRQ3NBT.js";
import {
  o as o2
} from "./chunk-MZX3HN4G.js";
import "./chunk-6GPADSSO.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F5A4XAOJ.js";
import {
  v
} from "./chunk-OG6CQEZJ.js";
import {
  c
} from "./chunk-X5Z3DJQ4.js";
import {
  O as O2
} from "./chunk-BUWXVMJU.js";
import "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import {
  a
} from "./chunk-D3XXPCBB.js";
import {
  t
} from "./chunk-OWBMOIIV.js";
import {
  b
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import {
  U as U2
} from "./chunk-OO2JXX7L.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-Y7FSCP47.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  Bt,
  C,
  Ct,
  F,
  G,
  H,
  I,
  K,
  Ot,
  ft,
  j
} from "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import {
  r as r2
} from "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  O,
  f,
  g,
  w
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  r,
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  e as e2
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/support/imageUtils.js
var A = null;
function o3(o7) {
  if (A)
    return A;
  const l5 = { lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA" };
  return A = new Promise((A2) => {
    const n4 = new Image();
    n4.onload = () => {
      n4.onload = n4.onerror = null, A2(n4.width > 0 && n4.height > 0);
    }, n4.onerror = () => {
      n4.onload = n4.onerror = null, A2(false);
    }, n4.src = "data:image/webp;base64," + l5[o7];
  }), A;
}

// node_modules/@arcgis/core/layers/support/SpriteSource.js
var h = s.getLogger("esri.layers.support.SpriteSource");
var r3 = 1.15;
var o4 = class {
  constructor(t3, e6, i2, s5) {
    this.baseURL = t3, this.devicePixelRatio = e6, this.maxTextureSize = i2, this._spriteImageFormat = s5, this._isRetina = false, this._spritesData = {}, this.image = null, this.width = null, this.height = null, this.loadStatus = "not-loaded";
  }
  get spriteNames() {
    const t3 = [];
    for (const e6 in this._spritesData)
      t3.push(e6);
    return t3.sort(), t3;
  }
  getSpriteInfo(t3) {
    return this._spritesData[t3];
  }
  async load(t3) {
    if (this.baseURL) {
      this.loadStatus = "loading";
      try {
        await this._loadSprites(t3), this.loadStatus = "loaded";
      } catch {
        this.loadStatus = "failed";
      }
    } else
      this.loadStatus = "failed";
  }
  _loadSprites(i2) {
    this._isRetina = this.devicePixelRatio > r3;
    const o7 = j(this.baseURL), l5 = o7.query ? "?" + I(o7.query) : "", n4 = this._isRetina ? "@2x" : "", d3 = `${o7.path}${n4}.${this._spriteImageFormat}${l5}`, g3 = `${o7.path}${n4}.json${l5}`;
    return Promise.all([U(g3, i2), U(d3, { responseType: "image", ...i2 })]).then(([t3, i3]) => {
      const s5 = Object.keys(t3.data);
      if (!s5 || 0 === s5.length || 1 === s5.length && "_ssl" === s5[0] || !i3 || !i3.data)
        return this._spritesData = this.image = null, this.width = this.height = 0, null;
      this._spritesData = t3.data;
      const a3 = i3.data, r6 = Math.max(this.maxTextureSize, 4096);
      if (a3.width > r6 || a3.height > r6) {
        const t4 = `Sprite resource for style ${o7.path} is bigger than the maximum allowed of ${r6} pixels}`;
        throw h.error(t4), new s2("SpriteSource", t4);
      }
      this.width = a3.width, this.height = a3.height;
      const l6 = document.createElement("canvas"), n5 = l6.getContext("2d");
      l6.width = a3.width, l6.height = a3.height, n5.drawImage(a3, 0, 0, a3.width, a3.height);
      const d4 = n5.getImageData(0, 0, a3.width, a3.height), g4 = new Uint8Array(d4.data);
      let u;
      for (let e6 = 0; e6 < g4.length; e6 += 4)
        u = g4[e6 + 3] / 255, g4[e6] = g4[e6] * u, g4[e6 + 1] = g4[e6 + 1] * u, g4[e6 + 2] = g4[e6 + 2] * u;
      this.image = g4;
    });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapIndex.js
var l3 = class {
  constructor(e6) {
    this.url = e6;
  }
  async fetchTileIndex() {
    return this._tileIndexPromise || (this._tileIndexPromise = U(this.url).then((e6) => e6.data.index)), this._tileIndexPromise;
  }
  async dataKey(e6, r6) {
    const l5 = await this.fetchTileIndex();
    return f(r6), this._getIndexedDataKey(l5, e6);
  }
  _getIndexedDataKey(e6, t3) {
    const l5 = [t3];
    if (t3.level < 0 || t3.row < 0 || t3.col < 0 || t3.row >> t3.level > 0 || t3.col >> t3.level > 0)
      return null;
    let i2 = t3;
    for (; 0 !== i2.level; )
      i2 = new e3(i2.level - 1, i2.row >> 1, i2.col >> 1, i2.world), l5.push(i2);
    let o7, s5, n4 = e6, a3 = l5.pop();
    if (1 === n4)
      return a3;
    for (; l5.length; )
      if (o7 = l5.pop(), s5 = (1 & o7.col) + ((1 & o7.row) << 1), n4) {
        if (0 === n4[s5]) {
          a3 = null;
          break;
        }
        if (1 === n4[s5]) {
          a3 = o7;
          break;
        }
        a3 = o7, n4 = n4[s5];
      }
    return a3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapRequest.js
var r4 = class {
  constructor(e6, t3) {
    this._tilemap = e6, this._tileIndexUrl = t3;
  }
  async fetchTileIndex(t3) {
    return this._tileIndexPromise || (this._tileIndexPromise = U(this._tileIndexUrl, { query: { ...t3 == null ? void 0 : t3.query } }).then((e6) => e6.data.index)), this._tileIndexPromise;
  }
  dataKey(e6, r6) {
    const { level: l5, row: s5, col: o7 } = e6, n4 = new e3(e6);
    return this._tilemap.fetchAvailabilityUpsample(l5, s5, o7, n4, r6).then(() => (n4.world = e6.world, n4)).catch((e7) => {
      if (g(e7))
        throw e7;
      return null;
    });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTilesRequestManager.js
var r5 = /* @__PURE__ */ new Map();
function n3(e6, t3, r6, n4, c2) {
  return o5(e6.replace(/\{z\}/gi, t3.toString()).replace(/\{y\}/gi, r6.toString()).replace(/\{x\}/gi, n4.toString()), c2);
}
function o5(n4, o7) {
  const c2 = r5.get(n4);
  if (c2)
    return c2.then((e6) => m(e6));
  const i2 = U(n4, { responseType: "array-buffer", ...o7 }).then(({ data: e6 }) => (r5.delete(n4), e6)).catch((e6) => {
    throw r5.delete(n4), e6;
  });
  return r5.set(n4, i2), i2;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTileSource.js
var h2 = class {
  constructor(u, h4, m3) {
    this.tilemap = null, this.tileInfo = null, this.capabilities = null, this.fullExtent = null, this.name = u, this.sourceUrl = h4;
    const f2 = j(this.sourceUrl), c2 = m(m3), x2 = c2.tiles;
    if (f2)
      for (let t3 = 0; t3 < x2.length; t3++) {
        const s5 = j(x2[t3]);
        s5 && (K(s5.path) || (s5.path = G(f2.path, s5.path)), x2[t3] = Bt(s5.path, { ...f2.query, ...s5.query }));
      }
    this.tileServers = x2;
    const d3 = m3.capabilities && m3.capabilities.split(",").map((t3) => t3.toLowerCase().trim()), y2 = true === (m3 == null ? void 0 : m3.exportTilesAllowed), T = true === (d3 == null ? void 0 : d3.includes("tilemap")), g3 = y2 && m3.hasOwnProperty("maxExportTilesCount") ? m3.maxExportTilesCount : 0;
    this.capabilities = { operations: { supportsExportTiles: y2, supportsTileMap: T }, exportTiles: y2 ? { maxExportTilesCount: +g3 } : null }, this.tileInfo = n2(c2.tileInfo, c2, null, { ignoreMinMaxLOD: true });
    const M2 = m3.tileMap ? Bt(G(f2.path, m3.tileMap), f2.query) : null;
    T ? (this.type = "vector-tile", this.tilemap = new r4(new z({ layer: { parsedUrl: f2, tileInfo: this.tileInfo, type: "vector-tile", tileServers: this.tileServers } }), M2)) : M2 && (this.tilemap = new l3(M2)), this.fullExtent = M.fromJSON(m3.fullExtent);
  }
  destroy() {
  }
  async getRefKey(t3, e6) {
    var _a;
    return ((_a = this.tilemap) == null ? void 0 : _a.dataKey(t3, e6)) ?? t3;
  }
  requestTile(t3, e6, i2, r6) {
    const l5 = this.tileServers[e6 % this.tileServers.length];
    return n3(l5, t3, e6, i2, r6);
  }
  isCompatibleWith(t3) {
    const e6 = this.tileInfo, i2 = t3.tileInfo;
    if (!e6.spatialReference.equals(i2.spatialReference))
      return false;
    if (!e6.origin.equals(i2.origin))
      return false;
    if (Math.round(e6.dpi) !== Math.round(i2.dpi))
      return false;
    const r6 = e6.lods, l5 = i2.lods, s5 = Math.min(r6.length, l5.length);
    for (let o7 = 0; o7 < s5; o7++) {
      const t4 = r6[o7], e7 = l5[o7];
      if (t4.level !== e7.level || Math.round(t4.scale) !== Math.round(e7.scale))
        return false;
    }
    return true;
  }
};

// node_modules/@arcgis/core/layers/support/vectorTileLayerLoader.js
var y = r.defaults && r.defaults.io.corsEnabledServers;
async function m2(e6, r6) {
  const t3 = { source: null, sourceBase: null, sourceUrl: null, validatedSource: null, style: null, styleBase: null, styleUrl: null, sourceNameToSource: {}, primarySourceName: "", spriteFormat: "png" }, [s5, o7] = "string" == typeof e6 ? [e6, null] : [null, e6.jsonUrl];
  await S2(t3, "esri", e6, o7, r6);
  const l5 = { layerDefinition: t3.validatedSource, url: s5, serviceUrl: t3.sourceUrl, style: t3.style, styleUrl: t3.styleUrl, spriteUrl: t3.style.sprite && h3(t3.styleBase, t3.style.sprite), spriteFormat: t3.spriteFormat, glyphsUrl: t3.style.glyphs && h3(t3.styleBase, t3.style.glyphs), sourceNameToSource: t3.sourceNameToSource, primarySourceName: t3.primarySourceName };
  return d2(l5.spriteUrl), d2(l5.glyphsUrl), l5;
}
function d2(e6) {
  if (!e6)
    return;
  const r6 = H(e6);
  y && !y.includes(r6) && y.push(r6);
}
function h3(...e6) {
  let r6;
  for (let t3 = 0; t3 < e6.length; ++t3)
    if (ft(e6[t3])) {
      if (r6) {
        const s5 = r6.split("://")[0];
        r6 = s5 + ":" + e6[t3].trim();
      }
    } else
      r6 = K(e6[t3]) ? e6[t3] : G(r6, e6[t3]);
  return Ct(r6);
}
async function S2(e6, s5, o7, l5, n4) {
  let i2, c2, a3;
  if (f(n4), "string" == typeof o7) {
    const e7 = F(o7);
    d2(e7), a3 = await U(e7, { ...n4, responseType: "json", query: { f: "json", ...n4 == null ? void 0 : n4.query } }), a3.ssl && (i2 && (i2 = i2.replace(/^http:/i, "https:")), c2 && (c2 = c2.replace(/^http:/i, "https:"))), i2 = e7, c2 = e7;
  } else
    a3 = { data: o7 }, i2 = o7.jsonUrl || null, c2 = l5;
  const f2 = a3.data;
  if (U3(f2))
    return e6.styleUrl = i2 || null, x(e6, f2, c2, n4);
  if (w2(f2))
    return e6.sourceUrl ? g2(e6, f2, c2, false, s5, n4) : (e6.sourceUrl = i2 || null, g2(e6, f2, c2, true, s5, n4));
  throw new Error("You must specify the URL or the JSON for a service or for a style.");
}
function U3(e6) {
  return !!e6.sources;
}
function w2(e6) {
  return !U3(e6);
}
async function x(e6, r6, t3, s5) {
  const o7 = t3 ? Ot(t3) : C();
  e6.styleBase = o7, e6.style = r6, e6.styleUrl && d2(e6.styleUrl), r6["sprite-format"] && "webp" === r6["sprite-format"].toLowerCase() && (e6.spriteFormat = "webp");
  const l5 = [];
  if (r6.sources && r6.sources.esri) {
    const t4 = r6.sources.esri;
    t4.url ? await S2(e6, "esri", h3(o7, t4.url), void 0, s5) : l5.push(S2(e6, "esri", t4, o7, s5));
  }
  for (const n4 of Object.keys(r6.sources))
    "esri" !== n4 && "vector" === r6.sources[n4].type && (r6.sources[n4].url ? l5.push(S2(e6, n4, h3(o7, r6.sources[n4].url), void 0, s5)) : r6.sources[n4].tiles && l5.push(S2(e6, n4, r6.sources[n4], o7, s5)));
  await Promise.all(l5);
}
async function g2(e6, r6, t3, o7, l5, n4) {
  const i2 = t3 ? Ct(t3) + "/" : C(), u = v2(r6, i2), c2 = new h2(l5, Bt(i2, n4 == null ? void 0 : n4.query), u);
  if (!o7 && e6.primarySourceName in e6.sourceNameToSource) {
    const r7 = e6.sourceNameToSource[e6.primarySourceName];
    if (!r7.isCompatibleWith(c2))
      return;
    null != c2.fullExtent && (null != r7.fullExtent ? r7.fullExtent.union(c2.fullExtent) : r7.fullExtent = c2.fullExtent.clone()), r7.tileInfo.lods.length < c2.tileInfo.lods.length && (r7.tileInfo = c2.tileInfo);
  }
  if (o7 ? (e6.sourceBase = i2, e6.source = r6, e6.validatedSource = u, e6.primarySourceName = l5, e6.sourceUrl && d2(e6.sourceUrl)) : d2(i2), e6.sourceNameToSource[l5] = c2, !e6.style) {
    if (null == r6.defaultStyles)
      throw new Error();
    return "string" == typeof r6.defaultStyles ? S2(e6, "", h3(i2, r6.defaultStyles, "root.json"), void 0, n4) : S2(e6, "", r6.defaultStyles, h3(i2, "root.json"), n4);
  }
}
function v2(e6, r6) {
  if (e6.hasOwnProperty("tileInfo"))
    return e6;
  const t3 = { xmin: -20037507067161843e-9, ymin: -20037507067161843e-9, xmax: 20037507067161843e-9, ymax: 20037507067161843e-9, spatialReference: { wkid: 102100 } }, s5 = 512;
  let o7 = 78271.51696400007, l5 = 2958287637957775e-7;
  const n4 = [], i2 = e6.hasOwnProperty("minzoom") ? +e6.minzoom : 0, u = e6.hasOwnProperty("maxzoom") ? +e6.maxzoom : 22;
  for (let c2 = 0; c2 <= u; c2++)
    c2 >= i2 && n4.push({ level: c2, scale: l5, resolution: o7 }), o7 /= 2, l5 /= 2;
  for (const c2 of e6.tiles)
    d2(h3(r6, c2));
  return { capabilities: "TilesOnly", initialExtent: t3, fullExtent: t3, minScale: 0, maxScale: 0, tiles: e6.tiles, tileInfo: { rows: s5, cols: s5, dpi: 96, format: "pbf", origin: { x: -20037508342787e-6, y: 20037508342787e-6 }, lods: n4, spatialReference: { wkid: 102100 } } };
}

// node_modules/@arcgis/core/portal/support/urlUtils.js
var a2 = /^https:\/\/([a-z\d-]+)(\.maps([^.]*))?\.arcgis\.com/i;
var e5 = { devext: { customBaseUrl: "mapsdevext.arcgis.com", portalHostname: "devext.arcgis.com" }, qaext: { customBaseUrl: "mapsqa.arcgis.com", portalHostname: "qaext.arcgis.com" }, www: { customBaseUrl: "maps.arcgis.com", portalHostname: "www.arcgis.com" } };
function t2(t3) {
  const s5 = t3 == null ? void 0 : t3.match(a2);
  if (!s5)
    return null;
  const [, o7, r6, l5] = s5;
  if (!o7)
    return null;
  let c2 = null, m3 = null, n4 = null;
  const { devext: u, qaext: i2, www: p2 } = e5;
  if (r6)
    if (c2 = o7, l5)
      switch (l5.toLowerCase()) {
        case "devext":
          ({ customBaseUrl: m3, portalHostname: n4 } = u);
          break;
        case "qa":
          ({ customBaseUrl: m3, portalHostname: n4 } = i2);
          break;
        default:
          return null;
      }
    else
      ({ customBaseUrl: m3, portalHostname: n4 } = p2);
  else
    switch (o7.toLowerCase()) {
      case "devext":
        ({ customBaseUrl: m3, portalHostname: n4 } = u);
        break;
      case "qaext":
        ({ customBaseUrl: m3, portalHostname: n4 } = i2);
        break;
      case "www":
        ({ customBaseUrl: m3, portalHostname: n4 } = p2);
        break;
      default:
        return null;
    }
  return { customBaseUrl: m3, isPortal: false, portalHostname: n4, urlKey: c2 };
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/tileInfoUtils.js
var l4 = 1e-6;
function s4(e6, s5) {
  if (e6 === s5)
    return true;
  if (!e6 && null != s5)
    return false;
  if (null != e6 && !s5)
    return false;
  if (!e6.spatialReference.equals(s5.spatialReference) || e6.dpi !== s5.dpi)
    return false;
  const o7 = e6.origin, r6 = s5.origin;
  if (Math.abs(o7.x - r6.x) >= l4 || Math.abs(o7.y - r6.y) >= l4)
    return false;
  let n4, t3;
  e6.lods[0].scale > s5.lods[0].scale ? (n4 = e6, t3 = s5) : (t3 = e6, n4 = s5);
  for (let i2 = n4.lods[0].scale; i2 >= t3.lods[t3.lods.length - 1].scale - l4; i2 /= 2)
    if (Math.abs(i2 - t3.lods[0].scale) < l4)
      return true;
  return false;
}
function o6(l5, s5) {
  if (l5 === s5)
    return l5;
  if (!l5 && null != s5)
    return s5;
  if (null != l5 && !s5)
    return l5;
  const o7 = l5.size[0], r6 = l5.format, n4 = l5.dpi, t3 = { x: l5.origin.x, y: l5.origin.y }, i2 = l5.spatialReference.toJSON(), a3 = l5.lods[0].scale > s5.lods[0].scale ? l5.lods[0] : s5.lods[0], d3 = l5.lods[l5.lods.length - 1].scale <= s5.lods[s5.lods.length - 1].scale ? l5.lods[l5.lods.length - 1] : s5.lods[s5.lods.length - 1], f2 = a3.scale, u = a3.resolution, c2 = d3.scale, p2 = [];
  let g3 = f2, h4 = u, x2 = 0;
  for (; g3 > c2; )
    p2.push({ level: x2, resolution: h4, scale: g3 }), x2++, g3 /= 2, h4 /= 2;
  return new S({ size: [o7, o7], dpi: n4, format: r6 || "pbf", origin: t3, lods: p2, spatialReference: i2 });
}

// node_modules/@arcgis/core/layers/VectorTileLayer.js
var B = class extends a(t(s3(p(c(v(o2(i(O2(b))))))))) {
  constructor(...e6) {
    super(...e6), this._spriteSourceMap = /* @__PURE__ */ new Map(), this.currentStyleInfo = null, this.style = null, this.isReference = null, this.operationalLayerType = "VectorTileLayer", this.type = "vector-tile", this.url = null, this.symbolCollisionBoxesVisible = false, this.path = null;
  }
  normalizeCtorArgs(e6, t3) {
    return "string" == typeof e6 ? { url: e6, ...t3 } : e6;
  }
  destroy() {
    if (this.sourceNameToSource)
      for (const e6 of Object.values(this.sourceNameToSource))
        e6 == null ? void 0 : e6.destroy();
    this._spriteSourceMap.clear();
  }
  async prefetchResources(e6) {
    await this.loadSpriteSource(globalThis.devicePixelRatio || 1, e6);
  }
  load(e6) {
    const r6 = this.loadFromPortal({ supportedTypes: ["Vector Tile Service"], supportsData: false }, e6).catch(w).then(async () => {
      if (!this.portalItem || !this.portalItem.id)
        return;
      const r7 = `${this.portalItem.itemUrl}/resources/styles/root.json`;
      (await U(r7, { ...e6, query: { f: "json", ...this.customParameters, token: this.apiKey } })).data && this.read({ url: r7 }, e4(this.portalItem));
    }).catch(w).then(() => this._loadStyle(e6));
    return this.addResolvingPromise(r6), Promise.resolve(this);
  }
  get attributionDataUrl() {
    const e6 = this.currentStyleInfo, t3 = e6 && e6.serviceUrl && j(e6.serviceUrl);
    if (!t3)
      return null;
    const r6 = this._getDefaultAttribution(t3.path);
    return r6 ? Bt(r6, { ...this.customParameters, token: this.apiKey }) : null;
  }
  get capabilities() {
    const e6 = this.primarySource;
    return e6 ? e6.capabilities : { operations: { supportsExportTiles: false, supportsTileMap: false }, exportTiles: null };
  }
  get fullExtent() {
    var _a;
    return ((_a = this.primarySource) == null ? void 0 : _a.fullExtent) || null;
  }
  get parsedUrl() {
    return this.serviceUrl ? j(this.serviceUrl) : null;
  }
  get serviceUrl() {
    return this.currentStyleInfo && this.currentStyleInfo.serviceUrl || null;
  }
  get spatialReference() {
    return this.tileInfo && this.tileInfo.spatialReference || null;
  }
  get styleUrl() {
    return this.currentStyleInfo && this.currentStyleInfo.styleUrl || null;
  }
  writeStyleUrl(e6, t3) {
    e6 && ft(e6) && (e6 = `https:${e6}`);
    const r6 = e2(t2(e6));
    t3.styleUrl = U2(e6, r6);
  }
  get tileInfo() {
    var _a;
    const e6 = [];
    for (const r6 in this.sourceNameToSource)
      e6.push(this.sourceNameToSource[r6]);
    let t3 = ((_a = this.primarySource) == null ? void 0 : _a.tileInfo) || new S();
    if (e6.length > 1)
      for (let r6 = 0; r6 < e6.length; r6++)
        s4(t3, e6[r6].tileInfo) && (t3 = o6(t3, e6[r6].tileInfo));
    return t3;
  }
  readVersion(e6, t3) {
    return t3.version ? parseFloat(t3.version) : parseFloat(t3.currentVersion);
  }
  async loadSpriteSource(e6 = 1, t3) {
    var _a;
    if (!this._spriteSourceMap.has(e6)) {
      const r6 = l2("2d").maxTextureSize, o7 = ((_a = this.currentStyleInfo) == null ? void 0 : _a.spriteUrl) ? Bt(this.currentStyleInfo.spriteUrl, { ...this.customParameters, token: this.apiKey }) : null, s5 = new o4(o7, e6, r6, this.currentStyleInfo.spriteFormat);
      await s5.load(t3), this._spriteSourceMap.set(e6, s5);
    }
    return this._spriteSourceMap.get(e6);
  }
  async setSpriteSource(e6, t3 = "png", r6 = 1, o7) {
    const s5 = l2("2d").maxTextureSize, i2 = e6 ? Bt(e6, { ...this.customParameters, token: this.apiKey }) : null;
    if (!i2)
      return null;
    const a3 = new o4(i2, r6, s5, t3);
    try {
      return await a3.load(o7), this._spriteSourceMap.clear(), this._spriteSourceMap.set(r6, a3), this.currentStyleInfo.spriteUrl = i2, this.emit("spriteSource-change", { spriteSource: a3 }), a3;
    } catch (n4) {
      w(n4);
    }
    return null;
  }
  async loadStyle(e6, t3) {
    var _a;
    const r6 = e6 || this.style || this.url;
    return this._loadingTask && "string" == typeof r6 && this.url === r6 || ((_a = this._loadingTask) == null ? void 0 : _a.abort(), this._loadingTask = O((e7) => (this._spriteSourceMap.clear(), this._getSourceAndStyle(r6, { signal: e7 })), t3)), this._loadingTask.promise;
  }
  getStyleLayerId(e6) {
    return this.styleRepository.getStyleLayerId(e6);
  }
  getStyleLayerIndex(e6) {
    return this.styleRepository.getStyleLayerIndex(e6);
  }
  getPaintProperties(e6) {
    return m(this.styleRepository.getPaintProperties(e6));
  }
  setPaintProperties(e6, t3) {
    const r6 = this.styleRepository.isPainterDataDriven(e6);
    this.styleRepository.setPaintProperties(e6, t3);
    const o7 = this.styleRepository.isPainterDataDriven(e6);
    this.emit("paint-change", { layer: e6, paint: t3, isDataDriven: r6 || o7 });
  }
  getStyleLayer(e6) {
    return m(this.styleRepository.getStyleLayer(e6));
  }
  setStyleLayer(e6, t3) {
    this.styleRepository.setStyleLayer(e6, t3), this.emit("style-layer-change", { layer: e6, index: t3 });
  }
  deleteStyleLayer(e6) {
    this.styleRepository.deleteStyleLayer(e6), this.emit("delete-style-layer", { layer: e6 });
  }
  getLayoutProperties(e6) {
    return m(this.styleRepository.getLayoutProperties(e6));
  }
  setLayoutProperties(e6, t3) {
    this.styleRepository.setLayoutProperties(e6, t3), this.emit("layout-change", { layer: e6, layout: t3 });
  }
  setStyleLayerVisibility(e6, t3) {
    this.styleRepository.setStyleLayerVisibility(e6, t3), this.emit("style-layer-visibility-change", { layer: e6, visibility: t3 });
  }
  getStyleLayerVisibility(e6) {
    return this.styleRepository.getStyleLayerVisibility(e6);
  }
  write(e6, t3) {
    return (t3 == null ? void 0 : t3.origin) && !this.styleUrl ? (t3.messages && t3.messages.push(new s2("vectortilelayer:unsupported", `VectorTileLayer (${this.title}, ${this.id}) with style defined by JSON only are not supported`, { layer: this })), null) : super.write(e6, t3);
  }
  getTileUrl(e6, t3, r6) {
    return null;
  }
  async _getSourceAndStyle(e6, t3) {
    if (!e6)
      throw new Error("invalid style!");
    const r6 = await m2(e6, { ...t3, query: { ...this.customParameters, token: this.apiKey } });
    if ("webp" === r6.spriteFormat) {
      await o3("lossy") || (r6.spriteFormat = "png");
    }
    this._set("currentStyleInfo", { ...r6 }), "string" == typeof e6 ? (this.url = e6, this.style = null) : (this.url = null, this.style = e6), this._set("sourceNameToSource", r6.sourceNameToSource), this._set("primarySource", r6.sourceNameToSource[r6.primarySourceName]), this._set("styleRepository", new l(r6.style)), this.read(r6.layerDefinition, { origin: "service" }), this.emit("load-style");
  }
  _getDefaultAttribution(e6) {
    const t3 = e6.match(/^https?:\/\/(?:basemaps|basemapsbeta|basemapsdev)(?:-api)?\.arcgis\.com(\/[^\/]+)?\/arcgis\/rest\/services\/([^\/]+(\/[^\/]+)*)\/vectortileserver/i), r6 = ["OpenStreetMap_v2", "OpenStreetMap_Daylight_v2", "OpenStreetMap_Export_v2", "OpenStreetMap_FTS_v2", "OpenStreetMap_GCS_v2", "World_Basemap", "World_Basemap_v2", "World_Basemap_Export_v2", "World_Basemap_GCS_v2", "World_Basemap_WGS84", "World_Contours_v2"];
    if (!t3)
      return;
    const o7 = t3[2] && t3[2].toLowerCase();
    if (!o7)
      return;
    const s5 = t3[1] || "";
    for (const i2 of r6)
      if (i2.toLowerCase().includes(o7))
        return F(`//static.arcgis.com/attribution/Vector${s5}/${i2}`);
  }
  async _loadStyle(e6) {
    var _a;
    return ((_a = this._loadingTask) == null ? void 0 : _a.promise) ?? this.loadStyle(null, e6);
  }
};
e([d({ readOnly: true })], B.prototype, "attributionDataUrl", null), e([d({ type: ["show", "hide"] })], B.prototype, "listMode", void 0), e([d({ json: { read: true, write: true } })], B.prototype, "blendMode", void 0), e([d({ readOnly: true, json: { read: false } })], B.prototype, "capabilities", null), e([d({ readOnly: true })], B.prototype, "currentStyleInfo", void 0), e([d({ json: { read: false }, readOnly: true, type: M })], B.prototype, "fullExtent", null), e([d()], B.prototype, "style", void 0), e([d({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], B.prototype, "isReference", void 0), e([d({ type: ["VectorTileLayer"] })], B.prototype, "operationalLayerType", void 0), e([d({ readOnly: true })], B.prototype, "parsedUrl", null), e([d({ readOnly: true })], B.prototype, "serviceUrl", null), e([d({ type: k, readOnly: true })], B.prototype, "spatialReference", null), e([d({ readOnly: true })], B.prototype, "styleRepository", void 0), e([d({ readOnly: true })], B.prototype, "sourceNameToSource", void 0), e([d({ readOnly: true })], B.prototype, "primarySource", void 0), e([d({ type: String, readOnly: true, json: { write: { ignoreOrigin: true }, origins: { "web-document": { write: { ignoreOrigin: true, isRequired: true } } } } })], B.prototype, "styleUrl", null), e([r2(["portal-item", "web-document"], "styleUrl")], B.prototype, "writeStyleUrl", null), e([d({ json: { read: false, origins: { service: { read: false } } }, readOnly: true, type: S })], B.prototype, "tileInfo", null), e([d({ json: { read: false }, readOnly: true, value: "vector-tile" })], B.prototype, "type", void 0), e([d({ json: { origins: { "web-document": { read: { source: "styleUrl" } }, "portal-item": { read: { source: "url" } } }, write: false, read: false } })], B.prototype, "url", void 0), e([d({ readOnly: true })], B.prototype, "version", void 0), e([o("version", ["version", "currentVersion"])], B.prototype, "readVersion", null), e([d({ type: Boolean })], B.prototype, "symbolCollisionBoxesVisible", void 0), e([d({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], B.prototype, "path", void 0), B = e([n("esri.layers.VectorTileLayer")], B);
var E = B;
export {
  E as default
};
//# sourceMappingURL=VectorTileLayer-EYHGNGUD.js.map
