import {
  o as o3
} from "./chunk-UV5UBITC.js";
import {
  o as o2
} from "./chunk-K37I5IIG.js";
import {
  r as r2
} from "./chunk-HRAEK6P4.js";
import {
  e as e4,
  t as t2
} from "./chunk-SV4VP57N.js";
import {
  o
} from "./chunk-XEIRRA3E.js";
import {
  r
} from "./chunk-FCDEMPPS.js";
import {
  c
} from "./chunk-DMGVDNFD.js";
import {
  e as e3
} from "./chunk-46N7XS5M.js";
import {
  e as e2
} from "./chunk-4MKQUQD4.js";
import {
  i2 as i
} from "./chunk-I5UNY2WQ.js";
import {
  n,
  t
} from "./chunk-NAB3NF54.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  e
} from "./chunk-IVBXK6OP.js";

// node_modules/@arcgis/core/views/3d/environment/SimpleAtmosphereTechniqueConfiguration.js
var n2;
!function(e5) {
  e5[e5.Cone = 0] = "Cone", e5[e5.Cylinder = 1] = "Cylinder", e5[e5.Underground = 2] = "Underground", e5[e5.COUNT = 3] = "COUNT";
}(n2 || (n2 = {}));
var t3 = class extends t2 {
  constructor() {
    super(...arguments), this.geometry = n2.Cone;
  }
};
e([e4({ count: n2.COUNT })], t3.prototype, "geometry", void 0);

// node_modules/@arcgis/core/chunks/SimpleAtmosphere.glsl.js
var f = class extends t {
};
function p(s) {
  const f2 = new i(), { vertex: p2, fragment: v2 } = f2;
  if (s.geometry === n2.Underground)
    f2.attributes.add(O.POSITION, "vec2"), f2.varyings.add("color", "vec4"), p2.uniforms.add([new e2("lightingMainDirection", (e5, o4) => o4.lighting.lightingMainDirection), new o3("cameraPosition"), new r2("undergroundFadeAlpha")]), p2.code.add(n`void main(void) {
float ndotl = dot(normalize(cameraPosition), lightingMainDirection);
float lighting = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));
color = vec4(vec3(lighting), undergroundFadeAlpha);
gl_Position = vec4(position.xy, 1.0, 1.0);
}`), v2.code.add(n`void main() {
gl_FragColor = color;
}`);
  else {
    f2.include(r), f2.attributes.add(O.POSITION, "vec3"), f2.varyings.add("vtc", "vec2"), f2.varyings.add("falloff", "float");
    const c2 = s.geometry === n2.Cylinder;
    p2.uniforms.add([new e3("proj", (e5, o4) => o4.camera.projectionMatrix), new o("view"), new e2("lightingMainDirection", (e5, o4) => o4.lighting.lightingMainDirection)]), c2 || (f2.varyings.add("innerFactor", "float"), p2.uniforms.add(new o3("silCircleCenter")), p2.uniforms.add(new o3("silCircleV1")), p2.uniforms.add(new o3("silCircleV2")), p2.uniforms.add(new o2("texV")), p2.uniforms.add(new r2("innerScale")));
    const u = 6.2831853, w = 1 / 128;
    p2.code.add(n`
		void main(void) {
      ${c2 ? n`
      vec3 pos = position;
      float ndotl = lightingMainDirection.z;
      vtc = vec2(0.0, position.z + 0.05);` : n`
      innerFactor = clamp(-position.z, 0.0, 1.0);
      float scale = position.y * (1.0 + innerFactor * innerScale);
      float phi = position.x * ${n.float(u * w)} + 1.0;
      vec3 pos =  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;
      float ndotl = dot(normalize(position.y > 0.0 ? pos: silCircleCenter), lightingMainDirection);
      vtc.x = position.x  * ${n.float(w)};
      vtc.y = texV.x * (1.0 - position.z) + texV.y * position.z;
      `}
      falloff = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));

		  gl_Position = transformPosition(proj, view, pos);
		  gl_Position.z = gl_Position.w; // project atmosphere onto the far plane
    }
	  `), v2.uniforms.add(new c("tex", (e5) => e5.texture)), c2 || v2.uniforms.add(new r2("altitudeFade")), v2.code.add(n`
		void main() {
			vec4 atmosphereColor = texture2D(tex, vtc) * falloff;
      ${c2 ? n`gl_FragColor = atmosphereColor;` : n`
			vec4 innerColor = vec4(atmosphereColor.rgb, 1.0 - altitudeFade);
			gl_FragColor = mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));
      `}
    }`);
  }
  return f2;
}
var v = Object.freeze(Object.defineProperty({ __proto__: null, SimpleAtmospherePassParameters: f, build: p }, Symbol.toStringTag, { value: "Module" }));

export {
  n2 as n,
  t3 as t,
  f,
  p,
  v
};
//# sourceMappingURL=chunk-Z34XFHPX.js.map
