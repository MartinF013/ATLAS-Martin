import {
  h as h2,
  t as t4
} from "./chunk-D3I6HXMB.js";
import {
  R as R2,
  d as d4,
  r as r3
} from "./chunk-SNC4BDIX.js";
import "./chunk-3CED37X7.js";
import "./chunk-FMIFCFD7.js";
import {
  n as n3,
  s as s6
} from "./chunk-WL7AHHN3.js";
import "./chunk-UGLXR5OV.js";
import "./chunk-RGZ7VIMW.js";
import "./chunk-6FQZDXGD.js";
import {
  c as c4,
  l as l3,
  r as r2
} from "./chunk-4JEAJE3K.js";
import {
  A
} from "./chunk-ZUKXZSOF.js";
import {
  s as s7
} from "./chunk-5QPLPQX7.js";
import {
  v as v2
} from "./chunk-JOD7ILR7.js";
import {
  o as o3
} from "./chunk-HH3D3A65.js";
import "./chunk-WFUZXUS4.js";
import "./chunk-NCMBCUFA.js";
import {
  Y
} from "./chunk-COK4R22F.js";
import "./chunk-T6XN76GI.js";
import "./chunk-EZ4QR7V3.js";
import "./chunk-EMETVH63.js";
import "./chunk-V56SVRSV.js";
import {
  f as f4,
  g as g3
} from "./chunk-XZHFGTRH.js";
import "./chunk-2I27THZD.js";
import "./chunk-X64NQ2GK.js";
import "./chunk-NVOCHKIH.js";
import "./chunk-DGELARKE.js";
import "./chunk-WN3KE5M2.js";
import "./chunk-YDPQRKY4.js";
import {
  l as l4
} from "./chunk-ADLZUJXZ.js";
import {
  h
} from "./chunk-TH2ECCFL.js";
import "./chunk-TCBD6DES.js";
import {
  i
} from "./chunk-ZIAGZEFK.js";
import "./chunk-FR7M4UDR.js";
import "./chunk-KBCUY3VB.js";
import {
  l as l2
} from "./chunk-G2GJVIQC.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-33INAWJA.js";
import "./chunk-FPMD6IB4.js";
import {
  s as s5
} from "./chunk-Z7BSDVJ3.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-PQO66WZ2.js";
import "./chunk-CC32E45Q.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import {
  c as c3,
  f as f5
} from "./chunk-TB42IUV7.js";
import {
  c as c2,
  q
} from "./chunk-ZWMYDR2G.js";
import {
  a as a2
} from "./chunk-ZZY5IDKU.js";
import {
  D as D2,
  M as M2,
  Q,
  b as b2,
  ce,
  ie,
  me,
  ne,
  ue
} from "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import {
  o as o2,
  s as s4,
  t as t3
} from "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-PZWU5EHT.js";
import {
  c as c5
} from "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import {
  S
} from "./chunk-HR2OX32D.js";
import {
  g as g4
} from "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import {
  d as d2
} from "./chunk-FU5UMT3R.js";
import {
  b as b3
} from "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import {
  a as a3,
  m,
  y as y2
} from "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  y
} from "./chunk-TBT57L4K.js";
import "./chunk-GRILTTJT.js";
import {
  d as d3
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  f as f3,
  j as j2,
  l
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-TT2HIXWQ.js";
import {
  n as n2
} from "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  E as E3,
  R,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  s as s3
} from "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  C,
  D,
  E as E2,
  L,
  b,
  f as f2,
  g as g2,
  j
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  E,
  a,
  c,
  e as e2,
  f,
  g,
  o,
  r,
  t,
  t2
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/2d/layers/features/processors.js
function o4(o8) {
  return "heatmap" === o8 ? import("./HeatmapProcessor-U3HNMCTB.js") : import("./SymbolProcessor-L5OVBW5E.js");
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var r4 = 268435455;
var n4 = class {
  constructor() {
    this.fieldMap = /* @__PURE__ */ new Map(), this.fields = [], this.hasFeatures = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
  hasField(e3) {
    return this.fieldMap.has(e3);
  }
  isDateField(e3) {
    var _a;
    return (_a = this.fieldMap.get(e3)) == null ? void 0 : _a.isDate;
  }
  getFieldIndex(e3) {
    var _a;
    return (_a = this.fieldMap.get(e3)) == null ? void 0 : _a.index;
  }
};
function a4(e3) {
  const t6 = 1, r5 = 2, n6 = e3.getLength(), a7 = e3.pos() + n6, i4 = { name: "", isDate: false };
  for (; e3.pos() < a7 && e3.next(); )
    switch (e3.tag()) {
      case t6:
        i4.name = e3.getString();
        break;
      case r5:
        "esriFieldTypeDate" === c2(e3.getEnum()) && (i4.isDate = true);
        break;
      default:
        e3.skip();
    }
  return i4;
}
function i2(e3) {
  return e3.toLowerCase().trim();
}
function o5(s8, o8, c11 = false) {
  const f10 = 1, d9 = 3, u4 = 9, l9 = 12, g8 = 13, p3 = 15, h6 = s8.pos(), m5 = new n4();
  let b5 = 0, w4 = 0;
  const k3 = 1, x5 = 2, y8 = 4, I2 = 3;
  let F3 = null, L4 = null, A4 = null, C2 = false;
  for (; s8.next(); )
    switch (s8.tag()) {
      case f10:
        F3 = s8.getString();
        break;
      case d9:
        L4 = s8.getString();
        break;
      case l9:
        A4 = s8.processMessage(q);
        break;
      case u4:
        if (m5.exceededTransferLimit = s8.getBool(), m5.exceededTransferLimit) {
          m5.offsets.geometry = c11 ? new Float64Array(8e3) : new Int32Array(8e3), m5.centroid = c11 ? new Float64Array(16e3) : new Int32Array(16e3);
          for (let e3 = 0; e3 < m5.centroid.length; e3++)
            m5.centroid[e3] = r4;
        }
        break;
      case g8: {
        const e3 = a4(s8), t6 = e3.name, r5 = i2(e3.name), n6 = { fieldName: t6, index: b5++, isDate: e3.isDate };
        m5.fields.push(n6), m5.fieldMap.set(e3.name, n6), m5.fieldMap.set(r5, n6);
        break;
      }
      case p3: {
        const e3 = s8.getLength(), t6 = s8.pos() + e3;
        if (!m5.exceededTransferLimit) {
          const e4 = m5.offsets.geometry, t7 = m5.centroid;
          e4.push(0), t7.push(r4), t7.push(r4);
        }
        !C2 && m5.exceededTransferLimit && (C2 = true, m5.offsets.attributes = c11 ? new Float64Array(8e3 * b5) : new Uint32Array(8e3 * b5));
        let n6 = w4 * b5;
        for (; s8.pos() < t6 && s8.next(); )
          switch (s8.tag()) {
            case k3: {
              if (C2)
                m5.offsets.attributes[n6++] = s8.pos();
              else {
                m5.offsets.attributes.push(s8.pos());
              }
              const e4 = s8.getLength();
              s8.skipLen(e4);
              break;
            }
            case x5:
              if (o8) {
                const e4 = s8.getLength(), t7 = s8.pos() + e4;
                for (; s8.pos() < t7 && s8.next(); )
                  switch (s8.tag()) {
                    case I2: {
                      s8.getUInt32();
                      const e5 = s8.getSInt64(), t8 = s8.getSInt64();
                      m5.centroid[2 * w4] = e5, m5.centroid[2 * w4 + 1] = t8;
                      break;
                    }
                    default:
                      s8.skip();
                  }
              } else {
                m5.offsets.geometry[w4] = s8.pos();
                const e4 = s8.getLength();
                m5.vertexCount += e4, s8.skipLen(e4);
              }
              break;
            case y8: {
              const e4 = s8.getLength(), t7 = s8.pos() + e4;
              for (; s8.pos() < t7 && s8.next(); )
                switch (s8.tag()) {
                  case I2: {
                    s8.getUInt32();
                    const e5 = s8.getSInt64(), t8 = s8.getSInt64();
                    m5.centroid[2 * w4] = e5, m5.centroid[2 * w4 + 1] = t8;
                    break;
                  }
                  default:
                    s8.skip();
                }
              break;
            }
            default:
              s8.skip();
          }
        w4++, m5.hasFeatures = true;
        break;
      }
      default:
        s8.skip();
    }
  const S4 = F3 || L4;
  if (!S4)
    throw new s2("FeatureSet has no objectId or globalId field name");
  return m5.featureCount = w4, m5.fieldCount = b5, m5.objectIdFieldIndex = m5.getFieldIndex(S4), m5.transform = A4, m5.displayIds = new Uint32Array(m5.featureCount), m5.groupIds = new Uint16Array(m5.featureCount), s8.move(h6), m5;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var c6 = s.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF");
var g5 = true;
var l5 = 268435455;
var _ = 128;
var f6 = 128e3;
var y3 = { small: { delta: new Int32Array(_), decoded: new Int32Array(_) }, large: { delta: new Int32Array(f6), decoded: new Int32Array(f6) } };
function I(e3) {
  return e3 <= y3.small.delta.length ? y3.small : (e3 <= y3.large.delta.length || (y3.large.delta = new Int32Array(Math.round(1.25 * e3)), y3.large.decoded = new Int32Array(Math.round(1.25 * e3))), y3.large);
}
function p(e3) {
  return e3.toLowerCase().trim();
}
function m2(t6) {
  try {
    const e3 = 2, r5 = new a2(new Uint8Array(t6), new DataView(t6));
    for (; r5.next(); ) {
      if (r5.tag() === e3)
        return x(r5.getMessage());
      r5.skip();
    }
  } catch (r5) {
    const t7 = new s2("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: r5 });
    c6.error(t7);
  }
  return null;
}
function x(e3) {
  const t6 = 1;
  for (; e3.next(); ) {
    if (e3.tag() === t6)
      return e3.getMessage();
    e3.skip();
  }
  return null;
}
function S2(e3) {
  const t6 = 1, r5 = 2, s8 = 3, i4 = 4, n6 = 5, a7 = 6, h6 = 7, o8 = 8, d9 = 9, u4 = e3.getLength(), c11 = e3.pos() + u4;
  for (; e3.pos() < c11 && e3.next(); )
    switch (e3.tag()) {
      case t6:
        return e3.getString();
      case r5:
        return e3.getFloat();
      case s8:
        return e3.getDouble();
      case i4:
        return e3.getSInt32();
      case n6:
        return e3.getUInt32();
      case a7:
        return e3.getInt64();
      case h6:
        return e3.getUInt64();
      case o8:
        return e3.getSInt64();
      case d9:
        return e3.getBool();
      default:
        return e3.skip(), null;
    }
  return null;
}
function F(e3, t6, r5, s8, i4, n6) {
  return 0.5 * Math.abs(e3 * s8 + r5 * n6 + i4 * t6 - e3 * n6 - r5 * t6 - i4 * s8);
}
function G(e3, t6, r5, s8) {
  return 0 === e3 * s8 - r5 * t6 && e3 * r5 + t6 * s8 > 0;
}
var w = class extends A {
  constructor(e3, t6, r5, s8) {
    super(e3, s8), this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0, centroid: void 0, legacyFeature: void 0, optFeature: void 0 }, this._geometryType = s8.geometryType, this._reader = t6, this._header = r5, this._hasNext = r5.hasFeatures, this._isPoints = "esriGeometryPoint" === s8.geometryType;
  }
  static fromBuffer(e3, t6, r5 = false) {
    const s8 = t6.geometryType, i4 = m2(e3), n6 = o5(i4, "esriGeometryPoint" === s8, r5), a7 = A.createInstance();
    return new w(a7, i4, n6, t6);
  }
  get geometryType() {
    return this._geometryType;
  }
  get size() {
    return this._header.featureCount;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get stride() {
    return 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  hasField(e3) {
    return this._header.hasField(e3) || this._header.hasField(p(e3));
  }
  getFieldNames() {
    return this._header.fields.map((e3) => e3.fieldName);
  }
  getSize() {
    return this.size;
  }
  getQuantizationTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e3) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0, this._featureIndex = e3;
  }
  getAttributeHash() {
    let e3 = "";
    return this._header.fields.forEach(({ index: t6 }) => {
      e3 += this._readAttributeAtIndex(t6) + ".";
    }), e3;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e3) {
    this._header.displayIds[this._featureIndex] = e3;
  }
  getGroupId() {
    return this._header.groupIds[this._featureIndex];
  }
  setGroupId(e3) {
    this._header.groupIds[this._featureIndex] = e3;
  }
  readLegacyFeature() {
    if (void 0 === this._cache.legacyFeature) {
      const e3 = this.readCentroid(), t6 = { attributes: this.readAttributes(), geometry: this._isPoints ? this.readLegacyPointGeometry() : this.readLegacyGeometry(), centroid: (e3 && { x: e3.coords[0], y: e3.coords[1] }) ?? null };
      return this._cache.legacyFeature = t6, t6;
    }
    return this._cache.legacyFeature;
  }
  readOptimizedFeature() {
    if (void 0 === this._cache.optFeature) {
      const e3 = new s4(this.readGeometry(), this.readAttributes(), this.readCentroid());
      return e3.objectId = this.getObjectId(), e3.displayId = this.getDisplayId(), this._cache.optFeature = e3, e3;
    }
    return this._cache.optFeature;
  }
  getXHydrated() {
    const e3 = this._header.centroid[2 * this._featureIndex], t6 = this.getQuantizationTransform();
    return t(t6) ? e3 : e3 * t6.scale[0] + t6.translate[0];
  }
  getYHydrated() {
    const e3 = this._header.centroid[2 * this._featureIndex + 1], t6 = this.getQuantizationTransform();
    return t(t6) ? e3 : t6.translate[1] - e3 * t6.scale[1];
  }
  getX() {
    return this._header.centroid[2 * this._featureIndex] * this._sx + this._tx;
  }
  getY() {
    return this._header.centroid[2 * this._featureIndex + 1] * this._sy + this._ty;
  }
  readLegacyPointGeometry() {
    return { x: this.getX(), y: this.getY() };
  }
  readLegacyGeometry(e3) {
    const t6 = this.readGeometry(e3);
    return ne(t6, this.geometryType, false, false);
  }
  readLegacyCentroid() {
    const e3 = this.readCentroid();
    if (!e3)
      return null;
    const [t6, r5] = e3.coords;
    return { x: t6, y: r5 };
  }
  readGeometryArea() {
    return this._cache.area || this.readGeometry(true), this._cache.area;
  }
  readUnquantizedGeometry(e3 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t6 = this.readGeometry(e3);
      if (!t6)
        return this._cache.unquantGeometry = null, null;
      const r5 = I(t6.coords.length).decoded, s8 = t6.clone(r5), i4 = s8.coords;
      let n6 = 0;
      for (const e4 of s8.lengths) {
        for (let t7 = 1; t7 < e4; t7++) {
          const e5 = 2 * (n6 + t7), r6 = 2 * (n6 + t7 - 1);
          i4[e5] += i4[r6], i4[e5 + 1] += i4[r6 + 1];
        }
        n6 += e4;
      }
      return this._cache.unquantGeometry = s8, s8;
    }
    return this._cache.unquantGeometry;
  }
  readHydratedGeometry() {
    if (this._isPoints) {
      if (this._header.centroid[2 * this._featureIndex] === l5)
        return null;
      const e4 = this.getXHydrated(), t7 = this.getYHydrated();
      return new t3([], [e4, t7]);
    }
    const e3 = this.readGeometry();
    if (!e3)
      return null;
    const t6 = e3.clone(), r5 = this.getQuantizationTransform();
    return r(r5) && me(t6, t6, this.hasZ, this.hasM, r5), t6;
  }
  readGeometry(e3 = false) {
    if (void 0 === this._cache.geometry) {
      let r5 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === l5)
          return null;
        const e4 = this.getX(), t6 = this.getY();
        r5 = new t3([], [e4, t6]);
      } else {
        const s8 = this._header.offsets.geometry[this._featureIndex], i4 = this._reader;
        if (0 === s8)
          return null;
        i4.move(s8);
        try {
          r5 = e3 ? this._parseGeometryForDisplay(i4) : this._parseGeometry(i4);
        } catch (t6) {
          return console.error("Failed to parse geometry!", t6), null;
        }
      }
      return this._cache.geometry = r5, r5;
    }
    return this._cache.geometry;
  }
  readCentroid() {
    if (void 0 === this._cache.centroid) {
      let e3 = null;
      const t6 = this._header.centroid[2 * this._featureIndex] + this._tx, r5 = this._header.centroid[2 * this._featureIndex + 1] + this._ty;
      return t6 === l5 ? (e3 = this._computeCentroid(), e3 && (this._header.centroid[2 * this._featureIndex] = e3.coords[0] - this._tx, this._header.centroid[2 * this._featureIndex + 1] = e3.coords[1] - this._ty)) : e3 = new t3([], [t6, r5]), this._cache.centroid = e3, e3;
    }
    return this._cache.centroid;
  }
  copy() {
    const e3 = this._reader.clone(), t6 = new w(this.instance, e3, this._header, this.fullSchema());
    return this.copyInto(t6), t6;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0; ++this._featureIndex < this.size && !this._getExists(); )
      ;
    return this._featureIndex < this.size;
  }
  _readAttribute(e3, t6) {
    const r5 = this._header.hasField(e3) ? e3 : p(e3), s8 = this._header.getFieldIndex(r5);
    if (null == s8)
      return;
    const i4 = this._readAttributeAtIndex(s8);
    if (!t6)
      return i4;
    if (null == i4)
      return i4;
    return this._header.isDateField(r5) ? new Date(i4) : i4;
  }
  _readAttributes() {
    const e3 = {};
    return this._header.fields.forEach(({ fieldName: t6, index: r5 }) => {
      e3[t6] = this._readAttributeAtIndex(r5);
    }), e3;
  }
  copyInto(e3) {
    super.copyInto(e3), e3._featureIndex = this._featureIndex, e3._featureOffset = this._featureOffset, e3._hasNext = this._hasNext;
  }
  _readAttributeAtIndex(e3) {
    const t6 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e3], r5 = this._reader;
    return r5.move(t6), S2(r5);
  }
  _parseGeometry(e3) {
    const t6 = 2, r5 = 3, s8 = e3.getLength(), i4 = e3.pos() + s8, n6 = [], a7 = [];
    for (; e3.pos() < i4 && e3.next(); )
      switch (e3.tag()) {
        case t6: {
          const t7 = e3.getUInt32(), r6 = e3.pos() + t7;
          for (; e3.pos() < r6; )
            a7.push(e3.getUInt32());
          break;
        }
        case r5: {
          const t7 = e3.getUInt32(), r6 = e3.pos() + t7;
          for (n6.push(e3.getSInt32() + this._tx), n6.push(e3.getSInt32() + this._ty), this.hasZ && e3.getSInt32(), this.hasM && e3.getSInt32(); e3.pos() < r6; )
            n6.push(e3.getSInt32()), n6.push(e3.getSInt32()), this.hasZ && e3.getSInt32(), this.hasM && e3.getSInt32();
          break;
        }
        default:
          e3.skip();
      }
    return new t3(a7, n6);
  }
  _parseGeometryForDisplay(e3) {
    const t6 = 2, r5 = 3, s8 = e3.getLength(), i4 = e3.pos() + s8, n6 = [], a7 = [];
    let h6 = 0, d9 = 0, u4 = null, c11 = 0;
    const l9 = "esriGeometryPolygon" === this.geometryType;
    for (; e3.pos() < i4 && e3.next(); )
      switch (e3.tag()) {
        case t6: {
          const t7 = e3.getUInt32(), r6 = e3.pos() + t7;
          for (; e3.pos() < r6; ) {
            const t8 = e3.getUInt32();
            n6.push(t8), h6 += t8;
          }
          u4 = I(2 * h6).delta;
          break;
        }
        case r5: {
          e3.getUInt32();
          const t7 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
          for (const r6 of n6)
            if (d9 + t7 * r6 > u4.length)
              for (let t8 = 0; t8 < r6; t8++)
                e3.getSInt32(), e3.getSInt32(), this.hasZ && e3.getSInt32(), this.hasM && e3.getSInt32();
            else if (l9 && g5) {
              const t8 = this.getAreaSimplificationThreshold(r6, this._header.vertexCount);
              let s9 = 2, i5 = 1;
              const n7 = false;
              let h7 = e3.getSInt32(), o8 = e3.getSInt32();
              u4[d9++] = h7, u4[d9++] = o8, this.hasZ && e3.getSInt32(), this.hasM && e3.getSInt32();
              let g8 = e3.getSInt32(), l10 = e3.getSInt32();
              for (this.hasZ && e3.getSInt32(), this.hasM && e3.getSInt32(); s9 < r6; ) {
                let r7 = e3.getSInt32(), n8 = e3.getSInt32();
                this.hasZ && e3.getSInt32(), this.hasM && e3.getSInt32();
                const a8 = h7 + g8, _3 = o8 + l10;
                F(h7, o8, a8, _3, a8 + r7, _3 + n8) >= t8 ? (c11 += -0.5 * (a8 - h7) * (_3 + o8), i5 > 1 && G(u4[d9 - 2], u4[d9 - 1], g8, l10) ? (u4[d9 - 2] += g8, u4[d9 - 1] += l10) : (u4[d9++] = g8, u4[d9++] = l10, i5++), h7 = a8, o8 = _3) : (r7 += g8, n8 += l10), g8 = r7, l10 = n8, s9++;
              }
              i5 < 3 || n7 ? d9 -= 2 * i5 : (c11 += -0.5 * (h7 + g8 - h7) * (o8 + l10 + o8), G(u4[d9 - 2], u4[d9 - 1], g8, l10) ? (u4[d9 - 2] += g8, u4[d9 - 1] += l10, a7.push(i5)) : (u4[d9++] = g8, u4[d9++] = l10, a7.push(++i5)));
            } else {
              let t8 = 0, s9 = e3.getSInt32(), i5 = e3.getSInt32();
              this.hasZ && e3.getSInt32(), this.hasM && e3.getSInt32(), u4[d9++] = s9, u4[d9++] = i5, t8 += 1;
              for (let n7 = 1; n7 < r6; n7++) {
                const r7 = e3.getSInt32(), a8 = e3.getSInt32(), h7 = s9 + r7, o8 = i5 + a8;
                c11 += -0.5 * (h7 - s9) * (o8 + i5), this.hasZ && e3.getSInt32(), this.hasM && e3.getSInt32(), n7 > 2 && G(u4[d9 - 2], u4[d9 - 1], r7, a8) ? (u4[d9 - 2] += r7, u4[d9 - 1] += a8) : (u4[d9++] = r7, u4[d9++] = a8, t8 += 1), s9 = h7, i5 = o8;
              }
              a7.push(t8);
            }
          break;
        }
        default:
          e3.skip();
      }
    if (this._cache.area = c11, !a7.length)
      return null;
    if (this._tx || this._ty) {
      let e4 = 0;
      for (const t7 of a7)
        u4[2 * e4] += this._tx, u4[2 * e4 + 1] += this._ty, e4 += t7;
    }
    return new t3(a7, u4);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/support/sourceAdapters.js
var l6 = class {
  constructor(e3) {
    this.service = e3;
  }
  destroy() {
  }
};
function f7(e3) {
  return Array.isArray(e3.source);
}
function y4(e3) {
  return e3 && e3.capabilities && e3.collection && e3.layerDefinition;
}
function h3(t6) {
  const { capabilities: r5 } = t6;
  return y4(t6.source) ? new w2(t6) : f7(t6) ? new v3(t6) : r5.query.supportsFormatPBF && a("featurelayer-pbf") ? new F2(t6) : new q2(t6);
}
async function d5(e3) {
  const t6 = new c5();
  return await t6.open(e3, {}), t6;
}
var v3 = class extends l6 {
  constructor(e3) {
    super(e3), this._portsOpen = d5(e3.source).then((e4) => this.client = e4);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(e3, t6) {
    await this._portsOpen;
    const r5 = await this.client.invoke("queryFeatures", e3.toJSON(), t6);
    return d4.fromFeatureSet(r5, this.service);
  }
};
var F2 = class extends l6 {
  async executeQuery(e3, t6) {
    const { data: r5 } = await f5(this.service.source, e3, t6), s8 = !e3.quantizationParameters;
    return w.fromBuffer(r5, this.service, s8);
  }
};
var q2 = class extends l6 {
  async executeQuery(e3, s8) {
    var _a;
    const { source: n6, capabilities: c11, spatialReference: p3, objectIdField: l9, geometryType: f10 } = this.service;
    if (r(e3.quantizationParameters) && !c11.query.supportsQuantization) {
      const t6 = e3.clone(), c12 = s5(e2(t6.quantizationParameters));
      t6.quantizationParameters = null;
      const { data: f11 } = await c3(n6, t6, p3, s8), y9 = ce(f11, l9);
      return ue(c12, y9), d4.fromOptimizedFeatureSet(y9, this.service);
    }
    const { data: y8 } = await c3(n6, e3, this.service.spatialReference, s8);
    return "esriGeometryPoint" === f10 && (y8.features = (_a = y8.features) == null ? void 0 : _a.filter((e4) => {
      if (r(e4.geometry)) {
        const t6 = e4.geometry;
        return Number.isFinite(t6.x) && Number.isFinite(t6.y);
      }
      return true;
    })), d4.fromFeatureSet(y8, this.service);
  }
};
var w2 = class extends l6 {
  async executeQuery(e3, t6) {
    const { capabilities: s8 } = this.service;
    if (e3.quantizationParameters && !s8.query.supportsQuantization) {
      const s9 = e3.clone(), a8 = s5(e2(s9.quantizationParameters));
      s9.quantizationParameters = null;
      const c11 = await v2(this.service.source, e3, t6);
      return ue(a8, c11), d4.fromOptimizedFeatureSet(c11, this.service);
    }
    const a7 = await v2(this.service.source, e3, t6);
    return d4.fromOptimizedFeatureSet(a7, this.service);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/UpdateToken.js
var t5 = class {
  constructor() {
    this.version = 0, this.source = false, this.targets = { feature: false, aggregate: false }, this.storage = { filters: false, data: false }, this.mesh = false, this.queryFilter = false, this.why = { mesh: [], source: [] };
  }
  static create(e3) {
    const s8 = new t5();
    for (const t6 in e3) {
      const r5 = e3[t6];
      if ("object" == typeof r5)
        for (const e4 in r5) {
          const a7 = r5[e4];
          s8[t6][e4] = a7;
        }
      s8[t6] = r5;
    }
    return s8;
  }
  static empty() {
    return t5.create({});
  }
  static all() {
    return t5.create({ source: true, targets: { feature: true, aggregate: true }, storage: { filters: true, data: true }, mesh: true });
  }
  unset(t6) {
    this.version = t6.version, t6.source && (this.source = false), t6.targets.feature && (this.targets.feature = false), t6.targets.aggregate && (this.targets.aggregate = false), t6.storage.filters && (this.storage.filters = false), t6.storage.data && (this.storage.data = false), t6.mesh && (this.mesh = false), t6.queryFilter && (this.queryFilter = false);
  }
  any() {
    return this.source || this.mesh || this.storage.filters || this.storage.data || this.targets.feature || this.targets.aggregate || this.queryFilter;
  }
  describe() {
    let t6 = 0, e3 = "";
    if (this.mesh) {
      t6 += 20, e3 += "-> (20) Mesh needs update\n";
      for (const t7 of this.why.mesh)
        e3 += `    + ${t7}
`;
    }
    if (this.source) {
      t6 += 10, e3 += "-> (10) The source needs update\n";
      for (const t7 of this.why.source)
        e3 += `    + ${t7}
`;
    }
    this.targets.feature && (t6 += 5, e3 += "-> (5) Feature target parameters changed\n"), this.storage.filters && (t6 += 5, e3 += "-> (5) Feature filter parameters changed\n"), this.targets.aggregate && (t6 += 4, e3 += "-> (4) Aggregate target parameters changed\n"), this.storage.data && (t6 += 1, e3 += "-> (1) Texture storage parameters changed");
    const s8 = t6 < 5 ? "Fastest" : t6 < 10 ? "Fast" : t6 < 15 ? "Moderate" : t6 < 20 ? "Slow" : "Very Slow";
    console.debug(`Applying ${s8} update of cost ${t6}/45 `), console.debug(e3);
  }
  toJSON() {
    return { queryFilter: this.queryFilter, source: this.source, targets: this.targets, storage: this.storage, mesh: this.mesh };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSubscription.js
var o6 = class {
  constructor(s8, t6) {
    this.requests = { done: new Array(), stream: new s7(10) }, this._edits = null, this._abortController = new AbortController(), this._version = 0, this._done = false, this.didSend = false, this.tile = s8, this._version = t6;
  }
  get signal() {
    return this._abortController.signal;
  }
  get options() {
    return { signal: this._abortController.signal };
  }
  get empty() {
    return !this.requests.done.length;
  }
  get edits() {
    return this._edits;
  }
  get done() {
    return this._done;
  }
  end() {
    this._done = true;
  }
  clear() {
    this.requests.done = [];
  }
  applyUpdate(e3) {
    this.requests.done.forEach((s8) => s8.message.status.unset(e3)), this._version = e3.version, r(this._edits) && this._edits.status.unset(e3);
  }
  add(e3) {
    e3.message.status = e3.message.status ?? t5.empty(), e3.message.status.version = this._version, a("esri-2d-update-debug") && console.debug(this.tile.id, "DataTileSubscription:add", this._version), e3.message.end && this.requests.done.forEach((e4) => {
      r(e4.message) && e4.message.end && (e4.message.end = false);
    }), this.requests.done.push(e3);
  }
  edit(e3, s8) {
    const t6 = e3.getQuantizationTransform(), o8 = e3.fullSchema(), n6 = Array.from(e3.features()), h6 = [...s8, ...n6.map((e4) => e4.objectId)];
    if (this.removeIds(h6), this._invalidate(), t(this._edits))
      return void (this._edits = { type: "append", addOrUpdate: d4.fromOptimizedFeatures(n6, o8, e2(t6)), id: this.tile.id, status: t5.empty(), end: true });
    this.requests.done.forEach((e4) => e4.message.end = false);
    e2(this._edits.addOrUpdate).append(e3.features());
  }
  *readers() {
    for (const { message: e3 } of this.requests.done)
      r(e3.addOrUpdate) && (yield e3.addOrUpdate);
    r(this._edits) && r(this._edits.addOrUpdate) && (yield this._edits.addOrUpdate);
  }
  _invalidate() {
    for (const e3 of this.requests.done)
      e3.message.status = t5.empty();
    r(this._edits) && (this._edits.status = t5.empty());
  }
  removeIds(e3) {
    this._invalidate();
    for (const { message: s8 } of this.requests.done) {
      const r5 = s8.addOrUpdate;
      r(r5) && (r5.removeIds(e3), r5.isEmpty && (s8.addOrUpdate = null));
    }
    r(this._edits) && r(this._edits.addOrUpdate) && this._edits.addOrUpdate.removeIds(e3), this.requests.done = this.requests.done.filter((e4) => e4.message.addOrUpdate || e4.message.end);
  }
  abort() {
    this._abortController.abort();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSource.js
function m3(e3, s8) {
  const t6 = /* @__PURE__ */ new Set();
  return e3 && e3.forEach((e4) => t6.add(e4)), s8 && s8.forEach((e4) => t6.add(e4)), t6.has("*") ? ["*"] : Array.from(t6);
}
var f8 = class {
  constructor(e3) {
    this.events = new n2(), this._resolver = D(), this._didEdit = false, this._subscriptions = /* @__PURE__ */ new Map(), this._outSR = e3.outSR, this._serviceInfo = e3.serviceInfo, this._onTileUpdateMessage = e3.onMessage;
  }
  destroy() {
  }
  async _onMessage(e3) {
    const s8 = this._subscriptions.get(e3.id);
    if (!s8)
      return;
    const t6 = { ...e3, remove: e3.remove ?? [], status: e3.status ?? t5.empty() };
    return j(this._onTileUpdateMessage(t6, s8.options));
  }
  update(s8, r5) {
    var _a;
    const i4 = r5.fields.length;
    r5.outFields = m3((_a = this._schema) == null ? void 0 : _a.outFields, r5.outFields), r5.outFields = r5.outFields.length >= 0.75 * i4 ? ["*"] : r5.outFields, r5.outFields.sort();
    const o8 = m(this._schema, r5);
    if (!o8)
      return;
    a("esri-2d-update-debug") && console.debug("Applying Update - Source:", o8);
    const n6 = "orderByFields" in this._serviceInfo && this._serviceInfo.orderByFields ? this._serviceInfo.orderByFields : this._serviceInfo.objectIdField + " ASC", c11 = { returnCentroid: a("esri-2d-query-centroid-enabled") && "esriGeometryPolygon" === this._serviceInfo.geometryType, returnGeometry: true, timeReferenceUnknownClient: "stream" !== this._serviceInfo.type && this._serviceInfo.timeReferenceUnknownClient, outFields: r5.outFields, outSpatialReference: this._outSR, orderByFields: [n6], where: r5.definitionExpression || "1=1", gdbVersion: r5.gdbVersion, historicMoment: r5.historicMoment, timeExtent: y.fromJSON(r5.timeExtent) }, d9 = this._schema && a3(o8, "outFields");
    this._schema && y2(o8, ["timeExtent", "definitionExpression", "gdbVersion", "historicMoment", "customParameters"]) && (s8.why.mesh.push("Layer filter and/or custom parameters changed"), s8.why.source.push("Layer filter and/or custom parameters changed"), s8.mesh = true, s8.source = true, s8.queryFilter = true), d9 && (s8.why.source.push("Layer required fields changed"), s8.source = true), m(c11, this._queryInfo) && (this._queryInfo = c11), this._schema = r5, this._resolver.resolve();
  }
  whenInitialized() {
    return this._resolver.promise;
  }
  async applyUpdate(e3) {
    if (e3.queryFilter || e3.source && this._didEdit)
      return this.refresh(e3.version), void (this._didEdit = false);
    this._subscriptions.forEach((s8) => s8.applyUpdate(e3)), await this.resend();
  }
  refresh(e3) {
    for (const s8 of this._tiles())
      this.unsubscribe(s8), this.subscribe(s8, e3);
  }
  subscribe(e3, s8) {
    const t6 = new o6(e3, s8);
    this._subscriptions.set(e3.id, t6);
  }
  unsubscribe(e3) {
    const s8 = this.get(e3.id);
    r(s8) && s8.abort(), this._subscriptions.delete(e3.id);
  }
  createQuery(e3 = {}) {
    const s8 = this._queryInfo.historicMoment ? new Date(this._queryInfo.historicMoment) : null;
    return new b3({ ...this._queryInfo, historicMoment: s8, ...e3 });
  }
  get(e3) {
    return this._subscriptions.has(e3) ? this._subscriptions.get(e3) : null;
  }
  async queryLastEditDate() {
    throw new Error("Service does not support query type");
  }
  async query(e3) {
    throw new Error("Service does not support query");
  }
  *_tiles() {
    const e3 = Array.from(this._subscriptions.values());
    for (const s8 of e3)
      yield s8.tile;
  }
  async edit(e3, s8) {
    const t6 = Array.from(this._subscriptions.values()), r5 = t6.map(({ tile: e4 }) => e4);
    for (const i4 of t6)
      i4.removeIds(s8);
    if (e3.length) {
      const t7 = r5.map((s9) => {
        const t8 = this.createTileQuery(s9);
        return t8.objectIds = e3, { tile: s9, query: t8 };
      }).map(async ({ tile: e4, query: s9 }) => ({ tile: e4, result: await this.query(s9), query: s9 })), i4 = (await C(t7)).map(async ({ tile: t8, result: r6 }) => {
        if (!r6.hasFeatures && !s8.length && !e3.length)
          return;
        const i5 = this._subscriptions.get(t8.key.id);
        i5 && i5.edit(r6, e3);
      });
      await E2(i4);
    }
    this._didEdit = true;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/BaseFeatureSource.js
var d6 = s.getLogger("esri.views.2d.layers.features.sources.BaseFeatureSource");
var y5 = 4;
var h4 = class extends f8 {
  constructor(e3) {
    super(e3), this.type = "feature", this.mode = "on-demand", this._adapter = h3(e3.serviceInfo), this._queue = new l2({ concurrency: 8, process: async (e4) => {
      if (f2(e4), r(e4.tile)) {
        const t6 = e4.tile.key.id, { signal: s8 } = e4, i4 = a("esri-tiles-debug") ? { tile: t6.replace(/\//g, "."), depth: e4.depth } : void 0, a7 = await this._adapter.executeQuery(e4.query, { signal: s8, query: { ...i4, ...this._schema.customParameters } });
        return a7.level = e4.tile.key.level, a7;
      }
      return this._adapter.executeQuery(e4.query, { ...e4, query: this._schema.customParameters });
    } }), this._patchQueue = new l2({ concurrency: 8, process: async (e4) => {
      if (f2(e4), r(e4.tile)) {
        const t6 = e4.tile.key.id, { signal: s8 } = e4, i4 = a("esri-tiles-debug") ? { tile: t6.replace(/\//g, "."), depth: e4.depth } : void 0, a7 = await this._adapter.executeQuery(e4.query, { signal: s8, query: { ...i4, ...this._schema.customParameters } });
        return a7.level = e4.tile.key.level, a7;
      }
      return this._adapter.executeQuery(e4.query, { ...e4, query: this._schema.customParameters });
    } });
  }
  destroy() {
    super.destroy(), this._adapter.destroy(), this._queue.destroy(), this._patchQueue.destroy();
  }
  get updating() {
    return !!this._queue.length || Array.from(this._subscriptions.values()).some((e3) => !e3.done);
  }
  get maxRecordCountFactor() {
    const { query: e3 } = this._serviceInfo.capabilities;
    return e3.supportsMaxRecordCountFactor ? y5 : null;
  }
  get maxPageSize() {
    const { query: e3 } = this._serviceInfo.capabilities;
    return (e3.maxRecordCount ?? 8e3) * c(this.maxRecordCountFactor, 1);
  }
  get pageSize() {
    return Math.min(8e3, this.maxPageSize);
  }
  enableEvent(e3, t6) {
  }
  subscribe(e3, r5) {
    super.subscribe(e3, r5);
    const s8 = this._subscriptions.get(e3.id);
    this._fetchDataTile(e3).catch((r6) => {
      g2(r6) || d6.error(new s2("mapview-query-error", "Encountered error when fetching tile", { tile: e3, error: r6 }));
    }).then(() => s8.end());
  }
  unsubscribe(e3) {
    super.unsubscribe(e3);
  }
  readers(e3) {
    return this._subscriptions.get(e3).readers();
  }
  async query(e3) {
    return this._adapter.executeQuery(e3, { query: this._schema.customParameters });
  }
  async queryLastEditDate() {
    const t6 = this._serviceInfo.source, r5 = { ...t6.query, f: "json" };
    return (await U(t6.path, { query: r5, responseType: "json" })).data.editingInfo.lastEditDate;
  }
  createTileQuery(e3, t6 = {}) {
    const s8 = this._serviceInfo.geometryType, i4 = this.createQuery(t6);
    i4.quantizationParameters = t6.quantizationParameters ?? e3.getQuantizationParameters(), i4.resultType = "tile", i4.geometry = e3.extent, this._serviceInfo.capabilities.query.supportsQuantization ? "esriGeometryPolyline" === s8 && (i4.maxAllowableOffset = e3.resolution * a("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== s8 && "esriGeometryPolygon" !== s8 || (i4.maxAllowableOffset = e3.resolution, "esriGeometryPolyline" === s8 && (i4.maxAllowableOffset *= a("feature-polyline-generalization-factor")));
    const a7 = this._serviceInfo.capabilities.query;
    return i4.defaultSpatialReferenceEnabled = a7.supportsDefaultSpatialReference, i4.compactGeometryEnabled = a7.supportsCompactGeometry, i4;
  }
  async _executePatchQuery(e3, t6, r5, s8) {
    const a7 = t6.clone();
    a7.outFields = [this._serviceInfo.objectIdField, ...r5], a7.returnCentroid = false, a7.returnGeometry = false;
    const o8 = r(a7.start) ? a7.start / 8e3 : 0, n6 = s8.signal;
    return this._patchQueue.push({ tile: e3, query: a7, signal: n6, depth: o8 });
  }
  async _resend(e3, t6) {
    const { query: r5, message: s8 } = e3, a7 = r(r5.outFields) ? r5.outFields : [], u4 = this._queryInfo.outFields, c11 = u4.filter((e4) => !a7.includes(e4));
    if (t(s8.addOrUpdate))
      this._onMessage({ ...s8, type: "append" });
    else if (c11.length)
      try {
        const e4 = this._subscriptions.get(s8.id).tile, i4 = await this._executePatchQuery(e4, r5, c11, t6);
        f2(t6), r5.outFields = u4, s8.addOrUpdate.joinAttributes(i4), this._onMessage({ ...s8, end: s8.end, type: "append" });
      } catch (l9) {
      }
    else
      this._onMessage({ ...s8, type: "append" });
  }
  async _resendSubscription(e3) {
    if (a("esri-2d-update-debug") && console.debug(e3.tile.id, "Resend Subscription"), e3.empty)
      return this._onMessage({ id: e3.tile.id, addOrUpdate: null, end: false, type: "append" });
    const t6 = e3.signal;
    for (const r5 of e3.requests.done)
      await this._resend(r5, { signal: t6 });
    return r(e3.edits) ? this._onMessage(e3.edits) : void 0;
  }
  async resend() {
    const e3 = Array.from(this._subscriptions.values());
    await Promise.all(e3.map((e4) => this._resendSubscription(e4)));
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DrillDownFeatureSource.js
var i3 = a("esri-mobile");
var a5 = { maxDrillLevel: i3 ? 1 : 4, maxRecordCountFactor: i3 ? 1 : 3 };
var o7 = class extends h4 {
  constructor(e3) {
    super(e3);
  }
  async _fetchDataTile(e3) {
    const s8 = this._serviceInfo.capabilities.query.supportsMaxRecordCountFactor, i4 = this._subscriptions.get(e3.key.id), o8 = i4.signal, n6 = e3.getQuantizationParameters();
    let c11 = 0;
    const d9 = async (u4, l9) => {
      const p3 = this._queryInfo, m5 = this.createTileQuery(u4, { maxRecordCountFactor: s8 ? a5.maxRecordCountFactor : void 0, returnExceededLimitFeatures: false, quantizationParameters: n6 });
      c11++;
      try {
        const r5 = await this._queue.push({ tile: e3, query: m5, signal: o8, depth: l9 });
        if (c11--, f2(o8), !r5)
          return;
        if (p3 !== this._queryInfo)
          return void d9(u4, l9);
        if (r5.exceededTransferLimit && l9 < a5.maxDrillLevel) {
          for (const e4 of u4.createChildTiles())
            d9(e4, l9 + 1);
          return;
        }
        const s9 = { id: e3.id, addOrUpdate: r5, end: 0 === c11, type: "append" };
        i4.add({ query: m5, message: s9 }), this._onMessage(s9);
      } catch (h6) {
        g2(h6) || this._onMessage({ id: e3.id, addOrUpdate: null, end: true, type: "append" });
      }
    };
    d9(e3, 0);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/GeoEventSource.js
var m4 = 2500;
function l7(t6, s8) {
  const r5 = t6.weakClone();
  if (r(t6.geometry)) {
    const e3 = b2(s8, t6.geometry.coords[0]), i4 = M2(s8, t6.geometry.coords[1]);
    r5.geometry = new t3([], [e3, i4]);
  }
  return r5;
}
function _2(e3) {
  return "esriGeometryPoint" === e3 ? l7 : (t6, s8) => {
    const r5 = t6.weakClone(), n6 = new t3(), o8 = false, c11 = false, d9 = ie(n6, t6.geometry, o8, c11, e3, s8, false, false);
    return r5.geometry = d9, r5;
  };
}
function f9(t6) {
  return "esriGeometryPoint" === t6 ? (t7) => r(t7.geometry) ? { minX: t7.geometry.coords[0], minY: t7.geometry.coords[1], maxX: t7.geometry.coords[0], maxY: t7.geometry.coords[1] } : { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } : (t7) => {
    let s8 = 1 / 0, r5 = 1 / 0, i4 = -1 / 0, n6 = -1 / 0;
    return r(t7.geometry) && t7.geometry.forEachVertex((e3, t8) => {
      s8 = Math.min(s8, e3), r5 = Math.min(r5, t8), i4 = Math.max(i4, e3), n6 = Math.max(n6, t8);
    }), { minX: s8, minY: r5, maxX: i4, maxY: n6 };
  };
}
function g6(e3, t6) {
  const r5 = i(9, f9(t6));
  return r5.load(e3), r5;
}
function v4(e3, t6) {
  return e3.search({ minX: t6.bounds[0], minY: t6.bounds[1], maxX: t6.bounds[2], maxY: t6.bounds[3] });
}
var y6 = class {
  constructor(e3, t6) {
    this.onUpdate = e3, this._geometryType = t6, this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  get _features() {
    const e3 = [];
    return this._objectIdToFeature.forEach((t6) => e3.push(t6)), e3;
  }
  add(e3) {
    this._objectIdToFeature.set(e3.objectId, e3), this._index = null;
  }
  get(e3) {
    return this._objectIdToFeature.has(e3) ? this._objectIdToFeature.get(e3) : null;
  }
  forEach(e3) {
    this._objectIdToFeature.forEach(e3);
  }
  search(e3) {
    return this._index || (this._index = g6(this._features, this._geometryType)), v4(this._index, e3);
  }
  removeById(e3) {
    const t6 = this._objectIdToFeature.get(e3);
    return t6 ? (this._objectIdToFeature.delete(e3), this._index = null, t6) : null;
  }
  update(e3, t6) {
    this.onUpdate(e3, t6);
  }
  get size() {
    return this._objectIdToFeature.size;
  }
};
var b4 = class extends f8 {
  constructor(e3) {
    super(e3), this.type = "geoevent", this._dataReceiveEventEnabled = false, this._level = 0, this._updateInfo = { websocket: 0, client: 0 };
    const { outSR: s8 } = e3, { geometryType: r5, objectIdField: i4, timeInfo: n6, purgeOptions: o8, source: a7, spatialReference: u4, serviceFilter: h6, maxReconnectionAttempts: p3, maxReconnectionInterval: l9, updateInterval: f10, enableDataReceived: g8, customParameters: v5 } = e3.serviceInfo, b5 = new y6(this._onUpdate.bind(this), r5), I2 = new h2(b5, i4, n6, o8), j4 = t4(a7, u4, s8, r5, h6, p3, l9, v5);
    this._store = b5, this._manager = I2, this._connection = j4, this._quantize = _2(r5), this._dataReceiveEventEnabled = g8, this._handles = [this._connection.on("feature", (e4) => this._onFeature(e4)), l(() => j4.connectionStatus, (e4) => this.events.emit("connectionStatus", e4)), l(() => j4.errorString, (e4) => this.events.emit("errorString", e4))], this._initUpdateInterval = () => {
      let t6 = performance.now();
      this._updateIntervalId = setInterval(() => {
        const s9 = performance.now(), r6 = s9 - t6;
        if (r6 > m4) {
          t6 = s9;
          const e4 = Math.round(this._updateInfo.client / (r6 / 1e3)), i5 = Math.round(this._updateInfo.websocket / (r6 / 1e3));
          this._updateInfo.client = 0, this._updateInfo.websocket = 0, this.events.emit("updateRate", { client: e4, websocket: i5 });
        }
        e3.canAcceptRequest() && this._manager.checkForUpdates();
      }, f10);
    }, this._initUpdateInterval();
  }
  destroy() {
    super.destroy(), this._clearUpdateInterval(), this._handles.forEach((e3) => e3.remove()), this._connection.destroy();
  }
  _fetchDataTile() {
  }
  pauseStream() {
    this._clearUpdateInterval();
  }
  resumeStream() {
    this._initUpdateInterval();
  }
  enableEvent(e3, t6) {
    "data-received" === e3 && (this._dataReceiveEventEnabled = t6);
  }
  get updating() {
    return false;
  }
  subscribe(e3, t6) {
    super.subscribe(e3, t6);
    const s8 = this._subscriptions.get(e3.id);
    this._level = e3.level;
    const r5 = this._getTileFeatures(e3);
    this._onMessage({ type: "append", id: e3.key.id, addOrUpdate: r5, end: true }), s8.didSend = true;
  }
  unsubscribe(e3) {
    super.unsubscribe(e3);
  }
  *readers(t6) {
    const s8 = this._subscriptions.get(t6), { tile: r5 } = s8;
    yield this._getTileFeatures(r5);
    for (const i4 of s8.requests.stream.entries)
      r(i4) && r(i4.addOrUpdate) && (yield i4.addOrUpdate);
  }
  createTileQuery(e3) {
    throw new Error("Service does not support tile  queries");
  }
  async resend() {
    this._subscriptions.forEach((e3) => {
      const { tile: t6 } = e3, s8 = { type: "append", id: t6.id, addOrUpdate: this._getTileFeatures(t6), end: true };
      this._onMessage(s8);
    });
  }
  _getTileFeatures(e3) {
    const t6 = this._store.search(e3).map((t7) => this._quantize(t7, e3.transform));
    return d4.fromOptimizedFeatures(t6, this._serviceInfo, e3.transform);
  }
  _onFeature(e3) {
    this._updateInfo.websocket++;
    try {
      this._dataReceiveEventEnabled && this.events.emit("feature", e3);
      const t6 = Q(e3, this._serviceInfo.geometryType, false, false, this._serviceInfo.objectIdField);
      this._manager.add(t6);
    } catch (t6) {
    }
  }
  _clearUpdateInterval() {
    clearInterval(this._updateIntervalId), this._updateIntervalId = 0;
  }
  _onUpdate(t6, s8) {
    r(t6) && (this._updateInfo.client += t6.length), this._subscriptions.forEach((e3, t7) => {
      e3.didSend && e3.tile.level === this._level && this._onMessage({ type: "append", id: t7, addOrUpdate: null, clear: true, end: false });
    }), this._subscriptions.forEach((e3, t7) => {
      if (!e3.didSend || e3.tile.level !== this._level)
        return;
      const s9 = e3.tile, r5 = { type: "append", id: t7, addOrUpdate: this._getTileFeatures(s9), remove: [], end: true, status: t5.empty() };
      e3.requests.stream.enqueue(r5), this._onMessage(r5);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/PagedFeatureSource.js
var n5 = s.getLogger("esri.views.2d.layers.features.sources.FeatureSource");
var d7 = class extends h4 {
  constructor(e3) {
    super(e3);
  }
  async _fetchDataTile(t6) {
    const r5 = 6, i4 = 20, o8 = this._subscriptions.get(t6.key.id);
    let d9 = false, c11 = 0, u4 = 0;
    const p3 = (e3, r6) => {
      u4--, f2(o8);
      const a7 = t6.id, i5 = e3.reader, n6 = e3.query;
      if (!i5.exceededTransferLimit) {
        if (d9 = true, 0 !== r6 && !i5.hasFeatures) {
          const e5 = { id: a7, addOrUpdate: i5, end: 0 === u4, type: "append" };
          return o8.add({ message: e5, query: n6 }), void this._onMessage(e5);
        }
        const e4 = { id: a7, addOrUpdate: i5, end: 0 === u4, type: "append" };
        return o8.add({ message: e4, query: n6 }), void this._onMessage(e4);
      }
      const c12 = { id: a7, addOrUpdate: i5, end: d9 && 0 === u4, type: "append" };
      o8.add({ message: c12, query: n6 }), this._onMessage(c12);
    };
    let h6 = 0, m5 = 0;
    for (; !d9 && m5++ < i4; ) {
      let i5;
      for (let r6 = 0; r6 < h6 + 1; r6++) {
        const r7 = c11++;
        u4++, i5 = this._fetchDataTilePage(t6, r7, o8).then((e3) => e3 && p3(e3, r7)).catch((r8) => {
          d9 = true, g2(r8) || (n5.error(new s2("mapview-query-error", "Encountered error when fetching tile", { tile: t6, error: r8 })), this._onMessage({ id: t6.id, addOrUpdate: null, end: d9, type: "append" }));
        });
      }
      await i5, f2(o8), h6 = Math.min(h6 + 2, r5);
    }
  }
  async _fetchDataTilePage(e3, t6, a7) {
    f2(a7);
    const o8 = this._queryInfo, n6 = { start: this.pageSize * t6, num: this.pageSize, returnExceededLimitFeatures: true, quantizationParameters: e3.getQuantizationParameters() };
    r(this.maxRecordCountFactor) && (n6.maxRecordCountFactor = this.maxRecordCountFactor);
    const d9 = this.createTileQuery(e3, n6);
    try {
      const r5 = a7.signal, i4 = await this._queue.push({ tile: e3, query: d9, signal: r5, depth: t6 });
      return f2(a7), i4 ? o8 !== this._queryInfo ? this._fetchDataTilePage(e3, t6, a7) : { reader: i4, query: d9 } : null;
    } catch (c11) {
      return b(c11), null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/SnapshotFeatureSource.js
var u = s.getLogger("esri.views.2d.layers.features.sources.SnapshotFeatureSource");
function l8(t6, e3, s8) {
  const r5 = t6.getXHydrated(), o8 = t6.getYHydrated(), a7 = e3.getColumnForX(r5), i4 = Math.floor(e3.normalizeCol(a7));
  return `${s8}/${Math.floor(e3.getRowForY(o8))}/${i4}`;
}
function c7(t6, e3) {
  if (t(t6))
    return null;
  const s8 = e3.transform, o8 = t6.getQuantizationTransform();
  if (t(o8)) {
    const [e4, r5] = s8.scale, [o9, a8] = s8.translate, i5 = -o9 / e4, n7 = 1 / e4, d10 = a8 / r5, h7 = 1 / -r5;
    return t6.transform(i5, d10, n7, h7);
  }
  const [a7, i4] = o8.scale, [n6, d9] = o8.translate, [h6, u4] = s8.scale, [l9, c11] = s8.translate, g8 = a7 / h6, p3 = (n6 - l9) / h6, _3 = i4 / u4, m5 = (-d9 + c11) / u4;
  return t6.transform(p3, m5, g8, _3);
}
var g7 = class extends h4 {
  constructor(t6) {
    super(t6), this.mode = "snapshot", this._loading = true, this._controller = new AbortController(), this._downloadPromise = null, this._didSendEnd = false, this._queries = new Array(), this._invalidated = false, this._hasAggregates = false, this._random = new t2(1e3), this._store = t6.store, this._markedIdsBufId = this._store.storage.createBitset();
  }
  destroy() {
    super.destroy(), this._controller.abort();
  }
  get loading() {
    return this._loading;
  }
  get _signal() {
    return this._controller.signal;
  }
  update(t6, e3) {
    super.update(t6, e3), this._hasAggregates = t6.targets.aggregate;
  }
  async resend(t6 = false) {
    if (await this._downloadPromise, this._invalidated || t6) {
      const t7 = f(this._schema.featureCount, "Expected featureCount to be defined");
      return this._invalidated = false, this._subscriptions.forEach((t8) => t8.clear()), this._downloadPromise = this._download(t7), void await this._downloadPromise;
    }
    const s8 = this._queries.map(({ query: t7, reader: e3 }) => this._sendPatchQuery(t7, e3));
    await Promise.all(s8), this._subscriptions.forEach((t7) => {
      t7.requests.done.forEach((t8) => this._onMessage(t8.message));
    });
  }
  async refresh() {
    await this.resend(true);
  }
  async _sendPatchQuery(t6, e3) {
    const r5 = r(t6.outFields) ? t6.outFields : [], a7 = this._queryInfo.outFields, i4 = a7.filter((t7) => !r5.includes(t7));
    if (!i4.length)
      return;
    const n6 = t6.clone(), d9 = this._signal;
    n6.returnGeometry = false, n6.returnCentroid = false, n6.outFields = i4, t6.outFields = a7;
    const h6 = await this._queue.push({ query: n6, depth: 0, signal: d9 });
    f2({ signal: d9 }), e3.joinAttributes(h6);
  }
  async _fetchDataTile(t6) {
    if (!this._downloadPromise) {
      const t7 = f(this._schema.featureCount, "Expected featureCount to be defined");
      this._downloadPromise = this._download(t7);
    }
    const s8 = this._store.search(t6), r5 = this._subscriptions.get(t6.key.id), o8 = s8.length - 1;
    for (let e3 = 0; e3 < o8; e3++) {
      const o9 = c7(s8[e3], t6), i5 = { type: "append", id: t6.id, addOrUpdate: o9, end: false, status: t5.empty() };
      r5.add({ query: null, message: i5 }), this._hasAggregates || await L(1), this._onMessage(i5);
    }
    const i4 = c7(o8 >= 0 ? s8[o8] : null, t6), n6 = this._didSendEnd, d9 = { type: "append", id: t6.id, addOrUpdate: i4, end: n6, status: t5.empty() };
    r5.add({ query: null, message: d9 }), this._onMessage(d9);
  }
  async _download(t6) {
    try {
      await this.whenInitialized();
      const e3 = this._store.storage.getBitset(this._markedIdsBufId), s8 = /* @__PURE__ */ new Set();
      e3.clear();
      const r5 = Math.ceil(t6 / this.pageSize), o8 = Array.from({ length: r5 }, (t7, e4) => e4).sort((t7, e4) => this._random.getInt() - this._random.getInt()).map((t7) => this._downloadPage(t7, e3, s8));
      await Promise.all(o8), this._store.sweepFeatures(e3, this._store.storage), this._store.sweepFeatureSets(s8);
    } catch (e3) {
      u.error("mapview-snapshot-source", "Encountered and error when downloading feature snapshot", e3);
    }
    this._sendEnd(), this._loading = false;
  }
  async _downloadPage(t6, e3, r5) {
    const a7 = this.pageSize, i4 = { start: t6 * a7, num: a7, cacheHint: true };
    r(this.maxRecordCountFactor) && (i4.maxRecordCountFactor = this.maxRecordCountFactor);
    const n6 = this.createQuery(i4), d9 = this._signal, h6 = await this._queue.push({ query: n6, depth: t6, signal: d9 });
    f2({ signal: d9 }), this._queries.push({ query: n6, reader: h6 }), this._store.insert(h6), r5.add(h6.instance);
    const u4 = h6.getCursor();
    for (; u4.next(); )
      e3.set(u4.getDisplayId());
    this._send(h6);
  }
  _send(t6) {
    if (!this._subscriptions.size)
      return;
    let e3 = null;
    const o8 = /* @__PURE__ */ new Map(), a7 = /* @__PURE__ */ new Set(), i4 = /* @__PURE__ */ new Map();
    this._subscriptions.forEach((t7) => {
      const s8 = t7.tile;
      o8.set(s8.key.id, null), e3 = s8.tileInfoView, a7.add(s8.level);
      const { row: r5, col: n6 } = s8.key, d9 = `${s8.level}/${r5}/${n6}`, h6 = i4.get(d9) ?? [];
      h6.push(t7), i4.set(d9, h6);
    });
    for (const s8 of a7) {
      const a8 = e3.getLODInfoAt(s8), n6 = t6.getCursor();
      for (; n6.next(); ) {
        const t7 = l8(n6, a8, s8), e4 = n6.getIndex();
        if (i4.has(t7))
          for (const s9 of i4.get(t7)) {
            const t8 = s9.tile.id;
            let a9 = o8.get(t8);
            t(a9) && (a9 = [], o8.set(t8, a9)), a9.push(e4);
          }
      }
    }
    o8.forEach((e4, r5) => {
      if (r(e4)) {
        const s8 = this._subscriptions.get(r5), o9 = { type: "append", id: r5, addOrUpdate: c7(r2.from(t6, e4), s8.tile), end: false, status: t5.empty() };
        s8.add({ query: null, message: o9 }), this._onMessage(o9);
      }
    });
  }
  _sendEnd() {
    this._subscriptions.forEach((t6) => {
      const e3 = { type: "append", id: t6.tile.id, addOrUpdate: null, end: true, status: t5.empty() };
      t6.add({ query: null, message: e3 }), this._onMessage(e3);
    }), this._didSendEnd = true;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/createSource.js
function a6(e3, r5, a7, u4, i4, p3) {
  const f10 = c8(e3, r5, a7, u4, i4, p3);
  switch (f10.type) {
    case "feature":
      switch (f10.origin) {
        case "hosted":
        case "local":
          return new d7(f10);
        case "snapshot":
          return new g7(f10);
        case "unknown":
          return new o7(f10);
      }
    case "geoevent":
      return new b4(f10);
  }
}
function c8(t6, o8, n6, s8, a7, c11) {
  switch (t6.type) {
    case "snapshot":
      return { type: "feature", origin: "snapshot", featureCount: c(t6.featureCount, 0), serviceInfo: t6, onMessage: s8, outSR: o8, tileInfoView: n6, canAcceptRequest: a7, store: c11 };
    case "stream":
      return { type: "geoevent", serviceInfo: t6, onMessage: s8, outSR: o8, canAcceptRequest: a7 };
    case "memory":
    case "on-demand":
      return { type: "feature", serviceInfo: t6, onMessage: s8, outSR: o8, origin: u4(t6.source), tileInfoView: n6, canAcceptRequest: a7 };
  }
  function u4(e3) {
    return Array.isArray(e3) ? "local" : "path" in e3 && g4(e3.path) ? "hosted" : "unknown";
  }
}

// node_modules/@arcgis/core/geohash/geohashUtils.js
var c9 = new Float64Array(2);
var h5 = new Float64Array(2);
function x2(t6, n6) {
  let o8 = -90, e3 = 90, r5 = -180, c11 = 180;
  for (let h6 = 0; h6 < n6; h6++) {
    const n7 = Math.ceil((h6 + 1) / 2), f10 = Math.floor((h6 + 1) / 2), l9 = 1 - h6 % 2, a7 = 30 - (3 * n7 + 2 * f10), u4 = 30 - (2 * n7 + 3 * f10), s8 = 3 * l9 + 2 * (1 - l9), i4 = 2 * l9 + 3 * (1 - l9), M4 = 3 * l9 + 7 * (1 - l9) << u4, g8 = (7 * l9 + 3 * (1 - l9) << a7 & t6.geohashX) >> a7, b5 = (M4 & t6.geohashY) >> u4;
    for (let t7 = s8 - 1; t7 >= 0; t7--) {
      const n8 = (r5 + c11) / 2, o9 = g8 & 1 << t7 ? 1 : 0;
      r5 = (1 - o9) * r5 + o9 * n8, c11 = (1 - o9) * n8 + o9 * c11;
    }
    for (let t7 = i4 - 1; t7 >= 0; t7--) {
      const n8 = (o8 + e3) / 2, r6 = b5 & 1 << t7 ? 1 : 0;
      o8 = (1 - r6) * o8 + r6 * n8, e3 = (1 - r6) * n8 + r6 * e3;
    }
  }
  return [r5, o8, c11, e3];
}
function y7(t6, n6, o8, e3) {
  e3 % 2 && (e3 += 1);
  let r5 = 0, c11 = 0, h6 = -90, f10 = 90, l9 = -180, a7 = 180;
  for (let u4 = 0; u4 < e3 / 2; u4++) {
    for (let t7 = 0; t7 < 5; t7++) {
      const n7 = (l9 + a7) / 2, e4 = o8 > n7 ? 1 : 0;
      r5 |= e4 << 29 - (t7 + 5 * u4), l9 = (1 - e4) * l9 + e4 * n7, a7 = (1 - e4) * n7 + e4 * a7;
    }
    for (let t7 = 0; t7 < 5; t7++) {
      const o9 = (h6 + f10) / 2, e4 = n6 > o9 ? 1 : 0;
      c11 |= e4 << 29 - (t7 + 5 * u4), h6 = (1 - e4) * h6 + e4 * o9, f10 = (1 - e4) * o9 + e4 * f10;
    }
  }
  t6.geohashX = r5, t6.geohashY = c11;
}
function p2(t6, n6, o8, e3, r5) {
  r5 % 2 && (r5 += 1);
  let c11 = 0, h6 = 0, f10 = -90, l9 = 90, a7 = -180, u4 = 180;
  for (let s8 = 0; s8 < r5 / 2; s8++) {
    for (let t7 = 0; t7 < 5; t7++) {
      const n7 = (a7 + u4) / 2, o9 = e3 > n7 ? 1 : 0;
      c11 |= o9 << 29 - (t7 + 5 * s8), a7 = (1 - o9) * a7 + o9 * n7, u4 = (1 - o9) * n7 + o9 * u4;
    }
    for (let t7 = 0; t7 < 5; t7++) {
      const n7 = (f10 + l9) / 2, e4 = o8 > n7 ? 1 : 0;
      h6 |= e4 << 29 - (t7 + 5 * s8), f10 = (1 - e4) * f10 + e4 * n7, l9 = (1 - e4) * n7 + e4 * l9;
    }
  }
  t6[2 * n6] = c11, t6[2 * n6 + 1] = h6;
}

// node_modules/@arcgis/core/geohash/GeohashTree.js
var c10 = class {
  constructor(e3 = [], s8, i4 = 8096) {
    this.onRelease = (t6) => {
    }, this._nodes = 0, this._root = new u2(this, 0, 0, 0), this._statisticFields = e3, this._pool = i4 ? new s7(8096) : null, this._serviceInfo = s8;
  }
  destroy() {
    this.clear();
  }
  _acquire(t6, s8, i4) {
    this._nodes++;
    let o8 = null;
    return r(this._pool) && (o8 = this._pool.dequeue()), r(o8) ? o8.realloc(t6, s8, i4) : o8 = new u2(this, t6, s8, i4), o8;
  }
  _release(t6) {
    this.onRelease(t6), this._nodes--, r(this._pool) && this._pool.enqueue(t6);
  }
  get count() {
    return this._root.count;
  }
  get size() {
    return this._nodes;
  }
  get poolSize() {
    return E(this._pool, 0, (t6) => t6.size);
  }
  get depth() {
    let t6 = 0;
    return this.forEach((e3) => t6 = Math.max(t6, e3.depth)), t6;
  }
  dropLevels(t6) {
    this.forEach((e3) => {
      if (e3.depth >= t6)
        for (let t7 = 0; t7 < e3.children.length; t7++) {
          const s8 = e3.children[t7];
          s8 && this._release(s8);
        }
    }), this.forEach((e3) => {
      if (e3.depth >= t6)
        for (let t7 = 0; t7 < e3.children.length; t7++)
          e3.children[t7] = null;
    });
  }
  clear() {
    this.forEach((t6) => this._release(t6)), this._root = new u2(this, 0, 0, 0);
  }
  insert(t6, e3, s8 = 0) {
    const i4 = d4.fromOptimizedFeatures([t6], this._serviceInfo).getCursor();
    i4.next();
    const o8 = i4.readGeometry();
    if (!o8)
      return;
    const [n6, a7] = o8.coords, r5 = t6.geohashX, l9 = t6.geohashY;
    this.insertCursor(i4, t6.displayId, n6, a7, r5, l9, e3, s8);
  }
  insertCursor(t6, e3, s8, i4, o8, n6, a7, r5 = 0) {
    let l9 = this._root, h6 = 0, c11 = 0, u4 = 0;
    for (; null !== l9; ) {
      if (l9.depth >= r5 && (l9.count += 1, l9.xTotal += s8, l9.yTotal += i4, l9.xGeohashTotal += o8, l9.yGeohashTotal += n6, l9.referenceId = e3, this._updateStatisticsCursor(t6, l9, 1)), h6 >= a7)
        return void l9.add(e3);
      const d9 = Math.ceil((h6 + 1) / 2), f10 = Math.floor((h6 + 1) / 2), x5 = 1 - h6 % 2, m5 = 30 - (3 * d9 + 2 * f10), p3 = 30 - (2 * d9 + 3 * f10), g8 = (o8 & 7 * x5 + 3 * (1 - x5) << m5) >> m5, y8 = (n6 & 3 * x5 + 7 * (1 - x5) << p3) >> p3, _3 = g8 + y8 * (8 * x5 + 4 * (1 - x5));
      c11 = c11 << 3 * x5 + 2 * (1 - x5) | g8, u4 = u4 << 2 * x5 + 3 * (1 - x5) | y8, null == l9.children[_3] && (l9.children[_3] = this._acquire(c11, u4, h6 + 1)), h6 += 1, l9 = l9.children[_3];
    }
  }
  remove(t6, e3) {
    const s8 = d4.fromOptimizedFeatures([t6], this._serviceInfo).getCursor();
    s8.next();
    const i4 = s8.readGeometry();
    if (!i4)
      return;
    const [o8, n6] = i4.coords, a7 = t6.geohashX, r5 = t6.geohashY;
    this.removeCursor(s8, o8, n6, a7, r5, e3);
  }
  removeCursor(t6, e3, s8, i4, o8, n6) {
    let a7 = this._root, r5 = 0;
    for (; null !== a7; ) {
      if (a7.count -= 1, a7.xTotal -= e3, a7.yTotal -= s8, a7.xGeohashTotal -= i4, a7.yGeohashTotal -= o8, this._updateStatisticsCursor(t6, a7, -1), r5 >= n6)
        return void a7.remove(t6.getDisplayId());
      const l9 = Math.ceil((r5 + 1) / 2), h6 = Math.floor((r5 + 1) / 2), c11 = 1 - r5 % 2, u4 = 30 - (3 * l9 + 2 * h6), d9 = 30 - (2 * l9 + 3 * h6), f10 = ((i4 & 7 * c11 + 3 * (1 - c11) << u4) >> u4) + ((o8 & 3 * c11 + 7 * (1 - c11) << d9) >> d9) * (8 * c11 + 4 * (1 - c11)), x5 = a7.children[f10];
      1 === x5.count && (this._release(x5), a7.children[f10] = null), r5 += 1, a7 = x5;
    }
  }
  forEach(t6) {
    let e3 = this._root;
    for (; null !== e3; ) {
      const s8 = this._linkChildren(e3) || e3.next;
      t6(e3), e3 = s8;
    }
  }
  find(t6, e3, s8) {
    return this._root.find(t6, e3, s8, 0, 0, 0);
  }
  findIf(t6) {
    let e3 = null;
    return this.forEach((s8) => {
      t6(s8) && (e3 = s8);
    }), e3;
  }
  findAllIf(t6) {
    const e3 = [];
    return this.forEach((s8) => {
      t6(s8) && e3.push(s8);
    }), e3;
  }
  findSingleOccupancyNode(t6, e3, s8, i4, o8) {
    let n6 = this._root;
    for (; null !== n6; ) {
      const a7 = n6.depth, r5 = n6.xNode, l9 = n6.yNode, h6 = 1 - a7 % 2, c11 = n6.xGeohashTotal / n6.count, u4 = n6.yGeohashTotal / n6.count;
      if (1 === n6.count && t6 < c11 && c11 <= s8 && e3 < u4 && u4 <= i4)
        return n6;
      if (a7 >= o8) {
        n6 = n6.next;
        continue;
      }
      const d9 = Math.ceil((a7 + 1) / 2), f10 = Math.floor((a7 + 1) / 2), x5 = 30 - (3 * d9 + 2 * f10), m5 = 30 - (2 * d9 + 3 * f10), p3 = ~((1 << x5) - 1), g8 = ~((1 << m5) - 1), y8 = (t6 & p3) >> x5, _3 = (e3 & g8) >> m5, M4 = (s8 & p3) >> x5, N = (i4 & g8) >> m5, T2 = r5 << 3 * h6 + 2 * (1 - h6), I2 = l9 << 2 * h6 + 3 * (1 - h6), S4 = T2 + 8 * h6 + 4 * (1 - h6), v5 = I2 + 4 * h6 + 8 * (1 - h6), C2 = Math.max(T2, y8), b5 = Math.max(I2, _3), G3 = Math.min(S4, M4), k3 = Math.min(v5, N);
      let F3 = null, z = null;
      for (let t7 = b5; t7 <= k3; t7++)
        for (let e4 = C2; e4 <= G3; e4++) {
          const s9 = e4 - T2 + (t7 - I2) * (8 * h6 + 4 * (1 - h6)), i5 = n6.children[s9];
          i5 && (F3 || (F3 = i5, F3.next = n6.next), z && (z.next = i5), z = i5, i5.next = n6.next);
        }
      n6 = F3 || n6.next;
    }
    return null;
  }
  getRegionDisplayIds(t6, e3, s8, i4, o8) {
    let n6 = this._root;
    const a7 = [];
    for (; null !== n6; ) {
      const r5 = n6.depth, l9 = n6.xNode, h6 = n6.yNode;
      if (r5 >= o8) {
        const o9 = n6.xGeohashTotal / n6.count, r6 = n6.yGeohashTotal / n6.count;
        t6 <= o9 && o9 <= s8 && e3 <= r6 && r6 <= i4 && n6.displayIds.forEach((t7) => a7.push(t7)), n6 = n6.next;
        continue;
      }
      const c11 = Math.ceil((r5 + 1) / 2), u4 = Math.floor((r5 + 1) / 2), d9 = 1 - r5 % 2, f10 = 30 - (3 * c11 + 2 * u4), x5 = 30 - (2 * c11 + 3 * u4), m5 = ~((1 << f10) - 1), p3 = ~((1 << x5) - 1), g8 = (t6 & m5) >> f10, y8 = (e3 & p3) >> x5, _3 = (s8 & m5) >> f10, M4 = (i4 & p3) >> x5, N = l9 << 3 * d9 + 2 * (1 - d9), T2 = h6 << 2 * d9 + 3 * (1 - d9), I2 = N + 8 * d9 + 4 * (1 - d9), S4 = T2 + 4 * d9 + 8 * (1 - d9), v5 = Math.max(N, g8), C2 = Math.max(T2, y8), b5 = Math.min(I2, _3), G3 = Math.min(S4, M4);
      let k3 = null, F3 = null;
      for (let t7 = C2; t7 <= G3; t7++)
        for (let e4 = v5; e4 <= b5; e4++) {
          const s9 = e4 - N + (t7 - T2) * (8 * d9 + 4 * (1 - d9)), i5 = n6.children[s9];
          i5 && (k3 || (k3 = i5, k3.next = n6.next), F3 && (F3.next = i5), F3 = i5, i5.next = n6.next);
        }
      n6 = k3 || n6.next;
    }
    return a7;
  }
  getRegionStatistics(t6, e3, s8, i4, o8) {
    let n6 = this._root, a7 = 0, r5 = 0, l9 = 0;
    const h6 = {};
    let c11 = 0;
    for (; null !== n6; ) {
      const u4 = n6.depth, d9 = n6.xNode, f10 = n6.yNode;
      if (u4 >= o8) {
        const o9 = n6.xGeohashTotal / n6.count, u5 = n6.yGeohashTotal / n6.count;
        t6 < o9 && o9 <= s8 && e3 < u5 && u5 <= i4 && (a7 += n6.count, r5 += n6.xTotal, l9 += n6.yTotal, 1 === n6.count && (c11 = n6.referenceId), this._aggregateStatistics(h6, n6.statistics)), n6 = n6.next;
        continue;
      }
      const x5 = Math.ceil((u4 + 1) / 2), m5 = Math.floor((u4 + 1) / 2), p3 = 1 - u4 % 2, g8 = 30 - (3 * x5 + 2 * m5), y8 = 30 - (2 * x5 + 3 * m5), _3 = ~((1 << g8) - 1), M4 = ~((1 << y8) - 1), N = (t6 & _3) >> g8, T2 = (e3 & M4) >> y8, I2 = (s8 & _3) >> g8, S4 = (i4 & M4) >> y8, v5 = d9 << 3 * p3 + 2 * (1 - p3), C2 = f10 << 2 * p3 + 3 * (1 - p3), b5 = v5 + 8 * p3 + 4 * (1 - p3), G3 = C2 + 4 * p3 + 8 * (1 - p3), k3 = Math.max(v5, N), F3 = Math.max(C2, T2), z = Math.min(b5, I2), w4 = Math.min(G3, S4);
      let j4 = null, E4 = null;
      for (let o9 = F3; o9 <= w4; o9++)
        for (let u5 = k3; u5 <= z; u5++) {
          const d10 = u5 - v5 + (o9 - C2) * (8 * p3 + 4 * (1 - p3)), f11 = n6.children[d10];
          if (f11) {
            if (o9 !== F3 && o9 !== w4 && u5 !== k3 && u5 !== z) {
              const o10 = f11.xGeohashTotal / f11.count, u6 = f11.yGeohashTotal / f11.count;
              t6 < o10 && o10 <= s8 && e3 < u6 && u6 <= i4 && (a7 += f11.count, r5 += f11.xTotal, l9 += f11.yTotal, 1 === n6.count && (c11 = n6.referenceId), this._aggregateStatistics(h6, f11.statistics));
              continue;
            }
            j4 || (j4 = f11, j4.next = n6.next), E4 && (E4.next = f11), E4 = f11, f11.next = n6.next;
          }
        }
      n6 = j4 || n6.next;
    }
    return { count: a7, attributes: this.normalizeStatistics(h6, a7), xTotal: r5, yTotal: l9, referenceId: c11 };
  }
  getBins(t6, e3, s8, i4, o8) {
    const n6 = [];
    let a7 = this._root;
    for (; null !== a7; ) {
      const r5 = a7.depth, l9 = a7.xNode, h6 = a7.yNode;
      if (r5 >= o8) {
        n6.push(a7), a7 = a7.next;
        continue;
      }
      const c11 = Math.ceil((r5 + 1) / 2), u4 = Math.floor((r5 + 1) / 2), d9 = 1 - r5 % 2, f10 = 30 - (3 * c11 + 2 * u4), x5 = 30 - (2 * c11 + 3 * u4), m5 = ~((1 << f10) - 1), p3 = ~((1 << x5) - 1), g8 = (t6 & m5) >> f10, y8 = (e3 & p3) >> x5, _3 = (s8 & m5) >> f10, M4 = (i4 & p3) >> x5, N = l9 << 3 * d9 + 2 * (1 - d9), T2 = h6 << 2 * d9 + 3 * (1 - d9), I2 = N + 8 * d9 + 4 * (1 - d9), S4 = T2 + 4 * d9 + 8 * (1 - d9), v5 = Math.max(N, g8), C2 = Math.max(T2, y8), b5 = Math.min(I2, _3), G3 = Math.min(S4, M4);
      let k3 = null, F3 = null;
      for (let t7 = C2; t7 <= G3; t7++)
        for (let e4 = v5; e4 <= b5; e4++) {
          const s9 = e4 - N + (t7 - T2) * (8 * d9 + 4 * (1 - d9)), i5 = a7.children[s9];
          i5 && (k3 || (k3 = i5, k3.next = a7.next), F3 && (F3.next = i5), F3 = i5, i5.next = a7.next);
        }
      a7 = k3 || a7.next;
    }
    return n6;
  }
  _linkChildren(t6) {
    let e3 = null, s8 = null;
    for (let i4 = 0; i4 <= t6.children.length; i4++) {
      const o8 = t6.children[i4];
      o8 && (e3 || (e3 = o8, e3.next = t6.next), s8 && (s8.next = o8), s8 = o8, o8.next = t6.next);
    }
    return e3;
  }
  _updateStatisticsCursor(t6, e3, s8) {
    for (const i4 of this._statisticFields) {
      const o8 = i4.name, n6 = i4.inField ? t6.readAttribute(i4.inField) : t6.getComputedNumericAtIndex(i4.inFieldIndex);
      switch (i4.statisticType) {
        case "norm": {
          e3.statistics[o8] || (e3.statistics[o8] = {});
          const a7 = i4.inNormalizationField, r5 = t6.readAttribute(a7), l9 = e3.statistics[o8].onStatisticField || 0, h6 = e3.statistics[o8].onStatisticNormalizationField || 0;
          null == n6 || isNaN(n6) || null == r5 || 0 === r5 || isNaN(r5) || (e3.statistics[o8].onStatisticField = l9 + s8 * n6, e3.statistics[o8].onStatisticNormalizationField = h6 + s8 * r5);
          break;
        }
        case "sum":
        case "avg": {
          e3.statistics[o8] || (e3.statistics[o8] = { value: 0, nanCount: 0 });
          const t7 = e3.statistics[o8].value, i5 = e3.statistics[o8].nanCount;
          null == n6 || isNaN(n6) ? e3.statistics[o8].nanCount = i5 + s8 : e3.statistics[o8].value = t7 + s8 * n6;
          break;
        }
        case "avg_angle": {
          e3.statistics[o8] || (e3.statistics[o8] = { x: 0, y: 0, nanCount: 0 });
          const t7 = e3.statistics[o8].x, i5 = e3.statistics[o8].y, a7 = e3.statistics[o8].nanCount, r5 = Math.PI / 180;
          null == n6 || isNaN(n6) ? e3.statistics[o8].nanCount = a7 + s8 : (e3.statistics[o8].x = t7 + s8 * Math.cos(n6 * r5), e3.statistics[o8].y = i5 + s8 * Math.sin(n6 * r5));
          break;
        }
        case "mode": {
          e3.statistics[o8] || (e3.statistics[o8] = {});
          const t7 = e3.statistics[o8][n6] || 0;
          e3.statistics[o8][n6] = t7 + s8;
          break;
        }
      }
    }
  }
  _aggregateStatistics(t6, e3) {
    for (const s8 of this._statisticFields) {
      const i4 = s8.name;
      switch (s8.statisticType) {
        case "sum":
        case "avg":
        case "avg_angle":
        case "mode":
        case "norm":
          t6[i4] || (t6[i4] = {});
          for (const s9 in e3[i4]) {
            const o8 = t6[i4][s9] || 0;
            t6[i4][s9] = o8 + e3[i4][s9];
          }
      }
    }
  }
  normalizeStatistics(t6, e3) {
    const s8 = {};
    for (const i4 of this._statisticFields) {
      const o8 = i4.name;
      switch (i4.statisticType) {
        case "norm": {
          const i5 = t6[o8];
          if (e3 && null == i5.onStatisticNormalizationField)
            break;
          if (e3 && i5.onStatisticNormalizationField) {
            s8[o8] = i5.onStatisticField / i5.onStatisticNormalizationField;
            break;
          }
          s8[o8] = 0;
          break;
        }
        case "sum": {
          if (!e3)
            break;
          const { value: i5, nanCount: n6 } = t6[o8];
          if (!(e3 - n6))
            break;
          s8[o8] = i5;
          break;
        }
        case "avg": {
          if (!e3)
            break;
          const { value: i5, nanCount: n6 } = t6[o8];
          if (!(e3 - n6))
            break;
          s8[o8] = i5 / (e3 - n6);
          break;
        }
        case "avg_angle": {
          if (!e3)
            break;
          const { x: i5, y: n6, nanCount: a7 } = t6[o8];
          if (!(e3 - a7))
            break;
          const r5 = i5 / (e3 - a7), l9 = n6 / (e3 - a7), h6 = 180 / Math.PI, c11 = Math.atan2(l9, r5) * h6;
          s8[o8] = c11;
          break;
        }
        case "mode": {
          const e4 = t6[o8];
          let i5 = 0, n6 = null;
          for (const t7 in e4) {
            const s9 = e4[t7];
            s9 > i5 && (i5 = s9, n6 = t7);
          }
          s8[o8] = "null" === n6 ? null : n6;
          break;
        }
      }
    }
    return s8;
  }
};
var u2 = class {
  constructor(t6, e3, s8, i4) {
    this.count = 0, this.xTotal = 0, this.yTotal = 0, this.statistics = {}, this.displayId = 0, this.referenceId = 0, this.displayIds = /* @__PURE__ */ new Set(), this.next = null, this.depth = 0, this.xNode = 0, this.yNode = 0, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this._tree = t6, this.children = new Array(32);
    for (let o8 = 0; o8 < this.children.length; o8++)
      this.children[o8] = null;
    this.xNode = e3, this.yNode = s8, this.depth = i4;
  }
  realloc(t6, e3, s8) {
    for (let i4 = 0; i4 < this.children.length; i4++)
      this.children[i4] = null;
    return this.xNode = t6, this.yNode = e3, this.depth = s8, this.next = null, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this.displayId = 0, this.referenceId = 0, this.xTotal = 0, this.yTotal = 0, this.count = 0, this.statistics = {}, this.displayIds.clear(), this;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  add(t6) {
    this.displayIds.add(t6);
  }
  remove(t6) {
    this.displayIds.delete(t6);
  }
  getAttributes() {
    const t6 = this._tree.normalizeStatistics(this.statistics, this.count);
    return t6.aggregateId = this.id, t6.aggregateCount = this.count, t6;
  }
  getGeometry(t6, s8) {
    const i4 = this.getLngLatBounds(), [h6, c11, u4, d9] = i4, f10 = g3({ rings: [[[h6, c11], [h6, d9], [u4, d9], [u4, c11], [h6, c11]]] }, k.WGS84, t6), x5 = D2(new t3(), f10, false, false);
    return r(s8) ? ie(new t3(), x5, false, false, "esriGeometryPolygon", s8, false, false) : x5;
  }
  getLngLatBounds() {
    const t6 = this.depth, e3 = Math.ceil(t6 / 2), s8 = Math.floor(t6 / 2), o8 = 30 - (3 * e3 + 2 * s8), n6 = 30 - (2 * e3 + 3 * s8), a7 = this.xNode << o8, r5 = this.yNode << n6;
    return x2({ geohashX: a7, geohashY: r5 }, this.depth);
  }
  find(t6, e3, s8, i4, o8, n6) {
    if (i4 >= s8)
      return this;
    const a7 = 1 - i4 % 2, r5 = 3 * a7 + 2 * (1 - a7), l9 = 2 * a7 + 3 * (1 - a7), h6 = 30 - o8 - r5, c11 = 30 - n6 - l9, u4 = ((t6 & 7 * a7 + 3 * (1 - a7) << h6) >> h6) + ((e3 & 3 * a7 + 7 * (1 - a7) << c11) >> c11) * (8 * a7 + 4 * (1 - a7)), d9 = this.children[u4];
    return null == d9 ? null : d9.find(t6, e3, s8, i4 + 1, o8 + r5, n6 + l9);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/BinStore.js
var G2 = s.getLogger("esri.view.2d.layers.features.support.BinStore");
var B = 12;
var L2 = 64;
var R3 = 5;
function S3(e3) {
  return 57.29577951308232 * e3;
}
var A2 = class extends c4 {
  constructor(e3, t6, s8, r5) {
    super(e3, s8), this._geohashLevel = R3, this._geohashBuf = [], this._serviceInfo = r5, this.geometryInfo = e3.geometryInfo, this._spatialReference = t6, this._projectionSupportCheck = f4(t6, k.WGS84), this._bitsets.geohash = s8.getBitset(s8.createBitset()), this._bitsets.inserted = s8.getBitset(s8.createBitset());
  }
  destroy() {
    this._tree && this._tree.destroy();
  }
  async updateSchema(t6, r5) {
    const i4 = this._schema;
    try {
      await super.updateSchema(t6, r5), await this._projectionSupportCheck;
    } catch (d9) {
    }
    const n6 = m(i4, r5);
    r5 && (!t(n6) || t6.source || t6.storage.filters) ? ((a3(n6, "params.fields") || a3(n6, "params") || !this._tree || t6.source) && (this._tree && this._tree.destroy(), this._tree = new c10(this._statisticFields, this._serviceInfo), this._tree.onRelease = (e3) => e3.displayId && this._storage.releaseDisplayId(e3.displayId), this._geohashLevel = this._schema.params.fixedBinLevel, this._rebuildTree(), a("esri-2d-update-debug") && G2.info("Aggregate mesh needs update due to tree changing")), a("esri-2d-update-debug") && G2.info("Aggregate mesh needs update due to tree changing"), t6.targets[r5.name] = true, t6.mesh = false) : i4 && (t6.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e3, t6) {
    this._bitsets.inserted.forEachSet((s8) => {
      if (!e3.has(s8)) {
        const e4 = t6.lookupByDisplayIdUnsafe(s8);
        this._remove(e4);
      }
    });
  }
  sweepAggregates(e3, t6, s8) {
  }
  onTileData(e3, t6, r5, i4, o8 = true) {
    if (!this._schema || t(t6.addOrUpdate))
      return t6;
    const a7 = this._getTransforms(e3, this._spatialReference);
    {
      const e4 = t6.addOrUpdate.getCursor();
      for (; e4.next(); )
        this._update(e4, i4);
    }
    if (t6.status.mesh || !o8)
      return t6;
    const h6 = new Array();
    this._getBinsForTile(h6, e3, a7, r5), t6.addOrUpdate = d4.fromOptimizedFeatures(h6, { ...this._serviceInfo, geometryType: "esriGeometryPolygon" }), t6.addOrUpdate.attachStorage(r5), t6.clear = true, t6.end = true;
    {
      const s8 = t6.addOrUpdate.getCursor();
      for (; s8.next(); ) {
        const t7 = s8.getDisplayId();
        this._bitsets.computed.unset(t7), this.setComputedAttributes(r5, s8, t7, e3.scale);
      }
    }
    return t6;
  }
  forEach(e3) {
    this._tree.forEach(e3);
  }
  onTileUpdate(e3) {
  }
  getAggregate(e3) {
    const t6 = s6(e3, true), s8 = this._tree.findIf((e4) => e4.displayId === t6);
    return o(s8, (e4) => this._toAggregateGraphic(e4));
  }
  getAggregates() {
    return this._tree.findAllIf((e3) => e3.depth === this._geohashLevel).map(this._toAggregateGraphic.bind(this));
  }
  getDisplayId(e3) {
    const t6 = this._tree.findIf((t7) => t7.id === e3);
    return o(t6, (e4) => e4.displayId);
  }
  getFeatureDisplayIdsForAggregate(e3) {
    const t6 = this._tree.findIf((t7) => t7.id === e3);
    return E(t6, [], (e4) => Array.from(e4.displayIds));
  }
  getDisplayIdForReferenceId(e3) {
    const t6 = this._tree.findIf((t7) => 1 === t7.displayIds.size && t7.displayIds.has(e3));
    return o(t6, (e4) => e4.displayId);
  }
  _toAggregateGraphic(e3) {
    const t6 = this._spatialReference;
    return { referenceId: null, objectId: e3.id, displayId: e3.displayId, attributes: e3.getAttributes(), geometry: ne(e3.getGeometry(t6), "esriGeometryPolygon", false, false), centroid: null };
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e3) {
    const t6 = e3.getDisplayId(), s8 = e3.getXHydrated(), r5 = e3.getYHydrated(), i4 = this._geohashBuf[2 * t6], o8 = this._geohashBuf[2 * t6 + 1];
    this._bitsets.inserted.has(t6) && (this._bitsets.inserted.unset(t6), this._tree.removeCursor(e3, s8, r5, i4, o8, this._geohashLevel));
  }
  _update(e3, t6) {
    const s8 = e3.getDisplayId(), r5 = this._bitsets.inserted, i4 = t6.isVisible(s8);
    if (i4 === r5.has(s8))
      return;
    if (!i4)
      return void this._remove(e3);
    const o8 = e3.getXHydrated(), a7 = e3.getYHydrated();
    if (!this._setGeohash(s8, o8, a7))
      return;
    const h6 = this._geohashBuf[2 * s8], n6 = this._geohashBuf[2 * s8 + 1];
    this._tree.insertCursor(e3, s8, o8, a7, h6, n6, this._geohashLevel), r5.set(s8);
  }
  _setGeohash(e3, t6, s8) {
    if (this._bitsets.geohash.has(e3))
      return true;
    const r5 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const i4 = S3(t6 / s3.radius), o8 = i4 - 360 * Math.floor((i4 + 180) / 360), a7 = S3(Math.PI / 2 - 2 * Math.atan(Math.exp(-s8 / s3.radius)));
      p2(r5, e3, a7, o8, B);
    } else {
      const i4 = g3({ x: t6, y: s8 }, this._spatialReference, k.WGS84);
      if (!i4)
        return false;
      p2(r5, e3, i4.y, i4.x, B);
    }
    return this._bitsets.geohash.set(e3), true;
  }
  _getBinsForTile(e3, t6, s8, r5) {
    try {
      const { xLL: i4, yLL: o8, xTR: a7, yTR: h6, level: n6 } = this._getGeohashBounds(t6), d9 = this._tree.getBins(i4, o8, a7, h6, n6);
      for (const t7 of d9) {
        t7.displayId || (t7.displayId = r5.createDisplayId(true));
        const i5 = t7.getGeometry(this._spatialReference, s8.tile), o9 = new s4(i5, t7.getAttributes());
        o9.objectId = t7.id, o9.displayId = t7.displayId, e3.push(o9);
      }
    } catch (i4) {
      return void G2.error("Unable to get bins for tile", t6.key.id);
    }
  }
  _getGeohash(e3, t6, s8) {
    const r5 = { geohashX: 0, geohashY: 0 };
    return y7(r5, t6, e3, s8), r5;
  }
  _getGeohashBounds(e3) {
    const t6 = this._getGeohashLevel(e3.key.level), s8 = [e3.extent.xmin, e3.extent.ymin, e3.extent.xmax, e3.extent.ymax], r5 = v.fromExtent(M.fromBounds(s8, this._spatialReference)), i4 = g3(r5, this._spatialReference, k.WGS84, { densificationStep: e3.resolution * L2 }), o8 = D2(new t3(), i4, false, false), a7 = o8.coords.filter((e4, t7) => !(t7 % 2)), h6 = o8.coords.filter((e4, t7) => t7 % 2), n6 = Math.min(...a7), d9 = Math.min(...h6), g8 = Math.max(...a7), p3 = Math.max(...h6), l9 = this._getGeohash(n6, d9, t6), u4 = this._getGeohash(g8, p3, t6);
    return { xLL: l9.geohashX, yLL: l9.geohashY, xTR: u4.geohashX, yTR: u4.geohashY, level: t6 };
  }
  _getGeohashLevel(e3) {
    return this._schema.params.fixedBinLevel;
  }
  _getTransforms(e3, t6) {
    const s8 = { originPosition: "upperLeft", scale: [e3.resolution, e3.resolution], translate: [e3.bounds[0], e3.bounds[3]] }, r5 = R(t6);
    if (!r5)
      return { tile: s8, left: null, right: null };
    const [i4, o8] = r5.valid;
    return { tile: s8, left: { ...s8, translate: [o8, e3.bounds[3]] }, right: { ...s8, translate: [i4 - o8 + e3.bounds[0], e3.bounds[3]] } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ClusterStore.js
var M3 = 12;
var x3 = 1;
var L3 = class extends o2 {
  constructor(e3, t6, s8, r5, i4) {
    super(new t3([], [t6, s8]), r5, null, e3), this.geohashBoundsInfo = i4;
  }
  get count() {
    return this.attributes.cluster_count;
  }
  static create(e3, t6, s8, r5, i4, a7, o8, h6) {
    const l9 = new L3(t6, s8, r5, a7, o8);
    return l9.displayId = e3.createDisplayId(true), l9.referenceId = h6, l9.tileLevel = i4, l9;
  }
  update(e3, t6, s8, r5, i4, a7) {
    return this.geometry.coords[0] = e3, this.geometry.coords[1] = t6, this.tileLevel = s8, this.attributes = r5, this.geohashBoundsInfo = i4, this.referenceId = null, this.referenceId = a7, this;
  }
  toJSON() {
    return { objectId: this.objectId, referenceId: 1 === this.attributes.cluster_count ? this.referenceId : null, attributes: { ...this.attributes, clusterId: this.objectId }, geometry: { x: this.geometry.coords[0], y: this.geometry.coords[1] } };
  }
};
function j3(e3) {
  return 57.29577951308232 * e3;
}
var w3 = class extends c4 {
  constructor(t6, s8, r5, i4) {
    super(t6, r5), this.events = new n2(), this._geohashLevel = 0, this._tileLevel = 0, this._aggregateValueRanges = {}, this._aggregateValueRangesChanged = false, this._geohashBuf = [], this._clusters = /* @__PURE__ */ new Map(), this._tiles = /* @__PURE__ */ new Map(), this._serviceInfo = i4, this.geometryInfo = t6.geometryInfo, this._spatialReference = s8, this._projectionSupportCheck = f4(s8, k.WGS84), this._bitsets.geohash = r5.getBitset(r5.createBitset()), this._bitsets.inserted = r5.getBitset(r5.createBitset());
  }
  destroy() {
    this._tree.destroy();
  }
  async updateSchema(e3, r5) {
    const i4 = this._schema;
    try {
      await super.updateSchema(e3, r5), await this._projectionSupportCheck;
    } catch (n6) {
    }
    const l9 = m(i4, r5);
    r5 && (!t(l9) || e3.source || e3.storage.filters) ? ((a3(l9, "params.fields") || !this._tree || e3.source) && (this._tree && this._tree.destroy(), this._tree = new c10(this._statisticFields, this._serviceInfo), this._rebuildTree(), a("esri-2d-update-debug") && console.debug("Aggregate mesh needs update due to tree changing")), a("esri-2d-update-debug") && console.debug("Applying Update - ClusterStore:", l9), e3.targets[r5.name] = true, e3.mesh = false, this._aggregateValueRanges = {}) : i4 && (e3.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e3, t6) {
    this._bitsets.inserted.forEachSet((s8) => {
      if (!e3.has(s8)) {
        const e4 = t6.lookupByDisplayIdUnsafe(s8);
        this._remove(e4);
      }
    });
  }
  sweepAggregates(e3, t6, s8) {
    this._clusters.forEach((r5, i4) => {
      r5 && r5.tileLevel !== s8 && (e3.releaseDisplayId(r5.displayId), t6.unsetAttributeData(r5.displayId), this._clusters.delete(i4));
    });
  }
  onTileData(e3, t6, r5, i4, a7 = true) {
    if (!this._schema || t(t6.addOrUpdate))
      return t6;
    const o8 = this._getTransforms(e3, this._spatialReference);
    {
      const e4 = t6.addOrUpdate.getCursor();
      for (; e4.next(); )
        this._update(e4, i4);
    }
    if (t6.status.mesh || !a7)
      return t6;
    const h6 = new Array(), l9 = this._schema.params.clusterRadius;
    this._getClustersForTile(h6, e3, l9, r5, o8), t6.addOrUpdate = d4.fromOptimizedFeatures(h6, this._serviceInfo), t6.addOrUpdate.attachStorage(r5), t6.clear = true, t6.end = true;
    {
      const s8 = t6.addOrUpdate.getCursor();
      for (; s8.next(); ) {
        const t7 = s8.getDisplayId();
        this._bitsets.computed.unset(t7), this.setComputedAttributes(r5, s8, t7, e3.scale);
      }
    }
    return this._aggregateValueRangesChanged && t6.end && (this.events.emit("valueRangesChanged", { valueRanges: this._aggregateValueRanges }), this._aggregateValueRangesChanged = false), t6;
  }
  onTileUpdate({ added: e3, removed: t6 }) {
    if (e3.length) {
      const t7 = e3[0].level;
      this._tileLevel = t7, this._setGeohashLevel(t7);
    }
    if (!this._schema)
      return;
    const s8 = this._schema.params.clusterRadius;
    t6.forEach((e4) => {
      this._tiles.delete(e4.key.id), this._markTileClustersForDeletion(e4, s8);
    });
  }
  getAggregate(e3) {
    for (const t6 of this._clusters.values())
      if (((t6 == null ? void 0 : t6.displayId) & n3) == (e3 & n3))
        return t6.toJSON();
    return null;
  }
  getAggregates() {
    const e3 = [];
    for (const t6 of this._clusters.values())
      (t6 == null ? void 0 : t6.tileLevel) === this._tileLevel && e3.push(t6.toJSON());
    return e3;
  }
  getDisplayId(e3) {
    const t6 = this._clusters.get(e3);
    return t6 ? t6.displayId : null;
  }
  getFeatureDisplayIdsForAggregate(e3) {
    const t6 = this._clusters.get(e3);
    if (!t6)
      return [];
    const s8 = t6.geohashBoundsInfo;
    return this._tree.getRegionDisplayIds(s8.xLL, s8.yLL, s8.xTR, s8.yTR, s8.level);
  }
  getDisplayIdForReferenceId(e3) {
    for (const t6 of this._clusters.values())
      if ((t6 == null ? void 0 : t6.referenceId) === e3)
        return t6.displayId;
    return null;
  }
  getAggregateValueRanges() {
    return this._aggregateValueRanges;
  }
  forEach(e3) {
    for (const [t6, s8] of this._clusters)
      s8 && e3(s8, t6);
  }
  size() {
    let e3 = 0;
    return this.forEach((t6) => e3++), e3;
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e3) {
    const t6 = e3.getDisplayId(), s8 = e3.getXHydrated(), r5 = e3.getYHydrated(), i4 = this._geohashBuf[2 * t6], a7 = this._geohashBuf[2 * t6 + 1];
    this._bitsets.inserted.has(t6) && (this._bitsets.inserted.unset(t6), this._tree.removeCursor(e3, s8, r5, i4, a7, this._geohashLevel));
  }
  _update(e3, t6) {
    const s8 = e3.getDisplayId(), r5 = this._bitsets.inserted, i4 = t6.isVisible(s8);
    if (i4 === r5.has(s8))
      return;
    if (!i4)
      return void this._remove(e3);
    const a7 = e3.getXHydrated(), o8 = e3.getYHydrated();
    if (!this._setGeohash(s8, a7, o8))
      return;
    const h6 = this._geohashBuf[2 * s8], l9 = this._geohashBuf[2 * s8 + 1];
    this._tree.insertCursor(e3, s8, a7, o8, h6, l9, this._geohashLevel), r5.set(s8);
  }
  _setGeohash(e3, t6, s8) {
    if (this._bitsets.geohash.has(e3))
      return true;
    const r5 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const i4 = j3(t6 / s3.radius), a7 = i4 - 360 * Math.floor((i4 + 180) / 360), o8 = j3(Math.PI / 2 - 2 * Math.atan(Math.exp(-s8 / s3.radius)));
      p2(r5, e3, o8, a7, M3);
    } else {
      const i4 = g3({ x: t6, y: s8 }, this._spatialReference, k.WGS84);
      if (!i4)
        return false;
      p2(r5, e3, i4.y, i4.x, M3);
    }
    return this._bitsets.geohash.set(e3), true;
  }
  _getClustersForTile(e3, t6, a7, o8, h6, l9 = true) {
    const n6 = this._schema.params.clusterPixelBuffer, u4 = 2 * a7, c11 = this._getGeohashLevel(t6.key.level), f10 = Math.ceil(2 ** t6.key.level * o3 / u4), _3 = Math.ceil(n6 / u4) + 0, m5 = Math.ceil(o3 / u4), { row: y8, col: v5 } = t6.key, b5 = v5 * o3, R5 = y8 * o3, C2 = Math.floor(b5 / u4) - _3, M4 = Math.floor(R5 / u4) - _3, x5 = C2 + m5 + 2 * _3, L4 = M4 + m5 + 2 * _3, j4 = t6.tileInfoView.getLODInfoAt(t6.key.level);
    for (let I2 = C2; I2 <= x5; I2++)
      for (let a8 = M4; a8 <= L4; a8++) {
        let n7 = I2;
        j4.wrap && (n7 = I2 < 0 ? I2 + f10 : I2 % f10);
        const u5 = j4.wrap && I2 < 0, _4 = j4.wrap && I2 % f10 !== I2, m6 = this._lookupCluster(o8, j4, t6.key.level, n7, a8, c11);
        if (r(m6)) {
          const t7 = o(h6, (e4) => u5 ? e4.left : _4 ? e4.right : e4.tile);
          if (l9 && t(t7))
            continue;
          if (!m6.count)
            continue;
          if (r(t7) && l9) {
            const s8 = m6.geometry.clone();
            let i4 = m6.attributes;
            s8.coords[0] = b2(t7, s8.coords[0]), s8.coords[1] = M2(t7, s8.coords[1]), 1 === m6.count && r(m6.referenceId) && (i4 = { ...m6.attributes, referenceId: m6.referenceId });
            const a9 = new s4(s8, i4);
            a9.displayId = m6.displayId, e3.push(a9);
          }
        }
      }
  }
  _getGeohashLevel(e3) {
    return Math.min(Math.ceil(e3 / 2 + 2), M3);
  }
  _setGeohashLevel(e3) {
    const t6 = this._getGeohashLevel(e3), s8 = (Math.floor(t6 / x3) + 1) * x3 - 1;
    if (this._geohashLevel !== s8)
      return this._geohashLevel = s8, this._rebuildTree(), void this._bitsets.geohash.clear();
  }
  _getTransforms(e3, t6) {
    const s8 = { originPosition: "upperLeft", scale: [e3.resolution, e3.resolution], translate: [e3.bounds[0], e3.bounds[3]] }, r5 = R(t6);
    if (!r5)
      return { tile: s8, left: null, right: null };
    const [i4, a7] = r5.valid;
    return { tile: s8, left: { ...s8, translate: [a7, e3.bounds[3]] }, right: { ...s8, translate: [i4 - a7 + e3.bounds[0], e3.bounds[3]] } };
  }
  _getClusterId(e3, t6, s8) {
    return (15 & e3) << 28 | (16383 & t6) << 14 | 16383 & s8;
  }
  _markForDeletion(e3, t6, s8) {
    const r5 = this._getClusterId(e3, t6, s8);
    this._clusters.delete(r5);
  }
  _getClusterBounds(e3, t6, s8) {
    const r5 = this._schema.params.clusterRadius, i4 = 2 * r5;
    let a7 = s8 % 2 ? t6 * i4 : t6 * i4 - r5;
    const o8 = s8 * i4;
    let h6 = a7 + i4;
    const l9 = o8 - i4, n6 = 2 ** e3.level * o3;
    e3.wrap && a7 < 0 && (a7 = 0), e3.wrap && h6 > n6 && (h6 = n6);
    const u4 = a7 / o3, c11 = o8 / o3, g8 = h6 / o3, d9 = l9 / o3;
    return [e3.getXForColumn(u4), e3.getYForRow(c11), e3.getXForColumn(g8), e3.getYForRow(d9)];
  }
  _lookupCluster(e3, t6, s8, i4, a7, o8) {
    const h6 = this._getClusterId(s8, i4, a7), l9 = this._clusters.get(h6), [c11, g8, d9, f10] = this._getClusterBounds(t6, i4, a7), p3 = { x: c11, y: g8 }, _3 = { x: d9, y: f10 };
    let m5 = 0, I2 = 0, v5 = 0, b5 = 0;
    if (this._spatialReference.isWebMercator) {
      {
        const e4 = j3(p3.x / s3.radius);
        m5 = e4 - 360 * Math.floor((e4 + 180) / 360), I2 = j3(Math.PI / 2 - 2 * Math.atan(Math.exp(-p3.y / s3.radius)));
      }
      {
        const e4 = j3(_3.x / s3.radius);
        v5 = e4 - 360 * Math.floor((e4 + 180) / 360), b5 = j3(Math.PI / 2 - 2 * Math.atan(Math.exp(-_3.y / s3.radius)));
      }
    } else {
      const e4 = g3(p3, this._spatialReference, k.WGS84), t7 = g3(_3, this._spatialReference, k.WGS84);
      if (!e4 || !t7)
        return null;
      m5 = e4.x, I2 = e4.y, v5 = t7.x, b5 = t7.y;
    }
    const R5 = { geohashX: 0, geohashY: 0 }, M4 = { geohashX: 0, geohashY: 0 };
    y7(R5, I2, m5, o8), y7(M4, b5, v5, o8);
    const x5 = R5.geohashX, w4 = R5.geohashY, V = M4.geohashX, S4 = M4.geohashY, F3 = { xLL: x5, yLL: w4, xTR: V, yTR: S4, level: o8 }, D3 = this._tree.getRegionStatistics(x5, w4, V, S4, o8), { count: T2, xTotal: k3, yTotal: B2, referenceId: A4 } = D3, G3 = T2 ? k3 / T2 : 0, O2 = T2 ? B2 / T2 : 0;
    if (0 === T2)
      return this._clusters.set(h6, null), null;
    const U3 = { cluster_count: T2, ...D3.attributes }, X = r(l9) ? l9.update(G3, O2, s8, U3, F3, A4) : L3.create(e3, h6, G3, O2, s8, U3, F3, A4);
    return 0 === T2 && (X.geometry.coords[0] = (c11 + d9) / 2, X.geometry.coords[1] = (g8 + f10) / 2), this._clusters.set(h6, X), this._updateAggregateValueRangeForCluster(X, X.tileLevel), X;
  }
  _updateAggregateValueRangeForCluster(e3, t6) {
    const s8 = this._aggregateValueRanges[t6] || { minValue: 1 / 0, maxValue: 0 }, r5 = s8.minValue, i4 = s8.maxValue;
    s8.minValue = Math.min(r5, e3.count), s8.maxValue = Math.max(i4, e3.count), this._aggregateValueRanges[t6] = s8, r5 === s8.minValue && i4 === s8.maxValue || (this._aggregateValueRangesChanged = true);
  }
  _markTileClustersForDeletion(e3, t6) {
    const s8 = 2 * t6, r5 = Math.ceil(o3 / s8), { row: i4, col: a7 } = e3.key, o8 = a7 * o3, h6 = i4 * o3, l9 = Math.floor(o8 / s8), n6 = Math.floor(h6 / s8);
    for (let u4 = l9; u4 < l9 + r5; u4++)
      for (let t7 = n6; t7 < n6 + r5; t7++)
        this._markForDeletion(e3.key.level, u4, t7);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/FeatureController2D.js
var T = 5e3;
var k2 = "tileRenderer.featuresView.attributeView.initialize";
var q3 = "tileRenderer.featuresView.attributeView.requestUpdate";
var R4 = "tileRenderer.featuresView.requestRender";
function U2(e3) {
  return "worker:port-closed" === e3.name;
}
function x4(e3) {
  if (!g2(e3) && !U2(e3))
    throw e3;
}
function Q2(e3) {
  return "feature" === e3.type && "snapshot" === e3.mode;
}
var O = class extends d3 {
  constructor() {
    super(...arguments), this._storage = new r3(), this._markedIdsBufId = this._storage.createBitset(), this._lastCleanup = performance.now(), this._cleanupNeeded = false, this._invalidated = false, this._tileToResolver = /* @__PURE__ */ new Map(), this._didEdit = false, this._updateVersion = 1, this.tileStore = null, this.config = null, this.processor = null, this.remoteClient = null, this.service = null;
  }
  initialize() {
    this._initStores(), this._initSource(), this._updateQueue = new l2({ concurrency: "geoevent" === this._source.type ? 1 : 4, process: (e3, t6) => this._onTileMessage(e3, { signal: t6 }) }), this.handles.add([this.tileStore.on("update", this.onTileUpdate.bind(this)), f3(() => !this.updating, () => this.onIdle())]), this._checkUpdating = setInterval(() => this.notifyChange("updating"), 300);
  }
  _initSource() {
    const e3 = this.tileStore.tileScheme, t6 = () => this._updateQueue.length < 50, r5 = (e4, t7) => (this._invalidated = true, this._patchTile(e4, t7));
    this._source = a6(this.service, this.spatialReference, e3, r5, t6, this.featureStore), this._proxyEvents();
  }
  _proxyEvents() {
    if ("geoevent" === this._source.type) {
      const e3 = this._source.events;
      this.handles.add([e3.on("connectionStatus", (e4) => this.remoteClient.invoke("setProperty", { propertyName: "connectionStatus", value: e4 }).catch(x4)), e3.on("errorString", (e4) => this.remoteClient.invoke("setProperty", { propertyName: "errorString", value: e4 }).catch(x4)), e3.on("feature", (e4) => this.remoteClient.invoke("emitEvent", { name: "data-received", event: { attributes: e4.attributes, centroid: e4.centroid, geometry: e4.geometry } }).catch(x4)), e3.on("updateRate", (e4) => this.remoteClient.invoke("emitEvent", { name: "update-rate", event: { ...e4 } }).catch(x4))]);
    }
  }
  _initAttributeStore(e3) {
    this.attributeStore ? this.attributeStore.invalidateResources() : this.attributeStore = new R2({ type: "remote", initialize: (e4, t6) => j(this.remoteClient.invoke(k2, e4, { signal: t6 }).catch(x4)), update: (e4, t6) => j(this.remoteClient.invoke(q3, e4, { signal: t6 }).catch(x4)), render: (e4) => j(this.remoteClient.invoke(R4, void 0, { signal: e4 }).catch(x4)) }, e3, () => this.notifyChange("updating"));
  }
  _initStores() {
    const e3 = "snapshot" === this.service.type ? "snapshot" : "on-demand", t6 = { geometryInfo: { geometryType: this.service.geometryType, hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
    this.featureStore = new l3(t6, this._storage, e3);
  }
  _initQueryEngine(e3) {
    var _a;
    const t6 = this;
    (_a = this.queryEngine) == null ? void 0 : _a.destroy(), this.queryEngine = new Y({ definitionExpression: e3.schema.source.definitionExpression, fields: this.service.fields, geometryType: this.service.geometryType, objectIdField: this.service.objectIdField, hasM: false, hasZ: false, spatialReference: this.spatialReference.toJSON(), cacheSpatialQueries: true, featureStore: this.featureStore, aggregateAdapter: { getFeatureObjectIds(e4) {
      if (t(t6.aggregateStore))
        return [];
      return t6.aggregateStore.getFeatureDisplayIdsForAggregate(e4).map((e5) => t6.getObjectId(e5));
    } }, timeInfo: this.service.timeInfo });
  }
  destroy() {
    this._updateQueue.destroy(), this._source.destroy(), this.queryEngine.destroy(), this.attributeStore && this.attributeStore.destroy();
    for (const e3 of this.tileStore.tiles)
      this._source.unsubscribe(e3);
    clearInterval(this._checkUpdating);
  }
  get fieldsIndex() {
    return new d2(this.service.fields);
  }
  get spatialReference() {
    return this.tileStore.tileScheme.spatialReference;
  }
  get updating() {
    return this.isUpdating();
  }
  isUpdating() {
    const e3 = this._source.updating, t6 = !!this._updateQueue.length, s8 = !this.attributeStore || this.attributeStore.isUpdating(), i4 = e3 || t6 || s8;
    return a("esri-2d-log-updating") && console.log(`Updating FeatureController2D: ${i4}
  -> updatingSource ${e3}
  -> updateQueue ${t6}
  -> updatingAttributeStore ${s8}
`), i4;
  }
  enableEvent(e3) {
    this._source.enableEvent(e3.name, e3.value);
  }
  pause() {
    this._updateQueue.pause(), this._updateQueue.clear();
  }
  resume() {
    this._updateQueue.resume();
  }
  pauseStream() {
    "geoevent" === this._source.type && this._source.pauseStream();
  }
  resumeStream() {
    "geoevent" === this._source.type && this._source.resumeStream();
  }
  _initAggregateStore(e3) {
    var _a, _b;
    const t6 = { geometryInfo: { geometryType: this.service.geometryType, hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields }, r5 = (_b = (_a = e3.schema.targets) == null ? void 0 : _a.aggregate) == null ? void 0 : _b.type, s8 = o(this.config, (e4) => {
      var _a2, _b2;
      return (_b2 = (_a2 = e4.schema.targets) == null ? void 0 : _a2.aggregate) == null ? void 0 : _b2.type;
    });
    if (s8 !== r5 && (r(this.aggregateStore) && (this.handles.remove("valueRangesChanged"), this.aggregateStore.destroy(), this.aggregateStore = null), r5)) {
      switch (r5) {
        case "cluster":
          this.aggregateStore = new w3(t6, this.spatialReference, this._storage, this.service), this.handles.add(this.aggregateStore.events.on("valueRangesChanged", (e4) => {
            this.remoteClient.invoke("emitEvent", { name: "valueRangesChanged", event: { valueRanges: e4.valueRanges } }).catch(x4);
          }), "valueRangesChanged");
          break;
        case "bin":
          this.aggregateStore = new A2(t6, this.spatialReference, this._storage, this.service);
      }
      this.aggregateStore.onTileUpdate({ added: this.tileStore.tiles, removed: [] });
    }
  }
  async update(e3, t6) {
    this._updateVersion++, this._initQueryEngine(t6), this._initAttributeStore(t6), this.pause(), await Promise.all([this._source.update(e3, t6.schema.source), this.featureStore.updateSchema(e3, t6.schema.targets.feature), this.attributeStore.update(e3, t6), this.attributeStore.updateFilters(e3, t6, this)]), this._initAggregateStore(t6), r(this.aggregateStore) && await this.aggregateStore.updateSchema(e3, t6.schema.targets.aggregate), a("esri-2d-update-debug") && e3.describe(), this._set("config", t6);
  }
  async applyUpdate(e3) {
    e3.version = this._updateVersion, a("esri-2d-update-debug") && console.debug(`Applying update ${e3.version}`), e3.mesh && this.clearTiles(), this._updateQueue.resume(), await this._source.applyUpdate(e3), this.notifyChange("updating"), await j2(() => !this.updating), r(this.aggregateStore) && (await L(10), await j2(() => !this.updating));
  }
  async onEdits({ edits: e3 }) {
    a("esri-2d-update-debug") && console.debug("Applying Edit:", e3), this._didEdit = true;
    try {
      const t6 = e3.removed.map((e4) => e4.objectId && -1 !== e4.objectId ? e4.objectId : this._lookupObjectIdByGlobalId(e4.globalId)), r5 = e3.addOrModified.map(({ objectId: e4 }) => e4);
      this.featureStore.invalidate(), await this._source.edit(r5, t6), this.clearTiles(), this.notifyChange("updating"), r(this.aggregateStore) && this.aggregateStore.clear(), await this._source.resend(), await j2(() => !this.updating);
    } catch (t6) {
    }
  }
  async refresh(e3) {
    if (!e3) {
      const e4 = t5.empty();
      return e4.storage.filters = true, this.applyUpdate(e4);
    }
    this.featureStore.invalidate(), this.clearTiles(), this._source.refresh(this._updateVersion), this._cleanupNeeded = true, this.notifyChange("updating"), await j2(() => !this.updating);
  }
  clearTiles() {
    for (const e3 of this.tileStore.tiles)
      this.processor.onTileClear(e3);
  }
  onTileUpdate(e3) {
    r(this.aggregateStore) && this.aggregateStore.onTileUpdate(e3);
    for (const t6 of e3.added)
      this._source.subscribe(t6, this._updateVersion), this._level = t6.level;
    for (const t6 of e3.removed)
      this._source.unsubscribe(t6), this._cleanupNeeded = true, this._tileToResolver.has(t6.id) && (this._tileToResolver.get(t6.id).resolve(), this._tileToResolver.delete(t6.id));
    this.notifyChange("updating");
  }
  async onIdle() {
    this._invalidated && (this._invalidated = false, (r(this.aggregateStore) || "heatmap" === this.processor.type) && await this._repushCurrentLevelTiles()), this._markAndSweep();
  }
  async querySummaryStatistics({ query: e3, params: t6 }) {
    return this.queryEngine.executeQueryForSummaryStatistics(e3, t6);
  }
  async queryUniqueValues({ query: e3, params: t6 }) {
    return this.queryEngine.executeQueryForUniqueValues(e3, t6);
  }
  async queryClassBreaks({ query: e3, params: t6 }) {
    return this.queryEngine.executeQueryForClassBreaks(e3, t6);
  }
  async queryHistogram({ query: e3, params: t6 }) {
    return this.queryEngine.executeQueryForHistogram(e3, t6);
  }
  queryExtent(e3) {
    return this.queryEngine.executeQueryForExtent(e3);
  }
  queryFeatures(e3) {
    return this.queryEngine.executeQuery(e3);
  }
  async queryVisibleFeatures(e3) {
    const t6 = await this.queryEngine.executeQuery(e3), r5 = t6.objectIdFieldName;
    return t6.features = t6.features.filter((e4) => {
      const t7 = e4.attributes[r5], s8 = this.getDisplayId(t7);
      return o(s8, (e5) => this.attributeStore.isVisible(e5));
    }), t6;
  }
  queryFeatureCount(e3) {
    return this.queryEngine.executeQueryForCount(e3);
  }
  queryLatestObservations(e3) {
    return this.queryEngine.executeQueryForLatestObservations(e3);
  }
  queryObjectIds(e3) {
    return this.queryEngine.executeQueryForIds(e3);
  }
  async queryStatistics() {
    return this.featureStore.storeStatistics;
  }
  getObjectId(e3) {
    return this.featureStore.lookupObjectId(e3, this._storage);
  }
  getDisplayId(e3) {
    if (r(this.aggregateStore)) {
      const t6 = this.aggregateStore.getDisplayId(e3);
      if (t(t6)) {
        const t7 = this.featureStore.lookupDisplayId(e3);
        return this.aggregateStore.getDisplayIdForReferenceId(t7);
      }
      return t6;
    }
    return this.featureStore.lookupDisplayId(e3);
  }
  getFeatures(e3) {
    const t6 = [], r5 = [];
    for (const s8 of e3) {
      const e4 = r(this.aggregateStore) ? this.getAggregate(s8) : null;
      if (r(e4))
        if (r(e4.referenceId)) {
          const r6 = this.getFeature(e4.referenceId);
          r(r6) && t6.push(r6);
        } else
          r5.push(e4);
      else {
        const e5 = this.getFeature(s8);
        r(e5) && t6.push(e5);
      }
    }
    return { features: t6, aggregates: r5 };
  }
  getFeature(e3) {
    const t6 = this.featureStore.lookupFeatureByDisplayId(e3, this._storage);
    if (t(t6))
      return null;
    const r5 = t6.readHydratedGeometry(), i4 = ne(r5, t6.geometryType, t6.hasZ, t6.hasM);
    return { attributes: t6.readAttributes(), geometry: i4 };
  }
  getAggregate(e3) {
    return t(this.aggregateStore) ? null : this.aggregateStore.getAggregate(e3);
  }
  getAggregates() {
    return t(this.aggregateStore) ? [] : this.aggregateStore.getAggregates();
  }
  async setHighlight(e3) {
    const t6 = g(e3.map((e4) => this.getDisplayId(e4)));
    return this.attributeStore.setHighlight(e3, t6);
  }
  _lookupObjectIdByGlobalId(e3) {
    const t6 = this.service.globalIdField;
    if (t(t6))
      throw new Error("Expected globalIdField to be defined");
    let r5 = null;
    if (this.featureStore.forEach((s8) => {
      e3 === s8.readAttribute(t6) && (r5 = s8.getObjectId());
    }), t(r5))
      throw new Error(`Expected to find a feature with globalId ${e3}`);
    return r5;
  }
  async _repushCurrentLevelTiles() {
    const e3 = this.tileStore.tiles.filter((e4) => e4.level === this._level).map(async (e4) => this._patchTile({ type: "append", id: e4.key.id, addOrUpdate: d4.fromOptimizedFeatures([], this.service), remove: [], end: true, status: t5.empty() }));
    await Promise.all(e3);
  }
  _maybeForceCleanup() {
    performance.now() - this._lastCleanup > T && this._markAndSweep();
  }
  _patchTile(e3, t6) {
    const r5 = this._updateQueue.push(e3, t6).then(() => {
      this.notifyChange("updating");
    }).catch((e4) => {
      this.notifyChange("updating");
    });
    return this.notifyChange("updating"), r5;
  }
  async _onTileMessage(e3, t6) {
    f2(t6);
    const r5 = this.tileStore.get(e3.id);
    if (!r5)
      return;
    if (e3.clear)
      return this.processor.onTileClear(r5);
    const i4 = e3.status;
    this._cleanupNeeded = true;
    const o8 = [];
    for (const s8 of e3.remove) {
      const e4 = this.featureStore.lookupDisplayId(s8);
      e4 && o8.push(e4);
    }
    e3.remove = o8;
    try {
      if (t(e3.addOrUpdate))
        return void this.processor.onTileMessage(r5, { ...e3, addOrUpdate: null }, r(this.aggregateStore), t6).catch(b);
      if (e3.addOrUpdate.setArcadeSpatialReference(this.spatialReference), this.featureStore.hasInstance(e3.addOrUpdate.instance) && i4.targets.feature || (i4.targets.feature = true, this.featureStore.onTileData(r5, e3)), !i4.storage.data || !i4.storage.filters) {
        i4.storage.data = true, i4.storage.filters = true, this.attributeStore.onTileData(r5, e3);
        "geoevent" === this._source.type || this._didEdit ? (await this.attributeStore.sendUpdates(), f2(t6)) : this.attributeStore.sendUpdates();
      }
      if (r(this.aggregateStore) && !i4.targets.aggregate) {
        i4.targets.aggregate = true;
        const t7 = Q2(this._source) && this._source.loading, s8 = !Q2(this._source) || t7 || e3.end;
        if (this.aggregateStore.onTileData(r5, e3, this._storage, this.attributeStore, s8), !s8)
          return;
        i4.mesh || (this.attributeStore.onTileData(r5, e3), await this.attributeStore.sendUpdates());
      }
      i4.mesh || (i4.mesh = true, await this.processor.onTileMessage(r5, e3, r(this.aggregateStore), t6), f2(t6)), this._maybeForceCleanup();
    } catch (n6) {
      b(n6);
    }
  }
  _mark(e3, t6, r5) {
    const s8 = (4294901760 & this._storage.getInstanceId(e3)) >>> 16;
    e3 && (t6.add(s8), r5.set(e3));
  }
  _markAndSweep() {
    this._lastCleanup = performance.now();
    if (!(!("feature" === this._source.type && "snapshot" === this._source.mode) && ("geoevent" === this._source.type || this._cleanupNeeded)))
      return;
    this._cleanupNeeded = false;
    const e3 = this._storage.getBitset(this._markedIdsBufId), t6 = /* @__PURE__ */ new Set();
    e3.clear();
    for (const r5 of this.tileStore.tiles)
      for (const s8 of this._source.readers(r5.id)) {
        const r6 = s8.getCursor();
        for (; r6.next(); ) {
          let s9 = r6.getDisplayId();
          if (!s9) {
            const e4 = r6.getObjectId();
            s9 = this.featureStore.lookupDisplayId(e4);
          }
          this._mark(s9, t6, e3);
        }
      }
    "symbol" === this.processor.type && this.processor.forEachBufferId((r5) => {
      this._mark(r5, t6, e3);
    }), this._updateQueue.forEach((r5) => {
      for (const s8 of r5.remove) {
        const r6 = this.featureStore.lookupDisplayId(s8);
        this._mark(r6, t6, e3);
      }
    }), r(this.aggregateStore) && (this.aggregateStore.sweepFeatures(e3, this.featureStore), "sweepAggregates" in this.aggregateStore && this.aggregateStore.sweepAggregates(this._storage, this.attributeStore, this._level)), this.featureStore.sweepFeatures(e3, this._storage, this.attributeStore), this.featureStore.sweepFeatureSets(t6);
  }
};
e([d({ constructOnly: true })], O.prototype, "tileStore", void 0), e([d()], O.prototype, "config", void 0), e([d({ readOnly: true })], O.prototype, "fieldsIndex", null), e([d()], O.prototype, "processor", void 0), e([d({ constructOnly: true })], O.prototype, "remoteClient", void 0), e([d({ constructOnly: true })], O.prototype, "service", void 0), e([d()], O.prototype, "spatialReference", null), e([d()], O.prototype, "updating", null), O = e([n("esri.views.2d.layers.features.controllers.FeatureController2D")], O);
var A3 = O;

// node_modules/@arcgis/core/views/2d/layers/features/Pipeline.js
var d8 = class extends d3 {
  constructor() {
    super(...arguments), this.controller = null, this.processor = null, this.remoteClient = null, this.tileStore = null, this.service = null, this.viewState = null, this._paused = false, this._pendingTileUpdates = [];
  }
  initialize() {
    this.handles.add(l(() => this.updating, (e3) => {
      this.remoteClient.invoke("setUpdating", e3).catch((e4) => {
      });
    }));
  }
  destroy() {
    var _a, _b;
    this.stop(), (_a = this.controller) == null ? void 0 : _a.destroy(), (_b = this.processor) == null ? void 0 : _b.destroy(), this.controller = this.processor = this.tileStore = this.remoteClient = null;
  }
  get updating() {
    return !this.controller || this.controller.updating;
  }
  stop() {
    var _a, _b, _c;
    this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e3) => e3.close()), this.service.source.length = 0), (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e3) => e3.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = null, this._pendingTileUpdates.length = 0;
  }
  async startup({ service: e3, config: t6, tileInfo: r5, tiles: s8 }) {
    var _a, _b, _c;
    if (this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e4) => e4.close()), this.service.source.length = 0), this.service = e3, !this.tileStore || !E3(this.tileStore.tileScheme.spatialReference, r5.spatialReference)) {
      const e4 = new h(S.fromJSON(r5));
      s8.added.length = s8.removed.length = 0, (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e5) => e5.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = new l4(e4), this._pendingTileUpdates.length = 0;
    }
    for (await this._createProcessorAndController(t6), await this.update({ config: t6 }), this.controller.resume(), this.tileStore.clear(), this.tileStore.updateTiles(s8), this._paused = false; this._pendingTileUpdates.length; )
      this.tileStore.updateTiles(this._pendingTileUpdates.pop());
  }
  async updateTiles(e3) {
    this._paused ? this._pendingTileUpdates.push(e3) : this.tileStore.updateTiles(e3);
  }
  async update({ config: e3 }) {
    const t6 = t5.empty();
    return await Promise.all([this.processor.update(t6, e3), this.controller.update(t6, e3)]), t6.toJSON();
  }
  async applyUpdate(e3) {
    return this.controller.applyUpdate(t5.create(e3));
  }
  async _createProcessorAndController(e3) {
    await Promise.all([this._handleControllerConfig(e3), this._handleProcessorConfig(e3)]), this.controller.processor = this.processor;
  }
  async _handleControllerConfig(e3) {
    return this._createController(this.service, e3);
  }
  async _handleProcessorConfig(e3) {
    return this._createProcessor(this.service, e3);
  }
  async _createController(e3, t6) {
    this.controller && this.controller.destroy();
    const { tileStore: r5, remoteClient: s8 } = this, o8 = new A3({ service: e3, tileStore: r5, remoteClient: s8 });
    return this.controller = o8, o8;
  }
  async _createProcessor(e3, t6) {
    const r5 = t6.schema.processors[0].type, s8 = (await o4(r5)).default, { remoteClient: o8, tileStore: i4 } = this, l9 = new s8({ service: e3, config: t6, tileStore: i4, remoteClient: o8 });
    return this.processor && this.processor.destroy(), this.processor = l9, l9;
  }
};
e([d()], d8.prototype, "controller", void 0), e([d()], d8.prototype, "processor", void 0), e([d()], d8.prototype, "updating", null), e([d()], d8.prototype, "viewState", void 0), d8 = e([n("esri.views.2d.layers.features.Pipeline")], d8);
var u3 = d8;
export {
  u3 as default
};
//# sourceMappingURL=Pipeline-JZK3BDGV.js.map
