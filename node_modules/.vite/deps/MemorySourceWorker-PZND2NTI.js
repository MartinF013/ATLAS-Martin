import {
  n,
  t as t2
} from "./chunk-AMX572WK.js";
import {
  a as a2,
  f as f2,
  g as g2,
  m,
  w
} from "./chunk-YRLGNAUD.js";
import {
  a,
  l as l2,
  u as u2
} from "./chunk-NCMBCUFA.js";
import {
  u
} from "./chunk-4QVQG5LC.js";
import "./chunk-UQFAHV7T.js";
import {
  Y
} from "./chunk-COK4R22F.js";
import "./chunk-T6XN76GI.js";
import "./chunk-EZ4QR7V3.js";
import "./chunk-25Y2OKSP.js";
import "./chunk-EMETVH63.js";
import "./chunk-V56SVRSV.js";
import {
  f,
  g
} from "./chunk-XZHFGTRH.js";
import "./chunk-2I27THZD.js";
import "./chunk-X64NQ2GK.js";
import "./chunk-NVOCHKIH.js";
import "./chunk-DGELARKE.js";
import "./chunk-WN3KE5M2.js";
import "./chunk-KBCUY3VB.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-CC32E45Q.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import {
  Q,
  W,
  ee
} from "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-CQ47VEUP.js";
import {
  d
} from "./chunk-FU5UMT3R.js";
import "./chunk-F5A4XAOJ.js";
import {
  i
} from "./chunk-JMZLJZMP.js";
import "./chunk-GRILTTJT.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import {
  P
} from "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import {
  l,
  v
} from "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  c
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/graphics/sources/support/MemorySourceWorker.js
var R = c;
var q = { xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: c };
var D = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: false, supportsSqlExpression: true, supportsDisjointSpatialRel: true } };
function O(e) {
  return l(e) ? null != e.z : !!e.hasZ;
}
function w2(e) {
  return l(e) ? null != e.m : !!e.hasM;
}
var S = class {
  constructor() {
    this._queryEngine = null, this._nextObjectId = null;
  }
  destroy() {
    this._queryEngine && this._queryEngine && this._queryEngine.destroy(), this._queryEngine = this._fieldsIndex = this._createDefaultAttributes = null;
  }
  async load(t3) {
    const i2 = [], { features: s2 } = t3, r2 = this._inferLayerProperties(s2, t3.fields), n2 = t3.fields || [], a3 = null != t3.hasM ? t3.hasM : r2.hasM, o = null != t3.hasZ ? t3.hasZ : r2.hasZ, l3 = !t3.spatialReference && !r2.spatialReference, y = l3 ? R : t3.spatialReference || r2.spatialReference, I = l3 ? q : null, b = t3.geometryType || r2.geometryType, F = !b;
    let j = t3.objectIdField || r2.objectIdField, _ = t3.timeInfo;
    if (!F && (l3 && i2.push({ name: "feature-layer:spatial-reference-not-found", message: "Spatial reference not provided or found in features. Defaults to WGS84" }), !b))
      throw new s("feature-layer:missing-property", "geometryType not set and couldn't be inferred from the provided features");
    if (!j)
      throw new s("feature-layer:missing-property", "objectIdField not set and couldn't be found in the provided fields");
    if (r2.objectIdField && j !== r2.objectIdField && (i2.push({ name: "feature-layer:duplicated-oid-field", message: `Provided objectIdField "${j}" doesn't match the field name "${r2.objectIdField}", found in the provided fields` }), j = r2.objectIdField), j && !r2.objectIdField) {
      let e = null;
      n2.some((t4) => t4.name === j && (e = t4, true)) ? (e.type = "esriFieldTypeOID", e.editable = false, e.nullable = false) : n2.unshift({ alias: j, name: j, type: "esriFieldTypeOID", editable: false, nullable: false });
    }
    for (const u3 of n2) {
      if (null == u3.name && (u3.name = u3.alias), null == u3.alias && (u3.alias = u3.name), !u3.name)
        throw new s("feature-layer:invalid-field-name", "field name is missing", { field: u3 });
      if (u3.name === j && (u3.type = "esriFieldTypeOID"), !i.jsonValues.includes(u3.type))
        throw new s("feature-layer:invalid-field-type", `invalid type for field "${u3.name}"`, { field: u3 });
    }
    const O2 = {};
    for (const e of n2)
      if ("esriFieldTypeOID" !== e.type && "esriFieldTypeGlobalID" !== e.type) {
        const t4 = P(e);
        void 0 !== t4 && (O2[e.name] = t4);
      }
    if (this._fieldsIndex = new d(n2), this._createDefaultAttributes = a(O2, j), _) {
      if (_.startTimeField) {
        const e = this._fieldsIndex.get(_.startTimeField);
        e ? (_.startTimeField = e.name, e.type = "esriFieldTypeDate") : _.startTimeField = null;
      }
      if (_.endTimeField) {
        const e = this._fieldsIndex.get(_.endTimeField);
        e ? (_.endTimeField = e.name, e.type = "esriFieldTypeDate") : _.endTimeField = null;
      }
      if (_.trackIdField) {
        const e = this._fieldsIndex.get(_.trackIdField);
        e ? _.trackIdField = e.name : (_.trackIdField = null, i2.push({ name: "feature-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: _ } }));
      }
      _.startTimeField || _.endTimeField || (i2.push({ name: "feature-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing or invalid", details: { timeInfo: _ } }), _ = null);
    }
    const w3 = { warnings: i2, featureErrors: [], layerDefinition: { ...D, drawingInfo: u2(b), templates: l2(O2), extent: I, geometryType: b, objectIdField: j, fields: n2, hasZ: !!o, hasM: !!a3, timeInfo: _ }, assignedObjectIds: {} };
    if (this._queryEngine = new Y({ fields: n2, geometryType: b, hasM: a3, hasZ: o, objectIdField: j, spatialReference: y, featureStore: new u({ geometryType: b, hasM: a3, hasZ: o }), timeInfo: _, cacheSpatialQueries: true }), !s2 || !s2.length)
      return this._nextObjectId = t2, w3;
    const S2 = n(j, s2);
    return this._nextObjectId = S2 + 1, await f(s2, y), this._loadInitialFeatures(w3, s2);
  }
  async applyEdits(e) {
    const { spatialReference: t3, geometryType: i2 } = this._queryEngine;
    return await Promise.all([w(t3, i2), f(e.adds, t3), f(e.updates, t3)]), this._applyEdits(e);
  }
  queryFeatures(e, t3 = {}) {
    return this._queryEngine.executeQuery(e, t3.signal);
  }
  queryFeatureCount(e, t3 = {}) {
    return this._queryEngine.executeQueryForCount(e, t3.signal);
  }
  queryObjectIds(e, t3 = {}) {
    return this._queryEngine.executeQueryForIds(e, t3.signal);
  }
  queryExtent(e, t3 = {}) {
    return this._queryEngine.executeQueryForExtent(e, t3.signal);
  }
  querySnapping(e, t3 = {}) {
    return this._queryEngine.executeQueryForSnapping(e, t3.signal);
  }
  _inferLayerProperties(e, i2) {
    let r2, n2, a3 = null, o = null, l3 = null;
    for (const u3 of e) {
      const e2 = u3.geometry;
      if (!t(e2) && (a3 || (a3 = v(e2)), o || (o = e2.spatialReference), null == r2 && (r2 = O(e2)), null == n2 && (n2 = w2(e2)), a3 && o && null != r2 && null != n2))
        break;
    }
    if (i2 && i2.length) {
      let e2 = null;
      i2.some((t3) => {
        const i3 = "esriFieldTypeOID" === t3.type, s2 = !t3.type && t3.name && "objectid" === t3.name.toLowerCase();
        return e2 = t3, i3 || s2;
      }) && (l3 = e2.name);
    }
    return { geometryType: a3, spatialReference: o, objectIdField: l3, hasM: n2, hasZ: r2 };
  }
  _loadInitialFeatures(e, t3) {
    const { geometryType: r2, hasM: n2, hasZ: o, objectIdField: l3, spatialReference: u3, featureStore: d2 } = this._queryEngine, p = [];
    for (const a3 of t3) {
      if (null != a3.uid && (e.assignedObjectIds[a3.uid] = -1), a3.geometry && r2 !== v(a3.geometry)) {
        e.featureErrors.push(a2("Incorrect geometry type."));
        continue;
      }
      const t4 = this._createDefaultAttributes(), n3 = m(this._fieldsIndex, t4, a3.attributes, true, e.warnings);
      n3 ? e.featureErrors.push(n3) : (this._assignObjectId(t4, a3.attributes, true), a3.attributes = t4, null != a3.uid && (e.assignedObjectIds[a3.uid] = a3.attributes[l3]), r(a3.geometry) && (a3.geometry = g(a3.geometry, a3.geometry.spatialReference, u3)), p.push(a3));
    }
    if (d2.addMany(W([], p, r2, o, n2, l3)), e.layerDefinition.extent = this._queryEngine.fullExtent, e.layerDefinition.timeInfo) {
      const { start: t4, end: i2 } = this._queryEngine.timeExtent;
      e.layerDefinition.timeInfo.timeExtent = [t4, i2];
    }
    return e;
  }
  _applyEdits(e) {
    const { adds: t3, updates: i2, deletes: s2 } = e, r2 = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if (t3 && t3.length && this._applyAddEdits(r2, t3), i2 && i2.length && this._applyUpdateEdits(r2, i2), s2 && s2.length) {
      for (const e2 of s2)
        r2.deleteResults.push(f2(e2));
      this._queryEngine.featureStore.removeManyById(s2);
    }
    return { fullExtent: this._queryEngine.fullExtent, featureEditResults: r2 };
  }
  _applyAddEdits(e, t3) {
    const { addResults: r2 } = e, { geometryType: n2, hasM: o, hasZ: l3, objectIdField: u3, spatialReference: d2, featureStore: p } = this._queryEngine, f3 = [];
    for (const a3 of t3) {
      if (a3.geometry && n2 !== v(a3.geometry)) {
        r2.push(a2("Incorrect geometry type."));
        continue;
      }
      const t4 = this._createDefaultAttributes(), o2 = m(this._fieldsIndex, t4, a3.attributes);
      if (o2)
        r2.push(o2);
      else {
        if (this._assignObjectId(t4, a3.attributes), a3.attributes = t4, null != a3.uid) {
          const t5 = a3.attributes[u3];
          e.uidToObjectId[a3.uid] = t5;
        }
        r(a3.geometry) && (a3.geometry = g(g2(a3.geometry, d2), a3.geometry.spatialReference, d2)), f3.push(a3), r2.push(f2(a3.attributes[u3]));
      }
    }
    p.addMany(W([], f3, n2, l3, o, u3));
  }
  _applyUpdateEdits({ updateResults: e }, t3) {
    const { geometryType: r2, hasM: n2, hasZ: a3, objectIdField: u3, spatialReference: d2, featureStore: p } = this._queryEngine;
    for (const f3 of t3) {
      const { attributes: t4, geometry: c2 } = f3, m2 = t4 && t4[u3];
      if (null == m2) {
        e.push(a2(`Identifier field ${u3} missing`));
        continue;
      }
      if (!p.has(m2)) {
        e.push(a2(`Feature with object id ${m2} missing`));
        continue;
      }
      const h = ee(p.getFeature(m2), r2, a3, n2);
      if (r(c2)) {
        if (r2 !== v(c2)) {
          e.push(a2("Incorrect geometry type."));
          continue;
        }
        h.geometry = g(g2(c2, d2), c2.spatialReference, d2);
      }
      if (t4) {
        const i2 = m(this._fieldsIndex, h.attributes, t4);
        if (i2) {
          e.push(i2);
          continue;
        }
      }
      p.add(Q(h, r2, a3, n2, u3)), e.push(f2(m2));
    }
  }
  _assignObjectId(e, t3, i2 = false) {
    const s2 = this._queryEngine.objectIdField;
    i2 && t3 && isFinite(t3[s2]) ? e[s2] = t3[s2] : e[s2] = this._nextObjectId++;
  }
};
export {
  S as default
};
//# sourceMappingURL=MemorySourceWorker-PZND2NTI.js.map
