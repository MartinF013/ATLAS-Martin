import {
  e as e2,
  o as o2
} from "./chunk-5JKCNCL2.js";
import {
  o
} from "./chunk-2YDCEMEJ.js";
import {
  e
} from "./chunk-4MKQUQD4.js";
import {
  o as o3
} from "./chunk-A3QLZKCF.js";
import {
  n
} from "./chunk-NAB3NF54.js";
import {
  O
} from "./chunk-VMF4NMEB.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js
var l = 8;
function s(s2, u) {
  const c = s2.vertex;
  c.uniforms.add(new o3("intrinsicWidth", (e3) => e3.width)), u.vvSize ? (s2.attributes.add(O.SIZEFEATUREATTRIBUTE, "float"), c.uniforms.add(new e("vvSizeMinSize", (e3) => e3.vvSizeMinSize)), c.uniforms.add(new e("vvSizeMaxSize", (e3) => e3.vvSizeMaxSize)), c.uniforms.add(new e("vvSizeOffset", (e3) => e3.vvSizeOffset)), c.uniforms.add(new e("vvSizeFactor", (e3) => e3.vvSizeFactor)), c.code.add(n`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)) : (s2.attributes.add(O.SIZE, "float"), c.code.add(n`float getSize(){
return intrinsicWidth * size;
}`)), u.vvOpacity ? (s2.attributes.add(O.OPACITYFEATUREATTRIBUTE, "float"), c.constants.add("vvOpacityNumber", "int", 8), c.uniforms.add([new o("vvOpacityValues", (e3) => e3.vvOpacityValues, l), new o("vvOpacityOpacities", (e3) => e3.vvOpacityOpacities, l)]), c.code.add(n`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)) : c.code.add(n`vec4 applyOpacity( vec4 color ){
return color;
}`), u.vvColor ? (s2.attributes.add(O.COLORFEATUREATTRIBUTE, "float"), c.constants.add("vvColorNumber", "int", o2), c.uniforms.add(new o("vvColorValues", (e3) => e3.vvColorValues, o2)), c.uniforms.add(new e2("vvColorColors", (e3) => e3.vvColorColors, o2)), c.code.add(n`vec4 interpolateColor( float value ) {
if (value <= vvColorValues[0]) {
return vvColorColors[0];
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return mix(vvColorColors[i-1], vvColorColors[i], f);
}
}
return vvColorColors[vvColorNumber - 1];
}
vec4 getColor(){
return applyOpacity(interpolateColor(colorFeatureAttribute));
}`)) : (s2.attributes.add(O.COLOR, "vec4"), c.code.add(n`vec4 getColor(){
return applyOpacity(color);
}`));
}

export {
  s
};
//# sourceMappingURL=chunk-ZLORWBMB.js.map
