import {
  E as E2,
  P,
  i as i2,
  l as l4
} from "./chunk-2NTPDKQY.js";
import {
  e as e4
} from "./chunk-KXA3AZ4N.js";
import {
  _,
  l as l3
} from "./chunk-D7PQAHH6.js";
import {
  c as c2,
  r as r2
} from "./chunk-NSEAWM6P.js";
import {
  e as e3
} from "./chunk-XKY65LLM.js";
import {
  a as a2,
  i
} from "./chunk-DSCM4HDL.js";
import {
  s as s3
} from "./chunk-UTJPTN6P.js";
import {
  w as w2
} from "./chunk-GRW2GUB3.js";
import {
  n as n4
} from "./chunk-RBVTRJPJ.js";
import {
  g
} from "./chunk-Z3S5X75I.js";
import {
  An,
  en,
  rn,
  tn
} from "./chunk-PZWU5EHT.js";
import {
  h as h2
} from "./chunk-BS7TS6UC.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  a,
  f,
  j as j2,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import {
  n as n3
} from "./chunk-P6G64ARX.js";
import {
  p
} from "./chunk-RN2KRYDN.js";
import {
  j3,
  y as y2
} from "./chunk-TADZYUVR.js";
import {
  S,
  m as m3
} from "./chunk-5TRUGQDM.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  n as n2
} from "./chunk-OIPX3EDD.js";
import {
  t as t2
} from "./chunk-VLCG72SW.js";
import {
  E
} from "./chunk-3NMRL5CR.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  m as m2,
  y
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  c,
  e as e2,
  h,
  l,
  m,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transformGraphic/isSupportedGraphic.js
function i3(i5) {
  var _a;
  if ("graphics" !== ((_a = i5.layer) == null ? void 0 : _a.type))
    return P.GRAPHICS_LAYER_MISSING;
  if (t(i5.geometry))
    return P.GEOMETRY_MISSING;
  switch (i5.geometry.type) {
    case "point":
      break;
    case "polygon":
    case "polyline":
    case "multipoint":
    case "extent":
    case "mesh":
      return P.SUPPORTED;
    default:
      return P.GEOMETRY_TYPE_UNSUPPORTED;
  }
  const n6 = r(i5.symbol) && "point-3d" === i5.symbol.type && i5.symbol.symbolLayers;
  if (!(n6 && n6.length > 0 && n6.some((e5) => "object" === e5.type)))
    return P.SYMBOL_TYPE_UNSUPPORTED;
  return "on-the-ground" !== i(i5) && a2(i5) ? P.ELEVATION_MODE_UNSUPPORTED : P.SUPPORTED;
}

// node_modules/@arcgis/core/widgets/Sketch/support/OperationHandle.js
var p2 = class extends n2.EventedAccessor {
  constructor(e5) {
    super(e5), this.cancelled = false, this.history = { undo: [], redo: [] }, this.type = null;
  }
  get tool() {
    if (!this.activeComponent)
      return null;
    switch (this.activeComponent.type) {
      case "graphic-mover":
      case "move-3d":
        return "move";
      case "box":
      case "transform-3d":
        return "transform";
      case "reshape":
      case "reshape-3d":
        return "reshape";
      case "draw-2d":
      case "draw-3d":
        return this.activeComponent.geometryType;
      default:
        n3(this.activeComponent);
    }
    return null;
  }
  addToHistory(e5) {
    this.history.redo = [], this.history.undo.push(e5);
  }
  resetHistory() {
    this.history.redo = [], this.history.undo = [];
  }
  canUndo() {
    return this.history.undo.length > 0;
  }
  canRedo() {
    return this.history.redo.length > 0;
  }
  complete() {
    this._reset(), this.onEnd(), this.emit("complete");
  }
  cancel() {
    this.cancelled = true, this.complete();
  }
  _reset() {
    this.activeComponent.reset();
  }
  refreshComponent() {
    const e5 = this.activeComponent;
    e5 && ("box" !== e5.type && "reshape" !== e5.type && "graphic-mover" !== e5.type || e5.refresh());
  }
  set undo(e5) {
    this._set("undo", () => {
      this.canUndo() && e5();
    });
  }
  set redo(e5) {
    this._set("redo", () => {
      this.canRedo() && e5();
    });
  }
};
e([d()], p2.prototype, "activeComponent", void 0), e([d()], p2.prototype, "cancelled", void 0), e([d()], p2.prototype, "history", void 0), e([d()], p2.prototype, "tool", null), e([d()], p2.prototype, "type", void 0), e([d()], p2.prototype, "canUndo", null), e([d()], p2.prototype, "canRedo", null), e([d()], p2.prototype, "onEnd", void 0), e([d()], p2.prototype, "undo", null), e([d()], p2.prototype, "redo", null), e([d()], p2.prototype, "toggleTool", void 0), e([d()], p2.prototype, "addToSelection", void 0), e([d()], p2.prototype, "removeFromSelection", void 0), p2 = e([n("esri.widgets.Sketch.support.OperationHandle")], p2);
var n5 = class extends p2 {
};
e([d()], n5.prototype, "activeComponent", void 0), n5 = e([n("esri.widgets.Sketch.support.CreateOperationHandle")], n5);
var i4 = class extends p2 {
  constructor(e5) {
    super(e5);
  }
};
e([d()], i4.prototype, "activeComponent", void 0), i4 = e([n("esri.widgets.Sketch.support.UpdateOperationHandle")], i4);

// node_modules/@arcgis/core/widgets/Sketch/SketchViewModel.js
var J = "esri.widgets.Sketch.SketchViewModel";
var Q = s.getLogger(J);
var X = { defaultZ: 0 };
var ee = { reshapeOptions: { edgeOperation: "split", shapeOperation: "move", vertexOperation: "move" }, enableMoveAllGraphics: true, enableRotation: true, enableScaling: true, multipleSelectionEnabled: true, preserveAspectRatio: false, toggleToolOnClick: true, enableZ: true, tool: "transform" };
var te = class extends n2.EventedAccessor {
  constructor(e5) {
    super(e5), this._numUpdating = 0, this._handles = new u(), this._internalGraphicsLayer = new h2({ listMode: "hide", internal: true, title: "SVM Internal" }), this._operationHandle = null, this._viewHandles = new u(), this.activeFillSymbol = null, this.activeLineSymbol = null, this.activeVertexSymbol = null, this.allowDeleteKey = true, this.labelOptions = new c2(), this.layer = null, this.pointSymbol = new y2({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this.polygonSymbol = new S({ color: [150, 150, 150, 0.2], outline: { color: [50, 50, 50], width: 2 } }), this.polylineSymbol = new m3({ color: [130, 130, 130, 1], width: 2 }), this._snappingManager = null, this.tooltipOptions = new r2(), this.updateGraphics = new j(), this.updateOnGraphicClick = true, this.updatePointSymbol = new y2({ size: 10, color: [0, 200, 255, 0.5], outline: { color: "black", width: 1 } }), this.updatePolygonSymbol = new S({ color: [12, 207, 255, 0.2], outline: { join: "round", color: [12, 207, 255], width: 2 } }), this.updatePolylineSymbol = new m3({ color: [12, 207, 255], width: 2 }), this.vertexSymbol = new y2({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this._moduleLoaderAbortController = null, this._viewReadyAbortController = null, this._originalAutoOpenEnabled = null, this.defaultCreateOptions = X, this.defaultUpdateOptions = ee, this.snappingOptions = new l3();
  }
  initialize() {
    this._handles.add([a(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.map) == null ? void 0 : _b.layers;
    }, "change", (e5) => {
      e5.removed.includes(this.layer) && this.cancel();
    }), a(() => {
      var _a;
      return (_a = this.layer) == null ? void 0 : _a.graphics;
    }, "change", (e5) => {
      if (r(this._operationHandle))
        for (const t3 of e5.removed)
          this.updateGraphics.includes(t3) && (this.updateGraphics.length > 1 ? this._operationHandle.removeFromSelection(t3) : this._operationHandle.cancel());
    }), l2(() => {
      var _a;
      return ((_a = this.layer) == null ? void 0 : _a.elevationInfo) ?? null;
    }, (e5) => {
      e5 !== this._internalGraphicsLayer.elevationInfo && (this.cancel(), this._internalGraphicsLayer.elevationInfo = e5);
    }, w), l2(() => this.view, (e5) => {
      l(this._snappingManager), e5 && (this._snappingManager = new _({ view: e5, options: this.snappingOptions }), "2d" === e5.type ? import("./editingTools-2PZOMEFY.js") : "3d" === e5.type && (import("./editingTools-QRSMERL7.js"), import("./GraphicsLayerView3D-P4B3GJUP.js")));
    }, w), l2(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.spatialReference;
    }, (e5, t3) => {
      e5 && t3 && !e5.equals(t3) && this.cancel();
    })]);
  }
  destroy() {
    this.cancel(), this._handles = l(this._handles), this._viewHandles = l(this._viewHandles), this._removeDefaultLayer(), this._snappingManager = l(this._snappingManager), this._set("view", null), this.emit("destroy");
  }
  get _defaultUpdateTool() {
    return "3d" === this.view.type ? "move" : "transform";
  }
  get updating() {
    return this._numUpdating > 0;
  }
  get activeTool() {
    return this._operationHandle && this._operationHandle.tool ? this._operationHandle.tool : null;
  }
  get activeComponent() {
    return this._operationHandle ? this._operationHandle.activeComponent : null;
  }
  get createGraphic() {
    return !r(this.activeComponent) || "draw-3d" !== this.activeComponent.type && "draw-2d" !== this.activeComponent.type ? this._get("createGraphic") : e2(this.activeComponent.graphic);
  }
  set defaultCreateOptions(e5) {
    this._set("defaultCreateOptions", { ...X, ...e5 });
  }
  set defaultUpdateOptions(e5) {
    this._set("defaultUpdateOptions", { ...ee, ...e5, reshapeOptions: { ...ee.reshapeOptions, ...e5 == null ? void 0 : e5.reshapeOptions } });
  }
  set snappingOptions(e5) {
    r(this._snappingManager) && (this._snappingManager.options = e5), this._set("snappingOptions", e5);
  }
  get state() {
    var _a;
    const e5 = !(!((_a = this.view) == null ? void 0 : _a.ready) || !this.layer), t3 = this._operationHandle;
    return e5 && t3 ? "active" : e5 ? "ready" : "disabled";
  }
  get view() {
    return this._get("view");
  }
  set view(e5) {
    const t3 = this._get("view");
    if (t3) {
      const { container: e6, map: o2 } = t3;
      e6 && (t3.cursor = null), o2 && o2.remove(this._internalGraphicsLayer), this._viewHandles.removeAll(), this.cancel();
    }
    const o = "view-ready";
    this._handles.remove(o), e5 && this._handles.add(f(() => e5.ready, (t4) => {
      this._viewHandles.removeAll(), t4 && this._viewHandles.add(this._generateViewHandles(e5));
    }, w), o), this._set("view", e5);
  }
  cancel() {
    this._moduleLoaderAbortController = h(this._moduleLoaderAbortController), this._viewReadyAbortController = h(this._viewReadyAbortController), this._operationHandle && this._operationHandle.cancel();
  }
  complete() {
    this._operationHandle && this._operationHandle.complete();
  }
  delete() {
    const { state: e5, updateGraphics: t3 } = this;
    if ("active" === e5 && t3.length) {
      const { activeTool: e6, layer: o } = this, i5 = t3.toArray();
      o.removeMany(i5), this.cancel(), this._emitDeleteEvent({ graphics: i5, tool: e6 });
    }
  }
  async create(e5, t3) {
    if (this.cancel(), await this._waitViewReady(), "disabled" === this.state)
      throw this.layer || this._logError("sketch:missing-property", "Property 'layer' is missing on SketchViewModel."), this.view || this._logError("sketch:missing-property", "Property 'view' is missing on SketchViewModel."), m2();
    if (r(this.view.activeTool) && (this.view.activeTool = null), !e5)
      return void this._logError("sketch:missing-parameter", "Missing parameter 'tool'.");
    e4(this.view, this._internalGraphicsLayer);
    const o = await this._setupCreateOperation(e5, t3);
    if (t(o) || this.destroyed)
      return void this.view.map.remove(this._internalGraphicsLayer);
    const i5 = () => {
      if (o === this._operationHandle) {
        const t4 = this.createGraphic, i6 = this._operationHandle.cancelled;
        this._operationHandle.destroy(), this._operationHandle = null, this._set("createGraphic", null), this.view && this.view.map && this.view.map.remove(this._internalGraphicsLayer), o.cancelled || null == t4 || this.layer.add(t4), this.emit("create", { graphic: t4, state: i6 ? "cancel" : "complete", tool: e5, toolEventInfo: null, type: "create" });
      }
    };
    o.on("complete", i5), this._operationHandle = o, this.view.ready && w2(this.view) && this.view.focus();
  }
  async update(e5, t3) {
    this.cancel(), await this._waitViewReady();
    const { layer: o, view: i5, state: a3 } = this;
    if ("disabled" === a3)
      throw i5 || this._logError("sketch:missing-property", "Property 'view' is missing on SketchViewModel."), o || this._logError("sketch:missing-property", "Property 'layer' is missing on SketchViewModel."), m2();
    r(this.view.activeTool) && (this.view.activeTool = null);
    const r3 = Array.isArray(e5) ? e5 : [e5];
    if (null == e5 || !r3 || !r3.length)
      return void this._logError("sketch:missing-parameter", "Missing parameter 'graphics'.");
    if (r3.some((e6) => e6.layer !== o ? (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics missing from the supplied GraphicsLayer."), true) : !!t(e6.geometry) && (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics with an unsupported geometry."), true)))
      return;
    const s4 = await this._setupUpdateOperation(r3, t3);
    this.destroyed || t(s4) || ne(s4) || (e4(this.view, this._internalGraphicsLayer), this._setUpdateOperationHandle(s4, t3), this.emit("update", { graphics: r3, state: "start", aborted: false, tool: s4.tool, toolEventInfo: null, type: "update" }));
  }
  async _updateSpatialReference(e5) {
    this._beginAsyncOperation(), e5 = Array.isArray(e5) ? e5 : [e5];
    for (const t3 of e5)
      r(t3.geometry) && "mesh" !== t3.geometry.type && !E(t3.geometry.spatialReference, this.view.spatialReference) && (An(t3.geometry.spatialReference, this.view.spatialReference) || en() || await tn(), t3.geometry = rn(t3.geometry, this.view.spatialReference));
    this._endAsyncOperation();
  }
  undo() {
    this.canUndo() && this._operationHandle.undo();
  }
  redo() {
    this.canRedo() && this._operationHandle.redo();
  }
  canUndo() {
    return !(!this._operationHandle || !this._operationHandle.canUndo());
  }
  canRedo() {
    return !(!this._operationHandle || !this._operationHandle.canRedo());
  }
  toggleUpdateTool() {
    this._operationHandle && this._operationHandle.toggleTool && this._operationHandle.toggleTool();
  }
  async _getFirstHit(e5) {
    const t3 = this.view;
    if ("2d" === t3.type) {
      const t4 = [];
      this.view.map.allLayers.forEach((e6) => {
        "vector-tile" !== e6.type && "imagery" !== e6.type || t4.push(e6);
      });
      const o2 = await this.view.hitTest(e5, { exclude: t4 });
      return s3(o2.results);
    }
    const o = [this.view.map.ground];
    t3.map.allLayers.forEach((e6) => {
      "integrated-mesh" === e6.type && o.push(e6);
    });
    const i5 = await t3.hitTest(e5, { exclude: o });
    if (i5.results.length > 0) {
      const e6 = i5.results[0];
      if (r(e6) && "graphic" === e6.type && e6.graphic && (!i5.ground.mapPoint || t3.map.ground.opacity < 1 || i5.ground.distance - c(e6.distance, 0) > -Math.min(3 * i5.ground.distance, "global" === t3.viewingMode ? p(t3.renderCoordsHelper.spatialReference).radius / t3.renderCoordsHelper.unitInMeters : Number.POSITIVE_INFINITY)))
        return e6;
    }
    return null;
  }
  _generateViewHandles(e5) {
    return [e5.on("immediate-click", async (t3) => {
      const o = "active" === this.state && "create" === this._operationHandle.type;
      if ("disabled" === this.state || o || !this.updateOnGraphicClick)
        return;
      this._beginAsyncOperation();
      const i5 = await t3.async(() => this._getFirstHit(n4(t3)));
      let a3 = null;
      if (r(i5)) {
        const o2 = i5.graphic;
        this.updateGraphics.includes(o2) || o2.layer === this.layer ? (t3.stopPropagation(), a3 = o2) : "2d" !== e5.type || this._isComponentGraphic(o2) || "active" !== this.state || this.cancel();
      } else
        "active" === this.state && this.cancel();
      r(a3) && !this.updateGraphics.includes(a3) && await this.update([a3], { ...this.defaultUpdateOptions, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions } }), this._endAsyncOperation();
    }, g.WIDGET)];
  }
  async _setupCreateOperation(e5, t3) {
    const o = { hasZ: "3d" === this.view.type, ...this.defaultCreateOptions, ...t3 }, i5 = await this._setupDrawGraphicTool(e5, this.view, o);
    return t(i5) ? null : (this.view.tools.add(i5), this.view.activeTool = i5, this._setupCreateOperationHandle(i5));
  }
  async _setupDrawGraphicTool(e5, t3, o) {
    if ("multipoint" === e5 && "3d" === t3.type)
      return this._logError("sketch:create", "Multipoint geometries are not supported in SceneView."), null;
    const i5 = "rectangle" !== e5, a3 = "rectangle" !== e5;
    this.snappingOptions.enabledToggled = false;
    const r3 = { view: t3, mode: "rectangle" === e5 || "circle" === e5 ? "hybrid" : "click", ...o, snapToScene: false, geometryType: e5, graphicSymbol: this._getGraphicSymbolFromTool(e5), snappingManager: this._snappingManager, forceUniformSize: a3, centered: i5 };
    return "2d" === this.view.type ? this._makeDrawGraphicTool2D(r3) : this._makeDrawGraphicTool3D(r3);
  }
  async _makeDrawGraphicTool2D(e5) {
    const t3 = await this._requireModule(import("./editingTools-2PZOMEFY.js"));
    return ne(t3) || this.destroyed ? null : new t3.module.DrawGraphicTool2D({ ...e5, activeVertexSymbol: this.activeVertexSymbol, regularVerticesSymbol: this.vertexSymbol, activeLineSymbol: this.activeLineSymbol, activeFillSymbol: oe(e5.geometryType) ? this.activeFillSymbol : null });
  }
  async _makeDrawGraphicTool3D(e5) {
    const t3 = await this._requireModule(import("./editingTools-QRSMERL7.js"));
    if (ne(t3) || this.destroyed)
      return null;
    const { elevationInfo: o } = this.layer;
    return new t3.module.DrawGraphicTool3D({ ...e5, elevationInfo: o, snapToScene: !r(o) || "absolute-height" === o.mode, labelOptions: this.labelOptions, tooltipOptions: this.tooltipOptions });
  }
  _setupCreateOperationHandle(e5) {
    let t3 = null;
    const o = e5.forceUniformSize, i5 = e5.centered, a3 = [this.view.on("key-down", (t4) => {
      if (t4.key === e3.pan)
        t4.stopPropagation(), t4.repeat || (e5.enabled = false);
      else if (t4.key === e3.complete)
        t4.stopPropagation(), e5.completeCreateOperation();
      else if (t4.key !== e3.vertexAdd || t4.repeat)
        t4.key === e3.undo ? (t4.stopPropagation(), r3.undo()) : t4.key === e3.redo ? (t4.stopPropagation(), r3.redo()) : t4.key !== e3.snappingToggle || "rectangle" === e5.geometryType || "circle" === e5.geometryType || t4.repeat ? t4.key !== e3.constraint || "rectangle" !== e5.geometryType && "circle" !== e5.geometryType || t4.repeat ? t4.key === e3.center && (t4.repeat || (e5.centered = !i5, t4.stopPropagation())) : (e5.forceUniformSize = !o, t4.stopPropagation()) : (this.snappingOptions.enabledToggled = true, t4.stopPropagation());
      else {
        const o2 = e5.drawOperation.geometryType;
        "polyline" !== o2 && "polygon" !== o2 && "multipoint" !== o2 || (t4.stopPropagation(), e5.drawOperation.commitStagedVertex());
      }
    }, g.WIDGET), this.view.on("key-up", (t4) => {
      t4.key === e3.pan ? e5.enabled = true : t4.key === e3.snappingToggle && "rectangle" !== e5.geometryType && "circle" !== e5.geometryType ? (this.snappingOptions.enabledToggled = false, t4.stopPropagation()) : t4.key !== e3.constraint || "rectangle" !== e5.geometryType && "circle" !== e5.geometryType ? t4.key === e3.center && (e5.centered = i5, t4.stopPropagation()) : (e5.forceUniformSize = o, t4.stopPropagation());
    }, g.WIDGET), e5.on("vertex-add", (o2) => {
      switch (t3 = t(t3) ? "start" : "active", o2.operation) {
        case "apply":
          this.emit("create", { graphic: e2(e5.graphic), state: t3, tool: this.activeTool, toolEventInfo: o2, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e2(e5.graphic)], tool: e5.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e2(e5.graphic)], tool: e5.geometryType });
      }
    }), e5.on("cursor-update", (t4) => {
      e5.drawOperation.numCommittedVertices > 0 && this.emit("create", { graphic: e2(e5.graphic), state: "active", tool: this.activeTool, toolEventInfo: { coordinates: t4.vertices[0].coordinates, type: "cursor-update" }, type: "create" });
    }), e5.on("vertex-remove", (t4) => {
      switch (t4.operation) {
        case "apply":
          this.emit("create", { graphic: e2(e5.graphic), state: "active", tool: this.activeTool, toolEventInfo: t4, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e2(e5.graphic)], tool: e5.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e2(e5.graphic)], tool: e5.geometryType });
      }
    }), e5.on("complete", (e6) => {
      this._set("createGraphic", e2(e6.graphic)), t3 = "complete", e6.aborted ? r3 && r3.cancel() : r3 && r3.complete();
    }), l2(() => this._getGraphicSymbolFromTool(e5.geometryType), (t4) => {
      e5.graphicSymbol = t4;
    })], r3 = new p2({ activeComponent: e5, tool: e5.geometryType, type: "create", onEnd: () => {
      var _a;
      a3.forEach((e6) => e6.remove()), a3.length = 0, (_a = this.view.tools) == null ? void 0 : _a.remove(e5);
    }, undo: () => {
      e5.canUndo && e5.undo();
    }, redo: () => {
      e5.canRedo && e5.redo();
    }, canUndo: () => e5.canUndo, canRedo: () => e5.canRedo });
    return r3;
  }
  _getGraphicSymbolFromTool(e5) {
    switch (e5) {
      case "point":
      case "multipoint":
        return this.pointSymbol;
      case "polyline":
        return this.polylineSymbol;
      case "circle":
      case "rectangle":
      case "polygon":
        return this.polygonSymbol;
      default:
        return null;
    }
  }
  async _setupUpdateOperation(e5, t3) {
    const { layer: o, view: i5 } = this, a3 = { tool: this._defaultUpdateTool, ...this.defaultUpdateOptions, ...t3, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions, ...t3 == null ? void 0 : t3.reshapeOptions } };
    let r3 = a3.tool;
    for (const s4 of e5)
      o.remove(s4), o.add(s4);
    if ("3d" === i5.type) {
      if (0 === e5.length)
        return null;
      switch (r3) {
        case "move":
          return this._setupMove3DOperation(e5, a3, i5, r3);
        case "reshape": {
          if (e5.length > 1)
            return this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null;
          const t4 = l4(e5[0]);
          return t4 === P.SUPPORTED ? this._setupReshape3DOperation(e5[0], a3, i5) : (this._logError("sketch:reshape", `Reshape operation not supported for provided graphic(s) (${E2(t4)}).`), null);
        }
        case "transform":
          return this._setupGraphicTransform3DOperation(e5, a3, i5);
      }
    }
    switch (r3) {
      case "move":
        return this._setupMove2DOperation(e5, a3, i5);
      case "reshape": {
        if (e5.length > 1)
          return this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null;
        const t4 = l4(e5[0]);
        return t4 === P.SUPPORTED ? this._setupTransformOrReshape2DOperation(e5, r3, a3, i5) : (this._logError("sketch:reshape", `Reshape operation not supported for provided graphic(s) (${E2(t4)}).`), null);
      }
      case "transform":
        if (1 === e5.length) {
          const t4 = m(e5[0].geometry, "type");
          "point" !== t4 && "multipoint" !== t4 || (r3 = "reshape");
        }
        return this._setupTransformOrReshape2DOperation(e5, r3, a3, i5);
    }
  }
  async _setupMove3DOperation(e5, t3, o, i5, a3 = false) {
    for (const l5 of e5) {
      const e6 = i2(l5);
      if (e6 !== P.SUPPORTED)
        return this._logError("sketch:move", `Move operation not supported for provided graphic(s) (${E2(e6)}).`), null;
    }
    const r3 = await this._requireModule(import("./editingTools-QRSMERL7.js"));
    if (ne(r3))
      return r3;
    const s4 = new r3.module.GraphicMoveTool({ view: o, enableZ: t3.enableZ, snappingManager: this._snappingManager, tooltipOptions: this.tooltipOptions });
    this.view.tools.add(s4), s4.graphics.addMany(e5), a3 || this.updateGraphics.addMany(e5);
    const n6 = [], p3 = new i4({ activeComponent: s4, tool: i5, type: "update", onEnd: () => {
      var _a;
      n6.forEach((e6) => e6.remove()), n6.length = 0, (_a = this.view.tools) == null ? void 0 : _a.remove(s4), s4.destroyed || s4.destroy();
    }, undo: () => {
      ie(p3, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 });
    }, redo: () => {
      ae(p3, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 });
    }, addToSelection: (e6) => {
      this.updateGraphics.push(e6), s4.graphics.push(e6), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e6], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e6) => {
      const t4 = this.updateGraphics.indexOf(e6);
      p3.history.undo.forEach((e7) => e7.updates.splice(t4, 1)), p3.history.redo.forEach((e7) => e7.updates.splice(t4, 1)), this.updateGraphics.remove(e6), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e6], type: "selection-change" }, type: "update" }), 0 !== this.updateGraphics.length ? s4.graphics.remove(e6) : p3.complete();
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t3.toggleToolOnClick)
        return;
      if ("transform" !== i5)
        return;
      const e6 = this.updateGraphics.getItemAt(0);
      if (l4(e6) !== P.SUPPORTED)
        return;
      const a4 = await this._setupReshape3DOperation(e6, t3, o, true);
      ne(a4) || (p3.onEnd(), p3.destroy(), this._setUpdateOperationHandle(a4, t3));
    } });
    return n6.push(...this._getHandlesForComponent(p3, t3), this.view.on("immediate-click", (e6) => this._getCommonUpdateOperationClickHandlers(p3, e6, t3), g.WIDGET), o.on("key-down", (e6) => {
      this._getCommonUpdateOperationKeyDownHandlers(p3, e6), e6.key === e3.snappingToggle && (this.snappingOptions.enabledToggled = true, e6.stopPropagation());
    }, g.WIDGET), o.on("key-up", (e6) => {
      e6.key === e3.snappingToggle && (this.snappingOptions.enabledToggled = false, e6.stopPropagation());
    }, g.WIDGET)), p3;
  }
  _setupGraphicTransform3DOperation(e5, t3, o, i5 = false) {
    if (1 === e5.length && i3(e5[0]) === P.SUPPORTED) {
      const a3 = e5[0], r3 = a3.geometry;
      if (r(r3) && ("point" === r3.type || "mesh" === r3.type))
        return this._setupPointTransform3DOperation(a3, t3, o);
      if (r(r3) && ("polygon" === r3.type || "polyline" === r3.type))
        return this._setupPolyTransform3DOperation(a3, t3, o, i5);
    }
    return this._setupMove3DOperation(e5, t3, o, "transform", i5);
  }
  async _setupPointTransform3DOperation(e5, t3, o) {
    const i5 = "transform", { enableRotation: a3, enableScaling: r3, enableZ: s4 } = t3, n6 = await this._requireModule(import("./editingTools-QRSMERL7.js"));
    if (ne(n6))
      return n6;
    const p3 = new n6.module.GraphicTransformTool({ graphic: e5, view: o, enableRotation: a3, enableScaling: r3, enableZ: s4, snappingManager: this._snappingManager, tooltipOptions: this.tooltipOptions });
    this.view.tools.add(p3), this.updateGraphics.add(e5);
    const l5 = [], h3 = new i4({ activeComponent: p3, tool: i5, type: "update", onEnd: () => {
      var _a;
      l5.forEach((e6) => e6.remove()), l5.length = 0, (_a = this.view.tools) == null ? void 0 : _a.remove(p3), p3.destroyed || p3.destroy();
    }, undo: () => {
      ie(h3, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 });
    }, redo: () => {
      ae(h3, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 });
    }, addToSelection: async (e6) => {
      this.updateGraphics.add(e6), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e6], removed: [], type: "selection-change" }, type: "update" });
      const i6 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t3, o, "transform", true);
      ne(i6) || (h3.onEnd(), h3.destroy(), this._setUpdateOperationHandle(i6, t3));
    }, removeFromSelection: (e6) => {
      this.updateGraphics.remove(e6), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e6], type: "selection-change" }, type: "update" }), h3.complete();
    }, toggleTool: () => {
    } });
    return l5.push(...this._getHandlesForComponent(h3, t3), this.view.on("immediate-click", (e6) => this._getCommonUpdateOperationClickHandlers(h3, e6, t3), g.WIDGET), o.on("key-down", (e6) => {
      this._getCommonUpdateOperationKeyDownHandlers(h3, e6), e6.key === e3.snappingToggle && (this.snappingOptions.enabledToggled = true, e6.stopPropagation());
    }, g.WIDGET), o.on("key-up", (e6) => {
      e6.key === e3.snappingToggle && (this.snappingOptions.enabledToggled = false, e6.stopPropagation());
    }, g.WIDGET)), h3;
  }
  async _setupPolyTransform3DOperation(e5, t3, o, i5 = false) {
    const a3 = "transform", { enableRotation: r3, enableScaling: s4, enableZ: n6, preserveAspectRatio: p3 } = t3, l5 = await this._requireModule(import("./editingTools-QRSMERL7.js"));
    if (ne(l5))
      return l5;
    const h3 = new l5.module.ExtentTransformTool({ graphic: e5, view: o, enableRotation: r3, enableScaling: s4, enableZ: n6, preserveAspectRatio: p3, tooltipOptions: this.tooltipOptions });
    this.view.tools.add(h3), i5 || this.updateGraphics.add(e5);
    const c3 = [], d2 = new i4({ activeComponent: h3, tool: a3, type: "update", onEnd: () => {
      var _a;
      c3.forEach((e6) => e6.remove()), c3.length = 0, (_a = this.view.tools) == null ? void 0 : _a.remove(h3), h3.destroyed || h3.destroy();
    }, canUndo: () => h3.canUndo, undo: () => {
      h3.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: a3 });
    }, canRedo: () => h3.canRedo, redo: () => {
      h3.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: a3 });
    }, addToSelection: async (e6) => {
      this.updateGraphics.add(e6), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e6], removed: [], type: "selection-change" }, type: "update" });
      const i6 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t3, o, "transform", true);
      ne(i6) || (d2.onEnd(), d2.destroy(), this._setUpdateOperationHandle(i6, t3));
    }, removeFromSelection: (e6) => {
      this.updateGraphics.remove(e6), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e6], type: "selection-change" }, type: "update" }), d2.complete();
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t3.toggleToolOnClick)
        return;
      const e6 = this.updateGraphics.getItemAt(0);
      if (l4(e6) !== P.SUPPORTED)
        return;
      const i6 = await this._setupReshape3DOperation(e6, t3, o, true);
      ne(i6) || (d2.onEnd(), d2.destroy(), this._setUpdateOperationHandle(i6, t3));
    } });
    return c3.push(...this._getHandlesForComponent(d2, t3), this.view.on("immediate-click", (e6) => this._getCommonUpdateOperationClickHandlers(d2, e6, t3), g.WIDGET), this.view.on("key-down", (e6) => this._getCommonUpdateOperationKeyDownHandlers(d2, e6), g.WIDGET), this.view.on("key-down", (e6) => {
      e6.key !== e3.constraint || e6.repeat || (h3.preserveAspectRatio = !h3.preserveAspectRatio, e6.stopPropagation());
    }, g.WIDGET), this.view.on("key-up", (e6) => {
      e6.key === e3.constraint && (h3.preserveAspectRatio = !h3.preserveAspectRatio, e6.stopPropagation());
    }, g.WIDGET)), d2;
  }
  async _setupMove2DOperation(e5, t3, o) {
    const i5 = "move";
    this.updateGraphics.addMany(e5), await this._updateSpatialReference(e5);
    const a3 = await this._getGraphicMover(e5, t3, o);
    if (ne(a3))
      return a3;
    const r3 = new i4({ activeComponent: a3, tool: i5, type: "update", onEnd: () => {
      var _a;
      this._displayDefaultCursor(), p3.forEach((e6) => e6.remove()), n6.forEach((e6) => e6.remove()), p3 = [], n6 = [], a3.destroy(), (_a = this._internalGraphicsLayer) == null ? void 0 : _a.removeMany([...this.updateGraphics.toArray()]);
    }, undo: () => {
      const e6 = this.updateGraphics.toArray();
      ie(r3, e6), r3.refreshComponent(), this._emitUndoEvent({ graphics: e6, tool: i5 });
    }, redo: () => {
      const e6 = this.updateGraphics.toArray();
      ae(r3, e6), r3.refreshComponent(), this._emitRedoEvent({ graphics: e6, tool: i5 });
    }, addToSelection: async (e6) => {
      await this._updateSpatialReference(e6), this.updateGraphics.push(e6), a3.graphics = this.updateGraphics.toArray(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e6], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e6) => {
      const t4 = this.updateGraphics.indexOf(e6);
      r3.history.undo.forEach((e7) => e7.updates.splice(t4, 1)), r3.history.redo.forEach((e7) => e7.updates.splice(t4, 1)), this.updateGraphics.remove(e6);
      const o2 = this.updateGraphics.toArray();
      this.emit("update", { graphics: o2, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e6], type: "selection-change" }, type: "update" }), 0 !== this.updateGraphics.length ? a3.graphics = o2 : r3.complete();
    } });
    let s4 = false, n6 = [o.on("immediate-click", (e6) => this._getCommonUpdateOperationClickHandlers(r3, e6, t3), g.WIDGET), o.on("key-down", (e6) => {
      this._getCommonUpdateOperationKeyDownHandlers(r3, e6), e6.key !== e3.constraint || e6.repeat || (s4 = true, a3.enableMoveAllGraphics = !a3.enableMoveAllGraphics);
    }, g.WIDGET), o.on("key-up", (e6) => {
      e6.key === e3.constraint && s4 && (s4 = false, a3.enableMoveAllGraphics = !a3.enableMoveAllGraphics);
    }, g.WIDGET)], p3 = this._getHandlesForComponent(r3, t3);
    return r3;
  }
  async _setupReshape3DOperation(e5, t3, o, i5 = false) {
    const a3 = "reshape", r3 = await this._requireModule(import("./editingTools-QRSMERL7.js"));
    if (ne(r3))
      return r3;
    this.snappingOptions.enabledToggled = false;
    const s4 = new r3.module.GraphicReshapeTool({ view: o, graphic: e5, enableZVertex: t3.enableZ && "move" === t3.reshapeOptions.vertexOperation, enableZShape: t3.enableZ && "move" === t3.reshapeOptions.shapeOperation, enableMoveGraphic: "move" === t3.reshapeOptions.shapeOperation || "move-xy" === t3.reshapeOptions.shapeOperation, enableMidpoints: "split" === t3.reshapeOptions.edgeOperation, enableEdgeOffset: "offset" === t3.reshapeOptions.edgeOperation, snappingManager: this._snappingManager, labelOptions: this.labelOptions, tooltipOptions: this.tooltipOptions });
    o.tools.add(s4), i5 || this.updateGraphics.add(e5);
    const n6 = [], p3 = new i4({ activeComponent: s4, tool: a3, type: "update", onEnd: () => {
      var _a;
      n6.forEach((e6) => e6.remove()), n6.length = 0, (_a = this.view.tools) == null ? void 0 : _a.remove(s4), s4.destroyed || s4.destroy();
    }, canUndo: () => s4.canUndo, undo: () => {
      s4.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: a3 });
    }, canRedo: () => s4.canRedo, redo: () => {
      s4.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: a3 });
    }, addToSelection: async (e6) => {
      this.updateGraphics.add(e6), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e6], removed: [], type: "selection-change" }, type: "update" });
      const i6 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t3, o, "transform", true);
      ne(i6) || (p3.onEnd(), p3.destroy(), this._setUpdateOperationHandle(i6, t3));
    }, removeFromSelection: (e6) => {
      this.updateGraphics.remove(e6), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e6], type: "selection-change" }, type: "update" }), p3.complete();
    }, toggleTool: async () => {
      if (false === t3.toggleToolOnClick)
        return;
      const e6 = await this._setupGraphicTransform3DOperation(this.updateGraphics.toArray(), t3, o, true);
      ne(e6) || (p3.onEnd(), p3.destroy(), this._setUpdateOperationHandle(e6, t3));
    } });
    return n6.push(...this._getHandlesForComponent(p3, t3), o.on("immediate-click", (e6) => this._getCommonUpdateOperationClickHandlers(p3, e6, t3), g.WIDGET), o.on("key-down", (e6) => {
      this._getCommonUpdateOperationKeyDownHandlers(p3, e6), e6.key === e3.snappingToggle && (this.snappingOptions.enabledToggled = true, e6.stopPropagation());
    }, g.WIDGET), o.on("key-up", (e6) => {
      e6.key === e3.snappingToggle && (this.snappingOptions.enabledToggled = false, e6.stopPropagation());
    }, g.WIDGET)), p3;
  }
  async _setupTransformOrReshape2DOperation(e5, t3, o, i5) {
    this.updateGraphics.addMany(e5), await this._updateSpatialReference(e5);
    const a3 = "transform" === t3 ? await this._getBox(e5, o, i5) : await this._getReshape(e5, o, i5);
    if (ne(a3))
      return a3;
    const r3 = new i4({ activeComponent: a3, type: "update", onEnd: () => {
      n6.forEach((e6) => e6.remove()), s4.forEach((e6) => e6.remove()), n6 = [], s4 = [], r3.activeComponent && !r3.activeComponent.destroyed && r3.activeComponent.destroy(), this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray());
    }, undo: () => {
      ie(r3, this.updateGraphics.toArray()), r3.refreshComponent(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: r3.tool });
    }, redo: () => {
      ae(r3, this.updateGraphics.toArray()), r3.refreshComponent(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: r3.tool });
    }, addToSelection: async (e6) => {
      let t4 = r3.activeComponent;
      if ("reshape" === t4.type) {
        const t5 = [...this.updateGraphics, e6];
        this.updateGraphics.removeAll();
        const a4 = await this._setupMove2DOperation(t5, o, i5);
        if (ne(a4))
          return;
        r3.onEnd(), r3.destroy(), this._setUpdateOperationHandle(a4, o);
      } else
        this.updateGraphics.add(e6), t4.graphics = this.updateGraphics.toArray(), t4.refresh(), r3.resetHistory();
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e6], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: async (e6) => {
      const t4 = this.updateGraphics.indexOf(e6);
      r3.history.undo.forEach((e7) => e7.updates.splice(t4, 1)), r3.history.redo.forEach((e7) => e7.updates.splice(t4, 1)), this.updateGraphics.remove(e6);
      const o2 = this.updateGraphics.toArray();
      if (0 === o2.length)
        r3.complete();
      else {
        const e7 = o2[0].geometry;
        1 !== o2.length || !r(e7) || "point" !== e7.type && "multipoint" !== e7.type ? r3.activeComponent.graphics = o2 : r3.toggleTool();
      }
      this.emit("update", { graphics: o2, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e6], type: "selection-change" }, type: "update" });
    }, toggleTool: async () => {
      if (this.updateGraphics.length > 1)
        return;
      const e6 = this.updateGraphics.getItemAt(0), t4 = e6.geometry;
      if (r(t4) && ("reshape" === r3.tool && ("point" === t4.type || "multipoint" === t4.type) || "transform" === r3.tool && "extent" === t4.type))
        return;
      let a4 = null;
      "transform" === r3.tool ? a4 = await this._getReshape([e6], o, i5) : "reshape" === r3.tool && (a4 = await this._getBox([e6], o, i5)), ne(a4) || (r3.activeComponent.destroy(), r3.activeComponent = a4, r3.activeComponent && (n6.forEach((e7) => e7.remove()), n6 = this._getHandlesForComponent(r3, o)));
    } });
    let s4 = [i5.on("immediate-click", (e6) => this._getCommonUpdateOperationClickHandlers(r3, e6, o), g.WIDGET), i5.on("key-down", (e6) => {
      if (this._getCommonUpdateOperationKeyDownHandlers(r3, e6), e6.key !== e3.snappingToggle || e6.repeat || (this.snappingOptions.enabledToggled = true, e6.stopPropagation()), e6.key === e3.constraint && !e6.repeat && r3) {
        const e7 = r3.activeComponent;
        e7 && "box" === e7.type && (e7.preserveAspectRatio = !e7.preserveAspectRatio);
      }
    }, g.WIDGET), i5.on("key-up", (e6) => {
      var _a;
      if (e6.key === e3.snappingToggle && "reshape" === ((_a = r3 == null ? void 0 : r3.activeComponent) == null ? void 0 : _a.type) && (this.snappingOptions.enabledToggled = false, e6.stopPropagation()), e6.key === e3.constraint && r3) {
        const e7 = r3.activeComponent;
        e7 && "box" === e7.type && (e7.preserveAspectRatio = !e7.preserveAspectRatio);
      }
    }, g.WIDGET)], n6 = this._getHandlesForComponent(r3, o);
    return r3;
  }
  async _getGraphicMover(e5, t3, o) {
    const { enableMoveAllGraphics: i5 } = t3, a3 = await this._requireModule(import("./GraphicMover-7RW6UIAN.js"));
    return ne(a3) ? a3 : new a3.module.default({ enableMoveAllGraphics: i5, highlightsEnabled: true, indicatorsEnabled: false, graphics: e5, view: o, callbacks: { onGraphicMoveStart: ({ dx: e6, dy: t4, graphic: o2 }) => {
      this._displayGrabbingCursor(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e6, dy: t4, mover: o2, type: "move-start" }, type: "update" });
    }, onGraphicMove: ({ dx: e6, dy: t4, graphic: o2 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e6, dy: t4, mover: o2, type: "move" }, type: "update" }), onGraphicMoveStop: ({ dx: e6, dy: t4, graphic: o2 }) => {
      this._displayPointerCursor(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e6, dy: t4, mover: o2, type: "move-stop" }, type: "update" });
    }, onGraphicPointerOver: () => this._displayPointerCursor(), onGraphicPointerOut: () => this._displayDefaultCursor() } });
  }
  async _getBox(e5, t3, o) {
    const { enableRotation: i5, enableScaling: a3, preserveAspectRatio: r3 } = t3, s4 = await this._requireModule(import("./Box-FU23Q26W.js"));
    return ne(s4) ? s4 : new s4.module.default({ graphics: e5, enableRotation: i5, enableScaling: a3, preserveAspectRatio: r3, layer: this._internalGraphicsLayer, view: o, callbacks: { onMoveStart: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onMove: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onMoveStop: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onScaleStart: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onScale: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onScaleStop: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onRotateStart: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onRotate: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onRotateStop: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }) } });
  }
  async _getReshape(e5, t3, o) {
    var _a, _b;
    const i5 = "split" === ((_a = t3.reshapeOptions) == null ? void 0 : _a.edgeOperation), a3 = "move" === ((_b = t3.reshapeOptions) == null ? void 0 : _b.shapeOperation), r3 = await this._requireModule(import("./Reshape-JQQNUJPH.js"));
    return ne(r3) ? r3 : new r3.module.default({ enableMidpoints: i5, enableMovement: a3, graphic: e5[0], layer: this._internalGraphicsLayer, snappingManager: this._snappingManager, view: o, callbacks: { onReshapeStart: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onReshape: (e6) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e6 }, type: "update" }), onReshapeStop: ({ mover: e6, type: t4 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6, type: t4 }, type: "update" }), onMoveStart: ({ dx: e6, dy: t4, mover: o2, type: i6 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e6, dy: t4, mover: o2, type: i6 }, type: "update" }), onMove: ({ dx: e6, dy: t4, mover: o2, type: i6 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e6, dy: t4, mover: o2, type: i6 }, type: "update" }), onMoveStop: ({ dx: e6, dy: t4, mover: o2, type: i6 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e6, dy: t4, mover: o2, type: i6 }, type: "update" }), onVertexAdd: ({ added: e6, type: t4, vertices: o2 }) => {
      const i6 = e6.map((e7) => t2(e7.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: i6, vertices: o2, type: t4 }, type: "update" });
    }, onVertexRemove: ({ removed: e6, type: t4, vertices: o2 }) => {
      const i6 = e6.map((e7) => t2(e7.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { removed: i6, vertices: o2, type: t4 }, type: "update" });
    } } });
  }
  _getHandlesForComponent(e5, t3) {
    const o = e5.activeComponent;
    switch (o.type) {
      case "graphic-mover":
        return [o.on("graphic-click", ({ graphic: t4, viewEvent: o2 }) => {
          var _a;
          ((_a = o2.native) == null ? void 0 : _a.shiftKey) && (o2.stopPropagation(), e5.removeFromSelection(t4));
        }), o.on("graphic-move-start", (t4) => e5.addToHistory(se(t4.allGraphics)))];
      case "box":
        return [o.on("graphic-click", (o2) => this._onTransformOrReshape2DGraphicClick(e5, t3, o2)), o.on("move-start", (t4) => e5.addToHistory(se(t4.graphics))), o.on("rotate-start", (t4) => e5.addToHistory(se(t4.graphics))), o.on("scale-start", (t4) => e5.addToHistory(se(t4.graphics)))];
      case "reshape":
        return [o.on("graphic-click", (o2) => this._onTransformOrReshape2DGraphicClick(e5, t3, o2)), o.on("move-start", (t4) => e5.addToHistory(se([t4.mover]))), o.on("reshape-start", (t4) => e5.addToHistory(se([t4.graphic]))), o.on("vertex-add", (t4) => e5.addToHistory(se([t4.oldGraphic]))), o.on("vertex-remove", (t4) => e5.addToHistory(se([t4.oldGraphic])))];
      case "move-3d":
        return [o.on("graphic-move-start", (t4) => {
          e5.addToHistory(se(t4.allGraphics)), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: t4.allGraphics.length > 0 ? t4.allGraphics[0] : null, type: "move-start" }, type: "update" });
        }), o.on("graphic-move", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e6.dx, dy: e6.dy, mover: e6.allGraphics.length > 0 ? e6.allGraphics[0] : null, type: "move" }, type: "update" });
        }), o.on("graphic-move-stop", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: e6.allGraphics.length > 0 ? e6.allGraphics[0] : null, type: "move-stop" }, type: "update" });
        }), o.on("immediate-click", (o2) => {
          o2.shiftKey ? this._toggleSelection([o2.graphic], e5, t3) : e5.toggleTool();
        })];
      case "transform-3d":
        return [o.on("record-undo", ({ record: t4 }) => {
          e5.addToHistory({ updates: [t4] });
        }), o.on("graphic-translate-start", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6.graphic, dx: e6.dxScreen, dy: e6.dyScreen, type: "move-start" }, type: "update" });
        }), o.on("graphic-translate-stop", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6.graphic, dx: e6.dxScreen, dy: e6.dyScreen, type: "move-stop" }, type: "update" });
        }), o.on("graphic-rotate-start", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6.graphic, angle: e6.angle, type: "rotate-start" }, type: "update" });
        }), o.on("graphic-rotate-stop", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6.graphic, angle: e6.angle, type: "rotate-stop" }, type: "update" });
        }), o.on("graphic-scale-start", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6.graphic, xScale: e6.xScale, yScale: e6.yScale, type: "scale-start" }, type: "update" });
        }), o.on("graphic-scale-stop", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6.graphic, xScale: e6.xScale, yScale: e6.yScale, type: "scale-stop" }, type: "update" });
        }), o.on("graphic-translate", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6.graphic, dx: e6.dxScreen, dy: e6.dyScreen, type: "move" }, type: "update" });
        }), o.on("graphic-rotate", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6.graphic, angle: e6.angle, type: "rotate" }, type: "update" });
        }), o.on("graphic-scale", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e6.graphic, xScale: e6.xScale, yScale: e6.yScale, type: "scale" }, type: "update" });
        }), o.on("immediate-click", (o2) => {
          o2.shiftKey ? this._toggleSelection([o2.graphic], e5, t3) : e5.toggleTool();
        })];
      case "reshape-3d":
        return [o.on("reshape", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e6, type: "update" });
        }), o.on("move", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e6, type: "update" });
        }), o.on("vertex-add", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e6, type: "update" });
        }), o.on("vertex-remove", (e6) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e6, type: "update" });
        }), o.on("immediate-click", (o2) => {
          o2.shiftKey ? this._toggleSelection([o2.graphic], e5, t3) : e5.toggleTool();
        })];
      default:
        return;
    }
  }
  _onTransformOrReshape2DGraphicClick(e5, t3, o) {
    var _a;
    const { graphic: i5, viewEvent: a3 } = o;
    return ((_a = a3.native) == null ? void 0 : _a.shiftKey) && i5.layer === this.layer ? (a3.stopPropagation(), e5.removeFromSelection(i5)) : t3.toggleToolOnClick ? (a3.stopPropagation(), e5.toggleTool()) : void 0;
  }
  _setUpdateOperationHandle(e5, t3) {
    this._operationHandle = e5;
    const o = this.view.map;
    this._disablePopup(t3);
    const i5 = () => {
      if (e5 === this._operationHandle) {
        const i6 = this.updateGraphics.toArray(), a3 = this._operationHandle.tool;
        this._operationHandle.destroy(), this._operationHandle = null, this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray()), this.updateGraphics.removeAll(), o && o.remove(this._internalGraphicsLayer), this._restorePopup(t3), this.emit("update", { graphics: i6, state: "complete", aborted: e5.cancelled, tool: a3, toolEventInfo: null, type: "update" });
      }
    };
    e5.on("complete", i5);
  }
  async _getCommonUpdateOperationClickHandlers(e5, t3, o) {
    const i5 = n4(t3), a3 = await t3.async(() => this._getFirstHit(i5));
    if (t(a3))
      return void e5.complete();
    if (t3.native.shiftKey && this._toggleSelection([a3.graphic], e5, o))
      return void t3.stopPropagation();
    this.updateGraphics.includes(a3.graphic) ? t3.stopPropagation() : e5.complete();
  }
  _toggleSelection(e5, t3, o) {
    const i5 = !!o.multipleSelectionEnabled;
    return e5.some((e6) => null != e6 && (!(!i5 || e6.layer !== this.layer) && (this.updateGraphics.includes(e6) ? t3.removeFromSelection(e6) : t3.addToSelection(e6), true)));
  }
  _getCommonUpdateOperationKeyDownHandlers(e5, t3) {
    if (!e5)
      return;
    const o = t3.key;
    o === e3.undo && e5.canUndo() ? (t3.stopPropagation(), e5.undo()) : o === e3.redo && e5.canRedo() ? (t3.stopPropagation(), e5.redo()) : o === e3.cancel ? (t3.stopPropagation(), e5.cancel()) : this.allowDeleteKey && e3.delete.includes(o) && this._onDeleteKey(t3);
  }
  _onDeleteKey(e5) {
    if (!this._operationHandle || "update" !== this._operationHandle.type)
      return;
    const t3 = this.activeComponent, o = this.updateGraphics.toArray();
    t(t3) || "reshape-3d" === t3.type || ("reshape" !== t3.type || 1 === o.length && "point" === m(o[0].geometry, "type")) && (e5.stopPropagation(), this.delete());
  }
  _removeDefaultLayer() {
    this._internalGraphicsLayer && (this.view && this.view.map && this.view.map.remove(this._internalGraphicsLayer), this._internalGraphicsLayer = l(this._internalGraphicsLayer));
  }
  _isComponentGraphic(e5) {
    const { activeComponent: t3 } = this;
    return !(!e5 || t(t3)) && (e5.attributes && e5.attributes.esriSketchTool || "draw-2d" === t3.type && t3.graphic === e5 || ("box" === t3.type || "reshape" === t3.type) && t3.isUIGraphic(e5));
  }
  _displayPointerCursor() {
    this.view && this.view.container && "pointer" !== this.view.cursor && (this.view.cursor = "pointer");
  }
  _displayGrabbingCursor() {
    this.view && this.view.container && "grabbing" !== this.view.cursor && (this.view.cursor = "grabbing");
  }
  _displayDefaultCursor() {
    this.view && this.view.container && null !== this.view.cursor && (this.view.cursor = null);
  }
  _logError(e5, t3, o) {
    Q.error(new s2(e5, t3, o));
  }
  async _requireModule(e5) {
    const t3 = new AbortController();
    this._moduleLoaderAbortController = t3;
    const o = await e5;
    return this._moduleLoaderAbortController !== t3 || t3.signal.aborted ? { requireError: "aborted" } : { module: o };
  }
  _emitUndoEvent(e5) {
    this.emit("undo", { ...e5, type: "undo" });
  }
  _emitRedoEvent(e5) {
    this.emit("redo", { ...e5, type: "redo" });
  }
  _emitDeleteEvent(e5) {
    this.emit("delete", { ...e5, type: "delete" });
  }
  get test() {
    return { operationHandle: this._operationHandle, defaultUpdateOptions: ee };
  }
  wait() {
    return j2(() => !this.updating);
  }
  _beginAsyncOperation() {
    this._numUpdating += 1, this.notifyChange("updating");
  }
  _endAsyncOperation() {
    this._numUpdating -= 1, this.notifyChange("updating");
  }
  _disablePopupEnabled(e5) {
    var _a;
    return "3d" !== ((_a = this.view) == null ? void 0 : _a.type) || this.updateOnGraphicClick || r(e5) && e5.toggleToolOnClick;
  }
  _disablePopup(e5) {
    if (!this._disablePopupEnabled(e5))
      return;
    const t3 = this.view.popup;
    t3 && t(this._originalAutoOpenEnabled) && (this._originalAutoOpenEnabled = t3.autoOpenEnabled, t3.autoOpenEnabled = false);
  }
  _restorePopup(e5) {
    if (!this._disablePopupEnabled(e5))
      return;
    const t3 = this.view.popup;
    t3 && r(this._originalAutoOpenEnabled) && (t3.autoOpenEnabled = this._originalAutoOpenEnabled, this._originalAutoOpenEnabled = null);
  }
  async _waitViewReady() {
    const e5 = this.view;
    e5 && (h(this._viewReadyAbortController), this._viewReadyAbortController = new AbortController(), await y(j2(() => e5 == null ? void 0 : e5.ready), this._viewReadyAbortController.signal));
  }
};
function oe(e5) {
  return "polygon" === e5 || "rectangle" === e5 || "circle" === e5;
}
function ie(e5, t3) {
  re("undo", e5.history.undo, e5.history.redo, t3);
}
function ae(e5, t3) {
  re("redo", e5.history.redo, e5.history.undo, t3);
}
function re(e5, t3, o, i5) {
  const a3 = t3.pop().updates, r3 = [];
  i5.forEach((t4, o2) => {
    const i6 = a3[o2];
    null != i6 && ("geometry" in i6 && r(i6.geometry) && (r3.push({ geometry: t4.geometry }), t4.geometry = i6.geometry), "symbol" in i6 && r(i6.symbol) && (r3.push({ symbol: t4.symbol }), t4.symbol = i6.symbol), "undo" in i6 && (r3.push(i6), i6[e5](t4)));
  }), o.push({ updates: r3 });
}
function se(e5) {
  return { updates: e5.map((e6) => ({ geometry: e6.geometry })) };
}
function ne(e5) {
  return "requireError" in e5 && "aborted" === e5.requireError;
}
e([d()], te.prototype, "updating", null), e([d()], te.prototype, "_operationHandle", void 0), e([d({ readOnly: true })], te.prototype, "activeTool", null), e([d()], te.prototype, "activeFillSymbol", void 0), e([d()], te.prototype, "activeLineSymbol", void 0), e([d()], te.prototype, "activeVertexSymbol", void 0), e([d()], te.prototype, "allowDeleteKey", void 0), e([d({ readOnly: true })], te.prototype, "createGraphic", null), e([d()], te.prototype, "defaultCreateOptions", null), e([d()], te.prototype, "defaultUpdateOptions", null), e([d({ type: c2, nonNullable: true })], te.prototype, "labelOptions", void 0), e([d()], te.prototype, "layer", void 0), e([d({ types: j3 })], te.prototype, "pointSymbol", void 0), e([d({ types: j3 })], te.prototype, "polygonSymbol", void 0), e([d({ types: j3 })], te.prototype, "polylineSymbol", void 0), e([d({ type: l3, nonNullable: true })], te.prototype, "snappingOptions", null), e([d()], te.prototype, "_snappingManager", void 0), e([d({ readOnly: true })], te.prototype, "state", null), e([d({ type: r2, nonNullable: true })], te.prototype, "tooltipOptions", void 0), e([d({ readOnly: true })], te.prototype, "updateGraphics", void 0), e([d()], te.prototype, "updateOnGraphicClick", void 0), e([d({ types: j3 })], te.prototype, "updatePointSymbol", void 0), e([d({ types: j3 })], te.prototype, "updatePolygonSymbol", void 0), e([d({ types: j3 })], te.prototype, "updatePolylineSymbol", void 0), e([d({ types: j3 })], te.prototype, "vertexSymbol", void 0), e([d({ value: null })], te.prototype, "view", null), te = e([n(J)], te);
var pe = te;

export {
  pe
};
//# sourceMappingURL=chunk-QWXV2ME4.js.map
