import {
  d as d3,
  h,
  i as i3,
  m as m7,
  x as x4
} from "./chunk-3KSVJZR6.js";
import {
  c as c4,
  f as f2,
  i as i4,
  m as m8
} from "./chunk-HXGHH25J.js";
import {
  D as D2,
  F,
  H,
  V,
  X,
  _,
  ee,
  k as k4,
  te as te2,
  v as v3
} from "./chunk-B5VZTE6L.js";
import {
  B,
  I,
  i,
  i3 as i2,
  k as k3,
  l as l3,
  m as m4,
  m2 as m6,
  n2 as n4,
  o as o4,
  o2 as o5,
  p as p2,
  r as r3,
  s as s3,
  te,
  u as u4
} from "./chunk-4ENPO4FB.js";
import {
  D,
  N,
  P,
  S as S4,
  U as U3,
  b as b2,
  c as c3,
  k as k2,
  l as l4,
  m as m5,
  n as n5,
  p as p3,
  r as r4,
  r2 as r5,
  x as x3
} from "./chunk-3SB6OSK7.js";
import {
  m as m3,
  p,
  u as u3,
  u2 as u5
} from "./chunk-I2XAFJCJ.js";
import {
  C,
  M as M2,
  U as U2,
  u,
  u2,
  x as x2
} from "./chunk-YRAX326I.js";
import "./chunk-DGELARKE.js";
import "./chunk-RRFFPL7N.js";
import "./chunk-JYR7GBAU.js";
import "./chunk-IG4CY4XM.js";
import "./chunk-HB4HVKJV.js";
import "./chunk-CC32E45Q.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-6FKG7JUE.js";
import "./chunk-PZWU5EHT.js";
import {
  a as a3
} from "./chunk-6O7ZZEV7.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import {
  x
} from "./chunk-4XBERLPX.js";
import {
  n as n3,
  z
} from "./chunk-IFZAYQVB.js";
import {
  S as S2
} from "./chunk-HR2OX32D.js";
import "./chunk-7ZPDA3EC.js";
import {
  o as o3
} from "./chunk-MZX3HN4G.js";
import {
  d as d2
} from "./chunk-T47JAOQZ.js";
import {
  S as S3
} from "./chunk-6GPADSSO.js";
import {
  n as n2
} from "./chunk-RIWDMEW4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import {
  o as o2
} from "./chunk-T7SYNS2R.js";
import {
  y
} from "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  v as v2
} from "./chunk-OG6CQEZJ.js";
import {
  c as c2
} from "./chunk-X5Z3DJQ4.js";
import {
  O
} from "./chunk-BUWXVMJU.js";
import {
  c,
  f
} from "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import {
  a as a2
} from "./chunk-D3XXPCBB.js";
import {
  t as t2
} from "./chunk-OWBMOIIV.js";
import {
  b
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  l as l2
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import {
  B as B2
} from "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import {
  r as r2
} from "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import {
  m as m2
} from "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  j as j2
} from "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  R,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  E,
  m,
  v,
  w
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  S
} from "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  a,
  e as e2,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/mixins/ImageryTileMixin.js
var j3 = s.getLogger("esri.layers.mixins.ImageryTileMixin");
var H2 = (i6) => {
  let H3 = class extends i6 {
    constructor() {
      super(...arguments), this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this.bandIds = null, this.copyright = null, this.fullExtent = null, this.interpolation = "nearest", this.multidimensionalDefinition = null, this.raster = null, this.rasterInfo = null, this.sourceJSON = null, this.spatialReference = null, this.tileInfo = null, this.symbolizer = null;
    }
    set url(e4) {
      this._set("url", S3(e4, j3));
    }
    set renderer(e4) {
      this._set("renderer", e4), this.updateRenderer();
    }
    async convertVectorFieldData(e4, t5) {
      if (t(e4))
        return null;
      const r7 = this._rasterJobHandler.instance, i7 = this.rasterInfo.dataType;
      return r7 ? r7.convertVectorFieldData({ pixelBlock: e4, dataType: i7 }, t5) : m3(e4, i7);
    }
    async createFlowMesh(e4, t5) {
      const r7 = this._rasterJobHandler.instance;
      return r7 ? r7.createFlowMesh(e4, t5) : u5(e4.meshType, e4.simulationSettings, e4.flowData, r(t5.signal) ? t5.signal : new AbortController().signal);
    }
    normalizeRasterFetchOptions(e4) {
      var _a, _b;
      const { multidimensionalInfo: t5 } = this.rasterInfo;
      if (t(t5))
        return e4;
      let r7 = e4.multidimensionalDefinition || this.multidimensionalDefinition;
      !t(r7) && r7.length || (r7 = i2(this.raster.rasterInfo));
      const i7 = e4.timeExtent || this.timeExtent;
      if (r(r7) && r(i7) && (r(i7.start) || r(i7.end))) {
        r7 = r7.map((e5) => e5.clone());
        const o8 = (_b = (_a = t5.variables.find(({ name: e5 }) => e5 === r7[0].variableName)) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find(({ name: e5 }) => "StdTime" === e5), a4 = r7.find(({ dimensionName: e5 }) => "StdTime" === e5);
        if (!o8 || !a4)
          return { ...e4, multidimensionalDefinition: null };
        const { start: l6, end: m10 } = i7, d5 = t(l6) ? null : l6.getTime(), u8 = t(m10) ? null : m10.getTime(), p4 = d5 ?? u8, h3 = u8 ?? d5;
        if (r(o8.values)) {
          const e5 = o8.values.filter((e6) => {
            if (Array.isArray(e6)) {
              if (p4 === h3)
                return e6[0] <= p4 && e6[1] >= p4;
              const t6 = e6[0] <= p4 && e6[1] > p4 || e6[0] < h3 && e6[1] >= h3, r8 = e6[0] >= p4 && e6[1] <= h3 || e6[0] < p4 && e6[1] > h3;
              return t6 || r8;
            }
            return p4 === h3 ? e6 === p4 : e6 >= p4 && e6 <= h3;
          });
          if (e5.length) {
            const t6 = e5.sort((e6, t7) => {
              if (p4 === h3)
                return (e6[0] ?? e6) - (t7[0] ?? t7);
              return Math.abs((e6[1] ?? e6) - h3) - Math.abs((t7[1] ?? t7) - h3);
            })[0];
            a4.values = [t6];
          } else
            r7 = null;
        } else if (o8.hasRegularIntervals && o8.extent) {
          const [e5, t6] = o8.extent;
          p4 > t6 || h3 < e5 ? r7 = null : a4.values = p4 === h3 ? [p4] : [Math.max(e5, p4), Math.min(t6, h3)];
        }
      }
      return { ...e4, multidimensionalDefinition: r7 };
    }
    async updateRenderer() {
      if (!this.loaded)
        return;
      if (JSON.stringify(this._cachedRendererJson) === JSON.stringify(this.renderer))
        return;
      const e4 = this._rasterJobHandler.instance;
      e4 && (this.symbolizer.rendererJSON = te(this.renderer.toJSON()), this.symbolizer.bind(), await e4.updateSymbolizer(this.symbolizer), this._cachedRendererJson = this.renderer.toJSON());
    }
    async applyRenderer(e4, t5) {
      const r7 = e4 && e4.pixelBlock;
      if (!(r(r7) && r7.pixels && r7.pixels.length > 0))
        return null;
      let i7;
      await this.updateRenderer();
      const s4 = this._rasterJobHandler.instance, { bandIds: o8 } = this;
      return i7 = s4 ? await s4.symbolize({ ...e4, simpleStretchParams: t5, bandIds: o8 }) : this.symbolizer.symbolize({ ...e4, simpleStretchParams: t5, bandIds: o8 }), i7;
    }
    getTileUrl(e4, t5, r7) {
      return "RasterTileServer" === this.raster.datasetFormat ? `${this.url}/tile/${e4}/${t5}/${r7}` : "";
    }
    getCompatibleTileInfo(e4, t5, r7 = false) {
      if (!this.loaded || t(t5))
        return null;
      if (r7 && e4.equals(this.spatialReference))
        return this.tileInfo;
      const i7 = R(e4);
      return S2.create({ size: 256, spatialReference: e4, origin: i7 ? { x: i7.origin[0], y: i7.origin[1] } : { x: t5.xmin, y: t5.ymax } });
    }
    getCompatibleFullExtent(e4) {
      return this.loaded ? (this._compatibleFullExtent && this._compatibleFullExtent.spatialReference.equals(e4) || (this._compatibleFullExtent = this.raster.computeExtent(e4)), this._compatibleFullExtent) : null;
    }
    async fetchTile(e4, t5, i7, o8 = {}) {
      if (o8.requestAsImageElement) {
        const s4 = this.getTileUrl(e4, t5, i7);
        return U(s4, { responseType: "image", query: { ...this.refreshParameters, ...this.raster.ioConfig.customFetchParameters }, signal: o8.signal }).then((e5) => e5.data);
      }
      if (r(this.rasterInfo.multidimensionalInfo) && (o8 = this.normalizeRasterFetchOptions(o8), t(o8.multidimensionalDefinition))) {
        const r7 = o8.tileInfo || this.rasterInfo.storageInfo.tileInfo;
        return { extent: this.raster.getTileExtentFromTileInfo(e4, t5, i7, r7), pixelBlock: null };
      }
      return await this._initJobHandler(), "raster-shaded-relief" === this.renderer.type && (o8 = { ...o8, buffer: { cols: 1, rows: 1 } }), this.raster.fetchTile(e4, t5, i7, o8);
    }
    async fetchPixels(e4, t5, r7, i7 = {}) {
      return r(this.rasterInfo.multidimensionalInfo) && (i7 = this.normalizeRasterFetchOptions(i7), t(i7.multidimensionalDefinition)) ? { extent: e4, pixelBlock: null } : (await this._initJobHandler(), this.raster.fetchPixels(e4, t5, r7, i7));
    }
    async identify(e4, t5 = {}) {
      if (r(this.rasterInfo.multidimensionalInfo)) {
        if (!(this.rasterInfo.hasMultidimensionalTranspose && !!(o5(t5.multidimensionalDefinition) || t5.transposedVariableName || t5.timeExtent)) && (t5 = this.normalizeRasterFetchOptions(t5), t(t5.multidimensionalDefinition)))
          return { location: e4, value: null };
      }
      return this.raster.identify(e4, t5);
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    hasStandardTime() {
      var _a;
      const e4 = this.rasterInfo.multidimensionalInfo;
      if (t(e4) || "standard-time" !== this.rasterInfo.dataType)
        return false;
      const t5 = (_a = this.multidimensionalDefinition[0]) == null ? void 0 : _a.variableName;
      return e4.variables.some((e5) => e5.name === t5 && e5.dimensions.some((e6) => "StdTime" === e6.name));
    }
    getStandardTimeValue(e4) {
      return new Date(24 * (e4 - 25569) * 3600 * 1e3).toString();
    }
    _configDefaultSettings() {
      this._configDefaultInterpolation(), this.multidimensionalDefinition || (this.multidimensionalDefinition = i2(this.raster.rasterInfo)), this._configDefaultRenderer();
    }
    _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const e4 = new n4();
      return this._rasterJobHandler.connectionPromise = e4.initialize().then(() => {
        this._rasterJobHandler.instance = e4, this.raster.rasterJobHandler = e4, this.renderer && this.updateRenderer();
      }).catch(() => null), this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this.raster.rasterJobHandler = null, this._cachedRendererJson = null;
    }
    _configDefaultInterpolation() {
      var _a;
      if (null == this.interpolation) {
        const e4 = I(this.rasterInfo, this.raster.tileType, (_a = this.sourceJSON) == null ? void 0 : _a.defaultResamplingMethod);
        this._set("interpolation", e4);
      }
    }
    _configDefaultRenderer() {
      var _a, _b, _c;
      const e4 = this.raster.rasterInfo;
      if (this.bandIds || (this.bandIds = B(e4)), !this.renderer) {
        const t6 = k3(e4, { bandIds: this.bandIds, variableName: r(this.multidimensionalDefinition) ? (_a = this.multidimensionalDefinition[0]) == null ? void 0 : _a.variableName : null });
        "WCSServer" === this.raster.datasetFormat && "raster-stretch" === t6.type && (((_b = e4.statistics) == null ? void 0 : _b[0].max) > 1e24 || ((_c = e4.statistics) == null ? void 0 : _c[0].min) < -1e24) && (t6.dynamicRangeAdjustment = true, t6.statistics = null, "none" === t6.stretchType && (t6.stretchType = "min-max")), this.renderer = t6;
      }
      this.symbolizer ? (this.symbolizer.rendererJSON = te(this.renderer.toJSON()), this.symbolizer.rasterInfo = e4) : this.symbolizer = new U3({ rendererJSON: this.renderer.toJSON(), rasterInfo: e4 });
      const t5 = this.symbolizer.bind();
      t5.success || j3.warn("imagery-tile-mixin", t5.error || "The given renderer is not supported by the layer.");
    }
  };
  return e([d()], H3.prototype, "_cachedRendererJson", void 0), e([d()], H3.prototype, "_compatibleFullExtent", void 0), e([d()], H3.prototype, "_rasterJobHandler", void 0), e([d()], H3.prototype, "bandIds", void 0), e([d({ json: { origins: { service: { read: { source: "copyrightText" } } } } })], H3.prototype, "copyright", void 0), e([d({ type: M, json: { read: false } }), o2("rasterInfo.extent")], H3.prototype, "fullExtent", void 0), e([d()], H3.prototype, "interpolation", void 0), e([d()], H3.prototype, "ioConfig", void 0), e([d({ type: [p2] })], H3.prototype, "multidimensionalDefinition", void 0), e([d()], H3.prototype, "raster", void 0), e([d({ readOnly: true }), o2("raster.rasterInfo")], H3.prototype, "rasterInfo", void 0), e([d()], H3.prototype, "sourceJSON", void 0), e([d({ type: k, json: { read: false } }), o2("rasterInfo.spatialReference")], H3.prototype, "spatialReference", void 0), e([d({ type: S2, json: { read: false } }), o2("rasterInfo.storageInfo.tileInfo")], H3.prototype, "tileInfo", void 0), e([d(f)], H3.prototype, "url", null), e([d({ types: l3 })], H3.prototype, "renderer", null), e([d()], H3.prototype, "symbolizer", void 0), H3 = e([n("esri.layers.ImageryTileMixin")], H3), H3;
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/BaseRaster.js
var q = 8;
var G = class extends m2(l) {
  constructor() {
    super(...arguments), this.rasterJobHandler = null, this.datasetName = null, this.datasetFormat = null, this.rasterInfo = null, this.ioConfig = { sampling: "closest" };
  }
  async init() {
    const t5 = k4();
    this.addResolvingPromise(t5), await this.when();
  }
  normalizeCtorArgs(t5) {
    return t5 && t5.ioConfig && (t5 = { ...t5, ioConfig: { resolution: null, bandIds: null, sampling: "closest", tileInfo: S2.create(), ...t5.ioConfig } }), t5;
  }
  get _isGlobalWrappableSource() {
    const { rasterInfo: t5 } = this, e4 = X(t5.spatialReference);
    return r(e4) && t5.extent.width >= e4 / 2;
  }
  set url(t5) {
    this._set("url", S3(t5, s.getLogger(this.declaredClass)));
  }
  async open(t5) {
    throw new s2("BaseRaster:open-not-implemented", "open() is not implemented");
  }
  async fetchTile(t5, e4, i6, o8 = {}) {
    const r7 = o8.tileInfo || this.rasterInfo.storageInfo.tileInfo, n8 = this.getTileExtentFromTileInfo(t5, e4, i6, r7);
    return this.fetchPixels(n8, r7.size[0], r7.size[1], o8);
  }
  async identify(t5, e4 = {}) {
    var _a;
    const { multidimensionalDefinition: i6, timeExtent: o8 } = e4, { hasMultidimensionalTranspose: r7, multidimensionalInfo: l6 } = this.rasterInfo;
    let { transposedVariableName: c7 } = e4;
    const m10 = r(l6) && r7 && (null != o8 || o5(i6));
    if (m10 && !c7) {
      c7 = r(i6) && i6.length > 0 ? i6[0].variableName : l6.variables[0].name, e4 = { ...e4, transposedVariableName: c7 };
    }
    e4 = this._getRequestOptionsWithSliceId(e4);
    const { spatialReference: f5, extent: h3 } = this.rasterInfo, { datumTransformation: u8 } = e4;
    let p4 = _(t5, f5, u8);
    if (!h3.intersects(p4))
      return { location: p4, value: null };
    if (r(this.rasterInfo.transform)) {
      const t6 = this.rasterInfo.transform.inverseTransform(p4);
      if (!this.rasterInfo.nativeExtent.intersects(t6))
        return { location: t6, value: null };
      p4 = t6;
    }
    let d5 = 0;
    const g = c7 && r(l6) && this.rasterInfo.hasMultidimensionalTranspose;
    if (!g) {
      if (e4.srcResolution) {
        d5 = te2(e4.srcResolution, this.rasterInfo, this.ioConfig.sampling).pyramidLevel;
      } else if (d5 = await this.computeBestPyramidLevelForLocation(t5, e4), null == d5)
        return { location: p4, value: null };
    }
    const y4 = this.identifyPixelLocation(p4, d5, null, g);
    if (null === y4)
      return { location: p4, value: null };
    const { row: I5, col: b5, rowOffset: v4, colOffset: S8, blockWidth: T } = y4, B3 = c7 ?? e2(e4.sliceId), P2 = i3(this.url, B3), W = `${d5}/${I5}/${b5}`;
    let M3 = m7(P2, null, W);
    t(M3) && (M3 = this.fetchRawTile(d5, I5, b5, e4), x4(P2, null, W, M3));
    const j4 = await M3;
    if (t(j4) || !((_a = j4.pixels) == null ? void 0 : _a.length))
      return { location: p4, value: null };
    const H3 = v4 * T + S8;
    return this._processIdentifyResult(j4, { srcLocation: p4, position: H3, pyramidLevel: d5, useTransposedTile: g, requestSomeSlices: m10, identifyOptions: e4 });
  }
  async fetchPixels(t5, e4, i6, o8 = {}) {
    if (t5 = ee(t5), (o8 = this._getRequestOptionsWithSliceId(o8)).requestRawData)
      return this._fetchPixels(t5, e4, i6, o8);
    const r7 = X(t5.spatialReference), n8 = D2(t5);
    if (t(r7) || 0 === n8 || 1 === n8 && this._isGlobalWrappableSource)
      return this._fetchPixels(t5, e4, i6, o8);
    if (n8 >= 3)
      return { extent: t5, pixelBlock: null };
    const s4 = [], { xmin: l6, xmax: c7 } = t5, m10 = Math.round(r7 / (c7 - l6) * e4), f5 = m10 - Math.round((r7 / 2 - l6) / (c7 - l6) * e4);
    let h3 = 0;
    const u8 = [];
    for (let a4 = 0; a4 <= n8; a4++) {
      const p5 = new M({ xmin: 0 === a4 ? l6 : -r7 / 2, xmax: a4 === n8 ? c7 - r7 * a4 : r7 / 2, ymin: t5.ymin, ymax: t5.ymax, spatialReference: t5.spatialReference }), d6 = 0 === a4 ? m10 - f5 : a4 === n8 ? e4 - h3 : m10;
      h3 += d6, u8.push(d6);
      const x7 = o8.disableWrapAround && a4 > 0 ? null : this._fetchPixels(p5, d6, i6, o8);
      s4.push(x7);
    }
    const p4 = (await Promise.all(s4)).map((t6) => t6 == null ? void 0 : t6.pixelBlock);
    let d5 = null;
    const x6 = { width: e4, height: i6 };
    if (this.rasterJobHandler) {
      d5 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: p4, srcMosaicSize: x6, destDimension: null, coefs: null, sampleSpacing: null, interpolation: "nearest", alignmentInfo: null, blockWidths: u8 }, o8)).pixelBlock;
    } else
      d5 = u2(p4, x6, { blockWidths: u8 });
    return { extent: t5, srcExtent: F(t5, this.rasterInfo.spatialReference, o8.datumTransformation), pixelBlock: d5 };
  }
  async fetchRawPixels(t5, e4, i6, o8 = {}) {
    e4 = { x: Math.floor(e4.x), y: Math.floor(e4.y) };
    const r7 = await this._fetchRawTiles(t5, e4, i6, o8), { nativeExtent: s4, nativePixelSize: a4, storageInfo: l6 } = this.rasterInfo, c7 = 2 ** t5, m10 = a4.x * c7, f5 = a4.y * c7, h3 = new M({ xmin: s4.xmin + m10 * e4.x, xmax: s4.xmin + m10 * (e4.x + i6.width - 1), ymin: s4.ymax - f5 * (e4.y + i6.height - 1), ymax: s4.ymax - f5 * e4.y, spatialReference: s4.spatialReference });
    if (!r7)
      return { extent: h3, srcExtent: h3, pixelBlock: null };
    const { pixelBlocks: u8, mosaicSize: p4 } = r7;
    if (1 === u8.length && r(u8[0]) && u8[0].width === i6.width && u8[0].height === i6.height)
      return { extent: h3, srcExtent: h3, pixelBlock: r7.pixelBlocks[0] };
    const d5 = t5 > 0 ? l6.pyramidBlockWidth : l6.blockWidth, x6 = t5 > 0 ? l6.pyramidBlockHeight : l6.blockHeight, g = { x: e4.x % d5, y: e4.y % x6 };
    let y4;
    if (this.rasterJobHandler) {
      y4 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: u8, srcMosaicSize: p4, destDimension: i6, clipOffset: g, clipSize: i6, coefs: null, sampleSpacing: null, interpolation: o8.interpolation, alignmentInfo: null, blockWidths: null }, o8)).pixelBlock;
    } else
      y4 = u2(u8, p4, { clipOffset: g, clipSize: i6 });
    return { extent: h3, srcExtent: h3, pixelBlock: y4 };
  }
  fetchRawTile(t5, e4, o8, r7) {
    throw new s2("BaseRaster:read-not-implemented", "fetchRawTile() is not implemented");
  }
  computeExtent(t5) {
    return F(this.rasterInfo.extent, t5);
  }
  decodePixelBlock(t5, e4) {
    return !this.rasterJobHandler || e4.useCanvas ? S4(t5, e4) : this.rasterJobHandler.decode({ data: t5, options: e4 });
  }
  async request(t5, i6, o8) {
    const { customFetchParameters: r7 } = this.ioConfig, { range: n8, query: s4, headers: a4 } = i6;
    o8 = o8 ?? i6.retryCount ?? this.ioConfig.retryCount;
    const l6 = n8 ? { Range: `bytes=${n8.from}-${n8.to}` } : null;
    try {
      return await U(t5, { ...i6, query: { ...s4, ...r7 }, headers: { ...a4, ...l6 } });
    } catch (c7) {
      if (o8 > 0)
        return o8--, this.request(t5, i6, o8);
      throw c7;
    }
  }
  getSliceIndex(t5) {
    const { multidimensionalInfo: e4 } = this.rasterInfo;
    return t(e4) || t(t5) || 0 === t5.length ? null : m4(t5, e4);
  }
  getTileExtentFromTileInfo(t5, e4, i6, o8) {
    const r7 = o8.lodAt(t5);
    return this.getTileExtent({ x: r7.resolution, y: r7.resolution }, e4, i6, o8.origin, o8.spatialReference, o8.size);
  }
  updateTileInfo() {
    const { storageInfo: t5, spatialReference: e4, extent: i6, pixelSize: o8 } = this.rasterInfo;
    if (!t5.tileInfo) {
      const r7 = [], n8 = t5.maximumPyramidLevel || 0;
      let s4 = Math.max(o8.x, o8.y), a4 = 1 / 0.0254 * 96 * s4;
      for (let t6 = 0; t6 <= n8; t6++)
        r7.push({ level: n8 - t6, resolution: s4, scale: a4 }), s4 *= 2, a4 *= 2;
      const l6 = new j({ x: i6.xmin, y: i6.ymax, spatialReference: e4 });
      t5.tileInfo = new S2({ origin: l6, size: [t5.blockWidth, t5.blockHeight], spatialReference: e4, lods: r7 }), t5.isVirtualTileInfo = true;
    }
  }
  createRemoteDatasetStorageInfo(t5, e4 = 512, i6 = 512, o8) {
    const { width: r7, height: n8, nativeExtent: s4, pixelSize: a4, spatialReference: l6 } = t5, c7 = new j({ x: s4.xmin, y: s4.ymax, spatialReference: l6 });
    null == o8 && (o8 = Math.max(0, Math.round(Math.log(Math.max(r7, n8)) / Math.LN2 - 8)));
    const m10 = this.computeBlockBoundary(s4, 512, 512, { x: s4.xmin, y: s4.ymax }, [a4], o8);
    t5.storageInfo = new p3({ blockWidth: e4, blockHeight: i6, pyramidBlockWidth: e4, pyramidBlockHeight: i6, origin: c7, firstPyramidLevel: 1, maximumPyramidLevel: o8, blockBoundary: m10 });
  }
  async computeBestPyramidLevelForLocation(t5, e4 = {}) {
    return 0;
  }
  computeBlockBoundary(t5, e4, i6, o8, r7, n8 = 0, s4 = 2) {
    if (1 === r7.length && n8 > 0) {
      r7 = [...r7];
      let { x: t6, y: e5 } = r7[0];
      for (let i7 = 0; i7 < n8; i7++)
        t6 *= s4, e5 *= s4, r7.push({ x: t6, y: e5 });
    }
    const a4 = [], { x: l6, y: c7 } = o8;
    for (let m10 = 0; m10 < r7.length; m10++) {
      const { x: o9, y: n9 } = r7[m10];
      a4.push({ minCol: Math.floor((t5.xmin - l6 + 0.1 * o9) / e4 / o9), maxCol: Math.floor((t5.xmax - l6 - 0.1 * o9) / e4 / o9), minRow: Math.floor((c7 - t5.ymax + 0.1 * n9) / i6 / n9), maxRow: Math.floor((c7 - t5.ymin - 0.1 * n9) / i6 / n9) });
    }
    return a4;
  }
  getPyramidPixelSize(t5) {
    const { nativePixelSize: e4 } = this.rasterInfo, { pyramidResolutions: i6, pyramidScalingFactor: o8 } = this.rasterInfo.storageInfo;
    if (0 === t5)
      return e4;
    if (r(i6) && i6.length)
      return i6[t5 - 1];
    const r7 = o8 ** t5;
    return { x: e4.x * r7, y: e4.y * r7 };
  }
  identifyPixelLocation(t5, e4, i6, o8) {
    const { spatialReference: r7, nativeExtent: s4, storageInfo: a4 } = this.rasterInfo, { maximumPyramidLevel: l6, origin: c7, transposeInfo: m10 } = a4, f5 = o8 && r(m10) ? m10.tileSize[0] : a4.blockWidth, h3 = o8 && r(m10) ? m10.tileSize[1] : a4.blockHeight, u8 = _(t5, r7, i6);
    if (!s4.intersects(u8))
      return null;
    if (e4 < 0 || e4 > l6)
      return null;
    const p4 = this.getPyramidPixelSize(e4), { x: d5, y: x6 } = p4, g = (c7.y - u8.y) / x6 / h3, y4 = (u8.x - c7.x) / d5 / f5, I5 = Math.min(h3 - 1, Math.floor((g - Math.floor(g)) * h3)), R2 = Math.min(f5 - 1, Math.floor((y4 - Math.floor(y4)) * f5));
    return { pyramidLevel: e4, row: Math.floor(g), col: Math.floor(y4), rowOffset: I5, colOffset: R2, blockWidth: f5, srcLocation: u8 };
  }
  getTileExtent(t5, e4, i6, o8, r7, n8) {
    const [s4, a4] = n8, l6 = o8.x + i6 * s4 * t5.x, c7 = l6 + s4 * t5.x, m10 = o8.y - e4 * a4 * t5.y, f5 = m10 - a4 * t5.y;
    return new M({ xmin: l6, xmax: c7, ymin: f5, ymax: m10, spatialReference: r7 });
  }
  getBlockWidthHeight(t5) {
    return { blockWidth: t5 > 0 ? this.rasterInfo.storageInfo.pyramidBlockWidth : this.rasterInfo.storageInfo.blockWidth, blockHeight: t5 > 0 ? this.rasterInfo.storageInfo.pyramidBlockHeight : this.rasterInfo.storageInfo.blockHeight };
  }
  isBlockOutside(t5, e4, i6) {
    const o8 = this.rasterInfo.storageInfo.blockBoundary[t5];
    return !o8 || o8.maxRow < e4 || o8.maxCol < i6 || o8.minRow > e4 || o8.minCol > i6;
  }
  async _fetchPixels(t5, e4, i6, o8 = {}) {
    let r7 = D2(t5);
    if (r7 >= 2)
      return { extent: t5, pixelBlock: null };
    const a4 = this._getSourceDataInfo(t5, e4, i6, o8), { pyramidLevel: l6, pyramidResolution: c7, srcResolution: m10, srcExtent: f5, srcWidth: h3, srcHeight: u8 } = a4;
    if (0 === h3 || 0 === u8)
      return { extent: t5, srcExtent: f5, pixelBlock: null };
    const p4 = e2(this.rasterInfo.transform), d5 = "gcs-shift" === (p4 == null ? void 0 : p4.type), x6 = r(X(t5.spatialReference));
    !d5 && x6 || (r7 = D2(a4.srcExtent, d5));
    const g = this.rasterInfo.storageInfo, y4 = { x: Math.floor((f5.xmin - g.origin.x) / c7.x + 0.1), y: Math.floor((g.origin.y - f5.ymax) / c7.y + 0.1) }, I5 = await this._fetchRawTiles(l6, y4, { width: h3, height: u8, wrapCount: r7 }, o8);
    if (!I5)
      return { extent: t5, srcExtent: f5, pixelBlock: null };
    const R2 = l6 > 0 ? g.pyramidBlockWidth : g.blockWidth, w3 = l6 > 0 ? g.pyramidBlockHeight : g.blockHeight, k5 = R2 === h3 && w3 === u8 && y4.x % R2 == 0 && y4.y % w3 == 0, b5 = new j({ x: (t5.xmax - t5.xmin) / e4, y: (t5.ymax - t5.ymin) / i6, spatialReference: t5.spatialReference }), v4 = !t5.spatialReference.equals(this.rasterInfo.spatialReference), { datumTransformation: S8 } = o8;
    if (!v4 && k5 && 1 === I5.pixelBlocks.length && R2 === e4 && w3 === i6 && m10.x === b5.x && m10.y === b5.y)
      return { extent: t5, srcExtent: f5, pixelBlock: I5.pixelBlocks[0] };
    const C2 = x6 && r(X(f5.spatialReference)), _3 = o8.requestProjectedLocalDirections && this.rasterInfo.dataType.startsWith("vector");
    _3 && !this.rasterJobHandler && await k4();
    const j4 = this.rasterJobHandler ? await this.rasterJobHandler.getProjectionOffsetGrid({ projectedExtent: t5, srcBufferExtent: I5.extent, pixelSize: b5.toJSON(), datumTransformation: S8, rasterTransform: p4, hasWrapAround: r7 > 0 || C2, isAdaptive: false !== this.ioConfig.optimizeProjectionAccuracy, includeGCSGrid: _3 }, o8) : V({ projectedExtent: t5, srcBufferExtent: I5.extent, pixelSize: b5, datumTransformation: S8, rasterTransform: p4, hasWrapAround: r7 > 0 || C2, isAdaptive: false, includeGCSGrid: _3 });
    let E3;
    const D3 = !o8.requestRawData, z2 = { rows: j4.spacing[0], cols: j4.spacing[1] }, F3 = e2(this._getRasterTileAlignmentInfo(l6, I5.extent.xmin)), { pixelBlocks: O2, mosaicSize: q2, isPartiallyFilled: G2 } = I5;
    let J2 = null;
    if (this.rasterJobHandler) {
      const t6 = await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: O2, srcMosaicSize: q2, destDimension: D3 ? { width: e4, height: i6 } : null, coefs: D3 ? j4.coefficients : null, sampleSpacing: D3 ? z2 : null, projectDirections: _3, gcsGrid: _3 ? j4.gcsGrid : null, isUV: "vector-uv" === this.rasterInfo.dataType, interpolation: o8.interpolation, alignmentInfo: F3, blockWidths: null }, o8);
      ({ pixelBlock: E3, localNorthDirections: J2 } = t6);
    } else {
      const t6 = u2(O2, q2, { alignmentInfo: F3 });
      E3 = D3 ? C(t6, { width: e4, height: i6 }, j4.coefficients, z2, o8.interpolation) : t6, _3 && j4.gcsGrid && (J2 = U2({ width: e4, height: i6 }, j4.gcsGrid), E3 = p(E3, this.rasterInfo.dataType, J2));
    }
    return o8.requestRawData || _3 ? { srcExtent: f5, pixelBlock: E3, transformGrid: j4, localNorthDirections: J2, extent: t5, isPartiallyFilled: G2 } : { srcExtent: f5, extent: t5, pixelBlock: E3 };
  }
  async _fetchRawTiles(t5, e4, i6, o8) {
    const { origin: r7, blockBoundary: s4 } = this.rasterInfo.storageInfo, { blockWidth: a4, blockHeight: l6 } = this.getBlockWidthHeight(t5);
    let { x: c7, y: m10 } = e4, { width: f5, height: h3, wrapCount: u8 } = i6;
    const p4 = this._getRasterTileAlignmentInfo(t5, 0);
    o8.buffer && (c7 -= o8.buffer.cols, m10 -= o8.buffer.rows, f5 += 2 * o8.buffer.cols, h3 += 2 * o8.buffer.rows);
    let d5 = 0, x6 = 0, g = 0;
    if (u8 && r(p4)) {
      ({ worldColumnCountFromOrigin: x6, originColumnOffset: g, rightPadding: d5 } = p4);
      x6 * p4.blockWidth - d5 >= c7 + f5 && (d5 = 0);
    }
    const y4 = Math.floor(c7 / a4), I5 = Math.floor(m10 / l6), R2 = Math.floor((c7 + f5 + d5 - 1) / a4), w3 = Math.floor((m10 + h3 + d5 - 1) / l6), k5 = s4[t5];
    if (!k5)
      return null;
    const { minRow: b5, minCol: v4, maxCol: S8, maxRow: T } = k5;
    if (0 === u8 && (w3 < b5 || R2 < v4 || I5 > T || y4 > S8))
      return null;
    const B3 = new Array();
    let P2 = false;
    const W = null == this.ioConfig.allowPartialFill ? o8.allowPartialFill : this.ioConfig.allowPartialFill;
    for (let L2 = I5; L2 <= w3; L2++)
      for (let e5 = y4; e5 <= R2; e5++) {
        let i7 = e5;
        if (!o8.disableWrapAround && u8 && r(p4) && x6 <= e5 && (i7 = e5 - x6 - g), L2 >= b5 && i7 >= v4 && T >= L2 && S8 >= i7) {
          const e6 = this._fetchRawTile(t5, L2, i7, o8);
          W ? B3.push(new Promise((t6) => {
            e6.then((e7) => t6(e7)).catch(() => {
              P2 = true, t6(null);
            });
          })) : B3.push(e6);
        } else
          B3.push(null);
      }
    if (0 === B3.length)
      return null;
    const M3 = await Promise.all(B3), C2 = { height: (w3 - I5 + 1) * l6, width: (R2 - y4 + 1) * a4 }, { spatialReference: _3 } = this.rasterInfo, j4 = this.getPyramidPixelSize(t5), { x: H3, y: E3 } = j4;
    return { extent: new M({ xmin: r7.x + y4 * a4 * H3, xmax: r7.x + (R2 + 1) * a4 * H3, ymin: r7.y - (w3 + 1) * l6 * E3, ymax: r7.y - I5 * l6 * E3, spatialReference: _3 }), pixelBlocks: M3, mosaicSize: C2, isPartiallyFilled: P2 };
  }
  _fetchRawTile(t5, e4, i6, o8) {
    const r7 = this.rasterInfo.storageInfo.blockBoundary[t5];
    if (!r7)
      return Promise.resolve(null);
    const { minRow: n8, minCol: s4, maxCol: l6, maxRow: m10 } = r7;
    if (e4 < n8 || i6 < s4 || e4 > m10 || i6 > l6)
      return Promise.resolve(null);
    const f5 = i3(this.url, o8.sliceId), h3 = `${t5}/${e4}/${i6}`;
    let u8 = m7(f5, o8.registryId, h3);
    if (t(u8)) {
      const r8 = new AbortController();
      u8 = this.fetchRawTile(t5, e4, i6, { ...o8, signal: r8.signal }), x4(f5, o8.registryId, h3, u8, r8), u8.catch(() => d3(f5, o8.registryId, h3));
    }
    return o8.signal && v(o8, () => {
      h(f5, o8.registryId, h3);
    }), u8;
  }
  _computeMagDirValues(t5) {
    var _a;
    const { bandCount: e4, dataType: i6 } = this.rasterInfo;
    if (!(2 === e4 && "vector-magdir" === i6 || "vector-uv" === i6) || 2 !== (t5 == null ? void 0 : t5.length) || !((_a = t5[0]) == null ? void 0 : _a.length))
      return null;
    const o8 = t5[0].length;
    if ("vector-magdir" === i6) {
      const e5 = t5[1].map((t6) => (t6 + 360) % 360);
      return [t5[0], e5];
    }
    const [r7, n8] = t5, s4 = [], a4 = [];
    for (let l6 = 0; l6 < o8; l6++) {
      const [t6, e5] = u3([r7[l6], n8[l6]]);
      s4.push(t6), a4.push(e5);
    }
    return [s4, a4];
  }
  _getRasterTileAlignmentInfo(t5, e4) {
    return null == this._rasterTileAlighmentInfo && (this._rasterTileAlighmentInfo = H(this.rasterInfo)), t(this._rasterTileAlighmentInfo.pyramidsInfo) ? null : { startX: e4, halfWorldWidth: this._rasterTileAlighmentInfo.halfWorldWidth, hasGCSSShiftTransform: this._rasterTileAlighmentInfo.hasGCSSShiftTransform, ...this._rasterTileAlighmentInfo.pyramidsInfo[t5] };
  }
  _getSourceDataInfo(t5, e4, i6, o8 = {}) {
    const r7 = { datumTransformation: o8.datumTransformation, pyramidLevel: 0, pyramidResolution: null, srcExtent: null, srcHeight: 0, srcResolution: null, srcWidth: 0 };
    o8.srcResolution && (r7.srcResolution = o8.srcResolution, this._updateSourceDataInfo(t5, r7));
    const n8 = this.rasterInfo.storageInfo.maximumPyramidLevel || 0, { srcWidth: s4, srcHeight: a4, pyramidLevel: l6 } = r7, c7 = s4 / e4, m10 = a4 / i6, f5 = l6 < n8 && c7 * m10 >= 16;
    if (f5 || l6 === n8 && (c7 > q || m10 > q) || (0 === s4 || 0 === a4)) {
      const s5 = new j({ x: (t5.xmax - t5.xmin) / e4, y: (t5.ymax - t5.ymin) / i6, spatialReference: t5.spatialReference });
      let a5 = v3(s5, this.rasterInfo.spatialReference, t5, r7.datumTransformation);
      const h3 = !a5 || o8.srcResolution && a5.x + a5.y < o8.srcResolution.x + o8.srcResolution.y;
      if (f5 && o8.srcResolution && h3) {
        const t6 = Math.round(Math.log(Math.max(c7, m10)) / Math.LN2) - 1;
        if (n8 - l6 + 3 >= t6) {
          const e5 = 2 ** t6;
          a5 = { x: o8.srcResolution.x * e5, y: o8.srcResolution.y * e5 };
        }
      }
      a5 && (r7.srcResolution = a5, this._updateSourceDataInfo(t5, r7));
    }
    return (r7.srcWidth / e4 > q || r7.srcHeight / i6 > q) && (r7.srcWidth = 0, r7.srcHeight = 0), r7;
  }
  _updateSourceDataInfo(t5, e4) {
    e4.srcWidth = 0, e4.srcHeight = 0;
    const i6 = this.rasterInfo.spatialReference, { srcResolution: o8, datumTransformation: r7 } = e4, { pyramidLevel: n8, pyramidResolution: a4, excessiveReading: l6 } = te2(o8, this.rasterInfo, this.ioConfig.sampling);
    if (l6)
      return;
    let c7 = e4.srcExtent || F(t5, i6, r7);
    if (null == c7)
      return;
    const m10 = e2(this.rasterInfo.transform);
    m10 && (c7 = m10.inverseTransform(c7)), e4.srcExtent = c7;
    const f5 = Math.ceil((c7.xmax - c7.xmin) / a4.x - 0.1), h3 = Math.ceil((c7.ymax - c7.ymin) / a4.y - 0.1);
    e4.pyramidLevel = n8, e4.pyramidResolution = a4, e4.srcWidth = f5, e4.srcHeight = h3;
  }
  _getRequestOptionsWithSliceId(t5) {
    return r(this.rasterInfo.multidimensionalInfo) && null == t5.sliceId && (t5 = { ...t5, sliceId: this.getSliceIndex(t5.multidimensionalDefinition) }), t5;
  }
  _processIdentifyResult(t5, e4) {
    const { srcLocation: i6, position: o8, pyramidLevel: r7, useTransposedTile: n8 } = e4, l6 = t5.pixels[0].length / t5.width / t5.height;
    if (!(!t5.mask || t5.mask[o8]))
      return { location: i6, value: null };
    const { multidimensionalInfo: c7 } = this.rasterInfo;
    if (t(c7) || !n8) {
      const e5 = t5.pixels.map((t6) => t6[o8]), n9 = { location: i6, value: e5, pyramidLevel: r7 }, s4 = this._computeMagDirValues(e5.map((t6) => [t6]));
      return (s4 == null ? void 0 : s4.length) && (n9.magdirValue = s4.map((t6) => t6[0])), n9;
    }
    let m10 = t5.pixels.map((t6) => Array.prototype.slice.call(t6, o8 * l6, o8 * l6 + l6)), f5 = this._computeMagDirValues(m10);
    const { requestSomeSlices: h3, identifyOptions: u8 } = e4;
    let p4 = r3(c7, u8.transposedVariableName);
    if (h3) {
      const t6 = s3(p4, e2(u8.multidimensionalDefinition), e2(u8.timeExtent));
      m10 = m10.map((e5) => t6.map((t7) => e5[t7])), f5 = f5 == null ? void 0 : f5.map((e5) => t6.map((t7) => e5[t7])), p4 = t6.map((t7) => p4[t7]);
    }
    return { location: i6, value: null, dataSeries: p4.map((t6, e5) => {
      const i7 = { value: m10.map((t7) => t7[e5]), multidimensionalDefinition: t6.multidimensionalDefinition, variableName: t6.multidimensionalDefinition[0].variableName, dimensionValues: {} };
      return (f5 == null ? void 0 : f5.length) && (i7.magdirValue = [f5[0][e5], f5[1][e5]]), t6.multidimensionalDefinition.forEach((t7) => i7.dimensionValues[t7.dimensionName] = t7.values[0]), i7;
    }), pyramidLevel: r7 };
  }
};
e([d()], G.prototype, "_rasterTileAlighmentInfo", void 0), e([d({ readOnly: true })], G.prototype, "_isGlobalWrappableSource", null), e([d(f)], G.prototype, "url", null), e([d({ type: String, json: { write: true } })], G.prototype, "datasetName", void 0), e([d({ type: String, json: { write: true } })], G.prototype, "datasetFormat", void 0), e([d()], G.prototype, "rasterInfo", void 0), e([d()], G.prototype, "ioConfig", void 0), e([d()], G.prototype, "sourceJSON", void 0), G = e([n("esri.layers.support.rasterDatasets.BaseRaster")], G);
var J = G;

// node_modules/@arcgis/core/layers/support/rasterDatasets/DBFParser.js
function t3(e4) {
  const t5 = e4.fields, r7 = e4.records, n8 = t5.some((e5) => "oid" === e5.name.toLowerCase()) ? "OBJECTID" : "OID", i6 = [{ name: n8, type: "esriFieldTypeOID", alias: "OID" }].concat(t5.map((e5) => ({ name: e5.name, type: "esriFieldType" + e5.typeName, alias: e5.name }))), s4 = i6.map((e5) => e5.name), a4 = [];
  let o8 = 0, l6 = 0;
  return r7.forEach((e5) => {
    const t6 = {};
    for (t6[n8] = o8++, l6 = 1; l6 < s4.length; l6++)
      t6[s4[l6]] = e5[l6 - 1];
    a4.push({ attributes: t6 });
  }), { displayFieldName: "", fields: i6, features: a4 };
}
var r6 = class {
  static get supportedVersions() {
    return [5];
  }
  static parse(r7) {
    const n8 = new DataView(r7), i6 = 3 & n8.getUint8(0);
    if (3 !== i6)
      return { header: { version: i6 }, recordSet: null };
    const s4 = n8.getUint32(4, true), a4 = n8.getUint16(8, true), o8 = n8.getUint16(10, true), l6 = { version: i6, recordCount: s4, headerByteCount: a4, recordByteCount: o8 };
    let p4 = 32;
    const g = [], u8 = [];
    let d5;
    if (3 === i6) {
      for (; 13 !== n8.getUint8(p4); )
        d5 = String.fromCharCode(n8.getUint8(p4 + 11)).trim(), g.push({ name: r4(new Uint8Array(r7, p4, 11)), type: d5, typeName: ["String", "Date", "Double", "Boolean", "String", "Integer"][["C", "D", "F", "L", "M", "N"].indexOf(d5)], length: n8.getUint8(p4 + 16) }), p4 += 32;
      if (p4 += 1, g.length > 0)
        for (; u8.length < s4 && r7.byteLength - p4 > o8; ) {
          const t5 = [];
          32 === n8.getUint8(p4) ? (p4 += 1, g.forEach((n9) => {
            if ("C" === n9.type)
              t5.push(r4(new Uint8Array(r7, p4, n9.length)).trim());
            else if ("N" === n9.type)
              t5.push(parseInt(String.fromCharCode.apply(null, new Uint8Array(r7, p4, n9.length)).trim(), 10));
            else if ("F" === n9.type)
              t5.push(parseFloat(String.fromCharCode.apply(null, new Uint8Array(r7, p4, n9.length)).trim()));
            else if ("D" === n9.type) {
              const e4 = String.fromCharCode.apply(null, new Uint8Array(r7, p4, n9.length)).trim();
              t5.push(new Date(parseInt(e4.substring(0, 4), 10), parseInt(e4.substring(4, 6), 10) - 1, parseInt(e4.substring(6, 8), 10)));
            }
            p4 += n9.length;
          }), u8.push(t5)) : p4 += o8;
        }
    }
    return { header: l6, fields: g, records: u8, recordSet: t3({ fields: g, records: u8 }) };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/CloudRaster.js
var y2 = /* @__PURE__ */ new Map();
y2.set("int16", "esriFieldTypeSmallInteger"), y2.set("int32", "esriFieldTypeInteger"), y2.set("int64", "esriFieldTypeInteger"), y2.set("float32", "esriFieldTypeSingle"), y2.set("float64", "esriFieldTypeDouble"), y2.set("text", "esriFieldTypeString");
var x5 = 8;
var S5 = class extends J {
  constructor() {
    super(...arguments), this.storageInfo = null, this.datasetFormat = "CRF";
  }
  async open(e4) {
    await this.init();
    const { data: r7 } = await this.request(this.url + "/conf.json", { signal: e4 == null ? void 0 : e4.signal });
    if (!this._validateHeader(r7))
      throw new s2("cloudraster:open", "Invalid or unsupported conf.json.");
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const { storageInfo: i6, rasterInfo: o8 } = this._parseHeader(r7);
    if ("thematic" === o8.dataType) {
      const e5 = await this._fetchAuxiliaryInformation();
      o8.attributeTable = e5;
    }
    this._set("storageInfo", i6), this._set("rasterInfo", o8), this.ioConfig.retryCount = this.ioConfig.retryCount || 0;
  }
  async fetchRawTile(e4, t5, r7, i6 = {}) {
    const { transposeInfo: o8 } = this.rasterInfo.storageInfo, { transposedVariableName: s4 } = i6, a4 = !(!o8 || !s4), n8 = a4 ? 0 : this.rasterInfo.storageInfo.maximumPyramidLevel - e4;
    if (n8 < 0)
      return null;
    const l6 = this._buildCacheFilePath(n8, t5, r7, i6.multidimensionalDefinition, s4), f5 = this._getIndexRecordFromBundle(t5, r7, a4), m10 = await this.request(l6, { range: { from: 0, to: this.storageInfo.headerSize - 1 }, responseType: "array-buffer", signal: i6.signal });
    if (!m10)
      return null;
    const c7 = new Uint8Array(m10.data), p4 = this._getTileEndAndContentType(c7, f5);
    if (0 === p4.recordSize)
      return null;
    const d5 = await this.request(l6, { range: { from: p4.position, to: p4.position + p4.recordSize }, responseType: "array-buffer", signal: i6.signal });
    if (!d5)
      return null;
    const [u8, h3] = this._getTileSize(a4);
    return this.decodePixelBlock(d5.data, { width: u8, height: h3, planes: null, pixelType: null, returnPixelInterleavedDims: a4 });
  }
  _validateHeader(e4) {
    const t5 = ["origin", "extent", "geodataXform", "LODInfos", "blockWidth", "blockHeight", "bandCount", "pixelType", "pixelSizeX", "pixelSizeY", "format", "packetSize"];
    return e4 && "RasterInfo" === e4.type && !t5.some((t6) => !e4[t6]);
  }
  _parseHeader(e4) {
    var _a;
    const t5 = ["u1", "u2", "u4", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"][e4.pixelType], { bandCount: r7, histograms: i6, colormap: o8, blockWidth: s4, blockHeight: f5, firstPyramidLevel: m10, maximumPyramidLevel: c7 } = e4, p4 = e4.statistics && e4.statistics.map((e5) => ({ min: e5.min, max: e5.max, avg: e5.mean, stddev: e5.standardDeviation, median: e5.median, mode: e5.mode })), d5 = e4.extent.spatialReference, y4 = (_a = e4.geodataXform) == null ? void 0 : _a.spatialReference, S8 = new k((d5 == null ? void 0 : d5.wkid) || (d5 == null ? void 0 : d5.wkt) ? d5 : y4);
    let I5 = new M({ xmin: e4.extent.xmin, ymin: e4.extent.ymin, xmax: e4.extent.xmax, ymax: e4.extent.ymax, spatialReference: S8 });
    const w3 = new j({ x: e4.pixelSizeX, y: e4.pixelSizeY, spatialReference: S8 }), _3 = Math.round((I5.xmax - I5.xmin) / w3.x), v4 = Math.round((I5.ymax - I5.ymin) / w3.y), b5 = this._parseTransform(e4.geodataXform), z2 = b5 ? I5 : null;
    b5 && (I5 = b5.forwardTransform(I5), w3.x = (I5.xmax - I5.xmin) / _3, w3.y = (I5.ymax - I5.ymin) / v4);
    const T = e4.properties ?? {}, k5 = e4.format.toLowerCase().replace("cache/", ""), j4 = new j(e4.origin.x, e4.origin.y, S8);
    let C2, R2, F3, P2;
    if (o8 && o8.colors)
      for (C2 = [], R2 = 0; R2 < o8.colors.length; R2++)
        F3 = o8.colors[R2], P2 = o8.values ? o8.values[R2] : R2, C2.push([P2, 255 & F3, F3 << 16 >>> 24, F3 << 8 >>> 24, F3 >>> 24]);
    const H3 = e4.LODInfos, D3 = [];
    for (R2 = 0; R2 < H3.levels.length; R2++)
      D3.push({ level: H3.levels[R2], resolution: H3.resolutions[R2], scale: 96 / 0.0254 * H3.resolutions[R2] });
    const L2 = new S2({ dpi: 96, lods: D3, format: k5, origin: j4, size: [s4, f5], spatialReference: S8 }), M3 = { recordSize: x5, packetSize: e4.packetSize, headerSize: e4.packetSize * e4.packetSize * x5 + 64 }, B3 = [{ maxCol: Math.ceil(_3 / s4) - 1, maxRow: Math.ceil(v4 / f5) - 1, minCol: 0, minRow: 0 }];
    let O2 = 2;
    if (c7 > 0)
      for (R2 = 0; R2 < c7; R2++)
        B3.push({ maxCol: Math.ceil(_3 / O2 / s4) - 1, maxRow: Math.ceil(v4 / O2 / f5) - 1, minCol: 0, minRow: 0 }), O2 *= 2;
    const $ = e4.mdInfo;
    let N3 = null;
    if ($ && T._yxs) {
      const e5 = T._yxs;
      N3 = { packetSize: e5.PacketSize, tileSize: [e5.TileXSize, e5.TileYSize] };
    }
    return { storageInfo: M3, rasterInfo: new l4({ width: _3, height: v4, pixelType: t5, bandCount: r7, extent: I5, nativeExtent: z2, transform: b5, spatialReference: S8, pixelSize: w3, keyProperties: T, statistics: p4, histograms: i6, multidimensionalInfo: $, colormap: C2, storageInfo: new p3({ blockWidth: s4, blockHeight: f5, pyramidBlockWidth: s4, pyramidBlockHeight: f5, origin: j4, tileInfo: L2, transposeInfo: N3, firstPyramidLevel: m10, maximumPyramidLevel: c7, blockBoundary: B3 }) }) };
  }
  _parseTransform(e4) {
    var _a, _b;
    if (!f2(e4))
      throw new s2("cloudraster:open", "the data contains unsupported geodata transform types");
    const r7 = i4(e4);
    if ("identity" === r7.type)
      return null;
    if ("polynomial" !== r7.type || !((_a = r7.forwardCoefficients) == null ? void 0 : _a.length) || !((_b = r7.inverseCoefficients) == null ? void 0 : _b.length))
      throw new s2("cloudraster:open", "the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");
    return r7;
  }
  async _fetchAuxiliaryInformation(e4) {
    const t5 = this.request(this.url + "/conf.vat.json", { signal: e4 }).then((e5) => e5.data).catch(() => null), r7 = this.request(this.url + "/conf.vat.dbf", { responseType: "array-buffer", signal: e4 }).then((e5) => e5.data).catch(() => null), i6 = await Promise.all([t5, r7]);
    let o8;
    if (i6[0]) {
      let e5 = i6[0].fields;
      const t6 = i6[0].values;
      if (e5 && t6) {
        e5 = e5.map((e6) => ({ type: "OID" === e6.name ? "esriFieldTypeOID" : y2.get(e6.type), name: e6.name, alias: e6.alias || e6.name }));
        const r8 = t6.map((e6) => ({ attributes: e6 }));
        e5 && t6 && (o8 = { fields: e5, features: r8 });
      }
    }
    if (!o8 && i6[1]) {
      o8 = r6.parse(i6[1]).recordSet;
    }
    return x.fromJSON(o8);
  }
  _buildCacheFilePath(e4, t5, i6, o8, s4) {
    const a4 = this._getPackageSize(!!s4), n8 = Math.floor(t5 / a4) * a4, l6 = Math.floor(i6 / a4) * a4, f5 = "R" + this._toHexString4(n8) + "C" + this._toHexString4(l6);
    let m10 = "L";
    m10 += e4 >= 10 ? e4.toString() : "0" + e4.toString();
    const { multidimensionalInfo: c7 } = this.rasterInfo, p4 = o8 == null ? void 0 : o8[0];
    if (t(c7) || !p4)
      return `${this.url}/_alllayers/${m10}/${f5}.bundle`;
    let d5 = "_yxs";
    if (!s4) {
      d5 = c7.variables.find((e6) => e6.name === p4.variableName).dimensions[0].values.indexOf(p4.values[0]).toString(16);
      const e5 = 4 - d5.length;
      for (let t6 = 0; t6 < e5; t6++)
        d5 = "0" + d5;
      d5 = "S" + d5;
    }
    const u8 = this._getVariableFolderName(s4 || p4.variableName);
    return `${this.url}/_alllayers/${u8}/${d5}/${m10}/${f5}.bundle`;
  }
  _getPackageSize(e4 = false) {
    const { transposeInfo: t5 } = this.rasterInfo.storageInfo;
    return e4 && r(t5) ? t5.packetSize : this.storageInfo.packetSize;
  }
  _getTileSize(e4 = false) {
    const { storageInfo: t5 } = this.rasterInfo, { transposeInfo: r7 } = t5;
    return e4 && r(r7) ? r7.tileSize : t5.tileInfo.size;
  }
  _getVariableFolderName(e4) {
    return "" === (e4 = e4.trim()) ? "_v" : e4.replace(/[\{|\}\-]/g, "_").replace("\\*", "_v");
  }
  _getIndexRecordFromBundle(e4, t5, r7 = false) {
    const i6 = this._getPackageSize(r7), o8 = i6 * (e4 % i6) + t5 % i6;
    if (o8 < 0)
      throw "Invalid level / row / col";
    return 20 + o8 * this.storageInfo.recordSize + 44;
  }
  _getTileEndAndContentType(e4, t5) {
    const r7 = e4.subarray(t5, t5 + 8);
    let i6, o8 = 0;
    for (i6 = 0; i6 < 5; i6++)
      o8 |= (255 & r7[i6]) << 8 * i6;
    const s4 = 1099511627775 & o8;
    for (o8 = 0, i6 = 5; i6 < 8; i6++)
      o8 |= (255 & r7[i6]) << 8 * (i6 - 5);
    return { position: s4, recordSize: 1099511627775 & o8 };
  }
  _toHexString4(e4) {
    let t5 = e4.toString(16);
    if (4 !== t5.length) {
      let e5 = 4 - t5.length;
      for (; e5-- > 0; )
        t5 = "0" + t5;
    }
    return t5;
  }
};
e([d({ readOnly: true })], S5.prototype, "storageInfo", void 0), e([d({ type: String, json: { write: true } })], S5.prototype, "datasetFormat", void 0), S5 = e([n("esri.layers.support.rasterDatasets.CloudRaster")], S5);
var I2 = S5;

// node_modules/@arcgis/core/layers/support/rasterDatasets/InMemoryRaster.js
var h2 = class extends J {
  constructor() {
    super(...arguments), this.datasetFormat = "MEMORY";
  }
  async open(t5) {
    await this.init();
    const { pixelBlock: e4, statistics: s4, histograms: r7, name: i6, keyProperties: o8, nativeExtent: m10, transform: n8 } = this.data, { width: l6, height: h3, pixelType: f5 } = e4, d5 = this.data.extent || new M({ xmin: -0.5, ymin: 0.5, xmax: l6 - 0.5, ymax: h3 - 0.5, spatialReference: new k({ wkid: 3857 }) }), u8 = this.data.isPseudoSpatialReference ?? !this.data.extent, y4 = { x: d5.width / l6, y: d5.height / h3 }, x6 = new l4({ width: l6, height: h3, pixelType: f5, extent: d5, nativeExtent: m10, transform: n8, pixelSize: y4, spatialReference: d5.spatialReference, bandCount: 3, keyProperties: o8 || {}, statistics: s4, isPseudoSpatialReference: u8, histograms: r7 });
    this.createRemoteDatasetStorageInfo(x6, 512, 512), this._set("rasterInfo", x6), this.updateTileInfo(), await this._buildInMemoryRaster(e4, { width: 512, height: 512 }, t5), this.datasetName = i6, this.url = "/InMemory/" + i6;
  }
  fetchRawTile(t5, e4, s4, r7 = {}) {
    const i6 = this._pixelBlockTiles.get(`${t5}/${e4}/${s4}`);
    return Promise.resolve(i6);
  }
  async _buildInMemoryRaster(t5, i6, o8) {
    var _a, _b;
    const a4 = this.rasterInfo.storageInfo.maximumPyramidLevel, m10 = this.rasterJobHandler ? this.rasterJobHandler.split({ pixelBlock: t5, tileSize: i6, maximumPyramidLevel: a4 }, o8) : Promise.resolve(M2(t5, i6, a4)), p4 = r(this.rasterInfo.statistics), c7 = r(this.rasterInfo.histograms), h3 = p4 ? Promise.resolve({ statistics: null, histograms: null }) : this.rasterJobHandler ? this.rasterJobHandler.estimateStatisticsHistograms({ pixelBlock: t5 }, o8) : Promise.resolve(m5(t5)), f5 = await E([m10, h3]);
    if (!f5[0].value && f5[1].value)
      throw new s2("inmemory-raster:open", "failed to build in memory raster");
    this._pixelBlockTiles = f5[0].value, p4 || (this.rasterInfo.statistics = (_a = f5[1].value) == null ? void 0 : _a.statistics), c7 || (this.rasterInfo.histograms = (_b = f5[1].value) == null ? void 0 : _b.histograms);
  }
};
e([d({ type: String, json: { write: true } })], h2.prototype, "datasetFormat", void 0), e([d()], h2.prototype, "data", void 0), h2 = e([n("esri.layers.support.rasterDatasets.InMemoryRaster")], h2);
var f3 = h2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/xmlUtilities.js
function n6(e4, t5) {
  if (!e4 || !t5)
    return [];
  let l6 = t5;
  t5.includes("/") ? (l6 = t5.slice(0, t5.indexOf("/")), t5 = t5.slice(t5.indexOf("/") + 1)) : t5 = "";
  const r7 = [];
  if (t5) {
    const u9 = n6(e4, l6);
    for (let e5 = 0; e5 < u9.length; e5++) {
      n6(u9[e5], t5).forEach((n8) => r7.push(n8));
    }
    return r7;
  }
  const u8 = e4.getElementsByTagNameNS("*", l6);
  if (!u8 || 0 === u8.length)
    return [];
  for (let n8 = 0; n8 < u8.length; n8++)
    r7.push(u8[n8] || u8.item[n8]);
  return r7;
}
function e3(t5, l6) {
  if (!t5 || !l6)
    return null;
  let r7 = l6;
  l6.includes("/") ? (r7 = l6.slice(0, l6.indexOf("/")), l6 = l6.slice(l6.indexOf("/") + 1)) : l6 = "";
  const u8 = n6(t5, r7);
  return u8.length > 0 ? l6 ? e3(u8[0], l6) : u8[0] : null;
}
function t4(n8, t5 = null) {
  const l6 = t5 ? e3(n8, t5) : n8;
  let r7;
  return l6 ? (r7 = l6.textContent || l6.nodeValue, r7 ? r7.trim() : null) : null;
}
function l5(e4, t5) {
  const l6 = n6(e4, t5), r7 = [];
  let u8;
  for (let n8 = 0; n8 < l6.length; n8++)
    u8 = l6[n8].textContent || l6[n8].nodeValue, u8 && (u8 = u8.trim(), "" !== u8 && r7.push(u8));
  return r7;
}
function u6(n8, e4) {
  return l5(n8, e4).map((n9) => Number(n9));
}
function o6(n8, e4) {
  const l6 = t4(n8, e4);
  return Number(l6);
}
function i5(n8, e4) {
  var _a;
  const t5 = (_a = n8 == null ? void 0 : n8.nodeName) == null ? void 0 : _a.toLowerCase(), l6 = e4.toLowerCase();
  return t5.slice(t5.lastIndexOf(":") + 1) === l6;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/pamParser.js
function o7(e4, t5) {
  if (!e4 || !t5)
    return null;
  const n8 = [];
  for (let s4 = 0; s4 < e4.length; s4++)
    n8.push(e4[s4]), n8.push(t5[s4]);
  return n8;
}
function u7(e4) {
  const n8 = e3(e4, "GeodataXform"), l6 = c5(o6(n8, "SpatialReference/WKID") || t4(n8, "SpatialReference/WKT"));
  if ("typens:PolynomialXform" !== n8.getAttribute("xsi:type"))
    return { spatialReference: l6, transform: null };
  const u8 = o6(n8, "PolynomialOrder") ?? 1, f5 = u6(n8, "CoeffX/Double"), m10 = u6(n8, "CoeffY/Double"), d5 = u6(n8, "InverseCoeffX/Double"), p4 = u6(n8, "InverseCoeffY/Double"), S8 = o7(f5, m10), C2 = o7(d5, p4);
  return { spatialReference: l6, transform: new m8({ spatialReference: l6, polynomialOrder: u8, forwardCoefficients: S8, inverseCoefficients: C2 }) };
}
function f4(e4) {
  var _a;
  const a4 = o6(e4, "NoDataValue"), i6 = e3(e4, "Histograms/HistItem"), l6 = o6(i6, "HistMin"), o8 = o6(i6, "HistMax"), u8 = o6(i6, "BucketCount"), f5 = (_a = t4(i6, "HistCounts")) == null ? void 0 : _a.split("|").map((e5) => Number(e5));
  let c7, m10, d5, p4;
  n6(e4, "Metadata/MDI").forEach((e5) => {
    const t5 = Number(e5.textContent ?? e5.nodeValue);
    switch (e5.getAttribute("key").toUpperCase()) {
      case "STATISTICS_MINIMUM":
        c7 = t5;
        break;
      case "STATISTICS_MAXIMUM":
        m10 = t5;
        break;
      case "STATISTICS_MEAN":
        d5 = t5;
        break;
      case "STATISTICS_STDDEV":
        p4 = t5;
    }
  });
  const S8 = o6(e4, "Metadata/SourceBandIndex");
  return { noDataValue: a4, histogram: (f5 == null ? void 0 : f5.length) && null != c7 && null != m10 ? { min: l6, max: o8, size: u8 || f5.length, counts: f5 } : null, sourceBandIndex: S8, statistics: null != c7 && null != m10 ? { min: c7, max: m10, avg: d5, stddev: p4 } : null };
}
function c5(e4) {
  if (!e4)
    return null;
  let t5 = Number(e4);
  if (!isNaN(t5) && 0 !== t5)
    return new k({ wkid: t5 });
  if ((e4 = String(e4)).startsWith("COMPD_CS")) {
    if (!e4.includes("VERTCS") || !e4.includes("GEOGCS") && !e4.startsWith("PROJCS"))
      return null;
    const n8 = e4.indexOf("VERTCS"), s4 = e4.indexOf("PROJCS"), r7 = s4 > -1 ? s4 : e4.indexOf("GEOGCS");
    if (-1 === r7)
      return null;
    const a4 = e4.slice(r7, e4.lastIndexOf("]", n8) + 1).trim(), i6 = e4.slice(n8, e4.lastIndexOf("]")).trim();
    t5 = m9(a4);
    const o8 = new k(t5 ? { wkid: t5 } : { wkt: a4 }), u8 = m9(i6);
    return u8 && (o8.vcsWkid = u8), o8;
  }
  return e4.startsWith("GEOGCS") || e4.startsWith("PROJCS") ? (t5 = m9(e4), new k(0 !== t5 ? { wkid: t5 } : { wkt: e4 })) : null;
}
function m9(e4) {
  var _a;
  const t5 = e4.replace(/\]/g, "[").replace(/\"/g, "").split("[").map((e5) => e5.trim()).filter((e5) => "" !== e5), n8 = t5[t5.length - 1].split(","), s4 = (_a = n8[0]) == null ? void 0 : _a.toLowerCase();
  if (("epsg" === s4 || "esri" === s4) && e4.endsWith('"]]')) {
    const e5 = Number(n8[1]);
    if (!isNaN(e5) && 0 !== e5)
      return e5;
  }
  return 0;
}
function d4(s4) {
  var _a;
  if ("pamdataset" !== ((_a = s4 == null ? void 0 : s4.documentElement.tagName) == null ? void 0 : _a.toLowerCase()))
    return {};
  const r7 = { spatialReference: null, transform: null, metadata: {}, rasterBands: [], statistics: null, histograms: null };
  s4.documentElement.childNodes.forEach((s5) => {
    if (1 === s5.nodeType) {
      if (i5(s5, "SRS")) {
        if (!r7.spatialReference) {
          const e4 = t4(s5);
          r7.spatialReference = c5(e4);
        }
      } else if (i5(s5, "Metadata"))
        if ("xml:ESRI" === s5.getAttribute("domain")) {
          const { spatialReference: e4, transform: t5 } = u7(s5);
          r7.transform = t5, r7.spatialReference || (r7.spatialReference = e4);
        } else {
          n6(s5, "MDI").forEach((e4) => r7.metadata[e4.getAttribute("key")] = t4(e4));
        }
      else if (i5(s5, "PAMRasterBand")) {
        const e4 = f4(s5);
        null != e4.sourceBandIndex && null == r7.rasterBands[e4.sourceBandIndex] ? r7.rasterBands[e4.sourceBandIndex] = e4 : r7.rasterBands.push(e4);
      }
    }
  });
  const a4 = r7.rasterBands;
  if (a4) {
    const e4 = !!a4[0].statistics;
    r7.statistics = e4 ? a4.map((e5) => e5.statistics) : null;
    const t5 = !!a4[0].histogram;
    r7.histograms = t5 ? a4.map((e5) => e5.histogram) : null;
  }
  return r7;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageAuxRaster.js
var y3 = class extends J {
  async open(t5) {
    await this.init();
    const s4 = await this._fetchData(t5);
    let { spatialReference: e4, statistics: r7, histograms: a4, transform: o8 } = await this._fetchAuxiliaryData(t5);
    const i6 = !e4;
    i6 && (e4 = new k({ wkid: 3857 })), (a4 == null ? void 0 : a4.length) && null == r7 && (r7 = c3(a4));
    const { width: n8, height: m10 } = s4;
    let p4 = new M({ xmin: -0.5, ymin: 0.5 - m10, xmax: n8 - 0.5, ymax: 0.5, spatialReference: e4 });
    const c7 = o8 ? o8.forwardTransform(p4) : p4;
    let u8 = true;
    if (o8) {
      const t6 = o8.forwardCoefficients;
      u8 = t6 && 0 === t6[1] && 0 === t6[2], u8 && (o8 = null, p4 = c7);
    }
    const y4 = new f3({ data: { extent: c7, nativeExtent: p4, transform: o8, pixelBlock: s4, statistics: r7, histograms: a4, keyProperties: { DateType: "Processed" }, isPseudoSpatialReference: i6 } });
    await y4.open(), y4.data = null, this._set("rasterInfo", y4.rasterInfo), this._inMemoryRaster = y4;
  }
  fetchRawTile(t5, s4, e4, r7 = {}) {
    return this._inMemoryRaster.fetchRawTile(t5, s4, e4, r7);
  }
  async _fetchData(t5) {
    const { data: r7 } = await this.request(this.url, { responseType: "array-buffer", signal: t5 == null ? void 0 : t5.signal }), a4 = P(r7).toUpperCase();
    if ("JPG" !== a4 && "PNG" !== a4 && "GIF" !== a4 && "BMP" !== a4)
      throw new s2("image-aux-raster:open", "the data is not a supported format");
    this._set("datasetFormat", a4);
    const o8 = a4.toLowerCase(), i6 = "gif" === o8 || "bmp" === o8 || !a("ios");
    return await this.decodePixelBlock(r7, { format: o8, useCanvas: i6, hasNoZlibMask: true });
  }
  async _fetchAuxiliaryData(t5) {
    var _a;
    const s4 = e2(t5 == null ? void 0 : t5.signal), e4 = this.ioConfig.skipExtensions ?? [], i6 = e4.includes("aux.xml") ? null : this.request(this.url + ".aux.xml", { responseType: "xml", signal: s4 }), n8 = this.datasetFormat, m10 = "JPG" === n8 ? "jgw" : "PNG" === n8 ? "pgw" : "BMP" === n8 ? "bpw" : null, l6 = e4.includes(m10) ? null : this.request(this.url.slice(0, this.url.lastIndexOf(".")) + "." + m10, { responseType: "text", signal: s4 }), c7 = await E([i6, l6]);
    if (s4 == null ? void 0 : s4.aborted)
      throw m();
    const f5 = d4((_a = c7[0].value) == null ? void 0 : _a.data);
    if (!f5.transform) {
      const t6 = c7[1].value ? c7[1].value.data.split("\n").slice(0, 6).map((t7) => Number(t7)) : null;
      f5.transform = 6 === (t6 == null ? void 0 : t6.length) ? new m8({ forwardCoefficients: [t6[4], t6[5], t6[0], -t6[1], t6[2], -t6[3]] }) : null;
    }
    return f5;
  }
};
e([d({ type: String, json: { write: true } })], y3.prototype, "datasetFormat", void 0), y3 = e([n("esri.layers.support.rasterDatasets.ImageAuxRaster")], y3);
var w2 = y3;

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageServerRaster.js
var S6 = class extends J {
  constructor() {
    super(...arguments), this._levelOffset = 0, this._tilemapCache = null, this._slices = null, this.datasetFormat = "RasterTileServer";
  }
  async open(e4) {
    var _a;
    await this.init();
    const s4 = e4 && e4.signal, a4 = this.sourceJSON ? { data: this.sourceJSON } : await this.request(this.url, { query: { f: "json" }, signal: s4 });
    a4.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
    const l6 = a4.data;
    if (this.sourceJSON = l6, !l6)
      throw new s2("imageserverraster:open", "cannot initialize tiled image service, missing service info");
    if (!l6.tileInfo)
      throw new s2("imageserverraster:open", "use ImageryLayer to open non-tiled image services");
    this._fixScaleInServiceInfo();
    const o8 = ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"];
    this.tileType = l6.cacheType, null == this.tileType && (o8.includes(l6.tileInfo.format.toLowerCase()) ? this.tileType = "Map" : "lerc" === l6.tileInfo.format.toLowerCase() ? this.tileType = "Elevation" : this.tileType = "Raster"), this.datasetName = l6.name.slice(l6.name.indexOf("/") + 1);
    const n8 = await this._fetchRasterInfo({ signal: s4 });
    if (!r(n8))
      throw new s2("image-server-raster:open", "cannot initialize image service");
    {
      const e5 = "Map" === this.tileType ? n3(l6.tileInfo, l6) : S2.fromJSON(l6.tileInfo), { extent: t5, pixelSize: i6 } = n8, s5 = 0.5 / n8.width * i6.x;
      let a5, r7;
      const o9 = e5.lodAt(Math.max.apply(null, e5.lods.map((e6) => e6.level)));
      "Map" !== this.tileType && 0 !== l6.maxScale && ("Raster" === this.tileType ? (a5 = e5.lods.find((e6) => e6.resolution === i6.x), a5 || (a5 = e5.lods[e5.lods.length - 1])) : (a5 = e5.lods.find((e6) => Math.abs(e6.scale - l6.maxScale) < s5), a5 || (a5 = e5.lods.filter((e6) => e6.scale > l6.maxScale).sort((e6, t6) => e6.scale > t6.scale ? 1 : -1)[0])), i6.x = i6.y = a5.resolution, n8.width = Math.ceil((t5.xmax - t5.xmin) / i6.x - 0.1), n8.height = Math.ceil((t5.ymax - t5.ymin) / i6.y - 0.1)), a5 || (a5 = o9);
      const p4 = e5.lodAt(Math.min.apply(null, e5.lods.map((e6) => e6.level)));
      "Map" === this.tileType ? this._levelOffset = e5.lods[0].level : 0 !== l6.minScale && "Elevation" === this.tileType && (r7 = e5.lods.find((e6) => Math.abs(e6.scale - l6.minScale) < s5), this._levelOffset = r7.level - p4.level), r7 || (r7 = p4);
      const f5 = Math.max(i6.x, i6.y);
      (Math.abs(i6.x - i6.y) > s5 || !e5.lods.some((e6) => Math.abs(e6.resolution - f5) < s5)) && (i6.x = i6.y = a5.resolution, n8.width = Math.ceil((t5.xmax - t5.xmin) / i6.x - 0.1), n8.height = Math.ceil((t5.ymax - t5.ymin) / i6.y - 0.1));
      const u8 = a5.level - r7.level, [y4, d5] = e5.size, x6 = [];
      e5.lods.forEach((e6) => {
        e6.level >= r7.level && e6.level <= a5.level && x6.push({ x: e6.resolution, y: e6.resolution });
      }), x6.sort((e6, t6) => e6.x - t6.x);
      const g = this.computeBlockBoundary(t5, y4, d5, e5.origin, x6, u8), v4 = x6.length > 1 ? x6.slice(1) : null;
      let S8;
      l6.transposeInfo && (S8 = { tileSize: [l6.transposeInfo.rows, l6.transposeInfo.cols], packetSize: ((_a = n8.keyProperties) == null ? void 0 : _a._yxs.PacketSize) ?? 0 }), n8.storageInfo = new p3({ blockWidth: e5.size[0], blockHeight: e5.size[1], pyramidBlockWidth: e5.size[0], pyramidBlockHeight: e5.size[1], pyramidResolutions: v4, compression: e5.format, origin: e5.origin, firstPyramidLevel: 1, maximumPyramidLevel: u8, tileInfo: e5, transposeInfo: S8, blockBoundary: g }), this._fixGCSShift(n8), this._set("rasterInfo", n8);
    }
    if (l6.capabilities.toLowerCase().includes("tilemap")) {
      const e5 = { tileInfo: n8.storageInfo.tileInfo, parsedUrl: j2(this.url), url: this.url, tileServers: [], type: "tile" };
      this._tilemapCache = new z({ layer: e5 });
    }
  }
  async fetchRawTile(e4, t5, s4, a4 = {}) {
    const { storageInfo: r7, extent: l6 } = this.rasterInfo, { transposeInfo: o8 } = r7, n8 = r(o8) && !!a4.transposedVariableName;
    if (this._slices && !n8 && null == a4.sliceId)
      return null;
    const c7 = n8 ? 0 : r7.maximumPyramidLevel - e4 + this._levelOffset, m10 = `${this.url}/tile/${c7}/${t5}/${s4}`, h3 = this._slices ? n8 ? { variable: a4.transposedVariableName } : { sliceId: a4.sliceId || 0 } : null, { data: p4 } = await this.request(m10, { query: h3, responseType: "array-buffer", signal: a4.signal });
    if (!p4)
      return null;
    const f5 = n8 ? o8.tileSize : r7.tileInfo.size, y4 = await this.decodePixelBlock(p4, { width: f5[0], height: f5[1], planes: null, pixelType: null, isPoint: "Elevation" === this.tileType, returnPixelInterleavedDims: n8 }), d5 = r7.blockBoundary[e4];
    if ("jpg" !== r7.compression || s4 > d5.minCol && s4 < d5.maxCol && t5 > d5.minRow && t5 < d5.maxRow)
      return y4;
    const { origin: x6, blockWidth: g, blockHeight: v4 } = r7, { x: S8, y: I5 } = this.getPyramidPixelSize(e4), w3 = Math.round((l6.xmin - x6.x) / S8) % g, j4 = Math.round((l6.xmax - x6.x) / S8) % g || g, T = Math.round((x6.y - l6.ymax) / I5) % v4, b5 = Math.round((x6.y - l6.ymin) / I5) % v4 || v4, _3 = s4 === d5.minCol ? w3 : 0, M3 = t5 === d5.minRow ? T : 0, R2 = s4 === d5.maxCol ? j4 : g, P2 = t5 === d5.maxRow ? b5 : v4;
    return x2(y4, { x: _3, y: M3 }, { width: R2 - _3, height: P2 - M3 }), y4;
  }
  getSliceIndex(e4) {
    if (!this._slices || t(e4) || 0 === e4.length)
      return null;
    const t5 = e4;
    for (let i6 = 0; i6 < this._slices.length; i6++) {
      const e5 = this._slices[i6].multidimensionalDefinition;
      if (e5.length === t5.length && !e5.some((e6) => {
        const i7 = t5.find((t6) => e6.variableName === t6.variableName && t6.dimensionName === e6.dimensionName);
        if (!i7)
          return true;
        return (Array.isArray(e6.values[0]) ? `${e6.values[0][0]}-${e6.values[0][1]}` : e6.values[0]) !== (Array.isArray(i7.values[0]) ? `${i7.values[0][0]}-${i7.values[0][1]}` : i7.values[0]);
      }))
        return i6;
    }
    return null;
  }
  async fetchVariableStatisticsHistograms(e4, t5) {
    const i6 = this.request(this.url + "/statistics", { query: { variable: e4, f: "json" }, signal: t5 }).then((e5) => {
      var _a;
      return (_a = e5.data) == null ? void 0 : _a.statistics;
    }), s4 = this.request(this.url + "/histograms", { query: { variable: e4, f: "json" }, signal: t5 }).then((e5) => {
      var _a;
      return (_a = e5.data) == null ? void 0 : _a.histograms;
    }), a4 = await Promise.all([i6, s4]);
    return a4[0] && a4[0].forEach((e5) => {
      e5.avg = e5.mean, e5.stddev = e5.standardDeviation;
    }), { statistics: a4[0] || null, histograms: a4[1] || null };
  }
  async computeBestPyramidLevelForLocation(e4, t5 = {}) {
    if (!this._tilemapCache)
      return 0;
    let i6 = this.identifyPixelLocation(e4, 0, e2(t5.datumTransformation));
    if (null === i6)
      return null;
    let s4 = 0;
    const { maximumPyramidLevel: r7 } = this.rasterInfo.storageInfo;
    let l6 = r7 - s4 + this._levelOffset;
    const o8 = i6.srcLocation;
    for (; l6 >= 0; ) {
      try {
        if ("available" === await this._tilemapCache.fetchAvailability(l6, i6.row, i6.col, t5))
          break;
      } catch {
      }
      if (l6--, s4++, i6 = this.identifyPixelLocation(o8, s4, e2(t5.datumTransformation)), null === i6)
        return null;
    }
    return -1 === l6 || null == i6 ? null : s4;
  }
  async _fetchRasterInfo(e4) {
    const t5 = this.sourceJSON;
    if ("Map" === this.tileType) {
      const e5 = Math.ceil((t5.extent.xmax - t5.extent.xmin) / t5.pixelSizeX - 0.1), i7 = Math.ceil((t5.extent.ymax - t5.extent.ymin) / t5.pixelSizeY - 0.1), s5 = k.fromJSON(t5.spatialReference || t5.extent.spatialReference), a5 = new j({ x: t5.pixelSizeX, y: t5.pixelSizeY, spatialReference: s5 });
      return new l4({ width: e5, height: i7, bandCount: 3, extent: M.fromJSON(t5.extent), spatialReference: s5, pixelSize: a5, pixelType: "u8", statistics: null, keyProperties: { DataType: "processed" } });
    }
    const { signal: i6 } = e4, s4 = m6(this.url, this.sourceJSON, { signal: i6, query: this.ioConfig.customFetchParameters }), a4 = t5.hasMultidimensions ? this.request(`${this.url}/slices`, { query: { f: "json" }, signal: i6 }).then((e5) => e5.data && e5.data.slices).catch(() => null) : null, r7 = await Promise.all([s4, a4]);
    return this._slices = r7[1], r7[0];
  }
  _fixScaleInServiceInfo() {
    const { sourceJSON: e4 } = this;
    e4.minScale && e4.minScale < 0 && (e4.minScale = 0), e4.maxScale && e4.maxScale < 0 && (e4.maxScale = 0);
  }
  _fixGCSShift(e4) {
    const { extent: t5, spatialReference: i6 } = e4;
    0 === t5.xmin && 360 === t5.xmax && i6.wkid && i6.isGeographic && (e4.nativeExtent = e4.extent, e4.transform = new c4(), e4.extent = e4.transform.forwardTransform(t5));
  }
};
e([d({ type: String, json: { write: true } })], S6.prototype, "datasetFormat", void 0), e([d()], S6.prototype, "tileType", void 0), S6 = e([n("esri.layers.support.rasterDatasets.ImageServerRaster")], S6);
var I3 = S6;

// node_modules/@arcgis/core/layers/support/rasterDatasets/MRFRaster.js
var I4 = /* @__PURE__ */ new Map();
I4.set("Int8", "s8"), I4.set("UInt8", "u8"), I4.set("Int16", "s16"), I4.set("UInt16", "u16"), I4.set("Int32", "s32"), I4.set("UInt32", "u32"), I4.set("Float32", "f32"), I4.set("Float64", "f32"), I4.set("Double64", "f32");
var b3 = /* @__PURE__ */ new Map();
b3.set("none", { blobExtension: ".til", isOneSegment: true, decoderFormat: "bip" }), b3.set("lerc", { blobExtension: ".lrc", isOneSegment: false, decoderFormat: "lerc" }), b3.set("deflate", { blobExtension: ".pzp", isOneSegment: true, decoderFormat: "deflate" }), b3.set("jpeg", { blobExtension: ".pjg", isOneSegment: true, decoderFormat: "jpg" });
var A = class extends J {
  constructor() {
    super(...arguments), this._files = null, this._storageIndex = null, this.datasetFormat = "MRF";
  }
  async open(t5) {
    var _a;
    await this.init(), this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const e4 = t5 ? e2(t5.signal) : null, o8 = await this.request(this.url, { responseType: "xml", signal: e4 }), { rasterInfo: i6, files: a4 } = this._parseHeader(o8.data);
    if (-1 === ((_a = this.ioConfig.skipExtensions) == null ? void 0 : _a.indexOf("aux.xml"))) {
      const e5 = await this._fetchAuxiliaryData(t5);
      null != e5 && (i6.statistics = e5.statistics ?? i6.statistics, i6.histograms = e5.histograms, e5.histograms && t(i6.statistics) && (i6.statistics = c3(e5.histograms)));
    }
    this._set("rasterInfo", i6), this._files = a4;
    const n8 = await this.request(a4.index, { responseType: "array-buffer", signal: e4 });
    this._storageIndex = this._parseIndex(n8.data);
    const { blockWidth: l6, blockHeight: f5 } = this.rasterInfo.storageInfo, c7 = this.rasterInfo.storageInfo.pyramidScalingFactor, { width: m10, height: p4 } = this.rasterInfo, h3 = [], u8 = this._getBandSegmentCount();
    let g = 0, y4 = -1;
    for (; g < this._storageIndex.length; ) {
      y4++;
      const t6 = Math.ceil(m10 / l6 / c7 ** y4) - 1, e5 = Math.ceil(p4 / f5 / c7 ** y4) - 1;
      g += (t6 + 1) * (e5 + 1) * u8 * 4, h3.push({ maxRow: e5, maxCol: t6, minCol: 0, minRow: 0 });
    }
    this.rasterInfo.storageInfo.blockBoundary = h3, y4 > 0 && (this.rasterInfo.storageInfo.firstPyramidLevel = 1, this.rasterInfo.storageInfo.maximumPyramidLevel = y4), this.updateTileInfo();
  }
  async fetchRawTile(t5, e4, r7, s4 = {}) {
    const { blockWidth: i6, blockHeight: a4, blockBoundary: l6 } = this.rasterInfo.storageInfo, f5 = l6[t5];
    if (!f5 || f5.maxRow < e4 || f5.maxCol < r7 || f5.minRow > e4 || f5.minCol > r7)
      return null;
    const { bandCount: c7, pixelType: m10 } = this.rasterInfo, { ranges: p4, actualTileWidth: h3, actualTileHeight: u8 } = this._getTileLocation(t5, e4, r7);
    if (!p4 || 0 === p4.length)
      return null;
    if (0 === p4[0].from && 0 === p4[0].to) {
      const t6 = new Uint8Array(i6 * a4);
      return new u({ width: i6, height: a4, pixels: null, mask: t6, validPixelCount: 0 });
    }
    const { bandIds: g } = this.ioConfig, d5 = this._getBandSegmentCount(), y4 = [];
    let x6 = 0;
    for (x6 = 0; x6 < d5; x6++)
      (!g || g.indexOf[x6] > -1) && y4.push(this.request(this._files.data, { range: { from: p4[x6].from, to: p4[x6].to }, responseType: "array-buffer", signal: s4.signal }));
    const w3 = await Promise.all(y4), I5 = w3.map((t6) => t6.data.byteLength).reduce((t6, e5) => t6 + e5), A2 = new Uint8Array(I5);
    let F3 = 0;
    for (x6 = 0; x6 < d5; x6++)
      A2.set(new Uint8Array(w3[x6].data), F3), F3 += w3[x6].data.byteLength;
    const _3 = b3.get(this.rasterInfo.storageInfo.compression).decoderFormat, R2 = await this.decodePixelBlock(A2.buffer, { width: i6, height: a4, format: _3, planes: (g == null ? void 0 : g.length) || c7, pixelType: m10 });
    if (r(this.rasterInfo.noDataValue) && "lerc" !== _3 && !R2.mask) {
      const t6 = this.rasterInfo.noDataValue[0];
      if (null != t6) {
        const e5 = R2.width * R2.height, r8 = new Uint8Array(e5);
        if (Math.abs(t6) > 1e24)
          for (x6 = 0; x6 < e5; x6++)
            Math.abs((R2.pixels[0][x6] - t6) / t6) > 1e-6 && (r8[x6] = 1);
        else
          for (x6 = 0; x6 < e5; x6++)
            R2.pixels[0][x6] !== t6 && (r8[x6] = 1);
        R2.mask = r8;
      }
    }
    let j4 = 0, k5 = 0;
    if (h3 !== i6 || u8 !== a4) {
      let t6 = R2.mask;
      if (t6)
        for (x6 = 0; x6 < a4; x6++)
          if (k5 = x6 * i6, x6 < u8)
            for (j4 = h3; j4 < i6; j4++)
              t6[k5 + j4] = 0;
          else
            for (j4 = 0; j4 < i6; j4++)
              t6[k5 + j4] = 0;
      else
        for (t6 = new Uint8Array(i6 * a4), R2.mask = t6, x6 = 0; x6 < u8; x6++)
          for (k5 = x6 * i6, j4 = 0; j4 < h3; j4++)
            t6[k5 + j4] = 1;
    }
    return R2;
  }
  _parseIndex(t5) {
    if (t5.byteLength % 16 > 0)
      throw "invalid array buffer must be multiples of 16";
    let e4, r7, s4, o8, i6, a4;
    if (r5) {
      for (r7 = new Uint8Array(t5), o8 = new ArrayBuffer(t5.byteLength), s4 = new Uint8Array(o8), i6 = 0; i6 < t5.byteLength / 4; i6++)
        for (a4 = 0; a4 < 4; a4++)
          s4[4 * i6 + a4] = r7[4 * i6 + 3 - a4];
      e4 = new Uint32Array(o8);
    } else
      e4 = new Uint32Array(t5);
    return e4;
  }
  _getBandSegmentCount() {
    return b3.get(this.rasterInfo.storageInfo.compression).isOneSegment ? 1 : this.rasterInfo.bandCount;
  }
  _getTileLocation(t5, e4, r7) {
    const { blockWidth: s4, blockHeight: o8, pyramidScalingFactor: i6 } = this.rasterInfo.storageInfo, { width: a4, height: n8 } = this.rasterInfo, l6 = this._getBandSegmentCount();
    let f5, c7, m10, p4 = 0, h3 = 0;
    for (m10 = 0; m10 < t5; m10++)
      h3 = i6 ** m10, f5 = Math.ceil(a4 / s4 / h3), c7 = Math.ceil(n8 / o8 / h3), p4 += f5 * c7;
    h3 = i6 ** t5, f5 = Math.ceil(a4 / s4 / h3), c7 = Math.ceil(n8 / o8 / h3), p4 += e4 * f5 + r7, p4 *= 4 * l6;
    const u8 = this._storageIndex.subarray(p4, p4 + 4 * l6);
    let g = 0, d5 = 0;
    const y4 = [];
    for (let x6 = 0; x6 < l6; x6++)
      g = u8[4 * x6 + 0] * 2 ** 32 + u8[4 * x6 + 1], d5 = g + u8[4 * x6 + 2] * 2 ** 32 + u8[4 * x6 + 3], y4.push({ from: g, to: d5 });
    return { ranges: y4, actualTileWidth: r7 < f5 - 1 ? s4 : Math.ceil(a4 / h3) - s4 * (f5 - 1), actualTileHeight: e4 < c7 - 1 ? o8 : Math.ceil(n8 / h3) - o8 * (c7 - 1) };
  }
  _parseHeader(t5) {
    const r7 = e3(t5, "MRF_META/Raster");
    if (!r7)
      throw new s2("mrf:open", "not a valid MRF format");
    const s4 = e3(r7, "Size"), o8 = parseInt(s4.getAttribute("x"), 10), i6 = parseInt(s4.getAttribute("y"), 10), a4 = parseInt(s4.getAttribute("c"), 10), n8 = (t4(r7, "Compression") || "none").toLowerCase();
    if (!b3.has(n8))
      throw new s2("mrf:open", "currently does not support compression " + n8);
    const c7 = t4(r7, "DataType") || "UInt8", p4 = I4.get(c7);
    if (null == p4)
      throw new s2("mrf:open", "currently does not support pixel type " + c7);
    const g = e3(r7, "PageSize"), d5 = parseInt(g.getAttribute("x"), 10), A2 = parseInt(g.getAttribute("y"), 10), F3 = e3(r7, "DataValues");
    let _3, R2;
    F3 && (R2 = F3.getAttribute("NoData"), null != R2 && (_3 = R2.trim().split(" ").map((t6) => parseFloat(t6))));
    if (e3(t5, "MRF_META/CachedSource"))
      throw new s2("mrf:open", "currently does not support MRF referencing other data files");
    const j4 = e3(t5, "MRF_META/GeoTags"), k5 = e3(j4, "BoundingBox");
    let M3, S8 = false;
    if (null != k5) {
      const t6 = parseFloat(k5.getAttribute("minx")), e4 = parseFloat(k5.getAttribute("miny")), r8 = parseFloat(k5.getAttribute("maxx")), s5 = parseFloat(k5.getAttribute("maxy")), o9 = t4(j4, "Projection") || "";
      let i7;
      if ("LOCAL_CS[]" !== o9)
        if (o9.toLowerCase().startsWith("epsg:")) {
          const t7 = Number(o9.slice(5));
          isNaN(t7) || 0 === t7 || (i7 = new k({ wkid: t7 }));
        } else
          i7 = c5(o9);
      else
        S8 = true, i7 = new k({ wkid: 3857 });
      M3 = new M(t6, e4, r8, s5), M3.spatialReference = i7;
    } else
      S8 = true, M3 = new M({ xmin: -0.5, ymin: 0.5 - i6, xmax: o8 - 0.5, ymax: 0.5, spatialReference: new k({ wkid: 3857 }) });
    const T = e3(t5, "MRF_META/Rsets"), C2 = parseInt(T && T.getAttribute("scale") || "2", 10), U4 = M3.spatialReference, B3 = new p3({ origin: new j({ x: M3.xmin, y: M3.ymax, spatialReference: U4 }), blockWidth: d5, blockHeight: A2, pyramidBlockWidth: d5, pyramidBlockHeight: A2, compression: n8, pyramidScalingFactor: C2 }), L2 = new j({ x: M3.width / o8, y: M3.height / i6, spatialReference: U4 }), E3 = new l4({ width: o8, height: i6, extent: M3, isPseudoSpatialReference: S8, spatialReference: U4, bandCount: a4, pixelType: p4, pixelSize: L2, noDataValue: _3, storageInfo: B3 }), P2 = t4(t5, "datafile"), O2 = t4(t5, "IndexFile");
    return { rasterInfo: E3, files: { mrf: this.url, index: O2 || this.url.replace(".mrf", ".idx"), data: P2 || this.url.replace(".mrf", b3.get(n8).blobExtension) } };
  }
  async _fetchAuxiliaryData(t5) {
    try {
      const { data: e4 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: t5 == null ? void 0 : t5.signal });
      return d4(e4);
    } catch {
      return null;
    }
  }
};
e([d()], A.prototype, "_files", void 0), e([d()], A.prototype, "_storageIndex", void 0), e([d({ type: String, json: { write: true } })], A.prototype, "datasetFormat", void 0), A = e([n("esri.layers.support.rasterIO.MRFRaster")], A);
var F2 = A;

// node_modules/@arcgis/core/layers/support/rasterDatasets/TIFFRaster.js
var _2 = (e4, t5) => {
  const r7 = e4.get(t5);
  return r7 && r7.values;
};
var b4 = (e4, t5) => {
  const r7 = e4.get(t5);
  return r7 && r7.values[0];
};
var E2 = class extends J {
  constructor() {
    super(...arguments), this._files = null, this._headerInfo = null, this._bufferSize = 1048576, this.datasetFormat = "TIFF";
  }
  async open(e4) {
    var _a, _b, _c;
    await this.init();
    const s4 = e4 ? e2(e4.signal) : null, { data: a4 } = await this.request(this.url, { range: { from: 0, to: this._bufferSize }, responseType: "array-buffer", signal: s4 });
    if (!a4)
      throw new s2("tiffraster:open", "failed to open url " + this.url);
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const { littleEndian: f5, firstIFD: m10, isBigTiff: c7 } = N(a4), h3 = [];
    await this._readIFDs(h3, a4, f5, m10, 0, c7 ? 8 : 4, s4);
    const d5 = b2(h3), { width: y4, height: _3, tileWidth: b5, tileHeight: E3, planes: S8, pixelType: F3, compression: R2, firstPyramidLevel: k5, maximumPyramidLevel: v4, pyramidBlockWidth: j4, pyramidBlockHeight: B3, tileBoundary: D3, affine: L2, metadata: z2 } = d5, O2 = ((_a = d5.extent.spatialReference) == null ? void 0 : _a.wkt) || ((_b = d5.extent.spatialReference) == null ? void 0 : _b.wkid);
    let P2 = c5(O2), H3 = false;
    null == P2 && (H3 = true, P2 = new k({ wkid: 3857 }));
    const A2 = new M({ ...d5.extent, spatialReference: P2 }), G2 = new j(A2 ? { x: A2.xmin, y: A2.ymax, spatialReference: P2 } : { x: 0, y: 0 }), q2 = new p3({ blockWidth: b5, blockHeight: E3, pyramidBlockWidth: j4, pyramidBlockHeight: B3, compression: R2, origin: G2, firstPyramidLevel: k5, maximumPyramidLevel: v4, blockBoundary: D3 }), C2 = new j({ x: (A2.xmax - A2.xmin) / y4, y: (A2.ymax - A2.ymin) / _3, spatialReference: P2 }), W = z2 ? { BandProperties: z2.bandProperties, DataType: z2.dataType } : {}, U4 = new l4({ width: y4, height: _3, bandCount: S8, pixelType: F3, compression: R2, pixelSize: C2, storageInfo: q2, spatialReference: P2, isPseudoSpatialReference: H3, keyProperties: W, extent: A2, statistics: z2 ? z2.statistics : null });
    if ((L2 == null ? void 0 : L2.length) && (U4.nativeExtent = new M({ xmin: -0.5, ymin: 0.5 - _3, xmax: y4 - 0.5, ymax: 0.5, spatialReference: P2 }), U4.transform = new m8({ polynomialOrder: 1, forwardCoefficients: [L2[2] + L2[0] / 2, L2[5] - L2[3] / 2, L2[0], L2[3], -L2[1], -L2[4]] }), U4.extent = U4.transform.forwardTransform(U4.nativeExtent), U4.pixelSize = new j({ x: (A2.xmax - A2.xmin) / y4, y: (A2.ymax - A2.ymin) / _3, spatialReference: P2 }), q2.origin.x = -0.5, q2.origin.y = 0.5), !((_c = this.ioConfig.skipExtensions) == null ? void 0 : _c.includes("aux.xml"))) {
      const t5 = await this._fetchAuxiliaryData(e4);
      if (null != t5) {
        if (U4.statistics = t5.statistics ?? U4.statistics, U4.histograms = t5.histograms, t5.histograms && t(U4.statistics) && (U4.statistics = c3(t5.histograms)), t5.transform && !L2) {
          U4.transform = t5.transform, U4.nativeExtent = U4.extent;
          const e5 = U4.transform.forwardTransform(U4.nativeExtent);
          U4.pixelSize = new j({ x: (e5.xmax - e5.xmin) / y4, y: (e5.ymax - e5.ymin) / _3, spatialReference: P2 }), U4.extent = e5;
        }
        U4.spatialReference || (U4.spatialReference = t5.spatialReference);
      }
    }
    if (this._set("rasterInfo", U4), this._headerInfo = { littleEndian: f5, isBigTiff: c7, ifds: h3, ...d5 }, !this._headerInfo.isSupported)
      throw new s2("tiffraster:open", "this tiff is not supported: " + this._headerInfo.message);
    this.updateTileInfo();
  }
  async fetchRawTile(e4, t5, r7, i6 = {}) {
    var _a;
    if (!((_a = this._headerInfo) == null ? void 0 : _a.isSupported) || this.isBlockOutside(e4, t5, r7))
      return null;
    const s4 = this._getTileLocation(e4, t5, r7);
    if (!s4)
      return null;
    const { ranges: a4, actualTileWidth: n8, actualTileHeight: o8, ifd: f5 } = s4, l6 = a4.map((e5) => this.request(this.url, { range: e5, responseType: "array-buffer", signal: i6.signal })), m10 = await Promise.all(l6), u8 = m10.map((e5) => e5.data.byteLength).reduce((e5, t6) => e5 + t6), p4 = 1 === m10.length ? m10[0].data : new ArrayBuffer(u8), c7 = [0], h3 = [0];
    if (m10.length > 1) {
      const e5 = new Uint8Array(p4);
      for (let t6 = 0, r8 = 0; t6 < m10.length; t6++) {
        const i7 = m10[t6].data;
        e5.set(new Uint8Array(i7), r8), c7[t6] = r8, r8 += i7.byteLength, h3[t6] = i7.byteLength;
      }
    }
    const { blockWidth: d5, blockHeight: y4 } = this.getBlockWidthHeight(e4), g = await this.decodePixelBlock(p4, { format: "tiff", customOptions: { headerInfo: this._headerInfo, ifd: f5, offsets: c7, sizes: h3 }, width: d5, height: y4, planes: null, pixelType: null });
    let x6, T, I5;
    if (n8 !== d5 || o8 !== y4) {
      let e5 = g.mask;
      if (e5)
        for (x6 = 0; x6 < y4; x6++)
          if (I5 = x6 * d5, x6 < o8)
            for (T = n8; T < d5; T++)
              e5[I5 + T] = 0;
          else
            for (T = 0; T < d5; T++)
              e5[I5 + T] = 0;
      else
        for (e5 = new Uint8Array(d5 * y4), g.mask = e5, x6 = 0; x6 < o8; x6++)
          for (I5 = x6 * d5, T = 0; T < n8; T++)
            e5[I5 + T] = 1;
    }
    return g;
  }
  async _readIFDs(e4, t5, r7, i6, s4, a4 = 4, n8) {
    if (!i6)
      return null;
    if (i6 >= t5.byteLength || i6 < 0) {
      t5 = (await this.request(this.url, { range: { from: i6 + s4, to: i6 + s4 + this._bufferSize }, responseType: "array-buffer", signal: n8 })).data, s4 = i6 + s4, i6 = 0;
    }
    const o8 = await this._readIFD(t5, r7, i6, s4, n5.TIFF_TAGS, a4, n8);
    if (e4.push(o8.ifd), !o8.nextIFD)
      return null;
    await this._readIFDs(e4, t5, r7, o8.nextIFD - s4, s4, a4, n8);
  }
  async _readIFD(e4, t5, r7, i6, s4 = n5.TIFF_TAGS, a4 = 4, n8) {
    if (!e4)
      return null;
    const o8 = k2(e4, t5, r7, i6, s4, a4);
    if (o8.success) {
      const r8 = [];
      if (o8.ifd.forEach((e5) => {
        e5.values || r8.push(e5);
      }), r8.length > 0) {
        const s5 = r8.map((e5) => e5.offlineOffsetSize), a5 = Math.min.apply(null, s5.map((e5) => e5[0]));
        if (Math.min.apply(null, s5.map((e5) => e5[0] + e5[1])) - a5 <= this._bufferSize) {
          const { data: s6 } = await this.request(this.url, { range: { from: a5, to: a5 + this._bufferSize }, responseType: "array-buffer", signal: n8 });
          e4 = s6, i6 = a5, r8.forEach((r9) => x3(e4, t5, r9, i6));
        }
      }
      if (o8.ifd.has("GEOKEYDIRECTORY")) {
        const r9 = o8.ifd.get("GEOKEYDIRECTORY"), s5 = r9.values;
        if (s5 && s5.length > 4) {
          const a5 = s5[0] + "." + s5[1] + "." + s5[2], o9 = await this._readIFD(e4, t5, r9.valueOffset + 6 - i6, i6, n5.GEO_KEYS, 2, n8);
          r9.data = o9.ifd, r9.data && r9.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a5] });
        }
      }
      return o8;
    }
    if (o8.requiredBufferSize && o8.requiredBufferSize !== e4.byteLength) {
      const r8 = await this.request(this.url, { range: { from: i6, to: i6 + o8.requiredBufferSize + 4 }, responseType: "array-buffer", signal: n8 });
      return (e4 = r8.data).byteLength < o8.requiredBufferSize ? null : this._readIFD(e4, t5, 0, i6, n5.TIFF_TAGS, 4, n8);
    }
  }
  _getTileLocation(e4, t5, r7) {
    const { firstPyramidLevel: i6, blockBoundary: s4 } = this.rasterInfo.storageInfo, a4 = 0 === e4 ? 0 : e4 - (i6 - 1), n8 = this._headerInfo.ifds[a4];
    if (!n8)
      return null;
    const o8 = D(n8, this._headerInfo), f5 = _2(n8, "TILEOFFSETS");
    if (void 0 === f5)
      return null;
    const l6 = _2(n8, "TILEBYTECOUNTS"), { minRow: m10, minCol: u8, maxRow: p4, maxCol: c7 } = s4[a4];
    if (t5 > p4 || r7 > c7 || t5 < m10 || r7 < u8)
      return null;
    const h3 = b4(n8, "IMAGEWIDTH"), y4 = b4(n8, "IMAGELENGTH"), g = b4(n8, "TILEWIDTH"), x6 = b4(n8, "TILELENGTH"), T = o8 ? this.rasterInfo.bandCount : 1, I5 = T * t5 * (c7 + 1) + r7, w3 = [{ from: f5[I5], to: f5[I5 + T - 1] + l6[I5 + T - 1] - 1 }];
    if (o8) {
      let e5 = true;
      for (let t6 = 0; t6 < T; t6++)
        if (f5[I5 + t6] + l6[I5 + t6] !== f5[I5 + t6 + 1]) {
          e5 = false;
          break;
        }
      if (!e5)
        for (let t6 = 0; t6 < T; t6++)
          w3[t6] = { from: f5[I5 + t6], to: f5[I5 + t6] + l6[I5 + t6] - 1 };
    }
    const E3 = f5[I5], S8 = l6[I5];
    if (null == E3 || null == S8)
      return null;
    return { ranges: w3, ifd: n8, actualTileWidth: r7 === c7 ? h3 % g : g, actualTileHeight: t5 === p4 ? y4 % x6 : x6 };
  }
  async _fetchAuxiliaryData(e4) {
    try {
      const { data: t5 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: e4 == null ? void 0 : e4.signal });
      return d4(t5);
    } catch {
      return null;
    }
  }
};
e([d()], E2.prototype, "_files", void 0), e([d()], E2.prototype, "_headerInfo", void 0), e([d()], E2.prototype, "_bufferSize", void 0), e([d({ type: String, json: { write: true } })], E2.prototype, "datasetFormat", void 0), E2 = e([n("esri.layers.support.rasterDatasets.TIFFRaster")], E2);
var S7 = E2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/RasterFactory.js
var c6 = /* @__PURE__ */ new Map();
c6.set("CRF", { desc: "Cloud Raster Format", constructor: I2 }), c6.set("MRF", { desc: "Meta Raster Format", constructor: F2 }), c6.set("TIFF", { desc: "GeoTIFF", constructor: S7 }), c6.set("RasterTileServer", { desc: "Raster Tile Server", constructor: I3 }), c6.set("JPG", { desc: "JPG Raster Format", constructor: w2 }), c6.set("PNG", { desc: "PNG Raster Format", constructor: w2 }), c6.set("GIF", { desc: "GIF Raster Format", constructor: w2 }), c6.set("BMP", { desc: "BMP Raster Format", constructor: w2 });
var n7 = class {
  static get supportedFormats() {
    const t5 = /* @__PURE__ */ new Set();
    return c6.forEach((e4, r7) => t5.add(r7)), t5;
  }
  static async open(e4) {
    const { url: r7, ioConfig: s4, sourceJSON: o8 } = e4;
    let a4 = e4.datasetFormat;
    null == a4 && r7.lastIndexOf(".") && (a4 = r7.slice(r7.lastIndexOf(".") + 1).toUpperCase()), "OVR" === a4 || "TIF" === a4 ? a4 = "TIFF" : "JPG" !== a4 && "JPEG" !== a4 && "JFIF" !== a4 || (a4 = "JPG"), r7.toLowerCase().includes("/imageserver") && !r7.toLowerCase().includes("/wcsserver") && (a4 = "RasterTileServer");
    const n8 = { url: r7, sourceJSON: o8, datasetFormat: a4, ioConfig: s4 || { bandIds: null, sampling: null } };
    let l6, i6;
    if (this.supportedFormats.has(a4)) {
      if ("CRF" === a4 && !s4.enableCRF)
        throw new s2("rasterfactory:open", `cannot open raster: ${r7}`);
      return l6 = c6.get(a4).constructor, i6 = new l6(n8), await i6.open({ signal: e4.signal }), i6;
    }
    if (a4)
      throw new s2("rasterfactory:open", "not a supported format " + a4);
    const u8 = Array.from(c6.keys());
    let F3 = 0;
    const m10 = () => (a4 = u8[F3++], a4 && ("CRF" !== a4 || s4.enableCRF) ? (l6 = c6.get(a4).constructor, i6 = new l6(n8), i6.open({ signal: e4.signal }).then(() => i6).catch(() => m10())) : null);
    return m10();
  }
  static register(t5, e4, r7) {
    c6.has(t5.toUpperCase()) || c6.set(t5.toUpperCase(), { desc: e4, constructor: r7 });
  }
};

// node_modules/@arcgis/core/layers/ImageryTileLayer.js
var L = class extends a2(t2(c2(v2(o3(H2(a3(n2(O(b))))))))) {
  constructor(...e4) {
    super(...e4), this.bandIds = null, this.interpolation = null, this.legendEnabled = true, this.isReference = null, this.listMode = "show", this.sourceJSON = null, this.version = null, this.title = null, this.type = "imagery-tile", this.operationalLayerType = "ArcGISTiledImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.fields = null;
  }
  normalizeCtorArgs(e4, r7) {
    return "string" == typeof e4 ? { url: e4, ...r7 } : e4;
  }
  load(e4) {
    const r7 = r(e4) ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e4).catch(w).then(() => this._openRaster(r7))), Promise.resolve(this);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    var _a, _b, _c;
    let e4 = [new y({ name: "Raster.ServicePixelValue", alias: "Pixel Value", domain: null, editable: false, length: 50, type: "string" })];
    const r7 = (_b = (_a = this.rasterInfo) == null ? void 0 : _a.attributeTable) == null ? void 0 : _b.fields, t5 = "Raster.";
    if (r7) {
      const o9 = r7.filter((e5) => "oid" !== e5.type && "value" !== e5.name.toLowerCase()).map((e5) => {
        const r8 = e5.clone();
        return r8.name = t5 + e5.name, r8;
      });
      e4 = e4.concat(o9);
    }
    const o8 = this.rasterInfo.dataType;
    if (("vector-magdir" === o8 || "vector-uv" === o8) && r(this.rasterInfo.multidimensionalInfo)) {
      const r8 = (_c = this.rasterInfo.multidimensionalInfo.variables[0].unit) == null ? void 0 : _c.trim(), t6 = "Magnitude" + (r8 ? ` (${r8})` : "");
      e4.push(new y({ name: "Raster.Magnitude", alias: t6, domain: null, editable: false, type: "double" })), e4.push(new y({ name: "Raster.Direction", alias: "Direction (°)", domain: null, editable: false, type: "double" }));
    }
    return e4;
  }
  set renderer(e4) {
    this._set("renderer", e4), this.updateRenderer();
  }
  readRenderer(e4, r7, o8) {
    const i6 = r7 && r7.layerDefinition && r7.layerDefinition.drawingInfo && r7.layerDefinition.drawingInfo.renderer, s4 = u4(i6, o8) || void 0;
    if (null != s4)
      return s4;
  }
  createPopupTemplate(e4) {
    return d2({ fields: this.rasterFields, title: this.title }, e4);
  }
  write(e4, r7) {
    const { raster: t5 } = this;
    if (this.loaded ? "RasterTileServer" === t5.datasetFormat && ("Raster" === t5.tileType || "Map" === t5.tileType) : this.url && /\/ImageServer(\/|\/?$)/i.test(this.url))
      return super.write(e4, r7);
    if (r7 && r7.messages) {
      const e5 = `${r7.origin}/${r7.layerContainerType || "operational-layers"}`;
      r7.messages.push(new s2("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e5}'`, { layer: this }));
    }
    return null;
  }
  async _openRaster(e4) {
    this.raster ? (this.raster.rasterInfo || await this.raster.open(), this.url = this.raster.url) : this.raster = await n7.open({ url: this.url, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: e4 });
    const { rasterInfo: r7 } = this.raster;
    if (!r7)
      throw new s2("imagery-tile-layer:load", "cannot load resources on " + this.url);
    if (this.sourceJSON = this.sourceJSON || this.raster.sourceJSON, null != this.sourceJSON) {
      const e5 = "Map" === this.raster.tileType && null != this.sourceJSON.minLOD && null != this.sourceJSON.maxLOD ? this.sourceJSON : { ...this.sourceJSON, minScale: 0, maxScale: 0 };
      this.read(e5, { origin: "service" });
    }
    null == this.title && (this.title = this.raster.datasetName), "Map" === this.raster.tileType && (this.popupEnabled = false), this._configDefaultSettings(), this.own(l2(() => this.customParameters, (e5) => {
      this.raster.ioConfig.customFetchParameters = e5;
    }));
  }
};
e([d({ type: [S], json: { write: { overridePolicy() {
  var _a;
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "0,1,2" !== ((_a = this.bandIds) == null ? void 0 : _a.join(",")) };
} } } })], L.prototype, "bandIds", void 0), e([d({ json: { write: { overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "bilinear" !== this.interpolation };
} } } }), r2(o4)], L.prototype, "interpolation", void 0), e([d({ json: { write: true } })], L.prototype, "multidimensionalDefinition", void 0), e([d(c)], L.prototype, "legendEnabled", void 0), e([d({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], L.prototype, "isReference", void 0), e([d({ type: ["show", "hide"] })], L.prototype, "listMode", void 0), e([d({ json: { read: true, write: true } })], L.prototype, "blendMode", void 0), e([d()], L.prototype, "sourceJSON", void 0), e([d({ readOnly: true, json: { origins: { service: { read: { source: "currentVersion" } } } } })], L.prototype, "version", void 0), e([d()], L.prototype, "title", void 0), e([d({ readOnly: true, json: { read: false } })], L.prototype, "type", void 0), e([d({ type: ["ArcGISTiledImageServiceLayer"] })], L.prototype, "operationalLayerType", void 0), e([d({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e4, r7) => !r7.disablePopup }, write: { target: "disablePopup", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
}, writer(e4, r7, t5) {
  r7[t5] = !e4;
} } } })], L.prototype, "popupEnabled", void 0), e([d({ type: B2, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
} } } })], L.prototype, "popupTemplate", void 0), e([d({ readOnly: true })], L.prototype, "defaultPopupTemplate", null), e([d({ readOnly: true, type: [y] })], L.prototype, "fields", void 0), e([d({ readOnly: true, type: [y] })], L.prototype, "rasterFields", null), e([d({ types: l3, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy() {
  var _a;
  const e4 = "raster-stretch" === ((_a = this.renderer) == null ? void 0 : _a.type) && "none" === this.renderer.stretchType && !this.renderer.useGamma;
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || !e4 };
} }, origins: { "web-scene": { types: i, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e4) => ({ enabled: e4 && "vector-field" !== e4.type && "flow" !== e4.type }) } } } } })], L.prototype, "renderer", null), e([o("renderer")], L.prototype, "readRenderer", null), L = e([n("esri.layers.ImageryTileLayer")], L);
var N2 = L;
export {
  N2 as default
};
//# sourceMappingURL=ImageryTileLayer-SAHSIBWV.js.map
