import {
  o as o2
} from "./chunk-FMIFCFD7.js";
import {
  i
} from "./chunk-UGLXR5OV.js";
import {
  A
} from "./chunk-6FQZDXGD.js";
import {
  c
} from "./chunk-HH3D3A65.js";
import {
  o,
  u
} from "./chunk-NWRK6QLX.js";
import {
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/support/visualVariablesUtils.js
function r(e, t2) {
  if (!e || !t2)
    return e;
  switch (t2) {
    case "radius":
    case "distance":
      return 2 * e;
    case "diameter":
    case "width":
      return e;
    case "area":
      return Math.sqrt(e);
  }
  return e;
}
function a(e) {
  return { value: e.value, size: o(e.size) };
}
function u2(e) {
  return e.map((e2) => a(e2));
}
function c2(e) {
  if ("string" == typeof e || "number" == typeof e)
    return o(e);
  const s = e;
  return { type: "size", expression: s.expression, stops: u2(s.stops) };
}
var f = (e) => {
  const t2 = [], n2 = [], i2 = u2(e), l2 = i2.length;
  for (let r2 = 0; r2 < 6; r2++) {
    const e2 = i2[Math.min(r2, l2 - 1)];
    t2.push(e2.value), n2.push(null == e2.size ? c : u(e2.size));
  }
  return { values: new Float32Array(t2), sizes: new Float32Array(n2) };
};
function m(e) {
  const t2 = e && e.length > 0 ? {} : null, s = t2 ? {} : null;
  if (!t2)
    return { vvFields: t2, vvRanges: s };
  for (const n2 of e)
    if (n2.field && (t2[n2.type] = n2.field), "size" === n2.type) {
      s.size || (s.size = {});
      const e2 = n2;
      switch (o2(e2)) {
        case A.SIZE_MINMAX_VALUE:
          s.size.minMaxValue = { minDataValue: e2.minDataValue, maxDataValue: e2.maxDataValue, minSize: c2(e2.minSize), maxSize: c2(e2.maxSize) };
          break;
        case A.SIZE_SCALE_STOPS:
          s.size.scaleStops = { stops: u2(e2.stops) };
          break;
        case A.SIZE_FIELD_STOPS:
          if (e2.levels) {
            const t3 = {};
            for (const s2 in e2.levels)
              t3[s2] = f(e2.levels[s2]);
            s.size.fieldStops = { type: "level-dependent", levels: t3 };
          } else
            s.size.fieldStops = { type: "static", ...f(e2.stops) };
          break;
        case A.SIZE_UNIT_VALUE:
          s.size.unitValue = { unit: e2.valueUnit, valueRepresentation: e2.valueRepresentation };
      }
    } else if ("color" === n2.type)
      s.color = y(n2);
    else if ("opacity" === n2.type)
      s.opacity = v(n2);
    else if ("rotation" === n2.type) {
      const e2 = n2;
      s.rotation = { type: e2.rotationType };
    }
  return { vvFields: t2, vvRanges: s };
}
function v(e) {
  const t2 = { values: [0, 0, 0, 0, 0, 0, 0, 0], opacities: [0, 0, 0, 0, 0, 0, 0, 0] };
  if ("string" == typeof e.field) {
    if (!e.stops)
      return null;
    {
      if (e.stops.length > 8)
        return null;
      const s = e.stops;
      for (let e2 = 0; e2 < 8; ++e2) {
        const n2 = s[Math.min(e2, s.length - 1)];
        t2.values[e2] = n2.value, t2.opacities[e2] = n2.opacity;
      }
    }
  } else {
    if (!(e.stops && e.stops.length >= 0))
      return null;
    {
      const s = e.stops && e.stops.length >= 0 && e.stops[0].opacity;
      for (let e2 = 0; e2 < 8; e2++)
        t2.values[e2] = 1 / 0, t2.opacities[e2] = s;
    }
  }
  return t2;
}
function g(e, t2, s) {
  e[4 * t2 + 0] = s.r / 255, e[4 * t2 + 1] = s.g / 255, e[4 * t2 + 2] = s.b / 255, e[4 * t2 + 3] = s.a;
}
function y(t2) {
  if (t(t2))
    return null;
  if (t2.normalizationField)
    return null;
  const s = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
  if ("string" == typeof t2.field) {
    if (!t2.stops)
      return null;
    {
      if (t2.stops.length > 8)
        return null;
      s.field = t2.field;
      const e = t2.stops;
      for (let t3 = 0; t3 < 8; ++t3) {
        const n2 = e[Math.min(t3, e.length - 1)];
        s.values[t3] = n2.value, g(s.colors, t3, n2.color);
      }
    }
  } else {
    if (!(t2.stops && t2.stops.length >= 0))
      return null;
    {
      const e = t2.stops && t2.stops.length >= 0 && t2.stops[0].color;
      for (let t3 = 0; t3 < 8; t3++)
        s.values[t3] = 1 / 0, g(s.colors, t3, e);
    }
  }
  for (let e = 0; e < 32; e += 4)
    i(s.colors, e, true);
  return s;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/util/debug.js
var n = (n2, l2) => n2 && ((...n3) => l2.warn("DEBUG:", ...n3)) || (() => null);
var l = false;

export {
  n,
  l,
  r,
  m
};
//# sourceMappingURL=chunk-3CED37X7.js.map
