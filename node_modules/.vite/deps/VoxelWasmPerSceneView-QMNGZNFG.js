import {
  d
} from "./chunk-OW2AZDS5.js";
import {
  H,
  x
} from "./chunk-ZGXOGFCR.js";
import "./chunk-22O7HU3A.js";
import {
  k,
  v2 as v
} from "./chunk-ZEDAE7EU.js";
import {
  A,
  E
} from "./chunk-ERNXFM5T.js";
import {
  I,
  N,
  O
} from "./chunk-FPMD6IB4.js";
import "./chunk-EOJGYH5X.js";
import "./chunk-7GTYHKA3.js";
import "./chunk-53KI6WDE.js";
import "./chunk-W2HLA6I3.js";
import "./chunk-Q6AASANP.js";
import "./chunk-ZYIEYKCD.js";
import "./chunk-TQLSOIYV.js";
import "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import {
  o
} from "./chunk-MV2XZ5BA.js";
import {
  l as l2
} from "./chunk-ZN2MGN4S.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-U7B2WKBH.js";
import {
  l
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import {
  a as a3
} from "./chunk-KVF4M6PZ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-56RHM4A6.js";
import "./chunk-HPH3FMVB.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-DMJWTK32.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  g
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  a,
  a2,
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/libs/vxl/enums.js
var e;
var t;
var i;
var n;
var a4;
!function(e3) {
  e3[e3.Binary = 0] = "Binary", e3[e3.JSON = 1] = "JSON";
}(e || (e = {})), function(e3) {
  e3[e3.TreeIndex = 0] = "TreeIndex", e3[e3.TreeStats = 1] = "TreeStats", e3[e3.TreeData = 2] = "TreeData", e3[e3.BrickBundles = 3] = "BrickBundles", e3[e3.Section = 4] = "Section", e3[e3.VariableStats = 5] = "VariableStats";
}(t || (t = {})), function(e3) {
  e3[e3.None = 1] = "None", e3[e3.Front = 2] = "Front", e3[e3.Back = 3] = "Back";
}(i || (i = {})), function(e3) {
  e3[e3.Low = 0] = "Low", e3[e3.Medium = 1] = "Medium", e3[e3.High = 2] = "High";
}(n || (n = {})), function(e3) {
  e3[e3.None = 0] = "None", e3[e3.StaticSections = 1] = "StaticSections", e3[e3.Slices = 2] = "Slices", e3[e3.DynamicSections = 4] = "DynamicSections", e3[e3.GhostShell = 8] = "GhostShell", e3[e3.Isosurface = 16] = "Isosurface", e3[e3.Quality = 32] = "Quality", e3[e3.SunLocation = 64] = "SunLocation", e3[e3.StaticSectionSelection = 128] = "StaticSectionSelection", e3[e3.ExaggerationAndOffset = 256] = "ExaggerationAndOffset", e3[e3.CurrentTime = 512] = "CurrentTime", e3[e3.CurrentVariable = 1024] = "CurrentVariable", e3[e3.DeleteIsosurface = 2048] = "DeleteIsosurface", e3[e3.ContainerVisibility = 4096] = "ContainerVisibility", e3[e3.RenderMode = 8192] = "RenderMode", e3[e3.Optimization = 16384] = "Optimization";
}(a4 || (a4 = {}));

// node_modules/@arcgis/core/libs/vxl/VxlModule.js
function e2(t2) {
  return new Promise((e3) => import("./vxlLayer-RU7VDM4L.js").then((t3) => t3.v).then(({ default: n2 }) => {
    const r2 = n2({ locateFile: i2, preinitializedWebGLContext: t2, onRuntimeInitialized: () => e3(r2) });
  })).catch((t3) => {
    throw t3;
  });
}
function i2(e3) {
  return a3(`esri/libs/vxl/${e3}`);
}

// node_modules/@arcgis/core/layers/VoxelWasmPerSceneView.js
var w = s.getLogger("esri.layers.VoxelWasmPerSceneView");
var R;
!function(e3) {
  e3[e3.Lifetime = 1] = "Lifetime", e3[e3.RequestResponse = 2] = "RequestResponse", e3[e3.Rendering = 3] = "Rendering", e3[e3.Error = 4] = "Error";
}(R || (R = {}));
var E2 = class {
  constructor(e3) {
    this._halfIntTexturesAvailable = false, this._textureFloatLinearAvailable = false, this._havePreparedWithAllLayers = false, this._renderPluginContext = null, this._vxl = null, this._pluginIsActive = false, this._moreToLoad = false, this._viewportWidth = -1, this._viewportHeight = -1, this._newLayers = [], this._layers = /* @__PURE__ */ new Map(), this._renderPass = A.MATERIAL, this._renderSlot = E.VOXEL, this._rctx = null, this._renderTargetToRestore = null, this._lastFrameWasStationary = false, this._wasmMemBlockSizes = [512, 1024, 2048, 4096, 8192, 16384, 32768, 65536], this._wasmMemBlocks = /* @__PURE__ */ new Map(), this._dbgFlags = /* @__PURE__ */ new Set(), this._captureFrustum = false, this._frustum = null, this._frustumRenderableId = -1, this._renderCoordsHelper = null, this._view = e3, this._initialize();
  }
  get canRender() {
    return !!this._vxl && "local" === this._view.viewingMode;
  }
  _dbg(e3, t2) {
    this._dbgFlags.has(e3) && (e3 === R.Error ? w.error(t2) : w.warn(t2));
  }
  _removeRenderPlugin() {
    this._pluginIsActive && this._view._stage && (this._dbg(R.Lifetime, "--removeRenderPlugin--"), this._view._stage.removeRenderPlugin(this)), this._pluginIsActive = false;
  }
  _initialize() {
    this._dbg(R.Lifetime, "--initialize--");
    for (const e3 of this._wasmMemBlockSizes)
      this._wasmMemBlocks.set(e3, 0);
    this._readyWatchHandle = l(() => this._view.ready, (e3) => {
      e3 && "local" === this._view.viewingMode ? (this._dbg(R.Lifetime, "view ready status changed to ready on a local view, calling addRenderPlugin"), this._view._stage.addRenderPlugin([this._renderSlot], this), this._pluginIsActive = true) : (this._dbg(R.Lifetime, "view ready status changed, not ready or not a local view!"), this._removeRenderPlugin());
    }, { initial: true }), this._qualityWatchHandle = l(() => {
      var _a;
      return (_a = this._view) == null ? void 0 : _a.qualityProfile;
    }, (e3) => {
      this._dbg(R.Rendering, "qualityProfile changed to " + e3), this._vxl && this._vxl.set_quality(this._toWasmQuality(e3));
    }, { initial: true }), this._timeExtentWatchHandle = l(() => {
      var _a;
      return (_a = this._view) == null ? void 0 : _a.timeExtent;
    }, () => {
      var _a;
      if (this._vxl) {
        const e3 = this._getTimeArgs((_a = this._view) == null ? void 0 : _a.timeExtent);
        this._dbg(R.Rendering, "sceneView timeExtent changed to useTime=" + e3.useTime + " st=" + e3.startTime + " et=" + e3.endTime), this._vxl.set_scene_time_extent(e3.startTime, e3.endTime, e3.useTime), this._renderPluginContext.requestRender();
      }
    }, { initial: true }), this._stationaryWatchHandle = l(() => {
      var _a;
      return (_a = this._view) == null ? void 0 : _a.stationary;
    }, (e3) => {
      this._vxl && e3 && !this._lastFrameWasStationary && this._renderPluginContext.requestRender();
    });
  }
  initializeRenderContext(e3) {
    this._dbg(R.Lifetime, "--initializeRenderContext--");
    const t2 = e3.renderContext.rctx;
    t2.type === o.WEBGL2 ? (this._renderPluginContext = e3, this._rctx = e3.renderContext.rctx, this._halfIntTexturesAvailable = !!this._rctx.capabilities.textureNorm16, this._textureFloatLinearAvailable = this._rctx.capabilities.textureFloatLinear, this._initializeWasm(t2.gl)) : this._dbg(R.Error, "WebGL 1 context only!");
  }
  uninitializeRenderContext() {
    this._renderPluginContext = null, this._rctx = null, this._dbg(R.Lifetime, "--uninitializeRenderContext--");
  }
  _restoreFramebuffer() {
    if (!this._renderTargetToRestore)
      return;
    const e3 = this._renderTargetToRestore.fbo;
    if (!!!this._rctx)
      return void this._dbg(R.Error, "no context in restoreFramebuffer!");
    this._rctx.bindFramebuffer(e3, true);
    const t2 = this._renderTargetToRestore.viewport;
    this._rctx.setViewport(t2.x, t2.y, t2.width, t2.height);
  }
  _bindPreviousDepthToSlot(e3, t2) {
    const r2 = !!this._rctx, s2 = !!this._renderTargetToRestore;
    if (!r2 || !s2)
      return 0;
    const i3 = this._renderTargetToRestore.fbo.depthStencilTexture;
    return i3 ? (0 === t2 ? this._rctx.bindTexture(null, e3, true) : this._rctx.bindTexture(i3, e3, true), 1) : (this._dbg(R.Error, "no depth/stencil texture exists!"), 0);
  }
  _modifyResourceCount(e3, t2, r2) {
    if (!this._rctx)
      return void this._dbg(R.Error, "modifyAllocation callback has no rendering context!");
    const s2 = e3;
    1 === r2 ? this._rctx.instanceCounter.increment(s2, t2) : this._rctx.instanceCounter.decrement(s2, t2);
  }
  _setBlendState(e3, t2, r2, s2) {
    this._rctx ? (this._rctx.setBlendingEnabled(1 === e3), this._rctx.setBlendFunction(t2, r2), this._rctx.setBlendEquation(s2)) : this._dbg(R.Error, "setBlendState callback has no rendering context!");
  }
  _setFrontFace(e3) {
    this._rctx ? this._rctx.setFrontFace(e3) : this._dbg(R.Error, "setFrontFace callback has no rendering context!");
  }
  _setDepthStencilStateFunction(e3, t2, r2) {
    this._rctx ? (this._rctx.setDepthFunction(r2), this._rctx.setDepthTestEnabled(1 === e3), this._rctx.setDepthWriteEnabled(1 === t2), this._rctx.setStencilTestEnabled(false), this._rctx.setStencilFunction(I.ALWAYS, 0, 255), this._rctx.setStencilOpSeparate(N.FRONT, O.KEEP, O.INCR, O.KEEP), this._rctx.setStencilOpSeparate(N.BACK, O.KEEP, O.DECR, O.KEEP)) : this._dbg(R.Error, "setDepthStencilStateFunction callback has no rendering context!");
  }
  _setRasterizerState(e3) {
    if (this._rctx)
      switch (e3) {
        case i.None:
          this._rctx.setFaceCullingEnabled(false);
          break;
        case i.Back:
          this._rctx.setCullFace(N.BACK), this._rctx.setFaceCullingEnabled(true);
          break;
        case i.Front:
          this._rctx.setCullFace(N.FRONT), this._rctx.setFaceCullingEnabled(true);
      }
    else
      this._dbg(R.Error, "setRasterizerState callback has no rendering context!");
  }
  _setViewport(e3, t2, r2, s2) {
    this._rctx ? this._rctx.setViewport(e3, t2, r2, s2) : this._dbg(R.Error, "setViewport callback has no rendering context!");
  }
  _updateMemoryUsage() {
    this._layers.forEach((e3, t2) => {
      if (e3.needMemoryUsageUpdate) {
        const r2 = this._vxl.estimate_memory_usage(t2);
        r2 >= 0 && (e3.needMemoryUsageUpdate = false, e3.layerView.setUsedMemory(r2));
      }
    });
  }
  _syncRequestsResponses() {
    this._layers.forEach((t2, r2) => {
      const s2 = [];
      t2.responses.forEach((e3, i4) => {
        s2.push(i4), this._dbg(R.RequestResponse, "responding for requestID:" + i4 + " size:" + e3.size), this._vxl.respond(r2, i4, e3), e3.requestType !== t.TreeIndex && e3.requestType !== t.Section || (t2.needMemoryUsageUpdate = true);
      });
      const i3 = t2.responses;
      for (const e3 of s2)
        i3.delete(e3);
      const n2 = this._vxl.get_new_requests(r2), o2 = t2.abortController.signal;
      for (const l3 in n2) {
        t2.outstandingRequestCount += 1, 1 === t2.outstandingRequestCount && t2.layerView.updatingFlagChanged();
        const r3 = n2[l3], s3 = { responseType: "array-buffer", signal: o2 };
        this._dbg(R.RequestResponse, "making requestID:" + l3 + " url:" + r3.url), U(r3.url, s3).then((e3) => {
          t2.outstandingRequestCount -= 1, 0 === t2.outstandingRequestCount && t2.layerView.updatingFlagChanged(), this._dbg(R.RequestResponse, "have response for requestID:" + l3);
          let s4 = 0;
          if (e3.data.byteLength > 0) {
            s4 = this._vxl._malloc(e3.data.byteLength);
            const t3 = new Uint8Array(this._vxl.HEAPU8.buffer, s4, e3.data.byteLength), r4 = new Uint8Array(e3.data);
            for (let s5 = 0; s5 < e3.data.byteLength; ++s5)
              t3[s5] = r4[s5];
          }
          i3.set(+l3, { responseType: r3.responseType, ptr: s4, size: e3.data.byteLength, success: true, requestType: r3.requestType });
        }).catch((e3) => {
          t2.outstandingRequestCount -= 1, 0 === t2.outstandingRequestCount && t2.layerView.updatingFlagChanged(), g(e3) || (this._dbg(R.Error, `requestID:${l3} failed, error=${e3.toString()}`), i3.set(+l3, { responseType: r3.responseType, ptr: 0, size: 0, success: false, requestType: r3.requestType }));
        });
      }
    });
  }
  updateWasmCamera(e3) {
    this._vxl.set_projection_matrix.apply(this._vxl, e3.projectionMatrix), this._vxl.set_view_matrix.apply(this._vxl, e3.viewMatrix), this._vxl.set_near_far(e3.near, e3.far);
  }
  isUpdating(e3) {
    return !(this._vxl || !this._vxlPromise) || !!this._layers.has(e3) && this._layers.get(e3).outstandingRequestCount > 0;
  }
  setEnabled(e3, t2) {
    this._layers.forEach((r2, s2) => {
      r2.layerView.wasmLayerId === e3.wasmLayerId && (this._vxl.set_enabled(s2, t2), r2.needMemoryUsageUpdate = true, this._renderPluginContext.requestRender());
    });
  }
  setSlices(e3, t2) {
    const r2 = { mask: a4.Slices, slices: { planes: t2, currentEditPlane: -1 } };
    return this._doMaskedUIUpdate(e3, r2, true);
  }
  setDynamicSections(e3, t2) {
    const r2 = { mask: a4.DynamicSections, dynamicSections: { planes: t2, currentEditPlane: -1 } };
    return this._doMaskedUIUpdate(e3, r2, true);
  }
  setStaticSections(e3, t2) {
    const r2 = { mask: a4.StaticSections, staticSections: t2 };
    return this._doMaskedUIUpdate(e3, r2, true);
  }
  setCurrentVariable(e3, t2) {
    const r2 = { mask: a4.CurrentVariable, currentVariable: t2 };
    return this._doMaskedUIUpdate(e3, r2, true);
  }
  setRenderMode(e3, t2) {
    const r2 = { mask: a4.RenderMode, renderMode: t2 };
    return this._doMaskedUIUpdate(e3, r2, true);
  }
  setVerticalExaggerationAndOffset(e3, t2, r2, s2) {
    const i3 = { mask: a4.ExaggerationAndOffset, volStyleDesc: { volumeId: t2, verticalExaggeration: r2, verticalOffset: s2 } };
    return this._doMaskedUIUpdate(e3, i3, true);
  }
  _doMaskedUIUpdate(e3, t2, r2) {
    if (!this._vxl)
      return false;
    let s2 = false;
    return this._layers.forEach((r3, i3) => {
      if (r3.layerView.wasmLayerId === e3.wasmLayerId) {
        const e4 = { str: JSON.stringify(t2), byteCount: 0, ptr: 0, isReusable: false };
        this._allocateBlock(e4) && (s2 = 1 === this._vxl.handle_masked_ui_update(i3, e4.ptr, e4.byteCount), e4.isReusable || this._vxl._free(e4.ptr));
      }
    }), s2 && r2 && this._renderPluginContext.requestRender(), s2;
  }
  _addTriangleToWasmBuffer(e3, t2, r2, s2, i3) {
    return e3[3 * t2 + 0] = r2[0], e3[3 * t2 + 1] = r2[1], e3[3 * t2 + 2] = r2[2], e3[3 * (t2 += 1) + 0] = s2[0], e3[3 * t2 + 1] = s2[1], e3[3 * t2 + 2] = s2[2], e3[3 * (t2 += 1) + 0] = i3[0], e3[3 * t2 + 1] = i3[1], e3[3 * t2 + 2] = i3[2], t2 += 1;
  }
  _addNormalToWasmBuffer(e3, t2, r2) {
    return e3[3 * t2 + 0] = r2[0], e3[3 * t2 + 1] = r2[1], e3[3 * t2 + 2] = r2[2], t2 += 1;
  }
  _doCaptureFrustum() {
    if (!this._vxl)
      return;
    const e3 = 36, t2 = e3 / 3, r2 = this._vxl._malloc(3 * e3 * Float32Array.BYTES_PER_ELEMENT), s2 = new Float32Array(this._vxl.HEAPF32.buffer, r2, 3 * e3), i3 = this._vxl._malloc(3 * t2 * Float32Array.BYTES_PER_ELEMENT), a5 = new Float32Array(this._vxl.HEAPF32.buffer, i3, e3), n2 = this._frustum.points[v.NEAR_BOTTOM_LEFT], o2 = this._frustum.points[v.NEAR_BOTTOM_RIGHT], _ = this._frustum.points[v.NEAR_TOP_RIGHT], d2 = this._frustum.points[v.NEAR_TOP_LEFT], u = this._frustum.points[v.FAR_BOTTOM_LEFT], c = this._frustum.points[v.FAR_BOTTOM_RIGHT], m = this._frustum.points[v.FAR_TOP_RIGHT], g2 = this._frustum.points[v.FAR_TOP_LEFT];
    let x2 = 0, f = 0;
    const p = this._frustum.planes[k.NEAR];
    x2 = this._addTriangleToWasmBuffer(s2, x2, _, o2, n2), f = this._addNormalToWasmBuffer(a5, f, p), x2 = this._addTriangleToWasmBuffer(s2, x2, n2, d2, _), f = this._addNormalToWasmBuffer(a5, f, p);
    const v2 = this._frustum.planes[k.FAR];
    x2 = this._addTriangleToWasmBuffer(s2, x2, u, c, m), f = this._addNormalToWasmBuffer(a5, f, v2), x2 = this._addTriangleToWasmBuffer(s2, x2, m, g2, u), f = this._addNormalToWasmBuffer(a5, f, v2);
    const y = this._frustum.planes[k.TOP];
    x2 = this._addTriangleToWasmBuffer(s2, x2, m, _, d2), f = this._addNormalToWasmBuffer(a5, f, y), x2 = this._addTriangleToWasmBuffer(s2, x2, d2, g2, m), f = this._addNormalToWasmBuffer(a5, f, y);
    const b = this._frustum.planes[k.BOTTOM];
    x2 = this._addTriangleToWasmBuffer(s2, x2, n2, o2, c), f = this._addNormalToWasmBuffer(a5, f, b), x2 = this._addTriangleToWasmBuffer(s2, x2, c, u, n2), f = this._addNormalToWasmBuffer(a5, f, b);
    const T = this._frustum.planes[k.LEFT];
    x2 = this._addTriangleToWasmBuffer(s2, x2, d2, n2, u), f = this._addNormalToWasmBuffer(a5, f, T), x2 = this._addTriangleToWasmBuffer(s2, x2, u, g2, d2), f = this._addNormalToWasmBuffer(a5, f, T);
    const w2 = this._frustum.planes[k.RIGHT];
    x2 = this._addTriangleToWasmBuffer(s2, x2, _, m, c), f = this._addNormalToWasmBuffer(a5, f, w2), x2 = this._addTriangleToWasmBuffer(s2, x2, c, o2, _), f = this._addNormalToWasmBuffer(a5, f, w2), -1 !== this._frustumRenderableId && this._vxl.remove_generic_mesh(this._frustumRenderableId), this._frustumRenderableId = this._vxl.add_generic_mesh(r2, 3 * e3, i3, e3, 255, 0, 0, 64), this._vxl._free(r2), this._vxl._free(i3), this._captureFrustum = false, this._renderPluginContext.requestRender();
  }
  captureFrustum() {
    null === this._renderCoordsHelper && (this._renderCoordsHelper = x.create(l2.Local, H(false, this._view.spatialReference))), null === this._frustum && (this._frustum = new d(this._renderCoordsHelper)), this._captureFrustum = true, null !== this._renderPluginContext && this._renderPluginContext.requestRender();
  }
  toggleFullVolumeExtentDraw(e3) {
    this._vxl && this._layers.forEach((t2, r2) => {
      t2.layerView.wasmLayerId === e3.wasmLayerId && (this._vxl.toggle_full_volume_extent_draw(r2), this._renderPluginContext.requestRender());
    });
  }
  addVoxelLayer(e3) {
    if (!this._vxl) {
      const t3 = { layerView: e3, resolveCallback: null, rejectCallback: null }, r2 = new Promise((e4, r3) => {
        t3.resolveCallback = e4, t3.rejectCallback = r3;
      });
      return this._newLayers.push(t3), r2;
    }
    const t2 = this._addVoxelLayer(e3);
    return t2 < 0 ? Promise.reject(-1) : Promise.resolve(t2);
  }
  removeVoxelLayer(e3) {
    if (!this._vxl) {
      const t3 = this._newLayers.findIndex((t4) => e3.uid === t4.layerView.uid);
      t3 >= 0 && (this._newLayers[t3].resolveCallback(-1), this._newLayers.splice(t3, 1));
      const r3 = this._newLayers.length;
      return 0 === r3 && (this._dbg(R.Lifetime, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()), r3;
    }
    let t2 = -1;
    this._layers.forEach((r3, s2) => {
      r3.layerView.wasmLayerId === e3.wasmLayerId && (t2 = s2, r3.abortController.abort(), this._vxl.remove_layer(t2));
    }), t2 >= 0 && this._layers.delete(t2);
    const r2 = this._layers.size;
    return 0 === r2 && (this._dbg(R.Lifetime, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()), r2;
  }
  _getBlockSize(e3) {
    for (const t2 of this._wasmMemBlockSizes)
      if (e3 < t2)
        return t2;
    return -1;
  }
  _allocateBlock(e3) {
    e3.byteCount = this._vxl.lengthBytesUTF8(e3.str) + 1;
    const t2 = this._getBlockSize(e3.byteCount);
    return t2 < 0 ? (e3.isReusable = false, e3.ptr = this._vxl._malloc(e3.byteCount)) : (e3.isReusable = true, e3.ptr = this._wasmMemBlocks.get(t2), 0 === e3.ptr && (e3.ptr = this._vxl._malloc(t2), this._wasmMemBlocks.set(t2, e3.ptr))), 0 !== e3.ptr && (this._vxl.stringToUTF8(e3.str, e3.ptr, e3.byteCount), true);
  }
  _getTimeArgs(e3) {
    let t2 = -Number.MAX_VALUE, r2 = Number.MAX_VALUE, i3 = false;
    return r(e3) && (e3.isAllTime ? i3 = true : (r(e3.start) && (i3 = true, t2 = e3.start.getTime() / 1e3), r(e3.end) && (i3 = true, r2 = e3.end.getTime() / 1e3))), { startTime: t2, endTime: r2, useTime: i3 };
  }
  _addVoxelLayer(e3) {
    var _a;
    const r2 = e3.layer;
    let s2 = -1;
    const i3 = r2.getConfiguration();
    if (i3.length < 1)
      return -1;
    const a5 = { str: i3, byteCount: 0, ptr: 0, isReusable: false };
    if (!this._allocateBlock(a5))
      return -1;
    const n2 = this._getTimeArgs((_a = this._view) == null ? void 0 : _a.timeExtent), o2 = this._view.spatialReference.isWGS84 && r2.spatialReference.isWGS84 ? 111319.49079327357 : 1;
    if (s2 = this._vxl.add_layer(r2.serviceRoot, a5.ptr, a5.byteCount, o2, o2, n2.startTime, n2.endTime, n2.useTime, this._toWasmQuality(this._view.qualityProfile)), a5.isReusable || this._vxl._free(a5.ptr), s2 >= 0) {
      const r3 = new AbortController();
      if (this._layers.set(s2, { layerView: e3, responses: /* @__PURE__ */ new Map(), outstandingRequestCount: 0, abortController: r3, needMemoryUsageUpdate: false }), !this._halfIntTexturesAvailable || a("mac")) {
        const t2 = [];
        let r4 = "";
        for (const s3 of e3.layer.variables)
          "Int16" !== s3.renderingFormat.type && "UInt16" !== s3.renderingFormat.type || (t2.push(s3.name), s3.id === e3.layer.currentVariableId && (r4 = s3.name));
        "" !== r4 && w.error("#addVoxelLayer_error()", e3.layer, `The voxel layer '${e3.layer.title}' cannot render the current variable '${r4}' in this browser`), t2.length > 0 && w.warn("#addVoxelLayer_warning()", e3.layer, `The voxel layer '${e3.layer.title}' cannot render the variables '${t2.toString()}' in this browser`);
      }
      if (!this._textureFloatLinearAvailable) {
        const t2 = [];
        let r4 = "";
        for (const s3 of e3.layer.variables)
          "Float32" === s3.renderingFormat.type && (t2.push(s3.name), s3.id === e3.layer.currentVariableId && (r4 = s3.name));
        "" !== r4 && w.error("#addVoxelLayer_error()", e3.layer, `The voxel layer '${e3.layer.title}' cannot render the current variable '${r4}' in this browser`), t2.length > 0 && w.warn("#addVoxelLayer_warning()", e3.layer, `The voxel layer '${e3.layer.title}' cannot render the variables '${t2.toString()}' in this browser`);
      }
      return a("esri-mobile") && w.warnOnce("Mobile support differs across devices. Voxel layer might not display as expected."), s2;
    }
    return -1;
  }
  prepareRender(e3) {
    if (!this._vxl)
      return;
    const t2 = e3.bindParameters.camera.viewForward, r2 = e3.bindParameters.camera.eye;
    this._vxl.update_camera_pos_and_direction(r2[0], r2[1], r2[2], t2[0], t2[1], t2[2]);
    const s2 = this._vxl.cull();
    this._dbg(R.RequestResponse, "missingResourceCount=" + s2), this._moreToLoad = s2 > 0, this._havePreparedWithAllLayers = 0 === this._newLayers.length, this._updateMemoryUsage();
  }
  render(e3) {
    if (!this._vxl || e3.pass !== this._renderPass || e3.bindParameters.slot !== this._renderSlot)
      return;
    for (const r2 of this._newLayers) {
      const e4 = this._addVoxelLayer(r2.layerView);
      -1 === e4 ? r2.rejectCallback(-1) : r2.resolveCallback(e4);
    }
    if (this._newLayers = [], 0 === this._layers.size)
      return void this._dbg(R.Error, "No voxel layers but RenderPlugin instance is being asked to render!");
    this._renderTargetToRestore = { fbo: this._rctx.getBoundFramebufferObject(), viewport: this._rctx.getViewport() }, this._syncRequestsResponses(), this._lastFrameWasStationary = this._view.stationary, this._rctx.setPolygonOffsetFillEnabled(false), this._rctx.setScissorTestEnabled(false), this._rctx.setColorMask(true, true, true, true), this._vxl.begin_color_frame(!this._view.stationary || this._moreToLoad, e3.bindParameters.lighting.lightingMainDirection[0], e3.bindParameters.lighting.lightingMainDirection[1], e3.bindParameters.lighting.lightingMainDirection[2]);
    const t2 = this._renderTargetToRestore.viewport;
    t2.width === this._viewportWidth && t2.height === this._viewportHeight || (this._viewportWidth = t2.width, this._viewportHeight = t2.height, this._vxl.set_viewport(t2.width, t2.height), this._layers.forEach((e4) => {
      e4.needMemoryUsageUpdate = true;
    })), 0 === t2.x && 0 === t2.y || this._dbg(R.Error, "Unsupported viewport parameters detected!"), this.updateWasmCamera(e3.bindParameters.camera), this._captureFrustum && (this._frustum.update(e3.bindParameters.camera), this._doCaptureFrustum()), this._vxl.draw(), this._renderTargetToRestore.fbo = null, e3.rctx.externalTextureUnitUpdate(this._vxl.get_texture_units_bound_in_frame(), this._vxl.get_active_texture_unit()), e3.rctx.externalVertexArrayObjectUpdate(), e3.rctx.externalVertexBufferUpdate(), this._rctx.externalProgramUpdate(), (this._moreToLoad || !this._havePreparedWithAllLayers && this._layers.size > 0) && this._renderPluginContext.requestRender();
  }
  destroy() {
    this._dbg(R.Lifetime, "--destroy--"), this._removeRenderPlugin(), this._readyWatchHandle = a2(this._readyWatchHandle), this._qualityWatchHandle = a2(this._qualityWatchHandle), this._timeExtentWatchHandle = a2(this._timeExtentWatchHandle), this._stationaryWatchHandle = a2(this._stationaryWatchHandle), this._vxl && (this._layers.forEach((e3) => {
      e3.abortController.abort();
    }), this._wasmMemBlocks.forEach((e3) => {
      0 !== e3 && this._vxl._free(e3);
    }), this._vxl.uninitialize_voxel_wasm(), this._vxl = null);
  }
  _initializeWasm(e3) {
    return this._vxl ? Promise.resolve() : (this._vxlPromise || (this._vxlPromise = e2(e3).then((e4) => {
      var _a;
      if (this._vxl = e4, this._vxlPromise = null, this._newLayers.length <= 0)
        return this._dbg(R.Lifetime, " no voxel layers left after WASM downloaded, removing RenderPlugin and destroying"), void this.destroy();
      const r2 = this._getTimeArgs((_a = this._view) == null ? void 0 : _a.timeExtent), s2 = this._vxl.addFunction(this._restoreFramebuffer.bind(this), "v"), i3 = this._vxl.addFunction(this._setBlendState.bind(this), "viiii"), a5 = this._vxl.addFunction(this._setFrontFace.bind(this), "vi"), n2 = this._vxl.addFunction(this._setRasterizerState.bind(this), "vi"), o2 = this._vxl.addFunction(this._setDepthStencilStateFunction.bind(this), "viii"), l3 = this._vxl.addFunction(this._setViewport.bind(this), "viiii"), h = this._vxl.addFunction(this._bindPreviousDepthToSlot.bind(this), "iii"), _ = this._vxl.addFunction(this._modifyResourceCount.bind(this), "viii"), d2 = this._halfIntTexturesAvailable && !a("mac"), u = this._textureFloatLinearAvailable;
      this._vxl.initialize_voxel_wasm(s2, i3, a5, n2, o2, l3, h, _, r2.startTime, r2.endTime, r2.useTime, d2, u), this._renderPluginContext && this._renderPluginContext.requestRender();
    }).catch(() => {
      for (const e4 of this._newLayers)
        e4.rejectCallback(-2);
      this._dbg(R.Error, " WASM failed to download, removing RenderPlugin and destroying"), this.destroy();
    })), this._vxlPromise);
  }
  pickDepth(e3, t2, r2) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size)
      return null;
    const s2 = r2.viewport[3] - t2;
    if (e3 < 0 || e3 > r2.viewport[2] || t2 < 0 || t2 > r2.viewport[3])
      return this._dbg(R.Error, `pickDepth: outOfRange, screenXY=[${e3}, ${s2}], vp=[${r2.viewport.toString()}]`), null;
    this._renderTargetToRestore = { fbo: this._rctx.getBoundFramebufferObject(), viewport: this._rctx.getViewport() };
    const i3 = r2.viewForward, a5 = r2.eye;
    this._vxl.update_camera_pos_and_direction(a5[0], a5[1], a5[2], i3[0], i3[1], i3[2]), this.updateWasmCamera(r2), this._vxl.begin_frame();
    const n2 = this._vxl.pick_depth(e3, s2);
    if (this._renderTargetToRestore.fbo = null, this._rctx.externalTextureUnitUpdate(this._vxl.get_texture_units_bound_in_frame(), this._vxl.get_active_texture_unit()), this._rctx.externalVertexArrayObjectUpdate(), this._rctx.externalVertexBufferUpdate(), this._rctx.externalProgramUpdate(), n2.success) {
      return n2.distanceToCamera;
    }
    return null;
  }
  _toWasmQuality(e3) {
    switch (e3) {
      case "low":
        return 0;
      case "medium":
        return 1;
      case "high":
        return 2;
    }
  }
};
export {
  E2 as default
};
//# sourceMappingURL=VoxelWasmPerSceneView-QMNGZNFG.js.map
