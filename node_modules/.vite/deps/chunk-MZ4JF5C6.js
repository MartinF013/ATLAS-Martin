import {
  o
} from "./chunk-BPZGJQOB.js";
import {
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/support/screenshotUtils.js
var h = 2048;
var e = 1.5;
var n = 8;
function o2(i, h2) {
  const { format: e2, quality: n2, rotation: o3, disableDecorations: a2 } = i || {}, r2 = P(i, h2.padding), l2 = q(i, { width: h2.width - r2.left - r2.right, height: h2.height - r2.top - r2.bottom }), { width: g2, height: u2 } = v(i, l2), f2 = k(e2), d2 = W[f2];
  return { format: f2, quality: o(null != n2 ? n2 : d2, 0, 100), area: l2, width: g2, height: u2, rotation: o3, disableDecorations: !!a2, ignoreBackground: !(!i || !i.ignoreBackground), ignorePadding: !(!i || !i.ignorePadding) };
}
function a(t2, i) {
  const h2 = o2(t2, i), e2 = h2.area, n2 = h2.width / e2.width, a2 = P(h2, i.padding), r2 = a2.left + a2.right, l2 = a2.top + a2.bottom, g2 = i.width - r2, u2 = i.height - l2, f2 = Math.floor(g2 * n2 + r2), d2 = Math.floor(u2 * n2 + l2), c2 = t2 && t2.layers ? t2.layers : [], s2 = h2.ignoreBackground, w2 = h2.ignorePadding;
  return { framebufferWidth: f2, framebufferHeight: d2, region: { x: Math.floor(e2.x * n2) + a2.left, y: Math.floor(e2.y * n2) + a2.top, width: h2.width, height: h2.height }, format: h2.format, quality: h2.quality, rotation: h2.rotation, pixelRatio: n2, layers: c2, disableDecorations: h2.disableDecorations, ignoreBackground: s2, ignorePadding: w2 };
}
function r(t2, i, h2) {
  const { ctx: e2, canvas: n2 } = g(t2, h2), o3 = e2.getImageData(0, 0, t2.width, t2.height), a2 = c(n2, i);
  return u(n2), { dataUrl: a2, data: o3 };
}
function l(t2, i) {
  const { ctx: h2, canvas: e2 } = g(t2, i), n2 = h2.getImageData(0, 0, t2.width, t2.height);
  return u(e2), n2;
}
function g(t2, i) {
  const h2 = f();
  i.premultipliedAlpha && E(t2), h2.width = t2.width, h2.height = t2.height;
  const e2 = h2.getContext("2d");
  return e2.putImageData(t2, 0, 0), i.flipY && B(e2), { ctx: e2, canvas: h2 };
}
function u(t2) {
  t2.width = 0, t2.height = 0;
}
function f() {
  return t(d) && (d = document.createElement("canvas")), d;
}
var d = null;
function c(t2, i) {
  const h2 = R[i.format], e2 = i.quality / 100;
  return t2.toDataURL(h2, e2);
}
function s(i, h2) {
  const e2 = k(i), n2 = W[e2];
  return { format: e2, quality: o(null != h2 ? h2 : n2, 0, 100) };
}
function w(t2, i) {
  return i / Math.max(t2[0], t2[1]);
}
function m(t2, i, h2) {
  if (!t2 || !i)
    throw new Error("Cannot construct image data without dimensions");
  if (j)
    try {
      return new ImageData(t2, i);
    } catch (e2) {
      j = false;
    }
  return x(t2, i, h2);
}
function M(t2, i, h2, e2) {
  if (!i || !h2)
    throw new Error("Cannot construct image data without dimensions");
  if (j)
    try {
      return new ImageData(t2, i, h2);
    } catch (o3) {
      j = false;
    }
  const n2 = x(i, h2, e2);
  return n2.data.set(t2, 0), n2;
}
function p(t2, i, h2, e2 = 0, n2 = 0, o3 = t2.width - e2, a2 = t2.height - n2, r2 = false) {
  const { data: l2 } = t2, { width: g2, height: u2, data: f2 } = i, d2 = o3 / g2, c2 = a2 / u2, s2 = Math.ceil(d2 / 2), w2 = Math.ceil(c2 / 2), m2 = t2.width;
  for (let M2 = 0; M2 < u2; M2++)
    for (let t3 = 0; t3 < g2; t3++) {
      const i2 = 4 * (t3 + (r2 ? u2 - M2 - 1 : M2) * g2);
      let o4 = 0, a3 = 0, p2 = 0, y2 = 0, x2 = 0, b2 = 0;
      const j2 = (M2 + 0.5) * c2;
      for (let r3 = Math.floor(M2 * c2); r3 < (M2 + 1) * c2; r3++) {
        const i3 = Math.abs(j2 - (r3 + 0.5)) / w2, g3 = (t3 + 0.5) * d2, u3 = i3 * i3;
        for (let f3 = Math.floor(t3 * d2); f3 < (t3 + 1) * d2; f3++) {
          const t4 = Math.abs(g3 - (f3 + 0.5)) / s2, i4 = Math.sqrt(u3 + t4 * t4);
          if (i4 >= 1)
            continue;
          let d3 = 2 * i4 * i4 * i4 - 3 * i4 * i4 + 1;
          const c3 = 4 * (e2 + f3 + (n2 + r3) * m2);
          b2 += d3 * l2[c3 + 3], a3 += d3, !h2 && l2[c3 + 3] < 255 && (d3 = d3 * l2[c3 + 3] / 255), p2 += d3 * l2[c3], y2 += d3 * l2[c3 + 1], x2 += d3 * l2[c3 + 2], o4 += d3;
        }
      }
      f2[i2] = p2 / o4, f2[i2 + 1] = y2 / o4, f2[i2 + 2] = x2 / o4, f2[i2 + 3] = b2 / a3;
    }
  return i;
}
function y(t2, i, o3) {
  if (!i)
    return t2;
  const { framebufferWidth: a2, framebufferHeight: r2, pixelRatio: l2, region: g2 } = t2, u2 = P(t2, o3), f2 = u2.left + u2.right, d2 = u2.top + u2.bottom, c2 = a2 - f2, s2 = r2 - d2, w2 = Math.min(n, Math.min((h - f2) / c2, (h - d2) / s2));
  return w2 < e ? t2 : { ...t2, framebufferWidth: Math.round(c2 * w2) + f2, framebufferHeight: Math.round(s2 * w2) + d2, pixelRatio: l2 * w2, resample: { region: { x: Math.round((g2.x - u2.left) * w2) + u2.left, y: Math.round((g2.y - u2.top) * w2) + u2.top, width: Math.round(g2.width * w2), height: Math.round(g2.height * w2) }, width: a2, height: r2 } };
}
function x(t2, i, h2) {
  return h2 || (h2 = D()), h2.getContext("2d").createImageData(t2, i);
}
var b = null;
var j = true;
function D() {
  return b || (b = document.createElement("canvas"), b.width = 1, b.height = 1), b;
}
function v(t2, i) {
  if (!t2)
    return i;
  const h2 = t2.width, e2 = t2.height;
  if (null != h2 && null != e2)
    return { width: Math.floor(h2), height: Math.floor(e2) };
  if (null == h2 && null == e2)
    return i;
  const n2 = i.width / i.height;
  return null == e2 ? { width: Math.floor(h2), height: Math.floor(h2 / n2) } : { width: Math.floor(e2 * n2), height: Math.floor(e2) };
}
function q(t2, i) {
  const h2 = { x: 0, y: 0, width: i.width, height: i.height };
  if (t2 && t2.area) {
    null != t2.area.x && (h2.x = Math.floor(t2.area.x)), null != t2.area.y && (h2.y = Math.floor(t2.area.y));
    const e2 = null != t2.area.width ? Math.floor(t2.area.width) : null, n2 = null != t2.area.height ? Math.floor(t2.area.height) : null;
    if (h2.width = i.width - h2.x, h2.height = i.height - h2.y, null != e2 && null != n2)
      h2.width = Math.min(h2.width, e2), h2.height = Math.min(h2.height, n2);
    else if (null == e2 && null != n2) {
      const t3 = Math.min(h2.width, e2);
      h2.height = t3 / h2.width * h2.height, h2.width = t3;
    } else if (null != e2 && null == n2) {
      const t3 = Math.min(h2.height, n2);
      h2.width = t3 / h2.height * h2.width, h2.height = t3;
    }
  }
  return I(C(h2, t2), i);
}
function I(t2, i) {
  const h2 = Math.floor(Math.max(t2.x, 0)), e2 = Math.floor(Math.max(t2.y, 0)), n2 = { x: h2, y: e2, width: Math.floor(Math.min(t2.width, i.width - h2)), height: Math.floor(Math.min(t2.height, i.height - e2)) }, o3 = n2.width / n2.height, a2 = t2.width / t2.height;
  if (a2 === o3)
    return n2;
  if (a2 > o3) {
    const t3 = Math.floor(n2.width / a2), i2 = n2.height - t3;
    return { x: n2.x, y: Math.floor(n2.y + i2 / 2), width: n2.width, height: t3 };
  }
  const r2 = Math.floor(n2.height * a2), l2 = n2.width - r2;
  return { x: Math.floor(n2.x + l2 / 2), y: n2.y, width: r2, height: n2.height };
}
function C(t2, i) {
  if (!i || null == i.width || null == i.height)
    return t2;
  const h2 = i.width / i.height, e2 = t2.width / t2.height;
  if (e2 === h2)
    return t2;
  if (e2 < h2) {
    const i2 = Math.floor(t2.height * h2);
    return t2.x -= (i2 - t2.width) / 2, t2.width = i2, t2;
  }
  const n2 = Math.floor(t2.width / h2);
  return t2.y -= (n2 - t2.height) / 2, t2.height = n2, t2;
}
function P(t2, i) {
  return !i || t2 && t2.ignorePadding ? A : i;
}
function k(t2) {
  switch (t2) {
    case "png":
    case "jpg":
    case "jpeg":
      return t2;
    default:
      return U;
  }
}
function B(t2) {
  t2.save(), t2.globalCompositeOperation = "copy", t2.scale(1, -1), t2.translate(0, -t2.canvas.height), t2.drawImage(t2.canvas, 0, 0), t2.restore();
}
function E(t2) {
  const i = t2.data, h2 = i.length;
  for (let e2 = 0; e2 < h2; e2 += 4) {
    const t3 = i[e2 + 3];
    if (255 !== t3 && t3 > 0) {
      const h3 = 255 / t3;
      i[e2 + 0] = i[e2 + 0] * h3, i[e2 + 1] = i[e2 + 1] * h3, i[e2 + 2] = i[e2 + 2] * h3;
    }
  }
}
var R = { png: "image/png", jpg: "image/jpeg", jpeg: "image/jpeg" };
var H = 98;
var U = "png";
var W = { png: 100, jpg: H, jpeg: H };
var A = { top: 0, right: 0, bottom: 0, left: 0 };

export {
  a,
  r,
  l,
  s,
  w,
  m,
  M,
  p,
  y
};
//# sourceMappingURL=chunk-MZ4JF5C6.js.map
