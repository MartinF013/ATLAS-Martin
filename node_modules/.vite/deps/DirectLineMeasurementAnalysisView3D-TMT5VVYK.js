import {
  e as e7,
  o as o5
} from "./chunk-M5Q6O4EN.js";
import {
  i as i2,
  t as t4
} from "./chunk-HXWHE6NR.js";
import {
  e as e6
} from "./chunk-233LLPHP.js";
import {
  j as j3
} from "./chunk-ZIG56NBC.js";
import {
  I as I2,
  l as l3,
  m as m2,
  v as v2
} from "./chunk-WFV6S5JH.js";
import "./chunk-2RRRGIMY.js";
import {
  s as s4
} from "./chunk-HGETZUJU.js";
import {
  a as a2,
  n as n5
} from "./chunk-FDKIF5RK.js";
import {
  n as n4
} from "./chunk-KQRXZVEP.js";
import {
  C as C2
} from "./chunk-OGZ4KF5L.js";
import {
  n as n6
} from "./chunk-JYMQQ22E.js";
import "./chunk-JYWDI7GA.js";
import {
  r as r5
} from "./chunk-B6K3W2TL.js";
import "./chunk-A2XF5TZW.js";
import {
  M as M3,
  g as g2,
  j as j2,
  w as w2,
  y as y3
} from "./chunk-VOFRIPQR.js";
import {
  r as r2,
  v
} from "./chunk-7LOTF6IL.js";
import "./chunk-DSCM4HDL.js";
import {
  r as r4
} from "./chunk-KYD2B4O6.js";
import "./chunk-PUU4QXN5.js";
import "./chunk-EHWEX2VK.js";
import "./chunk-HPO2NV7P.js";
import "./chunk-22O7HU3A.js";
import "./chunk-Y75V5CF3.js";
import "./chunk-PQM6RARY.js";
import "./chunk-2Y5KPYOJ.js";
import "./chunk-BBUIX72C.js";
import "./chunk-5ZS6RUSM.js";
import "./chunk-R3PFJUIG.js";
import "./chunk-7LH2XNVI.js";
import "./chunk-PXOPYXIX.js";
import "./chunk-WSQIVEW5.js";
import "./chunk-ZTFWVZTL.js";
import "./chunk-ELZC3DZT.js";
import "./chunk-TGUQXVQU.js";
import "./chunk-4LQ6NAOX.js";
import "./chunk-K37I5IIG.js";
import "./chunk-GKYJJGE3.js";
import "./chunk-AWIG2DGF.js";
import "./chunk-3236UEJN.js";
import "./chunk-KSOWE6GO.js";
import "./chunk-ZLORWBMB.js";
import "./chunk-CNL2CHF7.js";
import "./chunk-HRAEK6P4.js";
import "./chunk-K6UIDSFF.js";
import {
  T as T2
} from "./chunk-52W4YMC2.js";
import "./chunk-AIONJO5O.js";
import "./chunk-YLSPLHY5.js";
import "./chunk-4GGQTXXY.js";
import "./chunk-QMP4VG7M.js";
import "./chunk-5RP42VZJ.js";
import {
  r as r3
} from "./chunk-KD6KBT2L.js";
import "./chunk-XEWFCJLT.js";
import "./chunk-ZEDAE7EU.js";
import "./chunk-YXFNNKMT.js";
import "./chunk-7OZR6JFF.js";
import {
  e as e4,
  o as o4,
  t as t3
} from "./chunk-NXOQBIK7.js";
import {
  E as E4
} from "./chunk-ERNXFM5T.js";
import {
  i
} from "./chunk-6ITXWFMK.js";
import {
  e as e5
} from "./chunk-SV4VP57N.js";
import "./chunk-PWYPPSAW.js";
import {
  E as E3,
  c as c4
} from "./chunk-5EXPMKQP.js";
import {
  W,
  a,
  c as c3
} from "./chunk-B7F3T673.js";
import "./chunk-QXYW5CVF.js";
import "./chunk-Z7AZMEL6.js";
import "./chunk-FUKESVWQ.js";
import "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-XEIRRA3E.js";
import "./chunk-B3IXFXV6.js";
import "./chunk-XNOIZLCR.js";
import "./chunk-I22L7HNU.js";
import "./chunk-44UD36FH.js";
import "./chunk-ODYLXHP4.js";
import "./chunk-Y5AGUEHG.js";
import "./chunk-DVE4HUBR.js";
import "./chunk-RC6OMMF6.js";
import "./chunk-AWPZQDE5.js";
import "./chunk-OYNEZ5VG.js";
import "./chunk-R67CDTDF.js";
import "./chunk-UCWSHVC4.js";
import "./chunk-DHZ2TSD5.js";
import "./chunk-FAF3GP2W.js";
import "./chunk-YSWURJZW.js";
import "./chunk-5JKCNCL2.js";
import "./chunk-2YDCEMEJ.js";
import "./chunk-O7YSDCZE.js";
import "./chunk-767LZ6IM.js";
import "./chunk-TTKSAULB.js";
import {
  t as t2
} from "./chunk-WJDUBZ7S.js";
import "./chunk-DNPZNIDB.js";
import "./chunk-WW7VYUQW.js";
import "./chunk-FCDEMPPS.js";
import {
  o as o2
} from "./chunk-TEJEYVH4.js";
import "./chunk-HEZ2ATGC.js";
import "./chunk-AALA53RH.js";
import "./chunk-BOVIIQLB.js";
import "./chunk-IJHFAZOW.js";
import "./chunk-DMGVDNFD.js";
import "./chunk-YAQGRU5B.js";
import "./chunk-M3GMIUQS.js";
import "./chunk-BMA2CXVS.js";
import "./chunk-46N7XS5M.js";
import "./chunk-4MKQUQD4.js";
import "./chunk-A3QLZKCF.js";
import "./chunk-OYAHQ564.js";
import "./chunk-LGILR4HN.js";
import "./chunk-I5UNY2WQ.js";
import "./chunk-EYJ2F5XB.js";
import "./chunk-5EPJG7SL.js";
import "./chunk-TR3U55RZ.js";
import {
  T
} from "./chunk-3DCTMZI6.js";
import "./chunk-33INAWJA.js";
import "./chunk-5WOO2FX6.js";
import {
  E,
  I
} from "./chunk-FPMD6IB4.js";
import "./chunk-J73IXFNW.js";
import "./chunk-MQBVOUKB.js";
import "./chunk-PLLZPG4O.js";
import "./chunk-WQLER7IU.js";
import "./chunk-7GTYHKA3.js";
import "./chunk-MOXYEJRV.js";
import {
  d2,
  h as h2,
  o2 as o3
} from "./chunk-EEJIELE6.js";
import {
  E as E2
} from "./chunk-Y55TYMBP.js";
import "./chunk-NAB3NF54.js";
import "./chunk-MHB3L22D.js";
import {
  O as O3
} from "./chunk-MDCKEJ7B.js";
import "./chunk-MLAOYRDT.js";
import {
  O as O2
} from "./chunk-VMF4NMEB.js";
import "./chunk-NAIF4GWX.js";
import "./chunk-72PB636Q.js";
import "./chunk-RIOXX6J2.js";
import "./chunk-SOZCO2CU.js";
import "./chunk-53KI6WDE.js";
import "./chunk-W2HLA6I3.js";
import "./chunk-Q6AASANP.js";
import {
  c as c2
} from "./chunk-ZYIEYKCD.js";
import "./chunk-DLM6NKXW.js";
import "./chunk-TQLSOIYV.js";
import {
  e as e3
} from "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-3NPGGTI6.js";
import {
  j
} from "./chunk-YZNDHJDJ.js";
import "./chunk-GT2OBOXC.js";
import "./chunk-ZN2MGN4S.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-W66LN57L.js";
import "./chunk-FUQI3AAI.js";
import {
  An,
  Hn,
  jn
} from "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import {
  h
} from "./chunk-3DZ4BNVJ.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-F5A4XAOJ.js";
import {
  n as n3
} from "./chunk-U7B2WKBH.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-WKRVG5MO.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  f as f2,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import {
  M,
  y as y2,
  z
} from "./chunk-DYETG5YB.js";
import "./chunk-CLGCKZUR.js";
import {
  G,
  K,
  N,
  O,
  R
} from "./chunk-RN2KRYDN.js";
import {
  C
} from "./chunk-AWWWJUTQ.js";
import "./chunk-EQNRDJV7.js";
import "./chunk-FEEXJRYO.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import {
  s as s3,
  x as x2
} from "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import {
  s as s2
} from "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import {
  M as M2,
  f,
  g
} from "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import {
  L,
  _,
  e as e2,
  o,
  q,
  u,
  x,
  z as z2
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import {
  n as n2
} from "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import {
  m2 as m
} from "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  c,
  l,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementController.js
var S = s.getLogger("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController");
var C3 = 1e5;
var L2 = class extends y {
  constructor(e8) {
    super(e8), this._unitNormalizer = new t4(), this._handles = new u2(), this._tempStartPosition = n2(), this._tempEndPosition = n2(), this._tempCornerPosition = n2();
  }
  initialize() {
    this._handles.add(f2(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.ready;
    }, () => this._initialize(), { once: true, sync: true, initial: true }));
  }
  destroy() {
    this._handles = l(this._handles);
  }
  _initialize() {
    const e8 = this.view.spatialReference, t5 = O(e8), i3 = t5 === G ? R : t5;
    this._sphericalPCPF = i3;
    const s5 = An(e8, i3);
    this._unitNormalizer.spatialReference = s5 ? i3 : e8, this._handles.add([l2(() => ({ viewData: this.viewData, startPoint: this.analysis.startPoint }), ({ viewData: e9, startPoint: t6 }) => {
      e9.elevationAlignedStartPoint = this._applyProjectionAndElevationAlignment(t6);
    }, w), l2(() => ({ viewData: this.viewData, endPoint: this.analysis.endPoint }), ({ viewData: e9, endPoint: t6 }) => {
      e9.elevationAlignedEndPoint = this._applyProjectionAndElevationAlignment(t6);
    }, w), l2(() => ({ result: this._computedResult, viewData: this.viewData }), ({ result: e9, viewData: t6 }) => {
      t6.result = e9;
    }, w)]);
  }
  _applyProjectionAndElevationAlignment(e8) {
    if (t(e8))
      return e8;
    const t5 = n5(e8, this.view.spatialReference, this.view.elevationProvider);
    return t(t5) ? (a2(this.analysis, e8.spatialReference, S), null) : t5;
  }
  get _computedResult() {
    const { elevationAlignedStartPoint: e8, elevationAlignedEndPoint: t5, measurementMode: i3 } = this.viewData;
    if (t(e8) || t(t5))
      return null;
    const s5 = this._euclideanDistances(e8, t5), o6 = this._geodesicDistance(e8, t5, s5.horizontal.value), n7 = i3 === e6.Geodesic || i3 === e6.Auto && s5.horizontal.value > C3 ? "geodesic" : "euclidean";
    return { mode: n7, distance: "euclidean" === n7 ? s5.direct : o6, directDistance: s5.direct, horizontalDistance: s5.horizontal, verticalDistance: s5.vertical, geodesicDistance: o6 };
  }
  _euclideanDistances(e8, t5) {
    const i3 = e8.clone();
    i3.z = t5.z;
    const s5 = this._tempStartPosition, o6 = this._tempEndPosition, r6 = this._tempCornerPosition, n7 = this.view.spatialReference, c5 = this._sphericalPCPF, l4 = An(n7, c5) ? c5 : n7;
    Hn(e8, s5, l4), Hn(t5, o6, l4), Hn(i3, r6, l4);
    const m3 = x(s5, o6), p = x(r6, o6), d3 = Math.abs(t5.z - e8.z), u4 = (e9) => this._unitNormalizer.normalizeDistance(e9), v4 = u4(m3), f3 = u4(p), y7 = u4(d3);
    return { direct: r2(v4, "meters"), horizontal: r2(f3, "meters"), vertical: r2(y7, "meters") };
  }
  _geodesicDistance(e8, t5, i3) {
    const s5 = e8.spatialReference, o6 = new m({ spatialReference: s5 });
    o6.addPath([e8, t5]);
    const r6 = s5.isGeographic && M(s5) ? y2([o6], "meters")[0] : s5.isWebMercator ? C(o6, "meters") : null, c5 = r(r6) ? r6 : this._fallbackGeodesicDistance(e8, t5, i3);
    return r2(c5, "meters");
  }
  _fallbackGeodesicDistance(e8, t5, i3) {
    if (jn(e8, U) && jn(t5, k)) {
      const e9 = { distance: 0 };
      return z(e9, U, k), e9.distance;
    }
    return i3;
  }
};
e([d()], L2.prototype, "view", void 0), e([d()], L2.prototype, "analysis", void 0), e([d()], L2.prototype, "viewData", void 0), e([d()], L2.prototype, "_computedResult", null), L2 = e([n("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController")], L2);
var U = n2();
var k = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/MeasurementArrowTechnique.js
var g3 = class extends e4 {
  constructor(e8, r6, t5) {
    super(e8, r6, t5);
  }
  initializeProgram(e8) {
    const r6 = g3.shader.get().build(this.configuration);
    return new o4(e8.rctx, r6, E2);
  }
  _setPipelineState(e8) {
    const r6 = e8 === O3.NONE, t5 = this.configuration;
    return W({ blending: t5.transparent ? r6 ? c4 : E3(e8) : null, polygonOffset: this.configuration.polygonOffsetEnabled && { factor: 0, units: -4 }, depthTest: { func: I.LESS }, depthWrite: a, colorWrite: c3 });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
  get primitiveType() {
    return E.TRIANGLE_STRIP;
  }
};
g3.shader = new t3(s4, () => import("./MeasurementArrow.glsl-ZBKZHYDR.js"));
var b = class extends i {
  constructor() {
    super(...arguments), this.polygonOffsetEnabled = false, this.transparent = false, this.transparencyPassType = O3.NONE;
  }
};
e([e5()], b.prototype, "polygonOffsetEnabled", void 0), e([e5()], b.prototype, "transparent", void 0), e([e5({ count: O3.COUNT })], b.prototype, "transparencyPassType", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/MeasurementArrowMaterial.js
var g4 = class extends d2 {
  constructor(e8) {
    super(e8, new v3()), this.techniqueConfig = new b();
  }
  getConfiguration(e8, t5) {
    return this.techniqueConfig.polygonOffsetEnabled = this.parameters.polygonOffset, this.techniqueConfig.transparent = this.parameters.stripeEvenColor[3] < 1 || this.parameters.stripeOddColor[3] < 1 || this.parameters.outlineColor[3] < 1, this.techniqueConfig.transparencyPassType = (t5 == null ? void 0 : t5.transparencyPassType) ?? O3.NONE, this.techniqueConfig;
  }
  dispose() {
  }
  intersect() {
  }
  requiresSlot(e8) {
    return e8 === E4.OPAQUE_MATERIAL;
  }
  createGLMaterial(e8) {
    return e8.output === o2.Color ? new b2(e8) : null;
  }
  createBufferWriter() {
    return new x3();
  }
};
var b2 = class extends t2 {
  beginSlot(e8) {
    return this.ensureTechnique(g3, e8);
  }
};
var v3 = class extends o3 {
  constructor() {
    super(...arguments), this.width = 32, this.outlineSize = 0.2, this.outlineColor = [1, 0.5, 0, 1], this.stripeLength = 1, this.stripeEvenColor = [1, 1, 1, 1], this.stripeOddColor = [1, 0.5, 0, 1], this.polygonOffset = false;
  }
};
var C4 = T().vec3f(O2.POSITION).vec3f(O2.NORMAL).vec2f(O2.UV0).f32(O2.AUXPOS1);
var y4 = n2();
var A = n2();
var I3 = n2();
var T3 = n2();
var j4 = n2();
var x3 = class {
  constructor() {
    this.vertexBufferLayout = C4;
  }
  allocate(e8) {
    return this.vertexBufferLayout.createBuffer(e8);
  }
  elementCount(e8) {
    return 2 * (e8.indices.get(O2.POSITION).length / 2 + 1);
  }
  write(n7, a3, c5, u4) {
    const f3 = a3.vertexAttributes.get(O2.POSITION).data, l4 = a3.vertexAttributes.get(O2.NORMAL).data, p = f3.length / 3, h4 = a3 && a3.indices && a3.indices.get(O2.POSITION);
    h4 && h4.length !== 2 * (p - 1) && console.warn("MeasurementArrowMaterial does not support indices");
    const d3 = y4, O4 = A, g6 = I3, b3 = T3, v4 = j4, C5 = n7.transformation, x4 = n7.invTranspTransformation, L3 = c5.position, S2 = c5.normal, w4 = c5.uv0;
    let M4 = 0;
    for (let m3 = 0; m3 < p; ++m3) {
      const n8 = 3 * m3;
      if (o(d3, f3[n8], f3[n8 + 1], f3[n8 + 2]), m3 < p - 1) {
        const o6 = 3 * (m3 + 1);
        o(O4, f3[o6], f3[o6 + 1], f3[o6 + 2]), o(v4, l4[o6], l4[o6 + 1], l4[o6 + 2]), z2(v4, v4), e2(g6, O4, d3), z2(g6, g6), _(b3, v4, g6), z2(b3, b3);
      }
      const a4 = x(d3, O4);
      C5 && x4 && (L(d3, d3, C5), L(O4, O4, C5), L(b3, b3, x4));
      const c6 = u4 + 2 * m3, h5 = c6 + 1;
      L3.setVec(c6, d3), L3.setVec(h5, d3), S2.setVec(c6, b3), S2.setVec(h5, b3), w4.set(c6, 0, M4), w4.set(c6, 1, -1), w4.set(h5, 0, M4), w4.set(h5, 1, 1), m3 < p - 1 && (M4 += a4);
    }
    const q3 = c5.auxpos1;
    for (let e8 = 0; e8 < 2 * p; ++e8)
      q3.set(u4 + e8, M4);
  }
};

// node_modules/@arcgis/core/views/3d/interactive/visualElements/MeasurementArrowVisualElement.js
var _2 = class extends n6 {
  constructor(e8) {
    super(e8), this._parameters = w3, this._handles = null, this._origin = n2(), this._originTransform = e3(), this._arrowCenter = n2(), this._renderOccluded = h2.OccludeAndTransparent, this._geometry = null, this._stripeLength = 1, this._stripesEnabled = true, this._opacity = 1, this.applyProps(e8);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e8) {
    e8 !== this._renderOccluded && (this._renderOccluded = e8, this._arrowMaterial && this._arrowMaterial.setParameters({ renderOccluded: e8 }));
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e8) {
    this._geometry = e8, this._geometryChanged();
  }
  get stripeLength() {
    return this._stripeLength;
  }
  set stripeLength(e8) {
    this._stripeLength = e8, this.attached && this._arrowMaterial.setParameters({ stripeLength: this._stripeLength });
  }
  get stripesEnabled() {
    return this._stripesEnabled;
  }
  set stripesEnabled(e8) {
    if (this._stripesEnabled = e8, this.attached) {
      const e9 = this.opacity, { arrowStripeEvenColor: t5, arrowStripeOddColor: s5 } = this._parameters, i3 = g(g5, this._stripesEnabled ? t5 : s5, e9);
      this._arrowMaterial.setParameters({ stripeEvenColor: i3 });
    }
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e8) {
    e8 !== this._opacity && (this._opacity = e8, this._updateArrowOpacity());
  }
  createExternalResources() {
    const { arrowStripeEvenColor: r6, arrowStripeOddColor: t5, arrowOutlineColor: s5 } = this._parameters, o6 = this._stripesEnabled ? r6 : t5;
    this._arrowMaterial = new g4({ outlineColor: s5, stripeEvenColor: o6, stripeOddColor: t5, renderOccluded: this.renderOccluded, polygonOffset: true }), this._handles = new u2(), this._handles.add(l2(() => this.view.state.camera, () => {
      this._viewChanged();
    }));
  }
  destroyExternalResources() {
    this._arrowMaterial = null, this._handles.destroy(), this._handles = null;
  }
  forEachExternalMaterial(e8) {
    e8(this._arrowMaterial);
  }
  createGeometries(e8) {
    if (t(this._geometry) || t(this._geometry.startRenderSpace) || t(this._geometry.endRenderSpace))
      return;
    const r6 = this._createArrowGeometry(this._geometry.startRenderSpace, this._geometry.endRenderSpace, this._origin, this._geometry);
    e8.addGeometry(r6, this._arrowMaterial, this._originTransform), this._viewChanged();
  }
  _createArrowGeometry(e8, r6, t5, s5) {
    const i3 = this.view.renderCoordsHelper, o6 = [], n7 = [], h4 = (e9, r7) => {
      const s6 = c2.get();
      e2(s6, e9, t5), o6.push(s6), n7.push(r7);
    };
    if ("euclidean" === s5.type) {
      s5.eval(0.5, this._arrowCenter);
      const t6 = c2.get();
      i3.worldUpAtPosition(this._arrowCenter, t6), h4(e8, t6), h4(r6, t6);
    } else {
      s5.eval(0.5, this._arrowCenter);
      const e9 = this._parameters.arrowSubdivisions + 1 & -2;
      for (let r7 = 0; r7 < e9; ++r7) {
        const t6 = r7 / (e9 - 1), o7 = c2.get(), a3 = c2.get();
        s5.eval(t6, o7), i3.worldUpAtPosition(o7, a3), h4(o7, a3);
      }
    }
    return T2.createPolylineGeometry(o6, n7);
  }
  _geometryChanged() {
    this.recreateGeometry();
  }
  _viewChanged() {
    if (this.view.ready && this.attached && r(this._geometry)) {
      const e8 = this.view.state.camera.computeScreenPixelSizeAt(this._arrowCenter);
      this._arrowMaterial.setParameters({ width: this._parameters.arrowWidth * e8 });
    }
  }
  _updateArrowOpacity() {
    const e8 = this.opacity, { arrowStripeEvenColor: t5, arrowStripeOddColor: s5, arrowOutlineColor: i3 } = this._parameters, o6 = g(g5, this._stripesEnabled ? t5 : s5, e8), a3 = g(u3, i3, e8), n7 = g(y5, s5, e8);
    this._arrowMaterial.setParameters({ stripeEvenColor: o6, outlineColor: a3, stripeOddColor: n7 });
  }
};
var w3 = { arrowWidth: 16, arrowOutlineColor: [1, 0.5, 0, 1], arrowOutlineWidth: 0.2, arrowStripeEvenColor: [1, 1, 1, 1], arrowStripeOddColor: [1, 0.5, 0, 1], arrowStripeLength: 16, arrowSubdivisions: 128 };
var g5 = n3();
var u3 = n3();
var y5 = n3();

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementVisualization.js
var W2;
!function(e8) {
  e8[e8.Pending = 0] = "Pending", e8[e8.Ready = 1] = "Ready", e8[e8.Destroyed = 2] = "Destroyed";
}(W2 || (W2 = {}));
var Q = class extends y {
  constructor(e8) {
    super(e8), this._params = { ...N2 }, this._handles = new u2(), this._segmentVisualElement = null, this._triangleVisualElement = null, this._rightAngleQuad = null, this._projectedGeodesicLine = null, this._geodesicStartHint = null, this._geodesicEndHint = null, this._segmentLabel = null, this._verticalLabel = null, this._horizontalLabel = null, this._startPosition = n2(), this._endPosition = n2(), this._cornerPosition = n2(), this._startPositionAtSeaLevel = n2(), this._endPositionAtSeaLevel = n2(), this._triangleOrientationOverride = null, this.messages = null, this.loadingMessages = true, this.visualElementOrientation = o5.Auto, this.triangleCollapseRatioThreshold = 0.03;
  }
  get visible() {
    return this.analysisView.visible;
  }
  get viewMode() {
    const { elevationAlignedStartPoint: e8, elevationAlignedEndPoint: t5 } = this.analysisView;
    if (t(e8) || t(t5) || e8.equals(t5))
      return e7.None;
    const i3 = this.analysisView.result;
    if (t(i3))
      return e7.Direct;
    if ("geodesic" === i3.mode)
      return this._requiresGeodesicGuideAt(this._startPosition) || this._requiresGeodesicGuideAt(this._endPosition) ? e7.ProjectedGeodesic : e7.Direct;
    const { verticalDistance: s5, horizontalDistance: n7 } = i3, o6 = s5.value, r6 = n7.value;
    return Math.min(o6 / r6, r6 / o6) < this.triangleCollapseRatioThreshold ? e7.Direct : e7.Triangle;
  }
  get actualVisualizedMeasurement() {
    if (t(this.analysisView.result))
      switch (this.analysisView.measurementMode) {
        case e6.Auto:
        case e6.Euclidean:
        default:
          return "euclidean";
        case e6.Geodesic:
          return "geodesic";
      }
    return this.analysisView.result.mode;
  }
  get allowVisualElementsOrientationChange() {
    return t(this._triangleOrientationOverride);
  }
  set allowVisualElementsOrientationChange(e8) {
    t(this._triangleOrientationOverride) !== e8 && (t(this._triangleOrientationOverride) ? this._triangleOrientationOverride = this._actualVisualElementsOrientation : this._triangleOrientationOverride = null);
  }
  get labels() {
    const e8 = "geodesic" === this.actualVisualizedMeasurement;
    return { direct: this._segmentLabel, horizontal: e8 ? this._segmentLabel : this._horizontalLabel, vertical: this._verticalLabel };
  }
  initialize() {
    const e8 = this._params, t5 = { attached: true, view: this.view };
    this._segmentVisualElement = new _2({ ...t5, geometry: null, renderOccluded: h2.OccludeAndTransparent }), this._triangleVisualElement = new C2({ ...t5, width: e8.triangleLineWidth, color: e8.triangleColor, renderOccluded: h2.OccludeAndTransparent }), this._rightAngleQuad = new j3({ ...t5, color: B, renderOccluded: h2.OccludeAndTransparent });
    const i3 = { ...t5, polygonOffset: true, renderOccluded: h2.OccludeAndTransparent };
    this._projectedGeodesicLine = new C2({ ...i3, width: e8.geodesicProjectionLineWidth, color: e8.geodesicProjectionLineColor, stipplePattern: r4(e8.guideStippleLengthPixels) }), this._geodesicStartHint = new C2({ ...i3, width: e8.guideLineWidth, color: e8.geodesicProjectionLineColor, stipplePattern: r4(e8.guideStippleLengthPixels) }), this._geodesicEndHint = new C2({ ...i3, width: e8.guideLineWidth, color: e8.geodesicProjectionLineColor, stipplePattern: r4(e8.guideStippleLengthPixels) }), this._segmentLabel = new v2({ ...t5, fontSize: e8.direcLabelFontSize }), this._verticalLabel = new v2({ ...t5, fontSize: e8.verticalLabelFontSize }), this._horizontalLabel = new v2({ ...t5, fontSize: e8.horizontalLabelFontSize }), this._handles.add([l2(() => {
      const { elevationAlignedStartPoint: e9, elevationAlignedEndPoint: t6 } = this.analysisView, i4 = this.view;
      return { view: i4, camera: i4.state.camera, viewMode: this.viewMode, elevationAlignedStartPoint: e9, elevationAlignedEndPoint: t6, orientation: this._actualVisualElementsOrientation, visualizedMeasurement: this.actualVisualizedMeasurement, stripeLength: this._measurementArrowStripeLength };
    }, (e9) => this._updateGeometryAndViewMode(e9), w), l2(() => ({ visible: this.visible, viewMode: this.viewMode }), (e9) => this._updateVisualElementVisibility(e9), w), l2(() => ({ text: this._labelsText, visualizedMeasurement: this.actualVisualizedMeasurement }), (e9) => this._updateLabelText(e9), w), l2(() => ({ visible: this.visible, viewMode: this.viewMode }), (e9) => this._updateLabelVisibility(e9), w), l2(() => this._measurementArrowStripeLength, (e9) => this._updateSegmentStripeLength(e9), w), s2(async () => this._updateMessageBundle())]), this._updateMessageBundle();
  }
  destroy() {
    this._handles = l(this._handles), this._segmentVisualElement = l(this._segmentVisualElement), this._triangleVisualElement = l(this._triangleVisualElement), this._rightAngleQuad = l(this._rightAngleQuad), this._projectedGeodesicLine = l(this._projectedGeodesicLine), this._geodesicStartHint = l(this._geodesicStartHint), this._geodesicEndHint = l(this._geodesicEndHint), this._segmentLabel = l(this._segmentLabel), this._verticalLabel = l(this._verticalLabel), this._horizontalLabel = l(this._horizontalLabel), this.set("view", null);
  }
  _updateVisualElementVisibility({ visible: e8, viewMode: t5 }) {
    if (this._segmentVisualElement.visible = false, this._triangleVisualElement.visible = false, this._rightAngleQuad.visible = false, this._projectedGeodesicLine.visible = false, this._geodesicStartHint.visible = false, this._geodesicEndHint.visible = false, e8)
      switch (t5) {
        case e7.None:
          break;
        case e7.Direct:
          this._segmentVisualElement.visible = true;
          break;
        case e7.Triangle:
          this._segmentVisualElement.visible = true, this._triangleVisualElement.visible = true, this._rightAngleQuad.visible = true;
          break;
        case e7.ProjectedGeodesic:
          this._segmentVisualElement.visible = true, this._projectedGeodesicLine.visible = true, this._geodesicStartHint.visible = true, this._geodesicEndHint.visible = true;
      }
  }
  _updateGeometryAndViewMode({ view: e8, camera: t5, viewMode: i3, elevationAlignedStartPoint: s5, elevationAlignedEndPoint: n7, orientation: o6, visualizedMeasurement: r6, stripeLength: l4 }) {
    const c5 = e8.renderCoordsHelper;
    if (t(c5) || t(s5) || t(n7) || s5.equals(n7))
      return;
    let d3 = this._startPosition, h4 = this._endPosition;
    c5.toRenderCoords(s5, d3), c5.toRenderCoords(n7, h4);
    const u4 = o6 === o5.AboveSegment ? 1 : -1, m3 = u4 * (c5.getAltitude(h4) - c5.getAltitude(d3));
    m3 < 0 && (d3 = this._endPosition, h4 = this._startPosition);
    const g6 = "geodesic" === r6 ? new m2(this._startPosition, this._endPosition, c5.spatialReference) : new l3(this._startPosition, this._endPosition);
    switch (this._segmentVisualElement.geometry = g6, this._updateSegmentStripeLength(l4), i3) {
      case e7.Direct:
        this._updateSegment(g6, o6);
        break;
      case e7.Triangle:
        this._updateSegmentAndTriangle({ view: e8, camera: t5, segment: g6, orientation: o6, startPosition: d3, endPosition: h4, deltaSign: u4, altitudeDelta: m3 });
        break;
      case e7.ProjectedGeodesic:
        this._updateSegmentAndProjection({ view: e8, orientation: o6, startPosition: d3, endPosition: h4 });
    }
  }
  _updateSegment(e8, t5) {
    this._segmentLabel.anchor = t5 === o5.AboveSegment ? "top" : "bottom", this._segmentLabel.geometry = { type: "segment", segment: e8, sampleLocation: "center" };
  }
  _updateSegmentAndTriangle({ view: { renderCoordsHelper: e8 }, camera: t5, segment: i3, orientation: s5, startPosition: n7, endPosition: a3, deltaSign: o6, altitudeDelta: r6 }) {
    const l4 = this._cornerPosition;
    e8.worldUpAtPosition(n7, l4), q(l4, l4, o6 * Math.abs(r6)), u(l4, l4, n7), this._triangleVisualElement.geometry = [[[n7[0], n7[1], n7[2]], [l4[0], l4[1], l4[2]], [a3[0], a3[1], a3[2]]]], this._rightAngleQuad.geometry = { previous: n7, center: l4, next: a3 };
    const c5 = new l3(n7, l4), d3 = new l3(l4, a3), h4 = q2(n7, a3, l4, s5, t5);
    this._segmentLabel.anchor = h4.segment, this._segmentLabel.geometry = { type: "segment", segment: i3, sampleLocation: "center" }, this._verticalLabel.geometry = { type: "segment", segment: c5, sampleLocation: "center" }, this._verticalLabel.anchor = h4.vertical, this._horizontalLabel.geometry = { type: "segment", segment: d3, sampleLocation: "center" }, this._horizontalLabel.anchor = h4.horizontal;
  }
  _updateSegmentAndProjection({ view: { renderCoordsHelper: e8 }, orientation: t5, startPosition: i3, endPosition: s5 }) {
    e8.setAltitude(this._startPositionAtSeaLevel, 0, i3), e8.setAltitude(this._endPositionAtSeaLevel, 0, s5);
    const n7 = new m2(this._startPositionAtSeaLevel, this._endPositionAtSeaLevel, e8.spatialReference);
    this._projectedGeodesicLine.setGeometryFromSegment(n7), this._geodesicStartHint.setGeometryFromSegment(new l3(this._startPositionAtSeaLevel, i3)), this._geodesicEndHint.setGeometryFromSegment(new l3(this._endPositionAtSeaLevel, s5)), this._segmentLabel.geometry = { type: "segment", segment: n7, sampleLocation: "center" }, this._segmentLabel.anchor = t5 === o5.AboveSegment ? "top" : "bottom";
  }
  _updateLabelText({ text: e8, visualizedMeasurement: t5 }) {
    r(e8) ? (this._segmentLabel.text = "euclidean" === t5 ? e8.euclideanDistance : e8.geodesicDistance, this._horizontalLabel.text = e8.horizontalDistance, this._verticalLabel.text = e8.verticalDistance) : (this._segmentLabel.text = null, this._horizontalLabel.text = null, this._verticalLabel.text = null), this.notifyChange("labels");
  }
  _updateLabelVisibility({ visible: e8, viewMode: t5 }) {
    const i3 = this._segmentLabel, s5 = this._horizontalLabel, n7 = this._verticalLabel;
    if (i3.visible = false, s5.visible = false, n7.visible = false, e8)
      switch (t5) {
        case e7.Direct:
          i3.visible = true;
          break;
        case e7.Triangle:
          i3.visible = true, s5.visible = true, n7.visible = true;
          break;
        case e7.ProjectedGeodesic:
          i3.visible = true;
        case e7.None:
      }
  }
  get _labelsText() {
    if (this.destroyed)
      return null;
    const e8 = this.messages, t5 = this.analysisView.result;
    if (t(t5) || t(e8))
      return null;
    const { directDistance: i3, horizontalDistance: s5, verticalDistance: n7, geodesicDistance: o6 } = t5, r6 = this.analysisView.unit, m3 = (e9) => ({ euclideanDistance: "", geodesicDistance: "", horizontalDistance: "", verticalDistance: "", ...e9 });
    switch (r6) {
      case "metric":
        return m3({ euclideanDistance: i3 && M3(e8, i3), geodesicDistance: o6 && M3(e8, o6), horizontalDistance: s5 && M3(e8, s5), verticalDistance: n7 && w2(e8, n7) });
      case "imperial":
        return m3({ euclideanDistance: i3 && y3(e8, i3), geodesicDistance: o6 && y3(e8, o6), horizontalDistance: s5 && y3(e8, s5), verticalDistance: n7 && j2(e8, n7) });
      default:
        return m3({ euclideanDistance: i3 && g2(e8, i3, r6), geodesicDistance: o6 && g2(e8, o6, r6), horizontalDistance: s5 && g2(e8, s5, r6), verticalDistance: n7 && g2(e8, n7, r6) });
    }
  }
  _updateSegmentStripeLength(e8) {
    const t5 = this._segmentVisualElement;
    r(e8) ? (t5.stripeLength = e8, t5.stripesEnabled = true) : t5.stripesEnabled = false;
  }
  get _actualVisualElementsOrientation() {
    if (r(this._triangleOrientationOverride))
      return this._triangleOrientationOverride;
    const e8 = this.visualElementOrientation;
    return e8 === o5.Auto ? this.view.state.camera.aboveGround ? o5.AboveSegment : o5.BelowSegment : e8;
  }
  _requiresGeodesicGuideAt(e8) {
    const t5 = this.view;
    if (!(t5 == null ? void 0 : t5.state))
      return false;
    const i3 = t5.state.camera, s5 = t5.renderCoordsHelper, n7 = i3.computeScreenPixelSizeAt(e8);
    return s5.getAltitude(e8) / n7 >= 10;
  }
  get _measurementArrowStripeLength() {
    const { result: e8, unit: t5 } = this.analysisView;
    if (t(e8))
      return null;
    let i3 = null;
    const n7 = e8.directDistance;
    switch (t5) {
      case "metric":
        i3 = n7 && v(n7, "meters");
        break;
      case "imperial":
        i3 = n7 && v(n7, K(n7.value, n7.unit));
        break;
      default:
        i3 = n7 && v(n7, t5);
    }
    if (t(i3))
      return null;
    return f(i3.value / 30) * N(1, i3.unit, "meters");
  }
  _updateMessageBundle() {
    this.loadingMessages = true, h("esri/core/t9n/Units").then((e8) => {
      this.messages = e8;
    }).finally(() => {
      this.loadingMessages = false;
    });
  }
  get testData() {
    var _a;
    return { labels: this.labels, stripeLength: (_a = this._segmentVisualElement) == null ? void 0 : _a.stripeLength };
  }
};
function q2(e8, t5, i3, s5, n7) {
  const a3 = J, o6 = K2;
  n7.projectToRenderScreen(i3, a3), n7.projectToRenderScreen(t5, o6);
  const r6 = { segment: "bottom", horizontal: "top", vertical: a3[0] < o6[0] ? "left" : "right" };
  {
    const s6 = X, a4 = Y;
    if (i2(e8, i3, s6, n7), i2(e8, t5, a4, n7), j(s6, a4) >= I4) {
      const e9 = Math.sign(s6[1]) === Math.sign(a4[1]);
      r6.segment = e9 ? I2(r6.vertical) : r6.vertical;
    } else {
      const e9 = Z;
      i2(i3, t5, e9, n7), j(e9, a4) >= I4 && (r6.segment = Math.sign(e9[0]) === Math.sign(a4[0]) ? I2(r6.horizontal) : r6.horizontal);
    }
  }
  if (s5 === o5.BelowSegment) {
    const e9 = (e10) => "top" === e10 ? "bottom" : "top";
    r6.segment = e9(r6.segment), r6.horizontal = e9(r6.horizontal), r6.vertical = e9(r6.vertical);
  }
  return r6;
}
e([d()], Q.prototype, "_triangleOrientationOverride", void 0), e([d()], Q.prototype, "messages", void 0), e([d()], Q.prototype, "view", void 0), e([d()], Q.prototype, "analysis", void 0), e([d()], Q.prototype, "analysisView", void 0), e([d()], Q.prototype, "loadingMessages", void 0), e([d()], Q.prototype, "visible", null), e([d()], Q.prototype, "viewMode", null), e([d()], Q.prototype, "actualVisualizedMeasurement", null), e([d()], Q.prototype, "visualElementOrientation", void 0), e([d()], Q.prototype, "triangleCollapseRatioThreshold", void 0), e([d()], Q.prototype, "allowVisualElementsOrientationChange", null), e([d()], Q.prototype, "labels", null), e([d()], Q.prototype, "_labelsText", null), e([d()], Q.prototype, "_actualVisualElementsOrientation", null), e([d()], Q.prototype, "_measurementArrowStripeLength", null), Q = e([n("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementVisualization")], Q);
var B = r3(1, 0.5, 0, 0.75);
var N2 = { laserLineGlowColor: [1, 0.5, 0], laserLineGlowWidth: 8, laserLineGlowFalloff: 8, laserLineInnerColor: [1, 1, 1], laserLineInnerWidth: 0.75, laserLineGlobalAlpha: 0.75, laserLineEnabled: true, handleColor: [1, 0.5, 0], handleOpacity: 0.5, handleRadius: 5, triangleColor: B, triangleLineWidth: 3, triangleCornerSize: 32, triangleSubdivisions: 128, arrowWidth: 16, arrowOutlineColor: [1, 0.5, 0, 1], arrowOutlineWidth: 0.2, arrowStripeEvenColor: [1, 1, 1, 1], arrowStripeOddColor: [1, 0.5, 0, 1], arrowStripeLength: 16, arrowSubdivisions: 128, geodesicProjectionLineWidth: 2, geodesicProjectionLineColor: B, guideLineWidth: 2, guideLineColor: B, guideStippleLengthPixels: 6, labelDistance: 25, direcLabelFontSize: 16, horizontalLabelFontSize: 12, verticalLabelFontSize: 12 };
var I4 = Math.cos(M2(12));
var J = x2();
var K2 = x2();
var X = s3();
var Y = s3();
var Z = s3();

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurementAnalysisView3D.js
var y6 = class extends n4(y) {
  constructor(t5) {
    super(t5), this.type = "direct-line-measurement-view-3d", this.analysis = null, this.result = null, this.measurementMode = e6.Auto, this.elevationAlignedStartPoint = null, this.elevationAlignedEndPoint = null;
  }
  initialize() {
    const t5 = this.view, i3 = this.analysis;
    this._analysisVisualization = new Q({ view: t5, analysis: i3, analysisView: this }), this._analysisController = new L2({ view: t5, analysis: i3, viewData: this });
  }
  destroy() {
    this._analysisController = l(this._analysisController), this._analysisVisualization = l(this._analysisVisualization);
  }
  get updating() {
    var _a;
    return !!((_a = this._analysisVisualization) == null ? void 0 : _a.loadingMessages);
  }
  get viewMode() {
    return this._analysisVisualization.viewMode;
  }
  get actualVisualizedMeasurement() {
    return this._analysisVisualization.actualVisualizedMeasurement;
  }
  get visualElementOrientation() {
    return this._analysisVisualization.visualElementOrientation;
  }
  set visualElementOrientation(t5) {
    this._analysisVisualization.visualElementOrientation = t5;
  }
  get allowVisualElementsOrientationChange() {
    return this._analysisVisualization.allowVisualElementsOrientationChange;
  }
  set allowVisualElementsOrientationChange(t5) {
    this._analysisVisualization.allowVisualElementsOrientationChange = t5;
  }
  get triangleCollapseRatioThreshold() {
    return this._analysisVisualization.triangleCollapseRatioThreshold;
  }
  set triangleCollapseRatioThreshold(t5) {
    this._analysisVisualization.triangleCollapseRatioThreshold = t5;
  }
  get directLabelText() {
    return this._analysisVisualization.labels.direct.text;
  }
  get horizontalLabelText() {
    return this._analysisVisualization.labels.horizontal.text;
  }
  get verticalLabelText() {
    return this._analysisVisualization.labels.vertical.text;
  }
  get unit() {
    return c(this.analysis.unit, this._defaultUnit);
  }
  get testData() {
    var _a;
    return this.destroyed ? { labels: null, stripeLength: null, visualization: null, controller: null } : { ...(_a = this._analysisVisualization) == null ? void 0 : _a.testData, visualization: this._analysisVisualization, controller: this._analysisController };
  }
};
e([d()], y6.prototype, "updating", null), e([d({ readOnly: true })], y6.prototype, "type", void 0), e([d({ constructOnly: true, nonNullable: true })], y6.prototype, "analysis", void 0), e([d()], y6.prototype, "result", void 0), e([d()], y6.prototype, "measurementMode", void 0), e([d()], y6.prototype, "elevationAlignedStartPoint", void 0), e([d()], y6.prototype, "elevationAlignedEndPoint", void 0), e([d({ readOnly: true })], y6.prototype, "viewMode", null), e([d({ readOnly: true })], y6.prototype, "actualVisualizedMeasurement", null), e([d()], y6.prototype, "visualElementOrientation", null), e([d()], y6.prototype, "allowVisualElementsOrientationChange", null), e([d()], y6.prototype, "triangleCollapseRatioThreshold", null), e([d({ readOnly: true })], y6.prototype, "directLabelText", null), e([d({ readOnly: true })], y6.prototype, "horizontalLabelText", null), e([d({ readOnly: true })], y6.prototype, "verticalLabelText", null), e([d()], y6.prototype, "_analysisVisualization", void 0), e([d()], y6.prototype, "_analysisController", void 0), e([d()], y6.prototype, "unit", null), e([d(r5)], y6.prototype, "_defaultUnit", void 0), y6 = e([n("esri.views.3d.analysis.DirectLineMeasurementAnalysisView3D")], y6);
var h3 = y6;
export {
  h3 as default
};
//# sourceMappingURL=DirectLineMeasurementAnalysisView3D-TMT5VVYK.js.map
