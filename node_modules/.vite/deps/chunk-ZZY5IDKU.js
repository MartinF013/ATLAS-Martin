import {
  e
} from "./chunk-5EQKHR4M.js";
import {
  a
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/core/pbf.js
var i;
!function(t) {
  t[t.varint = 0] = "varint", t[t.fixed64 = 1] = "fixed64", t[t.delimited = 2] = "delimited", t[t.fixed32 = 5] = "fixed32", t[t.unknown = 99] = "unknown";
}(i || (i = {}));
var s = 4294967296;
var r = new TextDecoder("utf-8");
var n = a("safari") || a("ios") ? 6 : a("ff") ? 12 : 32;
var a2 = class {
  constructor(t, e2, s2 = 0, r2 = t ? t.byteLength : 0) {
    this._tag = 0, this._dataType = i.unknown, this._init(t, e2, s2, r2);
  }
  _init(t, e2, i2, s2) {
    this._data = t, this._dataView = e2, this._pos = i2, this._end = s2;
  }
  clone() {
    return new a2(this._data, this._dataView, this._pos, this._end);
  }
  pos() {
    return this._pos;
  }
  move(t) {
    this._pos = t;
  }
  nextTag(t) {
    for (; ; ) {
      if (this._pos === this._end)
        return false;
      const e2 = this._decodeVarint();
      if (this._tag = e2 >> 3, this._dataType = 7 & e2, !t || t === this._tag)
        break;
      this.skip();
    }
    return true;
  }
  next() {
    if (this._pos === this._end)
      return false;
    const t = this._decodeVarint();
    return this._tag = t >> 3, this._dataType = 7 & t, true;
  }
  empty() {
    return this._pos >= this._end;
  }
  tag() {
    return this._tag;
  }
  getInt32() {
    return this._decodeVarint();
  }
  getInt64() {
    return this._decodeVarint();
  }
  getUInt32() {
    let t = 4294967295;
    return t = (127 & this._data[this._pos]) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (127 & this._data[this._pos]) << 7) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (127 & this._data[this._pos]) << 14) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (127 & this._data[this._pos]) << 21) >>> 0, this._data[this._pos++] < 128 ? t : (t = (t | (15 & this._data[this._pos]) << 28) >>> 0, this._data[this._pos++] < 128 ? t : void 0))));
  }
  getUInt64() {
    return this._decodeVarint();
  }
  getSInt32() {
    const t = this.getUInt32();
    return t >>> 1 ^ -(1 & t) | 0;
  }
  getSInt64() {
    return this._decodeSVarint();
  }
  getBool() {
    const t = 0 !== this._data[this._pos];
    return this._skip(1), t;
  }
  getEnum() {
    return this._decodeVarint();
  }
  getFixed64() {
    const t = this._dataView, e2 = this._pos, i2 = t.getUint32(e2, true) + t.getUint32(e2 + 4, true) * s;
    return this._skip(8), i2;
  }
  getSFixed64() {
    const t = this._dataView, e2 = this._pos, i2 = t.getUint32(e2, true) + t.getInt32(e2 + 4, true) * s;
    return this._skip(8), i2;
  }
  getDouble() {
    const t = this._dataView.getFloat64(this._pos, true);
    return this._skip(8), t;
  }
  getFixed32() {
    const t = this._dataView.getUint32(this._pos, true);
    return this._skip(4), t;
  }
  getSFixed32() {
    const t = this._dataView.getInt32(this._pos, true);
    return this._skip(4), t;
  }
  getFloat() {
    const t = this._dataView.getFloat32(this._pos, true);
    return this._skip(4), t;
  }
  getString() {
    const t = this._getLength(), e2 = this._pos, i2 = this._toString(this._data, e2, e2 + t);
    return this._skip(t), i2;
  }
  getBytes() {
    const t = this._getLength(), e2 = this._pos, i2 = this._toBytes(this._data, e2, e2 + t);
    return this._skip(t), i2;
  }
  getLength() {
    return this._getLengthUnsafe();
  }
  processMessageWithArgs(t, e2, i2, s2) {
    const r2 = this.getMessage(), n2 = t(r2, e2, i2, s2);
    return r2.release(), n2;
  }
  processMessage(t) {
    const e2 = this.getMessage(), i2 = t(e2);
    return e2.release(), i2;
  }
  getMessage() {
    const t = this._getLength(), e2 = a2.pool.acquire();
    return e2._init(this._data, this._dataView, this._pos, this._pos + t), this._skip(t), e2;
  }
  release() {
    a2.pool.release(this);
  }
  dataType() {
    return this._dataType;
  }
  skip() {
    switch (this._dataType) {
      case i.varint:
        this._decodeVarint();
        break;
      case i.fixed64:
        this._skip(8);
        break;
      case i.delimited:
        this._skip(this._getLength());
        break;
      case i.fixed32:
        this._skip(4);
        break;
      default:
        throw new Error("Invalid data type!");
    }
  }
  skipLen(t) {
    this._skip(t);
  }
  _skip(t) {
    if (this._pos + t > this._end)
      throw new Error("Attempt to skip past the end of buffer!");
    this._pos += t;
  }
  _decodeVarint() {
    const t = this._data;
    let e2, i2 = this._pos, s2 = 0;
    if (this._end - i2 >= 10)
      do {
        if (e2 = t[i2++], s2 |= 127 & e2, 0 == (128 & e2))
          break;
        if (e2 = t[i2++], s2 |= (127 & e2) << 7, 0 == (128 & e2))
          break;
        if (e2 = t[i2++], s2 |= (127 & e2) << 14, 0 == (128 & e2))
          break;
        if (e2 = t[i2++], s2 |= (127 & e2) << 21, 0 == (128 & e2))
          break;
        if (e2 = t[i2++], s2 += 268435456 * (127 & e2), 0 == (128 & e2))
          break;
        if (e2 = t[i2++], s2 += 34359738368 * (127 & e2), 0 == (128 & e2))
          break;
        if (e2 = t[i2++], s2 += 4398046511104 * (127 & e2), 0 == (128 & e2))
          break;
        if (e2 = t[i2++], s2 += 562949953421312 * (127 & e2), 0 == (128 & e2))
          break;
        if (e2 = t[i2++], s2 += 72057594037927940 * (127 & e2), 0 == (128 & e2))
          break;
        if (e2 = t[i2++], s2 += 9223372036854776e3 * (127 & e2), 0 == (128 & e2))
          break;
        throw new Error("Varint too long!");
      } while (0);
    else {
      let r2 = 1;
      for (; i2 !== this._end && (e2 = t[i2], 0 != (128 & e2)); )
        ++i2, s2 += (127 & e2) * r2, r2 *= 128;
      if (i2 === this._end)
        throw new Error("Varint overrun!");
      ++i2, s2 += e2 * r2;
    }
    return this._pos = i2, s2;
  }
  _decodeSVarint() {
    const t = this._decodeVarint();
    return t % 2 ? -(t + 1) / 2 : t / 2;
  }
  _getLength() {
    if (this._dataType !== i.delimited)
      throw new Error("Not a delimited data type!");
    return this._decodeVarint();
  }
  _getLengthUnsafe() {
    return this.getUInt32();
  }
  _toString(t, e2, i2) {
    if ((i2 = Math.min(this._end, i2)) - e2 > n) {
      const s3 = t.subarray(e2, i2);
      return r.decode(s3);
    }
    let s2 = "", a3 = "";
    for (let r2 = e2; r2 < i2; ++r2) {
      const e3 = t[r2];
      128 & e3 ? a3 += "%" + e3.toString(16) : (s2 += decodeURIComponent(a3) + String.fromCharCode(e3), a3 = "");
    }
    return a3.length && (s2 += decodeURIComponent(a3)), s2;
  }
  _toBytes(t, e2, i2) {
    return i2 = Math.min(this._end, i2), new Uint8Array(t.buffer, e2, i2 - e2);
  }
};
a2.pool = new e(a2, null, (t) => {
  t._data = null, t._dataView = null;
});

export {
  a2 as a
};
//# sourceMappingURL=chunk-ZZY5IDKU.js.map
