import {
  M as M2,
  P as P2,
  b as b2,
  k as k2,
  q as q3,
  w as w2,
  x as x5,
  y as y2
} from "./chunk-6CMUWHIK.js";
import {
  c as c3,
  t as t4
} from "./chunk-HXWHE6NR.js";
import {
  e as e7
} from "./chunk-233LLPHP.js";
import {
  c as c4
} from "./chunk-JUQOAGTV.js";
import {
  l as l5,
  m as m3,
  v as v3
} from "./chunk-WFV6S5JH.js";
import "./chunk-2RRRGIMY.js";
import {
  a as a4
} from "./chunk-FDKIF5RK.js";
import {
  n as n7
} from "./chunk-KQRXZVEP.js";
import {
  C
} from "./chunk-OGZ4KF5L.js";
import {
  n as n8
} from "./chunk-JYMQQ22E.js";
import "./chunk-JYWDI7GA.js";
import {
  r as r6
} from "./chunk-B6K3W2TL.js";
import "./chunk-A2XF5TZW.js";
import {
  v as v2
} from "./chunk-OPQ375VL.js";
import {
  g as g3
} from "./chunk-VOFRIPQR.js";
import "./chunk-U7I6IKUN.js";
import {
  S as S3,
  g as g2,
  p as p2,
  x as x4
} from "./chunk-GVCSP4OP.js";
import {
  a as a3,
  o as o4,
  v
} from "./chunk-7LOTF6IL.js";
import "./chunk-N5C77AAH.js";
import "./chunk-DSCM4HDL.js";
import {
  r as r5
} from "./chunk-KYD2B4O6.js";
import "./chunk-EHWEX2VK.js";
import {
  i as i3
} from "./chunk-HPO2NV7P.js";
import "./chunk-22O7HU3A.js";
import "./chunk-Y75V5CF3.js";
import "./chunk-PQM6RARY.js";
import "./chunk-2Y5KPYOJ.js";
import "./chunk-BBUIX72C.js";
import "./chunk-5ZS6RUSM.js";
import "./chunk-7LH2XNVI.js";
import "./chunk-PXOPYXIX.js";
import "./chunk-WSQIVEW5.js";
import "./chunk-ZTFWVZTL.js";
import "./chunk-ELZC3DZT.js";
import "./chunk-TGUQXVQU.js";
import "./chunk-4LQ6NAOX.js";
import "./chunk-K37I5IIG.js";
import "./chunk-GKYJJGE3.js";
import "./chunk-AWIG2DGF.js";
import "./chunk-3236UEJN.js";
import "./chunk-KSOWE6GO.js";
import "./chunk-ZLORWBMB.js";
import "./chunk-CNL2CHF7.js";
import "./chunk-HRAEK6P4.js";
import "./chunk-K6UIDSFF.js";
import "./chunk-AIONJO5O.js";
import {
  i2,
  o as o5
} from "./chunk-YLSPLHY5.js";
import "./chunk-4GGQTXXY.js";
import "./chunk-QMP4VG7M.js";
import "./chunk-5RP42VZJ.js";
import "./chunk-KD6KBT2L.js";
import "./chunk-XEWFCJLT.js";
import "./chunk-ZEDAE7EU.js";
import "./chunk-YXFNNKMT.js";
import {
  g
} from "./chunk-7OZR6JFF.js";
import {
  e as e5,
  o as o3,
  t as t3
} from "./chunk-NXOQBIK7.js";
import {
  E as E3
} from "./chunk-ERNXFM5T.js";
import {
  i
} from "./chunk-6ITXWFMK.js";
import {
  e as e6
} from "./chunk-SV4VP57N.js";
import "./chunk-PWYPPSAW.js";
import {
  E as E2,
  S as S2,
  l as l4
} from "./chunk-5EXPMKQP.js";
import {
  W,
  a as a2,
  c as c2,
  l as l3
} from "./chunk-B7F3T673.js";
import "./chunk-QXYW5CVF.js";
import "./chunk-Z7AZMEL6.js";
import "./chunk-FUKESVWQ.js";
import "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-XEIRRA3E.js";
import "./chunk-B3IXFXV6.js";
import "./chunk-XNOIZLCR.js";
import "./chunk-I22L7HNU.js";
import "./chunk-44UD36FH.js";
import "./chunk-ODYLXHP4.js";
import "./chunk-Y5AGUEHG.js";
import "./chunk-DVE4HUBR.js";
import "./chunk-RC6OMMF6.js";
import "./chunk-AWPZQDE5.js";
import "./chunk-OYNEZ5VG.js";
import "./chunk-R67CDTDF.js";
import "./chunk-UCWSHVC4.js";
import "./chunk-DHZ2TSD5.js";
import "./chunk-FAF3GP2W.js";
import "./chunk-YSWURJZW.js";
import "./chunk-5JKCNCL2.js";
import "./chunk-2YDCEMEJ.js";
import "./chunk-767LZ6IM.js";
import "./chunk-TTKSAULB.js";
import {
  t as t2
} from "./chunk-WJDUBZ7S.js";
import "./chunk-DNPZNIDB.js";
import "./chunk-WW7VYUQW.js";
import "./chunk-FCDEMPPS.js";
import {
  o
} from "./chunk-TEJEYVH4.js";
import "./chunk-HEZ2ATGC.js";
import "./chunk-AALA53RH.js";
import "./chunk-BOVIIQLB.js";
import "./chunk-IJHFAZOW.js";
import "./chunk-DMGVDNFD.js";
import "./chunk-YAQGRU5B.js";
import "./chunk-M3GMIUQS.js";
import "./chunk-BMA2CXVS.js";
import "./chunk-46N7XS5M.js";
import "./chunk-4MKQUQD4.js";
import "./chunk-A3QLZKCF.js";
import "./chunk-OYAHQ564.js";
import "./chunk-LGILR4HN.js";
import "./chunk-I5UNY2WQ.js";
import "./chunk-EYJ2F5XB.js";
import "./chunk-5EPJG7SL.js";
import "./chunk-TR3U55RZ.js";
import "./chunk-3DCTMZI6.js";
import "./chunk-33INAWJA.js";
import "./chunk-5WOO2FX6.js";
import {
  R as R3
} from "./chunk-FPMD6IB4.js";
import "./chunk-J73IXFNW.js";
import "./chunk-MQBVOUKB.js";
import "./chunk-PLLZPG4O.js";
import "./chunk-WQLER7IU.js";
import "./chunk-7GTYHKA3.js";
import "./chunk-MOXYEJRV.js";
import {
  d2,
  h as h2,
  o2,
  x as x3
} from "./chunk-EEJIELE6.js";
import {
  E
} from "./chunk-Y55TYMBP.js";
import "./chunk-NAB3NF54.js";
import "./chunk-MHB3L22D.js";
import {
  O as O3
} from "./chunk-MDCKEJ7B.js";
import "./chunk-MLAOYRDT.js";
import {
  O as O2
} from "./chunk-VMF4NMEB.js";
import "./chunk-NAIF4GWX.js";
import {
  S
} from "./chunk-72PB636Q.js";
import "./chunk-RIOXX6J2.js";
import "./chunk-SOZCO2CU.js";
import {
  b,
  q as q2
} from "./chunk-53KI6WDE.js";
import {
  n as n6
} from "./chunk-W2HLA6I3.js";
import "./chunk-Q6AASANP.js";
import "./chunk-ZYIEYKCD.js";
import "./chunk-DLM6NKXW.js";
import "./chunk-TQLSOIYV.js";
import {
  e as e4
} from "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-3NPGGTI6.js";
import {
  m as m2,
  r as r4
} from "./chunk-YZNDHJDJ.js";
import "./chunk-GT2OBOXC.js";
import "./chunk-ZN2MGN4S.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import {
  n as n5
} from "./chunk-RTHP2LNT.js";
import "./chunk-W66LN57L.js";
import "./chunk-FUQI3AAI.js";
import {
  An,
  Bn,
  Ce,
  Hn,
  Rn,
  jn,
  xn
} from "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import {
  h
} from "./chunk-3DZ4BNVJ.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-F5A4XAOJ.js";
import {
  n as n4,
  r as r3
} from "./chunk-U7B2WKBH.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-WKRVG5MO.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import {
  j as j3,
  x as x2
} from "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-DYETG5YB.js";
import "./chunk-CLGCKZUR.js";
import {
  G,
  K,
  N,
  O,
  R,
  R2,
  T,
  Y,
  p
} from "./chunk-RN2KRYDN.js";
import "./chunk-AWWWJUTQ.js";
import "./chunk-EQNRDJV7.js";
import "./chunk-FEEXJRYO.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  D as D2,
  m
} from "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import {
  n as n3
} from "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import {
  s as s2
} from "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import {
  M,
  f
} from "./chunk-BPZGJQOB.js";
import {
  D,
  a
} from "./chunk-ZOKX6UGH.js";
import {
  P,
  _,
  e as e3,
  j as j2,
  q,
  r as r2,
  u,
  x,
  z
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import {
  n as n2
} from "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  G as G2
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  c,
  e as e2,
  l,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/MeasurementData.js
var H = class {
  constructor(e8, t5) {
    this.positionsWorldCoords = [], this.positionsRenderCoords = [], this.positionsProjectedWorldCoords = [], this.positionsFittedRenderCoords = [], this.positionsGeographic = [], this.positionsSpherical = [], this.positionsStereographic = [], this.pathSegmentLengths = [], this.geodesicPathSegmentLengths = [], this.perimeterSegmentLengths = [], this.intersectingSegments = /* @__PURE__ */ new Set(), this.geodesicIntersectingSegments = /* @__PURE__ */ new Set(), this.areaCentroidWorldCoords = n2(), this.areaCentroidRenderCoords = n2(), this.geodesicAreaCentroidRenderCoords = n2(), this._length = 0, this._centroidRenderCoords = n2(), this._planeWorldCoords = n4(), this._worldUp = n2(), this._worldTangent = n2(), this._frame = [n2(), n2(), n2()], this._pathVersion = -1, this._validMeasurement = false, this._hasCursorPoint = false, this._mode = null, this._tempU = n2(), this._tempV = n2(), this._tempVec3 = n2(), this._tempSphere = { center: n2(), radius: 0 }, this._sceneView = e8, this.unitNormalizer = t5;
  }
  update(e8, s4, o6, r7, n9, h4, d4) {
    const g5 = this.unitNormalizer, l7 = this._sceneView.renderSpatialReference, p3 = this.unitNormalizer.spatialReference, c7 = r(s4);
    if (this._pathVersion === e8.version && this._validMeasurement === r7 && !d4 && this._hasCursorPoint === c7 && this._mode === h4) {
      return !e8.isValidPolygon && (this._updateCursorSegmentLength(e8, s4), true);
    }
    this._pathVersion = e8.version, this._validMeasurement = r7, this._hasCursorPoint = c7;
    const m5 = e8.numVertices;
    this._resize(m5);
    const u6 = O(o6.spatialReference), _2 = An(o6.spatialReference, u6) && Ce(o6.spatialReference), { positionsGeographic: C2, positionsWorldCoords: f3, positionsRenderCoords: j4, positionsSpherical: M3 } = this;
    e8.forEachVertexPosition((e9, t5) => {
      X(o6.elevationProvider, e9), Hn(e9, f3[t5], p3), Hn(e9, j4[t5], l7), _2 && (jn(e9, C2[t5]), Hn(e9, M3[t5], u6), z(M3[t5], M3[t5]));
    });
    const W2 = this._updatePathLengths(r7);
    if (this.pathLength = this._length > 1 ? o4(g5.normalizeDistance(W2), "meters") : null, _2) {
      const e9 = this._updateGeodesicPathLengths(r7, p3);
      this.geodesicPathLength = this._length > 1 ? o4(e9, "meters") : null;
    } else
      this.geodesicPathLength = null;
    return this._updateCursorSegmentLength(e8, s4), this._updateMode(e8, h4), r7 ? (this._updateArea(o6, g5, l7, p3, n9), _2 && this._updateGeodesicArea(o6), true) : (this.area = null, this.geodesicArea = null, this.perimeterLength = null, this.triangleIndices = null, this.geodesicTriangleIndices = null, this.intersectingSegments.clear(), this.geodesicIntersectingSegments.clear(), true);
  }
  getData() {
    return { positionsWorldCoords: this.positionsWorldCoords, positionsRenderCoords: this.positionsRenderCoords, positionsProjectedWorldCoords: this.positionsProjectedWorldCoords, positionsFittedRenderCoords: this.positionsFittedRenderCoords, positionsGeographic: this.positionsGeographic, positionsSpherical: this.positionsSpherical, positionsStereographic: this.positionsStereographic, pathSegmentLengths: this.pathSegmentLengths, geodesicPathSegmentLengths: this.geodesicPathSegmentLengths, perimeterSegmentLengths: this.perimeterSegmentLengths, intersectingSegments: this.intersectingSegments, geodesicIntersectingSegments: this.geodesicIntersectingSegments, triangleIndices: this.triangleIndices, geodesicTriangleIndices: this.geodesicTriangleIndices, areaCentroidWorldCoords: this.areaCentroidWorldCoords, areaCentroidRenderCoords: this.areaCentroidRenderCoords, geodesicAreaCentroidRenderCoords: this.geodesicAreaCentroidRenderCoords, fittingMode: this.fittingMode, area: this.area, geodesicArea: this.geodesicArea, pathLength: this.pathLength, geodesicPathLength: this.geodesicPathLength, perimeterLength: this.perimeterLength, cursorSegmentLength: this.cursorSegmentLength, geodesicCursorSegmentLength: this.geodesicCursorSegmentLength, unitNormalizer: this.unitNormalizer, actualMeasurementMode: this.actualMeasurementMode };
  }
  _resize(e8) {
    for (e8 < this._length && (this.positionsWorldCoords.length = e8, this.positionsRenderCoords.length = e8, this.positionsProjectedWorldCoords.length = e8, this.positionsFittedRenderCoords.length = e8, this.positionsGeographic.length = e8, this.positionsSpherical.length = e8, this.positionsStereographic.length = e8, this.pathSegmentLengths.length = e8, this.geodesicPathSegmentLengths.length = e8, this.perimeterSegmentLengths.length = e8, this._length = e8); this._length < e8; )
      this.positionsWorldCoords.push(n2()), this.positionsRenderCoords.push(n2()), this.positionsProjectedWorldCoords.push(n5()), this.positionsFittedRenderCoords.push(n2()), this.positionsGeographic.push(n2()), this.positionsSpherical.push(n2()), this.positionsStereographic.push(n5()), this.pathSegmentLengths.push(0), this.geodesicPathSegmentLengths.push(0), this.perimeterSegmentLengths.push(0), ++this._length;
  }
  _updatePathLengths(e8) {
    const t5 = this.positionsWorldCoords, s4 = this.pathSegmentLengths;
    let i4 = 0;
    for (let o6 = 0; o6 < this._length; ++o6) {
      const r7 = s4[o6] = x(t5[o6], t5[(o6 + 1) % this._length]);
      (o6 < this._length - 1 || e8) && (i4 += r7);
    }
    return i4;
  }
  _updateGeodesicPathLengths(e8, t5) {
    const s4 = this.positionsGeographic, i4 = this.geodesicPathSegmentLengths;
    let o6 = 0;
    for (let r7 = 0; r7 < this._length; ++r7) {
      const n9 = i4[r7] = k2(s4[r7], s4[(r7 + 1) % this._length], t5);
      (r7 < this._length - 1 || e8) && (o6 += n9);
    }
    return o6;
  }
  _updateArea(e8, t5, s4, n9, h4) {
    const a5 = e8.renderCoordsHelper, d4 = this.positionsWorldCoords, C2 = this.positionsRenderCoords, f3 = this.positionsProjectedWorldCoords, S4 = this.positionsFittedRenderCoords, L = this._planeWorldCoords, P4 = this._centroidRenderCoords;
    c3(C2, P4), a5.worldUpAtPosition(P4, this._worldUp), a5.worldBasisAtPosition(P4, n6.X, this._worldTangent), xn(P4, this._worldUp, s4, this._worldUp, n9), xn(P4, this._worldTangent, s4, this._worldTangent, n9), d4.length > 2 && M2(d4, L), this.fittingMode = this._selectFittingMode(L, d4, this._worldUp, h4);
    let R4 = 0;
    if ("horizontal" === this.fittingMode) {
      let e9 = -1 / 0;
      C2.forEach((t6, s5) => {
        const i4 = a5.getAltitude(C2[s5]);
        i4 > e9 && (e9 = i4, R4 = s5);
      });
    }
    const A = d4[R4];
    let W2 = L, v4 = this._worldTangent;
    "horizontal" === this.fittingMode ? W2 = this._worldUp : "vertical" === this.fittingMode && (W2 = this._tempVec3, v4 = this._worldUp, q2(L, this._worldUp, W2)), r2(this._frame[2], W2), q2(v4, W2, this._frame[0]), _(this._frame[1], this._frame[0], this._frame[2]), j2(this._frame[1], this._frame[1]);
    const z3 = this._tempVec3, U3 = this._tempU, I = this._tempV;
    for (let i4 = 0; i4 < this._length; ++i4) {
      const e9 = f3[i4], t6 = S4[i4];
      e3(z3, d4[i4], A), r4(e9, P(this._frame[0], z3), P(this._frame[1], z3)), q(U3, this._frame[0], e9[0]), q(I, this._frame[1], e9[1]), u(z3, U3, I), u(z3, z3, A), Bn(z3, n9, t6, s4);
    }
    this.perimeterLength = this._length > 0 ? o4(t5.normalizeDistance(this._updatePerimeterLengths()), "meters") : null, c3(S4, this.areaCentroidRenderCoords), Bn(this.areaCentroidRenderCoords, s4, this.areaCentroidWorldCoords, n9), this._updateIntersectingSegments(), this.area = 0 === this.intersectingSegments.size ? a3(t5.normalizeArea(this._computeArea()), "square-meters") : null;
  }
  _updateGeodesicArea(e8) {
    const { renderCoordsHelper: t5, spatialReference: s4 } = e8, { positionsSpherical: i4, positionsStereographic: n9 } = this, h4 = this._tempVec3, a5 = x5(i4, h4);
    if (!a5)
      return void (this.geodesicArea = null);
    const d4 = this._tempU, g5 = this._tempV;
    b(h4, d4, g5);
    for (let o6 = 0; o6 < this._length; ++o6) {
      const e9 = P(i4[o6], d4), t6 = P(i4[o6], g5), s5 = P(i4[o6], h4);
      r4(n9[o6], e9 / s5, t6 / s5);
    }
    q(h4, h4, p(s4).radius), t5.toRenderCoords(h4, O(s4), this.geodesicAreaCentroidRenderCoords), this._updateGeodesicIntersectingSegments(), this.geodesicArea = a5 && 0 === this.geodesicIntersectingSegments.size ? a3(this._computeGeodesicArea(), "square-meters") : null;
  }
  _updatePerimeterLengths() {
    const e8 = this.positionsProjectedWorldCoords, t5 = this.perimeterSegmentLengths;
    let s4 = 0;
    for (let i4 = 0; i4 < this._length; ++i4) {
      s4 += t5[i4] = m2(e8[i4], e8[(i4 + 1) % this._length]);
    }
    return s4;
  }
  _updateIntersectingSegments() {
    const e8 = this.positionsProjectedWorldCoords, t5 = this.intersectingSegments;
    t5.clear();
    for (let s4 = 0; s4 < this._length; ++s4)
      for (let i4 = s4 + 2; i4 < this._length; ++i4) {
        if ((i4 + 1) % this._length === s4)
          continue;
        const o6 = e8[s4], r7 = e8[(s4 + 1) % this._length], n9 = e8[i4], h4 = e8[(i4 + 1) % this._length];
        G2(o6, r7, n9, h4) && (t5.add(s4), t5.add(i4));
      }
  }
  _computeArea() {
    const e8 = this.positionsProjectedWorldCoords, t5 = this.triangleIndices = new Uint32Array(v2(e8));
    let s4 = 0;
    for (let i4 = 0; i4 < t5.length; i4 += 3)
      s4 += S(e8[t5[i4]], e8[t5[i4 + 1]], e8[t5[i4 + 2]]);
    return s4;
  }
  _updateGeodesicIntersectingSegments() {
    const e8 = this.positionsStereographic, t5 = this.geodesicIntersectingSegments;
    t5.clear();
    for (let s4 = 0; s4 < this._length; ++s4)
      for (let i4 = s4 + 2; i4 < this._length; ++i4) {
        if ((i4 + 1) % this._length === s4)
          continue;
        const o6 = e8[s4], r7 = e8[(s4 + 1) % this._length], n9 = e8[i4], h4 = e8[(i4 + 1) % this._length];
        G2(o6, r7, n9, h4) && (t5.add(s4), t5.add(i4));
      }
  }
  _computeGeodesicArea() {
    const e8 = this.positionsGeographic, t5 = this.positionsStereographic, s4 = this.geodesicTriangleIndices = new Uint32Array(v2(t5));
    let i4 = 0;
    for (let o6 = 0; o6 < s4.length; o6 += 3)
      i4 += q3(e8[s4[o6]], e8[s4[o6 + 1]], e8[s4[o6 + 2]], k.WGS84);
    return i4;
  }
  _selectFittingMode(t5, s4, i4, o6) {
    const r7 = s4.map((e8) => Math.abs(b2(t5, e8))).reduce((e8, t6) => Math.max(e8, t6), 0);
    y2(s4, this._tempSphere);
    const n9 = r7 / (2 * this._tempSphere.radius), h4 = n9 < o6.maxRelativeErrorCoplanar, a5 = n9 < o6.maxRelativeErrorAlmostCoplanar;
    let d4 = "horizontal";
    if (h4)
      d4 = "oblique";
    else if (a5) {
      d4 = Math.abs(P(i4, t5)) > Math.cos(M(o6.verticalAngleThreshold)) ? "horizontal" : "vertical";
    }
    return d4;
  }
  _updateCursorSegmentLength(e8, s4) {
    const o6 = e8.lastPoint;
    !e8.isValidPolygon && r(o6) && r(s4) ? (this.geodesicCursorSegmentLength = o4(w2(o6, s4), "meters"), this.cursorSegmentLength = o4(this.unitNormalizer.normalizeDistance(P2(o6, s4, this.unitNormalizer.spatialReference)), "meters")) : (this.geodesicCursorSegmentLength = null, this.cursorSegmentLength = null);
  }
  _updateMode(e8, s4) {
    if (s4 === e7.Auto) {
      this.actualMeasurementMode = "euclidean";
      let s5 = 0;
      null != this.geodesicPathLength && (s5 += this.geodesicPathLength.value), !e8.isValidPolygon && r(this.geodesicCursorSegmentLength) && (s5 += this.geodesicCursorSegmentLength.value), s5 > Z && (this.actualMeasurementMode = "geodesic");
    } else
      this.actualMeasurementMode = s4 === e7.Euclidean ? "euclidean" : "geodesic";
    null == this.geodesicPathLength && (this.actualMeasurementMode = "euclidean"), this._mode = s4;
  }
};
function X(e8, t5) {
  t5.hasZ || (t5.z = c(i3(e8, t5, "ground"), 0));
}
var Z = 1e5;

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementController.js
var u3 = class extends y {
  constructor(e8) {
    super(e8);
  }
  initialize() {
    const { spatialReference: e8 } = this.view, t5 = O(e8), a5 = t5 === G ? R : t5, o6 = !e8 || An(e8, a5) ? a5 : e8, u6 = new t4(o6);
    this._measurementDataManager = new H(this.view, u6), this.own([this.analysisViewData.path.on("change", () => this._update()), l2(() => this.analysisViewData.cursorPoint, () => this._update(), U), l2(() => this.analysisViewData.mode, () => this._update(), U)]), this._update();
  }
  _update(e8 = false) {
    const { analysisViewData: t5, view: r7 } = this, s4 = { maxRelativeErrorCoplanar: 5e-3, maxRelativeErrorAlmostCoplanar: 0.01, verticalAngleThreshold: 80 };
    this._measurementDataManager.update(t5.path, t5.cursorPoint, r7, t5.validMeasurement, s4, t5.mode, e8) && (t5.measurementData = this._measurementDataManager.getData());
  }
};
e([d({ constructOnly: true })], u3.prototype, "view", void 0), e([d({ constructOnly: true })], u3.prototype, "analysis", void 0), e([d({ constructOnly: true })], u3.prototype, "analysisViewData", void 0), u3 = e([n("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementController")], u3);

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementPathHelper.js
var V = s.getLogger("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurement3DPathHelper");
var x6 = class extends n3.EventedAccessor {
  constructor(e8 = {}) {
    super(e8), this._handles = new u2(), this._version = 0, this._internalGeometryChange = false, this._extent = D2();
  }
  destroy() {
    this._handles = l(this._handles);
  }
  set areaMeasurement(e8) {
    this._set("areaMeasurement", e8), r(e8) && r(this.view) && this._initialize(e8, this.view);
  }
  set view(e8) {
    this._set("view", e8), r(e8) && r(this.areaMeasurement) && this._initialize(this.areaMeasurement, e8);
  }
  get initialized() {
    return r(this.areaMeasurement) && r(this.view);
  }
  get version() {
    return this._version;
  }
  get isValidPolygon() {
    return this.initialized && this.editGeometry.components.length > 0 && this.editGeometry.components[0].isClosed();
  }
  get extent() {
    if (this.initialized && this.editGeometry.components.length > 0 && this.editGeometry.components[0].vertices.length > 0) {
      const e8 = D2(this._extent);
      return this.forEachVertex((t5) => {
        m(e8, t5.pos);
      }), e8;
    }
    return null;
  }
  get spatialReference() {
    return this.initialized ? this.editGeometry.coordinateHelper.spatialReference : null;
  }
  _initialize(e8, t5) {
    this._handles.removeAll(), this._handles.add(l2(() => e8.geometry, () => {
      this._updateEditGeometryFromModelGeometry(e8, t5);
    }, w)), this._makeDirty(true);
  }
  _makeDirty(e8 = false) {
    this.notifyChange("isValidPolygon"), this.notifyChange("initialized"), this.notifyChange("extent"), e8 && this.notifyChange("numVertices");
  }
  _updateEditGeometryFromModelGeometry(e8, t5) {
    if (this._version++, this._internalGeometryChange)
      return;
    this._handles.remove("EditGeometry");
    let i4 = e8.geometry;
    if (r(i4)) {
      const r7 = Rn(i4, t5.spatialReference);
      t(r7) && a4(e8, i4.spatialReference, V), i4 = r7;
    }
    r(i4) ? this._editGeometryOperations = S3.fromGeometry(i4, t5.state.viewingMode) : this._editGeometryOperations = new S3(new g2("polygon", x4(true, false, t5.spatialReference))), this._makeDirty(true), this.emit("change"), this._handles.add(this.editGeometry.on("change", (t6) => {
      this._makeDirty(null != t6.addedVertices || null != t6.removedVertices), this._internalGeometryChange = true, e8.geometry = this.numVertices > 0 ? this.editGeometry.geometry : null, this._internalGeometryChange = false;
    }), "EditGeometry");
  }
  get editGeometry() {
    return this._editGeometryOperations.data;
  }
  get vertices() {
    const e8 = [];
    return this.forEachVertex((t5) => {
      e8.push(t5);
    }), e8;
  }
  get numVertices() {
    return this.initialized && this.editGeometry.components.length > 0 ? this.editGeometry.components[0].vertices.length : 0;
  }
  get lastPoint() {
    if (this.initialized && this.editGeometry.components.length > 0) {
      const e8 = this.editGeometry.components[0].getLastVertex();
      if (r(e8))
        return this.editGeometry.coordinateHelper.vectorToPoint(e8.pos);
    }
    return null;
  }
  getVertex(e8) {
    if (!this.initialized || 0 === this.editGeometry.components.length || 0 === this.editGeometry.components[0].vertices.length)
      return null;
    const t5 = this.editGeometry.components[0].vertices[0];
    let i4 = t5;
    do {
      if (i4.index === e8)
        return i4;
      i4 = i4.rightEdge.rightVertex;
    } while (i4 !== t5 && null != i4);
    return null;
  }
  getVertexPositionAsPoint(e8) {
    return this.editGeometry.coordinateHelper.vectorToPoint(e8.pos);
  }
  getVertexPositionAsPointFromIndex(e8) {
    return this.editGeometry.coordinateHelper.vectorToPoint(this.getVertex(e8).pos);
  }
  forEachVertex(e8) {
    this.initialized && this.editGeometry.components.length > 0 && this.editGeometry.components[0].iterateVertices(e8);
  }
  forEachVertexPosition(e8) {
    const t5 = this.editGeometry.coordinateHelper;
    this.forEachVertex((i4, r7) => {
      t5.vectorToPoint(i4.pos, P3), e8(P3, r7);
    });
  }
  clear() {
    r(this.areaMeasurement) && (this.areaMeasurement.geometry = null);
  }
  add(e8) {
    if (!this.initialized)
      return null;
    if (0 === this.editGeometry.components.length) {
      const e9 = e2(this.view);
      this.editGeometry.components.push(new p2(e9.spatialReference, e9.state.viewingMode));
    }
    const t5 = this._editGeometryOperations.appendVertex(this.editGeometry.coordinateHelper.pointToVector(e8));
    return this.emit("change"), t5;
  }
  close() {
    if (!this.initialized || 0 === this.editGeometry.components.length)
      return null;
    const e8 = this._editGeometryOperations.closeComponent(this.editGeometry.components[0]);
    return this.emit("change"), e8;
  }
  ensureContains(e8, t5 = "") {
    let i4 = false;
    if (this.editGeometry.components.forEach((t6) => {
      t6.iterateVertices((t7) => {
        t7 === e8 && (i4 = true);
      });
    }), !i4)
      throw new Error(`vertex doesnt exist ${t5}`);
    return i4;
  }
  setVertexPosition(e8, t5) {
    if (!this.initialized)
      return null;
    const i4 = this._editGeometryOperations.setVertexPosition(e8, this.editGeometry.coordinateHelper.pointToVector(t5));
    return this.emit("change"), i4;
  }
  equals(e8) {
    if (this.numVertices !== e8.numVertices)
      return false;
    let t5 = true;
    return this.forEachVertexPosition((i4, r7) => {
      const o6 = e8.getVertexPositionAsPointFromIndex(r7);
      i4.equals(o6) || (t5 = false);
    }), !!t5;
  }
};
e([d({ value: null })], x6.prototype, "areaMeasurement", null), e([d({ value: null })], x6.prototype, "view", null), e([d()], x6.prototype, "isValidPolygon", null), e([d()], x6.prototype, "extent", null), e([d()], x6.prototype, "spatialReference", null), e([d()], x6.prototype, "numVertices", null), x6 = e([n("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurement3DPathHelper")], x6);
var P3 = new j();

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/CheckerBoardTechnique.js
var h3 = class extends e5 {
  initializeProgram(e8) {
    const r7 = h3.shader.get().build(this.configuration);
    return new o3(e8.rctx, r7, E);
  }
  _setPipelineState(e8) {
    const r7 = this.configuration, i4 = e8 === O3.NONE, a5 = e8 === O3.FrontFace;
    return W({ blending: r7.transparent ? i4 ? g4 : E2(e8) : null, depthTest: { func: l4(e8) }, depthWrite: i4 ? r7.writeDepth && a2 : S2(e8), colorWrite: c2, polygonOffset: i4 || a5 ? r7.polygonOffset && u4 : { factor: -1, units: -25 } });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
h3.shader = new t3(c4, () => import("./CheckerBoard.glsl-5G5WUA74.js"));
var u4 = { factor: 0, units: -25 };
var g4 = l3(R3.SRC_ALPHA, R3.ONE, R3.ONE_MINUS_SRC_ALPHA, R3.ONE_MINUS_SRC_ALPHA);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/CheckerBoardTechniqueConfiguration.js
var s3 = class extends i {
  constructor() {
    super(...arguments), this.transparencyPassType = O3.NONE, this.transparent = false, this.writeDepth = true, this.polygonOffset = false, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([e6({ count: O3.COUNT })], s3.prototype, "transparencyPassType", void 0), e([e6()], s3.prototype, "transparent", void 0), e([e6()], s3.prototype, "writeDepth", void 0), e([e6()], s3.prototype, "polygonOffset", void 0), e([e6()], s3.prototype, "hasMultipassTerrain", void 0), e([e6()], s3.prototype, "cullAboveGround", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/CheckerBoardMaterial.js
var l6 = class extends d2 {
  constructor(e8) {
    super(e8, new f2()), this.techniqueConfig = new s3();
  }
  dispose() {
  }
  getConfiguration(e8, r7) {
    return this.techniqueConfig.transparent = this.parameters.transparent, this.techniqueConfig.writeDepth = this.parameters.writeDepth, this.techniqueConfig.polygonOffset = this.parameters.polygonOffset, this.techniqueConfig.transparencyPassType = r7 ? r7.transparencyPassType : O3.NONE, this.techniqueConfig.hasMultipassTerrain = !!r7 && r7.multipassTerrain.enabled, this.techniqueConfig.cullAboveGround = !!r7 && r7.multipassTerrain.cullAboveGround, this.techniqueConfig;
  }
  intersect(e8, t5, r7, i4, s4, n9, o6) {
    return x3(e8, t5, i4, s4, n9, void 0, o6);
  }
  requiresSlot(e8) {
    let t5 = E3.OPAQUE_MATERIAL;
    return this.parameters.transparent && (t5 = this.parameters.writeDepth ? E3.TRANSPARENT_MATERIAL : E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL), e8 === t5 || e8 === E3.DRAPED_MATERIAL;
  }
  createGLMaterial(t5) {
    return t5.output === o.Color || t5.output === o.Alpha ? new c5(t5) : null;
  }
  createBufferWriter() {
    return new i2(o5);
  }
};
var c5 = class extends t2 {
  beginSlot(e8) {
    return this.ensureTechnique(h3, e8);
  }
};
var f2 = class extends o2 {
  constructor() {
    super(...arguments), this.size = [1, 1], this.color1 = [0.75, 0.75, 0.75, 1], this.color2 = [0.5, 0.5, 0.5, 1], this.transparent = false, this.writeDepth = true, this.polygonOffset = false;
  }
};

// node_modules/@arcgis/core/views/3d/interactive/visualElements/MeasurementAreaVisualElement.js
var m4 = class extends n8 {
  constructor(e8) {
    super(e8), this._checkerBoardMaterial = null, this._renderOccluded = h2.OccludeAndTransparent, this._geometry = null, this._size = [1, 1], this._color1 = r3(1, 0.5, 0, 0.5), this._color2 = r3(1, 1, 1, 0.5), this.applyProps(e8);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e8) {
    e8 !== this._renderOccluded && (this._renderOccluded = e8, this._updateMaterial());
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e8) {
    this._geometry = e8, this._geometryChanged();
  }
  get size() {
    return this._size;
  }
  set size(e8) {
    this._size = e8, this._updateMaterial();
  }
  get color1() {
    return this._color1;
  }
  set color1(e8) {
    D(e8, this._color1) || (a(this._color1, e8), this._updateMaterial());
  }
  get color2() {
    return this._color2;
  }
  set color2(e8) {
    D(e8, this._color2) || (a(this._color2, e8), this._updateMaterial());
  }
  _updateMaterial() {
    r(this._checkerBoardMaterial) && this._checkerBoardMaterial.setParameters({ size: this._size, color1: this._color1, color2: this._color2, renderOccluded: this._renderOccluded });
  }
  createExternalResources() {
    this._checkerBoardMaterial = new l6({ size: this._size, color1: this._color1, color2: this._color2, transparent: true, writeDepth: false, polygonOffset: true, renderOccluded: h2.OccludeAndTransparent });
  }
  destroyExternalResources() {
    this._checkerBoardMaterial = null;
  }
  forEachExternalMaterial(r7) {
    r(this._checkerBoardMaterial) && r7(this._checkerBoardMaterial);
  }
  createGeometries(e8) {
    if (t(this._geometry) || t(this._checkerBoardMaterial))
      return;
    const i4 = u5;
    j3(i4, this.transform);
    const c7 = this._geometry, a5 = [], l7 = n2();
    c7.position.forEach((e9) => {
      e3(l7, e9, i4), a5.push(l7[0], l7[1], l7[2]);
    });
    const n9 = [];
    c7.uv.forEach((e9) => {
      n9.push(e9[0], e9[1]);
    });
    const _2 = new g([[O2.POSITION, { size: 3, data: a5, exclusive: true }], [O2.UV0, { size: 2, data: n9, exclusive: true }]], [[O2.POSITION, c7.triangleIndices], [O2.UV0, c7.triangleIndices]]);
    e8.addGeometry(_2, this._checkerBoardMaterial);
  }
  _geometryChanged() {
    this.recreateGeometry();
  }
};
var u5 = n2();

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementVisualization.js
var O4 = class extends y {
  constructor(e8) {
    super(e8), this._handles = new u2(), this._params = { ...z2 }, this._path = null, this._intersectedPath = null, this._perimeter = null, this._intersectedPerimeter = null, this._projectionLines = null, this._measurementArea = null, this._areaLabel = null, this._pathLengthLabel = null, this._cursorSegmentLengthLabel = null, this._perimeterLengthLabel = null, this._pathSegments = [], this._perimeterSegments = [], this._cursorSegment = null, this._origin = n2(), this._originTransform = e4(), this._cursorPositionRenderSpace = n2(), this.messages = null, this.viewData = q4, this.areaLabel = null, this.perimeterLengthLabel = null, this.loadingMessages = true;
  }
  get visible() {
    return this.analysisViewData.visible;
  }
  get testData() {
    return { labels: { area: this._areaLabel, pathLength: this._pathLengthLabel, cursorSegmentLength: this._cursorSegmentLengthLabel, perimeterLength: this._perimeterLengthLabel } };
  }
  initialize() {
    const { analysisViewData: e8, _params: t5, view: i4 } = this;
    this._path = new C({ view: i4, attached: true, width: t5.pathLineWidth, color: t5.pathLineColor, polygonOffset: true, renderOccluded: h2.OccludeAndTransparent }), this._intersectedPath = new C({ view: i4, attached: true, width: t5.pathLineWidth, color: t5.intersectingLineColor, polygonOffset: true, renderOccluded: h2.OccludeAndTransparent }), this._perimeter = new C({ view: i4, attached: true, width: t5.perimeterLineWidth, color: t5.perimeterLineColor, polygonOffset: true, renderOccluded: h2.OccludeAndTransparent }), this._intersectedPerimeter = new C({ view: i4, attached: true, width: t5.perimeterLineWidth, color: t5.intersectingLineColor, polygonOffset: true, renderOccluded: h2.OccludeAndTransparent }), this._projectionLines = new C({ view: i4, attached: true, width: t5.projectionLineWidth, color: t5.projectionLineColor, stipplePattern: r5(t5.projectionLineStippleSize), polygonOffset: true, renderOccluded: h2.OccludeAndTransparent }), this._measurementArea = new m4({ view: i4, attached: true, color1: t5.areaColor1, color2: t5.areaColor2 }), this._areaLabel = new v3({ view: i4, attached: true, fontSize: U2.Large }), this._pathLengthLabel = new v3({ view: i4, attached: true, fontSize: U2.Small }), this._cursorSegmentLengthLabel = new v3({ view: i4, attached: true, fontSize: U2.Small }), this._perimeterLengthLabel = new v3({ view: i4, attached: true, fontSize: U2.Small }), this._handles.add([l2(() => [e8.mode, this.visible, e8.unit, e8.measurementData, e8.cursorPoint], () => this._update(), w), l2(() => {
      var _a;
      return (_a = i4.state) == null ? void 0 : _a.camera;
    }, () => this._updateLabels(), w), s2(async () => this._updateMessageBundle())]), this._updateMessageBundle();
  }
  destroy() {
    this._measurementArea = l(this._measurementArea), this._path = l(this._path), this._intersectedPath = l(this._intersectedPath), this._perimeter = l(this._perimeter), this._intersectedPerimeter = l(this._intersectedPerimeter), this._areaLabel = l(this._areaLabel), this._pathLengthLabel = l(this._pathLengthLabel), this._cursorSegmentLengthLabel = l(this._cursorSegmentLengthLabel), this._perimeterLengthLabel = l(this._perimeterLengthLabel), this._projectionLines = l(this._projectionLines), this._handles = l(this._handles), this.set("view", null);
  }
  _update() {
    if (this.destroyed || !this.view.ready || !this.view.renderCoordsHelper)
      return;
    const { analysisViewData: { measurementData: e8 }, analysisViewData: t5 } = this;
    t(e8) || (this._updateViewData(e8, t5.path, t5.cursorPoint), this._updateOrigin(), this._updatePathSegments(), this._updatePerimeterSegments(), this._updateArea(), this._updateProjectionLines(), this._updateLabels());
  }
  _updateViewData(e8, t5, i4) {
    const r7 = t5.isValidPolygon, n9 = "geodesic" === e8.actualMeasurementMode, a5 = n9 ? e8.geodesicArea : e8.area;
    let o6 = 1;
    if (a5) {
      const t6 = this._toPreferredAreaUnit(a5, this.analysisViewData.unit);
      o6 = f(Math.sqrt(t6.value) / Math.sqrt(300)), o6 *= Math.sqrt(N(1, t6.unit, "square-meters")), o6 /= e8.unitNormalizer.normalizeDistance(1);
    }
    const l7 = { validMeasurement: r7, path: t5, pathVersion: t5.version, cursorPoint: i4, measurementData: e8, mode: e8.actualMeasurementMode, positionsGeographic: e8.positionsGeographic, positionsRenderCoords: e8.positionsRenderCoords, positionsProjected: e8.positionsProjectedWorldCoords, positionsFittedRenderCoords: e8.positionsFittedRenderCoords, intersectingSegments: n9 ? e8.geodesicIntersectingSegments : e8.intersectingSegments, triangleIndices: n9 ? e8.geodesicTriangleIndices : e8.triangleIndices, fittingMode: e8.fittingMode, areaCentroid: n9 ? e8.geodesicAreaCentroidRenderCoords : e8.areaCentroidRenderCoords, pathLengthLabelSegmentIndex: r7 ? 0 : t5.numVertices - 2, perimeterLengthLabelSegmentIndex: 0, checkerSize: o6 };
    this._set("viewData", l7);
  }
  _updateOrigin() {
    const e8 = this.viewData;
    c3(e8.positionsRenderCoords, this._origin), x2(this._originTransform, this._origin), this._measurementArea.transform = this._originTransform, this._projectionLines.transform = this._originTransform;
  }
  _createSegments(e8) {
    const t5 = this.viewData, i4 = t5.path, s4 = this.view.renderCoordsHelper.spatialReference, r7 = t5.mode, n9 = [], a5 = [], o6 = [], l7 = t5.validMeasurement ? i4.numVertices : i4.numVertices - 1;
    for (let h4 = 0; h4 < l7; ++h4) {
      const l8 = t5[e8][h4], c7 = t5[e8][(h4 + 1) % i4.numVertices];
      let m5 = null;
      switch (r7) {
        case "euclidean":
          m5 = new l5(l8, c7);
          break;
        case "geodesic":
          m5 = new m3(l8, c7, s4);
      }
      t5.intersectingSegments.has(h4) ? o6.push(m5) : a5.push(m5), n9.push(m5);
    }
    return { all: n9, nonIntersecting: a5, intersecting: o6 };
  }
  _updatePathSegments() {
    const { view: { renderCoordsHelper: e8 }, viewData: t5, visible: i4 } = this, s4 = this._createSegments("positionsRenderCoords"), { cursorPoint: r7, mode: n9, path: o6 } = t5, l7 = !o6.isValidPolygon, h4 = e8.spatialReference;
    if (this._cursorSegment = null, o6.numVertices > 0 && l7 && r(r7)) {
      if (e8.toRenderCoords(r7, this._cursorPositionRenderSpace)) {
        const e9 = t5.positionsRenderCoords[o6.numVertices - 1], i5 = this._cursorPositionRenderSpace;
        let r8 = null;
        switch (n9) {
          case "euclidean":
            r8 = new l5(e9, i5);
            break;
          case "geodesic":
            r8 = new m3(e9, i5, h4);
        }
        s4.nonIntersecting.push(r8), this._cursorSegment = r8;
      }
    }
    this._path.setGeometryFromSegments(s4.nonIntersecting, this._origin), this._path.visible = i4, this._intersectedPath.setGeometryFromSegments(s4.intersecting, this._origin), this._intersectedPath.visible = i4, this._pathSegments = s4.all;
  }
  _updatePerimeterSegments() {
    const e8 = this.visible && "euclidean" === this.viewData.mode, t5 = this._createSegments("positionsFittedRenderCoords");
    this._perimeter.setGeometryFromSegments(t5.nonIntersecting, this._origin), this._perimeter.visible = e8, this._intersectedPerimeter.setGeometryFromSegments(t5.intersecting, this._origin), this._intersectedPerimeter.visible = e8, this._perimeterSegments = t5.all;
  }
  _updateArea() {
    const e8 = this.viewData;
    switch (e8.mode) {
      case "euclidean":
        this._updateAreaEuclidean(e8);
        break;
      case "geodesic":
        this._updateAreaGeodesic();
    }
  }
  _updateAreaEuclidean(e8) {
    const t5 = this.visible;
    e8.validMeasurement && 0 === e8.intersectingSegments.size && e8.triangleIndices ? (this._measurementArea.geometry = { uv: e8.positionsProjected, position: e8.positionsFittedRenderCoords, triangleIndices: e8.triangleIndices }, this._measurementArea.size = [e8.checkerSize, e8.checkerSize], this._measurementArea.visible = t5) : this._measurementArea.visible = false;
  }
  _updateAreaGeodesic() {
    this._measurementArea.visible = false;
  }
  _updateProjectionLines() {
    const e8 = this.viewData, t5 = this.visible, i4 = e8.path, s4 = e8.mode;
    if (i4.numVertices > 0 && e8.validMeasurement && "euclidean" === s4) {
      const s5 = [];
      for (let t6 = 0; t6 < i4.numVertices; ++t6) {
        const i5 = n2();
        e3(i5, e8.positionsRenderCoords[t6], this._origin);
        const r7 = n2();
        e3(r7, e8.positionsFittedRenderCoords[t6], this._origin), s5.push([i5, r7]);
      }
      this._projectionLines.geometry = s5, this._projectionLines.visible = t5;
    } else
      this._projectionLines.geometry = null, this._projectionLines.visible = false;
  }
  _updateLabels() {
    if (this.destroyed)
      return;
    const { viewData: e8 } = this, { measurementData: t5, mode: i4, path: s4 } = e8;
    if (!s4)
      return;
    const r7 = !s4.isValidPolygon, n9 = this.visible, l7 = this._formatAreaLabel(this.messages, "geodesic" === i4 ? t5.geodesicArea : t5.area, this.analysisViewData.unit);
    r(l7) ? (this._areaLabel.geometry = { type: "point", point: e8.areaCentroid }, this._areaLabel.text = l7, this._areaLabel.visible = e8.validMeasurement && 0 === e8.intersectingSegments.size && n9) : this._areaLabel.visible = false, this._set("areaLabel", e2(l7));
    const h4 = this._formatLengthLabel(this.messages, "geodesic" === i4 ? t5.geodesicPathLength : t5.pathLength, this.analysisViewData.unit);
    if (r(h4) && e8.pathLengthLabelSegmentIndex >= 0 && e8.pathLengthLabelSegmentIndex < this._pathSegments.length) {
      const t6 = this._pathSegments[e8.pathLengthLabelSegmentIndex], i5 = r(this._cursorSegment) ? this._cursorSegment : k3;
      this._pathLengthLabel.distance = this._params.labelDistance, this._pathLengthLabel.geometry = { type: "corner", left: t6, right: i5 }, this._pathLengthLabel.text = h4, this._pathLengthLabel.visible = r7 && s4.numVertices > 0 && n9;
    } else
      this._pathLengthLabel.visible = false;
    const c7 = "geodesic" === i4 ? e8.measurementData.geodesicCursorSegmentLength : e8.measurementData.cursorSegmentLength;
    if (r(c7)) {
      const e9 = this._formatLengthLabel(this.messages, c7, this.analysisViewData.unit);
      this._cursorSegmentLengthLabel.distance = this._params.labelDistance, this._cursorSegmentLengthLabel.geometry = r(this._cursorSegment) ? { type: "segment", segment: this._cursorSegment, sampleLocation: "end" } : null, this._cursorSegmentLengthLabel.anchor = "bottom", this._cursorSegmentLengthLabel.text = e2(e9), this._cursorSegmentLengthLabel.visible = r7 && 0 !== c7.value && n9;
    } else
      this._cursorSegmentLengthLabel.visible = false;
    this._cursorSegmentLengthLabel.overlaps(this._pathLengthLabel) && (this._cursorSegmentLengthLabel.visible = false), this._pathLengthLabel.overlaps(this._areaLabel) && (this._pathLengthLabel.visible = false);
    const m5 = "geodesic" === e8.mode, d4 = m5 ? t5.geodesicPathLength : t5.perimeterLength, p3 = this._formatLengthLabel(this.messages, d4, this.analysisViewData.unit);
    if (this._set("perimeterLengthLabel", e2(p3)), e8.validMeasurement && 0 === e8.intersectingSegments.size) {
      this._perimeterLengthLabel.distance = this._params.labelDistance, this._perimeterLengthLabel.anchor = "top", this._perimeterLengthLabel.text = e2(p3), this._perimeterLengthLabel.visible = true;
      let t6 = true;
      for (let i5 = 0; i5 < e8.path.numVertices; ++i5) {
        const s5 = (e8.perimeterLengthLabelSegmentIndex + i5) % e8.path.numVertices, r8 = m5 ? this._pathSegments[s5] : this._perimeterSegments[s5];
        if (t6 = true, this._perimeterLengthLabel.geometry = { type: "segment", segment: r8, sampleLocation: "center" }, !this._perimeterLengthLabel.overlaps(this._areaLabel))
          break;
        t6 = false;
      }
      this._perimeterLengthLabel.visible = t6 && n9;
    } else
      this._perimeterLengthLabel.visible = false;
  }
  _toPreferredAreaUnit(e8, t5) {
    return v(e8, this._preferredAreaUnit(e8, t5));
  }
  _preferredAreaUnit(e8, t5) {
    switch (t5) {
      case "metric":
        return T(e8.value, e8.unit);
      case "imperial":
        return Y(e8.value, e8.unit);
      default:
        return t5;
    }
  }
  _preferredLengthUnit(e8, t5) {
    const i4 = this._deriveLengthUnitFromAreaUnit(t5);
    switch (i4) {
      case "metric":
        return R2(e8.value, e8.unit);
      case "imperial":
        return K(e8.value, e8.unit);
      default:
        return i4;
    }
  }
  _deriveLengthUnitFromAreaUnit(e8) {
    switch (e8) {
      case "metric":
      case "ares":
      case "hectares":
        return "metric";
      case "imperial":
      case "acres":
        return "imperial";
      case "square-inches":
        return "inches";
      case "square-feet":
        return "feet";
      case "square-yards":
        return "yards";
      case "square-miles":
        return "miles";
      case "square-us-feet":
        return "us-feet";
      case "square-millimeters":
        return "millimeters";
      case "square-centimeters":
        return "centimeters";
      case "square-decimeters":
        return "decimeters";
      case "square-meters":
        return "meters";
      case "square-kilometers":
        return "kilometers";
    }
    throw new Error("unhandled area unit");
  }
  _formatAreaLabel(e8, t5, i4) {
    return e8 && t5 && g3(e8, t5, this._preferredAreaUnit(t5, i4));
  }
  _formatLengthLabel(e8, t5, i4) {
    return e8 && t5 && g3(e8, t5, this._preferredLengthUnit(t5, i4));
  }
  _updateMessageBundle() {
    this.loadingMessages = true, h("esri/core/t9n/Units").then((e8) => {
      this.messages = e8, this.view && this._update();
    }).finally(() => {
      this.loadingMessages = false;
    });
  }
};
var U2;
e([d()], O4.prototype, "view", void 0), e([d()], O4.prototype, "messages", void 0), e([d()], O4.prototype, "analysis", void 0), e([d()], O4.prototype, "viewData", void 0), e([d()], O4.prototype, "analysisViewData", void 0), e([d({ readOnly: true })], O4.prototype, "areaLabel", void 0), e([d({ readOnly: true })], O4.prototype, "perimeterLengthLabel", void 0), e([d()], O4.prototype, "loadingMessages", void 0), e([d()], O4.prototype, "visible", null), O4 = e([n("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementVisualization")], O4), function(e8) {
  e8[e8.Small = 12] = "Small", e8[e8.Large = 16] = "Large";
}(U2 || (U2 = {}));
var z2 = { laserLineGlowColor: [1, 0.5, 0], laserLineGlowWidth: 8, laserLineGlowFalloff: 8, laserLineInnerColor: [1, 1, 1], laserLineInnerWidth: 1, laserLineGlobalAlpha: 0.75, laserLineEnabled: true, handleColor: [1, 0.5, 0], handleOpacity: 0.5, handleRadius: 5, handleRadiusHovered: 10, handleRadiusMouse: 10, handleRadiusTouch: 25, pathLineColor: [1, 0.5, 0, 1], pathLineWidth: 3, intersectingLineColor: [1, 0.2, 0, 1], perimeterLineColor: [1, 0.5, 0, 1], perimeterLineWidth: 2, projectionLineColor: [1, 0.5, 0, 1], projectionLineWidth: 2, projectionLineStippleSize: 5, areaColor1: [1, 0.5, 0, 0.5], areaColor2: [1, 1, 1, 0.5], fillColor: [1, 0.5, 0, 0.5], lineSubdivisions: 64, labelDistance: 25 };
var q4 = { validMeasurement: false, path: null, pathVersion: -1, cursorPoint: null, measurementData: null, mode: null, positionsGeographic: null, positionsRenderCoords: null, positionsProjected: null, positionsFittedRenderCoords: null, intersectingSegments: null, triangleIndices: null, fittingMode: null, areaCentroid: null, pathLengthLabelSegmentIndex: null, perimeterLengthLabelSegmentIndex: null, checkerSize: null };
var k3 = new l5(n2(), n2());

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurementAnalysisView3D.js
var d3 = class extends n7(y) {
  constructor(e8) {
    super(e8), this.type = "area-measurement-view-3d", this.analysis = null, this.measurementData = null, this.lastDraggedVertex = null, this.cursorPoint = null, this.mode = e7.Auto;
  }
  initialize() {
    const { analysis: e8, view: t5 } = this;
    this.path = new x6({ view: t5, areaMeasurement: e8 }), this.analysisVisualization = new O4({ view: t5, analysis: e8, analysisViewData: this }), this.analysisController = new u3({ view: t5, analysis: e8, analysisViewData: this });
  }
  destroy() {
    this.analysisController = l(this.analysisController), this.analysisVisualization = l(this.analysisVisualization), this.path.destroy();
  }
  get updating() {
    var _a;
    return !!((_a = this.analysisVisualization) == null ? void 0 : _a.loadingMessages);
  }
  get result() {
    const { measurementData: e8 } = this;
    return t(e8) ? { area: null, mode: null, perimeter: null } : "euclidean" === e8.actualMeasurementMode ? { area: e8.area, perimeter: e8.perimeterLength, mode: "euclidean" } : { area: e8.geodesicArea, perimeter: e8.pathLength, mode: "geodesic" };
  }
  get viewData() {
    return this.analysisVisualization.viewData;
  }
  get validMeasurement() {
    return this.path.isValidPolygon;
  }
  get unit() {
    return c(this.analysis.unit, this._defaultUnit);
  }
  get testData() {
    return { visualization: this.analysisVisualization, controller: this.analysisController };
  }
};
e([d({ readOnly: true })], d3.prototype, "type", void 0), e([d({ constructOnly: true, nonNullable: true })], d3.prototype, "analysis", void 0), e([d()], d3.prototype, "updating", null), e([d()], d3.prototype, "analysisVisualization", void 0), e([d()], d3.prototype, "analysisController", void 0), e([d()], d3.prototype, "result", null), e([d()], d3.prototype, "measurementData", void 0), e([d()], d3.prototype, "viewData", null), e([d()], d3.prototype, "validMeasurement", null), e([d()], d3.prototype, "path", void 0), e([d()], d3.prototype, "lastDraggedVertex", void 0), e([d()], d3.prototype, "cursorPoint", void 0), e([d()], d3.prototype, "mode", void 0), e([d()], d3.prototype, "unit", null), e([d(r6)], d3.prototype, "_defaultUnit", void 0), d3 = e([n("esri.views.3d.analysis.AreaMeasurementAnalysisView3D")], d3);
var c6 = d3;
export {
  c6 as default
};
//# sourceMappingURL=AreaMeasurementAnalysisView3D-WRMKCZPQ.js.map
