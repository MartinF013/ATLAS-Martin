import {
  O as O3,
  l as l9
} from "./chunk-PQM6RARY.js";
import {
  n as n11,
  o as o15
} from "./chunk-2Y5KPYOJ.js";
import {
  Q as Q2
} from "./chunk-BBUIX72C.js";
import {
  K
} from "./chunk-5ZS6RUSM.js";
import {
  L as L4,
  r as r7,
  s as s7,
  x as x5
} from "./chunk-7LH2XNVI.js";
import {
  _ as _4
} from "./chunk-PXOPYXIX.js";
import {
  c as c7
} from "./chunk-WSQIVEW5.js";
import {
  r as r8
} from "./chunk-ZTFWVZTL.js";
import {
  e as e12,
  p as p4,
  u as u9
} from "./chunk-4LQ6NAOX.js";
import {
  t as t11
} from "./chunk-AWIG2DGF.js";
import {
  E as E6,
  e as e11,
  t as t8,
  t2 as t9
} from "./chunk-AIONJO5O.js";
import {
  a as a6,
  i as i7,
  i2 as i8,
  o as o14
} from "./chunk-YLSPLHY5.js";
import {
  s as s6
} from "./chunk-QMP4VG7M.js";
import {
  t as t7
} from "./chunk-5RP42VZJ.js";
import {
  k as k2
} from "./chunk-ZEDAE7EU.js";
import {
  o as o7
} from "./chunk-YXFNNKMT.js";
import {
  g
} from "./chunk-7OZR6JFF.js";
import {
  P as P3,
  e as e7,
  e2 as e8,
  f as f3,
  i as i4,
  l as l8,
  m,
  o as o11,
  o2 as o12,
  s as s5,
  t as t5
} from "./chunk-NXOQBIK7.js";
import {
  A as A2,
  E as E5
} from "./chunk-ERNXFM5T.js";
import {
  i as i6
} from "./chunk-6ITXWFMK.js";
import {
  e as e10,
  t as t6
} from "./chunk-SV4VP57N.js";
import {
  p as p2,
  u as u7
} from "./chunk-PWYPPSAW.js";
import {
  E as E4,
  S,
  _ as _3,
  c as c5,
  f as f2,
  i as i3,
  l as l7
} from "./chunk-5EXPMKQP.js";
import {
  W,
  a as a5,
  c as c4,
  l as l6
} from "./chunk-B7F3T673.js";
import {
  t as t2
} from "./chunk-QXYW5CVF.js";
import {
  D as D2
} from "./chunk-Z7AZMEL6.js";
import {
  f
} from "./chunk-FUKESVWQ.js";
import {
  c as c3,
  n as n10
} from "./chunk-T3KDRLPE.js";
import {
  u as u6
} from "./chunk-EJ7RFMRW.js";
import {
  c as c6
} from "./chunk-B3IXFXV6.js";
import {
  e as e9,
  i as i5
} from "./chunk-XNOIZLCR.js";
import {
  r as r6
} from "./chunk-ODYLXHP4.js";
import {
  l as l4
} from "./chunk-DVE4HUBR.js";
import {
  v as v2
} from "./chunk-5JKCNCL2.js";
import {
  t as t4
} from "./chunk-WJDUBZ7S.js";
import {
  o as o13
} from "./chunk-DNPZNIDB.js";
import {
  o as o9
} from "./chunk-TEJEYVH4.js";
import {
  h as h2
} from "./chunk-EYJ2F5XB.js";
import {
  o as o5
} from "./chunk-TR3U55RZ.js";
import {
  T
} from "./chunk-3DCTMZI6.js";
import {
  D,
  E as E2,
  F,
  G,
  L as L3,
  M,
  P as P2,
  R,
  V,
  Y,
  _ as _2
} from "./chunk-FPMD6IB4.js";
import {
  H,
  T as T2
} from "./chunk-PLLZPG4O.js";
import {
  U,
  i as i9,
  t as t10
} from "./chunk-WQLER7IU.js";
import {
  d2,
  h as h4,
  o2 as o10,
  x as x4
} from "./chunk-EEJIELE6.js";
import {
  E as E3,
  l as l5,
  u as u8
} from "./chunk-Y55TYMBP.js";
import {
  t as t3
} from "./chunk-NAB3NF54.js";
import {
  A,
  O as O2,
  c as c2,
  i as i2,
  o as o8
} from "./chunk-MDCKEJ7B.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  M as M2,
  e as e6,
  h as h3
} from "./chunk-NAIF4GWX.js";
import {
  W as W2,
  Z,
  j,
  p2 as p3
} from "./chunk-53KI6WDE.js";
import {
  b,
  k,
  l as l2,
  v
} from "./chunk-Q6AASANP.js";
import {
  e as e5,
  o as o6
} from "./chunk-YFBAFAZ2.js";
import {
  n as n8
} from "./chunk-RB3LJE4I.js";
import {
  a as a4
} from "./chunk-YZNDHJDJ.js";
import {
  l as l3
} from "./chunk-ZN2MGN4S.js";
import {
  L as L2,
  Q,
  w as w2
} from "./chunk-JZY7CGEI.js";
import {
  n as n9,
  r as r5
} from "./chunk-RTHP2LNT.js";
import {
  Un
} from "./chunk-PZWU5EHT.js";
import {
  i,
  s as s4
} from "./chunk-F5A4XAOJ.js";
import {
  _,
  r as r4
} from "./chunk-U7B2WKBH.js";
import {
  u as u3
} from "./chunk-G4IZ2HTT.js";
import {
  a as a2,
  l,
  w
} from "./chunk-T7BEWVV3.js";
import {
  E,
  h,
  o as o4,
  u as u4,
  x as x3
} from "./chunk-ASC3X65B.js";
import {
  a as a3,
  u as u5,
  z
} from "./chunk-56RHM4A6.js";
import {
  n as n7
} from "./chunk-OIPX3EDD.js";
import {
  x as x2
} from "./chunk-NWRK6QLX.js";
import {
  a,
  o as o3
} from "./chunk-BPZGJQOB.js";
import {
  L,
  P,
  e as e4,
  o as o2,
  q,
  r as r3,
  s as s3,
  u as u2,
  x
} from "./chunk-PKZEO23A.js";
import {
  n as n6,
  r as r2
} from "./chunk-AIRC226G.js";
import {
  d,
  e3,
  n4 as n,
  n5 as n2,
  n6 as n3,
  n8 as n5,
  u3 as u,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  n as n4
} from "./chunk-23NWA6WL.js";
import {
  s as s2
} from "./chunk-CVWDM4C7.js";
import {
  c,
  e as e2,
  o,
  p,
  r,
  s,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/LocalOriginFactory.js
var r9 = class {
  constructor(n18, t18) {
    this.vec3 = n18, this.id = t18;
  }
};
function c8(n18, s15, c12, e16) {
  return new r9(r2(n18, s15, c12), e16);
}

// node_modules/@arcgis/core/views/3d/terrain/Overlay.js
var h5;
!function(e16) {
  e16[e16.None = 0] = "None", e16[e16.ColorAndWater = 1] = "ColorAndWater", e16[e16.Highlight = 2] = "Highlight", e16[e16.Occluded = 3] = "Occluded";
}(h5 || (h5 = {}));
var l10 = class {
  constructor(e16, r15) {
    this.index = e16, this.renderTargets = r15, this._extent = u5(), this.resolution = 0, this.renderLocalOrigin = c8(0, 0, 0, "O"), this.pixelRatio = 1, this.mapUnitsPerPixel = 1, this.canvasGeometries = new u10(), this.validTargets = null, this.hasDrapedFeatureSource = false, this.hasDrapedRasterSource = false, this.hasTargetWithoutRasterImage = false, this.index = e16, this.validTargets = new Array(r15.renderTargets.length).fill(false);
  }
  get extent() {
    return this._extent;
  }
  getValidTexture(e16) {
    return this.validTargets[e16] ? this.renderTargets.getTarget(e16).getTexture() : null;
  }
  get _needsColorWithoutRasterImage() {
    return this.hasDrapedRasterSource && this.hasDrapedFeatureSource && this.hasTargetWithoutRasterImage;
  }
  getColorTexture(e16) {
    const t18 = e16 === h5.ColorAndWater ? this.renderTargets.getTarget(H.Color) : e16 === h5.Highlight ? this.renderTargets.getTarget(H.Highlight) : this.renderTargets.getTarget(H.Occluded);
    return t18 ? t18.getTexture() : null;
  }
  getColorTextureNoRasterImage() {
    return this._needsColorWithoutRasterImage ? this.getValidTexture(H.ColorNoRasterImage) : this.hasDrapedFeatureSource ? this.getValidTexture(H.Color) : null;
  }
  getNormalTexture(e16) {
    const t18 = e16 === h5.ColorAndWater ? this.renderTargets.getTarget(H.Water) : null;
    return t18 ? t18.getTexture() : null;
  }
  draw(e16, t18) {
    const r15 = this.computeRenderTargetValidityBitfield();
    for (const s15 of this.renderTargets.renderTargets)
      s15.type !== H.ColorNoRasterImage || this._needsColorWithoutRasterImage ? this.validTargets[s15.type] = e16.drawTarget(this, s15, t18) : this.validTargets[s15.type] = false;
    return r15 ^ this.computeRenderTargetValidityBitfield() ? A.CHANGED : A.UNCHANGED;
  }
  computeRenderTargetValidityBitfield() {
    const e16 = this.validTargets;
    return +e16[H.Color] | +e16[H.ColorNoRasterImage] << 1 | +e16[H.Highlight] << 2 | +e16[H.Water] << 3 | +e16[H.Occluded] << 4;
  }
  setupGeometryViewsCyclical(e16) {
    this.setupGeometryViewsDirect();
    const t18 = 1e-3 * e16.range;
    if (this._extent[0] - t18 <= e16.min) {
      const t19 = this.canvasGeometries.extents[this.canvasGeometries.numViews++];
      z(this._extent, e16.range, 0, t19);
    }
    if (this._extent[2] + t18 >= e16.max) {
      const t19 = this.canvasGeometries.extents[this.canvasGeometries.numViews++];
      z(this._extent, -e16.range, 0, t19);
    }
  }
  setupGeometryViewsDirect() {
    this.canvasGeometries.numViews = 1, a3(this.canvasGeometries.extents[0], this._extent);
  }
  hasSomeSizedView() {
    for (let e16 = 0; e16 < this.canvasGeometries.numViews; e16++) {
      const t18 = this.canvasGeometries.extents[e16];
      if (t18[0] !== t18[2] && t18[1] !== t18[3])
        return true;
    }
    return false;
  }
  applyViewport(e16) {
    e16.setViewport(this.index === T2.INNER ? 0 : this.resolution, 0, this.resolution, this.resolution);
  }
};
function g2(t18, r15, s15) {
  return Math.min(a(Math.max(t18, r15) + 256), s15);
}
var u10 = class {
  constructor() {
    this.extents = [u5(), u5(), u5()], this.numViews = 0;
  }
};

// node_modules/@arcgis/core/views/3d/terrain/OverlayFramebufferObject.js
var b2 = class {
  constructor(e16, b3) {
    this.size = n8(), this._fbo = null, this._fbo = new D2(e16, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, pixelFormat: P2.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D.CLAMP_TO_EDGE, samplingMode: L3.LINEAR_MIPMAP_LINEAR, hasMipmap: b3, maxAnisotropy: 8, width: 0, height: 0 });
  }
  dispose() {
    this._fbo = s(this._fbo);
  }
  getTexture() {
    return this._fbo ? this._fbo.colorTexture : null;
  }
  isValid() {
    return null !== this._fbo;
  }
  resize(e16, t18) {
    this.size[0] = e16, this.size[1] = t18, this._fbo.resize(this.size[0], this.size[1]);
  }
  bind(e16) {
    e16.bindFramebuffer(this._fbo);
  }
  generateMipMap() {
    this._fbo.colorTexture.descriptor.hasMipmap && this._fbo.colorTexture.generateMipmap();
  }
  disposeRenderTargetMemory() {
    var _a;
    (_a = this._fbo) == null ? void 0 : _a.resize(0, 0);
  }
  get gpuMemoryUsage() {
    var _a;
    return ((_a = this._fbo) == null ? void 0 : _a.gpuMemoryUsage) ?? 0;
  }
};

// node_modules/@arcgis/core/views/3d/terrain/OverlayRenderTarget.js
var t13 = class {
  constructor(t18) {
    const o20 = (e16, s15, o21 = true) => ({ type: s15, fbo: new b2(t18, o21), renderPass: e16, valid: false, lastUsed: 1 / 0 });
    this.renderTargets = [o20(A2.MATERIAL, H.Color), o20(A2.MATERIAL, H.ColorNoRasterImage), o20(A2.MATERIAL_HIGHLIGHT, H.Highlight, false), o20(A2.MATERIAL_NORMAL, H.Water), o20(A2.MATERIAL, H.Occluded)];
  }
  getTarget(e16) {
    return this.renderTargets[e16].fbo;
  }
  dispose() {
    for (const e16 of this.renderTargets)
      e16.fbo.dispose();
  }
  disposeRenderTargetMemory() {
    for (const e16 of this.renderTargets)
      e16.fbo.disposeRenderTargetMemory();
  }
  validateUsageForTarget(e16, r15, s15) {
    if (e16)
      r15.lastUsed = s15;
    else if (s15 - r15.lastUsed > o16)
      r15.fbo.disposeRenderTargetMemory(), r15.lastUsed = 1 / 0;
    else if (r15.lastUsed < 1 / 0)
      return true;
    return false;
  }
  get gpuMemoryUsage() {
    return this.renderTargets.reduce((e16, r15) => e16 + r15.fbo.gpuMemoryUsage, 0);
  }
};
var o16 = 1e3;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueRepository.js
var s8 = class {
  constructor(e16) {
    this._context = e16, this._perConstructorInstances = new t7(), this._frameCounter = 0, this._keepAliveFrameCount = o17;
  }
  get viewingMode() {
    return this._context.viewingMode;
  }
  get constructionContext() {
    return this._context;
  }
  dispose() {
    this._perConstructorInstances.forEach((e16) => e16.forEach((e17) => e17.technique.destroy())), this._perConstructorInstances.clear();
  }
  acquire(t18, r15) {
    const s15 = r15.key;
    let o20 = this._perConstructorInstances.get(t18, s15);
    if (t(o20)) {
      const e16 = new t18(this._context, r15, () => this.release(e16));
      o20 = new n12(e16), this._perConstructorInstances.set(t18, s15, o20);
    }
    return ++o20.refCount, o20.technique;
  }
  releaseAndAcquire(e16, r15, s15) {
    if (r(s15)) {
      if (r15.key === s15.key)
        return s15;
      this.release(s15);
    }
    return this.acquire(e16, r15);
  }
  release(t18) {
    if (t(t18) || this._perConstructorInstances.empty)
      return;
    const r15 = this._perConstructorInstances.get(t18.constructor, t18.key);
    t(r15) || (--r15.refCount, 0 === r15.refCount && (r15.refZeroFrame = this._frameCounter));
  }
  frameUpdate() {
    this._frameCounter++, this._keepAliveFrameCount !== o17 && this._perConstructorInstances.forEach((e16, t18) => {
      e16.forEach((e17, r15) => {
        0 === e17.refCount && e17.refZeroFrame + this._keepAliveFrameCount < this._frameCounter && (e17.technique.destroy(), this._perConstructorInstances.delete(t18, r15));
      });
    });
  }
  async reloadAll() {
    const e16 = new Array();
    this._perConstructorInstances.forEach((t18, r15) => {
      const s15 = async (e17, t19) => {
        const r16 = t19.shader;
        r16 && (await r16.reload(), e17.forEach((e18) => {
          e18.technique.reload(this._context);
        }));
      };
      e16.push(s15(t18, r15));
    }), await Promise.all(e16);
  }
};
var n12 = class {
  constructor(e16) {
    this.technique = e16, this.refCount = 0, this.refZeroFrame = 0;
  }
};
var o17 = -1;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/AutoDisposable.js
var s9 = (s15) => {
  class e16 extends s15 {
    constructor() {
      super(...arguments), this._isDisposed = false;
    }
    dispose() {
      for (const s16 of this._managedDisposables ?? []) {
        const e17 = this[s16];
        this[s16] = null, e17 && "function" == typeof e17.dispose && e17.dispose();
      }
      this._isDisposed = true;
    }
    get isDisposed() {
      return this._isDisposed;
    }
  }
  return e16;
};
var e13 = class extends s9(class {
}) {
};
function i10() {
  return (s15, e16) => {
    var _a;
    s15.hasOwnProperty("_managedDisposables") || (s15._managedDisposables = ((_a = s15._managedDisposables) == null ? void 0 : _a.slice()) ?? []), s15._managedDisposables.unshift(e16);
  };
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterialRepository.js
var a7 = s2.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository");
var l11 = class {
  constructor(e16, t18, r15, i16) {
    this._textureRepository = e16, this._techniqueRepository = t18, this.materialChanged = r15, this.requestRender = i16, this._id2glMaterialRef = new t7();
  }
  dispose() {
    this._textureRepository.dispose();
  }
  acquire(e16, r15) {
    this._ownMaterial(e16);
    let i16 = this._id2glMaterialRef.get(r15, e16.id);
    if (t(i16)) {
      const t18 = e16.createGLMaterial({ material: e16, techniqueRep: this._techniqueRepository, textureRep: this._textureRepository, output: r15 });
      i16 = new n13(t18), this._id2glMaterialRef.set(r15, e16.id, i16);
    }
    return i16.ref(), i16.glMaterial;
  }
  release(e16, t18) {
    const s15 = this._id2glMaterialRef.get(t18, e16.id);
    r(s15) && (s15.unref(), s15.referenced || (s(s15.glMaterial), this._id2glMaterialRef.delete(t18, e16.id)));
  }
  _ownMaterial(e16) {
    r(e16.repository) && e16.repository !== this && a7.error("Material is already owned by a different material repository"), e16.repository = this;
  }
};
var n13 = class {
  constructor(e16) {
    this.glMaterial = e16, this.refCnt = 0;
  }
  ref() {
    ++this.refCnt;
  }
  unref() {
    --this.refCnt, e6(this.refCnt >= 0);
  }
  get referenced() {
    return this.refCnt > 0;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/testUtils.js
var e14 = { orderedRepackingEnabled: false };
var n14 = { rootOrigin: null };

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RibbonLineTechnique.js
var A3 = /* @__PURE__ */ new Map([[O.POSITION, 0], [O.SUBDIVISIONFACTOR, 1], [O.UV0, 2], [O.AUXPOS1, 3], [O.AUXPOS2, 4], [O.COLOR, 5], [O.COLORFEATUREATTRIBUTE, 5], [O.SIZE, 6], [O.SIZEFEATUREATTRIBUTE, 6], [O.OPACITYFEATUREATTRIBUTE, 7]]);
var I = class extends e7 {
  constructor(e16, t18, i16) {
    super(e16, t18, i16), this.stippleTextureRepository = e16.stippleTextureRepository;
  }
  initializeProgram(e16) {
    const t18 = I.shader.get().build(this.configuration);
    return new o11(e16.rctx, t18, A3);
  }
  destroy() {
    super.destroy(), this.stippleTextureRepository.release(this.stipplePattern), this.stipplePattern = null, this.stippleTextureBind = null;
  }
  bindPass(t18, i16) {
    if (this.program.bindPass(t18, i16), this.stipplePattern !== t18.stipplePattern) {
      const e16 = t18.stipplePattern;
      this.stippleTextureBind = this.stippleTextureRepository.swap(this.stipplePattern, e16), this.stipplePattern = e16;
    }
    if (this.configuration.stippleEnabled) {
      const { pixelSize: t19, sdfNormalizer: i17, pixels: r15 } = r(this.stippleTextureBind) ? this.stippleTextureBind(this.program) : { pixelSize: 1, sdfNormalizer: 1, pixels: 1 };
      this.program.setUniform1f("stipplePatternSDFNormalizer", i17), this.program.setUniform1f("stipplePatternTextureSize", r15), this.program.setUniform1f("stipplePatternPixelSize", t19), this.program.setUniform1f("stipplePatternPixelSizeInv", 1 / t19);
    }
  }
  _makePipelineState(e16, i16) {
    const r15 = this.configuration, c12 = e16 === O2.NONE, u12 = e16 === O2.FrontFace;
    return W({ blending: r15.output === o9.Color || r15.output === o9.Alpha ? c12 ? c5 : E4(e16) : null, depthTest: { func: l7(e16) }, depthWrite: c12 ? r15.writeDepth && a5 : S(e16), colorWrite: c4, stencilWrite: r15.hasOccludees ? e8 : null, stencilTest: r15.hasOccludees ? i16 ? o12 : f3 : null, polygonOffset: c12 || u12 ? r15.hasPolygonOffset && U2 : f2 });
  }
  initializePipeline() {
    const e16 = this.configuration;
    if (e16.occluder) {
      const t18 = e16.hasPolygonOffset && U2;
      this._occluderPipelineTransparent = W({ blending: c5, polygonOffset: t18, depthTest: s5, depthWrite: null, colorWrite: c4, stencilWrite: null, stencilTest: m }), this._occluderPipelineOpaque = W({ blending: c5, polygonOffset: t18, depthTest: s5, depthWrite: null, colorWrite: c4, stencilWrite: l8, stencilTest: P3 }), this._occluderPipelineMaskWrite = W({ blending: null, polygonOffset: t18, depthTest: i4, depthWrite: null, colorWrite: null, stencilWrite: e8, stencilTest: o12 });
    }
    return this._occludeePipelineState = this._makePipelineState(this.configuration.transparencyPassType, true), this._makePipelineState(this.configuration.transparencyPassType, false);
  }
  get primitiveType() {
    return this.configuration.wireframe ? E2.LINES : E2.TRIANGLE_STRIP;
  }
  getPipelineState(e16, t18) {
    return t18 ? this._occludeePipelineState : this.configuration.occluder ? e16 === E5.TRANSPARENT_OCCLUDER_MATERIAL ? this._occluderPipelineTransparent : e16 === E5.OCCLUDER_MATERIAL ? this._occluderPipelineOpaque : this._occluderPipelineMaskWrite : super.getPipelineState(e16, t18);
  }
};
I.shader = new t5(L4, () => import("./RibbonLine.glsl-O5GJASN6.js"));
var U2 = { factor: 0, units: -4 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/RibbonLineMaterial.js
var z2 = s2.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial");
var B;
!function(e16) {
  e16[e16.LEFT_JOIN_START = -2] = "LEFT_JOIN_START", e16[e16.LEFT_JOIN_END = -1] = "LEFT_JOIN_END", e16[e16.LEFT_CAP_START = -4] = "LEFT_CAP_START", e16[e16.LEFT_CAP_END = -5] = "LEFT_CAP_END", e16[e16.RIGHT_JOIN_START = 2] = "RIGHT_JOIN_START", e16[e16.RIGHT_JOIN_END = 1] = "RIGHT_JOIN_END", e16[e16.RIGHT_CAP_START = 4] = "RIGHT_CAP_START", e16[e16.RIGHT_CAP_END = 5] = "RIGHT_CAP_END";
}(B || (B = {}));
var H2 = class extends d2 {
  constructor(e16) {
    super(e16, new V2()), this._vertexAttributeLocations = A3, this.techniqueConfig = new s7(), this.layout = this.createLayout();
  }
  isClosed(e16, t18) {
    return Y2(this.parameters, e16, t18);
  }
  getConfiguration(e16, t18) {
    this.techniqueConfig.output = e16, this.techniqueConfig.draped = t18.slot === E5.DRAPED_MATERIAL;
    const i16 = r(this.parameters.stipplePattern) && e16 !== o9.Highlight;
    return this.techniqueConfig.stippleEnabled = i16, this.techniqueConfig.stippleOffColorEnabled = i16 && r(this.parameters.stippleOffColor), this.techniqueConfig.stippleScaleWithLineWidth = i16 && this.parameters.stippleScaleWithLineWidth, this.techniqueConfig.stipplePreferContinuous = i16 && this.parameters.stipplePreferContinuous, this.techniqueConfig.hasSlicePlane = this.parameters.hasSlicePlane, this.techniqueConfig.hasOccludees = this.parameters.hasOccludees, this.techniqueConfig.roundJoins = "round" === this.parameters.join, this.techniqueConfig.capType = this.parameters.cap, this.techniqueConfig.hasPolygonOffset = this.parameters.hasPolygonOffset, this.techniqueConfig.writeDepth = this.parameters.writeDepth, this.techniqueConfig.vvColor = this.parameters.vvColorEnabled, this.techniqueConfig.vvOpacity = this.parameters.vvOpacityEnabled, this.techniqueConfig.vvSize = this.parameters.vvSizeEnabled, this.techniqueConfig.innerColorEnabled = this.parameters.innerWidth > 0 && r(this.parameters.innerColor), this.techniqueConfig.falloffEnabled = this.parameters.falloff > 0, this.techniqueConfig.occluder = this.parameters.renderOccluded === h4.OccludeAndTransparentStencil, this.techniqueConfig.transparencyPassType = t18.transparencyPassType, this.techniqueConfig.hasMultipassTerrain = t18.multipassTerrain.enabled, this.techniqueConfig.cullAboveGround = t18.multipassTerrain.cullAboveGround, this.techniqueConfig.wireframe = this.parameters.wireframe, this.techniqueConfig;
  }
  intersect(e16, t18, i16, s15, a8, n18, o20, h8, l12) {
    r(l12) ? this._intersectDrapedLineGeometry(e16, s15, l12, n18, o20) : this._intersectLineGeometry(e16, t18, i16, s15, o20);
  }
  _intersectDrapedLineGeometry(e16, r15, i16, s15, a8) {
    if (!r15.options.selectionMode)
      return;
    const n18 = e16.vertexAttributes.get(O.POSITION).data, o20 = e16.vertexAttributes.get(O.SIZE);
    let h8 = this.parameters.width;
    if (this.parameters.vvSizeEnabled) {
      const r16 = e16.vertexAttributes.get(O.SIZEFEATUREATTRIBUTE).data[0];
      h8 *= o3(this.parameters.vvSizeOffset[0] + r16 * this.parameters.vvSizeFactor[0], this.parameters.vvSizeMinSize[0], this.parameters.vvSizeMaxSize[0]);
    } else
      o20 && (h8 *= o20.data[0]);
    const l12 = s15[0], c12 = s15[1], u12 = (h8 / 2 + 4) * e16.screenToWorldRatio;
    let p6 = Number.MAX_VALUE, m3 = 0;
    for (let f5 = 0; f5 < n18.length - 5; f5 += 3) {
      const e17 = n18[f5], r16 = n18[f5 + 1], i17 = l12 - e17, s16 = c12 - r16, a9 = n18[f5 + 3] - e17, o21 = n18[f5 + 4] - r16, h9 = o3((a9 * i17 + o21 * s16) / (a9 * a9 + o21 * o21), 0, 1), u13 = a9 * h9 - i17, T5 = o21 * h9 - s16, E8 = u13 * u13 + T5 * T5;
      E8 < p6 && (p6 = E8, m3 = f5 / 3);
    }
    p6 < u12 * u12 && a8(i16.dist, i16.normal, m3, false);
  }
  _intersectLineGeometry(e16, r15, i16, m3, f5) {
    if (!m3.options.selectionMode || u8(r15))
      return;
    if (!M2(i16))
      return void z2.error("intersection assumes a translation-only matrix");
    const T5 = e16.vertexAttributes, d4 = T5.get(O.POSITION).data;
    let R5 = this.parameters.width;
    if (this.parameters.vvSizeEnabled) {
      const e17 = T5.get(O.SIZEFEATUREATTRIBUTE).data[0];
      R5 *= o3(this.parameters.vvSizeOffset[0] + e17 * this.parameters.vvSizeFactor[0], this.parameters.vvSizeMinSize[0], this.parameters.vvSizeMaxSize[0]);
    } else
      T5.has(O.SIZE) && (R5 *= T5.get(O.SIZE).data[0]);
    const g4 = m3.camera, b3 = te;
    a4(b3, m3.point);
    const C = R5 * g4.pixelRatio / 2 + 4 * g4.pixelRatio;
    o2(ue[0], b3[0] - C, b3[1] + C, 0), o2(ue[1], b3[0] + C, b3[1] + C, 0), o2(ue[2], b3[0] + C, b3[1] - C, 0), o2(ue[3], b3[0] - C, b3[1] - C, 0);
    for (let t18 = 0; t18 < 4; t18++)
      if (!g4.unprojectFromRenderScreen(ue[t18], pe[t18]))
        return;
    j(g4.eye, pe[0], pe[1], me), j(g4.eye, pe[1], pe[2], fe), j(g4.eye, pe[2], pe[3], Te), j(g4.eye, pe[3], pe[0], Ee);
    let L6 = Number.MAX_VALUE, N = 0;
    const P5 = X(this.parameters, T5, e16.indices) ? d4.length - 2 : d4.length - 5;
    for (let t18 = 0; t18 < P5; t18 += 3) {
      Q3[0] = d4[t18] + i16[12], Q3[1] = d4[t18 + 1] + i16[13], Q3[2] = d4[t18 + 2] + i16[14];
      const e17 = (t18 + 3) % d4.length;
      if (K2[0] = d4[e17] + i16[12], K2[1] = d4[e17 + 1] + i16[13], K2[2] = d4[e17 + 2] + i16[14], W2(me, Q3) < 0 && W2(me, K2) < 0 || W2(fe, Q3) < 0 && W2(fe, K2) < 0 || W2(Te, Q3) < 0 && W2(Te, K2) < 0 || W2(Ee, Q3) < 0 && W2(Ee, K2) < 0)
        continue;
      if (g4.projectToRenderScreen(Q3, re), g4.projectToRenderScreen(K2, ie), re[2] < 0 && ie[2] > 0) {
        e4($, Q3, K2);
        const e18 = g4.frustum, t19 = -W2(e18[k2.NEAR], Q3) / P($, Z(e18[k2.NEAR]));
        q($, $, t19), u2(Q3, Q3, $), g4.projectToRenderScreen(Q3, re);
      } else if (re[2] > 0 && ie[2] < 0) {
        e4($, K2, Q3);
        const e18 = g4.frustum, t19 = -W2(e18[k2.NEAR], K2) / P($, Z(e18[k2.NEAR]));
        q($, $, t19), u2(K2, K2, $), g4.projectToRenderScreen(K2, ie);
      } else if (re[2] < 0 && ie[2] < 0)
        continue;
      re[2] = 0, ie[2] = 0;
      const r16 = b(l2(re, ie, ne), b3);
      r16 < L6 && (L6 = r16, r3(se, Q3), r3(ae, K2), N = t18 / 3);
    }
    const y3 = m3.rayBegin, D4 = m3.rayEnd;
    if (L6 < C * C) {
      let e17 = Number.MAX_VALUE;
      if (k(l2(se, ae, ne), l2(y3, D4, oe), ee)) {
        e4(ee, ee, y3);
        const t18 = s3(ee);
        q(ee, ee, 1 / t18), e17 = t18 / x(y3, D4);
      }
      f5(e17, ee, N, false);
    }
  }
  computeAttachmentOrigin(e16, t18) {
    const r15 = e16.vertexAttributes;
    if (!r15)
      return null;
    const i16 = e16.indices, s15 = r15.get(O.POSITION);
    return h2(s15, i16 ? i16.get(O.POSITION) : null, i16 && X(this.parameters, r15, i16), t18);
  }
  createLayout() {
    const e16 = T().vec3f(O.POSITION).f32(O.SUBDIVISIONFACTOR).vec2f(O.UV0).vec3f(O.AUXPOS1).vec3f(O.AUXPOS2);
    return this.parameters.vvSizeEnabled ? e16.f32(O.SIZEFEATUREATTRIBUTE) : e16.f32(O.SIZE), this.parameters.vvColorEnabled ? e16.f32(O.COLORFEATUREATTRIBUTE) : e16.vec4f(O.COLOR), this.parameters.vvOpacityEnabled && e16.f32(O.OPACITYFEATUREATTRIBUTE), e16;
  }
  createBufferWriter() {
    return new Z2(this.layout, this.parameters);
  }
  requiresSlot(e16, t18) {
    if (e16 === E5.DRAPED_MATERIAL)
      return true;
    if (this.parameters.renderOccluded === h4.OccludeAndTransparentStencil)
      return e16 === E5.OPAQUE_MATERIAL || e16 === E5.OCCLUDER_MATERIAL || e16 === E5.TRANSPARENT_OCCLUDER_MATERIAL;
    const r15 = i7(t18);
    if (r15 === o9.Color || r15 === o9.Alpha) {
      return e16 === (this.parameters.writeDepth ? E5.TRANSPARENT_MATERIAL : E5.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL);
    }
    return e16 === E5.OPAQUE_MATERIAL;
  }
  createGLMaterial(e16) {
    return e16.output === o9.Color || e16.output === o9.Alpha || e16.output === o9.Highlight || e16.output === o9.Depth ? new W3(e16) : null;
  }
  validateParameters(e16) {
    "miter" !== e16.join && (e16.miterLimit = 0);
  }
};
var W3 = class extends t4 {
  _updateOccludeeState(e16) {
    e16.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e16.hasOccludees });
  }
  beginSlot(e16) {
    return this._output !== o9.Color && this._output !== o9.Alpha || this._updateOccludeeState(e16), this.ensureTechnique(I, e16);
  }
};
var V2 = class extends v2 {
  constructor() {
    super(...arguments), this.width = 0, this.color = _, this.join = "miter", this.cap = r7.BUTT, this.miterLimit = 5, this.writeDepth = true, this.hasPolygonOffset = false, this.stippleScaleWithLineWidth = false, this.stipplePreferContinuous = true, this.hasSlicePlane = false, this.vvFastUpdate = false, this.isClosed = false, this.falloff = 0, this.innerWidth = 0, this.hasOccludees = false, this.wireframe = false;
  }
};
var Z2 = class {
  constructor(e16, t18) {
    this.parameters = t18, this.numJoinSubdivisions = 0, this.vertexBufferLayout = e16;
    const r15 = t18.stipplePattern ? 1 : 0;
    switch (this.parameters.join) {
      case "miter":
      case "bevel":
        this.numJoinSubdivisions = r15;
        break;
      case "round":
        this.numJoinSubdivisions = x5 + r15;
    }
  }
  _isClosed(e16) {
    return X(this.parameters, e16.vertexAttributes, e16.indices);
  }
  allocate(e16) {
    return this.vertexBufferLayout.createBuffer(e16);
  }
  elementCount(e16) {
    const t18 = 2, r15 = e16.indices.get(O.POSITION).length / 2 + 1, i16 = this._isClosed(e16);
    let s15 = i16 ? 2 : 2 * t18;
    return s15 += ((i16 ? r15 : r15 - 1) - (i16 ? 0 : 1)) * (2 * this.numJoinSubdivisions + 4), s15 += 2, this.parameters.wireframe && (s15 = 2 + 4 * (s15 - 2)), s15;
  }
  write(e16, t18, r15, i16) {
    var _a;
    const s15 = he, n18 = le, o20 = ce, h8 = t18.vertexAttributes.get(O.POSITION).data, l12 = t18.indices && t18.indices.get(O.POSITION), u12 = (_a = t18.vertexAttributes.get(O.DISTANCETOSTART)) == null ? void 0 : _a.data;
    l12 && l12.length !== 2 * (h8.length / 3 - 1) && console.warn("RibbonLineMaterial does not support indices");
    let f5 = 1, T5 = 0;
    this.parameters.vvSizeEnabled ? T5 = t18.vertexAttributes.get(O.SIZEFEATUREATTRIBUTE).data[0] : t18.vertexAttributes.has(O.SIZE) && (f5 = t18.vertexAttributes.get(O.SIZE).data[0]);
    let E8 = [1, 1, 1, 1], d4 = 0;
    this.parameters.vvColorEnabled ? d4 = t18.vertexAttributes.get(O.COLORFEATUREATTRIBUTE).data[0] : t18.vertexAttributes.has(O.COLOR) && (E8 = t18.vertexAttributes.get(O.COLOR).data);
    let A6 = 0;
    this.parameters.vvOpacityEnabled && (A6 = t18.vertexAttributes.get(O.OPACITYFEATUREATTRIBUTE).data[0]);
    const v3 = h8.length / 3, _5 = e16.transformation, R5 = new Float32Array(r15.buffer), S5 = this.vertexBufferLayout.stride / 4;
    let O5 = i16 * S5;
    const I3 = O5;
    let g4 = 0;
    const b3 = u12 ? (e17, t19, r16) => g4 = u12[r16] : (e17, t19, r16) => g4 += x(e17, t19), C = (e17, t19, r16, i17, s16, a8, n19) => {
      if (R5[O5++] = t19[0], R5[O5++] = t19[1], R5[O5++] = t19[2], R5[O5++] = i17, R5[O5++] = n19, R5[O5++] = s16, R5[O5++] = e17[0], R5[O5++] = e17[1], R5[O5++] = e17[2], R5[O5++] = r16[0], R5[O5++] = r16[1], R5[O5++] = r16[2], this.parameters.vvSizeEnabled ? R5[O5++] = T5 : R5[O5++] = f5, this.parameters.vvColorEnabled)
        R5[O5++] = d4;
      else {
        const e18 = Math.min(4 * a8, E8.length - 4);
        R5[O5++] = E8[e18 + 0], R5[O5++] = E8[e18 + 1], R5[O5++] = E8[e18 + 2], R5[O5++] = E8[e18 + 3];
      }
      this.parameters.vvOpacityEnabled && (R5[O5++] = A6);
    };
    O5 += S5, o2(n18, h8[0], h8[1], h8[2]), _5 && L(n18, n18, _5);
    const L6 = this._isClosed(t18);
    if (L6) {
      const e17 = h8.length - 3;
      o2(s15, h8[e17], h8[e17 + 1], h8[e17 + 2]), _5 && L(s15, s15, _5);
    } else
      o2(o20, h8[3], h8[4], h8[5]), _5 && L(o20, o20, _5), C(n18, n18, o20, 1, B.LEFT_CAP_START, 0, 0), C(n18, n18, o20, 1, B.RIGHT_CAP_START, 0, 0), r3(s15, n18), r3(n18, o20);
    const N = L6 ? 0 : 1, P5 = L6 ? v3 : v3 - 1;
    for (let p6 = N; p6 < P5; p6++) {
      const e17 = (p6 + 1) % v3 * 3;
      o2(o20, h8[e17 + 0], h8[e17 + 1], h8[e17 + 2]), _5 && L(o20, o20, _5), b3(s15, n18, p6), C(s15, n18, o20, 0, B.LEFT_JOIN_END, p6, g4), C(s15, n18, o20, 0, B.RIGHT_JOIN_END, p6, g4);
      const t19 = this.numJoinSubdivisions;
      for (let r16 = 0; r16 < t19; ++r16) {
        const e18 = (r16 + 1) / (t19 + 1);
        C(s15, n18, o20, e18, B.LEFT_JOIN_END, p6, g4), C(s15, n18, o20, e18, B.RIGHT_JOIN_END, p6, g4);
      }
      C(s15, n18, o20, 1, B.LEFT_JOIN_START, p6, g4), C(s15, n18, o20, 1, B.RIGHT_JOIN_START, p6, g4), r3(s15, n18), r3(n18, o20);
    }
    L6 ? (o2(o20, h8[3], h8[4], h8[5]), _5 && L(o20, o20, _5), g4 = b3(s15, n18, P5), C(s15, n18, o20, 0, B.LEFT_JOIN_END, N, g4), C(s15, n18, o20, 0, B.RIGHT_JOIN_END, N, g4)) : (g4 = b3(s15, n18, P5), C(s15, n18, n18, 0, B.LEFT_CAP_END, P5, g4), C(s15, n18, n18, 0, B.RIGHT_CAP_END, P5, g4)), k3(R5, I3 + S5, R5, I3, S5);
    O5 = k3(R5, O5 - S5, R5, O5, S5), this.parameters.wireframe && this._addWireframeVertices(r15, I3, O5, S5);
  }
  _addWireframeVertices(e16, t18, r15, i16) {
    const s15 = new Float32Array(e16.buffer, r15 * Float32Array.BYTES_PER_ELEMENT), a8 = new Float32Array(e16.buffer, t18 * Float32Array.BYTES_PER_ELEMENT, r15 - t18);
    let n18 = 0;
    const o20 = (e17) => n18 = k3(a8, e17, s15, n18, i16);
    for (let h8 = 0; h8 < a8.length - 1; h8 += 2 * i16)
      o20(h8), o20(h8 + 2 * i16), o20(h8 + 1 * i16), o20(h8 + 2 * i16), o20(h8 + 1 * i16), o20(h8 + 3 * i16);
  }
};
function k3(e16, t18, r15, i16, s15) {
  for (let a8 = 0; a8 < s15; a8++)
    r15[i16++] = e16[t18++];
  return i16;
}
function X(e16, t18, r15) {
  return Y2(e16, t18.get(O.POSITION).data, r15 ? r15.get(O.POSITION) : null);
}
function Y2(e16, t18, r15) {
  return !!e16.isClosed && (r15 ? r15.length > 2 : t18.length > 6);
}
var Q3 = n6();
var K2 = n6();
var $ = n6();
var ee = n6();
var te = n6();
var re = x2();
var ie = x2();
var se = n6();
var ae = n6();
var ne = v();
var oe = v();
var he = n6();
var le = n6();
var ce = n6();
var ue = [x2(), x2(), x2(), x2()];
var pe = [n6(), n6(), n6(), n6()];
var me = p3();
var fe = p3();
var Te = p3();
var Ee = p3();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GridLocalOriginFactory.js
var j2 = class {
  constructor(t18, r15 = 125e4) {
    this._originSR = t18, this._gridSize = r15, this._origins = /* @__PURE__ */ new Map(), this._objects = /* @__PURE__ */ new Map(), this._rootOriginId = "root/" + e3();
  }
  getOrigin(i16) {
    const r15 = this._origins.get(this._rootOriginId);
    if (null == r15) {
      const r16 = n14.rootOrigin;
      if (r(r16))
        return this._origins.set(this._rootOriginId, c8(r16[0], r16[1], r16[2], this._rootOriginId)), this.getOrigin(i16);
      const o20 = c8(i16[0] + Math.random() - 0.5, i16[1] + Math.random() - 0.5, i16[2] + Math.random() - 0.5, this._rootOriginId);
      return this._origins.set(this._rootOriginId, o20), o20;
    }
    const s15 = this._gridSize, e16 = Math.round(i16[0] / s15), a8 = Math.round(i16[1] / s15), n18 = Math.round(i16[2] / s15), h8 = `${e16}/${a8}/${n18}`;
    let c12 = this._origins.get(h8);
    const g4 = 0.5 * s15;
    if (e4(p5, i16, r15.vec3), p5[0] = Math.abs(p5[0]), p5[1] = Math.abs(p5[1]), p5[2] = Math.abs(p5[2]), p5[0] < g4 && p5[1] < g4 && p5[2] < g4) {
      if (c12) {
        const t18 = Math.max(...p5);
        e4(p5, i16, c12.vec3), p5[0] = Math.abs(p5[0]), p5[1] = Math.abs(p5[1]), p5[2] = Math.abs(p5[2]);
        if (Math.max(...p5) < t18)
          return c12;
      }
      return r15;
    }
    return c12 || (c12 = c8(e16 * s15, a8 * s15, n18 * s15, h8), this._origins.set(h8, c12)), c12;
  }
  _drawOriginBox(t18, i16 = r4(1, 1, 0, 1)) {
    const o20 = window.view, s15 = o20._stage, m3 = i16.toString();
    if (!this._objects.has(m3)) {
      this._material = new H2({ width: 2, color: i16 }), s15.add(this._material);
      const t19 = new l9({ isPickable: false }), r15 = new O3({ castShadow: false });
      s15.add(r15), t19.add(r15), s15.add(t19), this._objects.set(m3, r15);
    }
    const d4 = this._objects.get(m3), j4 = [0, 1, 5, 4, 0, 2, 1, 7, 6, 2, 0, 1, 3, 7, 5, 4, 6, 2, 0], p6 = j4.length, b3 = new Array(3 * p6), l12 = new Uint16Array(2 * (p6 - 1)), u12 = 0.5 * this._gridSize;
    for (let r15 = 0; r15 < p6; r15++)
      b3[3 * r15 + 0] = t18[0] + (1 & j4[r15] ? u12 : -u12), b3[3 * r15 + 1] = t18[1] + (2 & j4[r15] ? u12 : -u12), b3[3 * r15 + 2] = t18[2] + (4 & j4[r15] ? u12 : -u12), r15 > 0 && (l12[2 * r15 + 0] = r15 - 1, l12[2 * r15 + 1] = r15);
    Un(b3, this._originSR, 0, b3, o20.renderSpatialReference, 0, p6);
    const M4 = new g([[O.POSITION, { size: 3, data: b3, exclusive: true }]], [[O.POSITION, l12]], c2.Line);
    s15.add(M4), d4.addGeometry(M4, this._material, o6);
  }
};
var p5 = n6();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BindParameters.js
var h6 = class {
  constructor(h8, n18, l12) {
    this.shadowMap = h8, this.ssaoHelper = n18, this.slicePlane = l12, this.slot = E5.OPAQUE_MATERIAL, this.hasOccludees = false, this.enableFillLights = true, this._inverseViewport = n9(), this.lighting = new e9(), this.ssr = new c7(), this.multipassTerrain = new o13(), this.multipassGeometry = new s6(), this.clouds = new r8(), this.overlays = [];
  }
  get camera() {
    return this._camera;
  }
  set camera(s15) {
    this._camera = this.ssr.camera = s15, this._inverseViewport[0] = 1 / s15.fullViewport[2], this._inverseViewport[1] = 1 / s15.fullViewport[3];
  }
  get inverseViewport() {
    return this._inverseViewport;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/RenderContext.js
var n15 = class {
  constructor(t18, n18, c12, l12 = null) {
    this.rctx = t18, this.sliceHelper = l12, this.lastFrameCamera = new K(), this.pass = A2.MATERIAL, this.renderOccludedMask = i11, this.bindParameters = new h6(n18, c12, r(l12) ? l12.plane : null);
  }
  resetRenderOccludedMask() {
    this.renderOccludedMask = i11;
  }
  get isHighlightPass() {
    return this.pass === A2.MATERIAL_HIGHLIGHT;
  }
};
var c9 = class extends n15 {
  constructor(e16, s15, r15, t18, a8) {
    super(e16, r15, t18, a8), this.offscreenRenderingHelper = s15, this.sliceHelper = a8;
  }
};
var i11 = h4.Occlude | h4.OccludeAndTransparent | h4.OccludeAndTransparentStencil;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ChangeSet.js
var r10 = class {
  constructor() {
    this.adds = new n(), this.removes = new n(), this.updates = new n({ allocator: (e16) => e16 || new s10(), deallocator: (e16) => (e16.renderGeometry = null, e16) });
  }
  clear() {
    this.adds.clear(), this.removes.clear(), this.updates.clear();
  }
  prune() {
    this.adds.prune(), this.removes.prune(), this.updates.prune();
  }
};
var s10 = class {
};
var t14 = class {
  constructor() {
    this.adds = new Array(), this.removes = new Array(), this.updates = new Array();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/rendererUtils.js
function r11(r15) {
  const n18 = /* @__PURE__ */ new Map(), a8 = (r16) => {
    let t18 = n18.get(r16);
    return t18 || (t18 = new t14(), n18.set(r16, t18)), t18;
  };
  return r15.removes.forAll((e16) => {
    t15(e16) && a8(e16.material).removes.push(e16);
  }), r15.adds.forAll((e16) => {
    t15(e16) && a8(e16.material).adds.push(e16);
  }), r15.updates.forAll((e16) => {
    t15(e16.renderGeometry) && a8(e16.renderGeometry.material).updates.push(e16);
  }), n18;
}
function t15(e16) {
  return e16.data.indexCount >= 1;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DrawParameters.js
var i12 = class extends c6 {
  constructor(s15 = n6()) {
    super(), this.origin = s15, this.slicePlaneLocalOrigin = this.origin;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/AnimationTimer.js
var i13 = class {
  constructor() {
    this.enabled = true, this._time = 0;
  }
  get time() {
    return n2(this._time);
  }
  advance(t18) {
    return r(t18.forcedTime) ? this._time !== t18.forcedTime && (this._time = t18.forcedTime, true) : !(!this.enabled || 0 === t18.dt) && (this._time += t18.dt, true);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/WaterTechnique.js
var S2 = class extends e7 {
  constructor(e16, t18, o20) {
    super(e16, t18, o20), this._textureRepository = e16.waterTextureRepository;
  }
  initializeConfiguration(e16, o20) {
    o20.spherical = e16.viewingMode === l3.Global, o20.doublePrecisionRequiresObfuscation = r6(e16.rctx);
  }
  initializeProgram(e16) {
    const t18 = S2.shader.get().build(this.configuration);
    return new o11(e16.rctx, t18, E3);
  }
  bindPass(e16, t18) {
    this.program.bindPass(e16, t18), this.configuration.output !== o9.Color && this.configuration.output !== o9.Normal || this._textureRepository.bind(this.program);
  }
  _setPipelineState(e16) {
    const t18 = this.configuration, r15 = e16 === O2.NONE, i16 = e16 === O2.FrontFace;
    return W({ blending: t18.output !== o9.Normal && t18.output !== o9.Highlight && t18.transparent ? r15 ? c5 : E4(e16) : null, depthTest: { func: l7(e16) }, depthWrite: r15 ? t18.writeDepth && a5 : S(e16), colorWrite: c4, polygonOffset: r15 || i16 ? null : i3(t18.enableOffset) });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
S2.shader = new t5(_4, () => import("./WaterSurface.glsl-KKWXUO7J.js"));
var T3 = class extends i6 {
  constructor() {
    super(...arguments), this.output = o9.Color, this.transparencyPassType = O2.NONE, this.spherical = false, this.receiveShadows = false, this.hasSlicePlane = false, this.transparent = false, this.enableOffset = true, this.writeDepth = false, this.hasScreenSpaceReflections = false, this.doublePrecisionRequiresObfuscation = false, this.hasCloudsReflections = false, this.isDraped = false, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([e10({ count: o9.COUNT })], T3.prototype, "output", void 0), e([e10({ count: O2.COUNT })], T3.prototype, "transparencyPassType", void 0), e([e10()], T3.prototype, "spherical", void 0), e([e10()], T3.prototype, "receiveShadows", void 0), e([e10()], T3.prototype, "hasSlicePlane", void 0), e([e10()], T3.prototype, "transparent", void 0), e([e10()], T3.prototype, "enableOffset", void 0), e([e10()], T3.prototype, "writeDepth", void 0), e([e10()], T3.prototype, "hasScreenSpaceReflections", void 0), e([e10()], T3.prototype, "doublePrecisionRequiresObfuscation", void 0), e([e10()], T3.prototype, "hasCloudsReflections", void 0), e([e10()], T3.prototype, "isDraped", void 0), e([e10()], T3.prototype, "hasMultipassTerrain", void 0), e([e10()], T3.prototype, "cullAboveGround", void 0), e([e10({ constValue: l4.Water })], T3.prototype, "pbrMode", void 0), e([e10({ constValue: true })], T3.prototype, "useCustomDTRExponentForWater", void 0), e([e10({ constValue: true })], T3.prototype, "highStepCount", void 0), e([e10({ constValue: false })], T3.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/WaterGLMaterial.js
var o18 = class extends t4 {
  _updateShadowState(e16) {
    e16.shadowMap.enabled !== this._material.parameters.receiveShadows && this._material.setParameters({ receiveShadows: e16.shadowMap.enabled });
  }
  _updateSSRState(e16) {
    e16.ssr.enabled !== this._material.parameters.hasScreenSpaceReflections && this._material.setParameters({ hasScreenSpaceReflections: e16.ssr.enabled });
  }
  _updateCloudsReflectionState(t18) {
    const a8 = r(t18.clouds.data);
    a8 !== this._material.parameters.hasCloudsReflections && this._material.setParameters({ hasCloudsReflections: a8 });
  }
  ensureResources(e16) {
    const t18 = this._techniqueRepository.constructionContext.waterTextureRepository;
    return t18.resourceState === i2.NOT_LOADED && t18.loadTextures(e16), t18.resourceState;
  }
  beginSlot(e16) {
    return this._output === o9.Color && (this._updateShadowState(e16), this._updateSSRState(e16), this._updateCloudsReflectionState(e16)), this.ensureTechnique(S2, e16);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/WaterMaterial.js
var d3 = class extends d2 {
  constructor(e16) {
    super(e16, new A4()), this._techniqueConfig = new T3(), this.animation = new i13();
  }
  getConfiguration(e16, t18) {
    return this._techniqueConfig.output = e16, this._techniqueConfig.writeDepth = this.parameters.writeDepth, this._techniqueConfig.receiveShadows = this.parameters.receiveShadows, this._techniqueConfig.hasSlicePlane = this.parameters.hasSlicePlane, this._techniqueConfig.transparent = this.parameters.transparent, this._techniqueConfig.hasScreenSpaceReflections = this.parameters.hasScreenSpaceReflections, this._techniqueConfig.hasCloudsReflections = this.parameters.hasCloudsReflections, this._techniqueConfig.isDraped = this.parameters.isDraped, this._techniqueConfig.transparencyPassType = t18.transparencyPassType, this._techniqueConfig.enableOffset = t18.camera.relativeElevation < _3, this._techniqueConfig.hasMultipassTerrain = t18.multipassTerrain.enabled, this._techniqueConfig.cullAboveGround = t18.multipassTerrain.cullAboveGround, this._techniqueConfig;
  }
  update(t18) {
    const i16 = Math.min(t18.camera.relativeElevation, t18.camera.distance);
    this.animation.enabled = Math.sqrt(this.parameters.waveTextureRepeat / this.parameters.waveStrength) * i16 < R2;
    const r15 = this.animation.advance(t18);
    return this.setParameters({ timeElapsed: u(this.animation.time) * this.parameters.animationSpeed }, false), this.animation.enabled && r15;
  }
  intersect(e16, t18, i16, r15, s15, a8, n18) {
    x4(e16, t18, r15, s15, a8, void 0, n18);
  }
  requiresSlot(e16, t18) {
    switch (i7(t18)) {
      case o9.Normal:
        return e16 === E5.DRAPED_WATER;
      case o9.Color:
        if (this.parameters.isDraped)
          return e16 === E5.DRAPED_MATERIAL;
        break;
      case o9.Highlight:
        return e16 === E5.OPAQUE_MATERIAL || e16 === E5.DRAPED_MATERIAL;
    }
    let i16 = E5.OPAQUE_MATERIAL;
    return this.parameters.transparent && (i16 = this.parameters.writeDepth ? E5.TRANSPARENT_MATERIAL : E5.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL), e16 === i16;
  }
  createGLMaterial(e16) {
    if (e16.output === o9.Color && this.parameters.isDraped)
      return e16.output = o9.Draped, new o18(e16);
    switch (e16.output) {
      case o9.Color:
      case o9.Normal:
      case o9.Highlight:
      case o9.Alpha:
        return new o18(e16);
    }
    return null;
  }
  createBufferWriter() {
    return new i8(o14);
  }
};
var A4 = class extends o10 {
  constructor() {
    super(...arguments), this.waveStrength = 0.06, this.waveTextureRepeat = 32, this.waveDirection = r5(1, 0), this.waveVelocity = 0.05, this.flowStrength = 0.015, this.flowOffset = -0.5, this.animationSpeed = 0.35, this.timeElapsed = 0, this.color = r4(0, 0, 0, 0), this.transparent = true, this.writeDepth = true, this.hasSlicePlane = false, this.isDraped = false, this.receiveShadows = true, this.hasScreenSpaceReflections = false, this.hasCloudsReflections = false;
  }
};
var R2 = 35e3;

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/Instance.js
var t16 = class {
  constructor(t18) {
    this.first = t18.from, this.count = t18.to - t18.from;
  }
};
var s11 = class {
  constructor(t18 = 0, s15 = 0) {
    this.from = t18, this.to = s15;
  }
};
var o19 = class extends s11 {
  constructor(t18, s15, o20, r15, n18, i16) {
    super(s15, o20), this.id = t18, this.isVisible = r15, this.hasHighlights = n18, this.hasOccludees = i16;
  }
};
function r12(t18) {
  return Array.from(t18.values()).sort(n16);
}
function n16(t18, s15) {
  return t18.from === s15.from ? t18.to - s15.to : t18.from - s15.from;
}
function i14(s15, o20) {
  if (0 === s15.length)
    return void s15.push(new t16(o20));
  const r15 = s15[s15.length - 1];
  if (c10(r15, o20)) {
    const t18 = o20.from - r15.first + o20.to - o20.from;
    r15.count = t18;
  } else
    s15.push(new t16(o20));
}
function c10(t18, s15) {
  return t18.first + t18.count >= s15.from;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/MergedGeometryBuffer.js
var e15 = class {
  constructor(e16, r15) {
    this._pool = e16, this._size = 0, this._buffer = e16.newBuffer(s12(r15));
  }
  dispose() {
    this._buffer = this._pool.deleteBuffer(this._buffer), this._size = 0;
  }
  release() {
    this.erase(0, this._size), this.dispose();
  }
  get vao() {
    return this._buffer.vao;
  }
  get array() {
    return this._buffer.array;
  }
  get size() {
    return this._size;
  }
  grow(e16) {
    this._resize(this._size + e16, true).dispose();
  }
  alloc(e16) {
    return this._resize(e16, false);
  }
  _resize(e16, r15) {
    let s15;
    const i16 = t17(this._buffer.length, this._size, e16);
    if (this._buffer.length !== i16) {
      const e17 = this._pool.newBuffer(i16);
      r15 && (e17.array.set(this._buffer.array.subarray(0, Math.min(this._size, i16))), e17.vao.vertexBuffers.geometry.setSubData(e17.array, 0, 0, e17.array.byteLength)), s15 = this._buffer, this._buffer = e17;
    }
    const f5 = this._size;
    return this._size = e16, s15 ? { dispose: () => {
      s15.array.fill(0, 0, f5), this._pool.deleteBuffer(s15);
    }, copy: (e17, r16, t18) => this._buffer.array.set(s15.array.subarray(r16, t18), e17), hasNewBuffer: true } : { dispose: () => {
    }, copy: (e17, r16, s16) => {
      e17 !== r16 && this._buffer.array.copyWithin(e17, r16, s16);
    }, hasNewBuffer: false };
  }
  erase(e16, r15) {
    this._buffer.array.fill(0, e16, r15);
  }
};
var r13 = 65536;
function s12(e16) {
  return Math.ceil(e16 / r13) * r13;
}
function t17(e16, r15, t18) {
  return r15 <= t18 ? e16 >= t18 ? e16 : s12(Math.max(2 * e16, t18)) : e16 <= 2 * t18 ? e16 : s12(t18);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/StaticFloat32ArrayObject.js
var s13 = class {
  constructor(s15, o20, a8, i16) {
    this.vao = new f(s15, o20, { geometry: a8 }, { geometry: c3.createVertex(s15, F.STATIC_DRAW) }), this.array = new Float32Array(i16), this.vao.vertexBuffers.geometry.setSize(this.array.byteLength);
  }
  dispose() {
    this.vao.dispose(true);
  }
  get length() {
    return this.array.length;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/MergedGeometryBufferPool.js
var s14 = s4 + 1;
var h7 = class {
  constructor(t18, e16, r15) {
    this._rctx = t18, this._locations = e16, this._layout = r15, this._cache = t18.newCache(`MergedRenderer pool ${e3()}`, i15);
  }
  dispose() {
    this._cache.destroy();
  }
  newBuffer(e16) {
    const r15 = e16.toString(), o20 = this._cache.pop(r15);
    if (r(o20)) {
      const t18 = o20.pop();
      return o20.length > 0 && this._cache.put(r15, o20, t18.array.byteLength * o20.length, s14), t18;
    }
    return new s13(this._rctx, this._locations, this._layout, e16);
  }
  deleteBuffer(e16) {
    const r15 = e16.array.byteLength, o20 = e16.array.length.toString(), c12 = this._cache.pop(o20);
    return r(c12) ? (c12.push(e16), this._cache.put(o20, c12, r15 * c12.length, -1)) : this._cache.put(o20, [e16], r15, -1), null;
  }
};
function i15(t18, r15) {
  if (r15 === i.ALL)
    return void t18.forEach((t19) => t19.dispose());
  const o20 = t18.pop(), c12 = t18.length * o20.array.byteLength;
  return o20.dispose(), c12;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/MergedRenderer.js
var A5 = class {
  constructor(e16, t18, r15) {
    this._rctx = e16, this._materialRepository = t18, this._material = r15, this.type = "MergedRenderer", this._dataByOrigin = /* @__PURE__ */ new Map(), this._renderCommandData = new n(), this._hasHighlights = false, this._hasOccludees = false, this._glMaterials = new a6(this._material, this._materialRepository), this._bufferWriter = r15.createBufferWriter(), this._bufferPool = new h7(e16, r15.vertexAttributeLocations, o5(this._bufferWriter.vertexBufferLayout));
  }
  dispose() {
    this._glMaterials.destroy(), this._dataByOrigin.forEach((e16) => e16.buffer.dispose()), this._dataByOrigin.clear(), this._bufferPool.dispose();
  }
  get isEmpty() {
    return 0 === this._dataByOrigin.size;
  }
  get hasHighlights() {
    return this._hasHighlights;
  }
  get hasOccludees() {
    return this._hasOccludees;
  }
  get hasWater() {
    return !this.isEmpty && this._material instanceof d3;
  }
  get rendersOccluded() {
    return !this.isEmpty && this._material.renderOccluded !== h4.Occlude;
  }
  modify(e16) {
    this._updateGeometries(e16.updates), this._addAndRemoveGeometries(e16.adds, e16.removes), this._updateRenderCommands();
  }
  _addAndRemoveGeometries(e16, t18) {
    const r15 = this._bufferWriter, s15 = r15.vertexBufferLayout.stride / 4, i16 = this._dataByOrigin, a8 = R3(e16, t18);
    a8.forEach((e17, t19) => {
      a8.delete(t19);
      const o20 = e17.toAdd.reduce((e18, t20) => e18 + r15.elementCount(t20.data), 0);
      let n18 = i16.get(t19);
      if (null == n18)
        e6(0 === e17.toRemove.length), n18 = new D3(e17.origin, new e15(this._bufferPool, o20 * s15)), i16.set(t19, n18);
      else if (0 === e17.toAdd.length && n18.instances.size === e17.toRemove.length)
        return n18.buffer.dispose(), void i16.delete(t19);
      let d4 = 0;
      n18.instances.forEach((e18) => d4 += e18.to - e18.from);
      const h8 = e17.toRemove.reduce((e18, t20) => e18 + r15.elementCount(t20.data), 0), l12 = n18.buffer.size, m3 = (d4 + o20 - h8) * s15, f5 = T4;
      if (m3 < l12 / 2 ? this._removeAndRebuild(n18, e17.toRemove, s15, m3, f5) : e17.toRemove.length > 0 && this._remove(n18, e17.toRemove, s15, f5), e17.toAdd.length > 0) {
        const t20 = L5;
        h3(t20, -e17.origin[0], -e17.origin[1], -e17.origin[2]), this._add(n18, e17.toAdd, s15, t20, f5);
      }
      const g4 = n18.buffer.vao.vertexBuffers.geometry;
      B2(f5), f5.forAll(({ from: e18, to: t20 }) => {
        if (e18 < t20) {
          const r16 = n18.buffer.array, s16 = 4, i17 = e18 * s16, a9 = t20 * s16;
          g4.setSubData(r16, i17, i17, a9);
        }
      }), f5.clear(), n18.drawCommandsDirty = true;
    });
  }
  _updateGeometries(e16) {
    const t18 = this._bufferWriter, r15 = t18.vertexBufferLayout.stride / 4;
    for (const s15 of e16) {
      const e17 = s15.renderGeometry, i16 = this._dataByOrigin.get(e17.origin.id), a8 = i16 && i16.instances.get(e17.id);
      if (!a8)
        return;
      const o20 = s15.updateType;
      if (o20 & E6.State.VISIBILITIES && (a8.isVisible = e17.instanceParameters.visible), o20 & (E6.State.HIGHLIGHTS | E6.State.VISIBILITIES)) {
        const t19 = e17.instanceParameters.visible;
        a8.hasHighlights = !!e17.instanceParameters.highlights && t19;
      }
      if (o20 & E6.State.OCCLUDEES && (a8.hasOccludees = !!e17.instanceParameters.occludees), o20 & (E6.State.VERTEXATTRS | E6.State.TRANSFORMATION)) {
        const { array: s16, vao: o21 } = i16.buffer;
        l5(e17, P4, j3), t18.write({ transformation: P4, invTranspTransformation: j3 }, e17.data, t18.vertexBufferLayout.createView(s16.buffer), a8.from), e6(a8.from + t18.elementCount(e17.data) === a8.to, "material VBO layout has changed"), o21.vertexBuffers.geometry.setSubData(s16, a8.from * r15 * 4, a8.from * r15 * 4, a8.to * r15 * 4);
      }
      i16.drawCommandsDirty = true;
    }
  }
  _updateRenderCommands() {
    this._hasHighlights = false, this._hasOccludees = false, this._dataByOrigin.forEach((t19) => {
      t19.hasHiddenInstances = false, t19.hasHighlights = false, t19.hasOccludees = false, n4(t19.instances, (e16) => (e16.isVisible ? (e16.hasHighlights && (this._hasHighlights = true, t19.hasHighlights = true), e16.hasOccludees && (this._hasOccludees = true, t19.hasOccludees = true)) : t19.hasHiddenInstances = true, t19.hasHiddenInstances && t19.hasHighlights && t19.hasOccludees));
    });
    const t18 = (e16) => {
      if (e16.drawCommandsDefault = null, e16.drawCommandsHighlight = null, e16.drawCommandsOccludees = null, e16.drawCommandsShadowHighlightRest = null, 0 === e16.instances.size)
        return;
      if (!I2(e16)) {
        const t20 = this._bufferWriter.vertexBufferLayout.stride, r15 = 4 * e16.buffer.size / t20;
        return void (e16.drawCommandsDefault = [{ first: 0, count: r15 }]);
      }
      const t19 = r12(e16.instances);
      e16.drawCommandsDefault = [], e16.drawCommandsHighlight = [], e16.drawCommandsOccludees = [], e16.drawCommandsShadowHighlightRest = [];
      for (const r15 of t19)
        r15.isVisible && (r15.hasOccludees ? i14(e16.drawCommandsOccludees, r15) : i14(e16.drawCommandsDefault, r15), r15.hasHighlights ? i14(e16.drawCommandsHighlight, r15) : i14(e16.drawCommandsShadowHighlightRest, r15));
    };
    this._dataByOrigin.forEach((e16) => {
      e16.drawCommandsDirty && (t18(e16), e16.drawCommandsDirty = false);
    });
  }
  updateAnimation(e16) {
    return this._material.update(e16);
  }
  requiresSlot(e16, t18) {
    return null == e16 || this._material.requiresSlot(e16, t18);
  }
  render(e16, s15) {
    if (!this.requiresSlot(s15.slot, e16))
      return false;
    const i16 = e16 === A2.MATERIAL_HIGHLIGHT || e16 === A2.MATERIAL_DEPTH_SHADOWMAP_HIGHLIGHT;
    if (i16 && !this._hasHighlights)
      return false;
    const a8 = e16 === A2.MATERIAL_DEPTH_SHADOWMAP_DEFAULT, o20 = !(i16 || a8);
    if (this._dataByOrigin.forEach((e17) => {
      if (i16 && !e17.hasHighlights)
        return;
      const r15 = (i16 ? e17.drawCommandsHighlight : a8 && I2(e17) ? e17.drawCommandsShadowHighlightRest : e17.drawCommandsDefault) || null, s16 = o20 && e17.drawCommandsOccludees || null;
      (r(r15) || r(s16)) && this._renderCommandData.push(new M3(e17.origin, e17.buffer, r15, s16));
    }), 0 === this._renderCommandData.length)
      return false;
    const n18 = this._rctx, d4 = this._glMaterials.load(n18, e16);
    if (t(d4))
      return this._renderCommandData.clear(), false;
    const h8 = d4.beginSlot(s15);
    return n18.bindTechnique(h8, this._material.parameters, s15, false), this._renderCommandData.forAll((e17) => {
      h8.bindDraw(e17, s15);
      const { buffer: r15, renderCommands: i17, occludeeCommands: a9 } = e17;
      h8.ensureAttributeLocations(r15.vao), n18.bindVAO(r15.vao);
      const o21 = h8.primitiveType;
      r(i17) && this._renderCommands(n18, o21, i17), r(a9) && (h8.bindPipelineState(n18, s15.slot, true), this._renderCommands(n18, o21, a9), h8.bindPipelineState(n18, s15.slot, false));
    }), this._renderCommandData.clear(), true;
  }
  _renderCommands(e16, t18, r15) {
    for (let s15 = 0; s15 < r15.length; s15++)
      e16.drawArrays(t18, r15[s15].first, r15[s15].count);
  }
  _removeAndRebuild(e16, t18, r15, s15, i16) {
    for (const h8 of t18)
      e16.instances.delete(h8.id);
    const a8 = r12(e16.instances);
    e16.instances.clear();
    const o20 = e16.buffer.size, n18 = e16.buffer.alloc(s15);
    let d4 = 0;
    for (const h8 of a8) {
      const t19 = h8.from * r15, s16 = h8.to * r15;
      n18.copy(d4, t19, s16), h8.from = d4 / r15, d4 += s16 - t19, h8.to = d4 / r15, e16.instances.set(h8.id, h8);
    }
    i16.push(new s11(0, n18.hasNewBuffer ? e16.buffer.array.length : o20)), n18.dispose(), e16.buffer.erase(d4, i16.back().to), e16.holes.clear();
  }
  _remove(e16, t18, r15, s15) {
    for (const i16 of t18) {
      const t19 = i16.id, a8 = e16.instances.get(t19), o20 = a8.from * r15, n18 = a8.to * r15;
      e16.buffer.erase(o20, n18), e16.holes.push(new s11(a8.from, a8.to)), e16.instances.delete(t19), s15.push(new s11(o20, n18));
    }
    B2(e16.holes);
  }
  _add(e16, s15, n18, d4, h8) {
    if (0 === s15.length)
      return;
    const l12 = this._bufferWriter;
    let m3 = l12.vertexBufferLayout.createView(e16.buffer.array.buffer);
    const f5 = e16.holes.length > 0;
    let u12 = Number.MAX_SAFE_INTEGER, g4 = Number.MIN_SAFE_INTEGER;
    for (const _5 of s15) {
      const s16 = r(_5.transformation) ? u4(P4, d4, _5.transformation) : d4;
      h(j3, s16);
      const p6 = o4(j3, j3), y3 = l12.elementCount(_5.data), C = y3 * n18;
      let H3 = E7(e16.holes, y3);
      t(H3) && (H3 = e16.buffer.size / n18, e16.buffer.grow(C), m3 = l12.vertexBufferLayout.createView(e16.buffer.array.buffer)), l12.write({ transformation: s16, invTranspTransformation: p6 }, _5.data, m3, H3);
      const v3 = _5.instanceParameters.visible, A6 = !!_5.instanceParameters.highlights && v3, O5 = !!_5.instanceParameters.occludees, R5 = new o19(_5.id, H3, H3 + y3, v3, A6, O5);
      e6(null == e16.instances.get(_5.id)), e16.instances.set(_5.id, R5), f5 ? h8.push(new s11(R5.from * n18, R5.to * n18)) : (u12 = Math.min(R5.from, u12), g4 = Math.max(R5.to, g4));
    }
    f5 || h8.push(new s11(u12 * n18, g4 * n18));
  }
  get test() {
    return { material: this._material, glMaterials: this._glMaterials, dataByOrigin: this._dataByOrigin };
  }
};
var O4 = class {
  constructor(e16) {
    this.origin = e16, this.toAdd = new Array(), this.toRemove = new Array();
  }
};
function R3(e16, t18) {
  const r15 = /* @__PURE__ */ new Map();
  for (const s15 of e16)
    S3(r15, s15, true);
  for (const s15 of t18)
    S3(r15, s15, false);
  return r15;
}
function S3(e16, t18, s15) {
  const i16 = t18.origin;
  if (t(i16))
    return;
  let a8 = e16.get(i16.id);
  null == a8 && (a8 = new O4(i16.vec3), e16.set(i16.id, a8)), s15 ? a8.toAdd.push(t18) : a8.toRemove.push(t18);
}
function I2(e16) {
  return e16.hasOccludees || e16.hasHighlights || e16.hasHiddenInstances;
}
function E7(e16, t18) {
  let r15;
  if (!e16.some((e17) => !(e17.to - e17.from < t18) && (r15 = e17, true)))
    return null;
  const s15 = r15.from;
  return r15.from += t18, r15.from >= r15.to && e16.removeUnordered(r15), s15;
}
function B2(e16) {
  const t18 = /* @__PURE__ */ new Map();
  e16.forAll((e17) => t18.set(e17.from, e17));
  let r15 = true;
  for (; r15; )
    r15 = false, e16.forEach((s15) => {
      const i16 = t18.get(s15.to);
      i16 && (s15.to = i16.to, t18.delete(i16.from), e16.removeUnordered(i16), r15 = true);
    });
}
var D3 = class {
  constructor(e16, t18) {
    this.origin = e16, this.buffer = t18, this.instances = /* @__PURE__ */ new Map(), this.holes = new n({ deallocator: null }), this.hasHiddenInstances = false, this.hasHighlights = false, this.hasOccludees = false, this.drawCommandsDirty = false;
  }
};
var M3 = class extends i12 {
  constructor(e16, t18, r15, s15) {
    super(e16), this.buffer = t18, this.renderCommands = r15, this.occludeeCommands = s15;
  }
};
var T4 = new n({ deallocator: null });
var L5 = e5();
var P4 = e5();
var j3 = e5();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SortedRenderGeometryRenderer.js
var y2 = class extends y {
  constructor(e16) {
    super(e16), this._pending = new f4(), this._changes = new r10(), this._materialRenderers = /* @__PURE__ */ new Map(), this._sortedMaterialRenderers = new n(), this._geometries = /* @__PURE__ */ new Map(), this._hasHighlights = false, this._hasWater = false;
  }
  destroy() {
    this._changes.prune(), this._materialRenderers.forEach((e16) => e16.dispose()), this._materialRenderers.clear(), this._sortedMaterialRenderers.clear(), this._geometries.clear();
  }
  get updating() {
    return !this._pending.empty || this._changes.updates.length > 0;
  }
  get rctx() {
    return this.rendererContext.rctx;
  }
  get _materialRepository() {
    return this.rendererContext.materialRepository;
  }
  get _localOriginFactory() {
    return this.rendererContext.localOriginFactory;
  }
  get hasHighlights() {
    return this._hasHighlights;
  }
  get hasWater() {
    return this._hasWater;
  }
  get rendersOccluded() {
    return n4(this._materialRenderers, (e16) => e16.rendersOccluded);
  }
  get isEmpty() {
    return !this.updating && 0 === this._materialRenderers.size && 0 === this._geometries.size;
  }
  commitChanges() {
    if (!this.updating)
      return false;
    this._processAddsRemoves();
    const e16 = r11(this._changes);
    let r15 = false, s15 = false, i16 = false;
    return e16.forEach((e17, t18) => {
      let a8 = this._materialRenderers.get(t18);
      if (!a8 && e17.adds.length > 0 && (a8 = new A5(this.rctx, this._materialRepository, t18), this._materialRenderers.set(t18, a8), r15 = true, s15 = true, i16 = true), !a8)
        return;
      const n18 = s15 || a8.hasHighlights, o20 = i16 || a8.hasWater;
      a8.modify(e17), s15 = s15 || n18 !== a8.hasHighlights, i16 = i16 || o20 !== a8.hasWater, a8.isEmpty && (this._materialRenderers.delete(t18), a8.dispose(), r15 = true);
    }), this._changes.clear(), r15 && this._updateSortedMaterialRenderers(), s15 && (this._hasHighlights = n4(this._materialRenderers, (e17) => e17.hasHighlights)), i16 && (this._hasWater = n4(this._materialRenderers, (e17) => e17.hasWater)), this.notifyChange("updating"), true;
  }
  addGeometries(e16, r15) {
    if (0 === e16.length)
      return;
    const t18 = this._validateRenderGeometries(e16);
    for (const i16 of t18)
      this._geometries.set(i16.id, i16);
    const s15 = this._pending.empty;
    for (const i16 of t18)
      this._pending.adds.add(i16);
    s15 && this.notifyChange("updating"), r15 === E6.Geometry.UPDATE && this._notifyGraphicGeometryChanged(e16);
  }
  removeGeometries(e16, r15) {
    const t18 = this._pending.empty, i16 = this._pending.adds;
    for (const a8 of e16)
      i16.has(a8) ? (this._pending.removed.add(a8), i16.delete(a8)) : this._pending.removed.has(a8) || this._pending.removes.add(a8), this._geometries.delete(e2(a8.id));
    t18 && !this._pending.empty && this.notifyChange("updating"), r15 === E6.Geometry.UPDATE && this._notifyGraphicGeometryChanged(e16);
  }
  modifyGeometries(e16, r15) {
    const t18 = 0 === this._changes.updates.length;
    for (const s15 of e16) {
      const e17 = this._changes.updates.pushNew();
      e17.renderGeometry = this._validateRenderGeometry(s15), e17.updateType = r15;
    }
    switch (t18 && this._changes.updates.length > 0 && this.notifyChange("updating"), r15) {
      case E6.State.TRANSFORMATION:
      case E6.State.VERTEXATTRS:
        return this._notifyGraphicGeometryChanged(e16);
      case E6.State.VISIBILITIES:
        return this._notifyGraphicVisibilityChanged(e16);
    }
  }
  updateAnimation(e16) {
    let r15 = false;
    return this._sortedMaterialRenderers.forAll(({ materialRenderer: t18 }) => r15 = t18.updateAnimation(e16) || r15), r15;
  }
  render(e16, r15) {
    for (let t18 = 0; t18 < this._sortedMaterialRenderers.length; t18++) {
      const s15 = this._sortedMaterialRenderers.data[t18];
      s15.material.shouldRender(e16) && s15.materialRenderer.render(e16.pass, r15);
    }
  }
  intersect(e16, r15, t18, s15, i16) {
    return this._geometries.forEach((a8) => {
      if (s15 && !s15(a8))
        return;
      this._intersectRenderGeometry(a8, t18, r15, 0, e16, i16);
      const n18 = this.rendererContext.longitudeCyclical;
      n18 && (a8.boundingSphere[0] - a8.boundingSphere[3] < n18.min && this._intersectRenderGeometry(a8, t18, r15, n18.range, e16, i16), a8.boundingSphere[0] + a8.boundingSphere[3] > n18.max && this._intersectRenderGeometry(a8, t18, r15, -n18.range, e16, i16)), i16++;
    }), i16;
  }
  _updateSortedMaterialRenderers() {
    this._sortedMaterialRenderers.clear();
    let e16 = 0;
    this._materialRenderers.forEach((r15, t18) => {
      t18.insertOrder = e16++, this._sortedMaterialRenderers.push({ material: t18, materialRenderer: r15 });
    }), this._sortedMaterialRenderers.sort((e17, r15) => {
      const t18 = r15.material.renderPriority - e17.material.renderPriority;
      return 0 !== t18 ? t18 : e17.material.insertOrder - r15.material.insertOrder;
    });
  }
  _processAddsRemoves() {
    this._changes.adds.clear(), this._changes.removes.clear(), this._changes.adds.pushArray(Array.from(this._pending.adds)), this._changes.removes.pushArray(Array.from(this._pending.removes));
    for (let e16 = 0; e16 < this._changes.updates.length; ) {
      const r15 = this._changes.updates.data[e16];
      this._pending.has(r15.renderGeometry) ? this._changes.updates.removeUnorderedIndex(e16) : e16++;
    }
    this._pending.clear();
  }
  _intersectRenderGeometry(e16, r15, t18, s15, a8, n18) {
    if (!e16.instanceParameters.visible)
      return;
    let o20 = 0;
    r(e16.transformation) && (s15 += e16.transformation[12], o20 = e16.transformation[13]), G2[0] = t18[0] - s15, G2[1] = t18[1] - o20, G2[2] = 1, S4[0] = t18[0] - s15, S4[1] = t18[1] - o20, S4[2] = 0, e16.screenToWorldRatio = this.rendererContext.screenToWorldRatio, e16.material.intersect(e16, null, e16.getShaderTransformation(), a8, G2, S4, (t19, s16, i16) => {
      R4(r15, i16, e16.material.renderPriority, n18, a8, e16.layerUid, e16.graphicUid);
    }, e16.calculateShaderTransformation, r15);
  }
  _notifyGraphicGeometryChanged(e16) {
    if (t(this.drapeSource.notifyGraphicGeometryChanged))
      return;
    let r15;
    for (const t18 of e16) {
      const e17 = t18.graphicUid;
      r(e17) && e17 !== r15 && (this.drapeSource.notifyGraphicGeometryChanged(e17), r15 = e17);
    }
  }
  _notifyGraphicVisibilityChanged(e16) {
    if (t(this.drapeSource.notifyGraphicVisibilityChanged))
      return;
    let r15;
    for (const t18 of e16) {
      const e17 = t18.graphicUid;
      r(e17) && e17 !== r15 && (this.drapeSource.notifyGraphicVisibilityChanged(e17), r15 = e17);
    }
  }
  _validateRenderGeometries(e16) {
    for (const r15 of e16)
      this._validateRenderGeometry(r15);
    return e16;
  }
  _validateRenderGeometry(e16) {
    return t(e16.origin) && (e16.origin = this._localOriginFactory.getOrigin(e16.boundingSphere)), e16;
  }
  get test() {
    return { sortedMaterialRenderers: this._sortedMaterialRenderers };
  }
};
e([d()], y2.prototype, "drapeSource", void 0), e([d()], y2.prototype, "updating", null), e([d()], y2.prototype, "rctx", null), e([d()], y2.prototype, "rendererContext", void 0), e([d()], y2.prototype, "_materialRepository", null), e([d()], y2.prototype, "_localOriginFactory", null), y2 = e([n5("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")], y2);
var f4 = class {
  constructor() {
    this.adds = /* @__PURE__ */ new Set(), this.removes = /* @__PURE__ */ new Set(), this.removed = /* @__PURE__ */ new Set();
  }
  get empty() {
    return 0 === this.adds.size && 0 === this.removes.size && 0 === this.removed.size;
  }
  has(e16) {
    return this.adds.has(e16) || this.removes.has(e16) || this.removed.has(e16);
  }
  clear() {
    this.adds.clear(), this.removes.clear(), this.removed.clear();
  }
};
function R4(e16, r15, t18, s15, i16, a8, n18) {
  const o20 = { layerUid: a8, graphicUid: n18, triangleNr: r15 }, d4 = (r16) => {
    r16.set(i9.OVERLAY, o20, e16.dist, e16.normal, e16.transformation, t18, s15);
  };
  if ((null == i16.results.min.drapedLayerOrder || t18 >= i16.results.min.drapedLayerOrder) && (null == i16.results.min.dist || i16.results.ground.dist <= i16.results.min.dist) && d4(i16.results.min), i16.options.store !== t10.MIN && (null == i16.results.max.drapedLayerOrder || t18 < i16.results.max.drapedLayerOrder) && (null == i16.results.max.dist || i16.results.ground.dist > i16.results.max.dist) && d4(i16.results.max), i16.options.store === t10.ALL) {
    const e17 = U(i16.ray);
    d4(e17), i16.results.all.push(e17);
  }
}
var G2 = n6();
var S4 = n6();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SSAOTechnique.js
var n17 = class extends e7 {
  initializeProgram(e16) {
    const r15 = n17.shader.get().build(this.configuration);
    return new o11(e16.rctx, r15, E3);
  }
  initializePipeline() {
    return W({ colorWrite: c4 });
  }
};
n17.shader = new t5(p4, () => import("./SSAO.glsl-Y5XDLLHR.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SSAOHelper.js
var x6 = class {
  constructor(e16, t18, s15) {
    this._techniqueRep = e16, this._rctx = t18, this._requestRender = s15, this._enabled = false, this._ssaoTechniqueConfig = new e12(), this.quadVAO = null, this._blurSizePx = 2, this._attenuation = 0.5;
  }
  dispose() {
    this.quadVAO = s(this.quadVAO);
  }
  disposeOffscreenBuffers() {
    o(this._ssaoFBO, (e16) => e16.resize(0, 0)), o(this._blur0FBO, (e16) => e16.resize(0, 0)), o(this._blur1FBO, (e16) => e16.resize(0, 0));
  }
  set enabled(e16) {
    e16 ? this._enable() : this._disable();
  }
  get enabled() {
    return this._enabled;
  }
  get ready() {
    return this.enabled && r(this._noiseTexture) && r(this._ssaoFBO) && r(this._blur0FBO) && r(this._blur1FBO);
  }
  get colorTexture() {
    return r(this._blur1FBO) ? this._blur1FBO.colorTexture : null;
  }
  get width() {
    return r(this._ssaoFBO) ? this._ssaoFBO.width : -1;
  }
  get height() {
    return r(this._ssaoFBO) ? this._ssaoFBO.height : -1;
  }
  computeSSAO(e16, t18, s15) {
    if (!this.enabled || t(t18) || t(s15) || t(this._noiseTexture) || t(this._ssaoFBO) || t(this._blur0FBO) || t(this._blur1FBO))
      return;
    const h8 = this._rctx, o20 = e16.camera, n18 = o20.fullViewport, a8 = n18[2], _5 = n18[3], b3 = a8 / this._blurSizePx, d4 = _5 / this._blurSizePx;
    this._ssaoFBO.resize(a8, _5), this._blur0FBO.resize(b3, d4), this._blur1FBO.resize(b3, d4);
    const c12 = 1, m3 = 1, O5 = a8 * c12, T5 = _5 * m3;
    h8.bindFramebuffer(this._ssaoFBO), h8.setViewport(0, 0, a8, _5);
    const p6 = h8.bindTechnique(this._ssaoTechnique, g3, e16);
    p6.setUniform2f("rnmScale", a8 / this._noiseTexture.descriptor.width, _5 / this._noiseTexture.descriptor.height);
    let f5 = 1 / o20.computeRenderPixelSizeAtDist(1);
    p6.setUniform1f("projScale", f5 * c12), p6.setUniform2f("screenSize", O5, T5);
    const B3 = x(o20.eye, o20.center);
    let x7 = 20 * o20.computeRenderPixelSizeAtDist(B3);
    x7 = Math.max(0.1, x7), p6.setUniform1f("radius", x7), p6.setUniform1f("intensity", 4 * this._attenuation / x7 ** 6), p6.bindTexture("rnm", this._noiseTexture), p6.bindTexture("normalMap", s15), p6.bindTexture("depthMap", t18), t(this.quadVAO) && (this.quadVAO = u7(this._rctx)), h8.bindVAO(this.quadVAO), h8.drawArrays(E2.TRIANGLE_STRIP, 0, n10(this.quadVAO, "geometry"));
    const q2 = h8.bindTechnique(this._blurTechnique, g3, e16);
    q2.bindTexture("tex", this._ssaoFBO.colorTexture), q2.bindTexture("normalMap", s15), q2.bindTexture("depthMap", t18), h8.setViewport(0, 0, O5 / this._blurSizePx, T5 / this._blurSizePx), h8.bindFramebuffer(this._blur0FBO), q2.setUniform2f("screenSize", O5, T5), q2.setUniform2f("blurSize", 0, this._blurSizePx * c12 / T5), B3 > 5e4 && (f5 = Math.max(0, f5 - (B3 - 5e4))), q2.setUniform1f("projScale", f5), h8.drawArrays(E2.TRIANGLE_STRIP, 0, n10(this.quadVAO, "geometry")), q2.setUniform2f("blurSize", this._blurSizePx * m3 / O5, 0), h8.bindFramebuffer(this._blur1FBO), q2.bindTexture("tex", this._blur0FBO.colorTexture), h8.drawArrays(E2.TRIANGLE_STRIP, 0, n10(this.quadVAO, "geometry")), h8.setViewport(n18[0], n18[1], n18[2], n18[3]);
  }
  _selectPrograms() {
    this._ssaoTechniqueConfig.output = u9.SSAO, this._ssaoTechnique = this._techniqueRep.releaseAndAcquire(n17, this._ssaoTechniqueConfig, this._ssaoTechnique), this._ssaoTechniqueConfig.output = u9.Blur, this._blurTechnique = this._techniqueRep.releaseAndAcquire(n17, this._ssaoTechniqueConfig, this._blurTechnique);
  }
  _enable() {
    this.enabled || (this._enabled = true, this._loadResources(() => {
      this._enabled && this._initialize();
    }));
  }
  _loadResources(e16) {
    this._data ? e16() : import("./SSAOHelperData-QFXUY4WX.js").then((t18) => {
      this._data = t18, e16();
    });
  }
  _initialize() {
    const e16 = { target: M.TEXTURE_2D, pixelFormat: P2.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L3.LINEAR, wrapMode: D.CLAMP_TO_EDGE, width: 0, height: 0 }, t18 = { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE };
    t2(this._data.noiseTexture).then((s15) => {
      this._enabled && (this._ssaoFBO = new D2(this._rctx, t18, e16), this._blur0FBO = new D2(this._rctx, t18, e16), this._blur1FBO = new D2(this._rctx, t18, e16), this._noiseTexture = new u6(this._rctx, { target: M.TEXTURE_2D, pixelFormat: P2.RGBA, dataType: G.UNSIGNED_BYTE, hasMipmap: true, width: s15.width, height: s15.height }, s15), this._requestRender());
    }), this._selectPrograms();
  }
  _disable() {
    this._enabled = false, this._noiseTexture = s(this._noiseTexture), this._blur1FBO = s(this._blur1FBO), this._blur0FBO = s(this._blur0FBO), this._ssaoFBO = s(this._ssaoFBO);
  }
  get gpuMemoryUsage() {
    return (r(this._blur0FBO) ? this._blur0FBO.gpuMemoryUsage : 0) + (r(this._blur1FBO) ? this._blur1FBO.gpuMemoryUsage : 0) + (r(this._ssaoFBO) ? this._ssaoFBO.gpuMemoryUsage : 0);
  }
  get test() {
    return { ssao: this._ssaoFBO, blur: this._blur1FBO };
  }
};
var g3 = new t3();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextureTechnique.js
var m2 = class extends e7 {
  initializeProgram(e16) {
    const r15 = m2.shader.get().build();
    return new o11(e16.rctx, r15, E3);
  }
  initializePipeline() {
    return this.configuration.hasAlpha ? W({ blending: l6(R.SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE_MINUS_SRC_ALPHA), colorWrite: c4 }) : W({ colorWrite: c4 });
  }
};
m2.shader = new t5(t11, () => import("./TextureOnly.glsl-F4YQNGIY.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextureTechniqueConfiguration.js
var r14 = class extends t6 {
  constructor() {
    super(...arguments), this.hasAlpha = false;
  }
};
e([e10()], r14.prototype, "hasAlpha", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/StippleTextureRepository.js
var c11 = class {
  constructor(e16) {
    this._rctx = e16, this.cache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this.cache.forEach((e16) => e16.texture = s(e16.texture)), this.cache.clear();
  }
  _acquire(e16) {
    if (t(e16))
      return null;
    const t18 = this._patternId(e16), i16 = this.cache.get(t18);
    if (i16)
      return i16.refCount++, i16.bind;
    const c12 = e16.pixelRatio, { encodedData: h8, sdfNormalizer: l12, pixels: p6, paddedPixels: d4 } = u11(e16.pattern, c12), f5 = p6 / c12, x7 = { refCount: 1, texture: null, bind: (e17) => (t(x7.texture) && (x7.texture = new u6(this._rctx, { width: d4, height: 1, internalFormat: P2.RGBA, pixelFormat: P2.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D.CLAMP_TO_EDGE }, h8)), e17.bindTexture("stipplePatternTexture", x7.texture), { pixelSize: f5, sdfNormalizer: l12, pixels: p6 }) };
    return this.cache.set(t18, x7), x7.bind;
  }
  release(e16) {
    if (t(e16))
      return;
    const t18 = this._patternId(e16), o20 = this.cache.get(t18);
    o20 && (o20.refCount--, 0 === o20.refCount && (r(o20.texture) && o20.texture.dispose(), this.cache.delete(t18)));
  }
  swap(e16, t18) {
    const r15 = this._acquire(t18);
    return this.release(e16), r15;
  }
  _patternId(e16) {
    return `${e16.pattern.join(",")}-r${e16.pixelRatio}`;
  }
};
function u11(t18, r15) {
  const i16 = t18.map((e16) => Math.round(e16 * r15)), o20 = 1 / r15, a8 = Math.floor(i16.reduce((e16, t19) => e16 + t19)), n18 = i16.reduce((e16, t19) => Math.max(e16, t19)), s15 = (Math.floor(0.5 * (n18 - 1)) + 0.5) * o20, c12 = [];
  let u12 = 1;
  for (const e16 of i16) {
    for (let t19 = 0; t19 < e16; t19++) {
      const r16 = u12 * (Math.min(t19, e16 - 1 - t19) + 0.5) * o20 / s15 * 0.5 + 0.5;
      c12.push(r16);
    }
    u12 = -u12;
  }
  const h8 = Math.round(i16[0] / 2), l12 = [...c12.slice(h8), ...c12.slice(0, h8)], p6 = a8 + 2, d4 = new Uint8Array(4 * p6);
  let f5 = 4;
  for (const x7 of l12)
    o7(x7, d4, f5), f5 += 4;
  return d4.copyWithin(0, f5 - 4, f5), d4.copyWithin(f5, 4, 8), { encodedData: d4, sdfNormalizer: s15, paddedPixels: p6, pixels: a8 };
}

// node_modules/@arcgis/core/views/3d/terrain/OverlayRenderer.js
var he2 = class extends s9(y) {
  constructor(e16) {
    super(e16), this._overlays = null, this._overlayRenderTarget = null, this._hasHighlights = false, this._rendersOccluded = false, this._hasWater = false, this._handles = new u3(), this._frameTask = Q, this._drapeSourceRenderers = /* @__PURE__ */ new Map(), this._sortedDrapeSourceRenderersDirty = false, this._sortedDrapeSourceRenderers = new n(), this._rctx = null, this._materialRepository = null, this._screenToWorldRatio = 1, this._localOriginFactory = null, this.worldToPCSRatio = 1, this.events = new n7(), this.longitudeCyclical = null;
  }
  get _bindParameters() {
    return this._renderContext.bindParameters;
  }
  get rctx() {
    return this._rctx;
  }
  get materialRepository() {
    return this._materialRepository;
  }
  get screenToWorldRatio() {
    return this._screenToWorldRatio;
  }
  get localOriginFactory() {
    return this._localOriginFactory;
  }
  initialize() {
    const e16 = this.view._stage.renderView;
    this._rctx = e16.renderingContext;
    const r15 = e16.waterTextureRepository;
    this._stippleTextureRepository = new c11(e16.renderingContext), this._shaderTechniqueRepository = new s8({ rctx: this._rctx, viewingMode: l3.Local, stippleTextureRepository: this._stippleTextureRepository, waterTextureRepository: r15 }), this._renderContext = new n15(this._rctx, new Q2(this._rctx, this.view.state.viewingMode), new x6(this._shaderTechniqueRepository, this._rctx, () => {
    })), this._handles.add([l(() => r15.updating, () => this.events.emit("content-changed"), w), l(() => this.spatialReference, (e17) => this._localOriginFactory = new j2(e17), w), a2(() => this.view.allLayerViews, "after-changes", () => this._sortedDrapeSourceRenderersDirty = true)]), this._materialRepository = new l11(e16.textureRepository, this._shaderTechniqueRepository, (e17) => {
      (e17.renderOccluded & ge) > 0 !== this._rendersOccluded && this._updateRendersOccluded(), this.events.emit("content-changed"), this.notifyChange("updating");
    }, () => this.events.emit("content-changed")), this._bindParameters.slot = E5.DRAPED_MATERIAL, this._bindParameters.highlightDepthTexture = p2(this._rctx), this._bindParameters.camera = pe2, this._bindParameters.transparencyPassType = O2.NONE, this._bindParameters.lighting.groundLightingFactor = 1, this._bindParameters.lighting.globalFactor = 0, this._bindParameters.lighting.set([new i5(r2(1, 1, 1))]), this._frameTask = this.view.resourceController.scheduler.registerTask(L2.STAGE, this), this._handles.add(this._frameTask);
  }
  dispose() {
    this._handles.destroy(), this._drapeSourceRenderers.forEach((e16) => e16.destroy()), this._drapeSourceRenderers.clear(), this._debugTextureTechnique = p(this._debugTextureTechnique), this._debugPatternTexture = s(this._debugPatternTexture), this._bindParameters.highlightDepthTexture = s(this._bindParameters.highlightDepthTexture), this._shaderTechniqueRepository = s(this._shaderTechniqueRepository), this._temporaryFBO = s(this._temporaryFBO), this._quadVAO = s(this._quadVAO), this.disposeOverlays();
  }
  get updating() {
    return this._sortedDrapeSourceRenderersDirty || this._frameTask.updating || n4(this._drapeSourceRenderers, (e16) => e16.updating);
  }
  get hasOverlays() {
    return r(this._overlays) && r(this._overlayRenderTarget);
  }
  get gpuMemoryUsage() {
    return r(this._overlayRenderTarget) ? this._overlayRenderTarget.gpuMemoryUsage : 0;
  }
  createGeometryDrapeSourceRenderer(e16) {
    return this.createDrapeSourceRenderer(e16, y2);
  }
  createDrapeSourceRenderer(e16, r15, t18) {
    const s15 = this._drapeSourceRenderers.get(e16);
    r(s15) && s15.destroy();
    const i16 = new r15({ ...t18, rendererContext: this, drapeSource: e16 });
    return this._drapeSourceRenderers.set(e16, i16), this._sortedDrapeSourceRenderersDirty = true, "fullOpacity" in e16 && this._handles.add(l(() => e16.fullOpacity, () => this.events.emit("content-changed")), e16), i16;
  }
  removeDrapeSourceRenderer(e16) {
    if (t(e16))
      return;
    const r15 = this._drapeSourceRenderers.get(e16);
    t(r15) || (this._sortedDrapeSourceRenderersDirty = true, this._drapeSourceRenderers.delete(e16), this._handles.remove(e16), r15.destroy());
  }
  collectUnusedRenderTargetMemory(e16) {
    let r15 = false;
    if (r(this._overlayRenderTarget))
      for (const t18 of this._overlayRenderTarget.renderTargets) {
        const s15 = this.overlays[0].validTargets[t18.type] || !this.overlays[1].validTargets[t18.type];
        r15 = this._overlayRenderTarget.validateUsageForTarget(s15, t18, e16) || r15;
      }
    return r15;
  }
  get overlays() {
    return c(this._overlays, []);
  }
  ensureDrapeTargets(e16) {
    r(this._overlays) && this._overlays.forEach((r15) => {
      r15.hasTargetWithoutRasterImage = n3(e16, (e17) => e17.drapeTargetType === t8.WithoutRasterImage);
    });
  }
  ensureDrapeSources(e16) {
    r(this._overlays) && this._overlays.forEach((r15) => {
      r15.hasDrapedFeatureSource = n3(e16, (e17) => e17.drapeSourceType === e11.Features), r15.hasDrapedRasterSource = n3(e16, (e17) => e17.drapeSourceType === e11.RasterImage);
    });
  }
  ensureOverlays(e16, r15) {
    t(this._overlays) && (this._overlayRenderTarget = new t13(this._rctx), this._overlays = [new l10(T2.INNER, this._overlayRenderTarget), new l10(T2.OUTER, this._overlayRenderTarget)]), this.ensureDrapeTargets(e16), this.ensureDrapeSources(r15);
  }
  disposeOverlays() {
    this._overlays = null, this._overlayRenderTarget = s(this._overlayRenderTarget), this.events.emit("textures-disposed");
  }
  get running() {
    return this.updating;
  }
  runTask(e16, r15 = () => true) {
    this._frameTask.processQueue(e16), e16.done || this._processDrapeSources(e16, r15);
  }
  _processDrapeSources(e16, r15) {
    let t18 = false;
    for (const [s15, i16] of this._drapeSourceRenderers) {
      if (e16.done)
        break;
      (s15.destroyed || r15(s15)) && (i16.commitChanges() && (t18 = true, e16.madeProgress()));
    }
    this._updateSortedDrapeSourceRenderers(), t18 && (r(this._overlays) && 0 === this._drapeSourceRenderers.size && this.disposeOverlays(), this.notifyChange("updating"), this.events.emit("content-changed"), this._updateHasHighlights(), this._updateRendersOccluded(), this._updateHasWater());
  }
  processSyncDrapeSources() {
    this._processDrapeSources(w2, (e16) => e16.updatePolicy === o8.SYNC);
  }
  isEmpty() {
    if (t9.OVERLAY_DRAW_DEBUG_TEXTURE)
      return false;
    for (const e16 of this._drapeSourceRenderers.values())
      if (!e16.isEmpty)
        return false;
    return true;
  }
  get hasHighlights() {
    return this._hasHighlights;
  }
  get hasWater() {
    return this._hasWater;
  }
  get rendersOccluded() {
    return this._rendersOccluded;
  }
  updateAnimation(e16) {
    let r15 = false;
    return this._drapeSourceRenderers.forEach((t18) => r15 = t18.updateAnimation(e16) || r15), r15;
  }
  updateDrapeSourceOrder() {
    this._sortedDrapeSourceRenderersDirty = true;
  }
  drawTarget(e16, r15, t18) {
    const s15 = e16.canvasGeometries;
    if (0 === s15.numViews)
      return false;
    this._screenToWorldRatio = t18 * e16.mapUnitsPerPixel;
    const i16 = r15.renderPass;
    if (this.isEmpty() || i16 === A2.MATERIAL_HIGHLIGHT && !this.hasHighlights || i16 === A2.MATERIAL_NORMAL && !this.hasWater || !e16.hasSomeSizedView())
      return false;
    const o20 = r15.fbo;
    if (!o20.isValid())
      return false;
    const a8 = 2 * e16.resolution, d4 = e16.resolution;
    o20.resize(a8, d4);
    const h8 = this._rctx;
    pe2.pixelRatio = e16.pixelRatio * t18, this._renderContext.pass = i16, this._bindParameters.screenToWorldRatio = this._screenToWorldRatio, this._bindParameters.screenToPCSRatio = this._screenToWorldRatio * this.worldToPCSRatio, this._bindParameters.slot = i16 === A2.MATERIAL_NORMAL ? E5.DRAPED_WATER : E5.DRAPED_MATERIAL, e16.applyViewport(this._rctx), o20.bind(h8), e16.index === T2.INNER && (h8.setClearColor(0, 0, 0, 0), h8.clearSafe(_2.COLOR_BUFFER_BIT));
    const c12 = r15.type === H.ColorNoRasterImage ? ce2.ExcludeRasterImage : r15.type === H.Occluded ? ce2.OccludedOnly : ce2.Normal;
    if (c12 === ce2.OccludedOnly && (this._renderContext.renderOccludedMask = ge), t9.OVERLAY_DRAW_DEBUG_TEXTURE && c12 !== ce2.OccludedOnly)
      for (let n18 = 0; n18 < s15.numViews; n18++)
        this._setViewParameters(s15.extents[n18], e16, pe2), this._drawDebugTexture(e16.resolution, ue2[e16.index]);
    return this._drapeSourceRenderers.size > 0 && this._sortedDrapeSourceRenderers.forAll(({ drapeSource: r16, renderer: t19 }) => {
      if (c12 === ce2.ExcludeRasterImage && r16.drapeSourceType === e11.RasterImage)
        return;
      const { fullOpacity: l12 } = r16, u12 = r(l12) && l12 < 1 && i16 === A2.MATERIAL;
      u12 && (this.bindTemporaryFramebuffer(this._rctx, a8, d4), h8.clearSafe(_2.COLOR_BUFFER_BIT));
      for (let i17 = 0; i17 < s15.numViews; i17++)
        this._setViewParameters(s15.extents[i17], e16, pe2), t19.render(this._renderContext, this._bindParameters);
      u12 && r(this._temporaryFBO) && (o20.bind(h8), this.view._stage.renderView.compositingHelper.composite(this._renderContext.bindParameters, this._temporaryFBO.getTexture(), o15.PremultipliedAlpha, l12, n11.OverlayWithTransparency, e16.index));
    }), h8.bindFramebuffer(null), o20.generateMipMap(), this._renderContext.resetRenderOccludedMask(), true;
  }
  bindTemporaryFramebuffer(e16, r15, t18) {
    t(this._temporaryFBO) && (this._temporaryFBO = new b2(e16, false)), this._temporaryFBO.resize(r15, t18), this._temporaryFBO.bind(e16);
  }
  async reloadShaders() {
    await this._shaderTechniqueRepository.reloadAll();
  }
  notifyContentChanged() {
    this.events.emit("content-changed");
  }
  intersect(e16, r15, t18, s15) {
    var _a;
    let i16 = 0;
    for (const o20 of this._drapeSourceRenderers.values())
      i16 = ((_a = o20.intersect) == null ? void 0 : _a.call(o20, e16, r15, t18, s15, i16)) ?? i16;
  }
  _updateSortedDrapeSourceRenderers() {
    if (!this._sortedDrapeSourceRenderersDirty)
      return;
    if (this._sortedDrapeSourceRenderersDirty = false, this._sortedDrapeSourceRenderers.clear(), 0 === this._drapeSourceRenderers.size)
      return;
    const e16 = this.view.map.allLayers;
    this._drapeSourceRenderers.forEach((r15, t18) => {
      const s15 = e16.indexOf(t18.layer);
      this._sortedDrapeSourceRenderers.push(new le2(t18, r15, s15 < 0 ? 1 / 0 : s15));
    }), this._sortedDrapeSourceRenderers.sort((e17, r15) => e17.index - r15.index);
  }
  _setViewParameters(e16, r15, t18) {
    t18.viewport[0] = t18.viewport[1] = 0, t18.viewport[2] = t18.viewport[3] = r15.resolution, E(t18.projectionMatrix, 0, e16[2] - e16[0], 0, e16[3] - e16[1], t18.near, t18.far), x3(t18.viewMatrix, [-e16[0], -e16[1], 0]), this._bindParameters.camera = t18;
  }
  _updateHasWater() {
    const e16 = n4(this._drapeSourceRenderers, (e17) => e17.hasWater);
    e16 !== this._hasWater && (this._hasWater = e16, this.events.emit("has-water", e16));
  }
  _updateHasHighlights() {
    const e16 = n4(this._drapeSourceRenderers, (e17) => e17.hasHighlights);
    e16 !== this._hasHighlights && (this._hasHighlights = e16, this.events.emit("has-highlights", e16));
  }
  _updateRendersOccluded() {
    const e16 = n4(this._drapeSourceRenderers, (e17) => e17.rendersOccluded);
    e16 !== this._rendersOccluded && (this._rendersOccluded = e16, this.events.emit("renders-occluded", e16));
  }
  _drawDebugTexture(e16, r15) {
    this._ensureDebugPatternResources(e16, e16);
    const t18 = this._rctx, s15 = t18.bindTechnique(this._debugTextureTechnique);
    s15.setUniform4f("uColor", r15[0], r15[1], r15[2], 1), s15.bindTexture("tex", this._debugPatternTexture), t18.bindVAO(this._quadVAO), t18.drawArrays(E2.TRIANGLE_STRIP, 0, n10(this._quadVAO, "geometry"));
  }
  _ensureDebugPatternResources(e16, r15) {
    if (this._debugPatternTexture)
      return;
    const t18 = new Uint8Array(e16 * r15 * 4);
    let s15 = 0;
    for (let o20 = 0; o20 < r15; o20++)
      for (let i17 = 0; i17 < e16; i17++) {
        const a8 = Math.floor(i17 / 10), n18 = Math.floor(o20 / 10);
        a8 < 2 || n18 < 2 || 10 * a8 > e16 - 20 || 10 * n18 > r15 - 20 ? (t18[s15++] = 255, t18[s15++] = 255, t18[s15++] = 255, t18[s15++] = 255) : (t18[s15++] = 255, t18[s15++] = 255, t18[s15++] = 255, t18[s15++] = 1 & a8 && 1 & n18 ? 1 & i17 ^ 1 & o20 ? 0 : 255 : 1 & a8 ^ 1 & n18 ? 0 : 128);
      }
    this._debugPatternTexture = new u6(this._rctx, { target: M.TEXTURE_2D, pixelFormat: P2.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L3.NEAREST, width: e16, height: r15 }, t18);
    const i16 = new r14();
    i16.hasAlpha = true, this._debugTextureTechnique = this._shaderTechniqueRepository.acquire(m2, i16), this._quadVAO = u7(this._rctx);
  }
  get test() {
    return { drapeSourceRenderers: this._drapeSourceRenderers, getDrapeSourceRenderer: (e16) => this._drapeSourceRenderers.get(e16) };
  }
};
var ce2;
e([d()], he2.prototype, "_frameTask", void 0), e([d()], he2.prototype, "_sortedDrapeSourceRenderersDirty", void 0), e([i10()], he2.prototype, "_shaderTechniqueRepository", void 0), e([i10()], he2.prototype, "_stippleTextureRepository", void 0), e([d({ constructOnly: true })], he2.prototype, "view", void 0), e([d()], he2.prototype, "worldToPCSRatio", void 0), e([d()], he2.prototype, "spatialReference", void 0), e([d({ type: Boolean, readOnly: true })], he2.prototype, "updating", null), he2 = e([n5("esri.views.3d.terrain.OverlayRenderer")], he2), function(e16) {
  e16[e16.Normal = 0] = "Normal", e16[e16.OccludedOnly = 1] = "OccludedOnly", e16[e16.ExcludeRasterImage = 2] = "ExcludeRasterImage";
}(ce2 || (ce2 = {}));
var le2 = class {
  constructor(e16, r15, t18) {
    this.drapeSource = e16, this.renderer = r15, this.index = t18;
  }
};
var ue2 = [[1, 0.5, 0.5], [0.5, 0.5, 1]];
var pe2 = new K();
pe2.near = 1, pe2.far = 1e4, pe2.relativeElevation = null;
var _e = -2;
var ge = h4.OccludeAndTransparent;

export {
  c8 as c,
  h5 as h,
  g2 as g,
  s8 as s,
  s9 as s2,
  e13 as e,
  i10 as i,
  l11 as l,
  e14 as e2,
  H2 as H,
  j2 as j,
  h6 as h2,
  c9 as c2,
  r10 as r,
  r11 as r2,
  i12 as i2,
  i13 as i3,
  d3 as d,
  A4 as A,
  A5 as A2,
  y2 as y,
  x6 as x,
  m2 as m,
  r14 as r3,
  c11 as c3,
  he2 as he,
  _e,
  ge
};
//# sourceMappingURL=chunk-Y75V5CF3.js.map
