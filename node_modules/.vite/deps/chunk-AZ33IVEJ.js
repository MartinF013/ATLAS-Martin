import {
  o
} from "./chunk-23E5E222.js";
import {
  a
} from "./chunk-KVF4M6PZ.js";
import {
  r,
  t3 as t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n;
var e;
!function(n3) {
  n3[n3.None = 0] = "None", n3[n3.Int16 = 1] = "Int16", n3[n3.Int32 = 2] = "Int32";
}(n || (n = {})), function(n3) {
  n3[n3.Replace = 0] = "Replace", n3[n3.Outside = 1] = "Outside", n3[n3.Inside = 2] = "Inside", n3[n3.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n2 || (n2 = new Promise((t2) => import("./i3s-5TMSLSP7.js").then((t3) => t3.i).then(({ default: e3 }) => {
    const n3 = e3({ locateFile: i, onRuntimeInitialized: () => t2(n3) });
    delete n3.then;
  })).catch((t2) => {
    throw t2;
  })), n2;
}
function i(e3) {
  return a(`esri/libs/i3s/${e3}`);
}
var n2;

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function s(e3) {
  await g();
  const t2 = [e3.geometryBuffer];
  return { result: m(e3, t2), transferList: t2 };
}
async function f(e3) {
  var _a;
  await g();
  const r2 = [e3.geometryBuffer], { geometryBuffer: n3 } = e3, o2 = n3.byteLength, s2 = y._malloc(o2), f2 = new Uint8Array(y.HEAPU8.buffer, s2, o2);
  f2.set(new Uint8Array(n3));
  const i3 = y.dracoDecompressPointCloudData(s2, f2.byteLength);
  if (y._free(s2), i3.error.length > 0)
    throw `i3s.wasm: ${i3.error}`;
  const a3 = ((_a = i3.featureIds) == null ? void 0 : _a.length) > 0 ? t(i3.featureIds) : null, u2 = t(i3.positions);
  a3 && r2.push(a3.buffer), r2.push(u2.buffer);
  return { result: { positions: u2, featureIds: a3 }, transferList: r2 };
}
async function i2(e3) {
  await g(), E(e3);
  const t2 = { buffer: e3.buffer };
  return { result: t2, transferList: [t2.buffer] };
}
async function a2(e3) {
  await g(), b(e3);
}
async function u(e3) {
  await g(), y.setLegacySchema(e3.context, e3.jsonSchema);
}
function l(e3) {
  h(e3);
}
var c;
var y;
function b(e3) {
  const t2 = e3.modifications, r2 = y._malloc(8 * t2.length), n3 = new Float64Array(y.HEAPU8.buffer, r2, t2.length);
  for (let o2 = 0; o2 < t2.length; ++o2)
    n3[o2] = t2[o2];
  y.setModifications(e3.context, r2, t2.length, e3.isGeodetic), y._free(r2);
}
function m(n3, o2) {
  if (!y)
    return null;
  const { context: s2, localOrigin: f2, globalTrafo: i3, mbs: a3, obb: u2, elevationOffset: l2, geometryBuffer: c2, geometryDescriptor: b2, indexToVertexProjector: m2, vertexToRenderProjector: d2 } = n3, E2 = y._malloc(c2.byteLength), h2 = 33, g2 = y._malloc(h2 * Float64Array.BYTES_PER_ELEMENT), w2 = new Uint8Array(y.HEAPU8.buffer, E2, c2.byteLength);
  w2.set(new Uint8Array(c2));
  const A = new Float64Array(y.HEAPU8.buffer, g2, h2);
  p(A, f2);
  let _ = A.byteOffset + 3 * A.BYTES_PER_ELEMENT, L = new Float64Array(A.buffer, _);
  p(L, i3), _ += 16 * A.BYTES_PER_ELEMENT, L = new Float64Array(A.buffer, _), p(L, a3), _ += 4 * A.BYTES_PER_ELEMENT, r(u2) && (L = new Float64Array(A.buffer, _), p(L, u2.center), _ += 3 * A.BYTES_PER_ELEMENT, L = new Float64Array(A.buffer, _), p(L, u2.halfSize), _ += 3 * A.BYTES_PER_ELEMENT, L = new Float64Array(A.buffer, _), p(L, u2.quaternion));
  const I = b2, T = { isDraco: false, isLegacy: false, color: n3.layouts.some((e3) => e3.some((e4) => "color" === e4.name)), normal: n3.needNormals && n3.layouts.some((e3) => e3.some((e4) => "normalCompressed" === e4.name)), uv0: n3.layouts.some((e3) => e3.some((e4) => "uv0" === e4.name)), uvRegion: n3.layouts.some((e3) => e3.some((e4) => "uvRegion" === e4.name)), featureIndex: I.featureIndex }, P = y.process(s2, !!n3.obb, E2, w2.byteLength, I, T, g2, l2, m2, d2, n3.normalReferenceFrame);
  if (y._free(g2), y._free(E2), P.error.length > 0)
    throw `i3s.wasm: ${P.error}`;
  if (P.discarded)
    return null;
  const U = P.componentOffsets.length > 0 ? t(P.componentOffsets) : null, B = P.featureIds.length > 0 ? t(P.featureIds) : null, F = t(P.interleavedVertedData).buffer, M = P.indicesType === n.Int16 ? t(new Uint16Array(P.indices.buffer, P.indices.byteOffset, P.indices.byteLength / 2)) : t(new Uint32Array(P.indices.buffer, P.indices.byteOffset, P.indices.byteLength / 4)), S = t(P.positions), x = P.positionIndicesType === n.Int16 ? t(new Uint16Array(P.positionIndices.buffer, P.positionIndices.byteOffset, P.positionIndices.byteLength / 2)) : t(new Uint32Array(P.positionIndices.buffer, P.positionIndices.byteOffset, P.positionIndices.byteLength / 4)), O = { layout: n3.layouts[0], interleavedVertexData: F, indices: M, hasColors: P.hasColors, hasModifications: P.hasModifications, positionData: { data: S, indices: x } };
  return B && o2.push(B.buffer), U && o2.push(U.buffer), o2.push(F), o2.push(M.buffer), o2.push(S.buffer), o2.push(x.buffer), { componentOffsets: U, featureIds: B, transformedGeometry: O, obb: P.obb };
}
function d(e3) {
  return 0 === e3 ? o.Unmodified : 1 === e3 ? o.PotentiallyModified : 2 === e3 ? o.Culled : o.Unknown;
}
function E(e3) {
  const { context: t2, buffer: r2 } = e3, n3 = y._malloc(r2.byteLength), o2 = r2.byteLength / Float64Array.BYTES_PER_ELEMENT, s2 = new Float64Array(y.HEAPU8.buffer, n3, o2), f2 = new Float64Array(r2);
  s2.set(f2), y.filterOBBs(t2, n3, o2), f2.set(s2), y._free(n3);
}
function h(e3) {
  y && y.destroy(e3);
}
function p(e3, t2) {
  for (let r2 = 0; r2 < t2.length; ++r2)
    e3[r2] = t2[r2];
}
function g() {
  return y ? Promise.resolve() : (c || (c = e2().then((e3) => {
    y = e3, c = null;
  })), c);
}
var w = { transform: m, destroy: h };

export {
  e,
  s,
  f,
  i2 as i,
  a2 as a,
  u,
  l,
  b,
  d,
  E,
  g,
  w
};
//# sourceMappingURL=chunk-AZ33IVEJ.js.map
