import {
  h as h6
} from "./chunk-MQZSD3AZ.js";
import {
  s as s2
} from "./chunk-WGMCNMOI.js";
import {
  m
} from "./chunk-PUU4QXN5.js";
import {
  Z,
  f as f4,
  i as i5,
  w
} from "./chunk-HPO2NV7P.js";
import {
  O as O4,
  l as l2
} from "./chunk-PQM6RARY.js";
import {
  K
} from "./chunk-5ZS6RUSM.js";
import {
  T as T2
} from "./chunk-52W4YMC2.js";
import {
  i as i4
} from "./chunk-YLSPLHY5.js";
import {
  h as h5,
  p as p4
} from "./chunk-7OZR6JFF.js";
import {
  e as e7,
  o as o5,
  t as t3
} from "./chunk-NXOQBIK7.js";
import {
  E as E2
} from "./chunk-ERNXFM5T.js";
import {
  i as i3
} from "./chunk-6ITXWFMK.js";
import {
  e as e8
} from "./chunk-SV4VP57N.js";
import {
  E,
  S,
  c as c4,
  f as f3
} from "./chunk-5EXPMKQP.js";
import {
  W,
  a as a2,
  c as c3,
  h as h4
} from "./chunk-B7F3T673.js";
import {
  t as t2
} from "./chunk-WJDUBZ7S.js";
import {
  o as o3
} from "./chunk-TEJEYVH4.js";
import {
  T
} from "./chunk-3DCTMZI6.js";
import {
  I
} from "./chunk-FPMD6IB4.js";
import {
  i as i2
} from "./chunk-MQBVOUKB.js";
import {
  d2,
  h as h3,
  o2 as o4,
  x as x2
} from "./chunk-EEJIELE6.js";
import {
  O as O3,
  n as n5,
  o as o2
} from "./chunk-MDCKEJ7B.js";
import {
  O as O2
} from "./chunk-VMF4NMEB.js";
import {
  e as e6
} from "./chunk-NAIF4GWX.js";
import {
  _ as _2,
  p2 as p5,
  q2
} from "./chunk-53KI6WDE.js";
import {
  d as d3
} from "./chunk-W2HLA6I3.js";
import {
  B,
  b as b2,
  l,
  v
} from "./chunk-Q6AASANP.js";
import {
  c as c2,
  f as f2
} from "./chunk-ZYIEYKCD.js";
import {
  e as e5
} from "./chunk-YFBAFAZ2.js";
import {
  e as e4
} from "./chunk-LUU3J646.js";
import {
  a
} from "./chunk-3NPGGTI6.js";
import {
  t as t4,
  u as u3
} from "./chunk-G4ERZR5M.js";
import {
  b
} from "./chunk-YZNDHJDJ.js";
import {
  An,
  Pe,
  Pn,
  Vn
} from "./chunk-PZWU5EHT.js";
import {
  r as r3
} from "./chunk-U7B2WKBH.js";
import {
  h as h2,
  n as n3,
  r as r4,
  s,
  u as u2
} from "./chunk-ASC3X65B.js";
import {
  n as n4
} from "./chunk-P6G64ARX.js";
import {
  p
} from "./chunk-RN2KRYDN.js";
import {
  Y,
  p as p3
} from "./chunk-TMBOFNWA.js";
import {
  F
} from "./chunk-56RHM4A6.js";
import {
  n as n2
} from "./chunk-OIPX3EDD.js";
import {
  d,
  i,
  x,
  y
} from "./chunk-NWRK6QLX.js";
import {
  M
} from "./chunk-BPZGJQOB.js";
import {
  L,
  O,
  _,
  e as e3,
  o,
  p as p2,
  q,
  r as r2,
  u,
  z
} from "./chunk-PKZEO23A.js";
import {
  f,
  n
} from "./chunk-AIRC226G.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  h
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  c,
  e as e2,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/interactive/Manipulator3D.js
var te = class {
  constructor(e9) {
    this.camera = new K(), this._elevation = { offset: 0, override: null }, this.collisionType = { type: "point" }, this.collisionPriority = 0, this._renderObjects = [], this.autoScaleRenderObjects = true, this._available = true, this._noDisplayCount = 0, this._radius = 10, this._worldSized = false, this.focusMultiplier = 2, this.touchMultiplier = 2.5, this.worldOriented = false, this._modelTransform = e5(), this._worldFrame = null, this._renderLocation = n(), this._renderLocationDirty = true, this._location = new j({ x: 0, y: 0, z: 0 }), this._elevationAlignedLocation = new j(), this._elevationAlignedLocationDirty = true, this.interactive = true, this.selectable = false, this.grabbable = true, this.cursor = null, this._grabbing = false, this.dragging = false, this._hovering = false, this._selected = false, this._state = u3.None, this._focused = false, this.events = new n2.EventEmitter(), this._screenLocation = { screenPointArray: i(), renderScreenPointArray: x(), pixelSize: 0 }, this._screenLocationDirty = true, this._applyObjectTransform = null, this._engineResourcesAddedToStage = false, this._engineResources = null, this._attached = false, this._engineLayer = null, this._materialIdReferences = null, this._location.spatialReference = e9.view.spatialReference;
    for (const t5 in e9)
      this[t5] = e9[t5];
    this.view.state && this.view.state.camera && this.camera.copyFrom(this.view.state.camera);
  }
  destroy() {
    this._removeResourcesFromStage(), this._engineResources = null, this.view = null, this.camera = null;
  }
  get elevationInfo() {
    return this._elevationInfo;
  }
  set elevationInfo(e9) {
    this._elevationInfo = e9, this._elevationAlignedLocationDirty = true, this._renderLocationDirty = true, this._updateEngineObject();
  }
  get renderObjects() {
    return this._renderObjects;
  }
  set renderObjects(e9) {
    this._removeResourcesFromStage(), this._engineResources = null, this._renderObjects = e9.slice(), this._updateEngineObject();
  }
  set available(e9) {
    e9 !== this._available && (this._available = e9, this._updateEngineObject());
  }
  get available() {
    return this._available;
  }
  disableDisplay() {
    return this._noDisplayCount++, 1 === this._noDisplayCount && this._updateEngineObject(), { remove: h(() => {
      this._noDisplayCount--, 0 === this._noDisplayCount && this._updateEngineObject();
    }) };
  }
  set radius(e9) {
    e9 !== this._radius && (this._radius = e9, this._updateEngineObject());
  }
  get radius() {
    return this._radius;
  }
  set worldSized(e9) {
    e9 !== this._worldSized && (this._worldSized = e9, this._updateEngineObject());
  }
  get worldSized() {
    return this._worldSized;
  }
  get modelTransform() {
    return this._modelTransform;
  }
  set modelTransform(e9) {
    ie(e9) && (this._screenLocationDirty = true), n3(this._modelTransform, e9), this._updateEngineObject();
  }
  get renderLocation() {
    return this._renderLocationDirty && (this._renderLocationDirty = false, this.view.renderCoordsHelper.toRenderCoords(this.elevationAlignedLocation, this._renderLocation), this.worldOriented ? (this._worldFrame || (this._worldFrame = e5()), se(this.view, this._renderLocation, this._worldFrame)) : this._worldFrame && (this._worldFrame = null)), this._renderLocation;
  }
  set renderLocation(e9) {
    this.view.renderCoordsHelper.fromRenderCoords(e9, this._location), this.elevationAlignedLocation = this._location;
  }
  get location() {
    return this._location;
  }
  set location(e9) {
    Z(e9, this._location), this._renderLocationDirty = true, this._screenLocationDirty = true, this._elevationAlignedLocationDirty = true, this._updateEngineObject(), this.events.emit("location-update", { location: this._location });
  }
  get elevationAlignedLocation() {
    return this._elevationAlignedLocationDirty ? (this._evaluateElevationAlignment(), this._updateElevationAlignedLocation(), this._elevationAlignedLocation) : this._elevationAlignedLocation;
  }
  set elevationAlignedLocation(e9) {
    Z(e9, this._location), this._evaluateElevationAlignment(), this._location.z -= this._elevation.offset, this._updateElevationAlignedLocation(), this._updateEngineObject(), this.events.emit("location-update", { location: this._location });
  }
  _updateElevationAlignedLocation() {
    this._elevationAlignedLocation.x = this.location.x, this._elevationAlignedLocation.y = this.location.y;
    const e9 = r(this._elevation.override) ? this._elevation.override : this.location.z || 0;
    this._elevationAlignedLocation.z = e9 + this._elevation.offset, this._elevationAlignedLocation.spatialReference = this.location.spatialReference, this._renderLocationDirty = true, this._screenLocationDirty = true, this._elevationAlignedLocationDirty = false;
  }
  grabbableForEvent() {
    return true;
  }
  get grabbing() {
    return this._grabbing;
  }
  set grabbing(e9) {
    e9 !== this._grabbing && (this._grabbing = e9, this._setFocused(this._hovering || this._grabbing), this._updateEngineObject());
  }
  get hovering() {
    return this._hovering;
  }
  set hovering(e9) {
    e9 !== this._hovering && (this._hovering = e9, this._setFocused(this._hovering || this._grabbing), this._updateEngineObject());
  }
  get selected() {
    return this._selected;
  }
  set selected(e9) {
    e9 !== this._selected && (this._selected = e9, this._updateEngineObject(), this.events.emit("select-changed", { action: e9 ? "select" : "deselect" }));
  }
  get state() {
    return this._state;
  }
  set state(e9) {
    e9 !== this._state && (this._state = e9, this._updateEngineObject());
  }
  updateStateEnabled(e9, t5) {
    t5 ? this.state |= e9 : this.state &= ~e9;
  }
  _setFocused(e9) {
    e9 !== this._focused && (this._focused = e9, this.events.emit("focus-changed", { action: true === e9 ? "focus" : "unfocus" }));
  }
  get focused() {
    return this._focused;
  }
  get screenLocation() {
    return this._ensureScreenLocation(), this._screenLocation;
  }
  _ensureScreenLocation() {
    if (!this._screenLocationDirty)
      return;
    this._screenLocation.pixelSize = this.camera.computeScreenPixelSizeAt(this.renderLocation), this._screenLocationDirty = false;
    let e9;
    if (ie(this._modelTransform)) {
      const t5 = this._calculateModelTransformOffset(fe);
      e9 = u(t5, t5, this.renderLocation);
    } else
      e9 = this.renderLocation;
    this.camera.projectToRenderScreen(e9, this._screenLocation.renderScreenPointArray), this.camera.renderToScreen(this._screenLocation.renderScreenPointArray, this._screenLocation.screenPointArray);
  }
  get applyObjectTransform() {
    return this._applyObjectTransform;
  }
  set applyObjectTransform(e9) {
    this._applyObjectTransform = e9, this._screenLocationDirty = true, this._updateEngineObject();
  }
  intersectionDistance(t5, i6) {
    if (!this.available)
      return null;
    const s3 = d(t5, oe), n6 = this._getCollisionRadius(i6), r5 = -1 * this.collisionPriority;
    switch (this.collisionType.type) {
      case "point":
        if (b(this.screenLocation.screenPointArray, s3) < n6 * n6)
          return this.screenLocation.renderScreenPointArray[2] + r5;
        break;
      case "line": {
        const e9 = this.collisionType.paths, t6 = this._getWorldToScreenObjectScale(), i7 = this._calculateObjectTransform(t6, le), a3 = n6 * this.screenLocation.pixelSize, c5 = s2(this.camera, s3, re);
        if (t(c5))
          return null;
        for (const s4 of e9) {
          if (0 === s4.length)
            continue;
          const e10 = L(de, s4[0], i7);
          for (let t7 = 1; t7 < s4.length; t7++) {
            const o6 = L(_e, s4[t7], i7), n7 = B(l(e10, o6, ne), c5);
            if (null != n7 && n7 < a3 * a3) {
              const t8 = u(c2.get(), e10, o6);
              q(t8, t8, 0.5);
              const i8 = y(c2.get());
              return this.camera.projectToRenderScreen(t8, i8), i8[2] + r5;
            }
            r2(e10, o6);
          }
        }
        break;
      }
      case "disc": {
        const e9 = this.collisionType.direction, t6 = this.collisionType.offset ?? f, i7 = this._getWorldToScreenObjectScale(), a3 = this._calculateObjectTransform(i7, le), c5 = n6 * this.screenLocation.pixelSize, l3 = s2(this.camera, s3, re);
        if (t(l3))
          return null;
        const h7 = a(ae, a3), d4 = O(ge, e9, h7), u4 = L(me, t6, a3);
        _2(u4, d4, he);
        const g = ue;
        if (q2(he, l3, g) && p2(g, u4) < c5 * c5)
          return this.screenLocation.renderScreenPointArray[2] + r5;
        break;
      }
      case "ribbon": {
        const { paths: e9, direction: t6 } = this.collisionType, i7 = this._getWorldToScreenObjectScale(), a3 = this._calculateObjectTransform(i7, le), c5 = n6 * this.camera.computeScreenPixelSizeAt(this.renderLocation), l3 = s2(this.camera, s3, re);
        if (t(l3))
          return null;
        const d4 = a(ae, a3), u4 = O(ge, t6, d4), g = this._calculateModelTransformPosition(me);
        _2(g, u4, he);
        const m2 = ue;
        if (!q2(he, l3, m2))
          break;
        for (const s4 of e9) {
          if (0 === s4.length)
            continue;
          const e10 = L(de, s4[0], a3);
          for (let t7 = 1; t7 < s4.length; t7++) {
            const i8 = L(_e, s4[t7], a3), o6 = b2(l(e10, i8, ne), m2);
            if (null != o6 && o6 < c5 * c5) {
              const t8 = u(c2.get(), e10, i8);
              q(t8, t8, 0.5);
              const s5 = y(c2.get());
              return this.camera.projectToRenderScreen(t8, s5), s5[2] + r5;
            }
            r2(e10, i8);
          }
        }
        break;
      }
      default:
        n4(this.collisionType);
    }
    return null;
  }
  attach(e9 = { manipulator3D: {} }) {
    var _a;
    if (!this.view._stage)
      return;
    const t5 = e9.manipulator3D;
    if (t(t5.engineLayerId)) {
      const e10 = new l2({ isPickable: false, updatePolicy: o2.SYNC });
      this.view._stage.add(e10), t5.engineLayerId = e10.id, this._engineLayer = e10;
    } else
      ((_a = this.view._stage) == null ? void 0 : _a.getObject) && (this._engineLayer = this.view._stage.getObject(t5.engineLayerId));
    t5.engineLayerReferences = (t5.engineLayerReferences || 0) + 1, this._materialIdReferences = t5.materialIdReferences, t(this._materialIdReferences) && (this._materialIdReferences = /* @__PURE__ */ new Map(), t5.materialIdReferences = this._materialIdReferences), this.camera.copyFrom(this.view.state.camera), this._attached = true, this._updateEngineObject(), An(this._location.spatialReference, this.view.spatialReference) || (this.location = new j({ x: 0, y: 0, z: 0, spatialReference: this.view.spatialReference }));
  }
  detach(e9 = { manipulator3D: {} }) {
    const t5 = e9.manipulator3D;
    t5.engineLayerReferences--;
    const i6 = 0 === t5.engineLayerReferences;
    i6 && (t5.engineLayerId = null), this._removeResourcesFromStage(i6), this._engineResources = null, this._engineLayer = null, this._materialIdReferences = null, this._attached = false;
  }
  onViewChange() {
    this.camera.copyFrom(this.view.state.camera), this._screenLocationDirty = true, this._updateEngineObject();
  }
  onElevationChange(e9) {
    Pn(this.location, pe, e9.spatialReference), F(e9.extent, pe) && (this.location = this._location);
  }
  _evaluateElevationAlignment(e9 = this.location) {
    if (t(this.elevationInfo))
      return false;
    let t5 = null, i6 = 0;
    const s3 = c(this.elevationInfo.offset, 0);
    switch (this.elevationInfo.mode) {
      case "on-the-ground":
        t5 = c(i5(this.view.elevationProvider, e9, "ground"), 0);
        break;
      case "relative-to-ground":
        i6 = c(i5(this.view.elevationProvider, e9, "ground"), 0) + s3;
        break;
      case "relative-to-scene":
        i6 = c(i5(this.view.elevationProvider, e9, "scene"), 0) + s3;
        break;
      case "absolute-height":
        i6 = s3;
    }
    return (i6 !== this._elevation.offset || t5 !== this._elevation.override) && (this._elevation.offset = i6, this._elevation.override = t5, true);
  }
  _updateEngineObject() {
    if (!this._attached)
      return;
    if (!this.available)
      return void this._removeResourcesFromStage();
    const e9 = this._getWorldToScreenObjectScale(), t5 = le;
    if (true === this.autoScaleRenderObjects) {
      const i7 = this._getFocusedSize(this._radius, this.focused) * e9;
      this._calculateObjectTransform(i7, t5);
    } else
      this._calculateObjectTransform(e9, t5);
    const { objectsByState: i6 } = this._ensureEngineResources(), s3 = (this.focused ? t4.Focused : t4.Unfocused) | (this.selected ? t4.Selected : t4.Unselected), o6 = this._noDisplayCount > 0;
    for (const { stateMask: n6, objects: r5 } of i6) {
      if (o6) {
        for (const e11 of r5)
          e11.setVisible(false);
        continue;
      }
      const e10 = (n6 & t4.All) !== t4.None, i7 = (n6 & u3.All) !== u3.None, a3 = !e10 || (s3 & n6) == (n6 & t4.All), c5 = !i7 || (this.state & n6) == (n6 & u3.All);
      if (a3 && c5)
        for (const s4 of r5)
          s4.setVisible(true), s4.transformation = t5;
      else
        for (const t6 of r5)
          t6.setVisible(false);
    }
  }
  _ensureEngineResources() {
    if (t(this._engineResources)) {
      const e9 = e2(this._engineLayer), t5 = [], i6 = /* @__PURE__ */ new Set();
      this.renderObjects.forEach(({ material: e10 }) => {
        i6.has(e10) || (t5.push(e10), i6.add(e10));
      });
      const s3 = (e10, t6) => {
        const { geometry: i7, material: s4, transform: o7 } = t6;
        Array.isArray(i7) ? i7.forEach((t7) => e10.addGeometry(t7, s4, o7)) : e10.addGeometry(i7, s4, o7);
      }, o6 = /* @__PURE__ */ new Map();
      this._renderObjects.forEach((e10) => {
        const t6 = new O4({ castShadow: false });
        s3(t6, e10);
        const i7 = e10.stateMask || 0, n7 = o6.get(i7) || [];
        n7.push(t6), o6.set(i7, n7);
      });
      const n6 = [];
      o6.forEach((e10, t6) => n6.push({ stateMask: t6, objects: e10 })), this._engineResources = { objectsByState: n6, layer: e9, materials: t5 };
    }
    return this._addResourcesToStage(), this._engineResources;
  }
  _addResourcesToStage() {
    if (this._engineResourcesAddedToStage || t(this._engineResources))
      return;
    const { objectsByState: e9, layer: t5, materials: i6 } = this._engineResources;
    i6.forEach((e10) => {
      const t6 = e2(this._materialIdReferences), i7 = t6.get(e10.id) || 0;
      0 === i7 && this.view._stage.add(e10), t6.set(e10.id, i7 + 1);
    }), e9.forEach(({ objects: e10 }) => {
      t5.addMany(e10), this.view._stage.addMany(e10);
    }), this._engineResourcesAddedToStage = true;
  }
  _removeResourcesFromStage(e9 = false) {
    if (!this._engineResourcesAddedToStage || t(this._engineResources) || !this.view._stage)
      return;
    const { objectsByState: t5, layer: i6, materials: s3 } = this._engineResources;
    t5.forEach(({ objects: e10 }) => {
      i6.removeMany(e10), this.view._stage.removeMany(e10);
    }), s3.forEach((e10) => {
      const t6 = e2(this._materialIdReferences), i7 = t6.get(e10.id);
      1 === i7 ? (this.view._stage.remove(e10), t6.delete(e10.id)) : t6.set(e10.id, i7 - 1);
    }), e9 && this.view._stage.remove(i6), this._engineResourcesAddedToStage = false;
  }
  _getCollisionRadius(e9) {
    return this._getFocusedSize(this.radius, true) * ("touch" === e9 ? this.touchMultiplier : 1);
  }
  _getFocusedSize(e9, t5) {
    return e9 * (t5 ? this.focusMultiplier : 1);
  }
  _getWorldToScreenObjectScale() {
    return this._worldSized ? 1 : this.screenLocation.pixelSize;
  }
  _calculateModelTransformPosition(e9) {
    const t5 = this._getWorldToScreenObjectScale(), i6 = this._calculateObjectTransform(t5, ce);
    return o(e9, i6[12], i6[13], i6[14]);
  }
  _calculateModelTransformOffset(e9) {
    const t5 = this._calculateModelTransformPosition(e9);
    return e3(e9, t5, this.renderLocation);
  }
  _calculateObjectTransform(e9, t5) {
    return s(t5, e9, 0, 0, 0, 0, e9, 0, 0, 0, 0, e9, 0, 0, 0, 0, 1), this._worldFrame && u2(t5, t5, this._worldFrame), u2(t5, t5, this._modelTransform), t5[12] += this.renderLocation[0], t5[13] += this.renderLocation[1], t5[14] += this.renderLocation[2], t5[15] = 1, r(this._applyObjectTransform) && this._applyObjectTransform(t5), t5;
  }
  get test() {
    let e9 = false;
    if (r(this._engineResources))
      for (const t5 in this._engineResources.objectsByState) {
        const i6 = this._engineResources.objectsByState[t5];
        for (const t6 of i6.objects)
          if (t6.isVisible) {
            e9 = true;
            break;
          }
        if (e9)
          break;
      }
    return { areAnyResourcesVisible: e9 };
  }
};
function ie(e9) {
  return 0 !== e9[12] || 0 !== e9[13] || 0 !== e9[14];
}
function se(e9, t5, s3) {
  switch (e9.viewingMode) {
    case "local":
      return r4(s3), true;
    case "global": {
      const o6 = p(e9.renderCoordsHelper.spatialReference);
      return Pe(t5, 0, de, 0, o6.radius), Vn(M(de[0]), M(de[1]), s3), true;
    }
  }
}
var oe = i();
var ne = v();
var re = d3();
var ae = e4();
var ce = e5();
var le = e5();
var he = p5();
var de = n();
var _e = n();
var ue = n();
var ge = n();
var me = n();
var fe = n();
var pe = new j({ x: 0, y: 0, z: 0, spatialReference: null });

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/ShadedColorMaterialTechnique.js
var T3 = class extends e7 {
  initializeProgram(e9) {
    const t5 = T3.shader.get().build(this.configuration);
    return new o5(e9.rctx, t5, O5);
  }
  _setPipelineState(e9) {
    const r5 = this.configuration, o6 = e9 === O3.NONE, i6 = e9 === O3.FrontFace;
    return W({ blending: r5.output !== o3.Color && r5.output !== o3.Alpha || !r5.transparent ? null : o6 ? c4 : E(e9), culling: h4(r5.cullFace), depthTest: { func: i6 ? I.LESS : r5.shadingEnabled ? I.LEQUAL : I.LESS }, depthWrite: o6 ? r5.writeDepth && a2 : S(e9), colorWrite: c3, polygonOffset: o6 || i6 ? null : f3 });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
T3.shader = new t3(h6, () => import("./ShadedColorMaterial.glsl-K7QQYHLR.js"));
var j2 = class extends i3 {
  constructor() {
    super(...arguments), this.output = o3.Color, this.cullFace = n5.None, this.transparencyPassType = O3.NONE, this.hasSlicePlane = false, this.transparent = false, this.writeDepth = true, this.screenSizeEnabled = true, this.shadingEnabled = true, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([e8({ count: o3.COUNT })], j2.prototype, "output", void 0), e([e8({ count: n5.COUNT })], j2.prototype, "cullFace", void 0), e([e8({ count: O3.COUNT })], j2.prototype, "transparencyPassType", void 0), e([e8()], j2.prototype, "hasSlicePlane", void 0), e([e8()], j2.prototype, "transparent", void 0), e([e8()], j2.prototype, "writeDepth", void 0), e([e8()], j2.prototype, "screenSizeEnabled", void 0), e([e8()], j2.prototype, "shadingEnabled", void 0), e([e8()], j2.prototype, "hasMultipassTerrain", void 0), e([e8()], j2.prototype, "cullAboveGround", void 0);
var O5 = /* @__PURE__ */ new Map([[O2.POSITION, 0], [O2.NORMAL, 1], [O2.OFFSET, 2]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/ShadedColorMaterial.js
var q3 = class extends d2 {
  constructor(e9) {
    super(e9, new C()), this.supportsEdges = true, this.techniqueConfig = new j2(), this._vertexAttributeLocations = O5;
  }
  getConfiguration(e9, t5) {
    return this.techniqueConfig.output = e9, this.techniqueConfig.cullFace = this.parameters.cullFace, this.techniqueConfig.hasSlicePlane = this.parameters.hasSlicePlane, this.techniqueConfig.transparent = this.parameters.transparent, this.techniqueConfig.writeDepth = this.parameters.writeDepth, this.techniqueConfig.screenSizeEnabled = this.parameters.screenSizeEnabled, this.techniqueConfig.shadingEnabled = this.parameters.shadingEnabled, this.techniqueConfig.transparencyPassType = t5.transparencyPassType, this.techniqueConfig.hasMultipassTerrain = t5.multipassTerrain.enabled, this.techniqueConfig.cullAboveGround = t5.multipassTerrain.cullAboveGround, this.techniqueConfig;
  }
  intersect(e9, s3, a3, c5, h7, u4, l3) {
    if (this.parameters.screenSizeEnabled) {
      const a4 = e9.vertexAttributes.get(O2.OFFSET), p6 = { applyToVertex: (e10, s4, n6, o6) => {
        const h8 = o(L2, a4.data[3 * o6 + 0], a4.data[3 * o6 + 1], a4.data[3 * o6 + 2]), u5 = o(w2, e10, s4, n6);
        return q(h8, h8, this.parameters.screenSizeScale * c5.camera.computeRenderPixelSizeAt(h8)), u(u5, u5, h8), [u5[0], u5[1], u5[2]];
      }, applyToAabb: (e10) => {
        const t5 = p3(e10, L2);
        return Y(e10, this.parameters.screenSizeScale * c5.camera.computeRenderPixelSizeAt(t5));
      } };
      x2(e9, s3, c5, h7, u4, p6, l3);
    } else
      x2(e9, s3, c5, h7, u4, void 0, l3);
  }
  requiresSlot(e9, t5) {
    if (i4(t5) === o3.Highlight)
      return e9 === E2.OPAQUE_MATERIAL;
    let r5 = E2.OPAQUE_MATERIAL;
    return this.parameters.transparent && (r5 = this.parameters.writeDepth ? E2.TRANSPARENT_MATERIAL : E2.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL), e9 === r5 || e9 === E2.DRAPED_MATERIAL;
  }
  createGLMaterial(e9) {
    return e9.output === o3.Color || e9.output === o3.Alpha || e9.output === o3.Highlight ? new x3(e9) : null;
  }
  createBufferWriter() {
    return new O6(this.parameters.screenSizeEnabled);
  }
};
var x3 = class extends t2 {
  beginSlot(e9) {
    return this.ensureTechnique(T3, e9);
  }
};
var C = class extends o4 {
  constructor() {
    super(...arguments), this.color = r3(1, 1, 1, 1), this.shadingTint = r3(0, 0, 0, 0.25), this.shadingDirection = z(n(), [0.5, -0.5, -0.5]), this.screenSizeScale = 14, this.transparent = false, this.writeDepth = true, this.hasSlicePlane = false, this.cullFace = n5.None, this.screenSizeEnabled = false, this.shadingEnabled = true;
  }
};
var O6 = class {
  constructor(e9) {
    this.screenSizeEnabled = e9;
    const t5 = T().vec3f(O2.POSITION).vec3f(O2.NORMAL);
    this.screenSizeEnabled && t5.vec3f(O2.OFFSET), this.vertexBufferLayout = t5;
  }
  allocate(e9) {
    return this.vertexBufferLayout.createBuffer(e9);
  }
  elementCount(e9) {
    return e9.indices.get(O2.POSITION).length;
  }
  write(e9, t5, r5, i6) {
    if (h5(t5, this.vertexBufferLayout, e9.transformation, e9.invTranspTransformation, r5, i6), this.screenSizeEnabled) {
      if (!t5.vertexAttributes.has(O2.OFFSET))
        throw new Error(`${O2.OFFSET} vertex attribute required for screenSizeEnabled ShadedColorMaterial`);
      {
        const s3 = t5.vertexAttributes.get(O2.OFFSET), a3 = t5.indices.get(O2.OFFSET);
        e6(3 === s3.size);
        const n6 = r5.getField(O2.OFFSET, i2);
        if (!n6)
          throw new Error("unable to acquire view for " + O2.OFFSET);
        p4(a3, s3.data, e9.invTranspTransformation, n6, i6);
      }
    }
  }
};
var L2 = n();
var w2 = n();

// node_modules/@arcgis/core/views/3d/interactive/manipulatorUtils.js
function w3(e9, t5 = h3.OccludeAndTransparent, r5 = true) {
  const n6 = r3(e9[0], e9[1], e9[2], e9.length > 3 ? e9[3] : 1), o6 = e9[3] < 1;
  return r5 ? new q3({ color: n6, transparent: o6, writeDepth: true, cullFace: n5.Back, renderOccluded: t5 }) : new m({ color: n6, transparent: o6, writeDepth: true, cullFace: n5.Back, renderOccluded: t5 });
}
function b3(e9, t5 = h3.OccludeAndTransparent) {
  const r5 = r3(e9[0], e9[1], e9[2], 4 === e9.length ? e9[3] : 1);
  return new m({ color: r5, transparent: true, writeDepth: true, cullFace: n5.Front, renderOccluded: t5 });
}
function y2(e9, t5, r5) {
  return new te({ view: e9, renderObjects: [{ geometry: T2.createSphereGeometry(1, 32, 32), material: w3(r3(t5[0], t5[1], t5[2], null != r5 ? r5 : 1)) }] });
}
function O7(e9, t5, c5, i6) {
  const m2 = e3(c2.get(), e9, c5), p6 = k(m2, _(c2.get(), i6, m2), c5, f2.get());
  h2(p6, p6);
  const u4 = L(c2.get(), t5, p6);
  return Math.atan2(u4[1], u4[0]);
}
function k(e9, t5, r5, n6) {
  const a3 = z(c2.get(), e9), i6 = z(c2.get(), t5), l3 = _(c2.get(), a3, i6);
  return n6[0] = a3[0], n6[1] = a3[1], n6[2] = a3[2], n6[3] = 0, n6[4] = i6[0], n6[5] = i6[1], n6[6] = i6[2], n6[7] = 0, n6[8] = l3[0], n6[9] = l3[1], n6[10] = l3[2], n6[11] = 0, n6[12] = r5[0], n6[13] = r5[1], n6[14] = r5[2], n6[15] = 1, n6;
}
function F2(t5, r5) {
  const n6 = t5.getViewForGraphic(r5);
  return r(n6) && "computeAttachmentOrigin" in n6 ? n6.computeAttachmentOrigin(r5, t5.spatialReference) : null;
}
function v2(t5, r5, n6) {
  const o6 = F2(t5, n6);
  r(o6) ? r5.elevationAlignedLocation = o6 : A(r5, n6.geometry);
}
function A(e9, r5) {
  if (t(r5))
    return;
  const n6 = "mesh" === r5.type ? r5.anchor : w(r5);
  t(n6) || (e9.location = f4(n6));
}

export {
  te,
  q3 as q,
  w3 as w,
  b3 as b,
  y2 as y,
  O7 as O,
  k,
  F2 as F,
  v2 as v
};
//# sourceMappingURL=chunk-EEPTXXKK.js.map
