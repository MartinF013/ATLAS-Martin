import {
  d as d9,
  f as f11,
  g as g8
} from "./chunk-O2JKFSHC.js";
import {
  W as W2
} from "./chunk-76A4CWFG.js";
import {
  a as a11
} from "./chunk-KYD2B4O6.js";
import {
  J as J3
} from "./chunk-Y7MFFYJY.js";
import {
  d as d8,
  h as h10,
  s as s8,
  u as u10
} from "./chunk-KW6WHTET.js";
import {
  m as m9
} from "./chunk-PUU4QXN5.js";
import {
  L as L4,
  O as O6,
  P as P3,
  R as R6,
  d as d7,
  d2 as d11,
  f as f10,
  g as g7,
  j as j7,
  m as m8,
  p as p10,
  t as t13,
  v as v8,
  x as x5
} from "./chunk-EHWEX2VK.js";
import {
  D as D3,
  F as F4,
  O as O4,
  S as S3,
  U as U2,
  V as V3,
  t as t11,
  w as w4,
  z as z3
} from "./chunk-HPO2NV7P.js";
import {
  A as A4,
  H as H2,
  _e,
  d as d10
} from "./chunk-Y75V5CF3.js";
import {
  O as O5
} from "./chunk-PQM6RARY.js";
import {
  K
} from "./chunk-5ZS6RUSM.js";
import {
  A as A3,
  a as a9,
  f as f9
} from "./chunk-HTS3HEEU.js";
import {
  M as M4,
  p as p12
} from "./chunk-CYT6A5IX.js";
import {
  P as P4,
  a as a12
} from "./chunk-QWEWSWF7.js";
import {
  r as r14
} from "./chunk-7LH2XNVI.js";
import {
  e as e15,
  x as x6
} from "./chunk-PGSJOMCO.js";
import {
  a as a10,
  e as e14,
  o as o16
} from "./chunk-LJAT5UYW.js";
import {
  T as T3
} from "./chunk-52W4YMC2.js";
import {
  T as T4
} from "./chunk-MHEQOIKQ.js";
import {
  E as E8,
  t2 as t10
} from "./chunk-AIONJO5O.js";
import {
  a as a8,
  i as i9,
  i2 as i10
} from "./chunk-YLSPLHY5.js";
import {
  r as r13
} from "./chunk-4GGQTXXY.js";
import {
  u as u11
} from "./chunk-MCSRSOMA.js";
import {
  p as p11
} from "./chunk-2DP653N7.js";
import {
  G as G3
} from "./chunk-XEWFCJLT.js";
import {
  s as s6
} from "./chunk-ZEIWFXXO.js";
import {
  B as B3,
  J as J2,
  R as R5,
  _ as _6
} from "./chunk-X7CKOX5Z.js";
import {
  B as B2,
  d as d6,
  g as g4,
  g2 as g5,
  h as h9,
  p as p7
} from "./chunk-7OZR6JFF.js";
import {
  P as P2,
  e as e11,
  e2 as e12,
  f as f8,
  i as i6,
  l as l17,
  m as m7,
  o as o13,
  o2 as o14,
  s as s7,
  t as t9
} from "./chunk-NXOQBIK7.js";
import {
  A as A2,
  E as E6
} from "./chunk-ERNXFM5T.js";
import {
  i as i7
} from "./chunk-6ITXWFMK.js";
import {
  e as e13
} from "./chunk-SV4VP57N.js";
import {
  L as L3
} from "./chunk-5LWMNFCG.js";
import {
  E as E5,
  S as S2,
  _ as _4,
  c as c12,
  f as f7,
  i as i5,
  l as l16
} from "./chunk-5EXPMKQP.js";
import {
  W,
  a as a7,
  c as c11,
  h as h8,
  l as l15,
  o as o12
} from "./chunk-B7F3T673.js";
import {
  f as f6
} from "./chunk-FUKESVWQ.js";
import {
  E as E3,
  R as R4,
  c as c10
} from "./chunk-T3KDRLPE.js";
import {
  i as i4
} from "./chunk-E3V32BOJ.js";
import {
  n as n11,
  o as o15
} from "./chunk-EPNT7GPS.js";
import {
  r as r12
} from "./chunk-ODYLXHP4.js";
import {
  l as l14
} from "./chunk-DVE4HUBR.js";
import {
  v as v7
} from "./chunk-5JKCNCL2.js";
import {
  h as h6
} from "./chunk-TTKSAULB.js";
import {
  t as t8
} from "./chunk-WJDUBZ7S.js";
import {
  o as o10
} from "./chunk-TEJEYVH4.js";
import {
  h as h5,
  l as l11
} from "./chunk-EYJ2F5XB.js";
import {
  c as c8,
  l as l10
} from "./chunk-5EPJG7SL.js";
import {
  f as f4
} from "./chunk-XXEJXJP4.js";
import {
  c as c7
} from "./chunk-MFOJFHT7.js";
import {
  o as o6
} from "./chunk-TR3U55RZ.js";
import {
  T as T2
} from "./chunk-3DCTMZI6.js";
import {
  D as D2,
  F as F3,
  I,
  R as R2
} from "./chunk-FPMD6IB4.js";
import {
  R as R3,
  V as V2,
  j as j4,
  k as k2,
  v as v4
} from "./chunk-FFHGE66H.js";
import {
  r as r9,
  t as t4
} from "./chunk-MOZ4GR2L.js";
import {
  T,
  a as a4,
  b as b2,
  c as c5,
  d as d2,
  h as h4,
  i as i2,
  l as l9,
  u as u7,
  x as x2
} from "./chunk-MQBVOUKB.js";
import {
  U as U3,
  i as i11,
  t as t12
} from "./chunk-WQLER7IU.js";
import {
  O as O3,
  U,
  d2 as d5,
  h as h7,
  o2 as o11,
  v as v6,
  x as x4
} from "./chunk-EEJIELE6.js";
import {
  E as E4,
  p as p6
} from "./chunk-Y55TYMBP.js";
import {
  C,
  O as O2,
  c as c9,
  l as l12,
  n as n9,
  u as u9
} from "./chunk-MDCKEJ7B.js";
import {
  n as n10
} from "./chunk-MLAOYRDT.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  e as e10
} from "./chunk-NAIF4GWX.js";
import {
  x as x3
} from "./chunk-RIOXX6J2.js";
import {
  J,
  v as v5,
  w as w3
} from "./chunk-SOZCO2CU.js";
import {
  Z,
  _ as _7,
  b2 as b3,
  l as l18,
  p as p8,
  p2 as p9,
  q2 as q4
} from "./chunk-53KI6WDE.js";
import {
  C as C2,
  E as E7,
  _ as _5,
  j as j6
} from "./chunk-W2HLA6I3.js";
import {
  e as e8,
  o as o7,
  r as r8
} from "./chunk-YFBAFAZ2.js";
import {
  e as e7
} from "./chunk-LUU3J646.js";
import {
  t as t5
} from "./chunk-RB3LJE4I.js";
import {
  a as a5,
  j as j3,
  o as o8,
  u as u8
} from "./chunk-3NPGGTI6.js";
import {
  _ as _3,
  j as j2,
  l as l8,
  o as o5,
  q as q3,
  r as r7,
  s as s5,
  v as v3
} from "./chunk-YZNDHJDJ.js";
import {
  g as g6
} from "./chunk-RRFFPL7N.js";
import {
  l as l13
} from "./chunk-ZN2MGN4S.js";
import {
  L as L2
} from "./chunk-JZY7CGEI.js";
import {
  e as e9,
  f as f5,
  n as n8,
  r as r11,
  t as t7
} from "./chunk-RTHP2LNT.js";
import {
  te
} from "./chunk-6SWQ7R36.js";
import {
  An,
  Hn,
  Un,
  dn,
  ne,
  qn,
  zn
} from "./chunk-PZWU5EHT.js";
import {
  r as r10
} from "./chunk-7ZPDA3EC.js";
import {
  _ as _2,
  l as l5,
  n as n4,
  r as r5,
  t as t3
} from "./chunk-U7B2WKBH.js";
import {
  a as a6,
  n as n6
} from "./chunk-QKRZMDWG.js";
import {
  b,
  c as c3,
  h as h2,
  i,
  l as l6,
  m as m4,
  n as n5,
  p as p4,
  r as r6,
  s as s4,
  u as u4,
  x
} from "./chunk-ASC3X65B.js";
import {
  N as N2
} from "./chunk-2EZYA7VW.js";
import {
  n as n7
} from "./chunk-P6G64ARX.js";
import {
  m as m6
} from "./chunk-GD6ALUPQ.js";
import {
  p as p3,
  z
} from "./chunk-RN2KRYDN.js";
import {
  d as d4,
  i as i3,
  j as j5,
  o as o9
} from "./chunk-TADZYUVR.js";
import {
  c as c6,
  t as t6
} from "./chunk-HFDYAQZS.js";
import {
  d as d3
} from "./chunk-HJHWUUQQ.js";
import {
  A,
  B,
  E as E2,
  F as F2,
  G as G2,
  H,
  M as M3,
  R,
  S,
  V,
  a as a3,
  c as c4,
  f as f3,
  g as g3,
  h as h3,
  l as l7,
  p as p5,
  q as q2,
  u as u6,
  w as w2
} from "./chunk-TMBOFNWA.js";
import {
  D,
  M as M2,
  m as m5,
  u as u5
} from "./chunk-56RHM4A6.js";
import {
  i as i8
} from "./chunk-D7DLEBS2.js";
import {
  n as n3
} from "./chunk-OIPX3EDD.js";
import {
  e as e6,
  u as u3
} from "./chunk-NWRK6QLX.js";
import {
  It,
  nt
} from "./chunk-5N3FSR63.js";
import {
  l as l4
} from "./chunk-FVPTCNCX.js";
import {
  N,
  l as l3,
  o as o4
} from "./chunk-BPZGJQOB.js";
import {
  a as a2,
  l as l2,
  r as r4
} from "./chunk-ZOKX6UGH.js";
import {
  G,
  L,
  P,
  _,
  c as c2,
  e as e5,
  g as g2,
  j,
  o as o3,
  q,
  r as r3,
  s as s3,
  u as u2,
  z as z2
} from "./chunk-PKZEO23A.js";
import {
  e as e4,
  f as f2,
  l,
  n as n2,
  r as r2
} from "./chunk-AIRC226G.js";
import {
  o as o2,
  t as t2
} from "./chunk-BNPOKP6A.js";
import {
  m as m3
} from "./chunk-CHNDTVQJ.js";
import {
  v2
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  e as e3
} from "./chunk-5EQKHR4M.js";
import {
  d,
  f,
  g,
  k,
  m as m2,
  p as p2,
  v,
  w
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  E,
  F,
  a,
  c,
  e as e2,
  h,
  m,
  n,
  o,
  p,
  r,
  t,
  u
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationQuery.js
var n12 = class {
  constructor(e25, t20) {
    this.spatialReference = e25, this.view = t20;
  }
  getElevation(e25, t20, r24) {
    return this.view.elevationProvider.getElevation(e25, t20, 0, this.spatialReference, r24);
  }
  async queryElevation(e25, t20, r24, s16, i17) {
    return this.view.elevationProvider.queryElevation(e25, t20, 0, this.spatialReference, i17, r24, s16);
  }
};
var a13 = class {
  constructor(e25, t20, r24, s16) {
    this.spatialReference = t20, this._getElevationQueryProvider = r24, this._queries = new Array(), this._queryOptions = { ...s16, ignoreInvisibleLayers: true }, this._frameTask = e25.registerTask(L2.ELEVATION_QUERY, this);
  }
  destroy() {
    this._frameTask.remove();
  }
  queryElevation(t20, i17, o22, n24 = 0) {
    return new Promise((a21, l26) => {
      const u16 = { x: t20, y: i17, minDemResolution: n24, result: { resolve: a21, reject: l26 }, signal: o22 };
      this._queries.push(u16), v(o22, () => {
        F(this._queries, u16), l26(m2());
      });
    });
  }
  get running() {
    return this._queries.length > 0;
  }
  runTask() {
    const e25 = this._queries;
    this._queries = [];
    const i17 = this._getElevationQueryProvider();
    if (!i17)
      return void e25.forEach((e26) => e26.result.reject());
    const n24 = e25.map((e26) => [e26.x, e26.y]), a21 = e25.reduce((e26, t20) => Math.min(e26, t20.minDemResolution), 1 / 0), l26 = new m3({ points: n24, spatialReference: this.spatialReference }), u16 = e25.length > 1 && e25.some((e26) => !!e26.signal) ? new AbortController() : null, c21 = r(u16) ? u16.signal : e25[0].signal;
    if (r(u16)) {
      let t20 = 0;
      e25.forEach((i18) => v(i18.signal, () => {
        t20++, i18.result.reject(m2()), t20 === e25.length && u16.abort();
      }));
    }
    const h18 = { ...this._queryOptions, minDemResolution: a21, signal: c21 };
    i17.queryElevation(l26, h18).then((r24) => {
      e25.forEach((e26, i18) => {
        r(e26.signal) && e26.signal.aborted ? e26.result.reject(m2()) : e26.result.resolve(r24.geometry.points[i18][2]);
      });
    }).catch((t20) => {
      e25.forEach((e26) => e26.result.reject(t20));
    });
  }
  get test() {
    const e25 = this;
    return { update: () => e25._queries.length > 0 && e25.runTask() };
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/enums.js
var E9;
var C3;
!function(E19) {
  E19[E19.GRAPHIC = 0] = "GRAPHIC", E19[E19.LABEL = 1] = "LABEL", E19[E19._COUNT = 2] = "_COUNT";
}(E9 || (E9 = {})), function(E19) {
  E19[E19.USER_SETTING = 0] = "USER_SETTING", E19[E19.SCALE_RANGE = 1] = "SCALE_RANGE", E19[E19.FILTER = 2] = "FILTER", E19[E19.DECONFLICTION = 3] = "DECONFLICTION", E19[E19._COUNT = 4] = "_COUNT";
}(C3 || (C3 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DGraphicCreationContext.js
var r15 = class {
  constructor(r24, s16, t20) {
    this.graphic = r24, this.renderingInfo = s16, this.layer = t20;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationAligners.js
function p13(t20, e25, o22, a21) {
  const r24 = t20.stageObject, n24 = r24.geometryRecords;
  let s16 = 0;
  for (const i17 of n24) {
    const { update: t21, averageGeometrySampledElevation: n25 } = O7(i17, e25, o22, a21);
    s16 += n25, t21 && r24.geometryVertexAttrsUpdated(i17);
  }
  return s16 / n24.length;
}
function d12(t20, o22, r24, s16) {
  const l26 = t20.stageObject, f22 = o22.centerPointInElevationSR;
  let u16 = 0;
  if (l26.metadata.usesVerticalDistanceToGround)
    d7(f22, r24, o22, s16, M5), F4(l26, M5.verticalDistanceToGround), u16 = M5.sampledElevation;
  else {
    d7(f22, r24, o22, s16, M5);
    "absolute-height" !== o22.mode && (u16 = M5.sampledElevation);
  }
  const p21 = n5(g9, l26.transformation), d22 = o3(E10, p21[12], p21[13], p21[14]);
  t10.TESTS_DISABLE_OPTIMIZATIONS ? (T5[0] = f22.x, T5[1] = f22.y, T5[2] = M5.z, qn(f22.spatialReference, T5, p21, s16.spatialReference) && (l26.transformation = p21)) : s16.setAltitudeOfTransformation(M5.z, p21);
  const I7 = S4 / s16.unitInMeters;
  return (Math.abs(p21[12] - d22[0]) >= I7 || Math.abs(p21[13] - d22[1]) >= I7 || Math.abs(p21[14] - d22[2]) >= I7) && (l26.transformation = p21), u16;
}
var g9 = e8();
function I2(e25, o22, r24, s16) {
  const l26 = e25.graphics3DSymbolLayer.lodRenderer;
  if (t(l26))
    return 0;
  const c21 = o22.centerPointInElevationSR;
  d7(c21, r24, o22, s16, M5);
  const f22 = "absolute-height" !== o22.mode ? M5.sampledElevation : 0, u16 = l26.instanceData, p21 = e25.instanceIndex, d22 = A5;
  u16.getGlobalTransform(p21, d22);
  const g17 = o3(E10, d22[12], d22[13], d22[14]);
  t10.TESTS_DISABLE_OPTIMIZATIONS ? (T5[0] = c21.x, T5[1] = c21.y, T5[2] = M5.z, qn(c21.spatialReference, T5, d22, s16.spatialReference) && u16.setGlobalTransform(p21, d22)) : s16.setAltitudeOfTransformation(M5.z, d22);
  const I7 = S4 / s16.unitInMeters;
  return (t10.TESTS_DISABLE_OPTIMIZATIONS || Math.abs(d22[12] - g17[0]) >= I7 || Math.abs(d22[13] - g17[1]) >= I7 || Math.abs(d22[14] - g17[2]) >= I7) && u16.setGlobalTransform(p21, d22), f22;
}
function b4(t20, e25, o22, a21) {
  const r24 = t20.stageObject, n24 = r24.geometryRecords;
  if (0 === n24.length)
    return 0;
  let s16 = 0, i17 = null, l26 = 0, c21 = false;
  for (const m15 of n24) {
    const t21 = m15.geometry.vertexAttributes.get(O.POSITION);
    if (t21 !== i17) {
      const { update: r25, averageGeometrySampledElevation: n25 } = O7(m15, e25, o22, a21);
      l26 = n25, i17 = t21, c21 = r25;
    }
    c21 && r24.geometryVertexAttrsUpdated(m15), s16 += l26;
  }
  return s16 / n24.length;
}
var S4 = 0.01;
var T5 = n2();
var h11 = n2();
var v9 = n2();
var A5 = e8();
var E10 = n2();
var M5 = new j7();
function O7(t20, e25, o22, a21) {
  let r24 = false;
  const n24 = o22.spatialReference, l26 = t20.geometry, c21 = t20.getShaderTransformation(), p21 = e25.requiresSampledElevationInfo;
  h11[0] = c21[12], h11[1] = c21[13], h11[2] = c21[14], l26.invalidateBoundingInfo();
  const d22 = l26.getMutableAttribute(O.POSITION), g17 = d22.data, I7 = l26.vertexAttributes.get(O.MAPPOS).data, b13 = d22.size, A10 = g17.length / b13, E19 = new t11(I7, n24);
  let O15 = 0, y9 = 0;
  for (let f22 = 0; f22 < A10; f22++) {
    if (v9[0] = g17[O15], v9[1] = g17[O15 + 1], v9[2] = g17[O15 + 2], d7(E19, o22, e25, a21, M5), p21 && (y9 += M5.sampledElevation), t10.TESTS_DISABLE_OPTIMIZATIONS)
      g17[O15] = E19.array[E19.offset], g17[O15 + 1] = E19.array[E19.offset + 1], g17[O15 + 2] = M5.z, Un(g17, n24, O15, g17, a21.spatialReference, O15, 1), g17[O15] -= h11[0], g17[O15 + 1] -= h11[1], g17[O15 + 2] -= h11[2], r24 = true;
    else {
      T5[0] = g17[O15] + h11[0], T5[1] = g17[O15 + 1] + h11[1], T5[2] = g17[O15 + 2] + h11[2], a21.setAltitude(T5, M5.z), g17[O15] = T5[0] - h11[0], g17[O15 + 1] = T5[1] - h11[1], g17[O15 + 2] = T5[2] - h11[2];
      const t21 = S4 / a21.unitInMeters;
      (Math.abs(v9[0] - g17[O15]) >= t21 || Math.abs(v9[1] - g17[O15 + 1]) >= t21 || Math.abs(v9[2] - g17[O15 + 2]) >= t21) && (r24 = true);
    }
    O15 += b13, E19.offset += 3;
  }
  return y9 /= A10, { update: r24, averageGeometrySampledElevation: y9 };
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObject3DGraphicLayer.js
var p14 = class {
  constructor(e25, t20, s16, i17, a21, r24, n24, o22 = null) {
    this.graphics3DSymbolLayer = e25, this.stageObject = t20, this._uniqueGeometries = s16, this._uniqueMaterials = i17, this._sharedResource = a21, this.elevationAligner = r24, this.elevationContext = n24, this._edgeState = o22, this.type = "object3d", this._stageLayer = null, this._stage = null, this._visible = false, this._addedToStage = false, this.alignedSampledElevation = 0, this.needsElevationUpdates = false, this.useObjectOriginAsAttachmentOrigin = false, this.graphics3DSymbolLayer = e25, this.stageObject = t20;
  }
  get isElevationSource() {
    return !(!this.stageObject.metadata || !this.stageObject.metadata.isElevationSource);
  }
  initialize(e25, t20) {
    this._stageLayer = t20, this._stage = e25, e25.addMany(this._uniqueMaterials), e25.addMany(this._uniqueGeometries), e25.add(this.stageObject);
  }
  destroy() {
    const t20 = this._stage;
    this._stageLayer && (t20.removeMany(this._uniqueMaterials), t20.removeMany(this._uniqueGeometries)), t20.remove(this.stageObject), this._addedToStage && (this._stageLayer.remove(this.stageObject), this._addedToStage = false);
    const s16 = this._stage.renderView.ensureEdgeView();
    s16.hasObject(this.stageObject) && s16.removeObject(this.stageObject), this.stageObject.dispose(), r(this._sharedResource) && this._sharedResource.release(), this._visible = false, this._stageLayer = null, this._stage = null;
  }
  layerOpacityChanged(e25, s16) {
    if (t(this._edgeState))
      return;
    const i17 = v10(this._edgeState.baseMaterial);
    let a21 = false;
    for (const t20 of this._edgeState.edgeMaterials)
      t20.objectTransparency !== i17 && (t20.objectTransparency = i17, a21 = true);
    a21 && this._resetEdgeObject(s16);
    this._stage.renderView.ensureEdgeView().updateAllComponentOpacities(this.stageObject, [e25]);
  }
  slicePlaneEnabledChanged(e25, s16) {
    if (t(this._edgeState))
      return;
    this._stage.renderView.ensureEdgeView().updateAllComponentMaterials(this.stageObject, this._edgeState.edgeMaterials, { hasSlicePlane: e25 }, !s16), this._edgeState.properties.hasSlicePlane = e25;
  }
  setVisibility(t20) {
    if (null != this._stage && this._visible !== t20 && (this._visible = t20, this._visible ? this._addedToStage ? this.stageObject.setVisible(true) : (this._stageLayer.add(this.stageObject), this._addedToStage = true) : this.stageObject.setVisible(false), r(this._edgeState))) {
      const e25 = this._stage.renderView.ensureEdgeView();
      e25.hasObject(this.stageObject) ? e25.updateObjectVisibility(this.stageObject, t20) : t20 && this._addOrUpdateEdgeObject(e25, false);
    }
  }
  get visible() {
    return this._visible;
  }
  alignWithElevation(t20, s16, i17, a21) {
    null != this.elevationAligner && (r(i17) && s8(this.elevationContext.featureExpressionInfoContext, i17), this.alignedSampledElevation = this.elevationAligner(this, this.elevationContext, t20, s16), this._resetEdgeObject(a21));
  }
  getCenterObjectSpace(e25 = n2()) {
    return r3(e25, E7(this.stageObject.boundingVolumeObjectSpace.bounds));
  }
  getBoundingBoxObjectSpace(e25 = a3()) {
    const t20 = this.stageObject.boundingVolumeObjectSpace;
    return q2(e25, t20.min), w2(e25, t20.max), e25;
  }
  computeAttachmentOrigin(e25) {
    if (this.useObjectOriginAsAttachmentOrigin) {
      const t20 = this.stageObject.transformation;
      e25.render.origin[0] += t20[12], e25.render.origin[1] += t20[13], e25.render.origin[2] += t20[14], e25.render.num++;
    } else
      for (const t20 of this.stageObject.geometryRecords)
        t20.computeAttachmentOrigin(y) && (L(y, y, this.stageObject.transformation), u2(e25.render.origin, e25.render.origin, y), e25.render.num++);
  }
  async getProjectedBoundingBox(e25, t20, i17, r24, n24) {
    const o22 = this.getBoundingBoxObjectSpace(n24), c21 = E11, h18 = S(o22) ? 1 : c21.length;
    for (let s16 = 0; s16 < h18; s16++) {
      const e26 = c21[s16];
      S5[0] = o22[e26[0]], S5[1] = o22[e26[1]], S5[2] = o22[e26[2]], L(S5, S5, this.stageObject.transformation), f12[3 * s16 + 0] = S5[0], f12[3 * s16 + 1] = S5[1], f12[3 * s16 + 2] = S5[2];
    }
    if (!e25(f12, 0, h18))
      return null;
    B(o22);
    let u16 = null;
    this.calculateRelativeScreenBounds && (u16 = this.calculateRelativeScreenBounds());
    for (let s16 = 0; s16 < 3 * h18; s16 += 3) {
      for (let e26 = 0; e26 < 3; e26++)
        o22[e26] = Math.min(o22[e26], f12[s16 + e26]), o22[e26 + 3] = Math.max(o22[e26 + 3], f12[s16 + e26]);
      u16 && i17.push({ location: f12.slice(s16, s16 + 3), screenSpaceBoundingRect: u16 });
    }
    if (t20 && t20.service && "absolute-height" !== this.elevationContext.mode) {
      p5(o22, y);
      const e26 = "relative-to-scene" === this.elevationContext.mode ? "scene" : "ground";
      let i18 = 0;
      if (t20.useViewElevation)
        i18 = c(t20.service.getElevation(y[0], y[1], e26), 0);
      else
        try {
          const a21 = V3(o22, t20);
          i18 = c(await t20.service.queryElevation(y[0], y[1], r24, a21, e26), 0);
        } catch (O15) {
        }
      V(o22, 0, 0, -this.alignedSampledElevation + i18);
    }
    return o22;
  }
  addObjectState(e25, t20) {
    e25 === u9.Highlight && t20.addObject(this.stageObject, this.stageObject.highlight()), e25 === u9.MaskOccludee && t20.addObject(this.stageObject, this.stageObject.maskOccludee());
  }
  removeObjectState(e25) {
    e25.removeObject(this.stageObject);
  }
  _resetEdgeObject(e25) {
    if (t(this._edgeState))
      return;
    const s16 = this._stage.renderView.ensureEdgeView();
    this._visible ? this._addOrUpdateEdgeObject(s16, e25) : s16.removeObject(this.stageObject);
  }
  _addOrUpdateEdgeObject(e25, s16) {
    const i17 = this._edgeState;
    if (t(i17))
      return;
    const a21 = v10(i17.baseMaterial);
    for (const t20 of i17.edgeMaterials)
      t20.objectTransparency = a21;
    e25.addOrUpdateObject3D(this.stageObject, i17.edgeMaterials, i17.properties, !s16).then(() => {
      var _a;
      return (_a = this._stageLayer) == null ? void 0 : _a.sync();
    });
  }
};
function v10(e25) {
  return e25.isVisible ? e25.parameters.transparent ? A3.TRANSPARENT : A3.OPAQUE : A3.INVISIBLE;
}
var f12 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var S5 = n2();
var y = n2();
var E11 = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]];

// node_modules/@arcgis/core/views/3d/layers/graphics/interfaces.js
var e16;
!function(e25) {
  e25[e25.Recreate_Symbol = 0] = "Recreate_Symbol", e25[e25.Recreate_Graphics = 1] = "Recreate_Graphics", e25[e25.Fast_Update = 2] = "Fast_Update";
}(e16 || (e16 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Loadable.js
var a14 = class {
  constructor(t20) {
    this.schedule = t20, this._loadStatus = e17.LOADING, this.logger = null;
  }
  destroy() {
    this.abortLoad();
  }
  get loadStatus() {
    return this._loadStatus;
  }
  load(r24, s16) {
    return this._loadStatus === e17.LOADED ? (r24 && r24(), e2(this._loader)) : this._loadStatus === e17.FAILED ? (s16 && s16(this._loadError), e2(this._loader)) : (t(this._loader) && (this._abortController = new AbortController(), this._loader = this.doLoad(this._abortController.signal).then(() => {
      this._abortController = null, this._loadStatus = e17.LOADED;
    }, (t20) => {
      throw this._loadError = t20, this._abortController = null, this._loadStatus = e17.FAILED, !g(t20) && this.logger && t20.message && this.logger.warn(t20.message), t20;
    })), this._loader.then(r24, s16).catch(() => {
    }), this._loader);
  }
  abortLoad() {
    r(this._abortController) ? this._abortController = h(this._abortController) : this._loadStatus === e17.LOADING && (this._loadStatus = e17.FAILED), this._loader = null;
  }
};
var e17;
!function(t20) {
  t20[t20.LOADING = 0] = "LOADING", t20[t20.LOADED = 1] = "LOADED", t20[t20.FAILED = 2] = "FAILED";
}(e17 || (e17 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/primitiveObjectSymbolUtils.js
function n13(e25) {
  switch (e25) {
    case "sphere":
    case "cube":
    case "diamond":
    case "cylinder":
    case "cone":
    case "inverted-cone":
    case "tetrahedron":
      return true;
  }
  return false;
}
function t14(n24, t20) {
  const r24 = (n25, a21, r25 = false) => ({ levels: n25.map((n26) => {
    const c21 = a21(n26.tesselation);
    return r25 && T3.cgToGIS(c21), { components: [{ geometry: c21, material: t20 }], faceCount: c21.indexCount / 3, minScreenSpaceRadius: n26.minScreenSpaceRadius };
  }) });
  switch (n24) {
    case "sphere":
      return r24([{ tesselation: 0, minScreenSpaceRadius: 0 }, { tesselation: 1, minScreenSpaceRadius: 8 }, { tesselation: 2, minScreenSpaceRadius: 16 }, { tesselation: 3, minScreenSpaceRadius: 50 }, { tesselation: 4, minScreenSpaceRadius: 250 }], (n25) => T3.createPolySphereGeometry(0.5, n25, true));
    case "cube":
      return r24([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => T3.createBoxGeometry(1));
    case "cone":
      return r24(a15, (n25) => T3.createConeGeometry(1, 0.5, n25, false), true);
    case "inverted-cone":
      return r24(a15, (n25) => T3.createConeGeometry(1, 0.5, n25, true), true);
    case "cylinder":
      return r24(a15, (n25) => T3.createCylinderGeometry(1, 0.5, n25, [0, 0, 1], [0, 0, 0.5]));
    case "tetrahedron":
      return r24([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => T3.createTetrahedronGeometry(1), true);
    case "diamond":
      return r24([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => T3.createDiamondGeometry(1), true);
    default:
      return;
  }
}
var a15 = [{ tesselation: 6, minScreenSpaceRadius: 0 }, { tesselation: 18, minScreenSpaceRadius: 7 }, { tesselation: 64, minScreenSpaceRadius: 65 }];

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodResources.js
function r16(r24) {
  const e25 = [];
  return r24.levels.forEach((o22) => {
    o22.components.forEach((o23) => {
      e25.push(o23.material);
    });
  }), u(e25);
}
function e18(r24) {
  const e25 = new Array();
  return r24.levels.forEach((o22) => {
    o22.components.forEach((o23) => {
      o23.textures && e25.push(...o23.textures);
    });
  }), u(e25);
}
function n14(r24) {
  const e25 = [];
  return r24.components.forEach((o22) => {
    e25.push(o22.geometry);
  }), u(e25);
}
function t15(r24) {
  const e25 = [];
  return r24.levels.forEach((o22) => {
    o22.components.forEach((o23) => {
      e25.push(o23.geometry);
    });
  }), u(e25);
}
function c13(o22) {
  return n14(o22).reduce((o23, r24) => o23 + r24.indexCount / 3, 0);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/symbolComplexity.js
var b5 = { primitivesPerFeature: 0, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: true, memory: { bytesPerFeature: 0, bytesPerCoordinate: 0, bytesPerFeatureLabel: 0, draped: { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0 } } };
function P5(e25) {
  if ("web-style" === e25.type)
    return b5;
  return d13(e25.symbolLayers.toArray().map((r24) => m10(e25, r24)));
}
function d13(e25) {
  let t20 = 0, a21 = 0, s16 = 0, i17 = false, o22 = 0;
  const u16 = { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0, draped: { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0 } };
  for (const b13 of e25)
    t(b13) || (t20 += b13.primitivesPerFeature, a21 += b13.primitivesPerCoordinate, s16 += b13.drawCallsPerFeature, u16.bytesPerFeature += b13.memory.bytesPerFeature, u16.bytesPerFeatureLabel += b13.memory.bytesPerFeatureLabel, u16.bytesPerCoordinate += b13.memory.bytesPerCoordinate, u16.draped.bytesPerFeature += b13.memory.bytesPerFeature, u16.draped.bytesPerFeatureLabel += b13.memory.bytesPerFeatureLabel, u16.draped.bytesPerCoordinate += b13.memory.bytesPerCoordinate, i17 = i17 || b13.estimated, ++o22);
  return { primitivesPerFeature: t20, primitivesPerCoordinate: a21, drawCallsPerFeature: s16, estimated: i17, memory: u16, numComplexities: o22 };
}
function y2(e25) {
  const r24 = d13(e25);
  return r24.numComplexities > 0 && (r24.primitivesPerFeature /= r24.numComplexities, r24.primitivesPerCoordinate /= r24.numComplexities, r24.drawCallsPerFeature /= r24.numComplexities, r24.memory.bytesPerFeature /= r24.numComplexities, r24.memory.bytesPerFeatureLabel /= r24.numComplexities, r24.memory.bytesPerCoordinate /= r24.numComplexities, r24.memory.draped.bytesPerFeature /= r24.numComplexities, r24.memory.draped.bytesPerFeatureLabel /= r24.numComplexities, r24.memory.draped.bytesPerCoordinate /= r24.numComplexities), r24;
}
var n15 = {};
function m10(r24, s16) {
  const o22 = l19(r24, s16), u16 = a9(s16) ? 2 : 0;
  switch (s16.type) {
    case "extrude":
      return { primitivesPerFeature: -4, primitivesPerCoordinate: 4, drawCallsPerFeature: u16, estimated: false, memory: o22 };
    case "fill":
      return "mesh-3d" === r24.type ? { primitivesPerFeature: 0, primitivesPerCoordinate: 0, drawCallsPerFeature: u16, estimated: false, memory: o22 } : r(s16.outline) && s16.outline.size > 0 ? { primitivesPerFeature: -4, primitivesPerCoordinate: 3, drawCallsPerFeature: 0, estimated: false, memory: o22 } : { primitivesPerFeature: -2, primitivesPerCoordinate: 1, drawCallsPerFeature: 0, estimated: false, memory: o22 };
    case "water":
      return { primitivesPerFeature: -2, primitivesPerCoordinate: 1, drawCallsPerFeature: 0, estimated: false, memory: o22 };
    case "line":
      return { primitivesPerFeature: -2, primitivesPerCoordinate: 2, drawCallsPerFeature: 0, estimated: false, memory: o22 };
    case "object":
      if (s16.resource && s16.resource.href)
        return { primitivesPerFeature: 16, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: true, memory: o22 };
      return { ...F5(s16.resource && s16.resource.primitive || d4), memory: o22 };
    case "path": {
      const r25 = 3, t20 = 3, a21 = 10;
      let i17 = 0, u17 = 0;
      switch (s16.profile) {
        case "circle":
          i17 = a21;
          break;
        case "quad":
          i17 = 4;
          break;
        default:
          return void n7(s16.profile);
      }
      switch (s16.join) {
        case "round":
          u17 = r25;
          break;
        case "miter":
        case "bevel":
          u17 = 1;
          break;
        default:
          return void n7(s16.join);
      }
      const b13 = 2 * i17, P10 = i17 * u17 * 2;
      let d22 = -2 * P10 - b13;
      switch (s16.cap) {
        case "none":
          break;
        case "butt":
        case "square":
          d22 += 2 * (i17 - 1);
          break;
        case "round":
          d22 += 2 * (i17 * (t20 - 1) * 2 + i17);
          break;
        default:
          return;
      }
      return { primitivesPerFeature: d22, primitivesPerCoordinate: P10 + b13, drawCallsPerFeature: 0, estimated: false, memory: o22 };
    }
    case "text":
    case "icon":
      return { primitivesPerFeature: 2, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false, memory: o22 };
    default:
      return;
  }
}
function l19(r24, a21) {
  const s16 = "point-3d" === r24.type;
  switch (a21.type) {
    case "extrude":
      return a21.edges && a21.edges.size > 0 ? C4.EXTRUDE_EDGES : C4.EXTRUDE;
    case "fill":
      return r(a21.outline) && a21.outline.size > 0 ? C4.FILL_OUTLINE : C4.FILL;
    case "water":
      return C4.FILL;
    case "line":
      return "round" === a21.join ? C4.LINE_ROUND : C4.LINE_MITER;
    case "path":
      switch (a21.join) {
        case "round":
          switch (a21.profile) {
            case "circle":
              return C4.PATH_ROUND_CIRCLE;
            case "quad":
              return C4.PATH_ROUND_QUAD;
            default:
              return void n7(a21.profile);
          }
        case "miter":
        case "bevel":
          switch (a21.profile) {
            case "circle":
              return C4.PATH_MITER_CIRCLE;
            case "quad":
              return C4.PATH_MITER_QUAD;
            default:
              return void n7(a21.profile);
          }
        default:
          return void n7(a21.join);
      }
    case "object":
      return s16 ? C4.OBJECT_POINT : C4.OBJECT_POLYGON;
    case "icon":
    case "text":
      return s16 ? C4.ICON_POINT : C4.ICON_POLYGON;
    default:
      return;
  }
}
function F5(e25) {
  let r24 = n15[e25];
  if (r24)
    return r24;
  const t20 = t14(e25, null);
  return r24 = { primitivesPerFeature: n14(t20.levels[0]).reduce((e26, r25) => e26 + r25.indices.get(O.POSITION).length / 3, 0), primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false }, n15[e25] = r24, r24;
}
var C4 = { ICON_POINT: { bytesPerFeature: 7127.413186968842, bytesPerFeatureLabel: 4826.302896296296, bytesPerCoordinate: 0, draped: { bytesPerFeature: 3929.4396628895197, bytesPerFeatureLabel: 3550.1332222222227, bytesPerCoordinate: 0 } }, ICON_POLYGON: { bytesPerFeature: 9329.452613976147, bytesPerFeatureLabel: 3675.3372604938268, bytesPerCoordinate: 60.177252982212096, draped: { bytesPerFeature: 6190.247450139383, bytesPerFeatureLabel: 3744.074358024691, bytesPerCoordinate: 59.488211068026104 } }, OBJECT_POINT: { bytesPerFeature: 2350.5884192634558, bytesPerFeatureLabel: 4446.651003703703, bytesPerCoordinate: 0, draped: { bytesPerFeature: 2350.5884192634558, bytesPerFeatureLabel: 4446.651003703703, bytesPerCoordinate: 0 } }, OBJECT_POLYGON: { bytesPerFeature: 4583.807620302299, bytesPerFeatureLabel: 3665.342685185186, bytesPerCoordinate: 60.11621818101506, draped: { bytesPerFeature: 4583.807620302299, bytesPerFeatureLabel: 3665.342685185186, bytesPerCoordinate: 60.11621818101506 } }, LINE_MITER: { bytesPerFeature: 7321.028181375921, bytesPerFeatureLabel: 4048.0226716049388, bytesPerCoordinate: 186.55621386363578, draped: { bytesPerFeature: 4246.856619435009, bytesPerFeatureLabel: 3852.3737679012347, bytesPerCoordinate: 163.47884002621583 } }, LINE_ROUND: { bytesPerFeature: 7482.205842738954, bytesPerFeatureLabel: 4045.886987654321, bytesPerCoordinate: 191.5452524171851, draped: { bytesPerFeature: 4473.481387957992, bytesPerFeatureLabel: 3842.1112395061728, bytesPerCoordinate: 167.27703460226945 } }, PATH_MITER_CIRCLE: { bytesPerFeature: 9010.489006415351, bytesPerFeatureLabel: 4230.9109, bytesPerCoordinate: 4618.2594178027275, draped: { bytesPerFeature: 9010.489006415351, bytesPerFeatureLabel: 4230.9109, bytesPerCoordinate: 4618.2594178027275 } }, PATH_ROUND_CIRCLE: { bytesPerFeature: 4104.727250200398, bytesPerFeatureLabel: 4251.8525, bytesPerCoordinate: 8019.043777064957, draped: { bytesPerFeature: 4104.727250200398, bytesPerFeatureLabel: 4251.8525, bytesPerCoordinate: 8019.043777064957 } }, PATH_MITER_QUAD: { bytesPerFeature: 9416.372942261387, bytesPerFeatureLabel: 4241.2757, bytesPerCoordinate: 3176.7222742582203, draped: { bytesPerFeature: 9416.372942261387, bytesPerFeatureLabel: 4241.2757, bytesPerCoordinate: 3176.7222742582203 } }, PATH_ROUND_QUAD: { bytesPerFeature: 6614.431545308682, bytesPerFeatureLabel: 4206.7461, bytesPerCoordinate: 5141.817789093826, draped: { bytesPerFeature: 6614.431545308682, bytesPerFeatureLabel: 4206.7461, bytesPerCoordinate: 5141.817789093826 } }, FILL: { bytesPerFeature: 9478.244183633637, bytesPerFeatureLabel: 3713.816824691358, bytesPerCoordinate: 95.9343604185578, draped: { bytesPerFeature: 6287.911108168086, bytesPerFeatureLabel: 3790.785032098766, bytesPerCoordinate: 83.08783220478168 } }, FILL_OUTLINE: { bytesPerFeature: 13085.871870349445, bytesPerFeatureLabel: 3392.613241975309, bytesPerCoordinate: 118.63968023169875, draped: { bytesPerFeature: 8437.199992480122, bytesPerFeatureLabel: 3973.5431172839503, bytesPerCoordinate: 106.33556817014312 } }, EXTRUDE: { bytesPerFeature: 19459.53727140414, bytesPerFeatureLabel: 3743.7045209876546, bytesPerCoordinate: 372.6819978900477, draped: { bytesPerFeature: 19459.53727140414, bytesPerFeatureLabel: 3743.7045209876546, bytesPerCoordinate: 372.6819978900477 } }, EXTRUDE_EDGES: { bytesPerFeature: 22266.888534913724, bytesPerFeatureLabel: 3064.3193358024696, bytesPerCoordinate: 374.3725221561312, draped: { bytesPerFeature: 22266.888534913724, bytesPerFeatureLabel: 3064.3193358024696, bytesPerCoordinate: 374.3725221561312 } } };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolLayer.js
var f13 = s.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayer");
var y3 = class extends a14 {
  constructor(e25, t20, i17, o22) {
    super(i17.schedule), this._context = i17, this._elevationInfoOverride = null, this._ignoreDrivers = false, this._drivenProperties = { color: false, opacity: false, opacityAlwaysOpaque: true, size: false }, this.complexity = null, this.logger = f13, this._elevationOptions = { supportsOffsetAdjustment: false, supportsOnTheGround: true }, this.symbol = e25, this.symbolLayer = t20, this._renderPriority = o22.renderPriority, this._renderPriorityStep = o22.renderPriorityStep, this._elevationContext = new h10(), this.complexity = this.computeComplexity(), this._ignoreDrivers = o22.ignoreDrivers, this._ignoreDrivers || (this._drivenProperties = g10(this._context.renderer)), this._updateElevationContext();
  }
  getCachedSize() {
    return null;
  }
  get extentPadding() {
    return 0;
  }
  _drivenPropertiesChanged(e25) {
    if (this._ignoreDrivers)
      return false;
    const t20 = this._drivenProperties, i17 = g10(e25);
    return i17.color !== t20.color || i17.opacity !== t20.opacity || i17.opacityAlwaysOpaque !== t20.opacityAlwaysOpaque || i17.size !== t20.size;
  }
  get needsDrivenTransparentPass() {
    return this._drivenProperties.opacity && !this._drivenProperties.opacityAlwaysOpaque;
  }
  _logGeometryCreationWarnings(e25, t20, i17, o22) {
    const r24 = e25.projectionSuccess, n24 = "polygons" in e25 ? e25.polygons : null, s16 = `${o22} geometry failed to be created`;
    let a21 = null;
    r24 ? !t20.length || 1 === t20.length && !t20[0].length ? a21 = `${s16} (no ${i17} were defined)` : Array.isArray(t20) && Array.isArray(t20[0]) ? n24 && 0 === n24.length && "rings" === i17 && t20.length > 0 && t20[0].length > 2 && (a21 = `${s16} (filled rings should use clockwise winding - try reversing the order of vertices)`) : a21 = `${s16} (${i17} should be defined as a 2D array)` : a21 = `${s16} (failed to project geometry to view spatial reference)`, a21 && f13.warnOncePerTick(a21);
  }
  _validateGeometry(e25, t20 = null, o22 = null) {
    if (r(t20) && !t20.includes(e25.type))
      return this.logger.warn("unsupported geometry type for " + o22 + ` symbol: ${e25.type}`), false;
    if ("point" === e25.type) {
      const t21 = e25;
      if (!isFinite(t21.x) || !isFinite(t21.y))
        return f13.warn("point coordinate is not a valid number, graphic skipped"), false;
    }
    return true;
  }
  _defaultElevationInfoNoZ() {
    return m11;
  }
  _defaultElevationInfoZ() {
    return _8;
  }
  _updateElevationContext() {
    r(this._elevationInfoOverride) ? (this._elevationContext.setFromElevationInfo(this._elevationInfoOverride), this._elevationContext.updateFeatureExpressionInfoContext(null)) : this._context.layer.elevationInfo ? (this._elevationContext.setFromElevationInfo(this._context.layer.elevationInfo), this._elevationContext.updateFeatureExpressionInfoContext(this._context.featureExpressionInfoContext)) : this._elevationContext.reset();
  }
  getDefaultElevationInfo(e25) {
    return e25.hasZ ? this._defaultElevationInfoZ() : this._defaultElevationInfoNoZ();
  }
  getGeometryElevationMode(e25, t20 = this.getDefaultElevationInfo(e25)) {
    return this._elevationContext.mode || t20.mode;
  }
  setElevationInfoOverride(e25) {
    this._elevationInfoOverride = e25, this._updateElevationContext();
  }
  setGraphicElevationContext(e25, t20) {
    const i17 = e2(e25.geometry), n24 = this.getDefaultElevationInfo(i17);
    t20.unit = null != this._elevationContext.unit ? this._elevationContext.unit : n24.unit, t20.mode = this.getGeometryElevationMode(i17, n24), t20.offsetMeters = c(this._elevationContext.meterUnitOffset, c(n24.offset, 0));
    const s16 = !this._elevationOptions.supportsOnTheGround && "on-the-ground" === t20.mode;
    s16 && (t20.mode = "relative-to-ground", t20.offsetMeters = 0);
    const a21 = s16 ? d8 : this._elevationContext.featureExpressionInfoContext;
    return t20.updateFeatureExpressionInfoContext(a21, e25, this._context.layer), t20;
  }
  prepareSymbolLayerPatch(e25) {
  }
  updateGeometry(e25, t20) {
    return false;
  }
  onRemoveGraphic(e25) {
  }
  _getLayerOpacity() {
    if (this._context.graphicsCoreOwner && "fullOpacity" in this._context.graphicsCoreOwner)
      return this._context.graphicsCoreOwner.fullOpacity;
    const e25 = this._context.layer.opacity;
    return null == e25 ? 1 : e25;
  }
  _getCombinedOpacity(e25, t20 = x7) {
    let o22 = 1;
    return this.draped || (o22 *= this._getLayerOpacity()), this._drivenProperties.opacity || (r(e25) ? o22 *= e25.a : t20.hasIntrinsicColor || (o22 = 0)), o22;
  }
  _getCombinedOpacityAndColor(t20, o22 = x7) {
    const r24 = this._getCombinedOpacity(t20, o22);
    if (this._drivenProperties.color)
      return z3(null, r24);
    const s16 = r(t20) ? l4.toUnitRGB(t20) : l;
    return z3(s16, r24);
  }
  _getVertexOpacityAndColor(e25, t20 = null) {
    const o22 = this._drivenProperties.color ? e25.color : null, r24 = this._drivenProperties.opacity ? e25.opacity : null, n24 = z3(o22, r24);
    return r(t20) && (n24[0] *= t20, n24[1] *= t20, n24[2] *= t20, n24[3] *= t20), n24;
  }
  isFastUpdatesEnabled() {
    return this._fastUpdates && this._fastUpdates.enabled;
  }
  computeComplexity() {
    return m10(this.symbol, this.symbolLayer);
  }
  globalPropertyChanged(e25, t20, i17) {
    switch (e25) {
      case "opacity":
        return this.layerOpacityChanged(t20, i17);
      case "elevationInfo": {
        const e26 = this._elevationContext.mode;
        this._updateElevationContext();
        return this.layerElevationInfoChanged(t20, i17, e26) !== x5.RECREATE;
      }
      case "slicePlaneEnabled":
        return this.slicePlaneEnabledChanged(t20, i17);
      case "physicalBasedRenderingEnabled":
        return this.physicalBasedRenderingChanged();
      case "pixelRatio":
        return this.pixelRatioChanged();
      default:
        return false;
    }
  }
  updateGraphics3DGraphicElevationInfo(e25, t20, o22) {
    let r24 = x5.UPDATE;
    return e25.forEach((e26) => {
      const n24 = t20(e26);
      if (r(n24)) {
        const t21 = e26.graphic;
        this.setGraphicElevationContext(t21, n24.elevationContext), n24.needsElevationUpdates = o22(n24.elevationContext.mode);
      } else
        r24 = x5.RECREATE;
    }), r24;
  }
  applyRendererDiff(e25, t20) {
    return e16.Recreate_Symbol;
  }
  getFastUpdateAttrValues(e25) {
    if (!this._fastUpdates.enabled)
      return null;
    const t20 = this._fastUpdates.visualVariables, i17 = t20.size ? v11(t20.size.field, e25) : 0, o22 = t20.color ? v11(t20.color.field, e25) : 0, r24 = t20.opacity ? v11(t20.opacity.field, e25) : 0;
    return r5(i17, o22, r24, 0);
  }
  get draped() {
    return this._draped;
  }
  ensureDrapedStatus(e25) {
    return null == this._draped ? (this._draped = e25, true) : (e25 !== this.draped && f13.warnOnce("A symbol can only produce either draped or non-draped visualizations. Use two separate symbol instances for draped and non-draped graphics if necessary."), false);
  }
  test() {
    const e25 = () => {
      var _a, _b, _c, _d, _e6, _f, _g, _h, _i, _j, _k, _l;
      return { size: ((_c = (_b = (_a = this._fastUpdates) == null ? void 0 : _a.visualVariables) == null ? void 0 : _b.size) == null ? void 0 : _c.field) ?? null, color: ((_f = (_e6 = (_d = this._fastUpdates) == null ? void 0 : _d.visualVariables) == null ? void 0 : _e6.color) == null ? void 0 : _f.field) ?? null, opacity: ((_i = (_h = (_g = this._fastUpdates) == null ? void 0 : _g.visualVariables) == null ? void 0 : _h.opacity) == null ? void 0 : _i.field) ?? null, rotation: ((_l = (_k = (_j = this._fastUpdates) == null ? void 0 : _j.visualVariables) == null ? void 0 : _k.rotation) == null ? void 0 : _l.field) ?? null };
    };
    return { drivenProperties: this._drivenProperties, getVisVarFields: e25 };
  }
};
function v11(e25, t20) {
  const i17 = null != e25 ? t20.attributes[e25] : 0;
  return null != i17 && isFinite(i17) ? i17 : 0;
}
function g10(e25) {
  const t20 = { color: false, opacity: false, opacityAlwaysOpaque: true, size: false };
  return e25 && "visualVariables" in e25 && e25.visualVariables && e25.visualVariables.forEach((e26) => {
    switch (e26.type) {
      case "color":
        if (t20.color = true, e26.stops)
          for (let i17 = 0; i17 < e26.stops.length; i17++) {
            const o22 = e26.stops[i17].color;
            o22 && (t20.opacity = true, o22.a < 1 && (t20.opacityAlwaysOpaque = false));
          }
        break;
      case "opacity":
        t20.opacity = true, t20.opacityAlwaysOpaque = false;
        break;
      case "size":
        t20.size = true;
    }
  }), t20;
}
var m11 = { mode: "on-the-ground", offset: 0, unit: "meters" };
var _8 = { mode: "absolute-height", offset: 0, unit: "meters" };
var x7 = { hasIntrinsicColor: false };

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineCalloutTechnique.js
var h12 = class extends e11 {
  initializeConfiguration(i17, t20) {
    t20.spherical = i17.viewingMode === l13.Global;
  }
  initializeProgram(e25) {
    const i17 = h12.shader.get().build(this.configuration);
    return new o13(e25.rctx, i17, E4);
  }
  setPipelineState(e25) {
    const i17 = e25 ? I.ALWAYS : I.LESS;
    return this.configuration.depthHudEnabled ? W({ depthTest: { func: i17 }, depthWrite: a7 }) : W({ blending: l15(R2.ONE, R2.SRC_ALPHA, R2.ONE_MINUS_SRC_ALPHA, R2.ONE_MINUS_SRC_ALPHA), depthTest: { func: i17 }, colorWrite: c11 });
  }
  initializePipeline() {
    return this.setPipelineState(this.configuration.hasMultipassGeometry);
  }
};
h12.shader = new t9(u11, () => import("./LineCallout.glsl-ZWZ54IPI.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineCalloutTechniqueConfiguration.js
var i12 = class extends i7 {
  constructor() {
    super(...arguments), this.screenCenterOffsetUnitsEnabled = p11.World, this.spherical = false, this.occlusionTestEnabled = true, this.hasVerticalOffset = false, this.hasScreenSizePerspective = false, this.depthHudEnabled = false, this.depthHudAlignStartEnabled = false, this.hasSlicePlane = false, this.hasMultipassGeometry = false;
  }
};
e([e13({ count: p11.COUNT })], i12.prototype, "screenCenterOffsetUnitsEnabled", void 0), e([e13()], i12.prototype, "spherical", void 0), e([e13()], i12.prototype, "occlusionTestEnabled", void 0), e([e13()], i12.prototype, "hasVerticalOffset", void 0), e([e13()], i12.prototype, "hasScreenSizePerspective", void 0), e([e13()], i12.prototype, "depthHudEnabled", void 0), e([e13()], i12.prototype, "depthHudAlignStartEnabled", void 0), e([e13()], i12.prototype, "hasSlicePlane", void 0), e([e13()], i12.prototype, "hasMultipassGeometry", void 0), e([e13({ constValue: true })], i12.prototype, "hasSliceInVertexProgram", void 0), e([e13({ constValue: false })], i12.prototype, "isDraped", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/LineCalloutMaterial.js
var g11 = class extends d5 {
  constructor(e25) {
    super(e25, new S6()), this.techniqueConfig = new i12(), this._uniqueMaterialIdentifier = g11.uniqueMaterialIdentifier(this.parameters);
  }
  get uniqueMaterialIdentifier() {
    return this._uniqueMaterialIdentifier;
  }
  getPassParameters() {
    return this.parameters;
  }
  getConfiguration(t20, r24) {
    const i17 = (r24 == null ? void 0 : r24.slot) !== E6.LINE_CALLOUTS;
    return this.techniqueConfig.occlusionTestEnabled = this.parameters.occlusionTest, this.techniqueConfig.hasVerticalOffset = r(this.parameters.verticalOffset), this.techniqueConfig.hasScreenSizePerspective = r(this.parameters.screenSizePerspective), this.techniqueConfig.depthHudEnabled = i17, this.techniqueConfig.depthHudAlignStartEnabled = !!this.parameters.depthHUDAlignStart, this.techniqueConfig.screenCenterOffsetUnitsEnabled = "screen" === this.parameters.centerOffsetUnits ? p11.Screen : p11.World, this.techniqueConfig.hasSlicePlane = this.parameters.hasSlicePlane, this.techniqueConfig.hasMultipassGeometry = !!r24 && r24.multipassGeometry.enabled, this.techniqueConfig;
  }
  intersect() {
  }
  requiresSlot(e25) {
    switch (e25) {
      case E6.LINE_CALLOUTS:
      case E6.LINE_CALLOUTS_HUD_DEPTH:
        return true;
    }
    return false;
  }
  createGLMaterial(e25) {
    return e25.output === o10.Color ? new O8(e25) : null;
  }
  createBufferWriter() {
    return new C5();
  }
  validateParameters(e25) {
    const t20 = g11.uniqueMaterialIdentifier(e25);
    t20 !== this._uniqueMaterialIdentifier && (this._uniqueMaterialIdentifier = t20);
  }
  static uniqueMaterialIdentifier(e25) {
    return JSON.stringify({ screenOffset: e25.screenOffset || [0, 0], centerOffsetUnits: e25.centerOffsetUnits || "world" });
  }
};
var O8 = class extends t8 {
  beginSlot(e25) {
    return this.ensureTechnique(h12, e25);
  }
};
var S6 = class extends o11 {
  constructor() {
    super(...arguments), this.screenOffset = f5, this.color = [0, 0, 0, 1], this.size = 1, this.occlusionTest = false, this.shaderPolygonOffset = 1e-5, this.depthHUDAlignStart = false, this.centerOffsetUnits = "world", this.hasSlicePlane = false;
  }
};
var q5 = T2().vec3f(O.POSITION).vec3f(O.NORMAL).vec2f(O.UV0).vec4f(O.AUXPOS1);
var L5 = [t5(0, 0), t5(1, 0), t5(0, 1), t5(1, 0), t5(1, 1), t5(0, 1)];
var C5 = class {
  constructor() {
    this.vertexBufferLayout = q5;
  }
  allocate(e25) {
    return this.vertexBufferLayout.createBuffer(e25);
  }
  elementCount(e25) {
    return 6 * e25.indices.get(O.POSITION).length;
  }
  write(e25, t20, r24, i17) {
    p7(t20.indices.get(O.POSITION), t20.vertexAttributes.get(O.POSITION).data, e25.transformation, r24.position, i17, 6), B2(t20.indices.get(O.NORMAL), t20.vertexAttributes.get(O.NORMAL).data, e25.invTranspTransformation, r24.normal, i17, 6), d6(t20.indices.get(O.AUXPOS1), t20.vertexAttributes.get(O.AUXPOS1).data, r24.auxpos1, i17, 6);
    for (let s16 = 0; s16 < L5.length; ++s16)
      r24.uv0.setVec(i17 + s16, L5[s16]);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLineCalloutSymbolLayer.js
var b6 = class extends y3 {
  constructor(e25, t20) {
    super(e25, null, t20, U4), this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: false }, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    this._material = new g11(this.materialParameters), this._context.stage.add(this._material);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null;
  }
  _perInstanceMaterialParameters(e25) {
    const t20 = this.materialParameters;
    return t20.screenOffset = e25.screenOffset || f5, t20.centerOffsetUnits = e25.centerOffsetUnits || "world", t20;
  }
  get materialParameters() {
    const r24 = this.symbol, a21 = r24.callout, n24 = r(a21.color) ? l4.toUnitRGBA(a21.color) : [0, 0, 0, 0];
    n24[3] *= this._getLayerOpacity();
    const s16 = u3(a21.size || 0);
    let o22 = null;
    if (r24.verticalOffset) {
      const { screenLength: e25, minWorldLength: t20, maxWorldLength: a22 } = r24.verticalOffset;
      o22 = { screenLength: u3(e25), minWorldLength: t20 || 0, maxWorldLength: null != a22 ? a22 : 1 / 0 };
    }
    const l26 = r(a21.border) && r(a21.border.color) ? l4.toUnitRGBA(a21.border.color) : null, c21 = "object" === r24.symbolLayers.getItemAt(0).type, m15 = !c21, d22 = c21 ? 0 : void 0, h18 = "label-3d" === r24.type;
    return { color: n24, size: s16, verticalOffset: o22, screenSizePerspective: this._context.screenSizePerspectiveEnabled ? this._context.sharedResources.screenSizePerspectiveSettings : null, screenOffset: [0, 0], centerOffsetUnits: "world", borderColor: l26, occlusionTest: m15, shaderPolygonOffset: d22, depthHUDAlignStart: h18, hasSlicePlane: this._context.slicePlaneEnabled, renderOccluded: h7.Occlude, __tagStrict: "NoParameters" };
  }
  _defaultElevationInfoNoZ() {
    return E12;
  }
  createGraphics3DGraphic(e25) {
    const t20 = e25.renderingInfo, i17 = e25.graphic, a21 = this.setGraphicElevationContext(i17, new h10(), t20.elevationOffset || 0), s16 = t20.symbol, o22 = "on-the-ground" === this._elevationContext.mode && ("cim" === s16.type || !s16.symbolLayers.some((e26) => "object" === e26.type || "text" === e26.type));
    if ("label-3d" !== s16.type && o22)
      return null;
    if ("point-3d" === s16.type && s16.symbolLayers.every((e26) => "text" === e26.type && !i3(e26)))
      return null;
    const l26 = w4(i17.geometry);
    return t(l26) ? null : this._createAs3DShape(l26, a21, t20, i17.uid);
  }
  layerOpacityChanged() {
    return t(this._material) || this._material.setParameters(this.materialParameters), true;
  }
  layerElevationInfoChanged(e25, r24, i17) {
    const a21 = this._elevationContext.mode, n24 = p10(b6.elevationModeChangeTypes, i17, a21);
    return n24 !== x5.UPDATE || e25.forEach((e26) => {
      const i18 = r24(e26);
      r(i18) && this.updateGraphicElevationContext(e26.graphic, i18);
    }), n24;
  }
  slicePlaneEnabledChanged() {
    return t(this._material) || this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  setGraphicElevationContext(e25, t20, r24 = 0) {
    const i17 = super.setGraphicElevationContext(e25, t20);
    return i17.addOffsetRenderUnits(r24), i17;
  }
  updateGraphicElevationContext(e25, t20) {
    this.setGraphicElevationContext(e25, t20.elevationContext, t20.metadata.elevationOffset), t20.needsElevationUpdates = g7(t20.elevationContext.mode);
  }
  computeComplexity() {
    return { primitivesPerFeature: 2, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false, memory: b5.memory };
  }
  _createVertexData(e25) {
    const { translation: t20, centerOffset: r24 } = e25, i17 = t20 ? { size: 3, data: [t20[0], t20[1], t20[2]], exclusive: true } : { size: 3, data: [0, 0, 0], exclusive: true }, a21 = r24 ? { size: 4, data: [r24[0], r24[1], r24[2], r24[3]], exclusive: true } : { size: 4, data: [0, 0, 0, 1], exclusive: true };
    return [[O.POSITION, i17], [O.NORMAL, { size: 3, data: [0, 0, 1], exclusive: true }], [O.AUXPOS1, a21]];
  }
  _getOrCreateMaterial(e25) {
    const i17 = this._perInstanceMaterialParameters(e25), a21 = g11.uniqueMaterialIdentifier(i17);
    if (r(this._material) && a21 === this._material.uniqueMaterialIdentifier)
      return { material: this._material, isUnique: false };
    if (e25.materialCollection) {
      let t20 = e25.materialCollection.get(a21);
      return t(t20) && (t20 = new g11(i17), e25.materialCollection.add(a21, t20)), { material: t20, isUnique: false };
    }
    return { material: new g11(i17), isUnique: true };
  }
  _createAs3DShape(e25, t20, r24, i17) {
    const a21 = [new g4(this._createVertexData(r24), P6, c9.Point)], n24 = this._getOrCreateMaterial(r24), o22 = f11(this._context, e25, a21, [n24.material], t20, this._context.layer.uid, i17);
    if (null === o22)
      return null;
    const l26 = new p14(this, o22.object, a21, n24.isUnique ? [n24.material] : null, null, d12, t20);
    return l26.metadata = { elevationOffset: r24.elevationOffset || 0 }, l26.alignedSampledElevation = o22.sampledElevation, l26.needsElevationUpdates = g7(t20.mode), g8(l26, e25, this._context.elevationProvider), l26;
  }
};
b6.elevationModeChangeTypes = { definedChanged: x5.UPDATE, staysOnTheGround: x5.UPDATE, onTheGroundChanged: x5.RECREATE };
var C6 = new Uint16Array([0]);
var P6 = [[O.POSITION, C6], [O.NORMAL, C6], [O.AUXPOS1, C6]];
var E12 = { mode: "relative-to-ground", offset: 0 };
var U4 = { ignoreDrivers: true, renderPriority: 0, renderPriorityStep: 1 };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DCalloutSymbolLayerFactory.js
var t16 = s.getLogger("esri.views.3d.layers.graphics.Graphics3DCalloutSymbolLayerFactory");
function e19(o22, l26) {
  if (!o9(o22))
    return t16.error("Graphics3DCalloutSymbolLayerFactory#make", `symbol of type '${o22.type}' does not support callouts`), null;
  if (!o22.callout)
    return null;
  const e25 = a16[o22.callout.type];
  return e25 ? new e25(o22, l26) : (t16.error("Graphics3DCalloutSymbolLayerFactory#make", `unknown or unsupported callout type ${o22.callout.type}`), null);
}
var a16 = { line: b6 };

// node_modules/@arcgis/core/renderers/support/renderingInfoUtils.js
function i13(e25, o22) {
  if (!e25 || e25.symbol)
    return null;
  const r24 = o22 && o22.renderer;
  return e25 && r(r24) && r24.getObservationRenderer ? r24.getObservationRenderer(e25) : r24;
}
function n16(e25, o22) {
  if (r(e25.symbol))
    return e25.symbol;
  const r24 = i13(e25, o22);
  return r(r24) && "dot-density" !== r24.type ? r24.getSymbol(e25, o22) : null;
}
function a17(e25, t20) {
  const a21 = i13(e25, t20), l26 = n16(e25, t20);
  if (t(l26))
    return null;
  const s16 = { renderer: a21, symbol: l26 };
  if (t(a21) || !("visualVariables" in a21) || !a21.visualVariables)
    return s16;
  const u16 = N2(a21, e25, t20), c21 = ["proportional", "proportional", "proportional"];
  for (const { variable: o22, value: r24 } of u16)
    switch (o22.type) {
      case "color":
        s16.color = r24.toRgba();
        break;
      case "size":
        if ("outline" === o22.target)
          s16.outlineSize = r24;
        else {
          const e26 = o22.axis, t21 = o22.useSymbolValue ? "symbol-value" : r24;
          switch (e26) {
            case "width":
              c21[0] = t21;
              break;
            case "depth":
              c21[1] = t21;
              break;
            case "height":
              c21[2] = t21;
              break;
            case "width-and-depth":
              c21[0] = c21[1] = t21;
              break;
            default:
              c21[0] = c21[1] = c21[2] = t21;
          }
        }
        break;
      case "opacity":
        s16.opacity = r24;
        break;
      case "rotation":
        switch (o22.axis) {
          case "tilt":
            s16.tilt = r24;
            break;
          case "roll":
            s16.roll = r24;
            break;
          default:
            s16.heading = r24;
        }
    }
  return "proportional" === c21[0] && "proportional" === c21[1] && "proportional" === c21[2] || (s16.size = c21), s16;
}
async function l20(e25, o22) {
  if (r(e25.symbol))
    return e25.symbol;
  const r24 = i13(e25, o22);
  return r(r24) && r24.getSymbolAsync(e25, o22);
}
async function s9(t20, o22) {
  const n24 = i13(t20, o22), a21 = await l20(t20, o22);
  if (!a21)
    return null;
  const s16 = { renderer: n24, symbol: a21 };
  if (!n24 || !("visualVariables" in n24) || !n24.visualVariables)
    return s16;
  const u16 = N2(n24, t20, o22), c21 = ["proportional", "proportional", "proportional"];
  for (const { variable: r24, value: i17 } of u16)
    if ("color" === r24.type)
      s16.color = l4.toUnitRGBA(i17);
    else if ("size" === r24.type)
      if ("outline" === r24.target)
        s16.outlineSize = i17;
      else {
        const e25 = r24.axis, t21 = r24.useSymbolValue ? "symbol-value" : i17;
        "width" === e25 ? c21[0] = t21 : "depth" === e25 ? c21[1] = t21 : "height" === e25 ? c21[2] = t21 : c21[0] = c21[1] = "width-and-depth" === e25 ? t21 : c21[2] = t21;
      }
    else
      "opacity" === r24.type ? s16.opacity = i17 : "rotation" === r24.type && "tilt" === r24.axis ? s16.tilt = i17 : "rotation" === r24.type && "roll" === r24.axis ? s16.roll = i17 : "rotation" === r24.type && (s16.heading = i17);
  return (isFinite(c21[0]) || isFinite(c21[1]) || isFinite(c21[2])) && (s16.size = c21), s16;
}
function u12(e25, t20 = 0) {
  const o22 = e25[t20];
  return "number" == typeof o22 && isFinite(o22) ? o22 : null;
}
function c14(e25) {
  for (let t20 = 0; t20 < 3; t20++) {
    const o22 = e25[t20];
    if ("number" == typeof o22)
      return isFinite(o22) ? o22 : 0;
  }
  return 0;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextRenderer.js
var s10 = class {
  constructor(t20, e25, i17, n24 = 2048) {
    this.text = t20, this._alignment = e25, this._parameters = i17, this.maxSize = n24, this._textWidths = [], this._lineWidths = [], this._renderPixelRatio = null, this._displayWidth = null, this._heightMetrics = null, this.key = `TextRenderer-${this._parameters.key}-${this._alignment}--${t20}`, this._lines = t20.split(/\r?\n/);
  }
  get displayWidth() {
    return Math.ceil(this._ensureTextWidth() + 2 * this.backgroundHorizontalPadding);
  }
  get displayHeight() {
    const t20 = this.lineSpacing * (this._lines.length - 1), e25 = this.lineHeight;
    return Math.ceil(t20 + e25 + 2 * this.haloSize + this.backgroundTopPadding + this.backgroundBottomPadding);
  }
  get renderedWidth() {
    return Math.ceil(this._toRenderUnit(this.displayWidth));
  }
  get renderedHeight() {
    return Math.ceil(this._toRenderUnit(this.displayHeight));
  }
  get firstRenderedBaselinePosition() {
    return this._toRenderUnit(this.firstLineYOffset + this.baselinePosition);
  }
  get firstLineYOffset() {
    return this.backgroundTopPadding + this.haloSize;
  }
  get heightMetrics() {
    return this._ensureHeightMetrics();
  }
  get lineSpacing() {
    return (this.lineHeight + this.linePadding) * this._parameters.definition.lineSpacingFactor;
  }
  get lineHeight() {
    return this.heightMetrics.lineHeight;
  }
  get linePadding() {
    return this.lineHeight * d14;
  }
  get baselinePosition() {
    return this.heightMetrics.baselinePosition;
  }
  get renderedFontSize() {
    return this._toRenderUnit(this.fontSize);
  }
  get fontSize() {
    return this._parameters.definition.size;
  }
  get renderedHaloSize() {
    return this._toRenderUnit(this.haloSize);
  }
  get haloSize() {
    return this._parameters.haloSize;
  }
  get backgroundHorizontalPadding() {
    return this.hasBackground ? this._parameters.definition.background.padding[0] : 0;
  }
  get backgroundVerticalPadding() {
    return this.hasBackground ? this._parameters.definition.background.padding[1] : 0;
  }
  get backgroundTopPadding() {
    return Math.max(0, this.backgroundVerticalPadding - this.heightMetrics.paddingTop);
  }
  get backgroundBottomPadding() {
    return Math.max(0, this.backgroundVerticalPadding - this.heightMetrics.paddingBottom);
  }
  get hasBackground() {
    return !!this._parameters.backgroundStyle;
  }
  get renderPixelRatio() {
    if (t(this._renderPixelRatio)) {
      const t20 = this._parameters.definition.pixelRatio;
      this.maxSize > 0 ? this._renderPixelRatio = Math.min(t20, Math.min(this.maxSize / this.displayWidth, this.maxSize / this.displayHeight)) : this._renderPixelRatio = t20;
    }
    return this._renderPixelRatio;
  }
  _getLineXOffset(t20) {
    switch (this._alignment) {
      case h13.Left:
        return this.backgroundHorizontalPadding;
      case h13.Center:
        return (this.displayWidth - this._lineWidths[t20]) / 2;
      case h13.Right:
        return this.displayWidth - this.backgroundHorizontalPadding - this._lineWidths[t20];
    }
  }
  render(t20, e25 = 0, i17 = 0) {
    t20.save();
    const s16 = e25 /= this.renderPixelRatio, r24 = i17 /= this.renderPixelRatio, h18 = this.haloSize, o22 = this.firstLineYOffset;
    e25 += h18, i17 += o22 + this.baselinePosition;
    const a21 = this.haloSize > 0;
    a21 && this._renderHalo(t20, s16, r24, h18, o22), this._setFontProperties(t20, this.renderedFontSize);
    for (let n24 = 0; n24 < this._lines.length; ++n24) {
      const s17 = this._lines[n24], r25 = this._getLineXOffset(n24);
      a21 && (t20.globalCompositeOperation = "destination-out", t20.fillStyle = "rgb(0, 0, 0)", this._fillText(t20, s17, e25 + r25, i17), this._renderLineDecoration(t20, e25 + r25, i17, this._textWidths[n24])), t20.globalCompositeOperation = "source-over", t20.fillStyle = this._parameters.textStyle, this._fillText(t20, s17, e25 + this._getLineXOffset(n24), i17), this._renderLineDecoration(t20, e25 + r25, i17, this._textWidths[n24]), i17 += this.lineSpacing;
    }
    if (t10.TEXT_SHOW_BASELINE) {
      t20.strokeStyle = g12, t20.setLineDash([2, 2]), t20.lineWidth = 1;
      let e26 = r24 + o22;
      for (let i18 = 0; i18 < this._lines.length; ++i18) {
        const i19 = e26 + this.baselinePosition;
        this._drawLine(t20, [s16, i19], [s16 + this.displayWidth, i19]), e26 += this.lineSpacing;
      }
    }
    if (t10.TEXT_SHOW_BORDER && (t20.strokeStyle = g12, t20.setLineDash([]), t20.lineWidth = 1, this._drawBox(t20, [s16, r24], [this.displayWidth, this.displayHeight])), this.hasBackground) {
      const e26 = this._parameters.definition.background.borderRadius * this.renderPixelRatio;
      this._roundedRect(t20, s16, r24, e26), t20.globalCompositeOperation = "destination-over", t20.fillStyle = this._parameters.backgroundStyle, t20.fill();
    }
    t20.restore();
  }
  _renderLineDecoration(t20, e25, i17, n24, s16 = false) {
    if ("none" === this._parameters.definition.font.decoration || 0 === n24)
      return;
    const r24 = 1, h18 = Math.max(this._parameters.definition.size / 16, r24);
    switch (this._parameters.definition.font.decoration) {
      case "underline":
        i17 += 2 * h18;
        break;
      case "line-through":
        i17 -= 0.33 * this.baselinePosition;
    }
    const o22 = s16 ? this.haloSize : 0;
    t20.strokeStyle = s16 ? this._parameters.haloStyle : this._parameters.textStyle, t20.lineWidth = this._toRenderUnit(h18 + 2 * o22), t20.beginPath(), t20.moveTo(this._toRenderUnit(e25 - o22), this._toRenderUnit(i17)), t20.lineTo(this._toRenderUnit(e25 + n24 + o22), this._toRenderUnit(i17)), t20.stroke();
  }
  _roundedRect(e25, i17, n24, s16) {
    i17 = this._toRenderUnit(i17), n24 = this._toRenderUnit(n24);
    const r24 = this.renderedWidth, h18 = this.renderedHeight;
    0 !== s16 ? (s16 = o4(s16, 0, Math.floor(h18 / 2)), e25.beginPath(), e25.moveTo(i17, n24 + s16), e25.arcTo(i17, n24, i17 + s16, n24, s16), e25.lineTo(i17 + r24 - s16, n24), e25.arcTo(i17 + r24, n24, i17 + r24, n24 + s16, s16), e25.lineTo(i17 + r24, n24 + h18 - s16), e25.arcTo(i17 + r24, n24 + h18, i17 + r24 - s16, n24 + h18, s16), e25.lineTo(i17 + s16, n24 + h18), e25.arcTo(i17, n24 + h18, i17, n24 + h18 - s16, s16), e25.closePath()) : e25.rect(i17, n24, r24, h18);
  }
  _renderHalo(t20, e25, i17, n24, s16) {
    const r24 = this.renderedWidth, h18 = this.renderedHeight, d22 = o17(a18, Math.max(r24, l21), Math.max(h18, l21)), g17 = d22.getContext("2d");
    g17.clearRect(0, 0, r24, h18), this._setFontProperties(g17, this.renderedFontSize), g17.fillStyle = this._parameters.haloStyle, g17.strokeStyle = this._parameters.haloStyle;
    const c21 = this.renderedHaloSize < 3;
    g17.lineJoin = c21 ? "miter" : "round", c21 ? this._renderHaloEmulated(g17, n24, s16) : this._renderHaloNative(g17, n24, s16);
    let _14 = s16 + this.baselinePosition;
    for (let o22 = 0; o22 < this._lines.length; ++o22) {
      const t21 = this._getLineXOffset(o22);
      this._renderLineDecoration(g17, n24 + t21, _14, this._textWidths[o22], true), _14 += this.lineSpacing;
    }
    t20.globalAlpha = this._parameters.definition.halo.color[3], t20.drawImage(d22, 0, 0, r24, h18, this._toRenderUnit(e25), this._toRenderUnit(i17), r24, h18), t20.globalAlpha = 1;
  }
  _renderHaloEmulated(t20, e25, i17) {
    i17 += this.baselinePosition;
    for (let n24 = 0; n24 < this._lines.length; ++n24) {
      const s16 = this._lines[n24], h18 = this._getLineXOffset(n24);
      for (const [n25, o22] of r17)
        this._fillText(t20, s16, e25 + h18 + this.haloSize * n25, i17 + this.haloSize * o22);
      i17 += this.lineSpacing;
    }
  }
  _renderHaloNative(t20, e25, i17) {
    const n24 = 2 * this.haloSize;
    i17 += this.baselinePosition;
    for (let s16 = 0; s16 < this._lines.length; ++s16) {
      const r24 = this._lines[s16], h18 = this._getLineXOffset(s16), o22 = 5, a21 = 0.1;
      for (let s17 = 0; s17 < o22; s17++) {
        const d22 = 1 - (o22 - 1) * a21 + s17 * a21;
        t20.lineWidth = this._toRenderUnit(d22 * n24), this._strokeText(t20, r24, e25 + h18, i17);
      }
      i17 += this.lineSpacing;
    }
  }
  _setFontProperties(t20, e25) {
    t20.font = this._parameters.fontString(e25), t20.textAlign = "left", t20.textBaseline = "alphabetic";
  }
  _ensureTextWidth() {
    if (r(this._displayWidth))
      return this._displayWidth;
    const t20 = o17(a18, l21, l21).getContext("2d");
    this._setFontProperties(t20, this.fontSize);
    let e25 = 2 * this.haloSize;
    const n24 = this._parameters.definition.font;
    "italic" !== n24.style && "oblique" !== n24.style && "bold" !== n24.weight && "bolder" !== n24.weight || (e25 += 0.3 * t20.measureText("A").width), this._textWidths.length = 0, this._lineWidths.length = 0;
    let s16 = 0;
    for (const i17 of this._lines) {
      const n25 = t20.measureText(i17).width, r24 = n25 + e25;
      this._textWidths.push(n25), this._lineWidths.push(r24), s16 = Math.max(s16, r24);
    }
    return this._displayWidth = s16, this._displayWidth;
  }
  _ensureHeightMetrics() {
    if (t(this._heightMetrics)) {
      const t20 = o17(a18, l21, l21).getContext("2d");
      this._setFontProperties(t20, this.fontSize);
      const e25 = t20.measureText(this.text + c15), i17 = this.hasBackground ? t20.measureText(this._lines[0]) : e25, n24 = 1 === this._lines.length ? i17 : this.hasBackground ? t20.measureText(this._lines[this._lines.length - 1]) : e25, s16 = e25.actualBoundingBoxAscent + e25.actualBoundingBoxDescent;
      this._heightMetrics = { paddingTop: e25.actualBoundingBoxAscent - i17.actualBoundingBoxAscent, paddingBottom: e25.actualBoundingBoxDescent - n24.actualBoundingBoxDescent, lineHeight: s16, baselinePosition: e25.actualBoundingBoxAscent };
    }
    return this._heightMetrics;
  }
  _toRenderUnit(t20) {
    return t20 * this.renderPixelRatio;
  }
  _toRoundedRenderUnit(t20) {
    return Math.round(t20 * this.renderPixelRatio);
  }
  _fillText(t20, e25, i17, n24) {
    t20.fillText(e25, this._toRenderUnit(i17), this._toRenderUnit(n24));
  }
  _strokeText(t20, e25, i17, n24) {
    t20.strokeText(e25, this._toRenderUnit(i17), this._toRenderUnit(n24));
  }
  _drawLine(t20, e25, i17) {
    t20.beginPath(), t20.moveTo(this._toRoundedRenderUnit(e25[0]) + 0.5, this._toRoundedRenderUnit(e25[1]) + 0.5), t20.lineTo(this._toRoundedRenderUnit(i17[0]) + 0.5, this._toRoundedRenderUnit(i17[1]) + 0.5), t20.stroke();
  }
  _drawBox(t20, e25, i17) {
    const n24 = this._toRenderUnit(e25[0]), s16 = this._toRenderUnit(e25[1]), r24 = this._toRenderUnit(i17[0]), h18 = this._toRenderUnit(i17[1]), o22 = Math.floor(n24) + 0.5, a21 = Math.ceil(n24 + r24) - 0.5, d22 = Math.floor(s16) + 0.5, l26 = Math.ceil(s16 + h18) - 0.5;
    t20.beginPath(), t20.moveTo(o22, d22), t20.lineTo(a21, d22), t20.lineTo(a21, l26), t20.lineTo(o22, l26), t20.lineTo(o22, d22), t20.stroke();
  }
};
var r17 = [];
{
  const t20 = 16;
  for (let e25 = 0; e25 < 360; e25 += 360 / t20)
    r17.push([Math.cos(Math.PI * e25 / 180), Math.sin(Math.PI * e25 / 180)]);
}
var h13;
function o17(t20, e25, i17) {
  return t20.canvas || (t20.canvas = document.createElement("canvas")), t20.canvas.width = e25, t20.canvas.height = i17, t20.canvas;
}
!function(t20) {
  t20[t20.Left = 0] = "Left", t20[t20.Center = 1] = "Center", t20[t20.Right = 2] = "Right";
}(h13 || (h13 = {}));
var a18 = { canvas: null };
var d14 = 0.2;
var l21 = 512;
var g12 = "rgb(255, 0, 255, 0.5)";
var c15 = (() => {
  let t20 = "";
  for (let e25 = 32; e25 < 127; e25++)
    t20 += String.fromCharCode(e25);
  return t20;
})();

// node_modules/@arcgis/core/views/3d/layers/graphics/placementUtils.js
var r18 = { left: 0, center: 0.5, right: 1 };
var o18 = { "bottom-left": r11(0, 0), bottom: r11(0.5, 0), "bottom-right": r11(1, 0), left: r11(0, 0.5), center: r11(0.5, 0.5), right: r11(1, 0.5), "top-left": r11(0, 1), top: r11(0.5, 1), "top-right": r11(1, 1) };
function c16(t20) {
  switch (t20) {
    case "left":
      return h13.Left;
    case "right":
      return h13.Right;
    default:
      return h13.Center;
  }
}
function n17(t20) {
  switch (t20) {
    case "bottom-left":
    case "left":
    case "top-left":
      return "left";
    case "bottom":
    case "center":
    case "top":
      return "center";
    case "bottom-right":
    case "right":
    case "top-right":
      return "right";
  }
}
function s11(t20) {
  switch (t20) {
    case "bottom-left":
    case "bottom":
    case "bottom-right":
      return "bottom";
    case "left":
    case "center":
    case "right":
      return "center";
    case "top-left":
    case "top":
    case "top-right":
      return "top";
  }
}
function i14(t20, e25) {
  switch (e25) {
    case "bottom":
      return "left" === t20 ? "bottom-left" : "right" === t20 ? "bottom-right" : "bottom";
    case "center":
      return t20;
    case "top":
      return "left" === t20 ? "top-left" : "right" === t20 ? "top-right" : "top";
  }
}
function f14(t20) {
  return "middle" === t20 ? "center" : t20;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextRenderParameters.js
var s12 = s.getLogger("esri.views.3d.webgl-engine.lib.TextRenderParameters");
var a19 = class {
  constructor(o22) {
    this.definition = o22, this.key = JSON.stringify(o22), this.haloSize = Math.round(o22.halo.size), this.textStyle = this._colorToRGBA(o22.color), this.haloStyle = this._colorToRGB(o22.halo.color), this.backgroundStyle = 0 !== o22.background.color[3] ? this._colorToRGBA(o22.background.color) : null;
  }
  fontString(o22) {
    const t20 = this.definition.font;
    return `${t20.style} ${t20.weight} ${o22}px ${t20.family}, sans-serif`;
  }
  _colorToRGB(o22) {
    return `rgb(${o22.slice(0, 3).map((o23) => Math.floor(255 * o23)).toString()})`;
  }
  _colorToRGBA(o22) {
    return `rgba(${o22.slice(0, 3).map((o23) => Math.floor(255 * o23)).toString()},${o22[3]})`;
  }
  static async fromSymbol(t20, c21 = 1) {
    const g17 = m(t20, "material", "color"), f22 = E(g17, l5, l4.toUnitRGBA), d22 = E(t20.size, 12, u3), h18 = t20.lineHeight, m15 = r(t20.background) ? l4.toUnitRGBA(t20.background.color) : l5, u16 = { family: E(t20.font, "sans-serif", (o22) => o22.family), decoration: E(t20.font, "none", (o22) => o22.decoration), weight: E(t20.font, "normal", (o22) => o22.weight), style: E(t20.font, "normal", (o22) => o22.style) }, b13 = t20.halo, y9 = r(b13) && r(b13.color) && b13.size > 0 ? { size: u3(b13.size), color: l4.toUnitRGBA(b13.color) } : { size: 0, color: l5 }, p21 = new a19({ color: f22, size: d22, background: { color: m15, padding: r(t20.background) ? [0.65 * d22, 0.5 * d22] : [0, 0], borderRadius: r(t20.background) ? d22 * (6 / 16) : 0 }, lineSpacingFactor: h18, font: u16, halo: y9, pixelRatio: c21 }), S13 = p21.fontString(d22);
    try {
      await document.fonts.load(S13);
    } catch (R12) {
      s12.warnOnce(`Failed to preload font '${S13}'. Some text symbology may be rendered using the default browser font.`);
    }
    return p21;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DGraphic.js
var v12 = new e3(Array, (i17) => A(i17, H), null, 10, 5);
var S7 = u5();
var B4 = class {
  constructor(i17, e25, r24, s16, a21) {
    this.graphic = i17, this.graphics3DSymbol = e25, this.graphics = r24, this._labelGraphics = new Array(), this._auxiliaryGraphics = new Array(), this._visibilityFlags = V4(E9._COUNT, C3._COUNT), this._featureExpressionFeature = null, this._optimizedGeometry = { geometry: null, hasZ: false, hasM: false }, this._extent = null, this.isElevationSource = false, ++e25.referenced, this._featureExpressionFeature = a21 ? u10(a21, i17, s16) : null;
    for (const o22 of r24)
      r(o22) && (this.isElevationSource = this.isElevationSource || o22.isElevationSource);
  }
  get labelGraphics() {
    return this._labelGraphics;
  }
  get extent() {
    return this._extent;
  }
  initialize(i17, e25) {
    this._layer = e25, this._stage = i17, this._forEachSymbolLayerGraphic((t20) => {
      t20.initialize(i17, e25), t20.setVisibility(this.isVisible());
    });
  }
  destroy() {
    this._forEachSymbolLayerGraphic((i17) => i17.destroy()), this.graphics = null, this._auxiliaryGraphics = null, --this.graphics3DSymbol.referenced, this.graphics3DSymbol = null;
  }
  get destroyed() {
    return null == this.graphics;
  }
  clearLabelGraphics() {
    this._forEachLabelGraphic((i17) => i17.destroy()), this._labelGraphics.length = 0;
  }
  addLabelGraphic(i17, e25, t20) {
    this._labelGraphics.push(i17), i17.initialize(e25, t20), i17.setVisibility(this.isVisible(E9.LABEL));
  }
  addAuxiliaryGraphic(i17) {
    this._auxiliaryGraphics.push(i17), this._layer && (i17.initialize(this._stage, this._layer), i17.setVisibility(this.isVisible()));
  }
  get isDraped() {
    let i17 = false;
    return this._forEachSymbolLayerGraphic((e25) => {
      "draped" === e25.type && (i17 = true);
    }), i17;
  }
  isVisible(i17 = E9.GRAPHIC, e25) {
    for (let t20 = 0; t20 <= i17; t20++) {
      const i18 = this._visibilityFlags[t20];
      for (let t21 = 0; t21 < i18.length; ++t21)
        if (false === i18[t21] && t21 !== e25)
          return false;
    }
    return true;
  }
  hasVisibilityFlag(i17, e25) {
    return null != this._visibilityFlags[e25][i17];
  }
  setVisibilityFlag(i17, e25, t20) {
    const r24 = this.isVisible(t20);
    this._visibilityFlags[t20][i17] = e25;
    const s16 = this.isVisible(t20);
    if (r24 === s16)
      return false;
    if (t20 === E9.LABEL)
      this._forEachLabelGraphic((i18) => i18.setVisibility(s16));
    else {
      this._forEachSymbolLayerGraphic((i19) => i19.setVisibility(s16));
      const i18 = this.isVisible(E9.LABEL);
      this._forEachLabelGraphic((e26) => e26.setVisibility(i18));
    }
    return true;
  }
  clearVisibilityFlag(i17, e25 = E9.GRAPHIC) {
    return this.setVisibilityFlag(i17, void 0, e25);
  }
  computeExtent(i17) {
    if (!this._extent) {
      const e25 = this.graphic.geometry;
      if (t(e25))
        return false;
      this._extent = u5(), J(e25, this._extent);
      const t20 = e25.spatialReference;
      if (!t20.equals(i17) && !zn(this._extent, t20, this._extent, i17))
        return this._extent = null, false;
    }
    return true;
  }
  getAsOptimizedGeometry(i17, e25) {
    return r(this._optimizedGeometry.geometry) && this._optimizedGeometry.hasZ === i17 && this._optimizedGeometry.hasM === e25 || (this._optimizedGeometry.geometry = this._convertGraphicToOptimizedGeometry(this.graphic, i17, e25), this._optimizedGeometry.hasZ = i17, this._optimizedGeometry.hasM = e25), this._optimizedGeometry.geometry;
  }
  _convertGraphicToOptimizedGeometry(i17, e25, t20) {
    let r24 = i17.geometry;
    return "mesh" !== r24.type && "extent" !== r24.type || (r24 = v2.fromExtent("mesh" === r24.type ? r24.extent : r24)), te(r24, e25, t20);
  }
  get usedMemory() {
    let i17 = r10(this.graphic.attributes);
    return this._forEachSymbolLayerGraphic((e25) => {
      const t20 = e25.graphics3DSymbolLayer.complexity;
      if (t(t20))
        return;
      const s16 = "draped" === e25.type ? t20.memory.draped : t20.memory;
      i17 += s16.bytesPerFeature, s16.bytesPerCoordinate && (i17 += w3(this.graphic.geometry) * s16.bytesPerCoordinate);
    }), i17;
  }
  computeAttachmentOrigin() {
    const i17 = { render: { origin: n2(), num: 0 }, draped: { origin: n8(), num: 0 } };
    for (const e25 of this.graphics)
      t(e25) || e25.computeAttachmentOrigin(i17);
    return i17.render.num && q(i17.render.origin, i17.render.origin, 1 / i17.render.num), i17.draped.num && l8(i17.draped.origin, i17.draped.origin, 1 / i17.draped.num), i17;
  }
  async getProjectedBoundingBox(e25, t20, s16, a21, o22) {
    return o22 || (o22 = { boundingBox: null, requiresDrapedElevation: false, screenSpaceObjects: [] }), o22.boundingBox ? B(o22.boundingBox) : o22.boundingBox = B(), o22.requiresDrapedElevation = false, await n6(this.graphics, async (i17) => {
      if (t(i17))
        return;
      const h18 = "draped" === i17.type ? t20 : e25, n24 = v12.acquire(), c21 = await i17.getProjectedBoundingBox(h18, s16, o22.screenSpaceObjects, a21, n24);
      isFinite(c21[2]) && isFinite(c21[5]) || (o22.requiresDrapedElevation = true), c21 && f3(o22.boundingBox, n24), v12.release(n24);
    }), l7(o22.boundingBox) || M2(G2(o22.boundingBox, S7)) ? o22 : null;
  }
  needsElevationUpdates() {
    for (const i17 of this.graphics)
      if (r(i17) && ("object3d" === i17.type || "lod-instance" === i17.type) && i17.needsElevationUpdates)
        return true;
    for (const i17 of this._labelGraphics)
      if (i17 && i17.needsElevationUpdates)
        return true;
    return false;
  }
  alignWithElevation(i17, e25, t20) {
    this._forEachRenderedGraphic((r24) => {
      "object3d" !== r24.type && "lod-instance" !== r24.type || r24.alignWithElevation(i17, e25, this._featureExpressionFeature, t20);
    });
  }
  addObjectStateSet(i17, e25) {
    this._forEachSymbolLayerGraphic((t20) => t20.addObjectState(i17, e25));
  }
  removeObjectState(i17) {
    this._forEachSymbolLayerGraphic((e25) => e25.removeObjectState(i17));
  }
  _forEachGraphicList(i17, e25) {
    i17.forEach((i18) => i18 && e25(i18));
  }
  _forEachSymbolLayerGraphic(i17) {
    this._forEachGraphicList(this.graphics, i17), this._forEachGraphicList(this._auxiliaryGraphics, i17);
  }
  _forEachLabelGraphic(i17) {
    this._forEachGraphicList(this._labelGraphics, i17);
  }
  _forEachRenderedGraphic(i17) {
    this._forEachSymbolLayerGraphic(i17), this._forEachLabelGraphic(i17);
  }
};
function V4(i17, e25) {
  const t20 = new Array(i17);
  for (let r24 = 0; r24 < t20.length; r24++)
    t20[r24] = new Array(e25);
  return t20;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/polygonUtils.js
function c17(i17) {
  const o22 = [[O.POSITION, i17.indices]], e25 = [[O.POSITION, { size: 3, data: i17.attributeData.position, exclusive: true }]];
  return r(i17.attributeData.color) && (e25.push([O.COLOR, { size: 4, data: i17.attributeData.color, exclusive: true }]), o22.push([O.COLOR, new Uint32Array(i17.indices.length)])), r(i17.attributeData.uvMapSpace) && (e25.push([O.UVMAPSPACE, { size: 4, data: i17.attributeData.uvMapSpace, exclusive: true }]), o22.push([O.UVMAPSPACE, i17.indices])), r(i17.attributeData.boundingRect) && (e25.push([O.BOUNDINGRECT, { size: 9, data: i17.attributeData.boundingRect, exclusive: true }]), o22.push([O.BOUNDINGRECT, i17.indices])), r(i17.attributeData.mapPosition) && (e25.push([O.MAPPOS, { size: 3, data: i17.attributeData.mapPosition, exclusive: true }]), o22.push([O.MAPPOS, i17.indices])), new g4(e25, o22);
}
function l22(i17) {
  const o22 = [[O.POSITION, i17.indices], [O.UV0, i17.indices]], e25 = [[O.POSITION, { size: 3, data: i17.attributeData.position, exclusive: true }], [O.UV0, { size: 2, data: i17.attributeData.uv0, exclusive: true }]];
  return r(i17.attributeData.mapPosition) && (e25.push([O.MAPPOS, { size: 3, data: i17.attributeData.mapPosition, exclusive: true }]), o22.push([O.MAPPOS, i17.indices])), new g4(e25, o22);
}
function m12(t20) {
  switch (t20.type) {
    case "extent":
      if (t20 instanceof M)
        return v2.fromExtent(t20);
      break;
    case "polygon":
      return t20;
  }
  return null;
}
function d15(t20, i17, s16, a21) {
  const r24 = l10(t20.rings, t20.hasZ, c8.CCW_IS_HOLE), u16 = new Float64Array(r24.position.length), p21 = f10(r24.position, t20.spatialReference, 0, u16, 0, r24.position, 0, r24.position.length / 3, i17, s16, a21), c21 = null != p21;
  return { position: r24.position, mapPosition: u16, polygons: b7(r24.polygons, r24.position, u16), outlines: g13(r24.outlines, r24.position, u16), projectionSuccess: c21, sampledElevation: p21 };
}
function f15(t20, n24) {
  const a21 = l10(t20.rings, false, c8.CCW_IS_HOLE), r24 = Un(a21.position, t20.spatialReference, 0, a21.position, n24, 0, a21.position.length / 3);
  for (let i17 = 2; i17 < a21.position.length; i17 += 3)
    a21.position[i17] = _e;
  return { position: a21.position, polygons: b7(a21.polygons, a21.position), outlines: g13(a21.outlines, a21.position), projectionSuccess: r24 };
}
function g13(t20, i17, o22) {
  const e25 = new Array();
  for (const { index: n24, count: s16 } of t20) {
    if (s16 <= 1)
      continue;
    const t21 = 3 * n24, a21 = t21 + 3 * s16;
    e25.push({ index: n24, count: s16, position: i17.subarray(t21, a21), mapPosition: o22 ? o22.subarray(t21, a21) : void 0 });
  }
  return e25;
}
function b7(t20, i17, o22) {
  const e25 = new Array();
  for (const { index: n24, count: s16, holeIndices: a21, pathLengths: r24 } of t20) {
    if (s16 <= 1)
      continue;
    const t21 = 3 * n24, u16 = t21 + 3 * s16, p21 = a21.map((t22) => t22 - n24);
    e25.push({ index: n24, count: s16, holeIndices: p21, pathLengths: r24, position: i17.subarray(t21, u16), mapPosition: o22 ? o22.subarray(t21, u16) : void 0 });
  }
  return e25;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DExtrudeSymbolLayer.js
var q6 = ["polygon", "extent"];
var J4 = class extends y3 {
  constructor(e25, t20, r24, s16) {
    super(e25, t20, r24, s16), this.ensureDrapedStatus(false);
  }
  async doLoad() {
    if (!this._drivenProperties.size) {
      const t20 = O4(this._getSymbolSize());
      if (t20)
        throw new s2("graphics3dextrudesymbollayer:invalid-size", t20);
    }
    const r24 = m(this.symbolLayer, "material", "color"), s16 = this._getCombinedOpacityAndColor(r24), n24 = e4(s16), a21 = s16[3], i17 = a21 < 1 || this.needsDrivenTransparentPass, o22 = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true, diffuse: n24, ambient: n24, opacity: a21, transparent: i17, cullFace: i17 ? n9.None : n9.Back, hasVertexColors: true, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows, offsetTransparentBackfaces: true };
    this._material = new R5(o22), this._bottomMaterial = new R5({ ...o22, cullFace: n9.Back }), this._context.stage.add(this._material), this._context.stage.add(this._bottomMaterial);
  }
  destroy() {
    super.destroy(), this._material && (this._context.stage.remove(this._material), this._context.stage.remove(this._bottomMaterial));
  }
  createGraphics3DGraphic(e25) {
    const t20 = e25.graphic;
    if (!this._validateGeometry(t20.geometry, q6, this.symbolLayer.type))
      return null;
    const r24 = this._getVertexOpacityAndColor(e25.renderingInfo, 255), s16 = this.setGraphicElevationContext(t20, new h10());
    return this._createAs3DShape(t20, e25.renderingInfo, r24, s16, t20.uid);
  }
  layerOpacityChanged(e25, s16) {
    const n24 = m(this.symbolLayer, "material", "color"), a21 = this._getCombinedOpacity(n24), i17 = a21 < 1 || this.needsDrivenTransparentPass;
    this._material.setParameters({ opacity: a21, transparent: i17 }), this._bottomMaterial.setParameters({ opacity: a21, transparent: i17 });
    const o22 = this._getLayerOpacity();
    return e25.forEach((e26) => {
      const t20 = s16(e26);
      r(t20) && t20.layerOpacityChanged(o22, this._context.isAsync);
    }), true;
  }
  layerElevationInfoChanged(e25, t20) {
    return this.updateGraphics3DGraphicElevationInfo(e25, t20, v8);
  }
  slicePlaneEnabledChanged(e25, t20) {
    return this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), this._bottomMaterial.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), e25.forEach((e26) => {
      const s16 = t20(e26);
      r(s16) && s16.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync);
    }), true;
  }
  physicalBasedRenderingChanged() {
    return this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), this._bottomMaterial.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), true;
  }
  pixelRatioChanged() {
    return true;
  }
  _getExtrusionSize(e25) {
    let t20;
    return t20 = e25.size && this._drivenProperties.size ? u12(e25.size, 2) ?? 0 : this._getSymbolSize(), t20 /= this._context.renderCoordsHelper.unitInMeters, t20;
  }
  applyRendererDiff(e25, t20) {
    return this._drivenPropertiesChanged(t20) ? e16.Recreate_Symbol : e16.Recreate_Graphics;
  }
  _getSymbolSize() {
    return this.symbolLayer.size ?? 1;
  }
  _createAs3DShape(e25, t20, h18, m15, p21) {
    const d22 = m12(e25.geometry);
    if (t(d22))
      return null;
    const u16 = d15(d22, this._context.elevationProvider, this._context.renderCoordsHelper, m15);
    if (this._logGeometryCreationWarnings(u16, d22.rings, "rings", "ExtrudeSymbol3DLayer"), 0 === d22.rings.length || !d22.rings.some((e26) => e26.length > 0))
      return null;
    const f22 = w4(d22);
    if (t(f22))
      return null;
    const g17 = new Array(), j14 = new Array(), M11 = new Array(), O15 = a3(), B7 = e8(), I7 = n2(), R12 = this._context.renderCoordsHelper.viewingMode === l13.Global;
    R12 || this._context.renderCoordsHelper.worldUpAtPosition(null, I7), qn(d22.spatialReference, [f22.x, f22.y, 0], B7, this._context.renderCoordsHelper.spatialReference);
    const z8 = e8();
    h2(z8, B7);
    const k8 = e7();
    j3(k8, z8);
    const { polygons: N6, mapPosition: F11, position: V8 } = u16, H6 = V8.length / 3, Z3 = new Float64Array(3 * H6 * 6), W6 = new Float64Array(3 * H6 * 6), q13 = new Float64Array(3 * H6 * 6), J7 = new Float64Array(1 * H6 * 6);
    let X3 = 0;
    for (let r24 = 0; r24 < N6.length; ++r24) {
      const e26 = N6[r24], s16 = e26.count;
      if (this._context.clippingExtent && (B(O15), M3(O15, e26.mapPosition), !R(O15, this._context.clippingExtent)))
        continue;
      const a21 = x3(e26.mapPosition, e26.holeIndices, 3);
      if (0 === a21.length)
        continue;
      const i17 = 3 * s16 * 2 + a21.length, o22 = new Uint32Array(i17), c21 = new Uint32Array(a21.length), m16 = 6 * s16, p22 = 3 * Z3.BYTES_PER_ELEMENT, d23 = new T(Z3.buffer, X3 * p22, p22, (X3 + m16) * p22), u17 = 3 * W6.BYTES_PER_ELEMENT, f23 = new T(W6.buffer, X3 * u17, u17, (X3 + m16) * u17), y9 = new Float64Array(q13.buffer, 3 * X3 * q13.BYTES_PER_ELEMENT, 3 * m16), _14 = new Float64Array(J7.buffer, 1 * X3 * J7.BYTES_PER_ELEMENT, 1 * m16), b13 = this._getExtrusionSize(t20);
      Q(V8, F11, a21, e26, d23.typedBuffer, y9, f23.typedBuffer, _14, 0, o22, c21, b13, I7, R12), t4(d23, d23, z8), r9(f23, f23, k8), X3 += 6 * s16;
      const A10 = K2(o22, o22.length - c21.length, { positions: d23.typedBuffer, elevation: y9, normals: f23.typedBuffer, heights: _14 }, h18);
      g17.push(A10), j14.push(this._material), M11.push(o7);
      const L9 = K2(c21, 0, { positions: d23.typedBuffer, elevation: y9, normals: f23.typedBuffer, heights: _14 }, h18);
      g17.push(L9), j14.push(this._bottomMaterial), M11.push(o7);
    }
    if (0 === g17.length)
      return null;
    const $4 = new O5({ geometries: g17, materials: j14, transformations: M11, metadata: { layerUid: this._context.layer.uid, graphicUid: p21, isElevationSource: true } });
    $4.transformation = B7;
    const ee2 = f9(this.symbolLayer, { opacity: this._getLayerOpacity() }), te3 = r(ee2) ? { baseMaterial: this._material, edgeMaterials: [ee2], properties: { mergeGeometries: true, hasSlicePlane: this._context.slicePlaneEnabled } } : null, re2 = new p14(this, $4, g17, null, null, ce, m15, te3);
    return re2.alignedSampledElevation = u16.sampledElevation, re2.needsElevationUpdates = v8(m15.mode), re2;
  }
};
function K2(e25, t20, r24, s16) {
  const n24 = new Uint32Array(e25.length), a21 = [[O.POSITION, { size: 3, data: r24.positions, exclusive: true }], [O.NORMAL, { size: 3, data: r24.normals, exclusive: true }], [O.COLOR, { size: 4, data: s16, exclusive: true }], [O.SIZE, { size: 1, data: r24.heights, exclusive: true }]], i17 = [[O.POSITION, e25], [O.NORMAL, e25], [O.COLOR, n24]];
  return r24.elevation && (a21.push([O.MAPPOS, { size: 3, data: r24.elevation }]), i17.push([O.MAPPOS, e25])), new g4(a21, i17, c9.Triangle, t20);
}
function Q(e25, t20, r24, s16, n24, a21, i17, o22, l26, c21, h18, m15, p21, d22) {
  const u16 = r24.length / 3;
  let f22 = 0, g17 = 2 * s16.count;
  X(e25, t20, s16.index, s16.count, r24, 0, u16, n24, a21, i17, o22, l26, c21, h18, g17, m15, p21, d22), l26 += 2 * s16.count, g17 = 0, te2(n24, a21, o22, i17, f22, s16.pathLengths[0], s16.count, l26, c21, g17, m15), l26 += 4 * s16.pathLengths[0], g17 += 2 * s16.pathLengths[0], f22 += s16.pathLengths[0];
  for (let y9 = 1; y9 < s16.pathLengths.length; ++y9)
    te2(n24, a21, o22, i17, f22, s16.pathLengths[y9], s16.count, l26, c21, g17, m15), l26 += 4 * s16.pathLengths[y9], g17 += 2 * s16.pathLengths[y9], f22 += s16.pathLengths[y9];
}
function X(e25, t20, r24, s16, n24, a21, i17, o22, l26, c21, p21, d22, u16, f22, g17, y9, _14, b13) {
  r3(me, _14);
  const E19 = y9 > 0 ? 1 : -1;
  let x13 = 3 * r24, P10 = d22, S13 = 3 * P10, v17 = d22 + s16, w12 = 3 * v17;
  for (let h18 = 0; h18 < s16; ++h18)
    b13 && (me[0] = e25[x13 + 0], me[1] = e25[x13 + 1], me[2] = e25[x13 + 2], z2(me, me)), o22[S13 + 0] = e25[x13 + 0], o22[S13 + 1] = e25[x13 + 1], o22[S13 + 2] = e25[x13 + 2], l26[S13 + 0] = t20[x13 + 0], l26[S13 + 1] = t20[x13 + 1], l26[S13 + 2] = t20[x13 + 2], c21[S13 + 0] = -E19 * me[0], c21[S13 + 1] = -E19 * me[1], c21[S13 + 2] = -E19 * me[2], p21[P10] = 0, o22[w12 + 0] = e25[x13 + 0] + y9 * me[0], o22[w12 + 1] = e25[x13 + 1] + y9 * me[1], o22[w12 + 2] = e25[x13 + 2] + y9 * me[2], l26[w12 + 0] = t20[x13 + 0], l26[w12 + 1] = t20[x13 + 1], l26[w12 + 2] = t20[x13 + 2], c21[w12 + 0] = E19 * me[0], c21[w12 + 1] = E19 * me[1], c21[w12 + 2] = E19 * me[2], p21[v17] = y9, S13 += 3, w12 += 3, x13 += 3, P10 += 1, v17 += 1;
  x13 = 3 * a21, S13 = 0, w12 = 3 * g17;
  const j14 = y9 < 0 ? ue : de, A10 = y9 < 0 ? de : ue;
  for (let h18 = 0; h18 < i17; ++h18)
    f22[S13 + 0] = n24[x13 + j14[0]], f22[S13 + 1] = n24[x13 + j14[1]], f22[S13 + 2] = n24[x13 + j14[2]], u16[w12 + 0] = n24[x13 + A10[0]] + s16, u16[w12 + 1] = n24[x13 + A10[1]] + s16, u16[w12 + 2] = n24[x13 + A10[2]] + s16, S13 += 3, w12 += 3, x13 += 3;
}
function $(e25, t20, r24, s16, n24, a21, i17) {
  s16[a21] = s16[i17], i17 *= 3, e25[(a21 *= 3) + 0] = e25[i17 + 0], e25[a21 + 1] = e25[i17 + 1], e25[a21 + 2] = e25[i17 + 2], t20[a21 + 0] = t20[i17 + 0], t20[a21 + 1] = t20[i17 + 1], t20[a21 + 2] = t20[i17 + 2], r24[a21 + 0] = n24[0], r24[a21 + 1] = n24[1], r24[a21 + 2] = n24[2];
}
var ee = n2();
function te2(e25, t20, r24, s16, n24, a21, i17, o22, l26, c21, h18) {
  let m15 = n24, p21 = n24 + 1, d22 = n24 + i17, u16 = n24 + i17 + 1, f22 = o22, g17 = o22 + 1, y9 = o22 + 2 * a21, _14 = o22 + 2 * a21 + 1;
  h18 < 0 && (m15 = n24 + i17 + 1, u16 = n24), c21 *= 3;
  for (let b13 = 0; b13 < a21; ++b13)
    b13 === a21 - 1 && (h18 > 0 ? (p21 = n24, u16 = n24 + i17) : (p21 = n24, m15 = n24 + i17)), oe(e25, m15, p21, d22, ee), $(e25, t20, s16, r24, ee, f22, m15), $(e25, t20, s16, r24, ee, g17, p21), $(e25, t20, s16, r24, ee, y9, d22), $(e25, t20, s16, r24, ee, _14, u16), l26[c21++] = f22, l26[c21++] = y9, l26[c21++] = _14, l26[c21++] = f22, l26[c21++] = _14, l26[c21++] = g17, m15++, p21++, d22++, u16++, f22 += 2, g17 += 2, y9 += 2, _14 += 2;
}
var re = n2();
var se = n2();
var ne2 = n2();
var ae = n2();
var ie = n2();
function oe(e25, t20, r24, s16, n24) {
  t20 *= 3, r24 *= 3, s16 *= 3, o3(re, e25[t20++], e25[t20++], e25[t20++]), o3(se, e25[r24++], e25[r24++], e25[r24++]), o3(ne2, e25[s16++], e25[s16++], e25[s16++]), e5(ae, se, re), e5(ie, ne2, re), _(n24, ie, ae), z2(n24, n24);
}
var le = n2();
function ce(e25, t20, r24, s16) {
  const n24 = e25.stageObject, a21 = n24.geometryRecords, i17 = a21.length, l26 = "absolute-height" !== t20.mode;
  let h18 = 0;
  const m15 = n24.transformation, d22 = h2(e8(), m15);
  for (let o22 = 0; o22 < i17; o22 += 2) {
    const e26 = a21[o22].geometry, i18 = e26.getMutableAttribute(O.POSITION).data, c21 = e26.vertexAttributes.get(O.SIZE).data, u16 = e26.vertexAttributes.get(O.MAPPOS).data, g17 = new t11(u16), y9 = i18.length / 3;
    let _14 = 0, b13 = false, E19 = 0;
    const x13 = r24.spatialReference;
    for (let n25 = 0; n25 < y9; n25++) {
      le[0] = i18[_14], le[1] = i18[_14 + 1], le[2] = i18[_14 + 2], d7(g17, r24, t20, s16, pe), l26 && (E19 += pe.sampledElevation), t10.TESTS_DISABLE_OPTIMIZATIONS ? (o3(he, g17.array[g17.offset + 0], g17.array[g17.offset + 1], pe.z + c21[_14 / 3]), s16.toRenderCoords(he, x13, he), L(he, he, d22)) : (o3(he, i18[_14 + 0], i18[_14 + 1], i18[_14 + 2]), L(he, he, m15), s16.setAltitude(he, pe.z + c21[_14 / 3]), L(he, he, d22)), i18[_14] = he[0], i18[_14 + 1] = he[1], i18[_14 + 2] = he[2];
      const e27 = fe / s16.unitInMeters;
      (Math.abs(le[0] - i18[_14]) >= e27 || Math.abs(le[1] - i18[_14 + 1]) >= e27 || Math.abs(le[2] - i18[_14 + 2]) >= e27) && (b13 = true), g17.offset += 3, _14 += 3;
    }
    b13 && (e26.invalidateBoundingInfo(), n24.geometryVertexAttrsUpdated(a21[o22]), a21[o22 + 1].geometry.invalidateBoundingInfo(), n24.geometryVertexAttrsUpdated(a21[o22 + 1])), h18 += E19 / y9;
  }
  return h18 / i17;
}
var he = n2();
var me = n2();
var pe = new j7();
var de = [0, 2, 1];
var ue = [0, 1, 2];
var fe = 0.01;

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DDrapedGraphicLayer.js
var u13 = class {
  constructor(e25, t20, r24, i17) {
    this.graphics3DSymbolLayer = e25, this.renderGeometries = t20, this.boundingBox = r24, this._drapeSourceRenderer = i17, this.type = "draped", this.stage = null, this._visible = false, this._addedToStage = false, this.isElevationSource = false;
  }
  initialize(e25) {
    this.stage = e25;
  }
  setVisibility(e25) {
    if (null != this.stage && this._visible !== e25) {
      if (this._visible = e25, e25 && !this._addedToStage)
        return this._addedToStage = true, void this._drapeSourceRenderer.addGeometries(this.renderGeometries, E8.Geometry.ADD);
      if (e25 || this._addedToStage) {
        for (const e26 of this.renderGeometries)
          e26.instanceParameters.visible = this._visible;
        this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, E8.State.VISIBILITIES);
      }
    }
  }
  destroy() {
    this.stage && this._addedToStage && this._drapeSourceRenderer.removeGeometries(this.renderGeometries, E8.Geometry.REMOVE), this._addedToStage = false, this._visible = false, this.stage = null;
  }
  getCenterObjectSpace(e25 = n2()) {
    return o3(e25, 0, 0, 0);
  }
  getBoundingBoxObjectSpace(e25 = a3()) {
    return B(e25);
  }
  addObjectState(e25, t20) {
    e25 === u9.Highlight && (this.renderGeometries.forEach((e26) => {
      const r24 = e26.addHighlight();
      t20.addRenderGeometry(e26, r24, this);
    }), this._addedToStage && this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, E8.State.HIGHLIGHTS));
  }
  removeObjectState(e25) {
    this.renderGeometries.forEach((t20) => {
      e25.removeRenderGeometry(t20);
    });
  }
  removeRenderGeometryObjectState(e25, t20) {
    e25.removeHighlight(t20), this._addedToStage && this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, E8.State.HIGHLIGHTS);
  }
  computeAttachmentOrigin(e25) {
    for (const t20 of this.renderGeometries)
      t20.computeAttachmentOrigin(S8) && (e25.draped.origin[0] += S8[0], e25.draped.origin[1] += S8[1], e25.draped.num++);
  }
  async getProjectedBoundingBox(t20, r24, i17, n24, a21) {
    B(a21);
    for (let e25 = 0; e25 < this.renderGeometries.length; e25++) {
      const r25 = this.renderGeometries[e25];
      this._getRenderGeometryProjectedBoundingRect(r25, t20, l23, i17), c4(a21, l23);
    }
    if (r24) {
      let t21;
      p5(a21, S8);
      const i18 = V3(a21, r24);
      try {
        t21 = await r24.service.queryElevation(S8[0], S8[1], n24, i18, "ground");
      } catch (h18) {
      }
      r(t21) && (a21[2] = Math.min(a21[2], t21), a21[5] = Math.max(a21[5], t21));
    }
    return a21;
  }
  _getRenderGeometryProjectedBoundingRect(e25, t20, r24, i17) {
    if (this.boundingBox)
      A(p15, this.boundingBox);
    else {
      const t21 = e25.boundingSphere, r25 = t21[3];
      p15[0] = t21[0] - r25, p15[1] = t21[1] - r25, p15[2] = t21[2] - r25, p15[3] = t21[0] + r25, p15[4] = t21[1] + r25, p15[5] = t21[2] + r25;
    }
    return t20(p15, 0, 2), this.calculateRelativeScreenBounds && i17.push({ location: p5(p15), screenSpaceBoundingRect: this.calculateRelativeScreenBounds() }), G2(p15, r24);
  }
};
var l23 = u5();
var p15 = a3();
var S8 = n2();

// node_modules/@arcgis/core/views/3d/layers/support/FastSymbolUpdates.js
var S9;
var y4;
var h14;
function x8(e25) {
  return null != e25;
}
function b8(e25) {
  return "number" == typeof e25;
}
function C7(e25) {
  return "string" == typeof e25;
}
function g14(e25) {
  return null == e25 || C7(e25);
}
function M6(e25, o22) {
  e25 && e25.push(o22);
}
function V5(e25, o22, t20, i17 = e8()) {
  const n24 = e25 || 0, r24 = o22 || 0, s16 = t20 || 0;
  return 0 !== n24 && m4(i17, i17, -n24 / 180 * Math.PI), 0 !== r24 && b(i17, i17, r24 / 180 * Math.PI), 0 !== s16 && l6(i17, i17, s16 / 180 * Math.PI), i17;
}
function D4(e25, o22, t20, i17, n24) {
  const r24 = e25.minSize, s16 = e25.maxSize;
  if (e25.expression)
    return M6(n24, "Could not convert size info: expression not supported"), false;
  if (e25.useSymbolValue) {
    const e26 = i17.symbolSize[t20];
    return o22.minSize[t20] = e26, o22.maxSize[t20] = e26, o22.offset[t20] = o22.minSize[t20], o22.factor[t20] = 0, o22.type[t20] = S9.DefinedSize, true;
  }
  if (x8(e25.field))
    return x8(e25.stops) ? 2 === e25.stops.length && b8(e25.stops[0].size) && b8(e25.stops[1].size) ? (T6(e25.stops[0].size, e25.stops[1].size, e25.stops[0].value, e25.stops[1].value, o22, t20), o22.type[t20] = S9.DefinedSize, true) : (M6(n24, "Could not convert size info: stops only supported with 2 elements"), false) : b8(r24) && b8(s16) && x8(e25.minDataValue) && x8(e25.maxDataValue) ? (T6(r24, s16, e25.minDataValue, e25.maxDataValue, o22, t20), o22.type[t20] = S9.DefinedSize, true) : null != m6[e25.valueUnit] ? (o22.minSize[t20] = -1 / 0, o22.maxSize[t20] = 1 / 0, o22.offset[t20] = 0, o22.factor[t20] = 1 / m6[e25.valueUnit], o22.type[t20] = S9.DefinedSize, true) : "unknown" === e25.valueUnit ? (M6(n24, "Could not convert size info: proportional size not supported"), false) : (M6(n24, "Could not convert size info: scale-dependent size not supported"), false);
  if (!x8(e25.field)) {
    if (e25.stops && e25.stops[0] && b8(e25.stops[0].size))
      return o22.minSize[t20] = e25.stops[0].size, o22.maxSize[t20] = e25.stops[0].size, o22.offset[t20] = o22.minSize[t20], o22.factor[t20] = 0, o22.type[t20] = S9.DefinedSize, true;
    if (b8(r24))
      return o22.minSize[t20] = r24, o22.maxSize[t20] = r24, o22.offset[t20] = r24, o22.factor[t20] = 0, o22.type[t20] = S9.DefinedSize, true;
  }
  return M6(n24, "Could not convert size info: unsupported variant of sizeInfo"), false;
}
function T6(e25, o22, t20, i17, n24, r24) {
  const s16 = Math.abs(i17 - t20) > 0 ? (o22 - e25) / (i17 - t20) : 0;
  n24.minSize[r24] = s16 > 0 ? e25 : o22, n24.maxSize[r24] = s16 > 0 ? o22 : e25, n24.offset[r24] = e25 - t20 * s16, n24.factor[r24] = s16;
}
function U5(e25, o22, t20, i17) {
  if (e25.normalizationField || e25.valueRepresentation)
    return M6(i17, "Could not convert size info: unsupported property"), null;
  if (!g14(e25.field))
    return M6(i17, "Could not convert size info: field is not a string"), null;
  if (o22.size) {
    if (e25.field)
      if (o22.size.field) {
        if (e25.field !== o22.size.field)
          return M6(i17, "Could not convert size info: multiple fields in use"), null;
      } else
        o22.size.field = e25.field;
  } else
    o22.size = { field: e25.field, minSize: [0, 0, 0], maxSize: [0, 0, 0], offset: [0, 0, 0], factor: [0, 0, 0], type: [S9.Undefined, S9.Undefined, S9.Undefined] };
  let n24;
  switch (e25.axis) {
    case "width":
      return n24 = D4(e25, o22.size, 0, t20, i17), n24 ? o22 : null;
    case "height":
      return n24 = D4(e25, o22.size, 2, t20, i17), n24 ? o22 : null;
    case "depth":
      return n24 = D4(e25, o22.size, 1, t20, i17), n24 ? o22 : null;
    case "width-and-depth":
      return n24 = D4(e25, o22.size, 0, t20, i17), n24 && D4(e25, o22.size, 1, t20, i17), n24 ? o22 : null;
    case null:
    case void 0:
    case "all":
      return n24 = D4(e25, o22.size, 0, t20, i17), n24 = n24 && D4(e25, o22.size, 1, t20, i17), n24 = n24 && D4(e25, o22.size, 2, t20, i17), n24 ? o22 : null;
    default:
      return M6(i17, `Could not convert size info: unknown axis "${e25.axis}""`), null;
  }
}
function E13(e25, o22, t20) {
  for (let n24 = 0; n24 < 3; ++n24) {
    let t21 = o22.unitInMeters;
    e25.type[n24] === S9.DefinedSize && (t21 *= o22.modelSize[n24], e25.type[n24] = S9.DefinedScale), e25.minSize[n24] = e25.minSize[n24] / t21, e25.maxSize[n24] = e25.maxSize[n24] / t21, e25.offset[n24] = e25.offset[n24] / t21, e25.factor[n24] = e25.factor[n24] / t21;
  }
  let i17;
  if (e25.type[0] !== S9.Undefined)
    i17 = 0;
  else if (e25.type[1] !== S9.Undefined)
    i17 = 1;
  else {
    if (e25.type[2] === S9.Undefined)
      return M6(t20, "No size axis contains a valid size or scale"), false;
    i17 = 2;
  }
  for (let n24 = 0; n24 < 3; ++n24)
    e25.type[n24] === S9.Undefined && (e25.minSize[n24] = e25.minSize[i17], e25.maxSize[n24] = e25.maxSize[i17], e25.offset[n24] = e25.offset[i17], e25.factor[n24] = e25.factor[i17], e25.type[n24] = e25.type[i17]);
  return true;
}
function O9(e25, o22, t20) {
  e25[4 * o22 + 0] = t20.r / 255, e25[4 * o22 + 1] = t20.g / 255, e25[4 * o22 + 2] = t20.b / 255, e25[4 * o22 + 3] = t20.a;
}
function j8(e25, o22, t20) {
  if (e25.normalizationField)
    return M6(t20, "Could not convert color info: unsupported property"), null;
  if (C7(e25.field)) {
    if (!e25.stops)
      return M6(t20, "Could not convert color info: missing stops or colors"), null;
    {
      if (e25.stops.length > 8)
        return M6(t20, "Could not convert color info: too many color stops"), null;
      o22.color = { field: e25.field, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      const i17 = e25.stops;
      for (let e26 = 0; e26 < 8; ++e26) {
        const t21 = i17[Math.min(e26, i17.length - 1)];
        o22.color.values[e26] = t21.value, O9(o22.color.colors, e26, t21.color);
      }
    }
  } else {
    if (!(e25.stops && e25.stops.length >= 0))
      return M6(t20, "Could not convert color info: no field and no colors/stops"), null;
    {
      const t21 = e25.stops && e25.stops.length >= 0 && e25.stops[0].color;
      o22.color = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      for (let e26 = 0; e26 < 8; e26++)
        o22.color.values[e26] = 1 / 0, O9(o22.color.colors, e26, t21);
    }
  }
  return o22;
}
function k3(e25, o22, t20) {
  if (e25.normalizationField)
    return M6(t20, "Could not convert opacity info: unsupported property"), null;
  if (C7(e25.field)) {
    if (!e25.stops)
      return M6(t20, "Could not convert opacity info: missing stops or opacities"), null;
    {
      if (e25.stops.length > 8)
        return M6(t20, "Could not convert opacity info: too many opacity stops"), null;
      o22.opacity = { field: e25.field, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0] };
      const i17 = e25.stops;
      for (let e26 = 0; e26 < 8; ++e26) {
        const t21 = i17[Math.min(e26, i17.length - 1)];
        o22.opacity.values[e26] = t21.value, o22.opacity.opacityValues[e26] = t21.opacity;
      }
    }
  } else {
    if (!(e25.stops && e25.stops.length >= 0))
      return M6(t20, "Could not convert opacity info: no field and no opacities/stops"), null;
    {
      const t21 = e25.stops && e25.stops.length >= 0 && e25.stops[0].opacity;
      o22.opacity = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0] };
      for (let e26 = 0; e26 < 8; e26++)
        o22.opacity.values[e26] = 1 / 0, o22.opacity.opacityValues[e26] = t21;
    }
  }
  return o22;
}
function w5(e25, o22, t20) {
  const i17 = 2 === t20 && "arithmetic" === e25.rotationType;
  o22.offset[t20] = i17 ? 90 : 0, o22.factor[t20] = i17 ? -1 : 1, o22.type[t20] = 1;
}
function F6(e25, o22, t20) {
  if (!C7(e25.field))
    return M6(t20, "Could not convert rotation info: field is not a string"), null;
  if (o22.rotation) {
    if (e25.field)
      if (o22.rotation.field) {
        if (e25.field !== o22.rotation.field)
          return M6(t20, "Could not convert rotation info: multiple fields in use"), null;
      } else
        o22.rotation.field = e25.field;
  } else
    o22.rotation = { field: e25.field, offset: [0, 0, 0], factor: [1, 1, 1], type: [0, 0, 0] };
  switch (e25.axis) {
    case "tilt":
      return w5(e25, o22.rotation, 0), o22;
    case "roll":
      return w5(e25, o22.rotation, 1), o22;
    case null:
    case void 0:
    case "heading":
      return w5(e25, o22.rotation, 2), o22;
    default:
      return M6(t20, `Could not convert rotation info: unknown axis "${e25.axis}""`), null;
  }
}
function A6(e25, o22, t20) {
  if (!e25)
    return null;
  const i17 = !o22.supportedTypes || !!o22.supportedTypes.size, n24 = !o22.supportedTypes || !!o22.supportedTypes.color, r24 = !o22.supportedTypes || !!o22.supportedTypes.rotation, s16 = !!o22.supportedTypes && !!o22.supportedTypes.opacity, l26 = e25.reduce((e26, l27) => {
    if (!e26)
      return e26;
    if (l27.valueExpression)
      return M6(t20, "Could not convert visual variables: arcade expressions not supported"), null;
    switch (l27.type) {
      case "size":
        return i17 ? U5(l27, e26, o22, t20) : e26;
      case "color":
        return n24 ? j8(l27, e26, t20) : e26;
      case "opacity":
        return s16 ? k3(l27, e26, t20) : null;
      case "rotation":
        return r24 ? F6(l27, e26, t20) : e26;
      default:
        return null;
    }
  }, { size: null, color: null, opacity: null, rotation: null });
  return !(e25.length > 0 && l26) || l26.size || l26.color || l26.opacity || l26.rotation ? l26 && l26.size && !E13(l26.size, o22, t20) ? null : l26 : null;
}
function I3(e25) {
  return e25 && null != e25.size;
}
function P7(e25, o22) {
  if (!e25)
    return { enabled: false };
  if (t10.TESTS_DISABLE_FAST_UPDATES)
    return { enabled: false };
  const t20 = A6(e25.visualVariables, o22);
  return t20 ? { enabled: true, visualVariables: t20, materialParameters: q7(t20, o22), requiresShaderTransformation: I3(t20) } : { enabled: false };
}
function R7(e25, o22, t20) {
  if (!o22 || !e25.enabled)
    return false;
  const i17 = e25.visualVariables, n24 = A6(o22.visualVariables, t20);
  return !!n24 && (!!(_9(i17.size, n24.size, "size") && _9(i17.color, n24.color, "color") && _9(i17.rotation, n24.rotation, "rotation") && _9(i17.opacity, n24.opacity, "opacity")) && (e25.visualVariables = n24, e25.materialParameters = q7(n24, t20), e25.requiresShaderTransformation = I3(n24), true));
}
function _9(e25, o22, t20) {
  if (!!e25 != !!o22)
    return false;
  if (e25 && e25.field !== o22.field)
    return false;
  if (e25 && "rotation" === t20) {
    const t21 = e25, i17 = o22;
    for (let e26 = 0; e26 < 3; e26++)
      if (t21.type[e26] !== i17.type[e26] || t21.offset[e26] !== i17.offset[e26] || t21.factor[e26] !== i17.factor[e26])
        return false;
  }
  return true;
}
function q7(e25, n24) {
  const r24 = { vvSizeEnabled: false, vvSizeMinSize: null, vvSizeMaxSize: null, vvSizeOffset: null, vvSizeFactor: null, vvSizeValue: null, vvColorEnabled: false, vvColorValues: null, vvColorColors: null, vvOpacityEnabled: false, vvOpacityValues: null, vvOpacityOpacities: null, vvSymbolAnchor: null, vvSymbolRotationMatrix: null }, s16 = I3(e25);
  return e25 && e25.size ? (r24.vvSizeEnabled = true, r24.vvSizeMinSize = e25.size.minSize, r24.vvSizeMaxSize = e25.size.maxSize, r24.vvSizeOffset = e25.size.offset, r24.vvSizeFactor = e25.size.factor) : e25 && s16 && (r24.vvSizeValue = n24.transformation.scale), e25 && s16 && (r24.vvSymbolAnchor = n24.transformation.anchor, r24.vvSymbolRotationMatrix = e7(), r6($2), V5(n24.transformation.rotation[2], n24.transformation.rotation[0], n24.transformation.rotation[1], $2), a5(r24.vvSymbolRotationMatrix, $2)), e25 && e25.color && (r24.vvColorEnabled = true, r24.vvColorValues = e25.color.values, r24.vvColorColors = e25.color.colors), e25 && e25.opacity && (r24.vvOpacityEnabled = true, r24.vvOpacityValues = e25.opacity.values, r24.vvOpacityOpacities = e25.opacity.opacityValues), r24;
}
!function(e25) {
  e25[e25.Undefined = 0] = "Undefined", e25[e25.DefinedSize = 1] = "DefinedSize", e25[e25.DefinedScale = 2] = "DefinedScale";
}(S9 || (S9 = {})), function(e25) {
  e25[e25.Undefined = 0] = "Undefined", e25[e25.DefinedAngle = 1] = "DefinedAngle";
}(y4 || (y4 = {})), function(o22) {
  const t20 = e8(), i17 = n2();
  function u16(o23, u17, f23) {
    if (!o23.vvSizeEnabled)
      return f23;
    n5(t20, f23);
    const c21 = o23.vvSymbolRotationMatrix;
    s4($2, c21[0], c21[1], c21[2], 0, c21[3], c21[4], c21[5], 0, c21[6], c21[7], c21[8], 0, 0, 0, 0, 1), u4(t20, t20, $2);
    for (let t21 = 0; t21 < 3; ++t21) {
      const n24 = o23.vvSizeOffset[t21] + u17[0] * o23.vvSizeFactor[t21];
      i17[t21] = o4(n24, o23.vvSizeMinSize[t21], o23.vvSizeMaxSize[t21]);
    }
    return i(t20, t20, i17), c3(t20, t20, o23.vvSymbolAnchor), t20;
  }
  function f22(o23, t21, i18) {
    if (!t21.vvSizeEnabled)
      return o3(o23, 1, 1, 1);
    for (let n24 = 0; n24 < 3; ++n24) {
      const r24 = t21.vvSizeOffset[n24] + i18[0] * t21.vvSizeFactor[n24];
      o23[n24] = o4(r24, t21.vvSizeMinSize[n24], t21.vvSizeMaxSize[n24]);
    }
    return o23;
  }
  o22.evaluateModelTransform = u16, o22.evaluateModelTransformScale = f22;
}(h14 || (h14 = {}));
var $2 = e8();
var B5 = h14.evaluateModelTransform;
var L6 = h14.evaluateModelTransformScale;

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DIconSymbolLayer.js
var ae2 = e8();
var oe2 = r2(0, 0, 1);
var ne3 = 16;
var le2 = 1.5;
var ce2 = a10;
var he2 = [ce2 / 2, ce2 / 2, 1 - ce2 / 2, 1 - ce2 / 2];
var me2 = [e14 * ce2, e14 * ce2];
var ue2 = class extends y3 {
  constructor(e25, t20, r24, i17) {
    super(e25, t20, r24, i17), this._cimLayers = null, this._cimSymbolMaterials = /* @__PURE__ */ new Map(), this._cimSymbolTextures = /* @__PURE__ */ new Map(), this._cimMaterialParametersInfo = null, this._cimRequiredFields = null, this._cimScaleFactorOrFunction = null, this._size = null, this._symbolTextureRatio = 1, this._outlineSize = 0, this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: true };
  }
  getCachedSize() {
    return { size: this._getIconSize() };
  }
  async doLoad(e25) {
    this._validateOrThrow();
    const t20 = this._prepareMaterialParameters(), r24 = this._getPrimitive();
    if (r(r24))
      this._prepareResourcesPrimitive(t20, r24);
    else {
      const r25 = g6(this.symbol, this.symbolLayer), i17 = nt(r25);
      i17 && "application/json" === i17.mediaType ? await this._prepareResourcesCIM(t20, JSON.parse(i17.data), e25) : await this._prepareResourcesHref(t20, r25, e25);
    }
  }
  _validateOrThrow() {
    if (this._drivenProperties.size)
      return;
    const e25 = O4(this._getIconSize());
    if (e25)
      throw new s2("graphics3diconsymbollayer:invalid-size", e25);
  }
  _getIconSize() {
    const e25 = this.symbolLayer, t20 = Math.round(null != e25.size ? u3(e25.size) : ne3);
    return this._drivenProperties.size ? Math.max(t20, 64) : t20;
  }
  _generateTextureCIM(e25) {
    const t20 = this._getGraphicHash(e25);
    let r24 = "" === t20 ? null : this._cimSymbolTextures.get(t20);
    if (!r24) {
      const i17 = { scaleFactor: this._cimScaleFactorOrFunction }, s16 = this._context.sharedResources.cimSymbolRasterizer.rasterizeCIMSymbol(this._cimLayers, e25, "esriGeometryPoint", i17, null, null);
      this._cimMaterialParametersInfo.anchorPosition = this._getAnchorPos("relative", s16.anchorPosition);
      const a21 = { width: s16.imageData.width, height: s16.imageData.height, powerOfTwoResizeMode: l12.PAD };
      r24 = new L3(s16.imageData, a21), this._cimSymbolTextures.set(t20, r24), this._context.stage.add(r24);
    }
    return r24;
  }
  _computeSize(e25, t20) {
    const r24 = e25.width / e25.height;
    return r24 > 1 ? [t20, Math.round(t20 / r24)] : [Math.round(t20 * r24), t20];
  }
  _prepareMaterialParameters() {
    const e25 = { anchorPosition: this._getAnchorPos(this.symbolLayer.anchor, this.symbolLayer.anchorPosition) }, t20 = this.symbol;
    if (de2(t20)) {
      const { screenLength: r24, minWorldLength: i17, maxWorldLength: s16 } = t20.verticalOffset;
      e25.verticalOffset = { screenLength: u3(r24), minWorldLength: i17 || 0, maxWorldLength: null != s16 ? s16 : 1 / 0 };
    }
    return this._context.screenSizePerspectiveEnabled && (e25.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings), e25.occlusionTest = true, e25.hasSlicePlane = this._context.slicePlaneEnabled, e25;
  }
  _prepareResourcesPrimitive(e25, t20) {
    const r24 = this._getOutlineSize();
    if (_e2(t20) && 0 === r24)
      throw new Error("Nothing to render");
    this._outlineSize = r24, e25.color = this._getFillColor(), e25.outlineColor = this._getOutlineColor(), e25.outlineSize = this._outlineSize;
    const i17 = this._context.sharedResources.textures.fromData(t20, () => o16(t20));
    this._texture = i17.texture, this._releaseTexture = i17, e25.textureIsSignedDistanceField = true, e25.distanceFieldBoundingBox = he2, e25.textureId = this._texture.id;
    const s16 = this._getIconSize();
    this._size = [s16, s16], this._symbolTextureRatio = 1 / ce2, this._createMaterialAndAddToStage(e25, this._context.stage);
  }
  async _prepareResourcesHref(e25, s16, a21) {
    if (!a("esri-canvas-svg-support") && It(s16)) {
      throw new s2("graphics3diconsymbollayer:unsupported-image-format", "IconSymbol3DLayer failed to load (SVG symbols are not supported in IE11)");
    }
    this._outlineSize = this._getOutlineSize(), e25.color = this._getFillColor(), e25.outlineColor = this._getOutlineColor(), e25.outlineSize = this._outlineSize, e25.textureIsSignedDistanceField = false;
    const o22 = this._getIconSize(), n24 = o22 * this._context.graphicsCoreOwner.view.state.pixelRatio, l26 = await a6(this._context.sharedResources.textures.fromUrl(s16, n24, { signal: a21 }));
    if (false === l26.ok) {
      w(l26.error);
      throw new s2("graphics3diconsymbollayer:request-failed", `Failed to load (Request for icon resource failed: ${s16})`);
    }
    this._releaseTexture = l26.value;
    const c21 = l26.value.texture, m15 = c21.params;
    this._size = this._computeSize(m15, o22), e25.textureId = c21.id, this._createMaterialAndAddToStage(e25, this._context.stage);
  }
  async _prepareResourcesCIM(e25, t20, r24) {
    const i17 = new d3({ data: t20 });
    if (!this._context.sharedResources.cimSymbolRasterizer) {
      const e26 = (await import("./CIMSymbolRasterizer-6TTDKW2Q.js")).CIMSymbolRasterizer;
      f(r24), this._context.sharedResources.cimSymbolRasterizer || (this._context.sharedResources.cimSymbolRasterizer = new e26(this._context.renderCoordsHelper.spatialReference, true));
    }
    const s16 = this._context.layer.fields ? this._context.layer.fields.map((e26) => e26.toJSON()) : null;
    let a21, o22;
    if (this._cimLayers = await this._context.sharedResources.cimSymbolRasterizer.analyzeCIMSymbol(i17, s16, this._context.renderer && "dictionary" === this._context.renderer.type ? this._context.renderer.fieldMap : null, "esriGeometryPoint", { signal: r24 }), this._context.renderer && "dictionary" === this._context.renderer.type && this._context.renderer.scaleExpression) {
      const e26 = this._context.renderer;
      if (isNaN(e26.scaleExpression)) {
        const t21 = e26.scaleExpression, r25 = await i8(t21, this._context.layer.spatialReference, s16);
        o22 = (e27, t22, i18) => {
          const s17 = s6(r25, e27, { $view: i18 }, "esriGeometryPoint", t22);
          return null !== s17 ? s17 : 1;
        };
      } else
        a21 = Number(e26.scaleExpression);
    }
    this._cimScaleFactorOrFunction = a21 || o22 || 1;
    const n24 = this._context.renderer ? await this._context.renderer.getRequiredFields(this._context.layer.fieldsIndex) : [];
    f(r24);
    const l26 = this._context.layer.fieldsIndex;
    this._cimRequiredFields = n24.map((e26) => l26.get(e26).name), this._cimMaterialParametersInfo = e25, this._cimMaterialParametersInfo.color = this._getFillColor(), this._cimMaterialParametersInfo.outlineColor = [0, 0, 0, 0], this._cimMaterialParametersInfo.outlineSize = 0, this._cimMaterialParametersInfo.textureIsSignedDistanceField = false;
  }
  _getPrimitive() {
    return this.symbolLayer.resource && this.symbolLayer.resource.href ? null : this.symbolLayer.resource && this.symbolLayer.resource.primitive || j5;
  }
  _getOutlineSize() {
    let e25 = 0;
    const t20 = this.symbolLayer;
    if (r(t20.outline) && null != t20.outline.size)
      return Math.max(u3(t20.outline.size), 0);
    return e25 = _e2(this._getPrimitive()) ? le2 : 0, Math.max(e25, 0);
  }
  _getOutlineColor() {
    const t20 = this._getLayerOpacity(), r24 = this.symbolLayer, i17 = m(r24, "outline", "color");
    if (r(i17)) {
      const r25 = l4.toUnitRGB(i17), s16 = i17.a * t20;
      return [r25[0], r25[1], r25[2], s16];
    }
    return [0, 0, 0, 0];
  }
  _getFillColor() {
    if (_e2(this._getPrimitive()))
      return t13;
    const e25 = t(this._getPrimitive()), t20 = m(this.symbolLayer, "material", "color");
    return this._getCombinedOpacityAndColor(t20, { hasIntrinsicColor: e25 });
  }
  _getAnchorPos(e25, t20) {
    return "relative" === e25 ? r11((t20.x || 0) + 0.5, 0.5 - (t20.y || 0)) : e25 in o18 ? o18[e25] : o18.center;
  }
  _createMaterialAndAddToStage(e25, t20) {
    if (this._cimLayers ? this._fastUpdates = { enabled: false } : this._fastUpdates = P7(this._context.renderer, this._fastVisualVariableConvertOptions()), this._fastUpdates.enabled && Object.assign(e25, this._fastUpdates.materialParameters), this._cimLayers) {
      let r24 = r(e25.textureId) ? this._cimSymbolMaterials.get(e25.textureId) : null;
      return r24 || (r24 = new J3(e25), this._cimSymbolMaterials.set(c(e25.textureId, 0), r24), t20.add(r24)), r24;
    }
    return this._material = new J3(e25), t20.add(this._material), this._material;
  }
  _setDrapingDependentMaterialParameters() {
    this.draped && (this._forEachMaterial((e25) => {
      e25.setParameters({ verticalOffset: null, screenSizePerspective: null, occlusionTest: false, hasSlicePlane: false, shaderPolygonOffset: 0, isDraped: this.draped });
    }), this.layerOpacityChanged());
  }
  destroy() {
    super.destroy(), this._forEachMaterial((e25) => this._context.stage.remove(e25)), this._material = null, this._cimSymbolMaterials.clear(), this._cimSymbolTextures.forEach((e25) => this._context.stage.remove(e25)), this._cimSymbolTextures.clear(), this._releaseTexture = p(this._releaseTexture);
  }
  _getScaleFactor(e25, t20) {
    if (this._drivenProperties.size && e25.size) {
      for (let t21 = 0; t21 < 3; t21++) {
        const r24 = e25.size[t21];
        r24 && "symbol-value" !== r24 && "proportional" !== r24 && (e25.size[t21] = u3(r24));
      }
      if ("symbol-value" === e25.size[0])
        return 1;
      if (isFinite(+e25.size[0]))
        return +e25.size[0] / t20;
      if (isFinite(+e25.size[2]))
        return +e25.size[2] / t20;
    }
    return 1;
  }
  createGraphics3DGraphic(e25) {
    const t20 = e25.graphic;
    if (!this._validateGeometry(t20.geometry))
      return null;
    let r24, i17;
    if (this._cimLayers) {
      if (!this._cimLayers.length)
        return null;
      const e26 = this._generateTextureCIM(t20), s17 = { textureId: e26.id, ...this._cimMaterialParametersInfo };
      i17 = this._createMaterialAndAddToStage(s17, this._context.stage), r24 = [e26.params.width, e26.params.height];
    } else
      r24 = this._size, i17 = e2(this._material);
    const s16 = d9(t20.geometry);
    if (t(s16))
      return this.logger.warn(`unsupported geometry type for icon symbol: ${t20.geometry.type}`), null;
    const a21 = e25.renderingInfo, n24 = this._getVertexOpacityAndColor(a21);
    let l26 = 1;
    if (!this._fastUpdates.enabled || !this._fastUpdates.visualVariables.size) {
      const e26 = r24[0] > r24[1] ? r24[0] : r24[1];
      l26 = this._getScaleFactor(a21, e26);
    }
    l26 *= this._symbolTextureRatio;
    const h18 = [r24[0] * l26, r24[1] * l26], m15 = this.setGraphicElevationContext(t20, new h10());
    return this.ensureDrapedStatus("on-the-ground" === m15.mode) && this._setDrapingDependentMaterialParameters(), this.draped ? this._createAsOverlay(t20, s16, i17, n24, h18, e25.layer.uid) : this._createAs3DShape(t20, s16, i17, n24, h18, m15, t20.uid);
  }
  layerOpacityChanged() {
    const e25 = this._getFillColor(), t20 = this._getOutlineColor();
    return this._forEachMaterial((r24) => {
      r24.setParameters({ color: e25 }), r24.setParameters({ outlineColor: t20 });
    }), true;
  }
  layerElevationInfoChanged(e25, t20, r24) {
    const i17 = this._elevationContext.mode, s16 = p10(ue2.elevationModeChangeTypes, r24, i17);
    if (s16 !== x5.UPDATE)
      return s16;
    const a21 = g7(i17) || "absolute-height" === i17;
    return this.updateGraphics3DGraphicElevationInfo(e25, t20, () => a21);
  }
  slicePlaneEnabledChanged() {
    return this.draped || this._forEachMaterial((e25) => {
      e25.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return !!this._getPrimitive();
  }
  applyRendererDiff(e25, t20) {
    for (const r24 in e25.diff) {
      if ("visualVariables" !== r24)
        return e16.Recreate_Symbol;
      if (!R7(this._fastUpdates, t20, this._fastVisualVariableConvertOptions()))
        return e16.Recreate_Symbol;
      r(this._material) && this._material.setParameters(this._fastUpdates.materialParameters);
    }
    return e16.Fast_Update;
  }
  _defaultElevationInfoNoZ() {
    return pe2;
  }
  _createAs3DShape(e25, t20, r24, i17, s16, a21, o22) {
    const n24 = this.getFastUpdateAttrValues(e25), l26 = n24 ? (e26) => B5(this._fastUpdates.materialParameters, n24, e26) : null, c21 = [T3.createPointGeometry(oe2, null, i17, s16, fe2, null, n24)], h18 = f11(this._context, t20, c21, [r24], a21, this._context.layer.uid, o22, l26);
    if (null === h18)
      return null;
    const m15 = new p14(this, h18.object, c21, null, null, d12, a21);
    return m15.alignedSampledElevation = h18.sampledElevation, m15.needsElevationUpdates = g7(a21.mode) || "absolute-height" === a21.mode, m15.getScreenSize = this._createScreenSizeGetter(s16, l26), m15.calculateRelativeScreenBounds = (e26) => r24.calculateRelativeScreenBounds(m15.getScreenSize(), 1, e26), g8(m15, t20, this._context.elevationProvider), m15;
  }
  _createAsOverlay(e25, t20, r24, i17, a21, o22) {
    r24.renderPriority = this._renderPriority;
    const n24 = n4();
    Hn(t20, n24, this._context.overlaySR), n24[2] = _e;
    const l26 = this._context.clippingExtent;
    if (r(l26) && !E2(l26, n24))
      return null;
    const c21 = this.getFastUpdateAttrValues(e25), h18 = c21 ? (e26) => B5(this._fastUpdates.materialParameters, c21, e26) : null, m15 = T3.createPointGeometry(oe2, n24, i17, a21, null, null, c21), u16 = new T4(m15, r24, { layerUid: o22, graphicUid: e25.uid, calculateShaderTransformation: h18 });
    n24[3] = 0, a2(u16.boundingSphere, n24);
    const d22 = new u13(this, [u16], null, this._context.drapeSourceRenderer);
    return d22.getScreenSize = this._createScreenSizeGetter(a21, h18), d22.calculateRelativeScreenBounds = (e26) => r24.calculateRelativeScreenBounds(d22.getScreenSize(), 1, e26), d22;
  }
  _createScreenSizeGetter(e25, t20) {
    const r24 = this._outlineSize + 2;
    if (this._fastUpdates.enabled) {
      const i17 = e25[0] / this._symbolTextureRatio, s16 = e25[1] / this._symbolTextureRatio;
      return (e26 = n8()) => {
        const a21 = t20(ae2);
        return e26[0] = a21[0] * i17 + r24, e26[1] = a21[5] * s16 + r24, e26;
      };
    }
    {
      const t21 = e25[0] / this._symbolTextureRatio + r24, i17 = e25[1] / this._symbolTextureRatio + r24;
      return (e26 = n8()) => (e26[0] = t21, e26[1] = i17, e26);
    }
  }
  _fastVisualVariableConvertOptions() {
    const e25 = this._size[0] > this._size[1] ? this._size[0] : this._size[1], t20 = r2(e25, e25, e25), r24 = e6(1), i17 = e25 * r24;
    return { modelSize: t20, symbolSize: r2(i17, i17, i17), unitInMeters: r24, transformation: { anchor: f2, scale: l, rotation: f2 } };
  }
  _getGraphicHash(e25) {
    let t20 = "";
    for (const r24 of this._cimRequiredFields)
      t20 += r24 + e25.attributes[r24];
    return t20;
  }
  _forEachMaterial(e25) {
    r(this._material) && e25(this._material), this._cimSymbolMaterials.forEach(e25);
  }
  test() {
    return { ...super.test(), material: this._material };
  }
};
function de2(e25) {
  return e25 && "point-3d" === e25.type && e25.hasVisibleVerticalOffset();
}
function _e2(e25) {
  return !t(e25) && ("cross" === e25 || "x" === e25);
}
ue2.PRIMITIVE_SIZE = me2, ue2.elevationModeChangeTypes = { definedChanged: x5.UPDATE, staysOnTheGround: x5.NONE, onTheGroundChanged: x5.RECREATE };
var pe2 = { mode: "relative-to-ground", offset: 0 };
var fe2 = r5(0, 0, 0, 1);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineMarkerTechnique.js
var A7 = /* @__PURE__ */ new Map([[O.POSITION, 0], [O.UV0, 2], [O.AUXPOS1, 3], [O.SIZE, 6], [O.SIZEFEATUREATTRIBUTE, 6], [O.COLOR, 5], [O.COLORFEATUREATTRIBUTE, 5], [O.OPACITYFEATUREATTRIBUTE, 7]]);
var R8 = class extends e11 {
  initializeProgram(e25) {
    const t20 = R8.shader.get().build(this.configuration);
    return new o13(e25.rctx, t20, A7);
  }
  _makePipelineState(t20, i17) {
    const c21 = this.configuration, a21 = t20 === O2.NONE;
    return W({ blending: c21.output === o10.Color || c21.output === o10.Alpha ? a21 ? c12 : E5(t20) : null, depthTest: { func: l16(t20) }, depthWrite: a21 ? c21.writeDepth && a7 : S2(t20), colorWrite: c11, stencilWrite: c21.hasOccludees ? e12 : null, stencilTest: c21.hasOccludees ? i17 ? o14 : f8 : null, polygonOffset: { factor: 0, units: -10 } });
  }
  initializePipeline() {
    return this.configuration.occluder && (this._occluderPipelineTransparent = W({ blending: c12, depthTest: s7, depthWrite: null, colorWrite: c11, stencilWrite: null, stencilTest: m7 }), this._occluderPipelineOpaque = W({ blending: c12, depthTest: s7, depthWrite: null, colorWrite: c11, stencilWrite: l17, stencilTest: P2 }), this._occluderPipelineMaskWrite = W({ blending: null, depthTest: i6, depthWrite: null, colorWrite: null, stencilWrite: e12, stencilTest: o14 })), this._occludeePipelineState = this._makePipelineState(this.configuration.transparencyPassType, true), this._makePipelineState(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e25, t20) {
    return t20 ? this._occludeePipelineState : this.configuration.occluder ? e25 === E6.TRANSPARENT_OCCLUDER_MATERIAL ? this._occluderPipelineTransparent : e25 === E6.OCCLUDER_MATERIAL ? this._occluderPipelineOpaque : this._occluderPipelineMaskWrite : super.getPipelineState(e25, t20);
  }
};
R8.shader = new t9(x6, () => import("./LineMarker.glsl-KXBK7MEH.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js
var s13 = class extends i7 {
  constructor() {
    super(...arguments), this.output = o10.Color, this.transparencyPassType = O2.NONE, this.occluder = false, this.hasSlicePlane = false, this.writeDepth = false, this.draped = false, this.hasCap = false, this.vvSize = false, this.vvColor = false, this.vvOpacity = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([e13({ count: o10.COUNT })], s13.prototype, "output", void 0), e([e13({ count: O2.COUNT })], s13.prototype, "transparencyPassType", void 0), e([e13()], s13.prototype, "occluder", void 0), e([e13()], s13.prototype, "hasSlicePlane", void 0), e([e13()], s13.prototype, "writeDepth", void 0), e([e13()], s13.prototype, "draped", void 0), e([e13()], s13.prototype, "hasCap", void 0), e([e13()], s13.prototype, "vvSize", void 0), e([e13()], s13.prototype, "vvColor", void 0), e([e13()], s13.prototype, "vvOpacity", void 0), e([e13()], s13.prototype, "hasOccludees", void 0), e([e13()], s13.prototype, "hasMultipassTerrain", void 0), e([e13()], s13.prototype, "cullAboveGround", void 0), e([e13({ constValue: true })], s13.prototype, "hasVvInstancing", void 0), e([e13({ constValue: true })], s13.prototype, "hasSliceTranslatedView", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/LineMarkerMaterial.js
var T7 = class extends d5 {
  constructor(e25) {
    super(e25, new v13()), this._vertexAttributeLocations = A7, this.techniqueConfig = new s13(), this.layout = this.createLayout();
  }
  dispose() {
  }
  getConfiguration(e25, t20) {
    return this.techniqueConfig.output = e25, this.techniqueConfig.draped = t20.slot === E6.DRAPED_MATERIAL, this.techniqueConfig.hasCap = this.parameters.cap !== r14.BUTT, this.techniqueConfig.hasSlicePlane = this.parameters.hasSlicePlane, this.techniqueConfig.hasOccludees = this.parameters.hasOccludees, this.techniqueConfig.writeDepth = this.parameters.writeDepth, this.techniqueConfig.vvColor = this.parameters.vvColorEnabled, this.techniqueConfig.vvOpacity = this.parameters.vvOpacityEnabled, this.techniqueConfig.vvSize = this.parameters.vvSizeEnabled, this.techniqueConfig.occluder = this.parameters.renderOccluded === h7.OccludeAndTransparentStencil, this.techniqueConfig.transparencyPassType = t20.transparencyPassType, this.techniqueConfig.hasMultipassTerrain = t20.multipassTerrain.enabled, this.techniqueConfig.cullAboveGround = t20.multipassTerrain.cullAboveGround, this.techniqueConfig;
  }
  intersect() {
  }
  createLayout() {
    const e25 = T2().vec3f(O.POSITION).vec2f(O.UV0).vec3f(O.AUXPOS1);
    return this.parameters.vvSizeEnabled ? e25.f32(O.SIZEFEATUREATTRIBUTE) : e25.f32(O.SIZE), this.parameters.vvColorEnabled ? e25.f32(O.COLORFEATUREATTRIBUTE) : e25.vec4f(O.COLOR), this.parameters.vvOpacityEnabled && e25.f32(O.OPACITYFEATUREATTRIBUTE), e25;
  }
  createBufferWriter() {
    return new C8(this.layout, this.parameters);
  }
  requiresSlot(e25, t20) {
    if (e25 === E6.DRAPED_MATERIAL)
      return true;
    if (this.parameters.renderOccluded === h7.OccludeAndTransparentStencil)
      return e25 === E6.OPAQUE_MATERIAL || e25 === E6.OCCLUDER_MATERIAL || e25 === E6.TRANSPARENT_OCCLUDER_MATERIAL;
    const r24 = i9(t20);
    if (r24 === o10.Color || r24 === o10.Alpha) {
      return e25 === (this.parameters.writeDepth ? E6.TRANSPARENT_MATERIAL : E6.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL);
    }
    return e25 === E6.OPAQUE_MATERIAL;
  }
  createGLMaterial(e25) {
    return e25.output === o10.Color || e25.output === o10.Alpha || e25.output === o10.Highlight || e25.output === o10.Depth ? new f16(e25) : null;
  }
};
var f16 = class extends h6 {
  _updateParameters(e25) {
    return this.updateTexture(this._material.parameters.textureId), this._material.setParameters(this.textureBindParameters), this.ensureTechnique(R8, e25);
  }
  _updateOccludeeState(e25) {
    e25.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e25.hasOccludees });
  }
  beginSlot(e25) {
    return this._output !== o10.Color && this._output !== o10.Alpha || this._updateOccludeeState(e25), this._updateParameters(e25);
  }
};
var v13 = class extends v7 {
  constructor() {
    super(...arguments), this.width = 0, this.color = [1, 1, 1, 1], this.placement = "end", this.cap = r14.BUTT, this.writeDepth = true, this.hasSlicePlane = false, this.vvFastUpdate = false, this.hasOccludees = false;
  }
};
var C8 = class {
  constructor(e25, t20) {
    this.vertexBufferLayout = e25, this.parameters = t20;
  }
  allocate(e25) {
    return this.vertexBufferLayout.createBuffer(e25);
  }
  elementCount() {
    return "begin-end" === this.parameters.placement ? 12 : 6;
  }
  write(s16, a21, i17, n24) {
    const h18 = a21.vertexAttributes.get(O.POSITION).data, o22 = h18.length / 3;
    let u16 = 1, c21 = 0;
    this.parameters.vvSizeEnabled ? c21 = a21.vertexAttributes.get(O.SIZEFEATUREATTRIBUTE).data[0] : a21.vertexAttributes.has(O.SIZE) && (u16 = a21.vertexAttributes.get(O.SIZE).data[0]);
    let p21 = [1, 1, 1, 1], d22 = 0;
    this.parameters.vvColorEnabled ? d22 = a21.vertexAttributes.get(O.COLORFEATUREATTRIBUTE).data[0] : a21.vertexAttributes.has(O.COLOR) && (p21 = a21.vertexAttributes.get(O.COLOR).data);
    let m15 = 0;
    this.parameters.vvOpacityEnabled && (m15 = a21.vertexAttributes.get(O.OPACITYFEATUREATTRIBUTE).data[0]);
    const E19 = s16.transformation, A10 = new Float32Array(i17.buffer);
    let T10 = n24 * (this.vertexBufferLayout.stride / 4);
    const f22 = (e25, t20, r24, s17) => {
      if (A10[T10++] = e25[0], A10[T10++] = e25[1], A10[T10++] = e25[2], A10[T10++] = r24[0], A10[T10++] = r24[1], A10[T10++] = t20[0], A10[T10++] = t20[1], A10[T10++] = t20[2], this.parameters.vvSizeEnabled ? A10[T10++] = c21 : A10[T10++] = u16, this.parameters.vvColorEnabled)
        A10[T10++] = d22;
      else {
        const e26 = Math.min(4 * s17, p21.length - 4);
        A10[T10++] = p21[e26 + 0], A10[T10++] = p21[e26 + 1], A10[T10++] = p21[e26 + 2], A10[T10++] = p21[e26 + 3];
      }
      this.parameters.vvOpacityEnabled && (A10[T10++] = m15);
    };
    let v17;
    !function(e25) {
      e25[e25.ASCENDING = 1] = "ASCENDING", e25[e25.DESCENDING = -1] = "DESCENDING";
    }(v17 || (v17 = {}));
    const C13 = (s17, a22) => {
      const i18 = o3(b9, h18[3 * s17], h18[3 * s17 + 1], h18[3 * s17 + 2]), n25 = O10;
      let u17 = s17 + a22;
      do {
        o3(n25, h18[3 * u17], h18[3 * u17 + 1], h18[3 * u17 + 2]), u17 += a22;
      } while (G(i18, n25) && u17 >= 0 && u17 < o22);
      E19 && (L(i18, i18, E19), L(n25, n25, E19)), f22(i18, n25, [-1, -1], s17), f22(i18, n25, [1, -1], s17), f22(i18, n25, [1, 1], s17), f22(i18, n25, [-1, -1], s17), f22(i18, n25, [1, 1], s17), f22(i18, n25, [-1, 1], s17);
    }, R12 = this.parameters.placement;
    "begin" !== R12 && "begin-end" !== R12 || C13(0, v17.ASCENDING), "end" !== R12 && "begin-end" !== R12 || C13(o22 - 1, v17.DESCENDING);
  }
};
var b9 = n2();
var O10 = n2();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLineSymbolLayer.js
var q8 = ["polyline", "polygon", "extent"];
var K3 = class extends y3 {
  constructor(e25, t20, r24, i17) {
    super(e25, t20, r24, i17), this._uniformSize = 1;
  }
  async doLoad() {
    if (this._vvConvertOptions = { modelSize: [1, 1, 1], symbolSize: [1, 1, 1], unitInMeters: 1, transformation: { anchor: [0, 0, 0], scale: [1, 1, 1], rotation: [0, 0, 0] }, supportedTypes: { size: true, color: true, opacity: true, rotation: false } }, this._context.renderer && this._context.renderer.visualVariables && this._context.renderer.visualVariables.length > 0 ? this._fastUpdates = P7(this._context.renderer, this._vvConvertOptions) : this._fastUpdates = { enabled: false }, !this._drivenProperties.size) {
      const t20 = null != this.symbolLayer.size ? this.symbolLayer.size : e6(1);
      if (t20 < 0)
        throw new s2("graphics3dlinesymbollayer:invalid-size", "Symbol sizes may not be negative values");
      this._uniformSize = t20;
    }
    this._markerTexture = e15(this._context.sharedResources.textures, this.symbolLayer.marker);
  }
  _getMaterialParameters(e25, t20 = false) {
    var _a;
    const r24 = this._getCombinedOpacityAndColor(t20 && this._markerColor || this._materialColor);
    this._patternHidesLine && !t20 && (r24[3] = 0);
    const i17 = { width: this._computeMaterialWidth((_a = this.symbolLayer) == null ? void 0 : _a.size), color: r24, hasPolygonOffset: true, join: this.symbolLayer.join || "miter", cap: L4(this.symbolLayer.cap || "butt"), hasSlicePlane: this._context.slicePlaneEnabled, isClosed: e25, stipplePattern: a11(this.symbolLayer.pattern), stippleScaleWithLineWidth: true };
    return this._fastUpdates && this._fastUpdates.visualVariables ? { ...i17, ...this._fastUpdates.materialParameters } : i17;
  }
  get _materialColor() {
    return o(this.symbolLayer.material, (e25) => e25.color);
  }
  get _markerColor() {
    return o(this.symbolLayer.marker, (e25) => e25.color);
  }
  get lineMaterial() {
    return t(this._lineMaterial) && (this._lineMaterial = new H2(this._getMaterialParameters(false)), this._context.stage.add(this._lineMaterial)), this._lineMaterial;
  }
  get ringMaterial() {
    return t(this._ringMaterial) && (this._ringMaterial = new H2(this._getMaterialParameters(true)), this._context.stage.add(this._ringMaterial)), this._ringMaterial;
  }
  get wireframeLineMaterial() {
    return t(this._wireframeLineMaterial) && (this._wireframeLineMaterial = new H2({ ...this._getMaterialParameters(false), wireframe: true }), this._context.stage.add(this._wireframeLineMaterial)), this._wireframeLineMaterial;
  }
  get wireframeRingMaterial() {
    return t(this._wireframeRingMaterial) && (this._wireframeRingMaterial = new H2({ ...this._getMaterialParameters(true), wireframe: true }), this._context.stage.add(this._wireframeRingMaterial)), this._wireframeRingMaterial;
  }
  get markerMaterial() {
    return t(this._markerMaterial) && r(this.symbolLayer.marker) && r(this._markerTexture) && (this._markerMaterial = new T7({ ...this._getMaterialParameters(false, true), placement: this.symbolLayer.marker.placement, textureId: this._markerTexture.texture.id }), this._context.stage.add(this._markerMaterial)), this._markerMaterial;
  }
  destroy() {
    super.destroy(), this._forEachMaterial((e25) => this._context.stage.remove(e25)), this._lineMaterial = null, this._ringMaterial = null, this._wireframeLineMaterial = null, this._wireframeRingMaterial = null, this._markerMaterial = null, this._markerTexture = p(this._markerTexture);
  }
  _getDrivenSize(e25) {
    return this._drivenProperties.size && e25.size ? u3(c14(e25.size)) : 1;
  }
  _getSizeFeatureAttributeData(e25) {
    return this._fastUpdates.enabled && this._fastUpdates.visualVariables.size ? v11(this._fastUpdates.visualVariables.size.field, e25) : null;
  }
  _getDrivenColor(e25) {
    const t20 = r5(1, 1, 1, 1);
    return this._drivenProperties.color && e25.color && (t20[0] = e25.color[0], t20[1] = e25.color[1], t20[2] = e25.color[2], e25.color.length > 0 && (t20[3] = e25.color[3])), this._drivenProperties.opacity && e25.opacity && (t20[3] = e25.opacity), t20;
  }
  _getColorFeatureAttributeData(e25) {
    return this._fastUpdates.enabled && this._fastUpdates.visualVariables.color ? v11(this._fastUpdates.visualVariables.color.field, e25) : null;
  }
  _getOpacityFeatureAttributeData(e25) {
    return this._fastUpdates.enabled && this._fastUpdates.visualVariables.opacity ? v11(this._fastUpdates.visualVariables.opacity.field, e25) : null;
  }
  createGraphics3DGraphic(e25) {
    const t20 = e25.graphic;
    if (!this._validateGeometry(t20.geometry, q8, this.symbolLayer.type))
      return null;
    const r24 = this.setGraphicElevationContext(t20, new h10());
    return this.ensureDrapedStatus("on-the-ground" === r24.mode), this.draped ? this._createAsOverlay(e25, this._context.layer.uid) : this._createAs3DShape(e25, r24, t20.uid);
  }
  applyRendererDiff(e25, t20) {
    for (const r24 in e25.diff) {
      if ("visualVariables" !== r24)
        return e16.Recreate_Symbol;
      if (!R7(this._fastUpdates, t20, this._vvConvertOptions))
        return e16.Recreate_Symbol;
      this._forEachMaterial((e26) => e26.setParameters(this._fastUpdates.materialParameters));
    }
    return e16.Fast_Update;
  }
  prepareSymbolLayerPatch(e25) {
    var _a, _b;
    if ("partial" !== e25.diff.type)
      return;
    const t20 = e25.diff.diff, r24 = {};
    "complete" === ((_a = t20.size) == null ? void 0 : _a.type) && (r24.width = this._computeMaterialWidth(t20.size.newValue), delete t20.size), "complete" === ((_b = t20.cap) == null ? void 0 : _b.type) && (r24.cap = L4(c(t20.cap.newValue, "butt")), delete t20.cap);
    const i17 = this._prepareMarkerPatch(e25, t20);
    this._prepareMaterialPatch(e25, t20, i17), e25.symbolLayerStatePatches.push(() => this._forEachMaterial((e26) => e26.setParameters(r24)));
  }
  layerOpacityChanged() {
    return this._forEachMaterial((e25, t20) => this._updateMaterialLayerOpacity(e25, t20)), true;
  }
  _forEachMaterial(e25) {
    r(this._lineMaterial) && e25(this._lineMaterial), r(this._ringMaterial) && e25(this._ringMaterial), r(this._wireframeLineMaterial) && e25(this._wireframeLineMaterial), r(this._wireframeRingMaterial) && e25(this._wireframeRingMaterial), r(this._markerMaterial) && e25(this._markerMaterial, true);
  }
  _updateMaterialLayerOpacity(e25, t20 = false) {
    const r24 = e25.parameters.color, i17 = m(this.symbolLayer, "material", "color"), a21 = this._patternHidesLine && !t20 ? 0 : this._getCombinedOpacity(i17), s16 = r5(r24[0], r24[1], r24[2], a21);
    e25.setParameters({ color: s16 });
  }
  layerElevationInfoChanged(e25, t20, r24) {
    const i17 = this._elevationContext.mode, a21 = p10(K3.elevationModeChangeTypes, r24, i17);
    if (a21 !== x5.UPDATE)
      return a21;
    const s16 = g7(i17);
    return this.updateGraphics3DGraphicElevationInfo(e25, t20, () => s16);
  }
  slicePlaneEnabledChanged() {
    const e25 = { hasSlicePlane: this._context.slicePlaneEnabled };
    return this._forEachMaterial((t20) => t20.setParameters(e25)), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  _getGeometryAsPolygonOrPolyline(e25) {
    switch (e25.type) {
      case "extent":
        if (e25 instanceof M)
          return v2.fromExtent(e25);
        break;
      case "polygon":
      case "polyline":
        return e25;
    }
    return null;
  }
  _createAs3DShape(e25, t20, r24) {
    const a21 = e25.graphic, s16 = this._getGeometryAsPolygonOrPolyline(a21.geometry), o22 = "polygon" === s16.type ? s16.rings : s16.paths, n24 = new Array(), l26 = new Array(), h18 = new Array(), m15 = a3(), c21 = R6(s16, this._context.elevationProvider, this._context.renderCoordsHelper, t20), d22 = "polygon" === s16.type ? "rings" : "paths";
    this._logGeometryCreationWarnings(c21, o22, d22, "LineSymbol3DLayer");
    for (let _14 = 0; _14 < c21.lines.length; _14++) {
      const { position: t21, mapPosition: r25 } = c21.lines[_14];
      if (r(this._context.clippingExtent) && (B(m15), M3(m15, r25), !R(m15, this._context.clippingExtent)))
        continue;
      const a22 = this._createGeometry(e25, t21, r25, s16.type, J5.ELEVATED);
      n24.push(a22), l26.push("polygon" === s16.type ? this.ringMaterial : this.lineMaterial), h18.push(o7), t10.LINE_WIREFRAMES && (n24.push(a22.cloneShallow()), l26.push("polygon" === s16.type ? this.wireframeRingMaterial : this.wireframeLineMaterial), h18.push(o7));
      const o23 = this.markerMaterial;
      r(o23) && (n24.push(a22.cloneShallow()), l26.push(o23), h18.push(o7));
    }
    if (0 === n24.length)
      return null;
    const f22 = new O5({ geometries: n24, materials: l26, transformations: h18, castShadow: false, metadata: { layerUid: this._context.layer.uid, graphicUid: r24 } }), M11 = new p14(this, f22, n24, null, null, b4, t20);
    return M11.alignedSampledElevation = c21.sampledElevation, M11.needsElevationUpdates = g7(t20.mode), M11;
  }
  _createGeometry(e25, t20, r24, i17, a21) {
    const s16 = "polygon" === i17 ? P3.REMOVE : P3.KEEP, o22 = this._fastUpdates.enabled && this._fastUpdates.visualVariables.color, n24 = this._fastUpdates.enabled && this._fastUpdates.visualVariables.size;
    return O6({ overlayInfo: a21 === J5.DRAPED ? { spatialReference: this._context.overlaySR, renderCoordsHelper: this._context.renderCoordsHelper } : null, removeDuplicateStartEnd: s16, uniformSize: this._uniformSize, attributeData: { position: t20, mapPosition: r24, size: n24 ? null : this._getDrivenSize(e25.renderingInfo), color: o22 ? null : this._getDrivenColor(e25.renderingInfo), sizeFeature: this._getSizeFeatureAttributeData(e25.graphic), colorFeature: this._getColorFeatureAttributeData(e25.graphic), opacityFeature: this._getOpacityFeatureAttributeData(e25.graphic) } });
  }
  _createAsOverlay(e25, t20) {
    const r24 = e25.graphic, a21 = this._getGeometryAsPolygonOrPolyline(r24.geometry), s16 = "polygon" === a21.type ? a21.rings : a21.paths, o22 = "polygon" === a21.type ? this.ringMaterial : this.lineMaterial;
    o22.renderPriority = this._renderPriority;
    const l26 = t10.LINE_WIREFRAMES ? "polygon" === a21.type ? this.wireframeRingMaterial : this.wireframeLineMaterial : null, h18 = this.markerMaterial;
    r(l26) && (l26.renderPriority = this._renderPriority - 1e-3), r(h18) && (h18.renderPriority = this._renderPriority - 2e-3);
    const p21 = new Array(), m15 = a3(), c21 = B(), d22 = d11(a21, this._context.overlaySR), M11 = "polygon" === a21.type ? "rings" : "paths";
    this._logGeometryCreationWarnings(d22, s16, M11, "LineSymbol3DLayer");
    for (const _14 of d22.lines) {
      if (B(m15), M3(m15, _14.position), !R(m15, this._context.clippingExtent))
        continue;
      f3(c21, m15);
      const s17 = this._createGeometry(e25, _14.position, null, a21.type, J5.DRAPED), d23 = (e26) => {
        const i17 = new T4(s17, e26, { layerUid: t20, graphicUid: r24.uid });
        return p21.push(i17), i17;
      };
      if (r(h18)) {
        const e26 = d23(h18), t21 = e2(this.symbolLayer.marker).placement;
        "begin" !== t21 && "begin-end" !== t21 || M3(m15, _14.position, 0, 1), "end" !== t21 && "begin-end" !== t21 || M3(m15, _14.position, _14.position.length - 3, 1), this._updateBoundingSphere(e26, m15);
      }
      const M12 = d23(o22);
      if (this._updateBoundingSphere(M12, m15), t10.LINE_WIREFRAMES) {
        const e26 = d23(l26);
        this._updateBoundingSphere(e26, m15);
      }
    }
    return new u13(this, p21, c21, this._context.drapeSourceRenderer);
  }
  _updateBoundingSphere(e25, t20) {
    r4(e25.boundingSphere, 0.5 * (t20[0] + t20[3]), 0.5 * (t20[1] + t20[4]), 0, 0.5 * Math.sqrt((t20[3] - t20[0]) * (t20[3] - t20[0]) + (t20[4] - t20[1]) * (t20[4] - t20[1])));
  }
  get _patternHidesLine() {
    const e25 = this.symbolLayer.pattern;
    return r(e25) && "style" === e25.type && "none" === e25.style;
  }
  _computeMaterialWidth(e25) {
    return e25 = c(e25, e6(1)), this._drivenProperties.size ? this._fastUpdates.enabled && this._fastUpdates.visualVariables.size ? u3(1) : 1 : u3(e25);
  }
  _prepareMaterialPatch(e25, i17, a21) {
    const s16 = i17.material;
    if (t(s16))
      return void (a21.changed && a21.useMaterialColor && this._patchMaterialColor(this._getCombinedOpacityAndColor(this._materialColor), this._markerMaterial, e25));
    if ("collection" === s16.type)
      return;
    const o22 = "complete" === s16.type ? o(s16.newValue, (e26) => e26.color) : "complete" === s16.diff.color.type ? s16.diff.color.newValue : null, n24 = this._getCombinedOpacityAndColor(o22);
    a21.useMaterialColor && this._patchMaterialColor(t3(n24), this._markerMaterial, e25), this._patternHidesLine && (n24[3] = 0), this._patchMaterialColor(n24, this._lineMaterial, e25), delete i17.material;
  }
  _prepareMarkerPatch(e25, t20) {
    const a21 = t20.marker;
    if (t(a21) || "partial" !== a21.type || r(a21.diff.style) || r(a21.diff.placement) || r(a21.diff.color) && "complete" !== a21.diff.color.type)
      return { changed: false, useMaterialColor: t(this._markerColor) };
    const s16 = a21.diff.color;
    if (t(s16))
      return delete t20.marker, { changed: false, useMaterialColor: t(this._markerColor) };
    const o22 = e2(s16.newValue);
    return t(o22) ? (delete t20.marker, { changed: true, useMaterialColor: true }) : (this._patchMaterialColor(this._getCombinedOpacityAndColor(o22), this._markerMaterial, e25), delete t20.marker, { changed: true, useMaterialColor: false });
  }
  _patchMaterialColor(e25, t20, i17) {
    t(t20) || i17.symbolLayerStatePatches.push(() => t20.setParameters({ color: e25 }));
  }
};
var J5;
K3.elevationModeChangeTypes = { definedChanged: x5.RECREATE, staysOnTheGround: x5.NONE, onTheGroundChanged: x5.RECREATE }, function(e25) {
  e25[e25.DRAPED = 0] = "DRAPED", e25[e25.ELEVATED = 1] = "ELEVATED";
}(J5 || (J5 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DMeshFillSymbolLayer.js
var ue3 = ["mesh"];
var me3 = class extends y3 {
  constructor(e25, t20, r24, a21) {
    super(e25, t20, r24, a21), this._materials = /* @__PURE__ */ new Map(), this._textures = /* @__PURE__ */ new Map(), this.ensureDrapedStatus(false);
  }
  async doLoad() {
    t10.DRAW_MESH_GEOMETRY_NORMALS && (this._debugVertexNormalMaterial = new W2({ color: [1, 0, 1, 1] }), this._debugFaceNormalMaterial = new W2({ color: [0, 1, 1, 1] }));
  }
  destroy() {
    super.destroy(), this._context.stage.removeMany(Array.from(this._materials.values(), (e25) => e25.material)), this._context.stage.removeMany(Array.from(this._textures.values())), this._materials.clear(), this._textures.clear();
  }
  createGraphics3DGraphic(e25) {
    const t20 = e25.graphic;
    if (!this._validateGeometry(t20.geometry, ue3, "fill on mesh-3d"))
      return null;
    const r24 = this.setGraphicElevationContext(t20, new h10()), a21 = e25.renderingInfo;
    return this._createAs3DShape(t20, a21, r24, t20.uid);
  }
  layerOpacityChanged(e25, r24) {
    const a21 = this._getLayerOpacity();
    return this._materials.forEach((e26) => {
      e26.material.setParameters({ layerOpacity: a21 });
      const t20 = e26.material.parameters;
      this._setMaterialTransparentParameter(t20, e26), e26.material.setParameters({ transparent: t20.transparent });
    }), e25.forEach((e26) => {
      const o22 = r24(e26);
      r(o22) && o22.layerOpacityChanged(a21, this._context.isAsync);
    }), true;
  }
  layerElevationInfoChanged(e25, t20) {
    return this.updateGraphics3DGraphicElevationInfo(e25, t20, v8);
  }
  slicePlaneEnabledChanged(e25, r24) {
    return this._materials.forEach((e26) => {
      e26.material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), e25.forEach((e26) => {
      const a21 = r24(e26);
      r(a21) && a21.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync);
    }), true;
  }
  physicalBasedRenderingChanged() {
    const e25 = this._usePBR();
    return this._materials.forEach((t20) => t20.material.setParameters({ usePBR: e25 })), true;
  }
  pixelRatioChanged() {
    return true;
  }
  _requiresSymbolVertexColors() {
    return this._drivenProperties.color || this._drivenProperties.opacity;
  }
  _colorOrTextureUid(t20) {
    return t(t20) ? "-" : t20 instanceof l4 ? t20.toHex() : t20.contentHash;
  }
  _materialPropertiesDefault(e25, t20) {
    const r24 = this._requiresSymbolVertexColors(), a21 = !!e25.vertexAttributes.color, o22 = !!e25.vertexAttributes.tangent;
    return { hasSymbolVertexColors: r24, hasVertexColors: a21, hasVertexTangents: o22, uid: `vc:${a21},vt:${o22},vct${t20},svc:${r24}` };
  }
  _materialProperties(e25, t20, r24) {
    const a21 = this._materialPropertiesDefault(e25, r24);
    if (!t20.material)
      return a21;
    const { color: o22, colorTexture: s16, normalTexture: n24, doubleSided: i17, alphaCutoff: l26, alphaMode: c21 } = t20.material, u16 = this._colorOrTextureUid(o22), m15 = this._colorOrTextureUid(s16), h18 = this._colorOrTextureUid(n24);
    if (a21.color = o22, a21.colorTexture = s16, a21.normalTexture = n24, a21.uid = `${a21.uid},cmuid:${u16},ctmuid:${m15},ntmuid:${h18},ds:${i17},ac:${l26},am:${c21}`, t20.material instanceof c7) {
      const { metallic: e26, roughness: r25, metallicRoughnessTexture: o23, emissiveColor: s17, emissiveTexture: n25, occlusionTexture: i18 } = t20.material, l27 = this._colorOrTextureUid(o23), c22 = this._colorOrTextureUid(s17), u17 = this._colorOrTextureUid(n25), m16 = this._colorOrTextureUid(i18);
      a21.metallic = e26, a21.roughness = r25, a21.metallicRoughnessTexture = o23, a21.emissiveColor = s17, a21.emissiveTexture = n25, a21.occlusionTexture = i18, a21.uid = `${a21.uid},mrm:${e26},mrr:${r25},mrt:${l27},emuid:${c22},etmuid:${u17},otmuid:${m16}`;
    }
    return a21;
  }
  _setInternalColorValueParameters(t20, r24) {
    r24.diffuse = l4.toUnitRGB(t20), r24.opacity = t20.a;
  }
  _getLoadableTextureResource(e25) {
    return e25.data ? e25.data : e25.url;
  }
  _getInternalTextureId(e25) {
    const r24 = this._getInternalTexture(e25, C.Opaque);
    return r(r24) ? r24.id : null;
  }
  _getInternalTexture(e25, t20) {
    const r24 = this._getLoadableTextureResource(e25);
    if (!r24)
      return null;
    const a21 = `${e25.contentHash}/${t20}`;
    let o22 = this._textures.get(a21);
    return o22 || (o22 = new L3(r24, { mipmap: true, wrap: this._castTextureWrap(e25.wrap), noUnpackFlip: true, preMultiplyAlpha: t20 !== C.Opaque }), this._textures.set(a21, o22), this._context.stage.add(o22), this._context.stage.loadImmediate(o22)), o22;
  }
  _castTextureWrap(e25 = "repeat") {
    if ("string" == typeof e25) {
      const t20 = this._castTextureWrapIndividual(e25);
      return { s: t20, t: t20 };
    }
    return { s: this._castTextureWrapIndividual(e25.horizontal), t: this._castTextureWrapIndividual(e25.vertical) };
  }
  _castTextureWrapIndividual(e25) {
    switch (e25) {
      case "clamp":
        return D2.CLAMP_TO_EDGE;
      case "mirror":
        return D2.MIRRORED_REPEAT;
      default:
        return D2.REPEAT;
    }
  }
  _setInternalMaterialParameters(r24, a21) {
    if (r(r24.color) && this._setInternalColorValueParameters(r24.color, a21), r(r24.colorTexture)) {
      const e25 = this._getInternalTexture(r24.colorTexture, a21.textureAlphaMode);
      r(e25) ? (a21.textureId = e25.id, a21.textureAlphaPremultiplied = !!e25.params.preMultiplyAlpha) : a21.textureId = void 0;
    }
    r(r24.normalTexture) && (a21.normalTextureId = this._getInternalTextureId(r24.normalTexture)), r(r24.emissiveColor) && (a21.emissiveFactor = l4.toUnitRGB(r24.emissiveColor)), r(r24.emissiveTexture) && (a21.emissiveTextureId = this._getInternalTextureId(r24.emissiveTexture)), r(r24.occlusionTexture) && (a21.occlusionTextureId = this._getInternalTextureId(r24.occlusionTexture)), r(r24.metallicRoughnessTexture) && (a21.metallicRoughnessTextureId = this._getInternalTextureId(r24.metallicRoughnessTexture));
  }
  _setExternalMaterialParameters(r24) {
    const a21 = this._drivenProperties.color;
    let o22 = r(this.symbolLayer.material) ? this.symbolLayer.material.colorMixMode : null;
    if (a21)
      r24.externalColor = _2;
    else {
      const a22 = r(this.symbolLayer.material) ? this.symbolLayer.material.color : null;
      r(a22) ? r24.externalColor = l4.toUnitRGBA(a22) : (o22 = null, r24.externalColor = _2);
    }
    o22 && (r24.colorMixMode = o22), r24.castShadows = !!this.symbolLayer.castShadows;
  }
  _hasTransparentVertexColors(e25) {
    const t20 = e25.vertexAttributes.color;
    if (t(t20))
      return false;
    for (let r24 = 3; r24 < t20.length; r24 += 4)
      if (255 !== t20[r24])
        return true;
    return false;
  }
  _getOrCreateMaterial(e25, r24) {
    var _a, _b, _c;
    const a21 = (_a = r24.material) == null ? void 0 : _a.color, o22 = (_b = r24.material) == null ? void 0 : _b.colorTexture, s16 = (_c = r24.material) == null ? void 0 : _c.alphaMode, n24 = "blend" === s16, i17 = !("opaque" === s16) && (this._hasTransparentVertexColors(e25) || r(a21) && a21.a < 1 || r(o22) && o22.transparent || n24), l26 = this._materialProperties(e25, r24, i17), c21 = this._materials.get(l26.uid);
    if (c21)
      return c21.material;
    const u16 = { material: null, isComponentTransparent: i17, alphaMode: r24.material ? r24.material.alphaMode : "opaque" }, m15 = null == l26.metallicRoughnessTexture && null == l26.metallic && null == l26.roughness, h18 = { usePBR: this._usePBR(), isSchematic: m15, hasVertexColors: l26.hasVertexColors, hasSymbolColors: l26.hasSymbolVertexColors, hasVertexTangents: l26.hasVertexTangents, ambient: f2, diffuse: l, opacity: 1, doubleSided: true, doubleSidedType: "winding-order", cullFace: n9.None, layerOpacity: this._getLayerOpacity(), hasSlicePlane: this._context.slicePlaneEnabled, initTextureTransparent: true };
    m15 || (h18.mrrFactors = [null != l26.metallic ? l26.metallic : 1, null != l26.roughness ? l26.roughness : 1, 0.5]), r24.material && (h18.doubleSided = r24.material.doubleSided, h18.cullFace = r24.material.doubleSided ? n9.None : n9.Back, h18.textureAlphaCutoff = r24.material.alphaCutoff), this._setExternalMaterialParameters(h18), this._setMaterialTransparentParameter(h18, u16), this._setInternalMaterialParameters(l26, h18);
    const p21 = new R5(h18);
    return u16.material = p21, this._materials.set(l26.uid, u16), this._context.stage.add(p21), p21;
  }
  _usePBR() {
    return this._context.physicalBasedRenderingEnabled;
  }
  _setMaterialTransparentParameter(e25, t20) {
    e25.transparent = this.needsDrivenTransparentPass || t20.isComponentTransparent || e25.layerOpacity < 1 || e25.opacity < 1 || e25.externalColor && e25.externalColor[3] < 1, "auto" === t20.alphaMode ? e25.textureAlphaMode = e25.transparent ? C.MaskBlend : C.Opaque : e25.textureAlphaMode = "opaque" === t20.alphaMode ? C.Opaque : "mask" === t20.alphaMode ? C.Mask : C.Blend;
  }
  _addDebugNormals(e25, t20, r24, a21) {
    const o22 = t20.length, s16 = e25.spatialReference.isGeographic ? 20015077 / 180 : 1, n24 = 0.1 * Math.max(e25.extent.width * s16, e25.extent.height * s16, e25.extent.zmax - e25.extent.zmin), i17 = [], l26 = [], c21 = [], u16 = [];
    for (let m15 = 0; m15 < o22; m15++) {
      const e26 = t20[m15], r25 = e26.vertexAttributes.get(O.POSITION), a22 = e26.vertexAttributes.get(O.NORMAL), o23 = e26.indices.get(O.POSITION), s17 = e26.indices.get(O.NORMAL), h19 = r25.data, d23 = a22.data;
      for (let t21 = 0; t21 < o23.length; t21++) {
        const e27 = 3 * o23[t21], r26 = 3 * s17[t21];
        for (let t22 = 0; t22 < 3; t22++)
          i17.push(h19[e27 + t22]);
        for (let t22 = 0; t22 < 3; t22++)
          i17.push(h19[e27 + t22] + d23[r26 + t22] * n24);
        if (l26.push(l26.length), l26.push(l26.length), t21 % 3 == 0) {
          this._calculateFaceNormal(h19, o23, t21, ge), this._getFaceVertices(h19, o23, t21, pe3, fe3, de3), u2(pe3, pe3, fe3), u2(pe3, pe3, de3), q(pe3, pe3, 1 / 3);
          for (let e28 = 0; e28 < 3; e28++)
            c21.push(pe3[e28]);
          for (let e28 = 0; e28 < 3; e28++)
            c21.push(pe3[e28] + ge[e28] * n24);
          u16.push(u16.length), u16.push(u16.length);
        }
      }
    }
    const h18 = new g4([[O.POSITION, { data: i17, size: 3, exclusive: true }]], [[O.POSITION, new Uint32Array(l26)]], c9.Line);
    t20.push(h18), r24.push(this._debugVertexNormalMaterial), a21.push(r8(a21[0]));
    const d22 = new g4([[O.POSITION, { data: c21, size: 3, exclusive: true }]], [[O.POSITION, new Uint32Array(u16)]], c9.Line);
    t20.push(d22), r24.push(this._debugFaceNormalMaterial), a21.push(r8(a21[0]));
  }
  _createAs3DShape(e25, r24, a21, o22) {
    const s16 = e25.geometry;
    if ("mesh" !== s16.type)
      return null;
    const n24 = this._createGeometryInfo(s16, r24);
    if (!n24)
      return null;
    const { geometries: i17, materials: l26, transformations: c21, objectTransformation: u16 } = n24;
    t10.DRAW_MESH_GEOMETRY_NORMALS && this._addDebugNormals(s16, i17, l26, c21);
    const m15 = new O5({ geometries: i17, materials: l26, transformations: c21, metadata: { layerUid: this._context.layer.uid, graphicUid: o22 } });
    m15.transformation = u16;
    const h18 = this._createEdgeMaterial(), p21 = r(h18) ? { baseMaterial: l26[0], edgeMaterials: [h18], properties: { mergeGeometries: true, hasSlicePlane: this._context.slicePlaneEnabled } } : null, f22 = new p14(this, m15, i17, null, null, d12, a21, p21);
    return f22.needsElevationUpdates = v8(a21.mode), f22.useObjectOriginAsAttachmentOrigin = true, f22.elevationContext.centerPointInElevationSR = this._getCenterPointInElevationSR(m15), f22.alignedSampledElevation = d12(f22, f22.elevationContext, this._context.elevationProvider, this._context.renderCoordsHelper), f22;
  }
  _getCenterPointInElevationSR(e25) {
    const t20 = v5(0, 0, 0, this._context.elevationProvider.spatialReference);
    return dn([e25.transformation[12], e25.transformation[13], e25.transformation[14]], this._context.renderCoordsHelper.spatialReference, t20), t20;
  }
  _createComponentNormals(e25, t20, r24, a21) {
    switch (r24.shading || "flat") {
      case "source":
        return this._createComponentNormalsSource(e25, t20, r24, a21);
      case "flat":
        return this._createComponentNormalsFlat(e25, a21);
      case "smooth":
        return this._createComponentNormalsSmooth(e25, a21);
      default:
        return;
    }
  }
  _createComponentNormalsSource(e25, t20, a21, o22) {
    if (t(t20))
      return this._createComponentNormalsFlat(e25, o22);
    let s16 = false;
    if (!a21.trustSourceNormals)
      for (let r24 = 0; r24 < o22.length; r24 += 3) {
        this._calculateFaceNormal(e25, o22, r24, ge);
        for (let e26 = 0; e26 < 3; e26++) {
          const a22 = 3 * o22[r24 + e26];
          pe3[0] = t20[a22 + 0], pe3[1] = t20[a22 + 1], pe3[2] = t20[a22 + 2], P(ge, pe3) < 0 && (t20[a22 + 0] = -t20[a22 + 0], t20[a22 + 1] = -t20[a22 + 1], t20[a22 + 2] = -t20[a22 + 2], s16 = true);
        }
      }
    return { normals: t20, indices: o22, didFlipNormals: s16 };
  }
  _createComponentNormalsFlat(e25, t20) {
    const r24 = new Float32Array(t20.length), a21 = new Uint32Array(3 * t20.length);
    for (let o22 = 0; o22 < t20.length; o22 += 3) {
      const s16 = this._calculateFaceNormal(e25, t20, o22, ge);
      for (let e26 = 0; e26 < 3; e26++)
        r24[o22 + e26] = s16[e26], a21[o22 + e26] = o22 / 3;
    }
    return { normals: r24, indices: a21, didFlipNormals: false };
  }
  _createComponentNormalsSmooth(e25, t20) {
    const r24 = {};
    for (let s16 = 0; s16 < t20.length; s16 += 3) {
      const a22 = this._calculateFaceNormal(e25, t20, s16, ge);
      for (let e26 = 0; e26 < 3; e26++) {
        const o23 = t20[s16 + e26];
        let n24 = r24[o23];
        n24 || (n24 = { normal: n2(), count: 0 }, r24[o23] = n24), u2(n24.normal, n24.normal, a22), n24.count++;
      }
    }
    const a21 = new Float32Array(3 * t20.length), o22 = new Uint32Array(3 * t20.length);
    for (let s16 = 0; s16 < t20.length; s16++) {
      const e26 = r24[t20[s16]];
      1 !== e26.count && (z2(e26.normal, e26.normal), e26.count = 1);
      for (let t21 = 0; t21 < 3; t21++)
        a21[3 * s16 + t21] = e26.normal[t21];
      o22[s16] = s16;
    }
    return { normals: a21, indices: o22, didFlipNormals: false };
  }
  _getFaceVertices(e25, t20, r24, a21, o22, s16) {
    const n24 = 3 * t20[r24 + 0], i17 = 3 * t20[r24 + 1], l26 = 3 * t20[r24 + 2];
    a21[0] = e25[n24 + 0], a21[1] = e25[n24 + 1], a21[2] = e25[n24 + 2], o22[0] = e25[i17 + 0], o22[1] = e25[i17 + 1], o22[2] = e25[i17 + 2], s16[0] = e25[l26 + 0], s16[1] = e25[l26 + 1], s16[2] = e25[l26 + 2];
  }
  _calculateFaceNormal(e25, t20, r24, a21) {
    return this._getFaceVertices(e25, t20, r24, pe3, fe3, de3), e5(fe3, fe3, pe3), e5(de3, de3, pe3), _(pe3, fe3, de3), z2(a21, pe3), a21;
  }
  _getOrCreateComponents(e25) {
    return c(e25.components, be);
  }
  _createPositionBuffer(e25, r24) {
    let a21 = e25.vertexAttributes.position;
    const o22 = r24.reprojection === ve.ECEF ? r24.transformBeforeProject : null;
    if (r(o22) && (a21 = R3(a21, new Float64Array(a21.length), o22)), r24.reprojection === ve.NONE)
      return r24.needsBufferCopy ? new Float64Array(a21) : a21;
    const s16 = r(o22) ? a21 : new Float64Array(a21.length);
    return Un(a21, e25.spatialReference, 0, s16, this._context.renderCoordsHelper.spatialReference, 0, a21.length / 3), s16;
  }
  _createNormalBuffer(e25, a21, o22) {
    let s16 = e25.vertexAttributes.normal;
    if (t(s16))
      return null;
    const n24 = o22.reprojection === ve.ECEF ? o22.transformBeforeProject : null;
    r(n24) && (s16 = v4(s16, new Float32Array(s16.length), n24));
    if ("local" === this._context.graphicsCoreOwner.view.viewingMode || o22.reprojection === ve.NONE)
      return o22.needsBufferCopy && e25.vertexAttributes.normal === s16 ? new Float32Array(s16) : s16;
    const i17 = e25.vertexAttributes.position, l26 = r(n24) ? s16 : new Float32Array(s16.length);
    return j4(s16, i17, a21, e25.spatialReference, l26);
  }
  _createTangentBuffer(e25, a21, o22) {
    let s16 = e25.vertexAttributes.tangent;
    if (t(s16))
      return null;
    const n24 = o22.reprojection === ve.ECEF ? o22.transformBeforeProject : null;
    r(n24) && (s16 = V2(s16, new Float32Array(s16.length), n24));
    if ("local" === this._context.graphicsCoreOwner.view.viewingMode || o22.reprojection === ve.NONE)
      return o22.needsBufferCopy && e25.vertexAttributes.normal === s16 ? new Float32Array(s16) : s16;
    const i17 = e25.vertexAttributes.position, l26 = r(n24) ? s16 : new Float32Array(s16.length);
    return k2(s16, i17, a21, e25.spatialReference, l26);
  }
  _createColorBuffer(e25) {
    return e25.vertexAttributes.color;
  }
  _createSymbolColorBuffer(e25) {
    if (this._requiresSymbolVertexColors()) {
      const t20 = this._getVertexOpacityAndColor(e25), r24 = n11(m(this.symbolLayer, "material", "colorMixMode")), a21 = new Uint8Array(4);
      return o15(t20, r24, a21), a21;
    }
    return null;
  }
  _createBuffers(e25, r24) {
    const a21 = e25.vertexAttributes && e25.vertexAttributes.position;
    if (!a21)
      return this.logger.warn("Mesh geometry must contain position vertex attributes"), null;
    const o22 = e25.vertexAttributes.normal, s16 = e25.vertexAttributes.uv, n24 = e25.vertexAttributes.tangent;
    if (r(o22) && o22.length !== a21.length)
      return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"), null;
    if (r(n24) && n24.length / 4 != a21.length / 3)
      return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"), null;
    if (r(s16) && s16.length / 2 != a21.length / 3)
      return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"), null;
    const i17 = this._computeReprojectionInfo(e25), l26 = this._createPositionBuffer(e25, i17), c21 = this._createColorBuffer(e25), u16 = this._createSymbolColorBuffer(r24), m15 = this._createNormalBuffer(e25, l26, i17), p21 = this._createTangentBuffer(e25, l26, i17);
    return { positionBuffer: l26, normalBuffer: m15, tangentBuffer: p21, uvBuffer: s16, colorBuffer: c21, symbolColorBuffer: u16, objectTransformation: i17.reprojection === ve.NONE && r(i17.objectTransformation) ? i17.objectTransformation : this._transformOriginLocal(e25, l26, m15, p21), geometryTransformation: i17.reprojection === ve.NONE && r(i17.geometryTransformation) ? i17.geometryTransformation : e8() };
  }
  _computeReprojectionInfo(e25) {
    const r24 = r(e25.transform), a21 = r24 && e25.transform.geographic || this._context.renderCoordsHelper.viewingMode === l13.Local ? ve.NONE : ve.ECEF;
    if (r24) {
      if (a21 === ve.NONE) {
        const t21 = e8();
        qn(e25.spatialReference, e25.transform.origin, t21, this._context.renderCoordsHelper.spatialReference);
        return { reprojection: a21, objectTransformation: t21, geometryTransformation: r8(e25.transform.localMatrix), needsBufferCopy: false };
      }
      const t20 = x(e8(), e25.transform.origin);
      return u4(t20, t20, e25.transform.localMatrix), { reprojection: a21, transformBeforeProject: t20, needsBufferCopy: true };
    }
    return { reprojection: a21, needsBufferCopy: true };
  }
  _transformOriginLocal(e25, r24, a21, o22) {
    const i17 = this._context.renderCoordsHelper.spatialReference, l26 = e25.anchor;
    he3[0] = l26.x, he3[1] = l26.y, he3[2] = l26.z;
    const c21 = e8();
    qn(e25.spatialReference, he3, c21, i17);
    const m15 = T.fromTypedArray(r24);
    if (h2(xe, c21), t4(m15, m15, xe), r(a21) || r(o22)) {
      if (a5(_e3, c21), o8(_e3, _e3), r(a21)) {
        const e26 = i2.fromTypedArray(a21);
        r9(e26, e26, _e3);
      }
      if (r(o22)) {
        const e26 = i2.fromTypedArray(o22, 4 * o22.BYTES_PER_ELEMENT);
        r9(e26, e26, _e3);
      }
    }
    return c21;
  }
  _validateFaces(e25, t20) {
    const r24 = e25.vertexAttributes.position.length / 3, a21 = t20.faces;
    if (a21) {
      let e26 = -1;
      for (let t21 = 0; t21 < a21.length; t21++) {
        const r25 = a21[t21];
        r25 > e26 && (e26 = r25);
      }
      if (r24 <= e26)
        return this.logger.warn(`Vertex index ${e26} is out of bounds of the mesh position buffer`), false;
    } else if (r24 % 3 != 0)
      return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"), false;
    return true;
  }
  _getOrCreateFaces(e25, t20) {
    return t20.faces ? t20.faces : l11(e25.vertexAttributes.position.length / 3);
  }
  _isOutsideClippingArea(e25) {
    if (!this._context.clippingExtent)
      return false;
    const t20 = e25.vertexAttributes && e25.vertexAttributes.position;
    if (!t20)
      return false;
    const r24 = this._context.elevationProvider.spatialReference;
    let a21;
    const o22 = t20.length / 3;
    return e25.spatialReference.equals(r24) ? a21 = t20 : (a21 = new Float64Array(t20.length), Un(e25.vertexAttributes.position, e25.spatialReference, 0, a21, r24, 0, o22)), B(ye), M3(ye, a21, 0, o22), !R(ye, this._context.clippingExtent);
  }
  _createGeometryInfo(e25, a21) {
    if (!An(e25.spatialReference, this._context.graphicsCoreOwner.view.spatialReference))
      return this.logger.warn("Geometry spatial reference is not compatible with the view"), null;
    if (this._isOutsideClippingArea(e25))
      return null;
    const o22 = this._createBuffers(e25, a21);
    if (t(o22))
      return null;
    const { positionBuffer: s16, uvBuffer: n24, colorBuffer: i17, symbolColorBuffer: l26, normalBuffer: c21, tangentBuffer: u16, objectTransformation: m15, geometryTransformation: h18 } = o22, p21 = this._getOrCreateComponents(e25), f22 = [], d22 = [], g17 = [];
    let x13 = false;
    for (const r24 of p21) {
      if (!this._validateFaces(e25, r24))
        return null;
      const a22 = this._getOrCreateFaces(e25, r24);
      if (0 === a22.length)
        continue;
      const o23 = this._createComponentNormals(s16, c21, r24, a22);
      o23.didFlipNormals && (x13 = true);
      const m16 = [[O.POSITION, { size: 3, data: s16, exclusive: true }], [O.NORMAL, { size: 3, data: o23.normals, exclusive: true }]], p22 = [[O.POSITION, a22], [O.NORMAL, o23.indices]];
      r(i17) && (m16.push([O.COLOR, { size: 4, data: i17, exclusive: true }]), p22.push([O.COLOR, a22])), r(l26) && (m16.push([O.SYMBOLCOLOR, { size: 4, data: l26, exclusive: true }]), p22.push([O.SYMBOLCOLOR, new Uint16Array(a22.length)])), r(n24) && (m16.push([O.UV0, { size: 2, data: n24, exclusive: true }]), p22.push([O.UV0, a22])), r(u16) && (m16.push([O.TANGENT, { size: 4, data: u16, exclusive: true }]), p22.push([O.TANGENT, a22]));
      const _14 = new g4(m16, p22);
      f22.push(_14), d22.push(h18), g17.push(this._getOrCreateMaterial(e25, r24));
    }
    return x13 && this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."), { geometries: f22, transformations: d22, materials: g17, objectTransformation: m15 };
  }
  _createEdgeMaterial() {
    const e25 = { opacity: this._getLayerOpacity() };
    return f9(this.symbolLayer, e25);
  }
};
var he3 = n2();
var pe3 = n2();
var fe3 = n2();
var de3 = n2();
var ge = n2();
var xe = e8();
var _e3 = e7();
var ye = a3();
var be = [new f4()];
var ve;
!function(e25) {
  e25[e25.NONE = 0] = "NONE", e25[e25.ECEF = 1] = "ECEF";
}(ve || (ve = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLodInstanceGraphicLayer.js
var f17 = class {
  constructor(e25, t20, i17, n24) {
    this.graphics3DSymbolLayer = e25, this.instanceIndex = t20, this.elevationAligner = i17, this.elevationContext = n24, this.type = "lod-instance", this._highlights = /* @__PURE__ */ new Set(), this.alignedSampledElevation = 0, this.isElevationSource = false, this.needsElevationUpdates = false;
  }
  initialize() {
  }
  setVisibility(e25) {
    const t20 = this.lodRenderer.instanceData;
    e25 !== t20.getVisible(this.instanceIndex) && t20.setVisible(this.instanceIndex, e25);
  }
  destroy() {
    null != this.instanceIndex && (this.lodRenderer.instanceData.removeInstance(this.instanceIndex), this.graphics3DSymbolLayer.notifyDestroyGraphicLayer(this));
  }
  alignWithElevation(t20, i17, n24) {
    if (this.elevationAligner) {
      s8(this.elevationContext.featureExpressionInfoContext, n24);
      const s16 = this.elevationAligner(this, this.elevationContext, t20, i17);
      r(s16) && (this.alignedSampledElevation = s16);
    }
  }
  getCenterObjectSpace(e25 = n2()) {
    return this.lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex, I4), L(e25, this.lodRenderer.baseBoundingSphere.center, I4);
  }
  getBoundingBoxObjectSpace(e25 = a3()) {
    this.lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex, I4);
    const t20 = this.lodRenderer.baseBoundingBox;
    B(e25);
    for (let s16 = 0; s16 < 8; ++s16)
      o3(x9, 0 == (1 & s16) ? t20[0] : t20[3], 0 == (2 & s16) ? t20[1] : t20[4], 0 == (4 & s16) ? t20[2] : t20[5]), L(x9, x9, I4), h3(e25, x9);
    return e25;
  }
  computeAttachmentOrigin(e25) {
    this.lodRenderer.instanceData.getGlobalTransform(this.instanceIndex, I4), e25.render.origin[0] += I4[12], e25.render.origin[1] += I4[13], e25.render.origin[2] += I4[14], e25.render.num++;
  }
  async getProjectedBoundingBox(t20, n24, s16, r24, o22) {
    const d22 = this.getBoundingBoxObjectSpace(o22), m15 = v14, u16 = S(d22) ? 1 : m15.length;
    this.lodRenderer.instanceData.getGlobalTransform(this.instanceIndex, I4);
    for (let e25 = 0; e25 < u16; e25++) {
      const t21 = m15[e25];
      x9[0] = d22[t21[0]], x9[1] = d22[t21[1]], x9[2] = d22[t21[2]], L(x9, x9, I4), p16[3 * e25 + 0] = x9[0], p16[3 * e25 + 1] = x9[1], p16[3 * e25 + 2] = x9[2];
    }
    if (!t20(p16, 0, u16))
      return null;
    B(d22);
    let f22 = null;
    this.calculateRelativeScreenBounds && (f22 = this.calculateRelativeScreenBounds());
    for (let e25 = 0; e25 < 3 * u16; e25 += 3) {
      for (let t21 = 0; t21 < 3; t21++)
        d22[t21] = Math.min(d22[t21], p16[e25 + t21]), d22[t21 + 3] = Math.max(d22[t21 + 3], p16[e25 + t21]);
      f22 && s16.push({ location: p16.slice(e25, e25 + 3), screenSpaceBoundingRect: f22 });
    }
    if (n24 && (p5(d22, b10), "absolute-height" !== this.elevationContext.mode)) {
      let t21;
      const i17 = V3(d22, n24);
      try {
        t21 = await n24.service.queryElevation(b10[0], b10[1], r24, i17, "ground");
      } catch (S13) {
      }
      r(t21) && V(d22, 0, 0, -this.alignedSampledElevation + t21);
    }
    return d22;
  }
  addObjectState(e25, t20) {
    if (e25 === u9.Highlight) {
      const i17 = new r13(e25);
      this._addHighlightId(i17), t20.addExternal((e26) => {
        this._removeHighlightId(e26);
      }, i17);
    }
  }
  removeObjectState(e25) {
    this._highlights.forEach((t20) => e25.remove(t20));
  }
  _addHighlightId(e25) {
    this._highlights.add(e25), this.lodRenderer.instanceData.setHighlight(this.instanceIndex, true);
  }
  _removeHighlightId(e25) {
    this._highlights.delete(e25), this.lodRenderer.instanceData.setHighlight(this.instanceIndex, this._highlights.size > 0);
  }
  get lodRenderer() {
    return this.graphics3DSymbolLayer.lodRenderer;
  }
};
var p16 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var x9 = n2();
var b10 = n2();
var v14 = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]];
var I4 = e8();

// node_modules/@arcgis/core/views/3d/layers/graphics/lodResourceUtils.js
function t17(e25) {
  const t20 = [];
  return e25.stageResources.geometries.forEach((s16, n24) => {
    const o22 = e25.stageResources.materials[n24], r24 = e25.stageResources.textures;
    t20.push({ material: o22, geometry: s16, textures: r24 });
  }), { components: t20, minScreenSpaceRadius: e25.lodThreshold, pivotOffset: e25.pivotOffset };
}
function s14(e25) {
  return { levels: e25.map((e26) => t17(e26)) };
}
function n18(t20, s16 = r19) {
  const n24 = c13(t20);
  return Math.sqrt(n24 / (s16 * Math.PI));
}
function o19(e25) {
  e25.levels.forEach((e26) => {
    e26.minScreenSpaceRadius || (e26.minScreenSpaceRadius = n18(e26));
  });
}
var r19 = 0.05;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/InstanceData.js
var E14;
function F7(t20) {
  let e25 = T2().mat4f64(O.LOCALTRANSFORM).mat4f64(O.GLOBALTRANSFORM).vec4f64(O.BOUNDINGSPHERE).vec3f64(O.MODELORIGIN).mat3f(O.MODEL).mat3f(O.MODELNORMAL).vec2f(O.MODELSCALEFACTORS);
  return t20.includes("color") && (e25 = e25.vec4f(O.COLOR)), t20.includes("featureAttribute") && (e25 = e25.vec4f(O.FEATUREATTRIBUTE)), e25 = e25.u8(O.STATE).u8(O.LODLEVEL).alignTo(8), e25;
}
!function(t20) {
  t20[t20.ALLOCATED = 1] = "ALLOCATED", t20[t20.DEFAULT_ACTIVE = 2] = "DEFAULT_ACTIVE", t20[t20.VISIBLE = 4] = "VISIBLE", t20[t20.HIGHLIGHT = 8] = "HIGHLIGHT", t20[t20.HIGHLIGHT_ACTIVE = 16] = "HIGHLIGHT_ACTIVE", t20[t20.REMOVE = 32] = "REMOVE", t20[t20.TRANSFORM_CHANGED = 64] = "TRANSFORM_CHANGED", t20[t20.ACTIVE = 18] = "ACTIVE";
}(E14 || (E14 = {}));
var O11 = class {
  constructor(t20) {
    this.localTransform = t20.getField(O.LOCALTRANSFORM, b2), this.globalTransform = t20.getField(O.GLOBALTRANSFORM, b2), this.modelOrigin = t20.getField(O.MODELORIGIN, T), this.model = t20.getField(O.MODEL, l9), this.modelNormal = t20.getField(O.MODELNORMAL, l9), this.modelScaleFactors = t20.getField(O.MODELSCALEFACTORS, u7), this.boundingSphere = t20.getField(O.BOUNDINGSPHERE, h4), this.color = t20.getField(O.COLOR, c5), this.featureAttribute = t20.getField(O.FEATUREATTRIBUTE, c5), this.state = t20.getField(O.STATE, d2), this.lodLevel = t20.getField(O.LODLEVEL, d2);
  }
};
var S10 = class extends n3 {
  constructor(t20, e25) {
    super(), this._capacity = 0, this._size = 0, this._next = 0, this._layout = F7(t20), this._shaderTransformation = e25;
  }
  get capacity() {
    return this._capacity;
  }
  get size() {
    return this._size;
  }
  get buffer() {
    return this._buffer.buffer;
  }
  get view() {
    return this._view;
  }
  addInstance() {
    this._size + 1 > this._capacity && this._grow();
    const t20 = this._findSlot();
    return this._view.state.set(t20, E14.ALLOCATED), this._size++, this.emit("instance-added", { index: t20 }), t20;
  }
  removeInstance(t20) {
    const e25 = this._view.state;
    e10(t20 >= 0 && t20 < this._capacity && e25.get(t20) & E14.ALLOCATED, "invalid instance handle"), this._getStateFlag(t20, E14.ACTIVE) ? this._setStateFlags(t20, E14.REMOVE) : this.freeInstance(t20), this.emit("instance-removed", { index: t20 });
  }
  freeInstance(t20) {
    const e25 = this._view.state;
    e10(t20 >= 0 && t20 < this._capacity && e25.get(t20) & E14.ALLOCATED, "invalid instance handle"), e25.set(t20, 0), this._size--;
  }
  setLocalTransform(t20, e25, s16 = true) {
    this._view.localTransform.setMat(t20, e25), s16 && this.updateModelTransform(t20);
  }
  getLocalTransform(t20, e25) {
    this._view.localTransform.getMat(t20, e25);
  }
  setGlobalTransform(t20, e25, s16 = true) {
    this._view.globalTransform.setMat(t20, e25), s16 && this.updateModelTransform(t20);
  }
  getGlobalTransform(t20, e25) {
    this._view.globalTransform.getMat(t20, e25);
  }
  updateModelTransform(t20) {
    const a21 = this._view, o22 = M7, h18 = I5;
    a21.localTransform.getMat(t20, b11), a21.globalTransform.getMat(t20, w6);
    const l26 = u4(w6, w6, b11);
    o3(o22, l26[12], l26[13], l26[14]), a21.modelOrigin.setVec(t20, o22), a5(h18, l26), a21.model.setMat(t20, h18);
    const c21 = p8(M7, l26);
    c21.sort(), a21.modelScaleFactors.set(t20, 0, c21[1]), a21.modelScaleFactors.set(t20, 1, c21[2]), u8(h18, h18), o8(h18, h18), a21.modelNormal.setMat(t20, h18), this._setStateFlags(t20, E14.TRANSFORM_CHANGED), this.emit("instance-transform-changed", { index: t20 });
  }
  getModelTransform(t20, e25) {
    const s16 = this._view;
    s16.model.getMat(t20, I5), s16.modelOrigin.getVec(t20, M7), e25[0] = I5[0], e25[1] = I5[1], e25[2] = I5[2], e25[3] = 0, e25[4] = I5[3], e25[5] = I5[4], e25[6] = I5[5], e25[7] = 0, e25[8] = I5[6], e25[9] = I5[7], e25[10] = I5[8], e25[11] = 0, e25[12] = M7[0], e25[13] = M7[1], e25[14] = M7[2], e25[15] = 1;
  }
  applyShaderTransformation(t20, e25) {
    this._shaderTransformation && this._shaderTransformation.applyTransform(this, t20, e25);
  }
  getCombinedModelTransform(t20, e25) {
    return this.getModelTransform(t20, e25), this._shaderTransformation && this._shaderTransformation.applyTransform(this, t20, e25), e25;
  }
  getCombinedLocalTransform(t20, e25) {
    return this._view.localTransform.getMat(t20, e25), this._shaderTransformation && this._shaderTransformation.applyTransform(this, t20, e25), e25;
  }
  getCombinedMaxScaleFactor(t20) {
    let e25 = this._view.modelScaleFactors.get(t20, 1);
    if (this._shaderTransformation) {
      const s16 = this._shaderTransformation.scaleFactor(M7, this, t20);
      e25 *= Math.max(s16[0], s16[1], s16[2]);
    }
    return e25;
  }
  getCombinedMedianScaleFactor(t20) {
    let e25 = this._view.modelScaleFactors.get(t20, 0);
    if (this._shaderTransformation) {
      const s16 = this._shaderTransformation.scaleFactor(M7, this, t20);
      s16.sort(), e25 *= s16[1];
    }
    return e25;
  }
  getModel(t20, e25) {
    this._view.model.getMat(t20, e25);
  }
  setFeatureAttribute(t20, e25) {
    this._view.featureAttribute.setVec(t20, e25);
  }
  getFeatureAttribute(t20, e25) {
    this._view.featureAttribute.getVec(t20, e25);
  }
  setColor(t20, e25) {
    this._view.color.setVec(t20, e25);
  }
  getColor(t20, e25) {
    this._view.color.getVec(t20, e25);
  }
  setVisible(t20, e25) {
    e25 !== this.getVisible(t20) && (this._setStateFlag(t20, E14.VISIBLE, e25), this.emit("instance-visibility-changed", { index: t20 }));
  }
  getVisible(t20) {
    return this._getStateFlag(t20, E14.VISIBLE);
  }
  setHighlight(t20, e25) {
    e25 !== this.getHighlight(t20) && (this._setStateFlag(t20, E14.HIGHLIGHT, e25), this.emit("instance-highlight-changed", { index: t20 }));
  }
  getHighlight(t20) {
    return this._getStateFlag(t20, E14.HIGHLIGHT);
  }
  getState(t20) {
    return this._view.state.get(t20);
  }
  getLodLevel(t20) {
    return this._view.lodLevel.get(t20);
  }
  countFlags(t20) {
    let e25 = 0;
    for (let s16 = 0; s16 < this._capacity; ++s16) {
      this.getState(s16) & t20 && ++e25;
    }
    return e25;
  }
  _setStateFlags(t20, e25) {
    const s16 = this._view.state;
    e25 = s16.get(t20) | e25, s16.set(t20, e25);
  }
  _clearStateFlags(t20, e25) {
    const s16 = this._view.state;
    e25 = s16.get(t20) & ~e25, s16.set(t20, e25);
  }
  _setStateFlag(t20, e25, s16) {
    s16 ? this._setStateFlags(t20, e25) : this._clearStateFlags(t20, e25);
  }
  _getStateFlag(t20, e25) {
    return !!(this._view.state.get(t20) & e25);
  }
  _grow() {
    const t20 = Math.max(v15, Math.floor(this._capacity * p17)), e25 = this._layout.createBuffer(t20);
    if (this._buffer) {
      const t21 = new Uint8Array(this._buffer.buffer);
      new Uint8Array(e25.buffer).set(t21);
    }
    this._capacity = t20, this._buffer = e25, this._view = new O11(this._buffer);
  }
  _findSlot() {
    const t20 = this._view.state;
    let e25 = this._next;
    for (; t20.get(e25) & E14.ALLOCATED; )
      e25 = (e25 + 1) % this._capacity;
    return this._next = (e25 + 1) % this._capacity, e25;
  }
};
var v15 = 1024;
var p17 = 2;
var M7 = n2();
var I5 = e7();
var b11 = e8();
var w6 = e8();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/InstanceOctree.js
var n19 = class extends G3 {
  constructor(e25, r24) {
    super((t20) => C2(this._instanceData.view.boundingSphere.getVec(t20, this._tmpSphere)), { maximumDepth: 25 }), this._tmpSphere = _5(), this._tmpMat4 = e8(), this._instanceData = e25, this._boundingSphere = r24;
  }
  addInstance(t20) {
    const s16 = this._instanceData.view.boundingSphere, i17 = this._instanceData.getCombinedModelTransform(t20, this._tmpMat4);
    L(this._tmpSphere, this._boundingSphere.center, i17), this._tmpSphere[3] = this._boundingSphere.radius * l18(i17), s16.setVec(t20, this._tmpSphere), this.add([t20]);
  }
  removeInstance(t20) {
    this.remove([t20]);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LevelSelector.js
var t18 = class {
  constructor(t20, s16) {
    this.thresholdScale = 1, this._camera = new K(), this._worldSpaceRadius = t20, this._thresholds = s16.map((e25) => e25);
  }
  updateCamera(e25) {
    this._camera.copyFrom(e25);
  }
  selectLevel(e25, t20) {
    const s16 = this._camera.computeScreenPixelSizeAt(e25), r24 = this._worldSpaceRadius * t20 / s16, a21 = this._thresholds;
    let h18 = -1;
    for (let o22 = 0; o22 < a21.length; ++o22)
      r24 >= a21[o22] * this.thresholdScale && (h18 = o22);
    return h18;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodComponentData.js
var m13 = class {
  constructor(s16, o22) {
    const i17 = s16.renderContext.rctx, { geometry: m15, material: u16 } = o22;
    this._materialRepository = s16.materialRep, u16.setParameters({ instancedDoublePrecision: true });
    const f22 = u16.createBufferWriter(), d22 = f22.vertexBufferLayout, p21 = f22.elementCount(m15), c21 = f22.allocate(p21);
    f22.write({}, m15, c21, 0), this.geometry = m15, this.material = u16, this.glMaterials = new a8(u16, this._materialRepository), this.vertexBufferLayout = d22, this.vbo = c10.createVertex(i17, F3.STATIC_DRAW, c21.buffer), this.vao = new f6(i17, E4, { geometry: o6(d22) }, { geometry: this.vbo }), this.vertexCount = p21;
  }
  destroy() {
    this.glMaterials.destroy(), this.vbo.dispose(), this.vao.dispose();
  }
  get boundingInfo() {
    return this.geometry.boundingInfo;
  }
  get triangleCount() {
    return this.vertexCount / 3;
  }
  intersect(r24, e25, t20, a21, n24, l26, m15, u16) {
    const f22 = this.geometry.id;
    this.material.intersect(this.geometry, null, r24.transform.transform, r24, t20, a21, (t21, a22, d22, p21, c21) => {
      if (t21 >= 0) {
        if (null != e25 && !e25(r24.rayBegin, r24.rayEnd, t21))
          return;
        const p22 = { layerUid: l26.layerUid, graphicUid: l26.graphicUid(n24), geometryId: f22, triangleNr: d22, baseBoundingSphere: m15, numLodLevels: u16 };
        if ((null == r24.results.min.drapedLayerOrder || c21 >= r24.results.min.drapedLayerOrder) && (null == r24.results.min.dist || t21 < r24.results.min.dist) && r24.results.min.set(i11.LOD, p22, t21, a22, r24.transform.transform, c21), r24.options.store !== t12.MIN && (null == r24.results.max.drapedLayerOrder || c21 >= r24.results.max.drapedLayerOrder) && (null == r24.results.max.dist || t21 > r24.results.max.dist) && r24.results.max.set(i11.LOD, p22, t21, a22, r24.transform.transform, c21), r24.options.store === t12.ALL) {
          const e26 = U3(r24.results.min.ray);
          e26.set(i11.LOD, p22, t21, a22, r24.transform.transform, c21), r24.results.all.push(e26);
        }
      }
    });
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodLevel.js
var h15 = class {
  constructor(n24, o22) {
    this.minScreenSpaceRadius = n24, this.components = o22;
  }
  static async create(n24, o22, i17) {
    const r24 = await Promise.allSettled(o22.components.map((o23) => n24.schedule(() => new m13(n24, o23), i17))), s16 = r24.map((n25) => "fulfilled" === n25.status ? n25.value : null).filter((n25) => n25);
    if (p2(i17) || s16.length !== r24.length) {
      s16.forEach((n25) => n25.destroy()), f(i17);
      for (const n25 of r24)
        if ("rejected" === n25.status)
          throw n25.reason;
    }
    return new h15(o22.minScreenSpaceRadius, s16);
  }
  destroy() {
    this.components.forEach((n24) => n24.destroy());
  }
  intersect(n24, o22, t20, e25, i17, r24, s16) {
    this.components.forEach((c21) => c21.intersect(n24, o22, t20, e25, i17, r24, this.boundingSphere, s16));
  }
  get boundingBox() {
    if (t(this._boundingBox)) {
      const n24 = B();
      this.components.forEach((t20) => {
        r(t20.boundingInfo) && (h3(n24, t20.boundingInfo.bbMin), h3(n24, t20.boundingInfo.bbMax));
      }), this._boundingBox = n24;
    }
    return this._boundingBox;
  }
  get boundingSphere() {
    if (t(this._boundingSphere)) {
      const n24 = this.boundingBox, o22 = n2();
      p5(n24, o22), this._boundingSphere = { center: o22, radius: 0.5 * g3(n24) };
    }
    return this._boundingSphere;
  }
  get triangleCount() {
    return this.components.reduce((n24, o22) => n24 + o22.triangleCount, 0);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/BackedBufferObject.js
var r20 = class {
  constructor(r24, i17, s16) {
    this._elementSize = i17, this._buffer = c10.createVertex(r24, F3.STATIC_DRAW), this.resize(s16);
  }
  destroy() {
    this._buffer.dispose();
  }
  get elementSize() {
    return this._elementSize;
  }
  get capacity() {
    return this._capacity;
  }
  get array() {
    return this._array;
  }
  get buffer() {
    return this._buffer;
  }
  get memoryUsage() {
    return { cpu: this._capacity * this._elementSize, gpu: this._capacity * this._elementSize };
  }
  copyRange(e25, t20, r24, i17 = 0) {
    const s16 = new Uint8Array(this.array, e25 * this.elementSize, (t20 - e25) * this.elementSize);
    new Uint8Array(r24.array, i17 * this.elementSize).set(s16);
  }
  transferAll() {
    this._buffer.setData(this._array);
  }
  transferRange(e25, t20) {
    const r24 = e25 * this._elementSize, i17 = t20 * this._elementSize;
    this._buffer.setSubData(this._array, r24, r24, i17);
  }
  resize(e25) {
    const t20 = e25 * this._elementSize, r24 = new ArrayBuffer(t20);
    this._array && (e25 >= this._capacity ? new Uint8Array(r24).set(new Uint8Array(this._array)) : new Uint8Array(r24).set(new Uint8Array(this._array).subarray(0, e25 * this._elementSize))), this._array = r24, this._buffer.setSize(t20), this._capacity = e25;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/RenderInstanceData.js
var h16 = class {
  constructor(s16) {
    this.modelOriginHi = s16.getField(O.MODELORIGINHI, i2), this.modelOriginLo = s16.getField(O.MODELORIGINLO, i2), this.model = s16.getField(O.MODEL, l9), this.modelNormal = s16.getField(O.MODELNORMAL, l9), this.color = s16.getField(O.INSTANCECOLOR, c5), this.featureAttribute = s16.getField(O.INSTANCEFEATUREATTRIBUTE, c5);
  }
};
var n20 = class {
  constructor(t20, i17) {
    this._headIndex = 0, this._tailIndex = 0, this._captureFirstIndex = true, this._updating = false, this._prevHeadIndex = 0, this._resized = false, this._rctx = t20, this._instanceBufferLayout = i17, this._elementSize = i17.stride, this._capacity = 1;
  }
  destroy() {
    this._buffer && this._buffer.destroy();
  }
  get buffer() {
    return this._buffer.buffer;
  }
  get view() {
    return this._view;
  }
  get capacity() {
    return this._capacity;
  }
  get size() {
    const t20 = this._headIndex, i17 = this._tailIndex;
    return t20 >= i17 ? t20 - i17 : t20 + this._capacity - i17;
  }
  get isEmpty() {
    return this._headIndex === this._tailIndex;
  }
  get isFull() {
    return this._tailIndex === (this._headIndex + 1) % this._capacity;
  }
  get headIndex() {
    return this._headIndex;
  }
  get tailIndex() {
    return this._tailIndex;
  }
  get firstIndex() {
    return this._firstIndex;
  }
  get memoryUsage() {
    return this._buffer ? this._buffer.memoryUsage : { cpu: 0, gpu: 0 };
  }
  reset() {
    this._headIndex = 0, this._tailIndex = 0, this._firstIndex = null;
  }
  startUpdateCylce() {
    this._captureFirstIndex = true;
  }
  beginUpdate() {
    e10(!this._updating, "already updating"), this._updating = true, this._prevHeadIndex = this._headIndex;
  }
  endUpdate() {
    e10(this._updating, "not updating"), this.size < c18 * this.capacity && this._shrink(), this._resized ? (this._buffer.transferAll(), this._resized = false) : this._transferRange(this._prevHeadIndex, this._headIndex), this._updating = false;
  }
  allocateHead() {
    e10(this._updating, "not updating"), this.isFull && this._grow();
    const t20 = this.headIndex;
    return this._captureFirstIndex && (this._firstIndex = t20, this._captureFirstIndex = false), this._incrementHead(), e10(this._headIndex !== this._tailIndex, "invalid pointers"), t20;
  }
  freeTail() {
    e10(this._updating, "not updating"), e10(this.size > 0, "invalid size");
    const t20 = this._tailIndex === this._firstIndex;
    this._incrementTail(), t20 && (this._firstIndex = this._tailIndex);
  }
  _grow() {
    const t20 = Math.max(_10, Math.floor(this._capacity * d16));
    this._resize(t20);
  }
  _shrink() {
    const t20 = Math.max(_10, Math.floor(this._capacity * f18));
    this._resize(t20);
  }
  _resize(t20) {
    if (e10(this._updating, "not updating"), t20 === this._capacity)
      return;
    const i17 = new r20(this._rctx, this._elementSize, t20);
    if (this._buffer) {
      this._firstIndex && (this._firstIndex = (this._firstIndex + this._capacity - this._tailIndex) % this._capacity);
      const t21 = this.size, e25 = this._compactInstances(i17);
      e10(e25 === t21, "invalid compaction"), this._buffer.destroy(), this._tailIndex = 0, this._headIndex = e25, this._prevHeadIndex = 0;
    }
    this._resized = true, this._capacity = t20, this._buffer = i17, this._view = new h16(this._instanceBufferLayout.createView(this._buffer.array));
  }
  _compactInstances(t20) {
    const i17 = this._headIndex, e25 = this._tailIndex;
    return e25 < i17 ? (this._buffer.copyRange(e25, i17, t20), i17 - e25) : e25 > i17 ? (this._buffer.copyRange(e25, this._capacity, t20), i17 > 0 && this._buffer.copyRange(0, i17, t20, this._capacity - e25), i17 + (this._capacity - e25)) : 0;
  }
  _incrementHead(t20 = 1) {
    this._headIndex = (this._headIndex + t20) % this._capacity;
  }
  _incrementTail(t20 = 1) {
    this._tailIndex = (this._tailIndex + t20) % this._capacity;
  }
  _transferRange(t20, i17) {
    t20 < i17 ? this._buffer.transferRange(t20, i17) : t20 > i17 && (i17 > 0 && this._buffer.transferRange(0, i17), this._buffer.transferRange(t20, this._capacity));
  }
};
var _10 = 1024;
var d16 = 2;
var c18 = 0.3;
var f18 = 0.5;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodRenderer.js
var O12 = (e25) => {
  const t20 = e25.baseBoundingSphere.radius, s16 = e25.levels.map((e26) => e26.minScreenSpaceRadius);
  return new t18(t20, s16);
};
var M8 = class {
  constructor(e25, t20, s16, a21) {
    this.type = i11.LOD, this.isGround = false, this._levels = [], this._defaultRenderInstanceData = [], this._highlightRenderInstanceData = [], this._instanceIndex = 0, this._slicePlane = false, this._enableLevelSelection = true, this._lastCamera = new K(), this._updateCyclesWithStaticCamera = -1, this._needFullCycle = false, this.slots = [E6.OPAQUE_MATERIAL, E6.TRANSPARENT_MATERIAL], this.canRender = true, this._symbol = e25, this._optionalFields = t20, this._metadata = s16, this._instanceBufferLayout = B3({ instancedDoublePrecision: true, instanced: t20 }), this._glInstanceBufferLayout = o6(this._instanceBufferLayout, 1), this._instanceData = new S10(this._optionalFields, a21), this._instanceData.on("instance-added", () => this._requestUpdateCycle()), this._instanceData.on("instance-removed", () => this._requestUpdateCycle()), this._instanceData.on("instance-transform-changed", (e26) => {
      this._requestUpdateCycle(), this._metadata.notifyGraphicGeometryChanged(e26.index);
    }), this._instanceData.on("instance-visibility-changed", (e26) => {
      this._requestUpdateCycle(true), this._metadata.notifyGraphicVisibilityChanged(e26.index);
    }), this._instanceData.on("instance-highlight-changed", () => this._requestUpdateCycle(true)), this._enableLevelSelection = this._symbol.levels.length > 1;
  }
  get levels() {
    return this._levels;
  }
  get baseBoundingBox() {
    return this._levels[this._levels.length - 1].boundingBox;
  }
  get baseBoundingSphere() {
    return this._levels[this._levels.length - 1].boundingSphere;
  }
  get baseMaterial() {
    return this._levels[this._levels.length - 1].components[0].material;
  }
  get slicePlaneEnabled() {
    return this._slicePlane;
  }
  set slicePlaneEnabled(e25) {
    this._slicePlane = e25;
  }
  get layerUid() {
    return this._metadata.layerUid;
  }
  get instanceData() {
    return this._instanceData;
  }
  get memoryUsage() {
    const e25 = { cpu: 0, gpu: 0 };
    return this._defaultRenderInstanceData.forEach((t20) => {
      const s16 = t20.memoryUsage;
      e25.cpu += s16.cpu, e25.gpu += s16.gpu;
    }), this._highlightRenderInstanceData.forEach((t20) => {
      const s16 = t20.memoryUsage;
      e25.cpu += s16.cpu, e25.gpu += s16.gpu;
    }), e25;
  }
  get renderStats() {
    const e25 = this._instanceData.size, t20 = [];
    return this._levels.forEach((e26, s16) => {
      const a21 = this._defaultRenderInstanceData[s16], n24 = this._highlightRenderInstanceData[s16], i17 = a21.size + n24.size, r24 = e26.triangleCount;
      t20.push({ renderedInstances: i17, renderedTriangles: i17 * r24, trianglesPerInstance: r24 });
    }), { totalInstances: e25, renderedInstances: t20.reduce((e26, t21) => e26 + t21.renderedInstances, 0), renderedTriangles: t20.reduce((e26, t21) => e26 + t21.renderedTriangles, 0), levels: t20 };
  }
  async initializeRenderContext(e25, a21) {
    this._context = e25;
    const n24 = e25.renderContext.rctx, i17 = await Promise.allSettled(this._symbol.levels.map((t20) => (this._defaultRenderInstanceData.push(new n20(n24, this._instanceBufferLayout)), this._highlightRenderInstanceData.push(new n20(n24, this._instanceBufferLayout)), h15.create(e25, t20, a21)))), r24 = i17.map((e26) => "fulfilled" === e26.status ? e26.value : null).filter((e26) => e26);
    if (p2(a21) || r24.length !== i17.length) {
      r24.forEach((e26) => e26.destroy()), f(a21);
      for (const e26 of i17)
        if ("rejected" === e26.status)
          throw e26.reason;
    }
    this._levels = r24, this._levelSelector = O12(this);
  }
  uninitializeRenderContext() {
    this._invalidateOctree(), this._levels.forEach((e25) => e25.destroy()), this._defaultRenderInstanceData.forEach((e25) => e25.destroy()), this._highlightRenderInstanceData.forEach((e25) => e25.destroy());
  }
  get needsTransparentPass() {
    return this._levels.some((e25) => e25.components.some((e26) => e26.material.requiresSlot(E6.TRANSPARENT_MATERIAL)));
  }
  get needsHighlight() {
    return this._highlightRenderInstanceData.some((e25) => e25.size > 0);
  }
  prepareRender(e25) {
    if (t10.LOD_INSTANCE_RENDERER_DISABLE_UPDATES)
      return;
    if (this._enableLevelSelection) {
      const t21 = e25.bindParameters.contentCamera.equals(this._lastCamera);
      this._lastCamera.copyFrom(e25.bindParameters.contentCamera), t21 || this._requestUpdateCycle();
    }
    const t20 = this._needFullCycle ? this._instanceData.size : 2e3;
    this._needFullCycle = false, this._updateInstances(e25.bindParameters.contentCamera, t20), this.needsUpdates && this._context.requestRender();
  }
  render(e25) {
    if (!this.baseMaterial.isVisible() || !this.baseMaterial.isVisibleInPass(e25.pass))
      return;
    e25.rctx.bindVAO();
    const t20 = e25.pass !== A2.MATERIAL_HIGHLIGHT && e25.pass !== A2.MATERIAL_DEPTH_SHADOWMAP_HIGHLIGHT, s16 = e25.pass !== A2.MATERIAL_DEPTH_SHADOWMAP_DEFAULT;
    t20 && this._renderComponents(e25, this._defaultRenderInstanceData), s16 && this._renderComponents(e25, this._highlightRenderInstanceData);
  }
  intersect(e25, t20, s16, a21) {
    if (!this.baseMaterial.isVisible())
      return;
    const i17 = n2();
    e5(i17, a21, s16);
    const l26 = (n24) => {
      this._instanceData.getCombinedModelTransform(n24, P8), e25.transform.set(P8), L(F8, s16, e25.transform.inverse), L(w7, a21, e25.transform.inverse);
      const i18 = this._instanceData.getState(n24), o22 = this._instanceData.getLodLevel(n24), l27 = this._levels.length;
      e10(i18 & E14.ACTIVE, "invalid instance state"), e10(o22 >= 0 && o22 < l27, "invaid lod level"), this._levels[o22].intersect(e25, t20, F8, w7, n24, this._metadata, l27);
    };
    this.baseMaterial.parameters.verticalOffset ? this.octree.forEach(l26) : this.octree.forEachAlongRay(s16, i17, l26);
  }
  queryDepthRange(e25) {
    return this._queryDepthRangeOctree(e25);
  }
  notifyShaderTransformationChanged() {
    this._invalidateOctree();
  }
  _requestUpdateCycle(e25 = false) {
    this._updateCyclesWithStaticCamera = -1, e25 && (this._needFullCycle = true), this.needsUpdates && this._context.requestRender();
  }
  get needsUpdates() {
    return this._instanceData.size > 0 && this._updateCyclesWithStaticCamera < 1;
  }
  get octree() {
    return this._octree || (this._octree = this._buildOctree()), this._octree;
  }
  _invalidateOctree() {
    this._octree && (this._octree.destroy(), this._octree = null);
  }
  _buildOctree() {
    const e25 = new n19(this._instanceData, this.baseBoundingSphere), t20 = this._instanceData, s16 = t20.view ? t20.view.state : null;
    for (let a21 = 0; a21 < this._instanceData.capacity; ++a21) {
      s16.get(a21) & E14.ACTIVE && e25.addInstance(a21);
    }
    return e25;
  }
  _queryDepthRangeOctree(e25) {
    const t20 = e25.eye, s16 = e25.viewForward, a21 = this.octree.findClosest(s16, G3.DepthOrder.FRONT_TO_BACK, e25.frustum), r24 = this.octree.findClosest(s16, G3.DepthOrder.BACK_TO_FRONT, e25.frustum);
    if (null != a21 && null != r24) {
      this._instanceData.view.boundingSphere.getVec(a21, V6), e5(V6, V6, t20);
      const o22 = P(V6, s16) - V6[3];
      this._instanceData.view.boundingSphere.getVec(r24, V6), e5(V6, V6, t20);
      const l26 = P(V6, s16) + V6[3];
      return { near: Math.max(e25.near, o22), far: Math.min(e25.far, l26) };
    }
    return { near: 1 / 0, far: -1 / 0 };
  }
  _startUpdateCycle() {
    this._updateCyclesWithStaticCamera++, this._defaultRenderInstanceData.forEach((e25) => {
      e25.startUpdateCylce();
    }), this._highlightRenderInstanceData.forEach((e25) => {
      e25.startUpdateCylce();
    }), this.needsUpdates && this._context.requestRender();
  }
  _updateInstances(e25, t20) {
    const s16 = this._enableLevelSelection, a21 = this._levelSelector;
    a21.updateCamera(e25), this._defaultRenderInstanceData.forEach((e26) => {
      e26.beginUpdate();
    }), this._highlightRenderInstanceData.forEach((e26) => {
      e26.beginUpdate();
    });
    const n24 = this._instanceData, i17 = this._instanceData.view, r24 = n24.size, o22 = n24.capacity;
    let l26 = this._instanceIndex;
    t20 = Math.min(r24, t20);
    for (let c21 = 0; c21 < t20; ++c21) {
      0 === l26 && this._startUpdateCycle();
      const e26 = i17.state.get(l26);
      let r25 = 0;
      if (!(e26 & E14.ALLOCATED)) {
        l26 = (l26 + 1) % o22, t20++;
        continue;
      }
      const c22 = i17.lodLevel.get(l26);
      if (e26 & E14.DEFAULT_ACTIVE && this._defaultRenderInstanceData[c22].freeTail(), e26 & E14.HIGHLIGHT_ACTIVE && this._highlightRenderInstanceData[c22].freeTail(), e26 & E14.REMOVE)
        n24.freeInstance(l26);
      else if (e26 & E14.VISIBLE) {
        let t21 = 0;
        s16 && (i17.modelOrigin.getVec(l26, H3), t21 = a21.selectLevel(H3, n24.getCombinedMedianScaleFactor(l26))), r25 = e26 & ~(E14.ACTIVE | E14.TRANSFORM_CHANGED), t21 >= 0 && (e26 & E14.HIGHLIGHT ? (x10(this._highlightRenderInstanceData[t21], i17, l26), r25 |= E14.HIGHLIGHT_ACTIVE) : (x10(this._defaultRenderInstanceData[t21], i17, l26), r25 |= E14.DEFAULT_ACTIVE)), i17.state.set(l26, r25), i17.lodLevel.set(l26, t21);
      } else
        r25 = e26 & ~(E14.ACTIVE | E14.TRANSFORM_CHANGED), i17.state.set(l26, r25);
      if (this._octree) {
        const t21 = !!(e26 & E14.ACTIVE), s17 = !!(r25 & E14.ACTIVE);
        !t21 && s17 ? this._octree.addInstance(l26) : t21 && !s17 ? this._octree.removeInstance(l26) : t21 && s17 && e26 & E14.TRANSFORM_CHANGED && (this._octree.removeInstance(l26), this._octree.addInstance(l26));
      }
      l26 = (l26 + 1) % o22;
    }
    this._instanceIndex = l26, this._defaultRenderInstanceData.forEach((e26) => {
      e26.endUpdate();
    }), this._highlightRenderInstanceData.forEach((e26) => {
      e26.endUpdate();
    });
  }
  _renderComponents(e25, t20) {
    this.levels.forEach((s16, a21) => {
      s16.components.forEach((s17) => {
        this._renderComponent(e25, t20[a21], s17, a21);
      });
    });
  }
  _renderComponent(t20, s16, a21, n24) {
    const i17 = t20.bindParameters;
    if (0 === s16.size || !a21.material.requiresSlot(i17.slot))
      return;
    const { rctx: r24, pass: o22 } = t20, l26 = a21.glMaterials.load(r24, o22);
    if (t(l26))
      return;
    const h18 = l26.beginSlot(i17), d22 = r24.bindTechnique(h18, a21.material.parameters, i17);
    r24.bindVAO(a21.vao), h18.ensureAttributeLocations(a21.vao), h18.bindDraw(q9, i17), t10.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL && t20.pass === A2.MATERIAL && (d22.setUniform4fv("externalColor", N3[Math.min(n24, N3.length - 1)]), d22.setUniform1i("colorMixMode", U.replace));
    const u16 = r24.capabilities.instancing, m15 = s16.capacity, p21 = s16.headIndex, I7 = s16.tailIndex, D7 = s16.firstIndex, C13 = this._glInstanceBufferLayout, R12 = (e25, t21) => {
      R4(r24, E4, s16.buffer, C13, e25), u16.drawArraysInstanced(h18.primitiveType, 0, a21.vertexCount, t21 - e25), E3(r24, E4, s16.buffer, C13);
    };
    a21.material.parameters.transparent && null != D7 ? p21 > I7 ? (e10(D7 >= I7 && D7 <= p21, "invalid firstIndex"), R12(D7, p21), R12(I7, D7)) : p21 < I7 && (D7 <= p21 ? (e10(D7 >= 0 && D7 <= p21, "invalid firstIndex"), R12(D7, p21), R12(I7, m15), R12(0, D7)) : (e10(D7 >= I7 && D7 <= m15, "invalid firstIndex"), R12(D7, m15), R12(0, p21), R12(I7, D7))) : p21 > I7 ? R12(I7, p21) : p21 < I7 && (R12(0, p21), R12(I7, m15)), r24.bindVAO(null);
  }
};
function x10(e25, t20, s16) {
  const a21 = e25.allocateHead();
  j9(t20, s16, e25.view, a21);
}
function j9(e25, t20, s16, a21) {
  p6(e25.modelOrigin, t20, s16.modelOriginHi, s16.modelOriginLo, a21), s16.model.copyFrom(a21, e25.model, t20), s16.modelNormal.copyFrom(a21, e25.modelNormal, t20), e25.color && s16.color && s16.color.copyFrom(a21, e25.color, t20), e25.featureAttribute && s16.featureAttribute && s16.featureAttribute.copyFrom(a21, e25.featureAttribute, t20);
}
var H3 = n2();
var V6 = n4();
var P8 = e8();
var F8 = n2();
var w7 = n2();
var N3 = [[1, 0, 1, 1], [0, 0, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1], [1, 0, 0, 1]];
var q9 = new _6();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectSymbolLayer.js
var me4 = class extends y3 {
  constructor(e25, t20, s16, r24) {
    super(e25, t20, s16, r24), this._resources = null, this._optionalFields = new Array(), this._instanceIndexToGraphicUid = /* @__PURE__ */ new Map(), this.hasLoadedPBRTextures = false, this._disposeResourceHandles = new Array(), this.ensureDrapedStatus(false), this.hasLoadedPBRTextures = s16.physicalBasedRenderingEnabled;
  }
  getCachedSize() {
    const [e25, s16, r24] = r(this._resources) ? this._resources.symbolSize : [1, 1, 1];
    return { width: e25, depth: s16, height: r24 };
  }
  async doLoad(e25) {
    if (!this._drivenProperties.size) {
      if (O4(this.symbolLayer))
        throw new Error();
    }
    const t20 = this.symbolLayer;
    if (this.isPrimitive) {
      const s16 = t20.resource ? t20.resource.primitive : d4;
      this._resources = await this._createResourcesForPrimitive(s16, e25);
    } else
      this._resources = await this._createResourcesForUrl(t20.resource.href, e25);
    this.layerOpacityChanged(), this.slicePlaneEnabledChanged(), this.physicalBasedRenderingChanged(), this.complexity = this.computeComplexity();
  }
  get extentPadding() {
    return r(this._resources) ? this._resources.extentPadding : 0;
  }
  get isPrimitive() {
    return !(this.symbolLayer.resource && this.symbolLayer.resource.href);
  }
  get lodRenderer() {
    return m(this._resources, "lodRenderer");
  }
  _setMaterialTransparencyParams(e25, t20 = m(this.symbolLayer, "material", "color")) {
    const r24 = this._getCombinedOpacity(t20), a21 = r24 < 1 || this.needsDrivenTransparentPass;
    return e25.transparent = a21, e25.opacity = r24, e25.cullFace = a21 ? n9.None : n9.Back, e25;
  }
  async _createResourcesForPrimitive(s16, a21) {
    if (!n13(s16))
      throw new Error(`Unknown object symbol primitive: ${s16}`);
    const i17 = this.symbolLayer, n24 = a3(c6(s16)), c21 = e4(F2(n24)), l26 = e4(t6(c21, i17)), h18 = s3(l26), d22 = false, m15 = false, u16 = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true, ambient: l, diffuse: l, hasSlicePlane: this._context.slicePlaneEnabled, hasSliceHighlight: false, castShadows: this.symbolLayer.castShadows, offsetTransparentBackfaces: !this.symbolLayer.isPrimitive }, y9 = u16.usePBR;
    this._setMaterialTransparencyParams(u16);
    const f22 = this.symbol;
    if ("point-3d" === f22.type && f22.verticalOffset) {
      const { screenLength: e25, minWorldLength: t20, maxWorldLength: s17 } = f22.verticalOffset;
      u16.verticalOffset = { screenLength: u3(e25), minWorldLength: t20 || 0, maxWorldLength: null != s17 ? s17 : 1 / 0 }, u16.castShadows = false;
    }
    if (this._context.screenSizePerspectiveEnabled && (u16.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings), this._drivenProperties.color)
      u16.externalColor = _2;
    else {
      const s17 = r(i17.material) && i17.material.color, r24 = r(s17) ? l4.toUnitRGBA(s17) : _2;
      u16.externalColor = r24;
    }
    this._fastUpdates = P7(this._context.renderer, this._fastVisualVariableConvertOptions(n24, l26, c21, n)), u16.instanced = ["transformation"], this._fastUpdates.enabled ? (Object.assign(u16, this._fastUpdates.materialParameters), u16.instanced.push("featureAttribute"), this._optionalFields.push("featureAttribute")) : this._hasPerInstanceColor() && (u16.instanced.push("color"), this._optionalFields.push("color"));
    const _14 = new R5(u16), P10 = t14(s16, _14);
    if (!P10)
      throw new Error(`Unknown object symbol primitive: ${s16}`);
    const R12 = r16(P10).map((e25) => ({ opacity: 1, transparent: e25.parameters.transparent })), v17 = await this._createStageResources(P10, y9);
    return { lodResources: P10, lodRenderer: await this._createLodRenderer(P10, a21), stageResources: v17, symbolSize: l26, extentPadding: h18, isEsriSymbolResource: d22, isWosr: m15, originalMaterialParameters: R12, physicalBasedRenderingEnabled: y9, resourceBoundingBox: n24, resourceSize: c21, pivotOffset: n };
  }
  async _createResourcesForUrl(e25, t20) {
    const a21 = ["transformation"], i17 = { materialParamsMixin: { instanced: a21, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows }, streamDataRequester: this._context.streamDataRequester, cache: this._context.sharedResources.objectResourceCache };
    this._fastUpdates = P7(this._context.renderer, this._fastVisualVariableConvertOptions(n, n, n, n)), this._fastUpdates.enabled ? (Object.assign(i17.materialParamsMixin, this._fastUpdates.materialParameters), a21.push("featureAttribute"), this._optionalFields.push("featureAttribute")) : this._hasPerInstanceColor() && (a21.push("color"), this._optionalFields.push("color"));
    const n24 = this.symbol;
    if ("point-3d" === n24.type && n24.verticalOffset) {
      const { screenLength: e26, minWorldLength: t21, maxWorldLength: s16 } = n24.verticalOffset;
      i17.materialParamsMixin.verticalOffset = { screenLength: u3(e26), minWorldLength: t21 || 0, maxWorldLength: null != s16 ? s16 : 1 / 0 }, i17.materialParamsMixin.castShadows = false;
    }
    i17.signal = t20, i17.usePBR = this._context.physicalBasedRenderingEnabled;
    const c21 = i17.usePBR, l26 = await J2(e25, i17), h18 = l26.isEsriSymbolResource, d22 = l26.isWosr;
    this._addDisposeResource(() => l26.remove());
    const m15 = s14(l26.lods);
    o19(m15), m15.levels.sort((e26, t21) => e26.minScreenSpaceRadius - t21.minScreenSpaceRadius), m15.levels[0].minScreenSpaceRadius = Math.min(2, m15.levels[0].minScreenSpaceRadius);
    const u16 = this._context, y9 = this.symbolLayer.material, f22 = this._getExternalColorParameters(y9), _14 = m(this.symbolLayer, "material", "color"), g17 = this._getCombinedOpacity(_14, { hasIntrinsicColor: true }), P10 = this.needsDrivenTransparentPass, R12 = r16(m15), v17 = r16(m15).map((e26) => ({ opacity: e26.parameters.opacity || 1, transparent: e26.parameters.transparent }));
    R12.forEach((e26) => {
      const t21 = e26.parameters;
      e26.setParameters(f22);
      const s16 = t21.opacity * g17, r24 = s16 < 1 || P10 || t21.transparent;
      e26.setParameters({ opacity: s16, transparent: r24 }), u16.screenSizePerspectiveEnabled && e26.setParameters({ screenSizePerspective: u16.sharedResources.screenSizePerspectiveSettings });
    });
    const x13 = l26.referenceBoundingBox, S13 = e4(F2(x13)), L9 = e4(m15.levels[0].pivotOffset), C13 = e4(t6(S13, this.symbolLayer)), w12 = s3(C13);
    R7(this._fastUpdates, this._context.renderer, this._fastVisualVariableConvertOptions(x13, C13, S13, L9)) && R12.forEach((e26) => e26.setParameters(this._fastUpdates.materialParameters));
    const U7 = await this._createStageResources(m15, c21);
    return { lodResources: m15, lodRenderer: await this._createLodRenderer(m15, t20), stageResources: U7, symbolSize: C13, extentPadding: w12, isEsriSymbolResource: h18, isWosr: d22, originalMaterialParameters: v17, physicalBasedRenderingEnabled: c21, resourceBoundingBox: x13, resourceSize: S13, pivotOffset: L9 };
  }
  _addDisposeResource(e25) {
    this._disposeResourceHandles.push(e25);
  }
  async _createStageResources(e25, t20) {
    const s16 = this._context.stage, r24 = r16(e25);
    t20 !== this._context.physicalBasedRenderingEnabled && this.physicalBasedRenderingChanged(), s16.addMany(r24), this._addDisposeResource(() => s16.removeMany(r24));
    const a21 = e18(e25);
    s16.addMany(a21), this._addDisposeResource(() => s16.removeMany(a21)), await s16.load(a21);
    const i17 = t15(e25);
    return s16.addMany(i17), this._addDisposeResource(() => s16.removeMany(i17)), { materials: r24, textures: a21, geometries: i17 };
  }
  async _createLodRenderer(e25, t20) {
    const s16 = this._context.stage, r24 = { layerUid: this._context.layer.uid, graphicUid: (e26) => this._instanceIndexToGraphicUid.get(e26), notifyGraphicGeometryChanged: (e26) => this._context.notifyGraphicGeometryChanged(this._instanceIndexToGraphicUid.get(e26)), notifyGraphicVisibilityChanged: (e26) => this._context.notifyGraphicVisibilityChanged(this._instanceIndexToGraphicUid.get(e26)) }, a21 = this._fastUpdates.enabled ? { applyTransform: (e26, t21, s17) => {
      e26.getFeatureAttribute(t21, _e4), n5(s17, B5(this._fastUpdates.materialParameters, _e4, s17));
    }, scaleFactor: (e26, t21, s17) => (t21.getFeatureAttribute(s17, _e4), L6(e26, this._fastUpdates.materialParameters, _e4)) } : null, i17 = new M8(e25, this._optionalFields, r24, a21);
    return i17.slicePlaneEnabled = this._context.slicePlaneEnabled, this._addDisposeResource(() => {
      s16.removeRenderPlugin(i17);
    }), await s16.addRenderPlugin(i17.slots, i17, t20), i17;
  }
  _getExternalColorParameters(s16) {
    const r24 = {};
    return this._drivenProperties.color ? r24.externalColor = _2 : r(s16) && r(s16.color) ? r24.externalColor = l4.toUnitRGBA(s16.color) : (r24.externalColor = _2, r24.colorMixMode = "ignore"), r24;
  }
  destroy() {
    super.destroy(), this._cleanupResources();
  }
  _cleanupResources() {
    this._disposeResourceHandles.forEach((e25) => e25()), this._disposeResourceHandles.length = 0, this._resources = null;
  }
  createGraphics3DGraphic(e25) {
    const t20 = e25.graphic;
    if (!this._validateGeometry(t20.geometry))
      return null;
    const s16 = d9(t20.geometry);
    if (t(s16))
      return this.logger.warn(`unsupported geometry type for icon symbol: ${t20.geometry.type}`), null;
    const r24 = this.setGraphicElevationContext(t20, new h10()), i17 = e25.renderingInfo;
    return this._createAs3DShape(t20, s16, i17, r24, t20.uid);
  }
  notifyDestroyGraphicLayer(e25) {
    this._instanceIndexToGraphicUid.delete(e25.instanceIndex);
  }
  graphicLayerToGraphicId() {
    return 0;
  }
  layerOpacityChanged() {
    if (t(this._resources))
      return true;
    const e25 = this._drivenProperties.opacity, t20 = !this.isPrimitive, r24 = this._resources.stageResources.materials, i17 = this._resources.originalMaterialParameters;
    for (let a21 = 0; a21 < r24.length; a21++) {
      const o22 = r24[a21], n24 = m(this.symbolLayer, "material", "color"), c21 = i17[a21], l26 = this._getCombinedOpacity(n24, { hasIntrinsicColor: t20 }) * c21.opacity, h18 = l26 < 1 || e25 || c21.transparent;
      o22.setParameters({ opacity: l26, transparent: h18 }), this.isPrimitive && o22.setParameters({ cullFace: h18 ? n9.None : n9.Back });
    }
    return true;
  }
  layerElevationInfoChanged(e25, t20) {
    return this.updateGraphics3DGraphicElevationInfo(e25, t20, v8);
  }
  slicePlaneEnabledChanged() {
    if (t(this._resources))
      return true;
    this._resources.lodRenderer.slicePlaneEnabled = this._context.slicePlaneEnabled;
    for (const e25 of this._resources.stageResources.materials)
      e25.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    return true;
  }
  physicalBasedRenderingChanged() {
    if (t(this._resources))
      return true;
    const { stageResources: e25, isWosr: t20 } = this._resources;
    for (const s16 of e25.materials)
      this.isPrimitive ? s16.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }) : t20 || s16.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: false });
    return false !== this.hasLoadedPBRTextures || true !== this._context.physicalBasedRenderingEnabled || (this.hasLoadedPBRTextures = true, false);
  }
  pixelRatioChanged() {
    return true;
  }
  applyRendererDiff(e25, t20) {
    if (t(this._resources))
      return e16.Recreate_Symbol;
    const { stageResources: { materials: s16 }, lodRenderer: r24, resourceBoundingBox: i17, symbolSize: o22, resourceSize: n24, pivotOffset: c21 } = this._resources;
    for (const a21 in e25.diff) {
      if ("visualVariables" !== a21)
        return e16.Recreate_Symbol;
      if (!R7(this._fastUpdates, t20, this._fastVisualVariableConvertOptions(i17, o22, n24, c21)))
        return e16.Recreate_Symbol;
      for (const e26 of s16)
        e26.setParameters(this._fastUpdates.materialParameters);
      r24.notifyShaderTransformationChanged();
    }
    return e16.Fast_Update;
  }
  computeComplexity() {
    if (t(this._resources))
      return super.computeComplexity();
    return { primitivesPerFeature: n14(this._resources.lodResources.levels[0]).reduce((e25, t20) => e25 + t20.indices.get(O.POSITION).length, 0) / 3, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false, memory: l19(this.symbol, this.symbolLayer) };
  }
  _hasLodRenderer() {
    return r(this._resources);
  }
  _createAs3DShape(e25, s16, r24, i17, o22) {
    if (!this._hasLodRenderer() || t(this._resources))
      return null;
    const n24 = this.getFastUpdateAttrValues(e25), c21 = !this._fastUpdates.enabled && this._hasPerInstanceColor() ? z3(r24.color, r24.opacity) : null, l26 = this._context.clippingExtent;
    if (Hn(s16, ue4, this._context.elevationProvider.spatialReference), r(l26) && !E2(l26, ue4))
      return null;
    const h18 = this._requiresTerrainElevation(i17), d22 = this._computeGlobalTransform(s16, i17, fe4, be2), p21 = this._computeLocalTransform(this._resources, this.symbolLayer, r24, ye2), m15 = this._resources.lodRenderer.instanceData, u16 = m15.addInstance();
    this._instanceIndexToGraphicUid.set(u16, o22), m15.setLocalTransform(u16, p21, false), m15.setGlobalTransform(u16, d22), n24 && m15.setFeatureAttribute(u16, n24), c21 && m15.setColor(u16, c21);
    const y9 = new f17(this, u16, I2, i17);
    return h18 && (y9.alignedSampledElevation = be2.sampledElevation), y9.needsElevationUpdates = v8(i17.mode), g8(y9, s16, this._context.elevationProvider), y9;
  }
  _computeGlobalTransform(e25, t20, s16, r24) {
    return d7(e25, this._context.elevationProvider, t20, this._context.renderCoordsHelper, r24), ue4[0] = e25.x, ue4[1] = e25.y, ue4[2] = r24.z, qn(e25.spatialReference, ue4, s16, this._context.renderCoordsHelper.spatialReference), s16;
  }
  _computeLocalTransform(e25, t20, s16, r24) {
    return r6(r24), this._applyObjectRotation(s16, false, r24), this._applyObjectRotation(t20, true, r24), this._applyObjectScale(e25, s16, r24), this._applyAnchor(e25, t20, r24), r24;
  }
  _applyObjectScale(e25, t20, s16) {
    if (this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation)
      return;
    const r24 = this._drivenProperties.size && t20.size ? t20.size : e25.symbolSize, a21 = D3(r24, e25.symbolSize, e25.resourceSize, this._context.renderCoordsHelper.unitInMeters);
    1 === a21[0] && 1 === a21[1] && 1 === a21[2] || i(s16, s16, a21);
  }
  prepareSymbolLayerPatch(e25) {
    if ("partial" !== e25.diff.type)
      return;
    const t20 = e25.diff.diff;
    this._preparePatchTransform(e25, t20), this._preparePatchColor(e25, t20);
  }
  updateGeometry(e25, t20) {
    if (t(this._resources))
      return true;
    const s16 = t20 && d9(t20);
    if (t(s16))
      return false;
    const r24 = this.getGeometryElevationMode(t20);
    return e25.elevationContext.mode === r24 && (this._computeGlobalTransform(s16, e25.elevationContext, fe4, be2), this._requiresTerrainElevation(e25.elevationContext) && (e25.alignedSampledElevation = be2.sampledElevation), this._resources.lodRenderer.instanceData.setGlobalTransform(e25.instanceIndex, fe4, true), g8(e25, s16, this._context.elevationProvider), true);
  }
  _preparePatchTransform(e25, t20) {
    if (!(t20.heading || t20.tilt || t20.roll || t20.width || t20.height || t20.depth || t20.anchor || t20.anchorPosition))
      return;
    if (t(this._resources))
      return;
    const s16 = (e26, t21, s17) => c(null != e26 && "complete" === e26.type ? e26.newValue : t21, s17), r24 = s16(t20.heading, this.symbolLayer.heading, 0), o22 = s16(t20.tilt, this.symbolLayer.tilt, 0), n24 = s16(t20.roll, this.symbolLayer.roll, 0), c21 = s16(t20.width, this.symbolLayer.width, void 0), l26 = s16(t20.height, this.symbolLayer.height, void 0), h18 = s16(t20.depth, this.symbolLayer.depth, void 0), d22 = s16(t20.anchor, this.symbolLayer.anchor, void 0), p21 = s16(t20.anchorPosition, this.symbolLayer.anchorPosition, void 0);
    delete t20.heading, delete t20.tilt, delete t20.roll, delete t20.width, delete t20.height, delete t20.depth, delete t20.anchor, delete t20.anchorPosition;
    const m15 = { heading: r24, tilt: o22, roll: n24, anchor: d22, anchorPosition: p21 }, u16 = this._resources;
    this.loadStatus === e17.LOADED && e25.symbolLayerStatePatches.push(() => {
      u16.symbolSize = e4(t6(u16.resourceSize, { width: c21, height: l26, depth: h18, isPrimitive: this.symbolLayer.isPrimitive }));
    }), e25.graphics3DGraphicPatches.push((e26, t21) => {
      const s17 = this._computeLocalTransform(u16, m15, t21, ye2), r25 = e26.instanceIndex;
      u16.lodRenderer.instanceData.setLocalTransform(r25, s17, true);
    });
  }
  _preparePatchColor(s16, r24) {
    if (!r24.material || "partial" !== r24.material.type)
      return;
    const i17 = r24.material.diff;
    if (!i17.color || "complete" !== i17.color.type || null == i17.color.newValue || null == i17.color.oldValue)
      return;
    const o22 = i17.color.newValue, n24 = r(o22) ? l4.toUnitRGBA(o22) : _2;
    delete i17.color;
    const c21 = this._resources;
    t(c21) || s16.graphics3DGraphicPatches.push((e25) => {
      let t20;
      this._hasPerInstanceColor() ? (c21.lodRenderer.instanceData.setColor(e25.instanceIndex, n24), t20 = this._setMaterialTransparencyParams({}, o22)) : t20 = this._setMaterialTransparencyParams({ externalColor: n24 }, o22);
      for (const s17 of c21.stageResources.materials)
        s17.setParameters(t20);
    });
  }
  _requiresTerrainElevation(e25) {
    return "absolute-height" !== e25.mode;
  }
  _applyObjectRotation(e25, t20, s16) {
    if (!(this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation && t20))
      return S3(e25.heading, e25.tilt, e25.roll, s16);
  }
  _computeAnchor(e25, s16, r24) {
    const a21 = n2();
    switch (r24.anchor) {
      case "center":
        r3(a21, p5(e25)), j(a21, a21);
        break;
      case "top": {
        const t20 = p5(e25);
        o3(a21, -t20[0], -t20[1], -e25[5]);
        break;
      }
      case "bottom": {
        const t20 = p5(e25);
        o3(a21, -t20[0], -t20[1], -e25[2]);
        break;
      }
      case "relative": {
        const t20 = p5(e25), s17 = F2(e25), i17 = r24.anchorPosition, o22 = i17 ? r2(i17.x, i17.y, i17.z) : f2;
        c2(a21, s17, o22), u2(a21, a21, t20), j(a21, a21);
        break;
      }
      default:
        r(s16) ? j(a21, s16) : r3(a21, f2);
    }
    return a21;
  }
  _applyAnchor(e25, t20, s16) {
    if (this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation)
      return;
    const r24 = this._computeAnchor(e25.resourceBoundingBox, e25.pivotOffset, t20);
    r24 && c3(s16, s16, r24);
  }
  _hasPerInstanceColor() {
    return this._drivenProperties.color || this._drivenProperties.opacity;
  }
  _fastVisualVariableConvertOptions(e25, s16, r24, a21) {
    const i17 = r(e25) ? e4(F2(e25)) : l, o22 = r(e25) ? this._computeAnchor(e25, a21, this.symbolLayer) : f2, n24 = this._context.renderCoordsHelper.unitInMeters, c21 = D3(r(s16) ? s16 : void 0, s16, r24, n24), l26 = r2(this.symbolLayer.tilt || 0, this.symbolLayer.roll || 0, this.symbolLayer.heading || 0);
    return { modelSize: i17, symbolSize: r(s16) ? s16 : l, unitInMeters: n24, transformation: { anchor: o22, scale: c21, rotation: l26 } };
  }
};
var ue4 = n2();
var ye2 = e8();
var fe4 = e8();
var _e4 = n4();
var be2 = new j7();

// node_modules/@arcgis/core/chunks/mat2.js
function n21(t20, n24) {
  return t20[0] = n24[0], t20[1] = n24[1], t20[2] = n24[2], t20[3] = n24[3], t20;
}
function a20(t20) {
  return t20[0] = 1, t20[1] = 0, t20[2] = 0, t20[3] = 1, t20;
}
function r21(t20, n24, a21, r24, s16) {
  return t20[0] = n24, t20[1] = a21, t20[2] = r24, t20[3] = s16, t20;
}
function s15(t20, n24) {
  if (t20 === n24) {
    const a21 = n24[1];
    t20[1] = n24[2], t20[2] = a21;
  } else
    t20[0] = n24[0], t20[1] = n24[2], t20[2] = n24[1], t20[3] = n24[3];
  return t20;
}
function u14(t20, n24) {
  const a21 = n24[0], r24 = n24[1], s16 = n24[2], u16 = n24[3];
  let o22 = a21 * u16 - s16 * r24;
  return o22 ? (o22 = 1 / o22, t20[0] = u16 * o22, t20[1] = -r24 * o22, t20[2] = -s16 * o22, t20[3] = a21 * o22, t20) : null;
}
function o20(t20, n24) {
  const a21 = n24[0];
  return t20[0] = n24[3], t20[1] = -n24[1], t20[2] = -n24[2], t20[3] = a21, t20;
}
function e20(t20) {
  return t20[0] * t20[3] - t20[2] * t20[1];
}
function c19(t20, n24, a21) {
  const r24 = n24[0], s16 = n24[1], u16 = n24[2], o22 = n24[3], e25 = a21[0], c21 = a21[1], i17 = a21[2], f22 = a21[3];
  return t20[0] = r24 * e25 + u16 * c21, t20[1] = s16 * e25 + o22 * c21, t20[2] = r24 * i17 + u16 * f22, t20[3] = s16 * i17 + o22 * f22, t20;
}
function i15(t20, n24, a21) {
  const r24 = n24[0], s16 = n24[1], u16 = n24[2], o22 = n24[3], e25 = Math.sin(a21), c21 = Math.cos(a21);
  return t20[0] = r24 * c21 + u16 * e25, t20[1] = s16 * c21 + o22 * e25, t20[2] = r24 * -e25 + u16 * c21, t20[3] = s16 * -e25 + o22 * c21, t20;
}
function f19(t20, n24, a21) {
  const r24 = n24[0], s16 = n24[1], u16 = n24[2], o22 = n24[3], e25 = a21[0], c21 = a21[1];
  return t20[0] = r24 * e25, t20[1] = s16 * e25, t20[2] = u16 * c21, t20[3] = o22 * c21, t20;
}
function l24(t20, n24) {
  const a21 = Math.sin(n24), r24 = Math.cos(n24);
  return t20[0] = r24, t20[1] = a21, t20[2] = -a21, t20[3] = r24, t20;
}
function h17(t20, n24) {
  return t20[0] = n24[0], t20[1] = 0, t20[2] = 0, t20[3] = n24[1], t20;
}
function M9(t20) {
  return "mat2(" + t20[0] + ", " + t20[1] + ", " + t20[2] + ", " + t20[3] + ")";
}
function b12(t20) {
  return Math.sqrt(t20[0] ** 2 + t20[1] ** 2 + t20[2] ** 2 + t20[3] ** 2);
}
function m14(t20, n24, a21, r24) {
  return t20[2] = r24[2] / r24[0], a21[0] = r24[0], a21[1] = r24[1], a21[3] = r24[3] - t20[2] * a21[1], [t20, n24, a21];
}
function d17(t20, n24, a21) {
  return t20[0] = n24[0] + a21[0], t20[1] = n24[1] + a21[1], t20[2] = n24[2] + a21[2], t20[3] = n24[3] + a21[3], t20;
}
function p18(t20, n24, a21) {
  return t20[0] = n24[0] - a21[0], t20[1] = n24[1] - a21[1], t20[2] = n24[2] - a21[2], t20[3] = n24[3] - a21[3], t20;
}
function y5(t20, n24) {
  return t20[0] === n24[0] && t20[1] === n24[1] && t20[2] === n24[2] && t20[3] === n24[3];
}
function x11(n24, a21) {
  const r24 = n24[0], s16 = n24[1], u16 = n24[2], o22 = n24[3], e25 = a21[0], c21 = a21[1], i17 = a21[2], f22 = a21[3];
  return Math.abs(r24 - e25) <= t2 * Math.max(1, Math.abs(r24), Math.abs(e25)) && Math.abs(s16 - c21) <= t2 * Math.max(1, Math.abs(s16), Math.abs(c21)) && Math.abs(u16 - i17) <= t2 * Math.max(1, Math.abs(u16), Math.abs(i17)) && Math.abs(o22 - f22) <= t2 * Math.max(1, Math.abs(o22), Math.abs(f22));
}
function j10(t20, n24, a21) {
  return t20[0] = n24[0] * a21, t20[1] = n24[1] * a21, t20[2] = n24[2] * a21, t20[3] = n24[3] * a21, t20;
}
function S11(t20, n24, a21, r24) {
  return t20[0] = n24[0] + a21[0] * r24, t20[1] = n24[1] + a21[1] * r24, t20[2] = n24[2] + a21[2] * r24, t20[3] = n24[3] + a21[3] * r24, t20;
}
var g15 = c19;
var q10 = p18;
var _11 = Object.freeze(Object.defineProperty({ __proto__: null, copy: n21, identity: a20, set: r21, transpose: s15, invert: u14, adjoint: o20, determinant: e20, multiply: c19, rotate: i15, scale: f19, fromRotation: l24, fromScaling: h17, str: M9, frob: b12, LDU: m14, add: d17, subtract: p18, exactEquals: y5, equals: x11, multiplyScalar: j10, multiplyScalarAndAdd: S11, mul: g15, sub: q10 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/PathGeometry.js
var e21 = class extends g4 {
  constructor(t20, e25, r24, i17, n24, s16) {
    super(t20, e25), this.path = r24, this.geometrySR = i17, this.upVectorAlignment = n24, this.stencilWidth = s16;
  }
};
function r22(t20) {
  return "upVectorAlignment" in t20;
}

// node_modules/@arcgis/core/chunks/mat2f64.js
function e22() {
  return [1, 0, 0, 1];
}
function r23(e25) {
  return [e25[0], e25[1], e25[2], e25[3]];
}
function t19(e25, r24, t20, n24) {
  return [e25, r24, t20, n24];
}
function n22(e25, r24) {
  return new Float64Array(e25, r24, 4);
}
var o21 = Object.freeze(Object.defineProperty({ __proto__: null, create: e22, clone: r23, fromValues: t19, createView: n22 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/pathGeometryUtils.js
function k4() {
  return { up: n2(), right: n2() };
}
function E15(t20, e25, i17) {
  L(t20.up, e25.up, i17), L(t20.right, e25.right, i17);
}
function w8(t20, e25, i17) {
  r7(t20, P(i17, e25.right), P(i17, e25.up));
}
var G4 = class {
  constructor() {
    this.pos = n2(), this.posES = n2(), this.posGS = n2(), this.vRight = n2(), this.vLeft = n2(), this.frame = k4(), this.rotationFrame = k4(), this.rotationRight = n8(), this.rotationAngle = 0, this.miterStretch = e22();
  }
  setFrameFromUpVector(t20) {
    r3(this.frame.up, t20), u2(at, this.vLeft, this.vRight), z2(at, at), q(nt2, this.frame.up, P(at, this.frame.up)), e5(pt, at, nt2), z2(pt, pt), _(this.frame.right, pt, this.frame.up);
  }
  computeRotationAxisAndAngleFromUpVector() {
    r3(this.rotationFrame.up, this.frame.up), r3(this.rotationFrame.right, this.frame.right), r7(this.rotationRight, 1, 0), q(nt2, this.frame.up, P(this.frame.up, this.vLeft)), e5(nt2, this.vLeft, nt2), j(nt2, nt2), z2(nt2, nt2), q(at, this.frame.up, P(this.frame.up, this.vRight)), e5(at, this.vRight, at), z2(at, at), _(lt, this.rotationFrame.up, this.vLeft);
    const s16 = Math.sign(P(lt, this.vRight));
    if (this.rotationAngle = s16 * (Math.PI - l3(P(nt2, at))), Math.abs(this.rotationAngle) > 0) {
      const t20 = N(Math.cos(0.5 * this.rotationAngle));
      r21(this.miterStretch, t20 - 1 + 1, 0, 0, 1);
    }
    const r24 = Math.PI - this.rotationAngle;
    this.maxStretchDistance = Math.abs(Math.min(this.vLeftLength, this.vRightLength) / Math.cos(0.5 * r24));
  }
};
var j11 = class {
  constructor() {
    this.vertices = [], this.vertexIndices = [], this.vertexNormals = [], this.poles = [], this.poleIndices = [], this.uvs = null, this.uvIndices = null;
  }
  addVertex(t20, e25) {
    return this.vertices.push(t7(t20)), this.vertexNormals.push(t7(e25)), this.vertices.length - 1;
  }
  addUV(t20) {
    return this.uvs || (this.uvs = [], this.uvIndices = []), this.uvs.push(t20), this.uvs.length - 1;
  }
  addPole(t20, e25 = null) {
    return this.poles.push({ position: t7(t20), normal: e25 ? t7(e25) : null }), this.poles.length - 1;
  }
  addSegment(t20, e25 = null, i17 = null) {
    this.vertexIndices.push(t20.v0), this.vertexIndices.push(t20.v1), e25 && (this.uvIndices.push(e25.v0), this.uvIndices.push(e25.v1)), i17 && (this.poleIndices.push(i17.v0), this.poleIndices.push(i17.v1));
  }
  get numSegments() {
    return this.vertexIndices.length / 2;
  }
  hasUV() {
    return null != this.uvs;
  }
  translate(t20, e25) {
    for (const i17 of this.vertices)
      i17[0] += t20, i17[1] += e25;
    for (const i17 of this.poles)
      i17.position[0] += t20, i17.position[1] += e25;
  }
  static circle(t20 = 20) {
    const e25 = 0.5, i17 = new j11(), s16 = { v0: 0, v1: 0 };
    i17.addPole(r11(0, 0));
    for (let h18 = 0; h18 < t20; ++h18) {
      const s17 = 2 * h18 * Math.PI / t20, r25 = Math.cos(s17), o23 = Math.sin(s17), n24 = r11(r25 * e25, o23 * e25), a21 = r11(r25, o23);
      i17.addVertex(n24, a21), i17.addUV(h18 / t20);
    }
    i17.addUV(1);
    for (let h18 = 0; h18 < t20 - 1; ++h18) {
      const t21 = { v0: h18, v1: h18 + 1 }, e26 = t21;
      i17.addSegment(t21, e26, s16);
    }
    const r24 = { v0: t20 - 1, v1: 0 }, o22 = { v0: t20 - 1, v1: t20 };
    return i17.addSegment(r24, o22, s16), i17;
  }
  static rect() {
    const t20 = 1, e25 = 1, i17 = new j11(), s16 = r11(0.5 * -t20, 0.5 * -e25), r24 = r11(0.5 * t20, 0.5 * -e25), o22 = r11(0.5 * t20, 0.5 * e25), h18 = r11(0.5 * -t20, 0.5 * e25), n24 = r11(0, -1), a21 = r11(1, 0), l26 = r11(0, 1), u16 = r11(-1, 0);
    i17.addUV(0), i17.addUV(1), i17.addPole(r11(0, 0.5 * e25), l26), i17.addPole(r11(0, 0.5 * e25)), i17.addPole(r11(0, 0.5 * -e25)), i17.addPole(r11(0, 0.5 * -e25), n24);
    const p21 = { v0: 0, v1: 1 };
    return i17.addVertex(s16, n24), i17.addVertex(r24, n24), i17.addSegment({ v0: 0, v1: 1 }, p21, { v0: 3, v1: 3 }), i17.addVertex(r24, a21), i17.addVertex(o22, a21), i17.addSegment({ v0: 2, v1: 3 }, p21, { v0: 2, v1: 1 }), i17.addVertex(o22, l26), i17.addVertex(h18, l26), i17.addSegment({ v0: 4, v1: 5 }, p21, { v0: 0, v1: 0 }), i17.addVertex(h18, u16), i17.addVertex(s16, u16), i17.addSegment({ v0: 6, v1: 7 }, p21, { v0: 1, v1: 2 }), i17;
  }
};
var z4 = class {
  constructor(t20) {
    this.vertices = [], this.offset = n2(), this.xform = e8(), this.vertices = t20;
    const e25 = Math.floor((t20.length - 1) / 2);
    r3(this.offset, this.vertices[e25].pos);
    for (const i17 of this.vertices)
      e5(i17.pos, i17.pos, this.offset);
    c3(this.xform, this.xform, this.offset), this.updatePathVertexInformation();
  }
  updatePathVertexInformation() {
    const t20 = this.vertices.length;
    let e25 = this.vertices[0];
    e25.index = 0, o3(e25.vLeft, 0, 0, 0), e25.vLeftLength = 0, e5(e25.vRight, this.vertices[1].pos, e25.pos), e25.vRightLength = s3(e25.vRight), z2(e25.vRight, e25.vRight);
    let i17 = e25;
    for (let s16 = 1; s16 < t20; ++s16)
      e25 = this.vertices[s16], e25.index = s16, r3(e25.vLeft, i17.vRight), e25.vLeftLength = i17.vRightLength, s16 < t20 - 1 ? (e5(e25.vRight, this.vertices[s16 + 1].pos, e25.pos), e25.vRightLength = s3(e25.vRight), z2(e25.vRight, e25.vRight)) : (r3(e25.vRight, e25.vLeft), e25.vRightLength = e25.vLeftLength), i17 = e25;
  }
};
function J6(t20, e25) {
  let i17 = null;
  const s16 = t20.vertices.length, r24 = 0.99619469809, o22 = n2(), h18 = n2(), n24 = n2(), a21 = n2(), l26 = n2(), u16 = n2(), p21 = p9();
  let f22 = t20.vertices[0];
  r3(h18, e25), o3(o22, 0, 1, 0), T3.makeOrthoBasisDirUpFallback(f22.vRight, h18, o22, o22, n24, h18, r24), r3(f22.frame.up, h18), r3(f22.frame.right, n24), i17 = f22;
  for (let c21 = 1; c21 < s16; ++c21) {
    f22 = t20.vertices[c21], u2(l26, f22.vLeft, f22.vRight);
    let e26 = s3(l26);
    e26 > 0 ? (e26 = 1 / Math.sqrt(e26), l26[0] = l26[0] * e26, l26[1] = l26[1] * e26, l26[2] = l26[2] * e26) : (l26[0] = f22.vRight[0], l26[1] = f22.vRight[1], l26[2] = f22.vRight[2]), u2(u16, i17.pos, i17.frame.up), _7(f22.pos, l26, p21);
    q4(p21, j6(u16, f22.vLeft), a21) ? (e5(a21, a21, f22.pos), z2(h18, a21), _(n24, l26, h18), z2(n24, n24)) : T3.makeOrthoBasisDirUpFallback(l26, i17.frame.up, i17.frame.right, o22, n24, h18, r24), r3(f22.frame.up, h18), r3(f22.frame.right, n24), i17 = f22;
  }
}
var X2 = class {
  numProfilesPerJoin() {
    return 1;
  }
  extrude(t20, e25, i17) {
    for (let s16 = 0; s16 < e25.vertices.length; ++s16)
      i17(t20.index, t20.frame, e25.vertices[s16], e25.vertexNormals[s16], false);
  }
};
var q11 = class {
  constructor(t20 = 0.8 * Math.PI, e25 = 1) {
    this.cutoffAngle = t20, this.numBendSubdivisions = e25;
  }
  numProfilesPerJoin() {
    return this.numBendSubdivisions + 1;
  }
  extrude(t20, e25, i17) {
    const s16 = ft;
    if (Math.abs(t20.rotationAngle) >= this.cutoffAngle)
      for (let r24 = 0; r24 < this.numBendSubdivisions + 1; ++r24) {
        p4(ct, 0.5 * -t20.rotationAngle + r24 * t20.rotationAngle / this.numBendSubdivisions, t20.rotationFrame.up), E15(s16, t20.frame, ct);
        for (let r25 = 0; r25 < e25.vertices.length; ++r25) {
          j2(e25.vertices[r25], t20.rotationRight) * t20.rotationAngle >= 0 ? i17(t20.index, s16, e25.vertices[r25], e25.vertexNormals[r25], false) : (_3(rt, e25.vertices[r25], t20.miterStretch), i17(t20.index, t20.frame, rt, e25.vertexNormals[r25], true));
        }
      }
    else
      for (let r24 = 0; r24 < this.numBendSubdivisions + 1; ++r24)
        for (let s17 = 0; s17 < e25.vertices.length; ++s17) {
          const r25 = j2(e25.vertices[s17], t20.rotationRight) * t20.rotationAngle >= 0;
          _3(rt, e25.vertices[s17], t20.miterStretch), i17(t20.index, t20.frame, rt, e25.vertexNormals[s17], !r25);
        }
  }
};
var K4 = { generateUV: false };
var Q2 = class {
  rebuildConnectingProfileGeometry(t20, e25, i17) {
    for (let s16 = 0; s16 < e25.vertices.length; ++s16)
      i17(t20.index, t20.frame, e25.vertices[s16], e25.vertexNormals[s16], 0, 0);
  }
};
var W3 = class extends Q2 {
  constructor() {
    super();
  }
  getNumVertices() {
    return 0;
  }
  getNumIndices() {
    return 0;
  }
  rebuildCapGeometry() {
  }
  buildTopology() {
  }
};
var Y = class extends Q2 {
  constructor(t20, e25 = 0, i17 = false) {
    super(), this.profile = t20, this.profilePlaneOffset = e25, this.flip = i17;
  }
  getNumVertices() {
    return this.profile.vertices.length;
  }
  getNumIndices() {
    return 3 * this.profile.numSegments;
  }
  rebuildConnectingProfileGeometry(t20, e25, i17) {
    for (let s16 = 0; s16 < e25.vertices.length; ++s16)
      i17(t20.index, t20.frame, e25.vertices[s16], e25.vertexNormals[s16], this.profilePlaneOffset, 0);
  }
  rebuildCapGeometry(t20, e25) {
    const i17 = ot;
    r7(i17, 0, 0);
    const s16 = this.flip ? 1 : -1;
    for (let r24 = 0; r24 < this.profile.vertices.length; ++r24)
      e25(t20.index, t20.frame, this.profile.vertices[r24], i17, this.profilePlaneOffset, s16);
  }
  buildTopology(t20, e25) {
    const i17 = this.vertexBufferStart + this.profile.vertexIndices[0];
    for (let s16 = 1; s16 < this.profile.numSegments; ++s16) {
      const t21 = this.profile.vertexIndices[2 * s16 + 0], r24 = this.profile.vertexIndices[2 * s16 + 1], o22 = this.vertexBufferStart + t21, h18 = this.vertexBufferStart + r24;
      this.flip ? e25(h18, o22, i17) : e25(i17, o22, h18);
    }
  }
};
var Z2 = class extends Q2 {
  constructor(t20) {
    super(), this.flip = false, this.sign = 0, this.breakNormals = false, this.numSegments = 3, this.profile = t20.profile, this.flip = t20.flip, this.sign = this.flip ? 1 : -1, this.breakNormals = t20.breakNormals, this.numSegments = t20.subdivisions;
  }
  getNumVertices() {
    let t20 = 0;
    return t20 = this.profile.vertices.length * (this.numSegments - 1), this.breakNormals && (t20 += this.profile.vertices.length), t20 += this.profile.poles.length, t20;
  }
  getNumIndices() {
    let t20 = 0;
    t20 += 2 * this.profile.numSegments * (this.numSegments - 1);
    for (let e25 = 0; e25 < this.profile.numSegments; ++e25) {
      const i17 = this.profile.vertexIndices[2 * e25 + 0], s16 = this.profile.vertexIndices[2 * e25 + 1];
      this.profile.poleIndices[i17] === this.profile.poleIndices[s16] ? t20 += 1 : t20 += 2;
    }
    return 3 * t20;
  }
  rebuildCapGeometry(t20, e25) {
    const i17 = t20.frame, s16 = 0.5 * this.sign, r24 = rt, o22 = ot;
    r7(o22, 0, 0);
    for (let h18 = 0; h18 < this.profile.poles.length; ++h18) {
      const r25 = this.profile.poles[h18];
      r25.normal ? e25(t20.index, i17, r25.position, r25.normal, s16, 0) : e25(t20.index, i17, r25.position, o22, s16, this.sign);
    }
    if (this.breakNormals)
      for (let h18 = 0; h18 < this.profile.vertices.length; ++h18)
        e25(t20.index, i17, this.profile.vertices[h18], this.profile.vertexNormals[h18], 0, 0);
    for (let h18 = 0; h18 < this.numSegments - 1; ++h18) {
      const n24 = (1 - (h18 + 1) / this.numSegments) * Math.PI * 0.5, a21 = Math.sin(n24), l26 = Math.cos(n24);
      for (let h19 = 0; h19 < this.profile.vertices.length; ++h19) {
        const n25 = this.profile.poles[this.profile.poleIndices[h19]];
        o5(r24, this.profile.vertices[h19], n25.position), l8(r24, r24, a21), n25.normal ? (s5(r24, r24, n25.position), e25(t20.index, i17, r24, n25.normal, s16 * l26, 0)) : (v3(o22, r24), l8(o22, o22, a21), s5(r24, r24, n25.position), e25(t20.index, i17, r24, o22, s16 * l26, this.sign * l26));
      }
    }
  }
  buildTopology(t20, e25) {
    const i17 = this.breakNormals ? this.vertexBufferStart + this.profile.poles.length : this.firstProfileVertexIndex, s16 = this.breakNormals ? this.vertexBufferStart + this.profile.poles.length + this.profile.vertices.length : this.vertexBufferStart + this.profile.poles.length;
    for (let r24 = 0; r24 < this.profile.numSegments; ++r24) {
      const t21 = this.profile.vertexIndices[2 * r24 + 0], o22 = this.profile.vertexIndices[2 * r24 + 1], h18 = this.vertexBufferStart + this.profile.poleIndices[t21], n24 = this.vertexBufferStart + this.profile.poleIndices[o22];
      let a21 = i17 + t21, l26 = i17 + o22;
      for (let i18 = 0; i18 < this.numSegments - 1; ++i18) {
        const r25 = s16 + i18 * this.profile.vertices.length + t21, h19 = s16 + i18 * this.profile.vertices.length + o22;
        this.flip ? (e25(r25, l26, a21), e25(l26, r25, h19)) : (e25(a21, l26, r25), e25(h19, r25, l26)), a21 = r25, l26 = h19;
      }
      this.flip ? (e25(h18, l26, a21), h18 !== n24 && e25(h18, n24, l26)) : (e25(a21, l26, h18), h18 !== n24 && e25(l26, n24, h18));
    }
  }
};
var $3 = class {
  constructor(t20, e25, i17, s16, r24, o22 = K4) {
    this.options = o22, this._extrusionVertexCount = 0, this._triangleCount = 0, this.numExtrusionProfiles = 0, this.numVerticesTotal = 0, this.numNormalsTotal = 0, this.numUVTotal = 0, this.profile = e25, this.path = t20, this.extruder = i17, this.startCap = s16, this.endCap = r24;
    const h18 = this.path.vertices.length - 2;
    this.numExtrusionProfiles = i17.numProfilesPerJoin() * h18 + 2, this.numVerticesTotal = e25.vertices.length * this.numExtrusionProfiles, this.numNormalsTotal = this.numVerticesTotal, this.startCap.vertexBufferStart = this.numVerticesTotal;
    const n24 = this.startCap.getNumVertices();
    this.numVerticesTotal += n24, this.numNormalsTotal += n24, this.endCap.vertexBufferStart = this.numVerticesTotal;
    const a21 = this.endCap.getNumVertices();
    this.numVerticesTotal += a21, this.numNormalsTotal += a21, this.pathVertexData = new Float32Array(1 * this.numVerticesTotal), this.profileRightAxisData = new Float32Array(4 * this.numVerticesTotal), this.profileUpAxisData = new Float32Array(4 * this.numVerticesTotal), this.profileVertexAndNormalData = new Float32Array(4 * this.numVerticesTotal), this.profile.hasUV() && this.options.generateUV && (this.numUVTotal = this.profile.uvs.length, this.uvData = new Float32Array(2 * this.numUVTotal)), this.originData = new Float32Array(3 * this.path.vertices.length), this._rebuildGeometry(), this.buildTopology();
  }
  emitVertex(t20, e25, i17, s16, r24) {
    if (this.profileRightAxisData[4 * this._extrusionVertexCount + 0] = e25.right[0], this.profileRightAxisData[4 * this._extrusionVertexCount + 1] = e25.right[1], this.profileRightAxisData[4 * this._extrusionVertexCount + 2] = e25.right[2], this.profileUpAxisData[4 * this._extrusionVertexCount + 0] = e25.up[0], this.profileUpAxisData[4 * this._extrusionVertexCount + 1] = e25.up[1], this.profileUpAxisData[4 * this._extrusionVertexCount + 2] = e25.up[2], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 0] = i17[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 1] = i17[1], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 2] = s16[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 3] = s16[1], this.pathVertexData[this._extrusionVertexCount] = t20, r24) {
      const e26 = this.path.vertices[t20];
      this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = e26.rotationRight[0] * e26.maxStretchDistance, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = e26.rotationRight[1] * e26.maxStretchDistance;
    } else
      this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = 0, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = 0;
    ++this._extrusionVertexCount;
  }
  emitCapVertex(t20, e25, i17, s16, r24, o22) {
    this.profileRightAxisData[4 * this._extrusionVertexCount + 0] = e25.right[0], this.profileRightAxisData[4 * this._extrusionVertexCount + 1] = e25.right[1], this.profileRightAxisData[4 * this._extrusionVertexCount + 2] = e25.right[2], this.profileUpAxisData[4 * this._extrusionVertexCount + 0] = e25.up[0], this.profileUpAxisData[4 * this._extrusionVertexCount + 1] = e25.up[1], this.profileUpAxisData[4 * this._extrusionVertexCount + 2] = e25.up[2], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 0] = i17[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 1] = i17[1], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 2] = s16[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 3] = s16[1], this.pathVertexData[this._extrusionVertexCount] = t20, this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = r24, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = o22, ++this._extrusionVertexCount;
  }
  emitTriangle(t20, e25, i17) {
    this.vertexIndices[3 * this._triangleCount + 0] = t20, this.vertexIndices[3 * this._triangleCount + 1] = e25, this.vertexIndices[3 * this._triangleCount + 2] = i17, this.pathVertexIndices[3 * this._triangleCount + 0] = this.pathVertexData[t20], this.pathVertexIndices[3 * this._triangleCount + 1] = this.pathVertexData[e25], this.pathVertexIndices[3 * this._triangleCount + 2] = this.pathVertexData[i17], this.normalIndices[3 * this._triangleCount + 0] = t20, this.normalIndices[3 * this._triangleCount + 1] = e25, this.normalIndices[3 * this._triangleCount + 2] = i17, ++this._triangleCount;
  }
  _rebuildGeometry() {
    const t20 = (t21, e26, i17, s16, r24) => this.emitVertex(t21, e26, i17, s16, r24), e25 = (t21, e26, i17, s16, r24, o22) => this.emitCapVertex(t21, e26, i17, s16, r24, o22);
    this._extrusionVertexCount = 0;
    for (const i17 of this.path.vertices)
      this.originData[3 * i17.index + 0] = i17.pos[0], this.originData[3 * i17.index + 1] = i17.pos[1], this.originData[3 * i17.index + 2] = i17.pos[2];
    this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0], this.profile, e25);
    for (let i17 = 1; i17 < this.path.vertices.length - 1; ++i17)
      this.extruder.extrude(this.path.vertices[i17], this.profile, t20);
    if (this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length - 1], this.profile, e25), this.startCap.rebuildCapGeometry(this.path.vertices[0], e25), this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length - 1], e25), this.profile.hasUV() && this.options.generateUV)
      for (let i17 = 0; i17 < this.profile.uvs.length; ++i17)
        this.uvData[2 * i17 + 0] = this.profile.uvs[i17], this.uvData[2 * i17 + 1] = 0;
  }
  buildTopology() {
    const t20 = (t21, e26, i18) => this.emitTriangle(t21, e26, i18);
    this._triangleCount = 0;
    const e25 = this.profile.vertices.length, i17 = this.profile.numSegments, s16 = this.numExtrusionProfiles - 1;
    let r24 = 3 * (2 * (i17 * s16));
    this.startCap.indexBufferStart = r24, this.startCap.firstProfileVertexIndex = 0, r24 += this.startCap.getNumIndices(), this.endCap.indexBufferStart = r24, this.endCap.firstProfileVertexIndex = e25 * (this.numExtrusionProfiles - 1), r24 += this.endCap.getNumIndices(), this.vertexIndices = new Uint32Array(r24), this.normalIndices = new Uint32Array(r24), this.pathVertexIndices = new Uint32Array(r24), this.profile.hasUV() && this.options.generateUV && (this.uvIndices = new Uint32Array(r24));
    for (let o22 = 0; o22 < i17; ++o22) {
      const i18 = this.profile.vertexIndices[2 * o22], r25 = this.profile.vertexIndices[2 * o22 + 1];
      for (let o23 = 0; o23 < s16; ++o23) {
        const s17 = o23 * e25 + i18, h18 = (o23 + 1) * e25 + r25, n24 = o23 * e25 + r25;
        t20(s17, (o23 + 1) * e25 + i18, h18), t20(s17, h18, n24);
      }
    }
    this.startCap.buildTopology(this.path.vertices[0], t20), this.endCap.buildTopology(this.path.vertices[this.path.vertices.length - 1], t20);
  }
  onPathChanged() {
    this._rebuildGeometry();
  }
};
var tt = class {
  constructor(t20) {
    this.builder = t20;
  }
  get xform() {
    return this.builder.path.xform;
  }
  onPathChanged() {
    this.builder.onPathChanged();
  }
};
var et = class extends tt {
  constructor(t20) {
    super(t20), this.vertexAttributePosition = null, this.vertexAttributeNormal = null, this.vertexAttributeColor = null, this.vertexAttributePosition = new Float32Array(3 * this.builder.numVerticesTotal), this.vertexAttributeNormal = new Float32Array(3 * this.builder.numNormalsTotal), this.vertexAttributeColor = new Uint8Array(4), this.vertexAttributeColor[0] = 255, this.vertexAttributeColor[1] = 255, this.vertexAttributeColor[2] = 255, this.vertexAttributeColor[3] = 255;
  }
  bakeVertexColors(t20) {
    this.vertexAttributeColor[0] = 255 * t20[0], this.vertexAttributeColor[1] = 255 * t20[1], this.vertexAttributeColor[2] = 255 * t20[2], this.vertexAttributeColor[3] = 255 * (t20.length > 3 ? t20[3] : 1);
  }
  bake(t20) {
    this.size = t20;
    for (let e25 = 0; e25 < this.builder.numVerticesTotal; ++e25) {
      let i17 = this.builder.pathVertexData[e25];
      const s16 = 0 === i17 || i17 === this.builder.path.vertices.length - 1;
      i17 *= 3;
      const r24 = st;
      o3(r24, this.builder.originData[i17++], this.builder.originData[i17++], this.builder.originData[i17]);
      const o22 = 4 * e25, h18 = nt2, l26 = rt, u16 = at, d22 = lt, v17 = ut;
      let m15 = 0, g17 = 0;
      if (o3(d22, this.builder.profileRightAxisData[o22], this.builder.profileRightAxisData[o22 + 1], this.builder.profileRightAxisData[o22 + 2]), o3(v17, this.builder.profileUpAxisData[o22], this.builder.profileUpAxisData[o22 + 1], this.builder.profileUpAxisData[o22 + 2]), r7(l26, this.builder.profileVertexAndNormalData[o22] * t20[0], this.builder.profileVertexAndNormalData[o22 + 1] * t20[1]), s16)
        _(u16, v17, d22), m15 = this.builder.profileRightAxisData[o22 + 3] * t20[0], g17 = this.builder.profileUpAxisData[o22 + 3];
      else {
        const t21 = ot, e26 = ht;
        r7(t21, this.builder.profileRightAxisData[o22 + 3], this.builder.profileUpAxisData[o22 + 3]);
        const i18 = q3(t21);
        v3(t21, t21);
        const s17 = j2(l26, t21);
        if (Math.abs(s17) > i18) {
          r7(e26, -t21[1], t21[0]);
          const r25 = j2(l26, e26);
          l8(t21, t21, i18 * Math.sign(s17)), l8(e26, e26, r25), s5(l26, t21, e26);
        }
        o3(u16, 0, 0, 0);
      }
      o3(h18, d22[0] * l26[0] + v17[0] * l26[1], d22[1] * l26[0] + v17[1] * l26[1], d22[2] * l26[0] + v17[2] * l26[1]), this.vertexAttributePosition[3 * e25 + 0] = r24[0] + h18[0] + u16[0] * m15, this.vertexAttributePosition[3 * e25 + 1] = r24[1] + h18[1] + u16[1] * m15, this.vertexAttributePosition[3 * e25 + 2] = r24[2] + h18[2] + u16[2] * m15;
      const V8 = rt;
      r7(V8, this.builder.profileVertexAndNormalData[o22 + 2], this.builder.profileVertexAndNormalData[o22 + 3]), this.vertexAttributeNormal[3 * e25 + 0] = d22[0] * V8[0] + v17[0] * V8[1] + u16[0] * g17, this.vertexAttributeNormal[3 * e25 + 1] = d22[1] * V8[0] + v17[1] * V8[1] + u16[1] * g17, this.vertexAttributeNormal[3 * e25 + 2] = d22[2] * V8[0] + v17[2] * V8[1] + u16[2] * g17;
    }
  }
  createGeometryData() {
    const t20 = [[O.POSITION, this.builder.vertexIndices], [O.NORMAL, this.builder.normalIndices]], e25 = [[O.POSITION, { size: 3, data: this.vertexAttributePosition, exclusive: true }], [O.NORMAL, { size: 3, data: this.vertexAttributeNormal, exclusive: true }]];
    if (this.vertexAttributeColor) {
      const i17 = this.builder.vertexIndices.length;
      t20.push([O.COLOR, new Uint32Array(i17)]), e25.push([O.COLOR, { size: 4, data: this.vertexAttributeColor }]);
    }
    return { vertexAttributes: e25, indices: t20 };
  }
  onPathChanged() {
    super.onPathChanged(), this.bake(this.size);
  }
  intersect(t20, e25, i17) {
    const s16 = this.builder.vertexIndices, r24 = { size: 3, data: this.vertexAttributePosition }, o22 = s16.length / 3;
    v6(t20, e25, 0, o22, s16, r24, void 0, void 0, i17);
  }
};
var it = class extends tt {
  constructor(t20, e25, i17, s16) {
    super(t20), this.sizeAttributeValue = e25, this.colorAttributeValue = i17, this.opacityAttributeValue = s16, this.vvData = null, this.baked = new et(t20), this.vvData = new Float32Array(4 * this.builder.path.vertices.length);
    for (let r24 = 0; r24 < this.builder.path.vertices.length; ++r24) {
      this.vvData[4 * r24 + 0] = e25, this.vvData[4 * r24 + 1] = i17, this.vvData[4 * r24 + 2] = s16;
      const t21 = 0 === r24 || r24 === this.builder.path.vertices.length - 1;
      this.vvData[4 * r24 + 3] = t21 ? 1 : 0;
    }
  }
  createGeometryData() {
    return { vertexAttributes: [[O.POSITION, { size: 3, data: this.builder.originData, exclusive: true }], [O.PROFILERIGHT, { size: 4, data: this.builder.profileRightAxisData, exclusive: true }], [O.PROFILEUP, { size: 4, data: this.builder.profileUpAxisData, exclusive: true }], [O.PROFILEVERTEXANDNORMAL, { size: 4, data: this.builder.profileVertexAndNormalData, exclusive: true }], [O.FEATUREVALUE, { size: 4, data: this.vvData, exclusive: true }]], indices: [[O.POSITION, this.builder.pathVertexIndices], [O.PROFILERIGHT, this.builder.vertexIndices], [O.PROFILEUP, this.builder.vertexIndices], [O.PROFILEVERTEXANDNORMAL, this.builder.vertexIndices], [O.FEATUREVALUE, this.builder.pathVertexIndices]] };
  }
};
var st = n2();
var rt = n8();
var ot = n8();
var ht = n8();
var nt2 = n2();
var at = n2();
var lt = n2();
var ut = n2();
var pt = n2();
var ft = k4();
var ct = e8();

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PathTechnique.js
var R9 = /* @__PURE__ */ new Map([[O.POSITION, 0], [O.PROFILERIGHT, 1], [O.PROFILEUP, 2], [O.PROFILEVERTEXANDNORMAL, 3], [O.FEATUREVALUE, 4]]);
var C9 = class extends p12 {
  constructor() {
    super(...arguments), this.ambient = r2(0.2, 0.2, 0.2), this.diffuse = r2(0.8, 0.8, 0.8), this.specular = r2(0, 0, 0), this.opacity = 1;
  }
};
var E16 = class extends e11 {
  initializeConfiguration(e25, o22) {
    o22.spherical = e25.viewingMode === l13.Global, o22.doublePrecisionRequiresObfuscation = r12(e25.rctx);
  }
  initializeProgram(e25) {
    const o22 = E16.shader.get().build(this.configuration);
    return new o13(e25.rctx, o22, R9);
  }
  _setPipelineState(e25) {
    const o22 = this.configuration, t20 = e25 === O2.NONE, r24 = e25 === O2.FrontFace, n24 = (e26) => !e26.hasSlicePlane && !(e26.transparent || e26.doubleSidedMode === i4.None);
    return W({ blending: o22.output !== o10.Color && o22.output !== o10.Alpha || !o22.transparent ? null : t20 ? c12 : E5(e25), culling: n24(o22) && o12, depthTest: { func: l16(e25) }, depthWrite: t20 || r24 ? a7 : null, colorWrite: c11, stencilWrite: o22.hasOccludees ? e12 : null, stencilTest: o22.hasOccludees ? f8 : null, polygonOffset: t20 || r24 ? null : f7 });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
E16.shader = new t9(M4, () => import("./Path.glsl-MUZXOA6Y.js"));
var L7 = class extends i7 {
  constructor() {
    super(...arguments), this.output = o10.Color, this.doubleSidedMode = i4.None, this.transparencyPassType = O2.NONE, this.spherical = false, this.receiveShadows = false, this.receiveAmbientOcclusion = false, this.vvSize = false, this.vvColor = false, this.vvOpacity = false, this.hasSlicePlane = false, this.transparent = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.cullAboveGround = false, this.doublePrecisionRequiresObfuscation = false;
  }
};
e([e13({ count: o10.COUNT })], L7.prototype, "output", void 0), e([e13({ count: i4.COUNT })], L7.prototype, "doubleSidedMode", void 0), e([e13({ count: O2.COUNT })], L7.prototype, "transparencyPassType", void 0), e([e13()], L7.prototype, "spherical", void 0), e([e13()], L7.prototype, "receiveShadows", void 0), e([e13()], L7.prototype, "receiveAmbientOcclusion", void 0), e([e13()], L7.prototype, "vvSize", void 0), e([e13()], L7.prototype, "vvColor", void 0), e([e13()], L7.prototype, "vvOpacity", void 0), e([e13()], L7.prototype, "hasSlicePlane", void 0), e([e13()], L7.prototype, "transparent", void 0), e([e13()], L7.prototype, "hasOccludees", void 0), e([e13()], L7.prototype, "hasMultipassTerrain", void 0), e([e13()], L7.prototype, "cullAboveGround", void 0), e([e13()], L7.prototype, "doublePrecisionRequiresObfuscation", void 0), e([e13({ constValue: l14.Disabled })], L7.prototype, "pbrMode", void 0), e([e13({ constValue: true })], L7.prototype, "hasVvInstancing", void 0), e([e13({ constValue: false })], L7.prototype, "useCustomDTRExponentForWater", void 0), e([e13({ constValue: false })], L7.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PathMaterial.js
var _12 = class extends d5 {
  constructor(e25) {
    super(e25, new T8()), this.supportsEdges = true, this._vertexAttributeLocations = R9, this._configuration = new L7(), this.vertexBufferLayout = _12.getVertexBufferLayout(this.parameters);
  }
  getConfiguration(e25, t20) {
    return this._configuration.output = e25, this._configuration.vvSize = this.parameters.vvSizeEnabled, this._configuration.vvColor = this.parameters.vvColorEnabled, this._configuration.vvOpacity = this.parameters.vvOpacityEnabled, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.transparent = this.parameters.transparent, this._configuration.hasOccludees = this.parameters.hasOccludees, e25 !== o10.Color && e25 !== o10.Alpha || (this._configuration.doubleSidedMode = this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? i4.View : this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ? i4.WindingOrder : i4.None, this._configuration.receiveShadows = this.parameters.receiveShadows, this._configuration.receiveAmbientOcclusion = !!t20.ssaoHelper.ready && this.parameters.receiveSSAO), this._configuration.transparencyPassType = t20.transparencyPassType, this._configuration.hasMultipassTerrain = t20.multipassTerrain.enabled, this._configuration.cullAboveGround = t20.multipassTerrain.cullAboveGround, this._configuration;
  }
  isVisibleInPass(e25) {
    return e25 !== A2.MATERIAL_DEPTH_SHADOWMAP_ALL && e25 !== A2.MATERIAL_DEPTH_SHADOWMAP_DEFAULT && e25 !== A2.MATERIAL_DEPTH_SHADOWMAP_HIGHLIGHT || this.parameters.castShadows;
  }
  isVisible() {
    const e25 = this.parameters;
    return !!super.isVisible() && e25.opacity > 0;
  }
  intersect(i17, s16, a21, o22, n24, u16, h18) {
    const l26 = i17;
    if (!r22(l26))
      return;
    const p21 = l26.path, d22 = [this.parameters.size[0], this.parameters.size[1]];
    if (this.parameters.vvSizeEnabled) {
      const t20 = this.parameters.vvSizeOffset, r24 = this.parameters.vvSizeFactor, i18 = this.parameters.vvSizeMinSize, s17 = this.parameters.vvSizeMaxSize, a22 = p21.sizeAttributeValue;
      d22[0] *= o4(t20[0] + a22 * r24[0], i18[0], s17[0]), d22[1] *= o4(t20[2] + a22 * r24[2], i18[2], s17[2]);
    }
    const m15 = Math.max(d22[0], d22[1]), f22 = i17.boundingInfo;
    if (t(f22))
      return void this._intersectTriangles(p21, d22, n24, u16, h18);
    const b13 = u6(f22.bbMin[0] - m15, f22.bbMin[1] - m15, f22.bbMin[2] - m15, f22.bbMax[0] + m15, f22.bbMax[1] + m15, f22.bbMax[2] + m15), v17 = [u16[0] - n24[0], u16[1] - n24[1], u16[2] - n24[2]], S13 = Math.sqrt(v17[0] * v17[0] + v17[1] * v17[1] + v17[2] * v17[2]), A10 = [S13 / v17[0], S13 / v17[1], S13 / v17[2]];
    O3(b13, n24, A10, o22.tolerance) && this._intersectTriangles(p21, d22, n24, u16, h18);
  }
  _intersectTriangles(e25, t20, r24, i17, s16) {
    e25.baked.size && e25.baked.size[0] === t20[0] && e25.baked.size[1] === t20[1] || e25.baked.bake(t20), e25.baked.intersect(r24, i17, s16);
  }
  computeAttachmentOrigin(e25, t20) {
    const r24 = e25.vertexAttributes;
    if (!r24)
      return null;
    const i17 = r24.get(O.POSITION);
    return h5(i17, null, false, t20);
  }
  createBufferWriter() {
    return new L8(this.vertexBufferLayout);
  }
  requiresSlot(e25) {
    return e25 === (this.parameters.transparent ? E6.TRANSPARENT_MATERIAL : E6.OPAQUE_MATERIAL) || e25 === E6.DRAPED_MATERIAL;
  }
  createGLMaterial(e25) {
    return e25.output === o10.Color || e25.output === o10.Alpha || e25.output === o10.Depth || e25.output === o10.Normal || e25.output === o10.Highlight || e25.output === o10.Shadow && this.parameters.castShadows ? new O13(e25) : null;
  }
  static getVertexBufferLayout(e25) {
    let t20 = T2().vec3f(O.POSITION).vec4f(O.PROFILERIGHT).vec4f(O.PROFILEUP).vec4f(O.PROFILEVERTEXANDNORMAL);
    return (e25.vvColorEnabled || e25.vvSizeEnabled || e25.vvOpacityEnabled) && (t20 = t20.vec4f(O.FEATUREVALUE)), t20;
  }
};
var O13 = class extends t8 {
  _updateOccludeeState(e25) {
    e25.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e25.hasOccludees });
  }
  _updateShadowState(e25) {
    (t(this.technique) || e25.shadowMap.enabled !== this.technique.configuration.receiveShadows) && this._material.setParameters({ receiveShadows: e25.shadowMap.enabled });
  }
  beginSlot(e25) {
    return this._output !== o10.Color && this._output !== o10.Alpha || (this._updateShadowState(e25), this._updateOccludeeState(e25)), this.ensureTechnique(E16, e25);
  }
};
var T8 = class extends C9 {
  constructor() {
    super(...arguments), this.doubleSided = false, this.doubleSidedType = "normal", this.receiveSSAO = true, this.receiveShadows = false, this.castShadows = true, this.hasSlicePlane = false, this.transparent = false, this.hasOccludees = false;
  }
};
var L8 = class {
  constructor(e25) {
    this.vertexBufferLayout = e25;
  }
  allocate(e25) {
    return this.vertexBufferLayout.createBuffer(e25);
  }
  elementCount(e25) {
    return e25.indices.get(O.POSITION).length;
  }
  write(e25, t20, r24, s16) {
    const a21 = (e26) => {
      if (t20.vertexAttributes.has(e26)) {
        const a22 = t20.vertexAttributes.get(e26), o22 = t20.indices.get(e26);
        e10(4 === a22.size);
        const n24 = r24.getField(e26, c5);
        if (!n24)
          throw new Error("unable to acquire view for " + e26);
        d6(o22, a22.data, n24, s16);
      }
    };
    a21(O.PROFILERIGHT), a21(O.PROFILEUP), a21(O.PROFILEVERTEXANDNORMAL), this.vertexBufferLayout.hasField(O.FEATUREVALUE) && a21(O.FEATUREVALUE), h9(t20, this.vertexBufferLayout, e25.transformation, e25.invTranspTransformation, r24, s16);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPathSymbolLayer.js
var se2 = ["polyline"];
var ae3 = class extends y3 {
  constructor(e25, t20, r24, i17) {
    super(e25, t20, r24, i17), this._intrinsicSize = r11(1, 1), this.upVectorAlignment = "path", this.stencilWidth = 0.1, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    const t20 = r(this.symbolLayer.width) ? this.symbolLayer.width : this.symbolLayer.height, r24 = r(this.symbolLayer.height) ? this.symbolLayer.height : t20;
    this._vvConvertOptions = { modelSize: [1, 1, 1], symbolSize: [t20, 1, r24], unitInMeters: this._context.renderCoordsHelper.unitInMeters, transformation: { anchor: [0, 0, 0], scale: [1, 1, 1], rotation: [0, 0, 0] }, supportedTypes: { size: true, color: true, opacity: true, rotation: false } }, this._context.renderer && this._context.renderer.visualVariables && this._context.renderer.visualVariables.length > 0 ? this._fastUpdates = P7(this._context.renderer, this._vvConvertOptions) : this._fastUpdates = { enabled: false };
    const a21 = this.symbolLayer.anchor || "center";
    this.upVectorAlignment = "path", "heading" === this.symbolLayer.profileRotation && (this.upVectorAlignment = "world");
    const l26 = this.symbolLayer.profile || "circle";
    switch (l26) {
      case "circle":
      default:
        this._profile = j11.circle(_e5);
        break;
      case "quad":
        this._profile = j11.rect();
    }
    let c21 = [0, 0];
    "center" !== a21 && (c21 = { left: [0.5, 0], right: [-0.5, 0], top: [0, -0.5], bottom: [0, 0.5] }[a21], this._profile.translate(c21[0], c21[1]));
    switch (this.symbolLayer.join || "simple") {
      case "round":
        this._extruder = new q11(0, ge2);
        break;
      case "bevel":
        this._extruder = new q11(0, 1);
        break;
      case "miter":
        this._extruder = new q11(0.8 * Math.PI, 1);
        break;
      default:
        this._extruder = new X2();
    }
    const p21 = this.symbolLayer.cap || "butt";
    switch (p21) {
      case "none":
        this._startCap = new W3(), this._endCap = new W3();
        break;
      case "butt":
      default:
        this._startCap = new Y(this._profile, 0), this._endCap = new Y(this._profile, 0, true);
        break;
      case "square":
        this._startCap = new Y(this._profile, -0.5), this._endCap = new Y(this._profile, 0.5, true);
        break;
      case "round": {
        const e25 = "quad" === l26;
        this._startCap = new Z2({ profile: this._profile, flip: false, breakNormals: e25, subdivisions: ye3 }), this._endCap = new Z2({ profile: this._profile, flip: true, breakNormals: e25, subdivisions: ye3 });
        break;
      }
    }
    const m15 = m(this.symbolLayer, "material", "color"), f22 = this._getCombinedOpacityAndColor(m15), d22 = e4(f22), u16 = f22[3], g17 = u16 < 1 || this.needsDrivenTransparentPass, y9 = { diffuse: d22, ambient: d22, opacity: u16, transparent: g17, hasVertexColors: false, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows, cullFace: g17 || "none" === p21 ? n9.None : n9.Back, offsetTransparentBackfaces: true };
    if (!this._drivenProperties.size && (r7(this._intrinsicSize, t20, r24), !U2(this._intrinsicSize[0]) || !U2(this._intrinsicSize[1])))
      throw new s2("graphics3dpathsymbollayer:invalid-size", "Symbol sizes may not be negative values");
    if (this._fastUpdates.enabled && this._fastUpdates.visualVariables.size || l8(this._intrinsicSize, this._intrinsicSize, 1 / this._context.renderCoordsHelper.unitInMeters), this._fastUpdates.enabled) {
      const e25 = { ...y9, ...this._fastUpdates.materialParameters, size: e9(this._intrinsicSize) };
      this._material = new _12(e25);
    } else
      y9.hasVertexColors = this._drivenProperties.color || this._drivenProperties.opacity, this._material = new R5(y9);
    this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), this._context.stage.add(this._material);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null;
  }
  createGraphics3DGraphic(e25) {
    const t20 = e25.graphic;
    if (!this._validateGeometry(t20.geometry, se2, this.symbolLayer.type))
      return null;
    const r24 = this.setGraphicElevationContext(t20, new h10()), i17 = e25.renderingInfo;
    return this._createAs3DShape(t20, i17, r24, t20.uid);
  }
  layerOpacityChanged() {
    const e25 = m(this.symbolLayer, "material", "color"), t20 = this._getCombinedOpacity(e25), r24 = t20 < 1 || this.needsDrivenTransparentPass;
    return this._material.setParameters({ opacity: t20, transparent: r24 }), true;
  }
  layerElevationInfoChanged(e25, t20) {
    return this.updateGraphics3DGraphicElevationInfo(e25, t20, v8);
  }
  slicePlaneEnabledChanged() {
    return this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), true;
  }
  pixelRatioChanged() {
    return true;
  }
  applyRendererDiff(e25, t20) {
    for (const r24 in e25.diff) {
      if ("visualVariables" !== r24)
        return e16.Recreate_Symbol;
      if (!R7(this._fastUpdates, t20, this._vvConvertOptions))
        return e16.Recreate_Symbol;
      this._material.setParameters(this._fastUpdates.materialParameters);
    }
    return e16.Fast_Update;
  }
  getVertexData(e25) {
    let t20 = 0;
    const r24 = e25.paths, i17 = [], s16 = e25.spatialReference, a21 = this._context.elevationProvider.spatialReference, o22 = this._context.renderCoordsHelper.spatialReference;
    for (const m15 of r24)
      t20 += m15.length;
    const n24 = new Float64Array(3 * t20), l26 = new Float64Array(3 * t20), h18 = new Float64Array(3 * t20);
    let c21 = 0;
    for (const m15 of r24) {
      i17.push({ index: c21, numVertices: m15.length });
      for (const t21 of m15)
        n24[c21++] = t21[0], n24[c21++] = t21[1], n24[c21++] = e25.hasZ ? t21[2] : 0;
    }
    let p21 = true;
    return s16.equals(a21) ? this._copyVertices(n24, 0, l26, 0, t20) : p21 = Un(n24, s16, 0, l26, a21, 0, t20), a21.equals(o22) ? this._copyVertices(l26, 0, h18, 0, t20) : Un(l26, a21, 0, h18, o22, 0, t20), { pathVertexDataInfos: i17, vertexDataGS: n24, vertexDataES: l26, vertexDataRS: h18, projectionSuccess: p21, terrainElevation: 0 };
  }
  _copyVertices(e25, t20, r24, i17, s16) {
    t20 *= 3, i17 *= 3;
    for (let a21 = 0; a21 < s16; ++a21)
      r24[i17++] = e25[t20++], r24[i17++] = e25[t20++], r24[i17++] = e25[t20++];
  }
  _createAs3DShape(e25, t20, r24, s16) {
    const a21 = e25.geometry, o22 = new Array(), n24 = new Array(), l26 = new Array(), h18 = a21.spatialReference, p21 = a3(), m15 = this._context.renderCoordsHelper;
    pe4.spatialReference = h18;
    const f22 = this.getVertexData(a21);
    if (!f22.projectionSuccess)
      return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"), null;
    if (f22.pathVertexDataInfos.length > 0) {
      for (let s17 = 0; s17 < f22.pathVertexDataInfos.length; ++s17) {
        const a22 = f22.pathVertexDataInfos[s17], d22 = a22.index, u16 = a22.numVertices;
        if (u16 < 2)
          continue;
        if (r(this._context.clippingExtent) && (B(p21), M3(p21, f22.vertexDataES, 3 * d22, u16), !R(p21, this._context.clippingExtent)))
          continue;
        const g17 = [];
        for (let e26 = d22; e26 < d22 + 3 * u16; ) {
          const t21 = e26++, i17 = e26++, s18 = e26++, a23 = new G4();
          o3(a23.posGS, f22.vertexDataGS[t21], f22.vertexDataGS[i17], f22.vertexDataGS[s18]), o3(a23.posES, f22.vertexDataES[t21], f22.vertexDataES[i17], f22.vertexDataES[s18]);
          const o23 = m8(a23.posES, this._context.elevationProvider, r24, m15);
          o3(me5, f22.vertexDataRS[t21], f22.vertexDataRS[i17], f22.vertexDataRS[s18]), m15.setAltitude(me5, o23), o3(a23.pos, me5[0], me5[1], me5[2]), g17.push(a23);
        }
        const y9 = new z4(g17);
        oe3(y9, this.upVectorAlignment, this._context.renderCoordsHelper);
        const _14 = new $3(y9, this._profile, this._extruder, this._startCap, this._endCap);
        let b13 = null;
        if (this._fastUpdates.enabled) {
          const t21 = this._fastUpdates.visualVariables, r25 = t21.size ? v11(t21.size.field, e25) : 0, i17 = t21.color ? v11(t21.color.field, e25) : 0, s18 = t21.opacity ? v11(t21.opacity.field, e25) : 0;
          b13 = new it(_14, r25, i17, s18);
        } else {
          const e26 = [this._intrinsicSize[0], this._intrinsicSize[1]];
          this._drivenProperties.size && (e26[0] *= ne4(t20.size[0], "symbol-value" === t20.size[2] ? this.symbolLayer.height || 0 : t20.size[2], this.symbolLayer.width || 0), e26[1] *= ne4(t20.size[2], "symbol-value" === t20.size[0] ? this.symbolLayer.width || 0 : t20.size[0], this.symbolLayer.height || 0));
          let r25 = null;
          this._drivenProperties.color && (r25 = t20.color), this._drivenProperties.opacity && null != t20.opacity && (r25 = r25 ? [r25[0], r25[1], r25[2], t20.opacity] : [1, 1, 1, t20.opacity]);
          const i17 = new et(_14);
          i17.bake(e26), r25 && i17.bakeVertexColors(r25), b13 = i17;
        }
        const { vertexAttributes: v17, indices: x13 } = b13.createGeometryData(), w12 = new e21(v17, x13, b13, h18, this.upVectorAlignment, this.stencilWidth);
        o22.push(w12), n24.push(this._material), l26.push(b13.xform);
      }
      if (o22.length > 0) {
        const e26 = { layerUid: this._context.layer.uid, graphicUid: s16 }, t21 = new O5({ geometries: o22, materials: n24, transformations: l26, metadata: e26 }), i17 = new p14(this, t21, o22, null, null, he4, r24);
        return i17.alignedSampledElevation = f22.terrainElevation, i17.needsElevationUpdates = v8(r24.mode), i17;
      }
    } else
      0 !== a21.paths.length && a21.paths.some((e26) => e26.length > 0) || this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");
    return null;
  }
};
function oe3(e25, i17, s16) {
  switch (i17) {
    case "world":
      for (const t20 of e25.vertices)
        u2(fe5, t20.pos, e25.offset), s16.worldUpAtPosition(fe5, me5), t20.setFrameFromUpVector(me5), t20.computeRotationAxisAndAngleFromUpVector();
      break;
    case "path":
      u2(fe5, e25.vertices[0].pos, e25.offset), s16.worldUpAtPosition(fe5, me5), J6(e25, me5);
      for (const i18 of e25.vertices) {
        const e26 = Math.sign(P(i18.frame.right, i18.vRight));
        _(i18.rotationFrame.up, i18.vRight, i18.vLeft), q(i18.rotationFrame.up, i18.rotationFrame.up, e26), z2(i18.rotationFrame.up, i18.rotationFrame.up);
        const s17 = P(i18.rotationFrame.up, i18.frame.up), o22 = P(i18.rotationFrame.up, i18.frame.right);
        if (q(fe5, i18.frame.up, -o22), q(de4, i18.frame.right, s17), u2(fe5, fe5, de4), z2(i18.rotationFrame.right, fe5), w8(i18.rotationRight, i18.frame, i18.rotationFrame.right), j(fe5, i18.vLeft), i18.rotationAngle = -e26 * (Math.PI - l3(P(fe5, i18.vRight))), Math.abs(i18.rotationAngle) > 0) {
          const e27 = N(Math.cos(0.5 * i18.rotationAngle));
          r21(i18.miterStretch, 1 + (e27 - 1) * i18.rotationRight[0] * i18.rotationRight[0], (e27 - 1) * i18.rotationRight[0] * i18.rotationRight[1], (e27 - 1) * i18.rotationRight[0] * i18.rotationRight[1], 1 + (e27 - 1) * i18.rotationRight[1] * i18.rotationRight[1]);
        }
        const n24 = Math.PI - i18.rotationAngle;
        i18.maxStretchDistance = Math.abs(Math.min(i18.vLeftLength, i18.vRightLength) * N(Math.cos(0.5 * n24)));
      }
  }
}
function ne4(e25, t20, r24) {
  switch (e25) {
    case "symbol-value":
      return r24;
    case "proportional":
      return t20;
    default:
      return e25;
  }
}
function le3(e25, t20, r24, i17) {
  let s16 = 0;
  for (const a21 of e25.vertices)
    d7(a21.posES, r24, t20, i17, ue5), s16 += ue5.sampledElevation, u2(me5, a21.pos, e25.offset), i17.setAltitude(me5, ue5.z), e5(a21.pos, me5, e25.offset);
  return e25.updatePathVertexInformation(), s16 / e25.vertices.length;
}
function he4(e25, t20, r24, i17) {
  const s16 = e25.stageObject, a21 = s16.geometryRecords;
  let o22 = 0;
  ce3.spatialReference = i17.spatialReference;
  for (const n24 of a21) {
    const e26 = n24.geometry;
    if (!r22(e26))
      continue;
    const a22 = e26.path, l26 = a22.builder.path, h18 = e26.geometrySR;
    pe4.spatialReference = h18, o22 += le3(l26, t20, r24, i17), "world" !== e26.upVectorAlignment && oe3(l26, e26.upVectorAlignment, i17), a22.onPathChanged(), e26.invalidateBoundingInfo(), s16.geometryVertexAttrsUpdated(n24);
  }
  return o22 / a21.length;
}
var ce3 = v5(0, 0, 0, null);
var pe4 = v5(0, 0, 0, null);
var me5 = n2();
var fe5 = n10();
var de4 = n10();
var ue5 = new j7();
var ge2 = 3;
var ye3 = 3;
var _e5 = 10;

// node_modules/@arcgis/core/views/3d/layers/support/uvUtils.js
function T9(t20, o22, r24, s16, n24 = 1) {
  if (r24.isGeographic && s16 === l13.Global) {
    const t21 = new Float64Array(o22.typedBuffer.length), e25 = 3 * o22.count, s17 = p3(r24);
    for (let r25 = 0; r25 < e25; r25 += 3)
      ne(o22.typedBuffer, r25, t21, r25, s17);
    o22 = T.fromTypedArray(t21);
  }
  r7(k5, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
  for (let e25 = 0; e25 < o22.count; e25++)
    o22.getVec(e25, E17), k5[0] = Math.min(k5[0], E17[0]), k5[1] = Math.min(k5[1], E17[1]);
  const c21 = k5[0] % n24, a21 = k5[1] % n24;
  P9[0] = k5[0] - c21, P9[1] = k5[1] - a21;
  for (let e25 = 0; e25 < o22.count; e25++)
    o22.getVec(e25, E17), t20.setValues(e25, (E17[0] - P9[0]) / n24, (E17[1] - P9[1]) / n24, P9[0] / n24, P9[1] / n24);
}
function M10(t20, o22, r24, f22, i17 = 1) {
  o3(Y2, 1, 0, 0), o3(_13, 0, 1, 0), o3(d18, 0, 0, 1), z5(y6, o22), O14(o22, F9) && S12(F9, Y2, _13, d18, r24, y6), r7(k5, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), r7(A8, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
  for (let e25 = 0; e25 < o22.count; e25++) {
    o22.getVec(e25, E17);
    const t21 = P(Y2, E17), r25 = P(_13, E17);
    k5[0] = Math.min(k5[0], t21), k5[1] = Math.min(k5[1], r25), A8[0] = Math.max(A8[0], t21), A8[1] = Math.max(A8[1], r25);
  }
  const u16 = P(d18, y6);
  H4(v16, k5[0], k5[1], u16, Y2, _13, d18), H4(x12, A8[0], k5[1], u16, Y2, _13, d18), H4(G5, k5[0], A8[1], u16, Y2, _13, d18), e5(x12, x12, v16), q(x12, x12, 0.5), e5(G5, G5, v16), q(G5, G5, 0.5), u2(v16, v16, x12), u2(v16, v16, G5);
  const I7 = k5[0] % i17, p21 = k5[1] % i17;
  P9[0] = k5[0] - I7, P9[1] = k5[1] - p21;
  for (let e25 = 0; e25 < o22.count; e25++) {
    o22.getVec(e25, E17), t20.setValues(e25, (P(Y2, E17) - P9[0]) / i17, (P(_13, E17) - P9[1]) / i17, P9[0] / i17, P9[1] / i17);
    for (let t21 = 0; t21 < 3; t21++)
      f22.set(e25, t21, v16[t21]), f22.set(e25, t21 + 3, x12[t21]), f22.set(e25, t21 + 6, G5[t21]);
  }
}
var y6 = n2();
var E17 = n2();
var F9 = p9();
var Y2 = n2();
var _13 = n2();
var d18 = n2();
var k5 = n8();
var A8 = n8();
var P9 = n8();
var v16 = n2();
var x12 = n2();
var G5 = n2();
function O14(t20, o22) {
  const e25 = t20.count - 1;
  return b3(t20, o22, 0, Math.floor(e25 / 3), Math.floor(e25 * (2 / 3)));
}
function S12(o22, e25, r24, c21, m15, p21) {
  r(m15) ? (m15.basisMatrixAtPosition(p21, w9), o3(B6, w9[0], w9[1], w9[2]), o3(C10, w9[4], w9[5], w9[6]), o3(q12, w9[8], w9[9], w9[10])) : (o3(B6, 1, 0, 0), o3(C10, 0, 1, 0), o3(q12, 0, 0, 1));
  const N6 = Z(o22);
  P(N6, q12) < 0 && q(N6, N6, -1), r3(c21, N6);
  const l26 = P(N6, C10), h18 = P(N6, B6);
  Math.abs(l26) < Math.abs(h18) ? (g2(e25, B6, N6, -h18), z2(e25, e25), _(r24, e25, N6), z2(r24, r24), q(r24, r24, -1)) : (g2(r24, C10, N6, -l26), z2(r24, r24), _(e25, r24, N6), z2(e25, e25));
}
var w9 = e8();
var B6 = n2();
var C10 = n2();
var q12 = n2();
function z5(t20, o22) {
  o3(D5, 0, 0, 0);
  for (let e25 = 0; e25 < o22.count - 1; e25++)
    o22.getVec(e25, E17), u2(D5, D5, E17);
  q(t20, D5, 1 / (o22.count - 1));
}
var D5 = n2();
function H4(t20, o22, e25, r24, n24, c21, a21) {
  o3(t20, o22 * n24[0] + e25 * c21[0] + r24 * a21[0], o22 * n24[1] + e25 * c21[1] + r24 * a21[1], o22 * n24[2] + e25 * c21[2] + r24 * a21[2]);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/PatternTechnique.js
var j12 = class extends e11 {
  initializeProgram(e25) {
    const t20 = j12.shader.get().build(this.configuration);
    return new o13(e25.rctx, t20, w10);
  }
  _setPipelineState(e25, o22) {
    const r24 = this.configuration, i17 = e25 === O2.NONE, s16 = e25 === O2.FrontFace;
    return W({ blending: r24.output === o10.Color || r24.output === o10.Alpha ? i17 ? c12 : E5(e25) : null, culling: h8(r24.cullFace), depthTest: { func: l16(e25) }, depthWrite: i17 ? r24.writeDepth && a7 : S2(e25), colorWrite: c11, stencilWrite: r24.hasOccludees ? e12 : null, stencilTest: r24.hasOccludees ? o22 ? o14 : f8 : null, polygonOffset: i17 || s16 ? r24.polygonOffset && C11 : i5(r24.enableOffset) });
  }
  initializePipeline() {
    return this._occludeePipelineState = this._setPipelineState(this.configuration.transparencyPassType, true), this._setPipelineState(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e25, t20) {
    return t20 ? this._occludeePipelineState : super.getPipelineState(e25, t20);
  }
};
j12.shader = new t9(P4, () => import("./Pattern.glsl-FA43TTKX.js"));
var C11 = { factor: 1, units: 1 };
var N4 = class extends i7 {
  constructor() {
    super(...arguments), this.output = o10.Color, this.cullFace = n9.None, this.transparencyPassType = O2.NONE, this.hasSlicePlane = false, this.hasVertexColors = false, this.polygonOffset = false, this.writeDepth = true, this.hasOccludees = false, this.enableOffset = true, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([e13({ count: o10.COUNT })], N4.prototype, "output", void 0), e([e13({ count: n9.COUNT })], N4.prototype, "cullFace", void 0), e([e13({ count: a12.COUNT })], N4.prototype, "style", void 0), e([e13({ count: O2.COUNT })], N4.prototype, "transparencyPassType", void 0), e([e13()], N4.prototype, "hasSlicePlane", void 0), e([e13()], N4.prototype, "hasVertexColors", void 0), e([e13()], N4.prototype, "polygonOffset", void 0), e([e13()], N4.prototype, "writeDepth", void 0), e([e13()], N4.prototype, "hasOccludees", void 0), e([e13()], N4.prototype, "patternSpacing", void 0), e([e13()], N4.prototype, "lineWidth", void 0), e([e13()], N4.prototype, "enableOffset", void 0), e([e13()], N4.prototype, "draped", void 0), e([e13()], N4.prototype, "hasMultipassTerrain", void 0), e([e13()], N4.prototype, "cullAboveGround", void 0);
var w10 = /* @__PURE__ */ new Map([[O.POSITION, 0], [O.COLOR, 3], [O.UVMAPSPACE, 4], [O.BOUNDINGRECT, 5]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PatternMaterial.js
var y7 = class extends d5 {
  constructor(e25) {
    super(e25, new R10()), this.supportsEdges = true, this._vertexAttributeLocations = w10, this.techniqueConfig = new N4();
  }
  getConfiguration(e25, t20) {
    return this.techniqueConfig.output = e25, this.techniqueConfig.cullFace = this.parameters.cullFace, this.techniqueConfig.hasVertexColors = this.parameters.hasVertexColors, this.techniqueConfig.hasSlicePlane = this.parameters.hasSlicePlane, this.techniqueConfig.polygonOffset = this.parameters.polygonOffset, this.techniqueConfig.writeDepth = this.parameters.writeDepth, this.techniqueConfig.style = this.parameters.style, this.techniqueConfig.patternSpacing = this.parameters.patternSpacing, this.techniqueConfig.lineWidth = this.parameters.lineWidth, this.techniqueConfig.draped = this.parameters.draped, this.techniqueConfig.transparencyPassType = t20.transparencyPassType, this.techniqueConfig.enableOffset = t20.camera.relativeElevation < _4, this.techniqueConfig.hasMultipassTerrain = t20.multipassTerrain.enabled, this.techniqueConfig.cullAboveGround = t20.multipassTerrain.cullAboveGround, this.techniqueConfig;
  }
  intersect(e25, t20, r24, i17, s16, a21, n24) {
    x4(e25, t20, i17, s16, a21, void 0, n24);
  }
  requiresSlot(e25, t20) {
    if (e25 === E6.DRAPED_MATERIAL)
      return true;
    if (i9(t20) === o10.Highlight)
      return e25 === E6.OPAQUE_MATERIAL;
    return e25 === (this.parameters.writeDepth ? E6.TRANSPARENT_MATERIAL : E6.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL);
  }
  createGLMaterial(e25) {
    return e25.output === o10.Color || e25.output === o10.Alpha || e25.output === o10.Highlight || e25.output === o10.Depth && this.parameters.writeLinearDepth ? new j13(e25) : null;
  }
  createBufferWriter() {
    const e25 = T2().vec3f(O.POSITION).vec4u8(O.COLOR).vec4f(O.UVMAPSPACE);
    return this.parameters.draped || e25.mat3f(O.BOUNDINGRECT), new E18(e25);
  }
};
var j13 = class extends t8 {
  _updateParameters(e25) {
    return this.ensureTechnique(j12, e25);
  }
  _updateOccludeeState(e25) {
    e25.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e25.hasOccludees });
  }
  beginSlot(e25) {
    return this._output !== o10.Color && this._output !== o10.Alpha || this._updateOccludeeState(e25), this._updateParameters(e25);
  }
};
var E18 = class extends i10 {
  write(e25, a21, n24, o22) {
    for (const h18 of this.vertexBufferLayout.fieldNames) {
      const u16 = a21.vertexAttributes.get(h18), l26 = a21.indices.get(h18);
      if (u16 && l26)
        switch (h18) {
          case O.POSITION: {
            e10(3 === u16.size);
            const t20 = n24.getField(h18, i2);
            t20 && p7(l26, u16.data, e25.transformation, t20, o22);
            break;
          }
          case O.COLOR: {
            e10(3 === u16.size || 4 === u16.size);
            const e26 = n24.getField(h18, x2);
            e26 && g5(l26, u16.data, u16.size, e26, o22);
            break;
          }
          case O.UVMAPSPACE: {
            e10(4 === u16.size);
            const e26 = n24.getField(h18, c5);
            e26 && d6(l26, u16.data, e26, o22);
            break;
          }
          case O.BOUNDINGRECT: {
            e10(9 === u16.size);
            const r24 = n24.getField(h18, l9);
            r24 && this.writeBoundingRect(l26, u16.data, e25.transformation, r24, o22);
            break;
          }
        }
    }
  }
  writeBoundingRect(e25, t20, r24, i17, s16) {
    const a21 = r24, n24 = i17.typedBuffer, o22 = i17.typedBufferStride, h18 = e25.length;
    s16 *= o22;
    for (let u16 = 0; u16 < h18; ++u16) {
      const r25 = 9 * e25[u16], i18 = t20[r25], h19 = t20[r25 + 1], l26 = t20[r25 + 2];
      n24[s16] = a21[0] * i18 + a21[4] * h19 + a21[8] * l26 + a21[12], n24[s16 + 1] = a21[1] * i18 + a21[5] * h19 + a21[9] * l26 + a21[13], n24[s16 + 2] = a21[2] * i18 + a21[6] * h19 + a21[10] * l26 + a21[14];
      for (let e26 = 3; e26 < 9; ++e26)
        n24[s16 + e26] = t20[r25 + e26];
      s16 += o22;
    }
  }
};
var R10 = class extends o11 {
  constructor() {
    super(...arguments), this.color = r5(1, 1, 1, 1), this.writeDepth = true, this.writeLinearDepth = false, this.hasVertexColors = false, this.polygonOffset = false, this.hasSlicePlane = false, this.cullFace = n9.None, this.hasOccludees = false, this.style = a12.Cross, this.patternSpacing = 10, this.lineWidth = 1, this.draped = true;
  }
};

// node_modules/@arcgis/core/views/3d/layers/support/patternUtils.js
function f20(r24, e25, t20) {
  return g16(u15(r24), e25, t20);
}
function u15(r24) {
  return r24 && r24.pattern || null;
}
function g16(t20, a21, o22) {
  return r(t20) ? "none" === t20.style || "solid" === t20.style ? ("none" === t20.style && (a21.color = r5(0, 0, 0, 0), a21.transparent = true), new m9(a21)) : (a21.style = p19(t20.style), a21.draped = o22.isDraped, new y7(a21)) : new m9(a21);
}
function p19(r24) {
  switch (r24) {
    case "horizontal":
      return a12.Horizontal;
    case "vertical":
      return a12.Vertical;
    case "cross":
      return a12.Cross;
    case "forward-diagonal":
      return a12.ForwardDiagonal;
    case "backward-diagonal":
      return a12.BackwardDiagonal;
    case "diagonal-cross":
      return a12.DiagonalCross;
    default:
      return;
  }
}
function d19(r24) {
  return r24.material instanceof y7 && !r24.material.parameters.draped;
}
function y8(r24, e25) {
  if (d19(r24)) {
    const n24 = r24.geometry.vertexAttributes, l26 = n24.get(O.POSITION).data, m15 = n24.get(O.UVMAPSPACE).data, c21 = n24.get(O.BOUNDINGRECT).data;
    M10(c5.fromTypedArray(m15), T.fromTypedArray(l26), e25, a4.fromTypedArray(c21));
  }
}
function w11(r24, e25, t20, a21) {
  const o22 = p13(r24, e25, t20, a21), i17 = r24.stageObject.geometryRecords;
  for (let n24 = 0; n24 < i17.length; n24++)
    y8(i17[n24], a21);
  return o22;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPolygonFillSymbolLayer.js
var H5 = ["polyline", "polygon", "extent"];
var W4 = class extends y3 {
  constructor(e25, t20, i17, r24) {
    super(e25, t20, i17, r24), this._needsUV = false, this._hasOutline = false;
  }
  async doLoad() {
  }
  _ensureMaterials() {
    this._ensureFillMaterial(), this._ensureOutlineMaterial();
  }
  _ensureFillMaterial() {
    if (r(this._material))
      return;
    const e25 = m(this.symbolLayer, "material", "color"), r24 = this._getCombinedOpacityAndColor(e25);
    this._material = f20(this.symbolLayer, { color: r24, transparent: r24[3] < 1 || this.needsDrivenTransparentPass, polygonOffset: false, hasVertexColors: true, writeLinearDepth: true, hasSlicePlane: this._context.slicePlaneEnabled }, { isDraped: this.draped }), this._needsUV = this._material instanceof y7, this._context.stage.add(this._material);
  }
  _ensureOutlineMaterial() {
    const e25 = this.symbolLayer.outline;
    if (r(this._outlineMaterial) || !this._isValidOutline(e25))
      return;
    this._hasOutline = true;
    const i17 = (t20) => {
      const i18 = a11(e25.pattern);
      return new H2({ width: t20, color: this._getOutlineColor(), hasPolygonOffset: true, hasSlicePlane: this._context.slicePlaneEnabled, isClosed: true, stipplePattern: i18, stippleScaleWithLineWidth: true, cap: L4(e25.patternCap || "butt") });
    };
    this._outlineMaterial = i17(u3(e25.size)), this._context.stage.add(this._outlineMaterial);
  }
  _isValidOutline(e25) {
    return r(e25) && e25.size && e25.size > 0 && r(e25.color) && (t(e25.pattern) || "style" !== e25.pattern.type || "none" !== e25.pattern.style);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null, this._context.stage.remove(this._outlineMaterial), this._outlineMaterial = null;
  }
  createGraphics3DGraphic(e25) {
    const t20 = e25.graphic;
    if (!this._validateGeometry(t20.geometry, H5, this.symbolLayer.type))
      return null;
    const i17 = this._getVertexOpacityAndColor(e25.renderingInfo, 255), r24 = this.setGraphicElevationContext(t20, new h10());
    return this.ensureDrapedStatus("on-the-ground" === r24.mode), this._ensureMaterials(), this.draped ? this._createAsOverlay(t20, i17) : this._createAs3DShape(t20, i17, r24);
  }
  layerOpacityChanged() {
    if (r(this._material)) {
      const e25 = this._material.parameters.color, t20 = m(this.symbolLayer, "material", "color"), r24 = this._getCombinedOpacity(t20);
      this._material.setParameters({ color: [e25[0], e25[1], e25[2], r24], transparent: r24 < 1 || this.needsDrivenTransparentPass });
    }
    if (r(this._outlineMaterial)) {
      const e25 = this._outlineMaterial.parameters.color;
      this._outlineMaterial.setParameters({ color: [e25[0], e25[1], e25[2], this._getOutlineOpacity()] });
    }
    return true;
  }
  layerElevationInfoChanged(e25, t20, i17) {
    const r24 = this._elevationContext.mode, n24 = p10(W4.elevationModeChangeTypes, i17, r24);
    if (n24 !== x5.UPDATE)
      return n24;
    const o22 = g7(r24);
    return this.updateGraphics3DGraphicElevationInfo(e25, t20, () => o22);
  }
  slicePlaneEnabledChanged() {
    if (r(this._material) && this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), r(this._outlineMaterial)) {
      const e25 = { hasSlicePlane: this._context.slicePlaneEnabled };
      this._outlineMaterial.setParameters(e25);
    }
    return true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  _createAs3DShape(e25, t20, i17) {
    const n24 = m12(e25.geometry);
    if (t(n24))
      return null;
    z6.renderData = d15(n24, this._context.elevationProvider, this._context.renderCoordsHelper, i17), z6.color = t20;
    const o22 = z6.renderData.position.length / 3;
    if (this._needsUV && (z6.uvMapSpace = new Float32Array(4 * o22), z6.boundingRect = new Float64Array(9 * o22)), z6.outNum = 0, z6.outGeometries = [], z6.outTransforms = [], z6.outMaterials = [], this._createAs3DShapeFill(z6), this._hasOutline && this._createAs3DShapeOutline(z6), this._logGeometryCreationWarnings(z6.renderData, n24.rings, "rings", "FillSymbol3DLayer"), 0 === z6.outNum)
      return null;
    this._needsUV && M10(c5.fromTypedArray(z6.uvMapSpace), T.fromTypedArray(z6.renderData.position), this._context.renderCoordsHelper, a4.fromTypedArray(z6.boundingRect));
    const a21 = new O5({ geometries: z6.outGeometries, materials: z6.outMaterials, transformations: z6.outTransforms, castShadow: false, metadata: { layerUid: this._context.layer.uid, graphicUid: e25.uid } }), s16 = new p14(this, a21, z6.outGeometries, null, null, w11, i17);
    return s16.alignedSampledElevation = z6.renderData.sampledElevation, s16.needsElevationUpdates = g7(i17.mode), s16;
  }
  _createAs3DShapeFill(e25) {
    const i17 = e25.renderData.polygons;
    for (const { position: r24, mapPosition: o22, holeIndices: l26, index: u16, count: d22 } of i17) {
      if (r(this._context.clippingExtent) && (B(k6), M3(k6, o22), !R(k6, this._context.clippingExtent)))
        continue;
      const i18 = x3(o22, l26, 3);
      if (0 === i18.length)
        continue;
      const m15 = new Uint32Array(i18), _14 = c17({ indices: m15, attributeData: { position: r24, color: e25.color, mapPosition: o22, uvMapSpace: this._needsUV ? new Float32Array(e25.uvMapSpace.buffer, 4 * u16 * e25.uvMapSpace.BYTES_PER_ELEMENT, 4 * d22) : null, boundingRect: this._needsUV ? new Float64Array(e25.boundingRect.buffer, 9 * u16 * e25.boundingRect.BYTES_PER_ELEMENT, 9 * d22) : null } });
      e25.outGeometries.push(_14), e25.outMaterials.push(e2(this._material)), e25.outTransforms.push(o7), e25.outNum++;
    }
  }
  _createAs3DShapeOutline(e25) {
    if (!this._hasOutline)
      return;
    const i17 = e25.renderData.outlines;
    for (let r24 = 0; r24 < i17.length; ++r24) {
      const { mapPosition: o22, position: a21 } = i17[r24];
      if (r(this._context.clippingExtent) && (B(k6), M3(k6, o22), !R(k6, this._context.clippingExtent)))
        continue;
      const l26 = O6({ overlayInfo: null, removeDuplicateStartEnd: P3.REMOVE, attributeData: { position: a21, mapPosition: o22 } }), u16 = l26.vertexAttributes.get(O.POSITION);
      u16.data === a21 && (u16.data = new Float64Array(a21)), e25.outGeometries.push(l26), e25.outMaterials.push(e2(this._outlineMaterial)), e25.outTransforms.push(o7), e25.outNum++;
    }
  }
  _createAsOverlay(e25, i17) {
    const o22 = m12(e25.geometry);
    if (t(o22))
      return null;
    e2(this._material).renderPriority = this._renderPriority + this._renderPriorityStep / 2, r(this._outlineMaterial) && (this._outlineMaterial.renderPriority = this._renderPriority), Y3.renderData = f15(o22, this._context.overlaySR), Y3.color = i17;
    const a21 = Y3.renderData.position.length / 3;
    return this._needsUV && (Y3.uvMapSpace = new Float32Array(4 * a21)), Y3.outNum = 0, Y3.outGeometries = [], Y3.outBoundingBox = B(), Y3.layerUid = this._context.layer.uid, Y3.graphicsUid = e25.uid, this._createAsOverlayFill(Y3), this._hasOutline && this._createAsOverlayOutline(Y3), this._logGeometryCreationWarnings(Y3.renderData, o22.rings, "rings", "FillSymbol3DLayer"), 0 === Y3.outNum ? null : (this._needsUV && T9(c5.fromTypedArray(Y3.uvMapSpace), T.fromTypedArray(Y3.renderData.position), this._context.overlaySR, this._context.graphicsCoreOwner.view.state.viewingMode), Y3.outNum > 0 ? new u13(this, Y3.outGeometries, Y3.outBoundingBox, this._context.drapeSourceRenderer) : null);
  }
  _createAsOverlayFill(e25) {
    const t20 = e25.renderData.polygons;
    for (const { position: i17, holeIndices: r24, index: o22, count: s16 } of t20) {
      if (B(k6), M3(k6, i17), !R(k6, this._context.clippingExtent))
        continue;
      const t21 = x3(i17, r24, 3);
      if (0 === t21.length)
        continue;
      f3(e25.outBoundingBox, k6);
      const u16 = new Uint32Array(t21), m15 = c17({ indices: u16, attributeData: { position: i17, color: e25.color, uvMapSpace: this._needsUV ? new Float32Array(e25.uvMapSpace.buffer, 4 * o22 * e25.uvMapSpace.BYTES_PER_ELEMENT, 4 * s16) : null } }), _14 = new T4(m15, e2(this._material), { layerUid: e25.layerUid, graphicUid: e25.graphicsUid }), y9 = k6;
      r4(_14.boundingSphere, 0.5 * (y9[0] + y9[3]), 0.5 * (y9[1] + y9[4]), 0, 0.5 * Math.sqrt((y9[3] - y9[0]) * (y9[3] - y9[0]) + (y9[4] - y9[1]) * (y9[4] - y9[1]))), e25.outGeometries.push(_14), e25.outNum++;
    }
  }
  _createAsOverlayOutline(e25) {
    if (!this._hasOutline)
      return;
    const t20 = e25.renderData.outlines;
    for (let i17 = 0; i17 < t20.length; ++i17) {
      const { position: r24 } = t20[i17];
      if (B(k6), M3(k6, r24), !R(k6, this._context.clippingExtent))
        continue;
      f3(e25.outBoundingBox, k6);
      const o22 = O6({ overlayInfo: { spatialReference: this._context.overlaySR, renderCoordsHelper: this._context.renderCoordsHelper }, removeDuplicateStartEnd: P3.REMOVE, attributeData: { position: r24 } }), a21 = new T4(o22, e2(this._outlineMaterial), { layerUid: e25.layerUid, graphicUid: e25.graphicsUid }), s16 = k6;
      r4(a21.boundingSphere, 0.5 * (s16[0] + s16[3]), 0.5 * (s16[1] + s16[4]), 0, 0.5 * Math.sqrt((s16[3] - s16[0]) * (s16[3] - s16[0]) + (s16[4] - s16[1]) * (s16[4] - s16[1]))), e25.outGeometries.push(a21), e25.outNum++;
    }
  }
  _getOutlineOpacity() {
    const e25 = m(this.symbolLayer, "outline", "color");
    return (this.draped ? 1 : this._getLayerOpacity()) * (r(e25) ? e25.a : 0);
  }
  _getOutlineColor() {
    const r24 = m(this.symbolLayer, "outline", "color"), n24 = this._getOutlineOpacity();
    return z3(r(r24) ? l4.toUnitRGB(r24) : null, n24);
  }
  test() {
    return { ...super.test(), createAsOverlay: (e25, t20) => this._createAsOverlay(e25, t20), createAs3DShape: (e25, t20, i17) => this._createAs3DShape(e25, t20, i17) };
  }
};
W4.elevationModeChangeTypes = { definedChanged: x5.RECREATE, staysOnTheGround: x5.NONE, onTheGroundChanged: x5.RECREATE };
var k6 = a3();
var z6 = { renderData: null, color: null, uvMapSpace: null, boundingRect: null, outNum: 0, outBoundingBox: null, outGeometries: null, outMaterials: null, outTransforms: null };
var Y3 = { renderData: null, color: null, uvMapSpace: null, outNum: 0, outBoundingBox: null, outGeometries: null, outMaterials: null, outTransforms: null };

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextTextureFactory.js
var i16 = class {
  constructor(e25, t20, n24) {
    this._renderer = new s10(e25, t20, n24);
  }
  get key() {
    return this._renderer.key;
  }
  get baselineAnchorY() {
    return 1 - this._renderer.firstRenderedBaselinePosition / this._renderer.renderedHeight;
  }
  get displayWidth() {
    return this._renderer.displayWidth;
  }
  get displayHeight() {
    return this._renderer.displayHeight;
  }
  create() {
    const r24 = o17(d20, this._renderer.renderedWidth, this._renderer.renderedHeight), i17 = r24.getContext("2d");
    return i17.save(), this._renderer.render(i17, 0, 0), i17.restore(), new L3(r24, { wrap: { s: D2.CLAMP_TO_EDGE, t: D2.CLAMP_TO_EDGE }, noUnpackFlip: false, mipmap: true, preMultiplyAlpha: true, powerOfTwoResizeMode: l12.PAD });
  }
};
var d20 = { canvas: null };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DTextSymbolLayer.js
var C12 = [0, 0, 1];
var U6 = class extends y3 {
  constructor(e25, t20, r24, n24) {
    super(e25, t20, r24, n24), this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: false }, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    if (!this._drivenProperties.size) {
      const t20 = O4(this.symbolLayer.size);
      if (t20)
        throw new s2("graphics3dtextsymbollayer:invalid-size", t20);
    }
    await this._createTextRenderParameters();
  }
  async _createTextRenderParameters() {
    const e25 = this._context.graphicsCoreOwner.view.state.pixelRatio;
    this._textRenderParameters = await a19.fromSymbol(this.symbolLayer, e25);
  }
  destroy() {
    super.destroy();
  }
  createGraphics3DGraphic(e25) {
    const n24 = e25.graphic, s16 = d9(n24.geometry);
    if (t(s16))
      return this.logger.warn(`unsupported geometry type for text symbol: ${n24.geometry.type}`), null;
    const i17 = this.symbolLayer.text;
    if (t(i17) || "" === i17)
      return null;
    const o22 = o9(this.symbol) && this.symbol.hasVisibleVerticalOffset() ? this.symbol.verticalOffset : null;
    if (r(o22) && !i3(this.symbolLayer))
      return this.logger.errorOncePerTick(`Callouts and vertical offset on text symbols are currently only supported with 'center' horizontal alignment (not with '${this.symbolLayer.horizontalAlignment}' alignment)`), null;
    const a21 = { ...A9, verticalOffset: o22, horizontalPlacement: this.symbolLayer.horizontalAlignment, verticalPlacement: f14(this.symbolLayer.verticalAlignment) };
    return this._createAs3DShape(n24, s16, i17, a21);
  }
  createLabel(e25, r24, n24, s16) {
    const i17 = e25.graphic, o22 = d9(i17.geometry);
    if (t(o22))
      return this.logger.warn(`unsupported geometry type for label: ${i17.geometry.type}`), null;
    const a21 = r24.text;
    return !a21 || /^\s+$/.test(a21) ? null : this._createAs3DShape(i17, o22, a21, r24, n24, s16);
  }
  setGraphicElevationContext(e25, t20, r24 = 0) {
    const n24 = super.setGraphicElevationContext(e25, t20);
    return n24.addOffsetRenderUnits(r24), n24;
  }
  layerOpacityChanged() {
    return this.logger.warn("layer opacity change not yet implemented in Graphics3DTextSymbolLayer"), false;
  }
  layerElevationInfoChanged(e25, t20) {
    return D6(e25, t20, (e26, t21) => {
      this.updateGraphicElevationContext(t21, e26);
    }), x5.UPDATE;
  }
  slicePlaneEnabledChanged(e25, t20) {
    return D6(e25, t20, (e26) => {
      for (const t21 of e26.stageObject.geometryRecords)
        t21.material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return false;
  }
  updateGraphicElevationContext(e25, t20) {
    this.setGraphicElevationContext(e25, t20.elevationContext, t20.metadata.elevationOffset), t20.needsElevationUpdates = g7(t20.elevationContext.mode) || "absolute-height" === t20.elevationContext.mode;
  }
  _defaultElevationInfoNoZ() {
    return R11;
  }
  _createAs3DShape(e25, l26, c21, m15, f22, g17) {
    const y9 = this.setGraphicElevationContext(e25, new h10(), m15.elevationOffset), v17 = "polyline" === m(e25.geometry, "type"), b13 = e25.uid;
    let P10 = null, O15 = null;
    if (t(g17)) {
      const e26 = c16(m15.horizontalPlacement);
      P10 = new i16(c21, e26, this._textRenderParameters);
      let n24 = null;
      O15 = this._context.sharedResources.textures.fromData(P10.key, () => e2(P10).create(), () => {
        r(n24) && n24.release();
      });
      const o22 = this._context.stage.renderView.textureRepository.acquire(O15.texture.id);
      if (t(o22) || k(o22))
        return O15.release(), null;
      n24 = o22;
    }
    const w12 = G6(P10, m15), _14 = { occlusionTest: true, screenOffset: m15.screenOffset, anchorPosition: w12, polygonOffset: true, color: [1, 1, 1, 1], centerOffsetUnits: m15.centerOffsetUnits, debugDrawLabelBorder: m15.debugDrawLabelBorder, drawInSecondSlot: true };
    if (r(O15) && (_14.textureId = O15.texture.id), r(g17) && (_14.textureId = g17.id), r(m15.verticalOffset)) {
      const { screenLength: e26, minWorldLength: t20, maxWorldLength: r24 } = m15.verticalOffset;
      _14.verticalOffset = { screenLength: u3(e26), minWorldLength: t20 || 0, maxWorldLength: null != r24 ? r24 : 1 / 0 };
    }
    if (this._context.screenSizePerspectiveEnabled) {
      const { screenSizePerspectiveSettings: e26, screenSizePerspectiveSettingsLabels: t20 } = this._context.sharedResources;
      _14.screenSizePerspective = t20.overridePadding(this._textRenderParameters.haloSize + this._textRenderParameters.definition.background.padding[0]), _14.screenSizePerspectiveAlignment = e26;
    }
    let U7;
    if (v17 && (_14.shaderPolygonOffset = 1e-4), _14.hasSlicePlane = this._context.slicePlaneEnabled, r(f22)) {
      const e26 = JSON.stringify(_14);
      U7 = f22.get(e26), t(U7) && (U7 = new J3(_14), f22.add(e26, U7));
    } else
      U7 = new J3(_14);
    const D7 = [U7], R12 = m15.translation, A10 = r(P10) ? [P10.displayWidth, P10.displayHeight] : [0, 0], T10 = m15.centerOffset, W6 = C12, I7 = [0, 0], k8 = [T3.createPointGeometry(W6, R12, null, A10, T10, I7, null)], B7 = this._context.layer.uid, H6 = f11(this._context, l26, k8, D7, y9, B7, b13);
    if (null === H6)
      return null;
    const $4 = new p14(this, H6.object, k8, t(f22) ? D7 : null, O15, d12, y9);
    $4.alignedSampledElevation = H6.sampledElevation, $4.needsElevationUpdates = g7(y9.mode) || "absolute-height" === y9.mode;
    const { displayWidth: V8, displayHeight: N6 } = r(P10) ? P10 : m15;
    $4.getScreenSize = (e26 = n8()) => (e26[0] = V8, e26[1] = N6, e26);
    const q13 = { labelText: c21, elevationOffset: m15.elevationOffset };
    return $4.metadata = q13, g8($4, l26, this._context.elevationProvider), $4;
  }
};
function D6(e25, t20, n24) {
  e25 && e25.forEach((e26) => {
    const s16 = t20(e26);
    r(s16) && n24(s16, e26.graphic);
  });
}
function G6(e25, t20) {
  if ("baseline" === t20.verticalPlacement) {
    const n25 = r18[t20.horizontalPlacement], s16 = r(e25) ? e25.baselineAnchorY : 0;
    return r11(n25, s16);
  }
  const n24 = i14(t20.horizontalPlacement, t20.verticalPlacement);
  return o18[n24];
}
var R11 = { mode: "relative-to-ground", offset: 0 };
var A9 = { text: null, translation: [0, 0, 0], elevationOffset: 0, centerOffset: [0, 0, 0, 1], screenOffset: [0, 0], horizontalPlacement: "center", verticalPlacement: "center", verticalOffset: null, centerOffsetUnits: null, debugDrawLabelBorder: false, displayWidth: 0, displayHeight: 0 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/waterMaterialUtils.js
var e23 = { "calm-small": { waveStrength: 5e-3, perturbationStrength: 0.02, textureRepeat: 12, waveVelocity: 0.01 }, "rippled-small": { waveStrength: 0.02, perturbationStrength: 0.09, textureRepeat: 32, waveVelocity: 0.07 }, "slight-small": { waveStrength: 0.05, perturbationStrength: 0.07, textureRepeat: 28, waveVelocity: 0.1 }, "moderate-small": { waveStrength: 0.075, perturbationStrength: 0.07, textureRepeat: 24, waveVelocity: 0.1 }, "calm-medium": { waveStrength: 3125e-6, perturbationStrength: 0.01, textureRepeat: 8, waveVelocity: 0.02 }, "rippled-medium": { waveStrength: 0.035, perturbationStrength: 0.015, textureRepeat: 12, waveVelocity: 0.07 }, "slight-medium": { waveStrength: 0.06, perturbationStrength: 0.015, textureRepeat: 8, waveVelocity: 0.12 }, "moderate-medium": { waveStrength: 0.09, perturbationStrength: 0.03, textureRepeat: 4, waveVelocity: 0.12 }, "calm-large": { waveStrength: 0.01, perturbationStrength: 0, textureRepeat: 4, waveVelocity: 0.05 }, "rippled-large": { waveStrength: 0.025, perturbationStrength: 0.01, textureRepeat: 8, waveVelocity: 0.11 }, "slight-large": { waveStrength: 0.06, perturbationStrength: 0.02, textureRepeat: 3, waveVelocity: 0.13 }, "moderate-large": { waveStrength: 0.14, perturbationStrength: 0.03, textureRepeat: 2, waveVelocity: 0.15 } };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DWaterSymbolLayer.js
var N5 = ["polyline", "polygon", "extent"];
var V7 = class extends y3 {
  constructor(e25, t20, r24, o22) {
    super(e25, t20, r24, o22);
  }
  async doLoad() {
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null;
  }
  createGraphics3DGraphic(e25) {
    const t20 = e25.graphic;
    if (!this._validateGeometry(t20.geometry, N5, this.symbolLayer.type))
      return null;
    const r24 = this.setGraphicElevationContext(t20, new h10());
    return this.ensureDrapedStatus("on-the-ground" === r24.mode), this.ensureMaterial(), this.draped ? this._createAsOverlay(t20) : this._createAs3DShape(t20, r24, t20.uid);
  }
  ensureMaterial() {
    if (r(this._material))
      return;
    const r24 = new A4(), o22 = this.symbolLayer.color;
    r(o22) && (r24.color = l4.toUnitRGBA(o22));
    const i17 = this._getCombinedOpacity(o22, { hasIntrinsicColor: true });
    r24.color = [r24.color[0], r24.color[1], r24.color[2], i17], r24.transparent = i17 < 1 || this.needsDrivenTransparentPass, r24.waveDirection = r(this.symbolLayer.waveDirection) ? V7.headingVectorFromAngle(this.symbolLayer.waveDirection) : r11(0, 0);
    const a21 = this.symbolLayer.waveStrength + "-" + this.symbolLayer.waterbodySize, n24 = e23[a21];
    r24.waveStrength = n24.waveStrength, r24.waveTextureRepeat = n24.textureRepeat, r24.waveVelocity = n24.waveVelocity, r24.flowStrength = n24.perturbationStrength, r24.hasSlicePlane = this._context.slicePlaneEnabled, r24.isDraped = this.draped, this._material = new d10(r24), this._context.stage.add(this._material);
  }
  layerOpacityChanged() {
    if (t(this._material))
      return true;
    const e25 = this._material.parameters.color, t20 = this._getCombinedOpacity(this.symbolLayer.color, { hasIntrinsicColor: true }), o22 = t20 < 1 || this.needsDrivenTransparentPass;
    return this._material.setParameters({ color: [e25[0], e25[1], e25[2], t20], transparent: o22 }), true;
  }
  layerElevationInfoChanged(e25, t20, r24) {
    const o22 = this._elevationContext.mode, i17 = p10(V7.elevationModeChangeTypes, r24, o22);
    if (i17 !== x5.UPDATE)
      return i17;
    const a21 = g7(o22);
    return this.updateGraphics3DGraphicElevationInfo(e25, t20, () => a21);
  }
  slicePlaneEnabledChanged() {
    return r(this._material) && this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  _createAs3DShape(e25, t20, o22) {
    const i17 = m12(e25.geometry);
    if (t(i17))
      return null;
    z7.renderData = d15(i17, this._context.elevationProvider, this._context.renderCoordsHelper, t20);
    const a21 = z7.renderData.position.length / 3;
    if (z7.uvCoords = new Float64Array(2 * a21), z7.outNum = 0, z7.outGeometries = [], z7.outTransforms = [], z7.outMaterials = [], this._create3DShapeGeometries(z7), this._logGeometryCreationWarnings(z7.renderData, i17.rings, "rings", "WaterSymbol3DLayer"), 0 === z7.outNum)
      return null;
    this._createUVCoordsFromVertices(z7.uvCoords, z7.renderData.mapPosition, a21, this._context.elevationProvider.spatialReference);
    const n24 = new O5({ geometries: z7.outGeometries, materials: z7.outMaterials, transformations: z7.outTransforms, castShadow: false, metadata: { layerUid: this._context.layer.uid, graphicUid: o22 } }), s16 = new p14(this, n24, z7.outGeometries, null, null, p13, t20);
    return s16.alignedSampledElevation = z7.renderData.sampledElevation, s16.needsElevationUpdates = g7(t20.mode), s16;
  }
  _createUVCoordsFromVertices(e25, t20, r24, o22) {
    const a21 = z(o22);
    D(I6);
    for (let i17 = 0; i17 < r24; i17++)
      r7(W5, t20[3 * i17 + 0], t20[3 * i17 + 1]), m5(I6, W5);
    l2(I6, I6, a21);
    const n24 = I6[0] % V7.unitSizeOfTexture, l26 = I6[1] % V7.unitSizeOfTexture;
    F10[0] = I6[0] - n24, F10[1] = I6[1] - l26;
    for (let i17 = 0; i17 < r24; i17++)
      e25[2 * i17 + 0] = (t20[3 * i17 + 0] * a21 - F10[0]) / V7.unitSizeOfTexture, e25[2 * i17 + 1] = (t20[3 * i17 + 1] * a21 - F10[1]) / V7.unitSizeOfTexture;
  }
  _create3DShapeGeometries(e25) {
    const r24 = e25.renderData.polygons, i17 = e25.uvCoords;
    for (const { count: s16, index: l26, position: u16, mapPosition: c21, holeIndices: m15 } of r24) {
      if (r(this._context.clippingExtent) && (B(k7), M3(k7, c21), !R(k7, this._context.clippingExtent)))
        continue;
      const r25 = x3(c21, m15, 3);
      if (0 === r25.length)
        continue;
      const h18 = new Uint32Array(r25), d22 = new Float64Array(i17.buffer, 2 * l26 * i17.BYTES_PER_ELEMENT, 2 * s16), f22 = l22({ indices: h18, attributeData: { position: u16, uv0: d22, mapPosition: c21 } });
      e25.outGeometries.push(f22), e25.outMaterials.push(e2(this._material)), e25.outTransforms.push(o7), e25.outNum++;
    }
  }
  _createAsOverlay(e25) {
    const t20 = m12(e25.geometry);
    if (t(t20))
      return null;
    e2(this._material).renderPriority = this._renderPriority, Y4.renderData = f15(t20, this._context.overlaySR);
    const i17 = Y4.renderData.position.length / 3;
    return Y4.uvCoords = new Float64Array(2 * i17), Y4.outNum = 0, Y4.outGeometries = [], Y4.outBoundingBox = B(), Y4.layerUid = this._context.layer.uid, Y4.graphicsUid = e25.uid, this._createAsOverlayWater(Y4), this._logGeometryCreationWarnings(Y4.renderData, t20.rings, "rings", "WaterSymbol3DLayer"), 0 === Y4.outNum ? null : (this._createUVCoordsFromVertices(Y4.uvCoords, Y4.renderData.position, i17, this._context.overlaySR), Y4.outNum > 0 ? new u13(this, Y4.outGeometries, Y4.outBoundingBox, this._context.drapeSourceRenderer) : null);
  }
  _createAsOverlayWater(e25) {
    const t20 = e25.uvCoords, r24 = e25.renderData.polygons;
    for (const { position: i17, holeIndices: n24, index: s16, count: l26 } of r24) {
      if (B(k7), M3(k7, i17), !R(k7, this._context.clippingExtent))
        continue;
      f3(e25.outBoundingBox, k7);
      const r25 = x3(i17, n24, 3);
      if (0 === r25.length)
        continue;
      const u16 = new Uint32Array(r25), c21 = new Float64Array(t20.buffer, 2 * s16 * t20.BYTES_PER_ELEMENT, 2 * l26), h18 = l22({ indices: u16, attributeData: { position: i17, uv0: c21 } }), d22 = new T4(h18, e2(this._material), { layerUid: e25.layerUid, graphicUid: e25.graphicsUid }), _14 = k7;
      r4(d22.boundingSphere, 0.5 * (_14[0] + _14[3]), 0.5 * (_14[1] + _14[4]), 0, 0.5 * Math.sqrt((_14[3] - _14[0]) * (_14[3] - _14[0]) + (_14[4] - _14[1]) * (_14[4] - _14[1]))), e25.outGeometries.push(d22), e25.outNum++;
    }
  }
  static headingVectorFromAngle(e25) {
    const t20 = n8(), r24 = o2(e25);
    return t20[0] = Math.sin(r24), t20[1] = Math.cos(r24), t20;
  }
  test() {
    return { ...super.test(), create3DShape: (e25) => this._createAs3DShape(e25.graphic, e25.elevationContext, e25.graphicUid), ensureMaterial: () => this.ensureMaterial() };
  }
};
V7.unitSizeOfTexture = 100, V7.elevationModeChangeTypes = { definedChanged: x5.RECREATE, staysOnTheGround: x5.NONE, onTheGroundChanged: x5.RECREATE };
var F10 = n8();
var I6 = u5();
var W5 = n8();
var k7 = a3();
var z7 = { renderData: null, uvCoords: null, outNum: 0, outBoundingBox: null, outGeometries: null, outMaterials: null, outTransforms: null };
var Y4 = { renderData: null, uvCoords: null, outNum: 0, outBoundingBox: null, outGeometries: null, outMaterials: null, outTransforms: null };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolLayerFactory.js
var c20 = s.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayerFactory");
function l25(r24, o22, e25, t20) {
  const i17 = f21[r24.type] && f21[r24.type][o22.type] || n23[o22.type];
  return i17 ? new i17(r24, o22, e25, t20) : (c20.error("GraphicsLayerFactory#make", `unknown symbol type ${o22.type}`), null);
}
var n23 = { icon: ue2, object: me4, line: K3, path: ae3, fill: W4, extrude: J4, text: U6, water: V7 };
var f21 = { "mesh-3d": { fill: me3 } };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbol.js
var d21 = class extends a14 {
  constructor(e25, t20, s16) {
    super(t20.schedule), this._symbol = e25, this._context = t20, this._backgroundLayers = s16, this._destroyed = false, this.symbolLayers = new Array(), this.referenced = 0, this._extentPadding = 0;
  }
  set symbol(e25) {
    this._symbol = e25;
    for (let s16 = 0; s16 < e25.symbolLayers.length; s16++) {
      const r24 = this.symbolLayers[s16];
      t(r24) || (r24.symbol = e25, r24.symbolLayer = e25.symbolLayers.items[s16]);
    }
  }
  get symbol() {
    return this._symbol;
  }
  async doLoad(t20) {
    let r24 = this._symbol.symbolLayers;
    this._extentPadding = 0, this._backgroundLayers && (r24 = this._backgroundLayers.concat(r24));
    const i17 = r24.length;
    for (; this.symbolLayers.length < r24.length; )
      this.symbolLayers.push(null);
    this.symbolLayers.length = r24.length;
    const n24 = [];
    for (let e25 = 0; e25 < i17; e25++) {
      const s16 = r24.getItemAt(e25);
      if (false === s16.enabled)
        continue;
      p20.renderPriority = 1 - (1 + e25) / i17, p20.renderPriorityStep = 1 / i17, p20.ignoreDrivers = s16._ignoreDrivers;
      const a21 = l25(this.symbol, s16, this._context, p20);
      n24.push(d(t20, () => {
        this.symbolLayers[e25] = null, a21.destroy();
      })), this.symbolLayers[e25] = a21;
    }
    await n6(this.symbolLayers, async (e25, t21) => {
      if (r(e25))
        try {
          await e25.load(), this._extentPadding += Math.max(this._extentPadding, e25.extentPadding);
        } catch {
          this.symbolLayers[t21] = null;
        }
    });
    for (const e25 of n24)
      e25 == null ? void 0 : e25.remove();
    if (n24.length = 0, f(t20), this.symbolLayers.length && !this.symbolLayers.some((e25) => !!e25))
      throw new Error();
  }
  getSymbolLayerSize(e25) {
    const t20 = this.symbolLayers[e25];
    return r(t20) ? t20.getCachedSize() : null;
  }
  get extentPadding() {
    return this._extentPadding;
  }
  createGraphics3DGraphic(e25, t20) {
    const r24 = e25.graphic, o22 = new Array(this.symbolLayers.length);
    for (let i17 = 0; i17 < this.symbolLayers.length; i17++) {
      const t21 = this.symbolLayers[i17];
      o22[i17] = r(t21) ? t21.createGraphics3DGraphic(e25) : null;
    }
    const a21 = this._context.arcade || this._context.featureExpressionInfoContext && this._context.featureExpressionInfoContext.arcade && this._context.featureExpressionInfoContext.arcade.modules || null;
    return new B4(r24, t20 || this, o22, e25.layer, a21);
  }
  get complexity() {
    return d13(this.symbolLayers.map((e25) => m(e25, "complexity")));
  }
  globalPropertyChanged(e25, t20) {
    const r24 = this.symbolLayers.length;
    for (let o22 = 0; o22 < r24; o22++) {
      const r25 = this.symbolLayers[o22], a21 = (e26) => {
        const t21 = e26.graphics[o22];
        return t21 instanceof p14 ? t21 : null;
      };
      if (r(r25) && !r25.globalPropertyChanged(e25, t20, a21))
        return false;
    }
    return true;
  }
  applyRendererDiff(e25, t20) {
    return this.loadStatus !== e17.LOADED ? e16.Recreate_Symbol : this.symbolLayers.reduce((r24, o22) => r24 !== e16.Recreate_Symbol && r(o22) ? Math.min(r24, o22.applyRendererDiff(e25, t20)) : r24, e16.Fast_Update);
  }
  prepareSymbolPatch(e25) {
    if (this.loadStatus === e17.FAILED)
      return;
    if ("partial" !== e25.diff.type)
      return;
    const r24 = e25.diff.diff;
    if (!r24.symbolLayers || "partial" !== r24.symbolLayers.type)
      return;
    const o22 = r24.symbolLayers.diff;
    this.symbolLayers.forEach((r25, a21) => {
      if (t(r25))
        return;
      const i17 = o22[a21];
      if (i17) {
        const t20 = { diff: i17, graphics3DGraphicPatches: [], symbolLayerStatePatches: [] };
        r25.prepareSymbolLayerPatch(t20), e25.symbolStatePatches.push(...t20.symbolLayerStatePatches), t20.graphics3DGraphicPatches.length && e25.graphics3DGraphicPatches.push((e26, r26) => {
          const o23 = e26.graphics[a21];
          r(o23) && t20.graphics3DGraphicPatches.forEach((e27) => e27(o23, r26));
        });
      }
    });
  }
  updateGeometry(e25, s16) {
    for (let r24 = 0; r24 < this.symbolLayers.length; r24++) {
      const o22 = this.symbolLayers[r24];
      if (t(o22))
        continue;
      const a21 = e25.graphics[r24];
      if (t(a21) || !o22.updateGeometry(a21, s16))
        return false;
    }
    return true;
  }
  onRemoveGraphic(e25) {
    for (let r24 = 0; r24 < this.symbolLayers.length; r24++) {
      const o22 = this.symbolLayers[r24];
      if (t(o22))
        continue;
      const a21 = e25.graphics[r24];
      r(a21) && o22.onRemoveGraphic(a21);
    }
  }
  getFastUpdateStatus() {
    let e25 = 0, s16 = 0, r24 = 0;
    return this.symbolLayers.forEach((o22) => {
      t(o22) || (o22.loadStatus === e17.LOADING ? e25++ : o22.isFastUpdatesEnabled() ? r24++ : s16++);
    }), { loading: e25, slow: s16, fast: r24 };
  }
  destroy() {
    if (this.destroyed)
      console.error("Graphics3DSymbol.destroy called when already destroyed!");
    else {
      super.destroy();
      for (const e25 of this.symbolLayers)
        r(e25) && e25.destroy();
      this.symbolLayers.length = 0, this._destroyed = true;
    }
  }
  get destroyed() {
    return this._destroyed;
  }
};
var p20 = { renderPriority: 0, renderPriorityStep: 1, ignoreDrivers: false };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DWebStyleSymbol.js
var e24 = class extends a14 {
  constructor(t20, s16, r24) {
    super(s16), this.symbol = t20, this.convert = r24, this.graphics3DSymbol = null, this.referenced = 0;
  }
  getSymbolLayerSize(s16) {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.getSymbolLayerSize(s16) : null;
  }
  get symbolLayers() {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.symbolLayers : [];
  }
  get extentPadding() {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.extentPadding : 0;
  }
  async doLoad(s16) {
    const r24 = await this.symbol.fetchSymbol({ signal: s16 });
    r24.id = this.symbol.id, this.graphics3DSymbol = this.convert(r24), r(this.graphics3DSymbol) && await this.graphics3DSymbol.load();
  }
  createGraphics3DGraphic(s16) {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.createGraphics3DGraphic(s16, this) : null;
  }
  get complexity() {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.complexity : b5;
  }
  globalPropertyChanged(s16, r24) {
    return !!r(this.graphics3DSymbol) && this.graphics3DSymbol.globalPropertyChanged(s16, r24);
  }
  applyRendererDiff(r24, i17) {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.applyRendererDiff(r24, i17) : e16.Recreate_Symbol;
  }
  prepareSymbolPatch(s16) {
    r(this.graphics3DSymbol) && this.graphics3DSymbol.prepareSymbolPatch(s16);
  }
  updateGeometry(s16, r24) {
    return !!r(this.graphics3DSymbol) && this.graphics3DSymbol.updateGeometry(s16, r24);
  }
  onRemoveGraphic() {
  }
  getFastUpdateStatus() {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.getFastUpdateStatus() : { loading: 1, fast: 0, slow: 0 };
  }
  destroy() {
    r(this.graphics3DSymbol) && this.graphics3DSymbol.destroy(), this.graphics3DSymbol = void 0, super.destroy();
  }
  get destroyed() {
    return void 0 === this.graphics3DSymbol;
  }
};

export {
  n12 as n,
  a13 as a,
  E9 as E,
  C3 as C,
  r15 as r,
  e16 as e,
  e17 as e2,
  P5 as P,
  y2 as y,
  e19 as e3,
  a17 as a2,
  s9 as s,
  s10 as s2,
  c16 as c,
  n17 as n2,
  s11 as s3,
  a19 as a3,
  d21 as d,
  e24 as e4
};
//# sourceMappingURL=chunk-PUR7HIYZ.js.map
