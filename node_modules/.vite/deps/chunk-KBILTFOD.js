import {
  n as n3
} from "./chunk-POPR7XUB.js";
import {
  o
} from "./chunk-P6G64ARX.js";
import {
  r as r2
} from "./chunk-2HDG7SIE.js";
import {
  n as n4,
  r as r3
} from "./chunk-ACJD5XFJ.js";
import {
  n as n2
} from "./chunk-6DWU2ZQF.js";
import {
  m as m2
} from "./chunk-HVM5D6S5.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  l as l2
} from "./chunk-FVPTCNCX.js";
import {
  r
} from "./chunk-ZIHDQYKE.js";
import {
  l,
  u2 as u
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  E,
  f
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  S
} from "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";

// node_modules/@arcgis/core/ground/NavigationConstraint.js
var t;
var p = t = class extends l {
  constructor(o2) {
    super(o2), this.type = "none";
  }
  clone() {
    return new t({ type: this.type });
  }
};
e([r2({ none: "none", stayAbove: "stay-above" })], p.prototype, "type", void 0), p = t = e([n("esri.ground.NavigationConstraint")], p);

// node_modules/@arcgis/core/Ground.js
var w;
var C = s.getLogger("esri.Ground");
var S2 = w = class extends u(m2) {
  constructor(r4) {
    super(r4), this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new j();
    const e2 = (r5) => {
      r5.parent && r5.parent !== this && "remove" in r5.parent && r5.parent.remove(r5), r5.parent = this, "elevation" !== r5.type && "base-elevation" !== r5.type && C.error(`Layer '${r5.title}, id:${r5.id}' of type '${r5.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, t2 = (r5) => {
      r5.parent = null;
    };
    this.layers.on("after-add", (r5) => e2(r5.item)), this.layers.on("after-remove", (r5) => t2(r5.item));
  }
  initialize() {
    this.when().catch((r4) => {
      C.error("#load()", "Failed to load ground", r4);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const r4 = this.layers.removeAll();
    for (const e2 of r4)
      e2.destroy();
    this.layers.destroy();
  }
  normalizeCtorArgs(r4) {
    return r4 && "resourceInfo" in r4 && (this._set("resourceInfo", r4.resourceInfo), delete (r4 = { ...r4 }).resourceInfo), r4;
  }
  set layers(r4) {
    this._set("layers", n2(r4, this._get("layers")));
  }
  writeLayers(r4, e2, o2, t2) {
    const i = [];
    r4 ? (t2 = { ...t2, layerContainerType: "ground" }, r4.forEach((r5) => {
      if ("write" in r5) {
        const e3 = {};
        o(r5)().write(e3, t2) && i.push(e3);
      } else
        t2 && t2.messages && t2.messages.push(new s2("layer:unsupported", `Layers (${r5.title}, ${r5.id}) of type '${r5.declaredClass}' cannot be persisted in the ground`, { layer: r5 }));
    }), e2.layers = i) : e2.layers = i;
  }
  load(r4) {
    return this.addResolvingPromise(this._loadFromSource(r4)), Promise.resolve(this);
  }
  loadAll() {
    return n3(this, (r4) => {
      r4(this.layers);
    });
  }
  async queryElevation(r4, e2) {
    await this.load({ signal: e2 == null ? void 0 : e2.signal });
    const { ElevationQuery: o2 } = await import("./ElevationQuery-OWCJHJ4T.js");
    f(e2);
    const t2 = new o2(), s3 = this.layers.filter(L).toArray();
    return t2.queryAll(s3, r4, e2);
  }
  async createElevationSampler(r4, e2) {
    await this.load({ signal: e2 == null ? void 0 : e2.signal });
    const { ElevationQuery: o2 } = await import("./ElevationQuery-OWCJHJ4T.js");
    f(e2);
    const t2 = new o2(), s3 = this.layers.filter(L).toArray();
    return t2.createSamplerAll(s3, r4, e2);
  }
  clone() {
    const r4 = { opacity: this.opacity, surfaceColor: m(this.surfaceColor), navigationConstraint: m(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (r4.loadStatus = "loaded"), new w({ resourceInfo: this.resourceInfo }).set(r4);
  }
  read(r4, e2) {
    this.resourceInfo || this._set("resourceInfo", { data: r4, context: e2 }), super.read(r4, e2);
  }
  _loadFromSource(r4) {
    const e2 = this.resourceInfo;
    return e2 ? this._loadLayersFromJSON(e2.data, e2.context, r4) : Promise.resolve(null);
  }
  _loadLayersFromJSON(r4, e2, o2) {
    const t2 = e2 && e2.origin || "web-scene", s3 = e2 && e2.portal || null, a = e2 && e2.url || null;
    return import("./layersCreator-25L6KWMN.js").then(({ populateOperationalLayers: e3 }) => {
      f(o2);
      const i = [];
      if (r4.layers && Array.isArray(r4.layers)) {
        const o3 = { context: { origin: t2, url: a, portal: s3, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
        i.push(e3(this.layers, r4.layers, o3));
      }
      return E(i);
    }).then(() => {
    });
  }
};
function I(r4) {
  return r4 && "createElevationSampler" in r4;
}
function L(r4) {
  return "elevation" === r4.type || I(r4);
}
e([d({ json: { read: false } })], S2.prototype, "layers", null), e([r("layers")], S2.prototype, "writeLayers", null), e([d({ readOnly: true })], S2.prototype, "resourceInfo", void 0), e([d({ type: Number, nonNullable: true, range: { min: 0, max: 1 }, json: { type: S, read: { reader: r3, source: "transparency" }, write: { writer: (r4, e2) => {
  e2.transparency = n4(r4);
}, target: "transparency" } } })], S2.prototype, "opacity", void 0), e([d({ type: l2, json: { type: [S], write: (r4, e2) => {
  e2.surfaceColor = r4.toJSON().slice(0, 3);
} } })], S2.prototype, "surfaceColor", void 0), e([d({ type: p, json: { write: true } })], S2.prototype, "navigationConstraint", void 0), S2 = w = e([n("esri.Ground")], S2);
var A = S2;

export {
  A
};
//# sourceMappingURL=chunk-KBILTFOD.js.map
