import {
  y
} from "./chunk-JYR7GBAU.js";
import {
  e as e3
} from "./chunk-CC32E45Q.js";
import {
  n
} from "./chunk-QKRZMDWG.js";
import {
  i
} from "./chunk-2AGPHSDM.js";
import {
  a as a2
} from "./chunk-KVF4M6PZ.js";
import {
  c2 as c,
  l as l3,
  x
} from "./chunk-TADZYUVR.js";
import {
  e as e2,
  u
} from "./chunk-NWRK6QLX.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  l as l2
} from "./chunk-FVPTCNCX.js";
import {
  l
} from "./chunk-AIRC226G.js";
import {
  a,
  e,
  m,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/symbols/support/gfxUtils.js
var s = "picture-fill";
var l4 = "simple-fill";
var a3 = "simple-line";
var c2 = "simple-marker";
var m2 = "text";
var u2 = "cim";
var d = new e3(1e3);
function b(t2) {
  const r2 = t2.style;
  let o = null;
  if (t2)
    switch (t2.type) {
      case c2:
        "cross" !== r2 && "x" !== r2 && (o = t2.color);
        break;
      case l4:
        "solid" === r2 ? o = t2.color : "none" !== r2 && (o = { type: "pattern", x: 0, y: 0, src: a2(`esri/symbols/patterns/${r2}.png`), width: 5, height: 5 });
        break;
      case s:
        o = { type: "pattern", src: t2.url, width: u(t2.width) * t2.xscale, height: u(t2.height) * t2.yscale, x: u(t2.xoffset), y: u(t2.yoffset) };
        break;
      case m2:
        o = t2.color;
        break;
      case u2:
        o = y(t2);
    }
  return o;
}
function w(e4, t2) {
  const o = e4 + "-" + t2;
  return void 0 !== d.get(o) ? Promise.resolve(d.get(o)) : U(e4, { responseType: "image" }).then((e5) => {
    const r2 = e5.data, n2 = r2.naturalWidth, i2 = r2.naturalHeight, s2 = document.createElement("canvas");
    s2.width = n2, s2.height = i2;
    const l5 = s2.getContext("2d");
    l5.fillStyle = t2, l5.fillRect(0, 0, n2, i2), l5.globalCompositeOperation = "destination-in", l5.drawImage(r2, 0, 0);
    const a4 = s2.toDataURL();
    return d.put(o, a4), a4;
  });
}
function j(e4) {
  if (!e4)
    return null;
  let t2;
  switch (e4.type) {
    case l4:
    case s:
    case c2:
      t2 = j(e4.outline);
      break;
    case a3: {
      const r2 = u(e4.width);
      "none" !== e4.style && 0 !== r2 && (t2 = { color: e4.color, style: x2(e4.style), width: r2, cap: e4.cap, join: "miter" === e4.join ? u(e4.miterLimit) : e4.join });
      break;
    }
    default:
      t2 = null;
  }
  return t2;
}
var x2 = (() => {
  const e4 = {};
  return (t2) => {
    if (e4[t2])
      return e4[t2];
    const r2 = t2.replace(/-/g, "");
    return e4[t2] = r2, r2;
  };
})();
var k = new l2([128, 128, 128]);

// node_modules/@arcgis/core/symbols/support/utils.js
var p = /\/resource\/(.*?)\.svg$/;
var h = new l2("white");
function b2(e4) {
  const t2 = e4.symbolLayers && e4.symbolLayers.length;
  if (!t2)
    return;
  const r2 = e4.symbolLayers.getItemAt(t2 - 1);
  return "outline" in r2 ? m(r2, "outline", "size") : void 0;
}
function w2(e4) {
  if (!e4)
    return 0;
  if (c(e4)) {
    const t2 = b2(e4);
    return r(t2) ? t2 : 0;
  }
  const r2 = j(e4);
  return r2 && e2(r2.width) || 0;
}
function d2(e4) {
  if (t(e4) || !("symbolLayers" in e4) || t(e4.symbolLayers))
    return false;
  switch (e4.type) {
    case "point-3d":
      return e4.symbolLayers.some((e5) => "object" === e5.type);
    case "line-3d":
      return e4.symbolLayers.some((e5) => "path" === e5.type);
    case "polygon-3d":
      return e4.symbolLayers.some((e5) => "object" === e5.type || "extrude" === e5.type);
    default:
      return false;
  }
}
function g(e4, t2) {
  const r2 = t2.resource.href;
  return !a("esri-canvas-svg-support") && e4.styleOrigin && p.test(r2) ? r2.replace(p, "/resource/png/$1.png") : r2;
}
function j2(o, n2) {
  if (!o)
    return null;
  let l5 = null;
  return c(o) ? l5 = k2(o) : x(o) && (l5 = o.color ? new l2(o.color) : null), l5 ? L(l5, n2) : null;
}
function k2(t2) {
  const r2 = t2.symbolLayers;
  if (!r2)
    return null;
  let o = null;
  return r2.forEach((e4) => {
    "object" === e4.type && null != e4.resource.href || (o = "water" === e4.type ? e(e4.color) : r(e4.material) ? e(e4.material.color) : null);
  }), o ? new l2(o) : null;
}
function L(t2, r2) {
  if (null == r2)
    return t2;
  const o = t2.toRgba();
  return o[3] = o[3] * r2, new l2(o);
}
function z(e4, t2, r2) {
  const o = e4.symbolLayers;
  if (!o)
    return;
  const n2 = (e5) => {
    const o2 = r(e5) ? e5 : null;
    return L(t2 = t2 || o2 || null != r2 && h, r2);
  };
  o.forEach((e5) => {
    if ("object" !== e5.type || null == e5.resource.href || t2)
      if ("water" === e5.type)
        e5.color = n2(e5.color);
      else {
        const t3 = r(e5.material) ? e5.material.color : null, o2 = n2(t3);
        t(e5.material) ? e5.material = new l3({ color: o2 }) : e5.material.color = o2, null != r2 && "outline" in e5 && r(e5.outline) && r(e5.outline.color) && (e5.outline.color = L(e5.outline.color, r2));
      }
  });
}
function v(e4, t2, r2) {
  (t2 = t2 || e4.color) && (e4.color = L(t2, r2)), null != r2 && "outline" in e4 && e4.outline && e4.outline.color && (e4.outline.color = L(e4.outline.color, r2));
}
function x3(o, n2, l5) {
  o && (n2 || null != l5) && (n2 && (n2 = new l2(n2)), c(o) ? z(o, n2, l5) : x(o) && v(o, n2, l5));
}
async function S(e4, t2) {
  const r2 = e4.symbolLayers;
  r2 && await n(r2, async (e5) => U2(e5, t2));
}
async function U2(e4, t2) {
  switch (e4.type) {
    case "extrude":
      R(e4, t2);
      break;
    case "icon":
    case "line":
    case "text":
      O(e4, t2);
      break;
    case "path":
      A(e4, t2);
      break;
    case "object":
      await $(e4, t2);
  }
}
function O(e4, t2) {
  const r2 = E(t2);
  r(r2) && (e4.size = r2);
}
function E(e4) {
  for (const t2 of e4)
    if ("number" == typeof t2)
      return t2;
  return null;
}
function R(e4, t2) {
  e4.size = "number" == typeof t2[2] ? t2[2] : 0;
}
async function $(e4, t2) {
  const { resourceSize: r2, symbolSize: o } = await D(e4), n2 = C(t2, r2, o);
  e4.width = I(t2[0], o[0], r2[0], n2), e4.depth = I(t2[1], o[1], r2[1], n2), e4.height = I(t2[2], o[2], r2[2], n2);
}
function A(e4, t2) {
  const r2 = C(t2, l, [e4.width, void 0, e4.height]);
  e4.width = I(t2[0], e4.width, 1, r2), e4.height = I(t2[2], e4.height, 1, r2);
}
function C(e4, t2, r2) {
  for (let o = 0; o < 3; o++) {
    const n2 = e4[o];
    switch (n2) {
      case "symbol-value":
        return null != r2[o] ? r2[o] / t2[o] : 1;
      case "proportional":
        break;
      default:
        if (n2 && t2[o])
          return n2 / t2[o];
    }
  }
  return 1;
}
async function D(e4) {
  const t2 = await import("./symbolLayerUtils-6U5VUJB4.js"), r2 = await t2.computeObjectLayerResourceSize(e4, 10), { width: o, height: n2, depth: l5 } = e4, i2 = [o, l5, n2];
  let s2 = 1;
  for (let c3 = 0; c3 < 3; c3++)
    if (null != i2[c3]) {
      s2 = i2[c3] / r2[c3];
      break;
    }
  for (let c3 = 0; c3 < 3; c3++)
    null == i2[c3] && (i2[c3] = r2[c3] * s2);
  return { resourceSize: r2, symbolSize: i2 };
}
function I(e4, t2, r2, o) {
  switch (e4) {
    case "proportional":
      return r2 * o;
    case "symbol-value":
      return null != t2 ? t2 : r2;
    default:
      return e4;
  }
}
function J(e4, t2) {
  const r2 = E(t2);
  if (!t(r2))
    switch (e4.type) {
      case "simple-marker":
        e4.size = r2;
        break;
      case "picture-marker": {
        const t3 = e4.width / e4.height;
        t3 > 1 ? (e4.width = r2, e4.height = r2 * t3) : (e4.width = r2 * t3, e4.height = r2);
        break;
      }
      case "simple-line":
        e4.width = r2;
        break;
      case "text":
        e4.font.size = r2;
    }
}
async function M(e4, o) {
  if (e4 && o)
    return c(e4) ? S(e4, o) : void (x(e4) && J(e4, o));
}
function N(e4, o, n2) {
  if (e4 && null != o)
    if (c(e4)) {
      const t2 = e4.symbolLayers;
      t2 && t2.forEach((e5) => {
        if (e5 && "object" === e5.type)
          switch (n2) {
            case "tilt":
              e5.tilt = o;
              break;
            case "roll":
              e5.roll = o;
              break;
            default:
              e5.heading = o;
          }
      });
    } else
      x(e4) && ("simple-marker" !== e4.type && "picture-marker" !== e4.type && "text" !== e4.type || (e4.angle = o));
}
function q(e4) {
  if (!e4)
    return null;
  const t2 = e4.effects.filter((e5) => "bloom" !== e5.type).map((e5) => e5.toJSON());
  return i(t2);
}

export {
  b,
  w,
  j,
  x2 as x,
  k,
  w2,
  d2 as d,
  g,
  j2,
  x3 as x2,
  M,
  N,
  q
};
//# sourceMappingURL=chunk-RRFFPL7N.js.map
