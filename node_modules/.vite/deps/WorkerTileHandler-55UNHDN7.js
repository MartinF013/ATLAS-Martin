import {
  a as a2,
  d,
  l,
  n,
  o
} from "./chunk-XP3NTQW6.js";
import "./chunk-UJS24K6P.js";
import {
  C,
  t as t2
} from "./chunk-RB2H3SKO.js";
import {
  T,
  l as l3,
  m as m2,
  t as t5
} from "./chunk-57NDR3D3.js";
import {
  a as a4,
  l as l2,
  m,
  n as n3,
  o as o2,
  p as p2,
  u
} from "./chunk-PNNMRFHO.js";
import {
  s,
  t as t3
} from "./chunk-4V2P7IXX.js";
import {
  P,
  a as a3,
  b,
  f,
  h,
  n as n2,
  r as r2,
  t as t4
} from "./chunk-SF7Z6XNR.js";
import "./chunk-HH3D3A65.js";
import "./chunk-YDPQRKY4.js";
import "./chunk-CMKLTW5X.js";
import {
  o as o3
} from "./chunk-IYLBVJ6T.js";
import {
  I,
  L
} from "./chunk-YSQDB5AA.js";
import "./chunk-33INAWJA.js";
import "./chunk-FPMD6IB4.js";
import {
  x
} from "./chunk-RIOXX6J2.js";
import "./chunk-HB4HVKJV.js";
import {
  a
} from "./chunk-ZZY5IDKU.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import {
  t
} from "./chunk-5EQKHR4M.js";
import {
  g,
  p
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import {
  c
} from "./chunk-G5JBUC5N.js";
import {
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/ScriptUtils.js
function e(e3) {
  return 746 === e3 || 747 === e3 || !(e3 < 4352) && (e3 >= 12704 && e3 <= 12735 || (e3 >= 12544 && e3 <= 12591 || (e3 >= 65072 && e3 <= 65103 && !(e3 >= 65097 && e3 <= 65103) || (e3 >= 63744 && e3 <= 64255 || (e3 >= 13056 && e3 <= 13311 || (e3 >= 11904 && e3 <= 12031 || (e3 >= 12736 && e3 <= 12783 || (e3 >= 12288 && e3 <= 12351 && !(e3 >= 12296 && e3 <= 12305 || e3 >= 12308 && e3 <= 12319 || 12336 === e3) || (e3 >= 13312 && e3 <= 19903 || (e3 >= 19968 && e3 <= 40959 || (e3 >= 12800 && e3 <= 13055 || (e3 >= 12592 && e3 <= 12687 || (e3 >= 43360 && e3 <= 43391 || (e3 >= 55216 && e3 <= 55295 || (e3 >= 4352 && e3 <= 4607 || (e3 >= 44032 && e3 <= 55215 || (e3 >= 12352 && e3 <= 12447 || (e3 >= 12272 && e3 <= 12287 || (e3 >= 12688 && e3 <= 12703 || (e3 >= 12032 && e3 <= 12255 || (e3 >= 12784 && e3 <= 12799 || (e3 >= 12448 && e3 <= 12543 && 12540 !== e3 || (e3 >= 65280 && e3 <= 65519 && !(65288 === e3 || 65289 === e3 || 65293 === e3 || e3 >= 65306 && e3 <= 65310 || 65339 === e3 || 65341 === e3 || 65343 === e3 || e3 >= 65371 && e3 <= 65503 || 65507 === e3 || e3 >= 65512 && e3 <= 65519) || (e3 >= 65104 && e3 <= 65135 && !(e3 >= 65112 && e3 <= 65118 || e3 >= 65123 && e3 <= 65126) || (e3 >= 5120 && e3 <= 5759 || (e3 >= 6320 && e3 <= 6399 || (e3 >= 65040 && e3 <= 65055 || (e3 >= 19904 && e3 <= 19967 || (e3 >= 40960 && e3 <= 42127 || e3 >= 42128 && e3 <= 42191)))))))))))))))))))))))))))));
}
function c2(e3) {
  return !(e3 < 11904) && (e3 >= 12704 && e3 <= 12735 || (e3 >= 12544 && e3 <= 12591 || (e3 >= 65072 && e3 <= 65103 || (e3 >= 63744 && e3 <= 64255 || (e3 >= 13056 && e3 <= 13311 || (e3 >= 11904 && e3 <= 12031 || (e3 >= 12736 && e3 <= 12783 || (e3 >= 12288 && e3 <= 12351 || (e3 >= 13312 && e3 <= 19903 || (e3 >= 19968 && e3 <= 40959 || (e3 >= 12800 && e3 <= 13055 || (e3 >= 65280 && e3 <= 65519 || (e3 >= 12352 && e3 <= 12447 || (e3 >= 12272 && e3 <= 12287 || (e3 >= 12032 && e3 <= 12255 || (e3 >= 12784 && e3 <= 12799 || (e3 >= 12448 && e3 <= 12543 || (e3 >= 65040 && e3 <= 65055 || (e3 >= 42128 && e3 <= 42191 || e3 >= 40960 && e3 <= 42127)))))))))))))))))));
}
function s2(e3) {
  switch (e3) {
    case 10:
    case 32:
    case 38:
    case 40:
    case 41:
    case 43:
    case 45:
    case 47:
    case 173:
    case 183:
    case 8203:
    case 8208:
    case 8211:
    case 8231:
      return true;
  }
  return false;
}
function a5(e3) {
  switch (e3) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
      return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TextShaping.js
var c3 = 24;
var h2 = 17;
var a6 = class {
  constructor(t8, e3, i, s6, o6, c4, h4) {
    this._glyphItems = t8, this._maxWidth = e3, this._lineHeight = i, this._letterSpacing = s6, this._hAnchor = o6, this._vAnchor = c4, this._justify = h4;
  }
  getShaping(o6, c4, h4) {
    const a9 = this._letterSpacing, l5 = this._lineHeight, r7 = this._justify, n5 = this._maxWidth, m3 = [];
    let f3 = 0, p4 = 0;
    const g3 = o6.length;
    for (let t8 = 0; t8 < g3; t8++) {
      const e3 = o6.charCodeAt(t8), i = h4 && e(e3);
      let c5;
      for (const t9 of this._glyphItems)
        if (c5 = t9[e3], c5)
          break;
      m3.push({ codePoint: e3, x: f3, y: p4, vertical: i, glyphMosaicItem: c5 }), c5 && (f3 += c5.metrics.advance + a9);
    }
    let y2 = f3;
    if (n5 > 0) {
      y2 = f3 / Math.max(1, Math.ceil(f3 / n5));
    }
    const d2 = o6.includes("â€‹"), x3 = [];
    for (let e3 = 0; e3 < g3 - 1; e3++) {
      const s6 = m3[e3].codePoint, o7 = c2(s6);
      if (s2(s6) || o7) {
        let t8 = 0;
        if (10 === s6)
          t8 -= 1e4;
        else if (o7 && d2)
          t8 += 150;
        else {
          40 !== s6 && 65288 !== s6 || (t8 += 50);
          const i = m3[e3 + 1].codePoint;
          41 !== i && 65289 !== i || (t8 += 50);
        }
        x3.push(this._buildBreak(e3 + 1, m3[e3].x, y2, x3, t8, false));
      }
    }
    const M = this._optimalBreaks(this._buildBreak(g3, f3, y2, x3, 0, true));
    let u4 = 0;
    const _ = c4 ? -l5 : l5;
    let I5 = 0;
    for (let t8 = 0; t8 < M.length; t8++) {
      const i = M[t8];
      let s6 = I5;
      for (; s6 < i && a5(m3[s6].codePoint); )
        m3[s6].glyphMosaicItem = null, ++s6;
      let o7 = i - 1;
      for (; o7 > s6 && a5(m3[o7].codePoint); )
        m3[o7].glyphMosaicItem = null, --o7;
      if (s6 <= o7) {
        const t9 = m3[s6].x;
        for (let i2 = s6; i2 <= o7; i2++)
          m3[i2].x -= t9, m3[i2].y = p4;
        let e3 = m3[o7].x;
        m3[o7].glyphMosaicItem && (e3 += m3[o7].glyphMosaicItem.metrics.advance), u4 = Math.max(e3, u4), r7 && this._applyJustification(m3, s6, o7);
      }
      I5 = i, p4 += _;
    }
    if (m3.length > 0) {
      const t8 = M.length - 1, e3 = (r7 - this._hAnchor) * u4;
      let i = (-this._vAnchor * (t8 + 1) + 0.5) * l5;
      c4 && t8 && (i += t8 * l5);
      for (const s6 of m3)
        s6.x += e3, s6.y += i;
    }
    return m3.filter((t8) => t8.glyphMosaicItem);
  }
  static getTextBox(t8, e3) {
    if (!t8.length)
      return null;
    let i = 1 / 0, s6 = 1 / 0, o6 = 0, c4 = 0;
    for (const a9 of t8) {
      const t9 = a9.glyphMosaicItem.metrics.advance, l5 = a9.x, r7 = a9.y - h2, n5 = l5 + t9, m3 = r7 + e3;
      i = Math.min(i, l5), o6 = Math.max(o6, n5), s6 = Math.min(s6, r7), c4 = Math.max(c4, m3);
    }
    return { x: i, y: s6, width: o6 - i, height: c4 - s6 };
  }
  static getBox(t8) {
    if (!t8.length)
      return null;
    let e3 = 1 / 0, i = 1 / 0, s6 = 0, o6 = 0;
    for (const c4 of t8) {
      const { height: t9, left: h4, top: a9, width: l5 } = c4.glyphMosaicItem.metrics, r7 = c4.x, n5 = c4.y - (t9 - Math.abs(a9)), m3 = r7 + l5 + h4, f3 = n5 + t9;
      e3 = Math.min(e3, r7), s6 = Math.max(s6, m3), i = Math.min(i, n5), o6 = Math.max(o6, f3);
    }
    return { x: e3, y: i, width: s6 - e3, height: o6 - i };
  }
  static addDecoration(t8, e3) {
    const i = t8.length;
    if (0 === i)
      return;
    const s6 = 3;
    let c4 = t8[0].x + t8[0].glyphMosaicItem.metrics.left, h4 = t8[0].y;
    for (let l5 = 1; l5 < i; l5++) {
      const i2 = t8[l5];
      if (i2.y !== h4) {
        const a10 = t8[l5 - 1].x + t8[l5 - 1].glyphMosaicItem.metrics.left + t8[l5 - 1].glyphMosaicItem.metrics.width;
        t8.push({ codePoint: 0, x: c4, y: h4 + e3 - s6, vertical: false, glyphMosaicItem: { sdf: true, rect: new t2(4, 0, 4, 8), metrics: { width: a10 - c4, height: 2 + 2 * s6, left: 0, top: 0, advance: 0 }, page: 0, code: 0 } }), h4 = i2.y, c4 = i2.x + i2.glyphMosaicItem.metrics.left;
      }
    }
    const a9 = t8[i - 1].x + t8[i - 1].glyphMosaicItem.metrics.left + t8[i - 1].glyphMosaicItem.metrics.width;
    t8.push({ codePoint: 0, x: c4, y: h4 + e3 - s6, vertical: false, glyphMosaicItem: { sdf: true, rect: new t2(4, 0, 4, 8), metrics: { width: a9 - c4, height: 2 + 2 * s6, left: 0, top: 0, advance: 0 }, page: 0, code: 0 } });
  }
  _breakScore(t8, e3, i, s6) {
    const o6 = (t8 - e3) * (t8 - e3);
    return s6 ? t8 < e3 ? o6 / 2 : 2 * o6 : o6 + Math.abs(i) * i;
  }
  _buildBreak(t8, e3, i, s6, o6, c4) {
    let h4 = null, a9 = this._breakScore(e3, i, o6, c4);
    for (const l5 of s6) {
      const t9 = e3 - l5.x, s7 = this._breakScore(t9, i, o6, c4) + l5.score;
      s7 <= a9 && (h4 = l5, a9 = s7);
    }
    return { index: t8, x: e3, score: a9, previousBreak: h4 };
  }
  _optimalBreaks(t8) {
    return t8 ? this._optimalBreaks(t8.previousBreak).concat(t8.index) : [];
  }
  _applyJustification(t8, e3, i) {
    const s6 = t8[i], o6 = s6.vertical ? c3 : s6.glyphMosaicItem ? s6.glyphMosaicItem.metrics.advance : 0, h4 = (s6.x + o6) * this._justify;
    for (let c4 = e3; c4 <= i; c4++)
      t8[c4].x -= h4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/Placement.js
var x2 = 4096;
var w = 8;
var p3 = 0.5;
var y = 2;
var T2 = class {
  constructor(e3, t8, i = 0, n5 = -1, s6 = p3) {
    this.x = e3, this.y = t8, this.angle = i, this.segment = n5, this.minzoom = s6;
  }
};
var f2 = class {
  constructor(e3, t8, n5, s6, o6, a9 = p3, l5 = n2) {
    this.anchor = e3, this.labelAngle = t8, this.glyphAngle = n5, this.page = s6, this.alternateVerticalGlyph = o6, this.minzoom = a9, this.maxzoom = l5;
  }
};
var I2 = class {
  constructor(e3, t8, i, n5, s6, o6, a9, l5, h4, r7, c4, g3) {
    this.tl = e3, this.tr = t8, this.bl = i, this.br = n5, this.mosaicRect = s6, this.labelAngle = o6, this.minAngle = a9, this.maxAngle = l5, this.anchor = h4, this.minzoom = r7, this.maxzoom = c4, this.page = g3;
  }
};
var b2 = class {
  constructor(e3) {
    this.shapes = e3;
  }
};
var u2 = class {
  getIconPlacement(i, n5, s6) {
    const o6 = new t3(i.x, i.y), a9 = s6.rotationAlignment === l2.MAP, l5 = s6.keepUpright;
    let h4 = s6.rotate * f;
    a9 && (h4 += i.angle);
    const g3 = new b2([]);
    return s6.allowOverlap && s6.ignorePlacement || !o3 || (g3.iconColliders = []), this._addIconPlacement(g3, o6, n5, s6, h4), a9 && l5 && this._addIconPlacement(g3, o6, n5, s6, h4 + t4), g3;
  }
  _addIconPlacement(e3, t8, n5, s6, o6) {
    const a9 = n5.pixelRatio, l5 = n5.width / a9, h4 = n5.height / a9, c4 = s6.offset;
    let x3 = c4[0], d2 = c4[1];
    switch (s6.anchor) {
      case m.CENTER:
        x3 -= l5 / 2, d2 -= h4 / 2;
        break;
      case m.LEFT:
        d2 -= h4 / 2;
        break;
      case m.RIGHT:
        x3 -= l5, d2 -= h4 / 2;
        break;
      case m.TOP:
        x3 -= l5 / 2;
        break;
      case m.BOTTOM:
        x3 -= l5 / 2, d2 -= h4;
        break;
      case m.TOP_LEFT:
        break;
      case m.BOTTOM_LEFT:
        d2 -= h4;
        break;
      case m.TOP_RIGHT:
        x3 -= l5;
        break;
      case m.BOTTOM_RIGHT:
        x3 -= l5, d2 -= h4;
    }
    const w3 = n5.rect, y2 = 2 / a9, T4 = x3 - y2, f3 = d2 - y2, b4 = T4 + w3.width / a9, u4 = f3 + w3.height / a9, P2 = new t3(T4, f3), O = new t3(b4, u4), _ = new t3(T4, u4), k = new t3(b4, f3);
    if (0 !== o6) {
      const e4 = Math.cos(o6), t9 = Math.sin(o6);
      P2.rotate(e4, t9), O.rotate(e4, t9), _.rotate(e4, t9), k.rotate(e4, t9);
    }
    const M = new I2(P2, k, _, O, w3, o6, 0, 256, t8, p3, n2, 0);
    if (e3.shapes.push(M), (!s6.allowOverlap || !s6.ignorePlacement) && o3) {
      const n6 = s6.size, a10 = s6.padding, r7 = { xTile: t8.x, yTile: t8.y, dxPixels: x3 * n6 - a10, dyPixels: d2 * n6 - a10, hard: !s6.optional, partIndex: 0, width: l5 * n6 + 2 * a10, height: h4 * n6 + 2 * a10, angle: o6, minLod: p3, maxLod: n2 };
      e3.iconColliders.push(r7);
    }
  }
  getTextPlacement(n5, s6, o6, r7) {
    const x3 = new t3(n5.x, n5.y), d2 = r7.rotate * f, T4 = r7.rotationAlignment === l2.MAP, u4 = r7.keepUpright, P2 = r7.padding;
    let O = p3;
    const _ = !T4 ? 0 : n5.angle, k = n5.segment >= 0 && T4, M = r7.allowOverlap && r7.ignorePlacement ? null : [], E = [], G = 4, N = !k;
    let A2 = Number.POSITIVE_INFINITY, L2 = Number.NEGATIVE_INFINITY, z = A2, F = L2;
    const v = (k || T4) && u4, R = r7.size / c3;
    let B2 = false;
    for (const e3 of s6)
      if (e3.vertical) {
        B2 = true;
        break;
      }
    let H, V = 0, j = 0;
    if (!k && B2) {
      const e3 = a6.getTextBox(s6, r7.lineHeight * c3);
      switch (r7.anchor) {
        case m.LEFT:
          V = e3.height / 2, j = -e3.width / 2;
          break;
        case m.RIGHT:
          V = -e3.height / 2, j = e3.width / 2;
          break;
        case m.TOP:
          V = e3.height / 2, j = e3.width / 2;
          break;
        case m.BOTTOM:
          V = -e3.height / 2, j = -e3.width / 2;
          break;
        case m.TOP_LEFT:
          V = e3.height;
          break;
        case m.BOTTOM_LEFT:
          j = -e3.width;
          break;
        case m.TOP_RIGHT:
          j = e3.width;
          break;
        case m.BOTTOM_RIGHT:
          V = -e3.height;
      }
    }
    V += r7.offset[0] * c3, j += r7.offset[1] * c3;
    for (const e3 of s6) {
      const s7 = e3.glyphMosaicItem;
      if (!s7 || s7.rect.isEmpty)
        continue;
      const a9 = s7.rect, l5 = s7.metrics, c4 = s7.page;
      if (M && N) {
        if (void 0 !== H && H !== e3.y) {
          let e4, t8, s8, o7;
          B2 ? (e4 = -F + V, t8 = A2 + j, s8 = F - z, o7 = L2 - A2) : (e4 = A2 + V, t8 = z + j, s8 = L2 - A2, o7 = F - z);
          const a10 = { xTile: n5.x, yTile: n5.y, dxPixels: e4 * R - P2, dyPixels: t8 * R - P2, hard: !r7.optional, partIndex: 1, width: s8 * R + 2 * P2, height: o7 * R + 2 * P2, angle: d2, minLod: p3, maxLod: n2 };
          M.push(a10), A2 = Number.POSITIVE_INFINITY, L2 = Number.NEGATIVE_INFINITY, z = A2, F = L2;
        }
        H = e3.y;
      }
      const g3 = [];
      if (k) {
        const t8 = 0.5 * s7.metrics.width, i = (e3.x + l5.left - G + t8) * R * w;
        if (O = this._placeGlyph(n5, O, i, o6, n5.segment, 1, e3.vertical, c4, g3), u4 && (O = this._placeGlyph(n5, O, i, o6, n5.segment, -1, e3.vertical, c4, g3)), O >= y)
          break;
      } else
        g3.push(new f2(x3, _, _, c4, false)), T4 && u4 && g3.push(new f2(x3, _ + t4, _ + t4, c4, false));
      const b4 = e3.x + l5.left, C3 = e3.y - h2 - l5.top, S = b4 + l5.width, Y = C3 + l5.height;
      let q, U, D, J, K, Q, W, X;
      if (!k && B2)
        if (e3.vertical) {
          const e4 = (b4 + S) / 2 - l5.height / 2, t8 = (C3 + Y) / 2 + l5.width / 2;
          q = new t3(-t8 - G + V, e4 - G + j), U = new t3(q.x + a9.width, q.y + a9.height), D = new t3(q.x, U.y), J = new t3(U.x, q.y);
        } else
          q = new t3(-C3 + G + V, b4 - G + j), U = new t3(q.x - a9.height, q.y + a9.width), D = new t3(U.x, q.y), J = new t3(q.x, U.y);
      else
        q = new t3(b4 - G + V, C3 - G + j), U = new t3(q.x + a9.width, q.y + a9.height), D = new t3(q.x, U.y), J = new t3(U.x, q.y);
      for (const t8 of g3) {
        let i, s8, o7, h4;
        if (t8.alternateVerticalGlyph) {
          if (!K) {
            const e4 = (C3 + Y) / 2 + j;
            K = new t3((b4 + S) / 2 + V - l5.height / 2 - G, e4 + l5.width / 2 + G), Q = new t3(K.x + a9.height, K.y - a9.width), W = new t3(Q.x, K.y), X = new t3(K.x, Q.y);
          }
          i = K, s8 = W, o7 = X, h4 = Q;
        } else
          i = q, s8 = D, o7 = J, h4 = U;
        const c5 = C3, g4 = Y, x4 = t8.glyphAngle + d2;
        if (0 !== x4) {
          const e4 = Math.cos(x4), t9 = Math.sin(x4);
          i = i.clone(), s8 = s8.clone(), o7 = o7.clone(), h4 = h4.clone(), i.rotate(e4, t9), h4.rotate(e4, t9), s8.rotate(e4, t9), o7.rotate(e4, t9);
        }
        let w3 = 0, p4 = 256;
        if (k && B2 ? e3.vertical ? t8.alternateVerticalGlyph ? (w3 = 32, p4 = 96) : (w3 = 224, p4 = 32) : (w3 = 224, p4 = 96) : (w3 = 192, p4 = 64), E.push(new I2(i, o7, s8, h4, a9, t8.labelAngle, w3, p4, t8.anchor, t8.minzoom, t8.maxzoom, t8.page)), M && (!v || this._legible(t8.labelAngle))) {
          if (N)
            b4 < A2 && (A2 = b4), c5 < z && (z = c5), S > L2 && (L2 = S), g4 > F && (F = g4);
          else if (t8.minzoom < y) {
            const e4 = { xTile: n5.x, yTile: n5.y, dxPixels: (b4 + V) * R - P2, dyPixels: (c5 + V) * R - P2, hard: !r7.optional, partIndex: 1, width: (S - b4) * R + 2 * P2, height: (g4 - c5) * R + 2 * P2, angle: x4, minLod: t8.minzoom, maxLod: t8.maxzoom };
            M.push(e4);
          }
        }
      }
    }
    if (O >= y)
      return null;
    if (M && N) {
      let e3, t8, s7, o7;
      B2 ? (e3 = -F + V, t8 = A2 + j, s7 = F - z, o7 = L2 - A2) : (e3 = A2 + V, t8 = z + j, s7 = L2 - A2, o7 = F - z);
      const a9 = { xTile: n5.x, yTile: n5.y, dxPixels: e3 * R - P2, dyPixels: t8 * R - P2, hard: !r7.optional, partIndex: 1, width: s7 * R + 2 * P2, height: o7 * R + 2 * P2, angle: d2, minLod: p3, maxLod: n2 };
      M.push(a9);
    }
    const C2 = new b2(E);
    return M && M.length > 0 && (C2.textColliders = M), C2;
  }
  _legible(e3) {
    const t8 = h(e3);
    return t8 < 65 || t8 >= 193;
  }
  _placeGlyph(e3, n5, a9, l5, h4, r7, c4, g3, x3) {
    let d2 = r7;
    const w3 = d2 < 0 ? a3(e3.angle + t4, r2) : e3.angle;
    let p4 = 0;
    a9 < 0 && (d2 *= -1, a9 *= -1, p4 = t4), d2 > 0 && ++h4;
    let y2 = new t3(e3.x, e3.y), T4 = l5[h4], I5 = n2;
    if (l5.length <= h4)
      return I5;
    for (; ; ) {
      const e4 = T4.x - y2.x, t8 = T4.y - y2.y, i = Math.sqrt(e4 * e4 + t8 * t8), r8 = Math.max(a9 / i, n5), m3 = e4 / i, b4 = t8 / i, u4 = a3(Math.atan2(b4, m3) + p4, r2);
      if (x3.push(new f2(y2, w3, u4, g3, false, r8, I5)), c4 && x3.push(new f2(y2, w3, u4, g3, true, r8, I5)), r8 <= n5)
        return r8;
      y2 = T4.clone();
      do {
        if (h4 += d2, l5.length <= h4 || h4 < 0)
          return r8;
        T4 = l5[h4];
      } while (y2.isEqual(T4));
      let P2 = T4.x - y2.x, O = T4.y - y2.y;
      const _ = Math.sqrt(P2 * P2 + O * O);
      P2 *= i / _, O *= i / _, y2.x -= P2, y2.y -= O, I5 = r8;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/Feature.js
var t6;
!function(e3) {
  e3[e3.moveTo = 1] = "moveTo", e3[e3.lineTo = 2] = "lineTo", e3[e3.close = 7] = "close";
}(t6 || (t6 = {}));
var s3 = class {
  constructor(e3, t8) {
    this.values = {};
    const s6 = t8.keys, o6 = t8.values;
    for (; e3.next(); )
      switch (e3.tag()) {
        case 1:
          this.id = e3.getUInt64();
          break;
        case 2: {
          const t9 = e3.getMessage(), r7 = this.values;
          for (; !t9.empty(); ) {
            const e4 = t9.getUInt32(), a9 = t9.getUInt32();
            r7[s6[e4]] = o6[a9];
          }
          t9.release();
          break;
        }
        case 3:
          this.type = e3.getUInt32();
          break;
        case 4:
          this._pbfGeometry = e3.getMessage();
          break;
        default:
          e3.skip();
      }
  }
  getGeometry(s6) {
    if (void 0 !== this._geometry)
      return this._geometry;
    if (!this._pbfGeometry)
      return null;
    const o6 = this._pbfGeometry;
    let r7, a9;
    this._pbfGeometry = null, s6 ? s6.reset(this.type) : r7 = [];
    let n5, l5 = t6.moveTo, i = 0, c4 = 0, h4 = 0;
    for (; !o6.empty(); ) {
      if (0 === i) {
        const e3 = o6.getUInt32();
        l5 = 7 & e3, i = e3 >> 3;
      }
      switch (i--, l5) {
        case t6.moveTo:
          c4 += o6.getSInt32(), h4 += o6.getSInt32(), s6 ? s6.moveTo(c4, h4) : (a9 && r7.push(a9), a9 = [], a9.push(new t3(c4, h4)));
          break;
        case t6.lineTo:
          c4 += o6.getSInt32(), h4 += o6.getSInt32(), s6 ? s6.lineTo(c4, h4) : a9.push(new t3(c4, h4));
          break;
        case t6.close:
          s6 ? s6.close() : a9 && !a9[0].equals(c4, h4) && a9.push(a9[0].clone());
          break;
        default:
          throw o6.release(), new Error("Invalid path operation");
      }
    }
    return s6 ? n5 = s6.result() : (a9 && r7.push(a9), n5 = r7), o6.release(), this._geometry = n5, n5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/IndexMemoryBuffer.js
var r3 = class extends t5 {
  constructor() {
    super(12);
  }
  add(s6, r7, t8) {
    const e3 = this.array;
    e3.push(s6), e3.push(r7), e3.push(t8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SourceLayerData.js
var e2 = class {
  constructor(t8) {
    for (this.extent = 4096, this.keys = [], this.values = [], this._pbfLayer = t8.clone(); t8.next(); )
      switch (t8.tag()) {
        case 1:
          this.name = t8.getString();
          break;
        case 3:
          this.keys.push(t8.getString());
          break;
        case 4:
          this.values.push(t8.processMessage(e2._parseValue));
          break;
        case 5:
          this.extent = t8.getUInt32();
          break;
        default:
          t8.skip();
      }
  }
  getData() {
    return this._pbfLayer;
  }
  static _parseValue(e3) {
    for (; e3.next(); )
      switch (e3.tag()) {
        case 1:
          return e3.getString();
        case 2:
          return e3.getFloat();
        case 3:
          return e3.getDouble();
        case 4:
          return e3.getInt64();
        case 5:
          return e3.getUInt64();
        case 6:
          return e3.getSInt64();
        case 7:
          return e3.getBool();
        default:
          e3.skip();
      }
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VertexMemoryBuffer.js
var o4 = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o6, r7, u4, h4, a9, n5, d2, e3, p4, i, c4) {
    const M = this.array;
    let l5 = t5.i1616to32(t8, o6);
    M.push(l5);
    const m3 = 31;
    l5 = t5.i8888to32(Math.round(m3 * r7), Math.round(m3 * u4), Math.round(m3 * h4), Math.round(m3 * a9)), M.push(l5), l5 = t5.i8888to32(Math.round(m3 * n5), Math.round(m3 * d2), Math.round(m3 * e3), Math.round(m3 * p4)), M.push(l5), l5 = t5.i1616to32(i, 0), M.push(l5), c4 && M.push(...c4);
  }
};
var r4 = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o6, r7) {
    const u4 = this.array;
    u4.push(t5.i1616to32(t8, o6)), r7 && u4.push(...r7);
  }
};
var u3 = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o6, r7, u4, h4, a9, n5) {
    const d2 = this.array, e3 = this.index;
    let p4 = t5.i1616to32(t8, o6);
    d2.push(p4);
    const i = 15;
    return p4 = t5.i8888to32(Math.round(i * r7), Math.round(i * u4), h4, a9), d2.push(p4), n5 && d2.push(...n5), e3;
  }
};
var h3 = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(o6, r7, u4, h4, a9, n5, d2, e3, p4, i, c4, M) {
    const l5 = this.array;
    let m3 = t5.i1616to32(o6, r7);
    l5.push(m3), m3 = t5.i1616to32(Math.round(8 * u4), Math.round(8 * h4)), l5.push(m3), m3 = t5.i8888to32(a9 / 4, n5 / 4, e3, p4), l5.push(m3), m3 = t5.i8888to32(0, h(d2), 10 * i, Math.min(10 * c4, 255)), l5.push(m3), M && l5.push(...M);
  }
};
var a7 = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o6, r7, u4, h4) {
    const a9 = this.array, n5 = t5.i1616to32(2 * t8 + r7, 2 * o6 + u4);
    a9.push(n5), h4 && a9.push(...h4);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/BaseBucket.js
var t7 = class {
  constructor(t8, e3, s6) {
    this.layerExtent = 4096, this._features = [], this.layer = t8, this.zoom = e3, this._spriteInfo = s6, this._filter = t8.getFeatureFilter();
  }
  pushFeature(t8) {
    this._filter && !this._filter.filter(t8, this.zoom) || this._features.push(t8);
  }
  hasFeatures() {
    return this._features.length > 0;
  }
  getResources(t8, e3, s6) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/CircleBucket.js
var r5 = class extends t7 {
  constructor(t8, r7, i, c4, s6) {
    super(t8, r7, i), this.type = I.CIRCLE, this._circleVertexBuffer = c4, this._circleIndexBuffer = s6;
  }
  get circleIndexStart() {
    return this._circleIndexStart;
  }
  get circleIndexCount() {
    return this._circleIndexCount;
  }
  processFeatures(e3) {
    const t8 = this._circleVertexBuffer, r7 = this._circleIndexBuffer;
    this._circleIndexStart = 3 * r7.index, this._circleIndexCount = 0;
    const i = this.layer, c4 = this.zoom;
    e3 && e3.setExtent(this.layerExtent);
    for (const s6 of this._features) {
      const n5 = s6.getGeometry(e3);
      if (!n5)
        continue;
      const l5 = i.circleMaterial.encodeAttributes(s6, c4, i);
      for (const e4 of n5)
        if (e4)
          for (const i2 of e4) {
            const e5 = t8.index;
            t8.add(i2.x, i2.y, 0, 0, l5), t8.add(i2.x, i2.y, 0, 1, l5), t8.add(i2.x, i2.y, 1, 0, l5), t8.add(i2.x, i2.y, 1, 1, l5), r7.add(e5 + 0, e5 + 1, e5 + 2), r7.add(e5 + 1, e5 + 2, e5 + 3), this._circleIndexCount += 6;
          }
    }
  }
  serialize() {
    let e3 = 6;
    e3 += this.layerUIDs.length, e3 += this._circleVertexBuffer.array.length, e3 += this._circleIndexBuffer.array.length;
    const t8 = new Uint32Array(e3), r7 = new Int32Array(t8.buffer);
    let i = 0;
    t8[i++] = this.type, t8[i++] = this.layerUIDs.length;
    for (let c4 = 0; c4 < this.layerUIDs.length; c4++)
      t8[i++] = this.layerUIDs[c4];
    t8[i++] = this._circleIndexStart, t8[i++] = this._circleIndexCount, t8[i++] = this._circleVertexBuffer.array.length;
    for (let c4 = 0; c4 < this._circleVertexBuffer.array.length; c4++)
      r7[i++] = this._circleVertexBuffer.array[c4];
    t8[i++] = this._circleIndexBuffer.array.length;
    for (let c4 = 0; c4 < this._circleIndexBuffer.array.length; c4++)
      t8[i++] = this._circleIndexBuffer.array[c4];
    return t8.buffer;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/FillBucket.js
var s4 = class extends t7 {
  constructor(t8, e3, i, l5, n5, s6, o6) {
    super(t8, e3, i), this.type = I.FILL, this._patternMap = /* @__PURE__ */ new Map(), this._fillVertexBuffer = l5, this._fillIndexBuffer = n5, this._outlineVertexBuffer = s6, this._outlineIndexBuffer = o6;
  }
  get fillIndexStart() {
    return this._fillIndexStart;
  }
  get fillIndexCount() {
    return this._fillIndexCount;
  }
  get outlineIndexStart() {
    return this._outlineIndexStart;
  }
  get outlineIndexCount() {
    return this._outlineIndexCount;
  }
  getResources(t8, e3, i) {
    const r7 = this.layer, l5 = this.zoom, n5 = r7.getPaintProperty("fill-pattern");
    if (n5)
      if (n5.isDataDriven)
        for (const s6 of this._features)
          e3(n5.getValue(l5, s6), true);
      else
        e3(n5.getValue(l5), true);
  }
  processFeatures(t8) {
    this._fillIndexStart = 3 * this._fillIndexBuffer.index, this._fillIndexCount = 0, this._outlineIndexStart = 3 * this._outlineIndexBuffer.index, this._outlineIndexCount = 0;
    const e3 = this.layer, i = this.zoom, { fillMaterial: r7, outlineMaterial: l5, hasDataDrivenFill: n5, hasDataDrivenOutline: s6 } = e3;
    t8 && t8.setExtent(this.layerExtent);
    const o6 = e3.getPaintProperty("fill-pattern"), a9 = o6 == null ? void 0 : o6.isDataDriven;
    let f3 = !o6 && e3.getPaintValue("fill-antialias", i);
    if (e3.outlineUsesFillColor) {
      if (f3 && !e3.hasDataDrivenOpacity) {
        const t9 = e3.getPaintValue("fill-opacity", i), r8 = e3.getPaintValue("fill-opacity", i + 1);
        t9 < 1 && r8 < 1 && (f3 = false);
      }
      if (f3 && !e3.hasDataDrivenColor) {
        const t9 = e3.getPaintValue("fill-color", i), r8 = e3.getPaintValue("fill-color", i + 1);
        t9[3] < 1 && r8[3] < 1 && (f3 = false);
      }
    }
    const u4 = this._features, d2 = t8 == null ? void 0 : t8.validateTessellation;
    if (a9) {
      const n6 = [];
      for (const a10 of u4) {
        const u5 = o6.getValue(i, a10), h4 = this._spriteInfo[u5];
        if (!h4 || !h4.rect)
          continue;
        const x3 = r7.encodeAttributes(a10, i, e3, h4), c4 = f3 && s6 ? l5.encodeAttributes(a10, i, e3) : [], _ = a10.getGeometry(t8);
        n6.push({ ddFillAttributes: x3, ddOutlineAttributes: c4, page: h4.page, geometry: _ }), n6.sort((t9, e4) => t9.page - e4.page);
        for (const { ddFillAttributes: t9, ddOutlineAttributes: i2, page: r8, geometry: l6 } of n6)
          this._processFeature(l6, f3, e3.outlineUsesFillColor, t9, i2, d2, r8);
      }
    } else
      for (const h4 of u4) {
        const o7 = n5 ? r7.encodeAttributes(h4, i, e3) : null, a10 = f3 && s6 ? l5.encodeAttributes(h4, i, e3) : null, u5 = h4.getGeometry(t8);
        this._processFeature(u5, f3, e3.outlineUsesFillColor, o7, a10, d2);
      }
  }
  serialize() {
    let t8 = 10;
    t8 += this.layerUIDs.length, t8 += this._fillVertexBuffer.array.length, t8 += this._fillIndexBuffer.array.length, t8 += this._outlineVertexBuffer.array.length, t8 += this._outlineIndexBuffer.array.length, t8 += 3 * this._patternMap.size + 1;
    const e3 = new Uint32Array(t8), i = new Int32Array(e3.buffer);
    let r7 = 0;
    e3[r7++] = this.type, e3[r7++] = this.layerUIDs.length;
    for (let s6 = 0; s6 < this.layerUIDs.length; s6++)
      e3[r7++] = this.layerUIDs[s6];
    e3[r7++] = this._fillIndexStart, e3[r7++] = this._fillIndexCount, e3[r7++] = this._outlineIndexStart, e3[r7++] = this._outlineIndexCount;
    const l5 = this._patternMap, n5 = l5.size;
    if (e3[r7++] = n5, n5 > 0)
      for (const [s6, [o6, a9]] of l5)
        e3[r7++] = s6, e3[r7++] = o6, e3[r7++] = a9;
    e3[r7++] = this._fillVertexBuffer.array.length;
    for (let s6 = 0; s6 < this._fillVertexBuffer.array.length; s6++)
      i[r7++] = this._fillVertexBuffer.array[s6];
    e3[r7++] = this._fillIndexBuffer.array.length;
    for (let s6 = 0; s6 < this._fillIndexBuffer.array.length; s6++)
      e3[r7++] = this._fillIndexBuffer.array[s6];
    e3[r7++] = this._outlineVertexBuffer.array.length;
    for (let s6 = 0; s6 < this._outlineVertexBuffer.array.length; s6++)
      i[r7++] = this._outlineVertexBuffer.array[s6];
    e3[r7++] = this._outlineIndexBuffer.array.length;
    for (let s6 = 0; s6 < this._outlineIndexBuffer.array.length; s6++)
      e3[r7++] = this._outlineIndexBuffer.array[s6];
    return e3.buffer;
  }
  _processFeature(t8, e3, i, r7, l5, n5, o6) {
    if (!t8)
      return;
    const a9 = t8.length, f3 = !l5 || 0 === l5.length;
    if (e3 && (!i || f3))
      for (let s6 = 0; s6 < a9; s6++)
        this._processOutline(t8[s6], l5);
    const u4 = 32;
    let d2;
    for (let h4 = 0; h4 < a9; h4++) {
      const e4 = s4._area(t8[h4]);
      e4 > u4 ? (void 0 !== d2 && this._processFill(t8, d2, r7, n5, o6), d2 = [h4]) : e4 < -u4 && void 0 !== d2 && d2.push(h4);
    }
    void 0 !== d2 && this._processFill(t8, d2, r7, n5, o6);
  }
  _processOutline(t8, e3) {
    const i = this._outlineVertexBuffer, r7 = this._outlineIndexBuffer, l5 = r7.index;
    let s6, o6, a9;
    const f3 = new t3(0, 0), u4 = new t3(0, 0), d2 = new t3(0, 0);
    let h4 = -1, x3 = -1, c4 = -1, _ = -1, y2 = -1, g3 = false;
    const p4 = 0;
    let I5 = t8.length;
    if (I5 < 2)
      return;
    const B2 = t8[p4];
    let m3 = t8[I5 - 1];
    for (; I5 && m3.isEqual(B2); )
      --I5, m3 = t8[I5 - 1];
    if (!(I5 - p4 < 2)) {
      for (let l6 = p4; l6 < I5; ++l6) {
        l6 === p4 ? (s6 = t8[I5 - 1], o6 = t8[p4], a9 = t8[p4 + 1], f3.assignSub(o6, s6), f3.normalize(), f3.rightPerpendicular()) : (s6 = o6, o6 = a9, a9 = l6 !== I5 - 1 ? t8[l6 + 1] : t8[p4], f3.assign(u4));
        const n5 = this._isClipEdge(s6, o6);
        -1 === _ && (g3 = n5), u4.assignSub(a9, o6), u4.normalize(), u4.rightPerpendicular();
        const B3 = f3.x * u4.y - f3.y * u4.x;
        d2.assignAdd(f3, u4), d2.normalize();
        const m4 = -d2.x * -f3.x + -d2.y * -f3.y;
        let V = Math.abs(0 !== m4 ? 1 / m4 : 1);
        V > 8 && (V = 8), B3 >= 0 ? (c4 = i.add(o6.x, o6.y, f3.x, f3.y, 0, 1, e3), -1 === _ && (_ = c4), h4 >= 0 && x3 >= 0 && c4 >= 0 && !n5 && r7.add(h4, x3, c4), x3 = i.add(o6.x, o6.y, V * -d2.x, V * -d2.y, 0, -1, e3), -1 === y2 && (y2 = x3), h4 >= 0 && x3 >= 0 && c4 >= 0 && !n5 && r7.add(h4, x3, c4), h4 = x3, x3 = c4, c4 = i.add(o6.x, o6.y, d2.x, d2.y, 0, 1, e3), h4 >= 0 && x3 >= 0 && c4 >= 0 && !n5 && r7.add(h4, x3, c4), x3 = i.add(o6.x, o6.y, u4.x, u4.y, 0, 1, e3), h4 >= 0 && x3 >= 0 && c4 >= 0 && !n5 && r7.add(h4, x3, c4)) : (c4 = i.add(o6.x, o6.y, V * d2.x, V * d2.y, 0, 1, e3), -1 === _ && (_ = c4), h4 >= 0 && x3 >= 0 && c4 >= 0 && !n5 && r7.add(h4, x3, c4), x3 = i.add(o6.x, o6.y, -f3.x, -f3.y, 0, -1, e3), -1 === y2 && (y2 = x3), h4 >= 0 && x3 >= 0 && c4 >= 0 && !n5 && r7.add(h4, x3, c4), h4 = x3, x3 = c4, c4 = i.add(o6.x, o6.y, -d2.x, -d2.y, 0, -1, e3), h4 >= 0 && x3 >= 0 && c4 >= 0 && !n5 && r7.add(h4, x3, c4), h4 = i.add(o6.x, o6.y, -u4.x, -u4.y, 0, -1, e3), h4 >= 0 && x3 >= 0 && c4 >= 0 && !n5 && r7.add(h4, x3, c4));
      }
      h4 >= 0 && x3 >= 0 && _ >= 0 && !g3 && r7.add(h4, x3, _), h4 >= 0 && _ >= 0 && y2 >= 0 && !g3 && r7.add(h4, y2, _), this._outlineIndexCount += 3 * (r7.index - l5);
    }
  }
  _processFill(r7, l5, n5, s6, o6) {
    s6 = true;
    let a9;
    l5.length > 1 && (a9 = []);
    let f3 = 0;
    for (const t8 of l5)
      0 !== f3 && a9.push(f3), f3 += r7[t8].length;
    const u4 = 2 * f3, d2 = t.acquire();
    for (const t8 of l5) {
      const e3 = r7[t8], i = e3.length;
      for (let t9 = 0; t9 < i; ++t9)
        d2.push(e3[t9].x, e3[t9].y);
    }
    const h4 = x(d2, a9, 2);
    if (s6 && x.deviation(d2, a9, 2, h4) > 0) {
      const t8 = l5.map((t9) => r7[t9].length), { buffer: e3, vertexCount: s7 } = a2(d2, t8);
      if (s7 > 0) {
        const t9 = this._fillVertexBuffer.index;
        for (let i = 0; i < s7; i++)
          this._fillVertexBuffer.add(e3[2 * i], e3[2 * i + 1], n5);
        for (let e4 = 0; e4 < s7; e4 += 3) {
          const i = t9 + e4;
          this._fillIndexBuffer.add(i, i + 1, i + 2);
        }
        if (void 0 !== o6) {
          const t10 = this._patternMap, e4 = t10.get(o6);
          e4 ? e4[1] += s7 : t10.set(o6, [this._fillIndexStart + this._fillIndexCount, s7]);
        }
        this._fillIndexCount += s7;
      }
    } else {
      const t8 = h4.length;
      if (t8 > 0) {
        const e3 = this._fillVertexBuffer.index;
        let i = 0;
        for (; i < u4; )
          this._fillVertexBuffer.add(d2[i++], d2[i++], n5);
        let r8 = 0;
        for (; r8 < t8; )
          this._fillIndexBuffer.add(e3 + h4[r8++], e3 + h4[r8++], e3 + h4[r8++]);
        if (void 0 !== o6) {
          const e4 = this._patternMap, i2 = e4.get(o6);
          i2 ? i2[1] += t8 : e4.set(o6, [this._fillIndexStart + this._fillIndexCount, t8]);
        }
        this._fillIndexCount += t8;
      }
    }
    t.release(d2);
  }
  _isClipEdge(t8, e3) {
    return t8.x === e3.x ? t8.x <= -64 || t8.x >= 4160 : t8.y === e3.y && (t8.y <= -64 || t8.y >= 4160);
  }
  static _area(t8) {
    let e3 = 0;
    const i = t8.length - 1;
    for (let r7 = 0; r7 < i; r7++)
      e3 += (t8[r7].x - t8[r7 + 1].x) * (t8[r7].y + t8[r7 + 1].y);
    return e3 += (t8[i].x - t8[0].x) * (t8[i].y + t8[0].y), 0.5 * e3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/LineBucket.js
var s5 = 65535;
var n4 = class extends t7 {
  constructor(t8, s6, n5, a9, o6) {
    super(t8, s6, n5), this.type = I.LINE, this._tessellationOptions = { pixelCoordRatio: 8, halfWidth: 0, offset: 0 }, this._patternMap = /* @__PURE__ */ new Map(), this.tessellationProperties = { _lineVertexBuffer: null, _lineIndexBuffer: null, _ddValues: null }, this.tessellationProperties._lineVertexBuffer = a9, this.tessellationProperties._lineIndexBuffer = o6, this._lineTessellator = new d(r6(this.tessellationProperties), l4(this.tessellationProperties), t8.canUseThinTessellation);
  }
  get lineIndexStart() {
    return this._lineIndexStart;
  }
  get lineIndexCount() {
    return this._lineIndexCount;
  }
  getResources(e3, t8, i) {
    const s6 = this.layer, n5 = this.zoom, r7 = s6.hasDataDrivenLine, l5 = s6.getPaintProperty("line-pattern"), a9 = s6.getPaintProperty("line-dasharray"), o6 = s6.getLayoutProperty("line-cap");
    if (!l5 && !a9)
      return;
    const u4 = (o6 == null ? void 0 : o6.getValue(n5)) || 0, f3 = o6 == null ? void 0 : o6.isDataDriven;
    if (r7) {
      const e4 = l5 == null ? void 0 : l5.isDataDriven, i2 = a9 == null ? void 0 : a9.isDataDriven;
      if (!e4 && !i2)
        return;
      for (const r8 of this._features)
        t8(e4 ? l5.getValue(n5, r8) : this._getDashArrayKey(r8, n5, s6, a9, f3, o6, u4));
    } else if (l5)
      t8(l5.getValue(n5));
    else if (a9) {
      const e4 = a9.getValue(n5);
      t8(s6.getDashKey(e4, u4));
    }
  }
  processFeatures(e3) {
    this._lineIndexStart = 3 * this.tessellationProperties._lineIndexBuffer.index, this._lineIndexCount = 0;
    const t8 = this.layer, i = this.zoom, s6 = this._features, n5 = this._tessellationOptions, { hasDataDrivenLine: r7, lineMaterial: l5 } = t8;
    e3 && e3.setExtent(this.layerExtent);
    const a9 = t8.getPaintProperty("line-pattern"), o6 = t8.getPaintProperty("line-dasharray"), u4 = a9 == null ? void 0 : a9.isDataDriven, f3 = o6 == null ? void 0 : o6.isDataDriven;
    let h4;
    h4 = t8.getLayoutProperty("line-cap");
    const p4 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, g3 = p4 ? null : t8.getLayoutValue("line-cap", i), y2 = g3 || 0, d2 = !!p4;
    h4 = t8.getLayoutProperty("line-join");
    const c4 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, _ = c4 ? null : t8.getLayoutValue("line-join", i);
    h4 = t8.getLayoutProperty("line-miter-limit");
    const x3 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, D = x3 ? null : t8.getLayoutValue("line-miter-limit", i);
    h4 = t8.getLayoutProperty("line-round-limit");
    const m3 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, V = m3 ? null : t8.getLayoutValue("line-round-limit", i);
    h4 = t8.getPaintProperty("line-width");
    const P2 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, I5 = P2 ? null : t8.getPaintValue("line-width", i);
    h4 = t8.getPaintProperty("line-offset");
    const L2 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, B2 = L2 ? null : t8.getPaintValue("line-offset", i);
    if (u4 || f3) {
      const r8 = [];
      for (const n6 of s6) {
        const s7 = u4 ? a9.getValue(i, n6) : this._getDashArrayKey(n6, i, t8, o6, d2, p4, y2), f4 = this._spriteInfo[s7];
        if (!f4 || !f4.rect)
          continue;
        const h5 = l5.encodeAttributes(n6, i, t8, f4), v = n6.getGeometry(e3);
        r8.push({ ddAttributes: h5, page: f4.page, cap: p4 ? p4.getValue(i, n6) : g3, join: c4 ? c4.getValue(i, n6) : _, miterLimit: x3 ? x3.getValue(i, n6) : D, roundLimit: m3 ? m3.getValue(i, n6) : V, halfWidth: 0.5 * (P2 ? P2.getValue(i, n6) : I5), offset: L2 ? L2.getValue(i, n6) : B2, geometry: v });
      }
      r8.sort((e4, t9) => e4.page - t9.page), n5.textured = true;
      for (const { ddAttributes: e4, page: t9, cap: i2, join: s7, miterLimit: l6, roundLimit: a10, halfWidth: o7, offset: u5, geometry: f4 } of r8)
        n5.capType = i2, n5.joinType = s7, n5.miterLimit = l6, n5.roundLimit = a10, n5.halfWidth = o7, n5.offset = u5, this._processFeature(f4, e4, t9);
    } else {
      n5.textured = !(!a9 && !o6), n5.capType = g3, n5.joinType = _, n5.miterLimit = D, n5.roundLimit = V, n5.halfWidth = 0.5 * I5, n5.offset = B2;
      for (const a10 of s6) {
        const s7 = r7 ? l5.encodeAttributes(a10, i, t8) : null;
        p4 && (n5.capType = p4.getValue(i, a10)), c4 && (n5.joinType = c4.getValue(i, a10)), x3 && (n5.miterLimit = x3.getValue(i, a10)), m3 && (n5.roundLimit = m3.getValue(i, a10)), P2 && (n5.halfWidth = 0.5 * P2.getValue(i, a10)), L2 && (n5.offset = L2.getValue(i, a10));
        const o7 = a10.getGeometry(e3);
        this._processFeature(o7, s7);
      }
    }
  }
  serialize() {
    let e3 = 6;
    e3 += this.layerUIDs.length, e3 += this.tessellationProperties._lineVertexBuffer.array.length, e3 += this.tessellationProperties._lineIndexBuffer.array.length, e3 += 3 * this._patternMap.size + 1;
    const t8 = new Uint32Array(e3), i = new Int32Array(t8.buffer);
    let s6 = 0;
    t8[s6++] = this.type, t8[s6++] = this.layerUIDs.length;
    for (let l5 = 0; l5 < this.layerUIDs.length; l5++)
      t8[s6++] = this.layerUIDs[l5];
    t8[s6++] = this._lineIndexStart, t8[s6++] = this._lineIndexCount;
    const n5 = this._patternMap, r7 = n5.size;
    if (t8[s6++] = r7, r7 > 0)
      for (const [l5, [a9, o6]] of n5)
        t8[s6++] = l5, t8[s6++] = a9, t8[s6++] = o6;
    t8[s6++] = this.tessellationProperties._lineVertexBuffer.array.length;
    for (let l5 = 0; l5 < this.tessellationProperties._lineVertexBuffer.array.length; l5++)
      i[s6++] = this.tessellationProperties._lineVertexBuffer.array[l5];
    t8[s6++] = this.tessellationProperties._lineIndexBuffer.array.length;
    for (let l5 = 0; l5 < this.tessellationProperties._lineIndexBuffer.array.length; l5++)
      t8[s6++] = this.tessellationProperties._lineIndexBuffer.array[l5];
    return t8.buffer;
  }
  _processFeature(e3, t8, i) {
    if (!e3)
      return;
    const s6 = e3.length;
    for (let n5 = 0; n5 < s6; n5++)
      this._processGeometry(e3[n5], t8, i);
  }
  _processGeometry(e3, t8, i) {
    if (e3.length < 2)
      return;
    const n5 = 1e-3;
    let r7, l5, a9 = e3[0], o6 = 1;
    for (; o6 < e3.length; )
      r7 = e3[o6].x - a9.x, l5 = e3[o6].y - a9.y, r7 * r7 + l5 * l5 < n5 * n5 ? e3.splice(o6, 1) : (a9 = e3[o6], ++o6);
    if (e3.length < 2)
      return;
    const u4 = this.tessellationProperties._lineIndexBuffer, f3 = 3 * u4.index;
    this._tessellationOptions.initialDistance = 0, this._tessellationOptions.wrapDistance = s5, this.tessellationProperties._ddValues = t8, this._lineTessellator.tessellate(e3, this._tessellationOptions);
    const h4 = 3 * u4.index - f3;
    if (void 0 !== i) {
      const e4 = this._patternMap, t9 = e4.get(i);
      t9 ? t9[1] += h4 : e4.set(i, [f3 + this._lineIndexCount, h4]);
    }
    this._lineIndexCount += h4;
  }
  _getDashArrayKey(e3, t8, i, s6, n5, r7, l5) {
    const a9 = n5 ? r7.getValue(t8, e3) : l5, o6 = s6.getValue(t8, e3);
    return i.getDashKey(o6, a9);
  }
};
var r6 = (e3) => (t8, i, s6, n5, r7, l5, a9, o6, u4, f3, h4) => (e3._lineVertexBuffer.add(t8, i, a9, o6, s6, n5, r7, l5, u4, f3, h4, e3._ddValues), e3._lineVertexBuffer.index - 1);
var l4 = (e3) => (t8, i, s6) => {
  e3._lineIndexBuffer.add(t8, i, s6);
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/SymbolBucket.js
var I3 = 10;
function b3(e3, t8) {
  return e3.iconMosaicItem && t8.iconMosaicItem ? e3.iconMosaicItem.page === t8.iconMosaicItem.page ? 0 : e3.iconMosaicItem.page - t8.iconMosaicItem.page : e3.iconMosaicItem && !t8.iconMosaicItem ? 1 : !e3.iconMosaicItem && t8.iconMosaicItem ? -1 : 0;
}
var A = class extends t7 {
  constructor(e3, t8, i, s6, a9, o6, r7, l5) {
    super(e3, t8, l5.getSpriteItems()), this.type = I.SYMBOL, this._markerMap = /* @__PURE__ */ new Map(), this._glyphMap = /* @__PURE__ */ new Map(), this._glyphBufferDataStorage = /* @__PURE__ */ new Map(), this._isIconSDF = false, this._iconVertexBuffer = i, this._iconIndexBuffer = s6, this._textVertexBuffer = a9, this._textIndexBuffer = o6, this._placementEngine = r7, this._workerTileHandler = l5;
  }
  get markerPageMap() {
    return this._markerMap;
  }
  get glyphsPageMap() {
    return this._glyphMap;
  }
  get symbolInstances() {
    return this._symbolInstances;
  }
  getResources(e3, n5, i) {
    const s6 = this.layer, a9 = this.zoom;
    e3 && e3.setExtent(this.layerExtent);
    const o6 = s6.getLayoutProperty("icon-image"), r7 = s6.getLayoutProperty("text-field");
    let l5 = s6.getLayoutProperty("text-transform"), h4 = s6.getLayoutProperty("text-font");
    const x3 = [];
    let c4, g3, f3, y2;
    o6 && !o6.isDataDriven && (c4 = o6.getValue(a9)), r7 && !r7.isDataDriven && (g3 = r7.getValue(a9)), l5 && l5.isDataDriven || (f3 = s6.getLayoutValue("text-transform", a9), l5 = null), h4 && h4.isDataDriven || (y2 = s6.getLayoutValue("text-font", a9), h4 = null);
    for (const m3 of this._features) {
      const u4 = m3.getGeometry(e3);
      if (!u4 || 0 === u4.length)
        continue;
      let p4, _;
      o6 && (p4 = o6.isDataDriven ? o6.getValue(a9, m3) : this._replaceKeys(c4, m3.values), p4 && n5(p4));
      let M = false;
      if (r7 && (_ = r7.isDataDriven ? r7.getValue(a9, m3) : this._replaceKeys(g3, m3.values), _)) {
        switch (_ = _.replace(/\\n/g, "\n"), l5 && (f3 = l5.getValue(a9, m3)), f3) {
          case o2.LOWERCASE:
            _ = _.toLowerCase();
            break;
          case o2.UPPERCASE:
            _ = _.toUpperCase();
        }
        if (A._bidiEngine.hasBidiChar(_)) {
          let e5;
          e5 = "rtl" === A._bidiEngine.checkContextual(_) ? "IDNNN" : "ICNNN", _ = A._bidiEngine.bidiTransform(_, e5, "VLYSN"), M = true;
        }
        const e4 = _.length;
        if (e4 > 0) {
          h4 && (y2 = h4.getValue(a9, m3));
          for (const t8 of y2) {
            let n6 = i[t8];
            n6 || (n6 = i[t8] = /* @__PURE__ */ new Set());
            for (let t9 = 0; t9 < e4; t9++) {
              const e5 = _.charCodeAt(t9);
              n6.add(e5);
            }
          }
        }
      }
      if (!p4 && !_)
        continue;
      const P2 = s6.getLayoutValue("symbol-sort-key", a9, m3), I5 = { feature: m3, sprite: p4, label: _, rtl: M, geometry: u4, hash: (_ ? c(_) : 0) ^ (p4 ? c(p4) : 0), priority: P2, textFont: y2 };
      x3.push(I5);
    }
    this._symbolFeatures = x3;
  }
  processFeatures(e3) {
    e3 && e3.setExtent(this.layerExtent);
    const t8 = this.layer, n5 = this.zoom, s6 = t8.getLayoutValue("symbol-placement", n5), a9 = s6 !== n3.POINT, c4 = t8.getLayoutValue("symbol-spacing", n5) * w, d2 = t8.getLayoutProperty("icon-image"), P2 = t8.getLayoutProperty("text-field"), I5 = d2 ? new m2(t8, n5, a9) : null, L2 = P2 ? new T(t8, n5, a9) : null, V = this._workerTileHandler;
    let T4;
    d2 && (T4 = V.getSpriteItems()), this._iconIndexStart = 3 * this._iconIndexBuffer.index, this._textIndexStart = 3 * this._textIndexBuffer.index, this._iconIndexCount = 0, this._textIndexCount = 0, this._markerMap.clear(), this._glyphMap.clear();
    const w3 = [];
    let B2 = 1;
    L2 && L2.size && (B2 = L2.size / c3);
    const C2 = L2 ? L2.maxAngle * f : 0, R = L2 ? L2.size * w : 0;
    for (const i of this._symbolFeatures) {
      let e4;
      I5 && T4 && i.sprite && (e4 = T4[i.sprite], e4 && e4.sdf && (this._isIconSDF = true));
      let t9;
      !!e4 && I5.update(n5, i.feature);
      let d3 = 0;
      const p4 = i.label;
      if (p4) {
        L2.update(n5, i.feature);
        const e5 = a9 ? L2.keepUpright : L2.writingMode && L2.writingMode.includes(p2.VERTICAL);
        let s7 = 0.5;
        switch (L2.anchor) {
          case m.TOP_LEFT:
          case m.LEFT:
          case m.BOTTOM_LEFT:
            s7 = 0;
            break;
          case m.TOP_RIGHT:
          case m.RIGHT:
          case m.BOTTOM_RIGHT:
            s7 = 1;
        }
        let r7 = 0.5;
        switch (L2.anchor) {
          case m.TOP_LEFT:
          case m.TOP:
          case m.TOP_RIGHT:
            r7 = 0;
            break;
          case m.BOTTOM_LEFT:
          case m.BOTTOM:
          case m.BOTTOM_RIGHT:
            r7 = 1;
        }
        let l5 = 0.5;
        switch (L2.justify) {
          case u.AUTO:
            l5 = s7;
            break;
          case u.LEFT:
            l5 = 0;
            break;
          case u.RIGHT:
            l5 = 1;
        }
        const c5 = L2.letterSpacing * c3, g3 = a9 ? 0 : L2.maxWidth * c3, u4 = L2.lineHeight * c3, _ = i.textFont.map((e6) => V.getGlyphItems(e6));
        if (t9 = new a6(_, g3, u4, c5, s7, r7, l5).getShaping(p4, i.rtl, e5), t9 && t9.length > 0) {
          let e6 = 1e30, n6 = -1e30;
          for (const i2 of t9)
            e6 = Math.min(e6, i2.x), n6 = Math.max(n6, i2.x);
          d3 = (n6 - e6 + 2 * c3) * B2 * w;
        }
      }
      for (let n6 of i.geometry) {
        const h4 = [];
        if (s6 === n3.LINE) {
          if (t9 && t9.length > 0 && L2 && L2.size) {
            const e5 = L2.size * w * (2 + Math.min(2, 4 * Math.abs(L2.offset[1])));
            n6 = A._smoothVertices(n6, e5);
          }
          A._pushAnchors(h4, n6, c4, d3);
        } else
          s6 === n3.LINE_CENTER ? A._pushCenterAnchor(h4, n6) : i.feature.type === s.Polygon ? A._pushCentroid(h4, n6) : h4.push(new T2(n6[0].x, n6[0].y));
        for (const s7 of h4) {
          if (s7.x < 0 || s7.x > x2 || s7.y < 0 || s7.y > x2)
            continue;
          if (a9 && d3 > 0 && L2.rotationAlignment === l2.MAP && !A._honorsTextMaxAngle(n6, s7, d3, C2, R))
            continue;
          const o6 = { shaping: t9, line: n6, iconMosaicItem: e4, anchor: s7, symbolFeature: i, textColliders: [], iconColliders: [], textVertexRanges: [], iconVertexRanges: [] };
          w3.push(o6), this._processFeature(o6, I5, L2);
        }
      }
    }
    w3.sort(b3), this._addPlacedGlyphs(), this._symbolInstances = w3;
  }
  serialize() {
    let e3 = 11;
    e3 += this.layerUIDs.length, e3 += 3 * this.markerPageMap.size, e3 += 3 * this.glyphsPageMap.size, e3 += A._symbolsSerializationLength(this._symbolInstances), e3 += this._iconVertexBuffer.array.length, e3 += this._iconIndexBuffer.array.length, e3 += this._textVertexBuffer.array.length, e3 += this._textIndexBuffer.array.length;
    const t8 = new Uint32Array(e3), n5 = new Int32Array(t8.buffer), i = new Float32Array(t8.buffer);
    let s6 = 0;
    t8[s6++] = this.type, t8[s6++] = this.layerUIDs.length;
    for (let a9 = 0; a9 < this.layerUIDs.length; a9++)
      t8[s6++] = this.layerUIDs[a9];
    t8[s6++] = this._isIconSDF ? 1 : 0, t8[s6++] = this.markerPageMap.size;
    for (const [a9, [o6, r7]] of this.markerPageMap)
      t8[s6++] = a9, t8[s6++] = o6, t8[s6++] = r7;
    t8[s6++] = this.glyphsPageMap.size;
    for (const [a9, [o6, r7]] of this.glyphsPageMap)
      t8[s6++] = a9, t8[s6++] = o6, t8[s6++] = r7;
    t8[s6++] = this._iconVertexBuffer.index / 4, t8[s6++] = this._textVertexBuffer.index / 4, s6 = A.serializeSymbols(t8, n5, i, s6, this._symbolInstances), t8[s6++] = this._iconVertexBuffer.array.length;
    for (let a9 = 0; a9 < this._iconVertexBuffer.array.length; a9++)
      n5[s6++] = this._iconVertexBuffer.array[a9];
    t8[s6++] = this._iconIndexBuffer.array.length;
    for (let a9 = 0; a9 < this._iconIndexBuffer.array.length; a9++)
      t8[s6++] = this._iconIndexBuffer.array[a9];
    t8[s6++] = this._textVertexBuffer.array.length;
    for (let a9 = 0; a9 < this._textVertexBuffer.array.length; a9++)
      n5[s6++] = this._textVertexBuffer.array[a9];
    t8[s6++] = this._textIndexBuffer.array.length;
    for (let a9 = 0; a9 < this._textIndexBuffer.array.length; a9++)
      t8[s6++] = this._textIndexBuffer.array[a9];
    return t8.buffer;
  }
  static _symbolsSerializationLength(e3) {
    let t8 = 0;
    t8 += 1;
    for (const n5 of e3 || []) {
      t8 += 4, t8 += 1;
      for (const e4 of n5.textColliders)
        t8 += I3;
      for (const e4 of n5.iconColliders)
        t8 += I3;
      t8 += 1, t8 += 2 * n5.textVertexRanges.length, t8 += 1, t8 += 2 * n5.iconVertexRanges.length;
    }
    return t8;
  }
  static serializeSymbols(e3, t8, n5, i, s6) {
    s6 = s6 || [], t8[i++] = s6.length;
    for (const a9 of s6) {
      t8[i++] = a9.anchor.x, t8[i++] = a9.anchor.y, t8[i++] = a9.symbolFeature.hash, t8[i++] = a9.symbolFeature.priority, t8[i++] = a9.textColliders.length + a9.iconColliders.length;
      for (const e4 of a9.textColliders)
        t8[i++] = e4.xTile, t8[i++] = e4.yTile, t8[i++] = e4.dxPixels, t8[i++] = e4.dyPixels, t8[i++] = e4.hard ? 1 : 0, t8[i++] = e4.partIndex, n5[i++] = e4.minLod, n5[i++] = e4.maxLod, t8[i++] = e4.width, t8[i++] = e4.height;
      for (const e4 of a9.iconColliders)
        t8[i++] = e4.xTile, t8[i++] = e4.yTile, t8[i++] = e4.dxPixels, t8[i++] = e4.dyPixels, t8[i++] = e4.hard ? 1 : 0, t8[i++] = e4.partIndex, n5[i++] = e4.minLod, n5[i++] = e4.maxLod, t8[i++] = e4.width, t8[i++] = e4.height;
      t8[i++] = a9.textVertexRanges.length;
      for (const [e4, n6] of a9.textVertexRanges)
        t8[i++] = e4, t8[i++] = n6;
      t8[i++] = a9.iconVertexRanges.length;
      for (const [e4, n6] of a9.iconVertexRanges)
        t8[i++] = e4, t8[i++] = n6;
    }
    return i;
  }
  _replaceKeys(e3, t8) {
    return e3.replace(/{([^{}]+)}/g, (e4, n5) => n5 in t8 ? t8[n5] : "");
  }
  _processFeature(e3, t8, n5) {
    const { line: i, iconMosaicItem: a9, shaping: o6, anchor: r7 } = e3, l5 = this.zoom, h4 = this.layer, x3 = !!a9;
    let c4 = true;
    x3 && (c4 = t8.optional || !a9);
    const d2 = o6 && o6.length > 0;
    let g3, f3, y2 = true;
    if (d2 && (y2 = n5.optional), x3 && (g3 = this._placementEngine.getIconPlacement(r7, a9, t8)), (g3 || c4) && (d2 && (f3 = this._placementEngine.getTextPlacement(r7, o6, i, n5)), f3 || y2)) {
      if (g3 && f3 || (y2 || c4 ? y2 || f3 ? c4 || g3 || (f3 = null) : g3 = null : (g3 = null, f3 = null)), f3) {
        const t9 = h4.hasDataDrivenText ? h4.textMaterial.encodeAttributes(e3.symbolFeature.feature, l5, h4) : null;
        if (this._storePlacedGlyphs(e3, f3.shapes, l5, n5.rotationAlignment, t9), f3.textColliders) {
          e3.textColliders = f3.textColliders;
          for (const e4 of f3.textColliders) {
            e4.minLod = Math.max(l5 + P(e4.minLod), 0), e4.maxLod = Math.min(l5 + P(e4.maxLod), 25);
            const t10 = e4.angle;
            if (t10) {
              const n6 = Math.cos(t10), i2 = Math.sin(t10), s6 = e4.dxPixels * n6 - e4.dyPixels * i2, a10 = e4.dxPixels * i2 + e4.dyPixels * n6, o7 = (e4.dxPixels + e4.width) * n6 - e4.dyPixels * i2, r8 = (e4.dxPixels + e4.width) * i2 + e4.dyPixels * n6, l6 = e4.dxPixels * n6 - (e4.dyPixels + e4.height) * i2, h5 = e4.dxPixels * i2 + (e4.dyPixels + e4.height) * n6, x4 = (e4.dxPixels + e4.width) * n6 - (e4.dyPixels + e4.height) * i2, c5 = (e4.dxPixels + e4.width) * i2 + (e4.dyPixels + e4.height) * n6, d3 = Math.min(s6, o7, l6, x4), g4 = Math.max(s6, o7, l6, x4), f4 = Math.min(a10, r8, h5, c5), y3 = Math.max(a10, r8, h5, c5);
              e4.dxPixels = d3, e4.dyPixels = f4, e4.width = g4 - d3, e4.height = y3 - f4;
            }
          }
        }
      }
      if (g3) {
        const n6 = h4.hasDataDrivenIcon ? h4.iconMaterial.encodeAttributes(e3.symbolFeature.feature, l5, h4) : null;
        if (this._addPlacedIcons(e3, g3.shapes, l5, a9.page, t8.rotationAlignment === l2.VIEWPORT, n6), g3.iconColliders) {
          e3.iconColliders = g3.iconColliders;
          for (const e4 of g3.iconColliders) {
            e4.minLod = Math.max(l5 + P(e4.minLod), 0), e4.maxLod = Math.min(l5 + P(e4.maxLod), 25);
            const t9 = e4.angle;
            if (t9) {
              const n7 = Math.cos(t9), i2 = Math.sin(t9), s6 = e4.dxPixels * n7 - e4.dyPixels * i2, a10 = e4.dxPixels * i2 + e4.dyPixels * n7, o7 = (e4.dxPixels + e4.width) * n7 - e4.dyPixels * i2, r8 = (e4.dxPixels + e4.width) * i2 + e4.dyPixels * n7, l6 = e4.dxPixels * n7 - (e4.dyPixels + e4.height) * i2, h5 = e4.dxPixels * i2 + (e4.dyPixels + e4.height) * n7, x4 = (e4.dxPixels + e4.width) * n7 - (e4.dyPixels + e4.height) * i2, c5 = (e4.dxPixels + e4.width) * i2 + (e4.dyPixels + e4.height) * n7, d3 = Math.min(s6, o7, l6, x4), g4 = Math.max(s6, o7, l6, x4), f4 = Math.min(a10, r8, h5, c5), y3 = Math.max(a10, r8, h5, c5);
              e4.dxPixels = d3, e4.dyPixels = f4, e4.width = g4 - d3, e4.height = y3 - f4;
            }
          }
        }
      }
    }
  }
  _addPlacedIcons(e3, t8, n5, i, a9, o6) {
    const r7 = Math.max(n5 - 1, 0), l5 = this._iconVertexBuffer, h4 = this._iconIndexBuffer, x3 = this._markerMap;
    for (const c4 of t8) {
      const t9 = a9 ? 0 : Math.max(n5 + P(c4.minzoom), r7), d2 = a9 ? 25 : Math.min(n5 + P(c4.maxzoom), 25);
      if (d2 <= t9)
        continue;
      const g3 = c4.tl, f3 = c4.tr, y2 = c4.bl, m3 = c4.br, u4 = c4.mosaicRect, p4 = c4.labelAngle, _ = c4.minAngle, M = c4.maxAngle, P2 = c4.anchor, I5 = l5.index, b4 = u4.x, A2 = u4.y, L2 = b4 + u4.width, V = A2 + u4.height, T4 = l5.index;
      l5.add(P2.x, P2.y, g3.x, g3.y, b4, A2, p4, _, M, t9, d2, o6), l5.add(P2.x, P2.y, f3.x, f3.y, L2, A2, p4, _, M, t9, d2, o6), l5.add(P2.x, P2.y, y2.x, y2.y, b4, V, p4, _, M, t9, d2, o6), l5.add(P2.x, P2.y, m3.x, m3.y, L2, V, p4, _, M, t9, d2, o6), e3.iconVertexRanges.length > 0 && e3.iconVertexRanges[0][0] + e3.iconVertexRanges[0][1] === T4 ? e3.iconVertexRanges[0][1] += 4 : e3.iconVertexRanges.push([T4, 4]), h4.add(I5 + 0, I5 + 1, I5 + 2), h4.add(I5 + 1, I5 + 2, I5 + 3), x3.has(i) ? x3.get(i)[1] += 6 : x3.set(i, [this._iconIndexStart + this._iconIndexCount, 6]), this._iconIndexCount += 6;
    }
  }
  _addPlacedGlyphs() {
    const e3 = this._textVertexBuffer, t8 = this._textIndexBuffer, n5 = this._glyphMap;
    for (const [i, s6] of this._glyphBufferDataStorage)
      for (const a9 of s6) {
        const s7 = e3.index, o6 = a9.symbolInstance, r7 = a9.ddAttributes, l5 = e3.index;
        e3.add(a9.glyphAnchor[0], a9.glyphAnchor[1], a9.tl[0], a9.tl[1], a9.xmin, a9.ymin, a9.labelAngle, a9.minAngle, a9.maxAngle, a9.minLod, a9.maxLod, r7), e3.add(a9.glyphAnchor[0], a9.glyphAnchor[1], a9.tr[0], a9.tr[1], a9.xmax, a9.ymin, a9.labelAngle, a9.minAngle, a9.maxAngle, a9.minLod, a9.maxLod, r7), e3.add(a9.glyphAnchor[0], a9.glyphAnchor[1], a9.bl[0], a9.bl[1], a9.xmin, a9.ymax, a9.labelAngle, a9.minAngle, a9.maxAngle, a9.minLod, a9.maxLod, r7), e3.add(a9.glyphAnchor[0], a9.glyphAnchor[1], a9.br[0], a9.br[1], a9.xmax, a9.ymax, a9.labelAngle, a9.minAngle, a9.maxAngle, a9.minLod, a9.maxLod, r7), o6.textVertexRanges.length > 0 && o6.textVertexRanges[0][0] + o6.textVertexRanges[0][1] === l5 ? o6.textVertexRanges[0][1] += 4 : o6.textVertexRanges.push([l5, 4]), t8.add(s7 + 0, s7 + 1, s7 + 2), t8.add(s7 + 1, s7 + 2, s7 + 3), n5.has(i) ? n5.get(i)[1] += 6 : n5.set(i, [this._textIndexStart + this._textIndexCount, 6]), this._textIndexCount += 6;
      }
    this._glyphBufferDataStorage.clear();
  }
  _storePlacedGlyphs(e3, t8, n5, i, a9) {
    const o6 = Math.max(n5 - 1, 0), r7 = i === l2.VIEWPORT;
    let l5, h4, x3, c4, d2, g3, f3, y2, m3, p4, _;
    for (const u4 of t8) {
      if (l5 = r7 ? 0 : Math.max(n5 + P(u4.minzoom), o6), h4 = r7 ? 25 : Math.min(n5 + P(u4.maxzoom), 25), h4 <= l5)
        continue;
      x3 = u4.tl, c4 = u4.tr, d2 = u4.bl, g3 = u4.br, f3 = u4.labelAngle, y2 = u4.minAngle, m3 = u4.maxAngle, p4 = u4.anchor, _ = u4.mosaicRect, this._glyphBufferDataStorage.has(u4.page) || this._glyphBufferDataStorage.set(u4.page, []);
      this._glyphBufferDataStorage.get(u4.page).push({ glyphAnchor: [p4.x, p4.y], tl: [x3.x, x3.y], tr: [c4.x, c4.y], bl: [d2.x, d2.y], br: [g3.x, g3.y], xmin: _.x, ymin: _.y, xmax: _.x + _.width, ymax: _.y + _.height, labelAngle: f3, minAngle: y2, maxAngle: m3, minLod: l5, maxLod: h4, placementLod: o6, symbolInstance: e3, ddAttributes: a9 });
    }
  }
  static _pushAnchors(e3, t8, n5, i) {
    n5 += i;
    let s6 = 0;
    const o6 = t8.length - 1;
    for (let a9 = 0; a9 < o6; a9++)
      s6 += t3.distance(t8[a9], t8[a9 + 1]);
    let l5 = i || n5;
    if (l5 *= 0.5, s6 <= l5)
      return;
    const h4 = l5 / s6;
    let x3 = 0, c4 = -(n5 = s6 / Math.max(Math.round(s6 / n5), 1)) / 2;
    const d2 = t8.length - 1;
    for (let g3 = 0; g3 < d2; g3++) {
      const i2 = t8[g3], s7 = t8[g3 + 1], o7 = s7.x - i2.x, l6 = s7.y - i2.y, d3 = Math.sqrt(o7 * o7 + l6 * l6);
      let f3;
      for (; c4 + n5 < x3 + d3; ) {
        c4 += n5;
        const t9 = (c4 - x3) / d3, y2 = b(i2.x, s7.x, t9), m3 = b(i2.y, s7.y, t9);
        void 0 === f3 && (f3 = Math.atan2(l6, o7)), e3.push(new T2(y2, m3, f3, g3, h4));
      }
      x3 += d3;
    }
  }
  static _pushCenterAnchor(e3, t8) {
    let n5 = 0;
    const i = t8.length - 1;
    for (let a9 = 0; a9 < i; a9++)
      n5 += t3.distance(t8[a9], t8[a9 + 1]);
    const s6 = n5 / 2;
    let o6 = 0;
    const l5 = t8.length - 1;
    for (let h4 = 0; h4 < l5; h4++) {
      const n6 = t8[h4], i2 = t8[h4 + 1], l6 = i2.x - n6.x, x3 = i2.y - n6.y, c4 = Math.sqrt(l6 * l6 + x3 * x3);
      if (s6 < o6 + c4) {
        const t9 = (s6 - o6) / c4, d2 = b(n6.x, i2.x, t9), g3 = b(n6.y, i2.y, t9), f3 = Math.atan2(x3, l6);
        return void e3.push(new T2(d2, g3, f3, h4, 0));
      }
      o6 += c4;
    }
  }
  static _deviation(e3, t8, n5) {
    const i = (t8.x - e3.x) * (n5.x - t8.x) + (t8.y - e3.y) * (n5.y - t8.y), s6 = (t8.x - e3.x) * (n5.y - t8.y) - (t8.y - e3.y) * (n5.x - t8.x);
    return Math.atan2(s6, i);
  }
  static _honorsTextMaxAngle(e3, t8, n5, i, s6) {
    let a9 = 0;
    const o6 = n5 / 2;
    let r7 = new t3(t8.x, t8.y), l5 = t8.segment + 1;
    for (; a9 > -o6; ) {
      if (--l5, l5 < 0)
        return false;
      a9 -= t3.distance(e3[l5], r7), r7 = e3[l5];
    }
    a9 += t3.distance(e3[l5], e3[l5 + 1]);
    const h4 = [];
    let x3 = 0;
    const c4 = e3.length;
    for (; a9 < o6; ) {
      const t9 = e3[l5];
      let n6, o7 = l5;
      do {
        if (++o7, o7 === c4)
          return false;
        n6 = e3[o7];
      } while (n6.isEqual(t9));
      let r8, d2 = o7;
      do {
        if (++d2, d2 === c4)
          return false;
        r8 = e3[d2];
      } while (r8.isEqual(n6));
      const g3 = this._deviation(t9, n6, r8);
      for (h4.push({ deviation: g3, distToAnchor: a9 }), x3 += g3; a9 - h4[0].distToAnchor > s6; )
        x3 -= h4.shift().deviation;
      if (Math.abs(x3) > i)
        return false;
      a9 += t3.distance(n6, r8), l5 = o7;
    }
    return true;
  }
  static _smoothVertices(e3, t8) {
    if (t8 <= 0)
      return e3;
    let n5 = e3.length;
    if (n5 < 3)
      return e3;
    const i = [];
    let s6 = 0, a9 = 0;
    i.push(0);
    for (let f3 = 1; f3 < n5; f3++) {
      const t9 = t3.distance(e3[f3], e3[f3 - 1]);
      t9 > 0 && (s6 += t9, i.push(s6), a9++, a9 !== f3 && (e3[a9] = e3[f3]));
    }
    if (n5 = a9 + 1, n5 < 3)
      return e3;
    t8 = Math.min(t8, 0.2 * s6);
    const o6 = e3[0].x, r7 = e3[0].y, l5 = e3[n5 - 1].x, h4 = e3[n5 - 1].y, x3 = t3.sub(e3[0], e3[1]);
    x3.normalize(), e3[0].x += t8 * x3.x, e3[0].y += t8 * x3.y, x3.assignSub(e3[n5 - 1], e3[n5 - 2]), x3.normalize(), e3[n5 - 1].x += t8 * x3.x, e3[n5 - 1].y += t8 * x3.y, i[0] -= t8, i[n5 - 1] += t8;
    const c4 = [];
    c4.push(new t3(o6, r7));
    const d2 = 1e-6, g3 = 0.5 * t8;
    for (let f3 = 1; f3 < n5 - 1; f3++) {
      let s7 = 0, a10 = 0, o7 = 0;
      for (let n6 = f3 - 1; n6 >= 0; n6--) {
        const r8 = g3 + i[n6 + 1] - i[f3];
        if (r8 < 0)
          break;
        const l6 = i[n6 + 1] - i[n6], h5 = i[f3] - i[n6] < g3 ? 1 : r8 / l6;
        if (h5 < d2)
          break;
        const x4 = h5 * h5, c5 = h5 * r8 - 0.5 * x4 * l6, y2 = h5 * l6 / t8, m3 = e3[n6 + 1], u4 = e3[n6].x - m3.x, p4 = e3[n6].y - m3.y;
        s7 += y2 / c5 * (m3.x * h5 * r8 + 0.5 * x4 * (r8 * u4 - l6 * m3.x) - x4 * h5 * l6 * u4 / 3), a10 += y2 / c5 * (m3.y * h5 * r8 + 0.5 * x4 * (r8 * p4 - l6 * m3.y) - x4 * h5 * l6 * p4 / 3), o7 += y2;
      }
      for (let r8 = f3 + 1; r8 < n5; r8++) {
        const n6 = g3 - i[r8 - 1] + i[f3];
        if (n6 < 0)
          break;
        const l6 = i[r8] - i[r8 - 1], h5 = i[r8] - i[f3] < g3 ? 1 : n6 / l6;
        if (h5 < d2)
          break;
        const x4 = h5 * h5, c5 = h5 * n6 - 0.5 * x4 * l6, y2 = h5 * l6 / t8, m3 = e3[r8 - 1], u4 = e3[r8].x - m3.x, p4 = e3[r8].y - m3.y;
        s7 += y2 / c5 * (m3.x * h5 * n6 + 0.5 * x4 * (n6 * u4 - l6 * m3.x) - x4 * h5 * l6 * u4 / 3), a10 += y2 / c5 * (m3.y * h5 * n6 + 0.5 * x4 * (n6 * p4 - l6 * m3.y) - x4 * h5 * l6 * p4 / 3), o7 += y2;
      }
      c4.push(new t3(s7 / o7, a10 / o7));
    }
    return c4.push(new t3(l5, h4)), e3[0].x = o6, e3[0].y = r7, e3[n5 - 1].x = l5, e3[n5 - 1].y = h4, c4;
  }
  static _pushCentroid(e3, t8) {
    const n5 = 0, i = 0, s6 = 4096, a9 = 4096, o6 = t8.length - 1;
    let l5 = 0, h4 = 0, x3 = 0, c4 = t8[0].x, d2 = t8[0].y;
    c4 > s6 && (c4 = s6), c4 < n5 && (c4 = n5), d2 > a9 && (d2 = a9), d2 < i && (d2 = i);
    for (let r7 = 1; r7 < o6; r7++) {
      let e4 = t8[r7].x, o7 = t8[r7].y, g3 = t8[r7 + 1].x, f3 = t8[r7 + 1].y;
      e4 > s6 && (e4 = s6), e4 < n5 && (e4 = n5), o7 > a9 && (o7 = a9), o7 < i && (o7 = i), g3 > s6 && (g3 = s6), g3 < n5 && (g3 = n5), f3 > a9 && (f3 = a9), f3 < i && (f3 = i);
      const y2 = (e4 - c4) * (f3 - d2) - (g3 - c4) * (o7 - d2);
      l5 += y2 * (c4 + e4 + g3), h4 += y2 * (d2 + o7 + f3), x3 += y2;
    }
    l5 /= 3 * x3, h4 /= 3 * x3, isNaN(l5) || isNaN(h4) || e3.push(new T2(l5, h4));
  }
};
A._bidiEngine = new C();

// node_modules/@arcgis/core/views/2d/tiling/enums.js
var I4;
!function(I5) {
  I5[I5.INITIALIZED = 0] = "INITIALIZED", I5[I5.NO_DATA = 1] = "NO_DATA", I5[I5.READY = 2] = "READY", I5[I5.MODIFIED = 3] = "MODIFIED", I5[I5.INVALID = 4] = "INVALID";
}(I4 || (I4 = {}));

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileParser.js
var T3 = 8;
var g2 = 14;
var w2 = 5;
var B = class {
  constructor(t8, r7, s6, i, o6) {
    if (this._pbfTiles = {}, this._tileClippers = {}, this._client = s6, this._tile = r7, o6) {
      this._styleLayerUIDs = /* @__PURE__ */ new Set();
      for (const e3 of o6)
        this._styleLayerUIDs.add(e3);
    }
    this._styleRepository = i, this._layers = this._styleRepository.layers;
    const [n5, c4, l5] = r7.tileKey.split("/").map(parseFloat);
    this._level = n5;
    const a9 = T3 + Math.max((this._level - g2) * w2, 0);
    for (const u4 of Object.keys(t8)) {
      const r8 = t8[u4];
      this._pbfTiles[u4] = new a(new Uint8Array(r8.protobuff), new DataView(r8.protobuff));
      if (r8.refKey) {
        const [e3] = r8.refKey.split("/").map(parseFloat), t9 = n5 - e3;
        if (t9 > 0) {
          const e4 = (1 << t9) - 1, r9 = c4 & e4, s7 = l5 & e4;
          this._tileClippers[u4] = new n(t9, r9, s7, 8, a9);
        }
      }
      this._tileClippers[u4] || (this._tileClippers[u4] = new l());
    }
  }
  _canParseStyleLayer(e3) {
    return !this._styleLayerUIDs || this._styleLayerUIDs.has(e3);
  }
  async parse(e3) {
    const t8 = o(), s6 = this._initialize(e3), { returnedBuckets: i } = s6;
    this._processLayers(s6), this._linkReferences(s6), this._filterFeatures(s6);
    const o6 = [], n5 = /* @__PURE__ */ new Set(), c4 = (e4, t9) => {
      n5.has(e4) || (o6.push({ name: e4, repeat: t9 }), n5.add(e4));
    }, l5 = {};
    for (const r7 of i)
      r7.getResources(r7.tileClipper, c4, l5);
    if (this._tile.status === I4.INVALID)
      return [];
    const a9 = this._fetchResources(o6, l5, e3);
    return Promise.all([...a9, t8]).then(() => this._processFeatures(s6.returnedBuckets));
  }
  _initialize(e3) {
    return { signal: e3 && e3.signal, sourceNameToTileData: this._parseTileData(this._pbfTiles), layers: this._layers, zoom: this._level, sourceNameToTileClipper: this._tileClippers, sourceNameToUniqueSourceLayerBuckets: {}, sourceNameToUniqueSourceLayers: {}, returnedBuckets: [], layerIdToBucket: {}, referencerUIDToReferencedId: /* @__PURE__ */ new Map() };
  }
  _processLayers(e3) {
    const { sourceNameToTileData: t8, layers: r7, zoom: s6, sourceNameToTileClipper: i, sourceNameToUniqueSourceLayerBuckets: o6, sourceNameToUniqueSourceLayers: n5, returnedBuckets: c4, layerIdToBucket: l5, referencerUIDToReferencedId: a9 } = e3;
    for (let u4 = r7.length - 1; u4 >= 0; u4--) {
      const e4 = r7[u4];
      if (!this._canParseStyleLayer(e4.uid) || e4.minzoom && s6 < Math.floor(e4.minzoom) || e4.maxzoom && s6 >= e4.maxzoom || e4.type === a4.BACKGROUND)
        continue;
      if (!t8[e4.source] || !i[e4.source])
        continue;
      const f3 = t8[e4.source], p4 = i[e4.source], h4 = e4.sourceLayer, m3 = f3[h4];
      if (m3) {
        let t9 = n5[e4.source];
        if (t9 || (t9 = n5[e4.source] = /* @__PURE__ */ new Set()), t9.add(e4.sourceLayer), e4.refLayerId)
          a9.set(e4.uid, e4.refLayerId);
        else {
          const t10 = this._createBucket(e4);
          if (t10) {
            t10.layerUIDs = [e4.uid], t10.layerExtent = m3.extent, t10.tileClipper = p4;
            let r8 = o6[e4.source];
            r8 || (r8 = o6[e4.source] = {});
            let s7 = r8[h4];
            s7 || (s7 = r8[h4] = []), s7.push(t10), c4.push(t10), l5[e4.id] = t10;
          }
        }
      }
    }
  }
  _linkReferences(e3) {
    const { layerIdToBucket: t8, referencerUIDToReferencedId: r7 } = e3;
    r7.forEach((e4, r8) => {
      t8[e4] && t8[e4].layerUIDs.push(r8);
    });
  }
  _filterFeatures(e3) {
    const { signal: r7, sourceNameToTileData: i, sourceNameToUniqueSourceLayerBuckets: o6, sourceNameToUniqueSourceLayers: n5 } = e3, c4 = 10 * this._level, l5 = 10 * (this._level + 1), a9 = [], u4 = [];
    for (const t8 of Object.keys(n5)) {
      n5[t8].forEach((e4) => {
        a9.push(e4), u4.push(t8);
      });
    }
    for (let f3 = 0; f3 < a9.length; f3++) {
      const e4 = u4[f3], n6 = a9[f3];
      if (!i[e4] || !o6[e4])
        continue;
      const p4 = i[e4][n6], h4 = o6[e4][n6];
      if (!h4 || 0 === h4.length)
        continue;
      if (p(r7))
        return;
      const m3 = p4.getData();
      for (; m3.nextTag(2); ) {
        const e5 = m3.getMessage(), t8 = new s3(e5, p4);
        e5.release();
        const r8 = t8.values;
        if (r8) {
          const e6 = r8._minzoom;
          if (e6 && e6 >= l5)
            continue;
          const t9 = r8._maxzoom;
          if (t9 && t9 <= c4)
            continue;
        }
        for (const s6 of h4)
          s6.pushFeature(t8);
      }
    }
  }
  _fetchResources(e3, t8, r7) {
    const s6 = [], i = this._tile.getWorkerTileHandler();
    let o6, n5;
    e3.length > 0 && (o6 = i.fetchSprites(e3, this._client, r7), s6.push(o6));
    for (const c4 in t8) {
      const e4 = t8[c4];
      e4.size > 0 && (n5 = i.fetchGlyphs(this._tile.tileKey, c4, e4, this._client, r7), s6.push(n5));
    }
    return s6;
  }
  _processFeatures(e3) {
    const t8 = e3.filter((e4) => e4.hasFeatures() || this._canParseStyleLayer(e4.layer.uid));
    for (const r7 of t8)
      r7.processFeatures(r7.tileClipper);
    return t8;
  }
  _parseTileData(e3) {
    const t8 = {};
    for (const r7 of Object.keys(e3)) {
      const s6 = e3[r7], i = {};
      for (; s6.next(); )
        switch (s6.tag()) {
          case 3: {
            const e4 = s6.getMessage(), t9 = new e2(e4);
            e4.release(), i[t9.name] = t9;
            break;
          }
          default:
            s6.skip();
        }
      t8[r7] = i;
    }
    return t8;
  }
  _createBucket(e3) {
    switch (e3.type) {
      case a4.BACKGROUND:
        return null;
      case a4.FILL:
        return this._createFillBucket(e3);
      case a4.LINE:
        return this._createLineBucket(e3);
      case a4.CIRCLE:
        return this._createCircleBucket(e3);
      case a4.SYMBOL:
        return this._createSymbolBucket(e3);
    }
  }
  _createFillBucket(e3) {
    return new s4(e3, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new r4(e3.fillMaterial.getStride()), new r3(), new u3(e3.outlineMaterial.getStride()), new r3());
  }
  _createLineBucket(e3) {
    return new n4(e3, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new o4(e3.lineMaterial.getStride()), new r3());
  }
  _createCircleBucket(e3) {
    return new r5(e3, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new a7(e3.circleMaterial.getStride()), new r3());
  }
  _createSymbolBucket(e3) {
    const t8 = this._tile;
    return new A(e3, this._level, new h3(e3.iconMaterial.getStride()), new r3(), new h3(e3.textMaterial.getStride()), new r3(), t8.placementEngine, t8.getWorkerTileHandler());
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTile.js
var a8 = class {
  constructor(t8, e3, r7, a9) {
    this.status = I4.INITIALIZED, this.placementEngine = new u2(), this.tileKey = t8, this.refKeys = e3, this._workerTileHandler = r7, this._styleRepository = a9;
  }
  release() {
    this.tileKey = "", this.refKeys = null, this.status = I4.INITIALIZED, this._workerTileHandler = null;
  }
  async parse(s6, r7) {
    const a9 = r7 && r7.signal;
    if (r(a9)) {
      const t8 = () => {
        a9.removeEventListener("abort", t8), this.status = I4.INVALID;
      };
      a9.addEventListener("abort", t8);
    }
    let n5;
    const l5 = { bucketsWithData: [], emptyBuckets: null };
    try {
      n5 = await this._parse(s6, r7);
    } catch (y2) {
      if (g(y2))
        throw y2;
      return { result: l5, transferList: [] };
    }
    this.status = I4.READY;
    const o6 = l5.bucketsWithData, u4 = [];
    for (const t8 of n5)
      if (t8.hasFeatures()) {
        const e3 = t8.serialize();
        o6.push(e3);
      } else
        u4.push(t8.layer.uid);
    const h4 = [...o6];
    let c4 = null;
    return u4.length > 0 && (c4 = Uint32Array.from(u4), h4.push(c4.buffer)), l5.emptyBuckets = c4, { result: l5, transferList: h4 };
  }
  setObsolete() {
    this.status = I4.INVALID;
  }
  getLayers() {
    return this._workerTileHandler.getLayers();
  }
  getWorkerTileHandler() {
    return this._workerTileHandler;
  }
  async _parse(t8, e3) {
    const s6 = t8.sourceName2DataAndRefKey;
    if (0 === Object.keys(s6).length)
      return [];
    this.status = I4.MODIFIED;
    return new B(s6, this, e3.client, this._styleRepository, t8.styleLayerUIDs).parse(e3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTileHandler.js
var o5 = class {
  constructor() {
    this._spriteInfo = {}, this._glyphInfo = {};
  }
  reset() {
    return this._spriteInfo = {}, this._glyphInfo = {}, Promise.resolve();
  }
  getLayers() {
    var _a;
    return (_a = this._styleRepository) == null ? void 0 : _a.layers;
  }
  async createTileAndParse(t8, r7) {
    const { key: o6 } = t8, i = {};
    for (const e3 of Object.keys(t8.sourceName2DataAndRefKey)) {
      const s6 = t8.sourceName2DataAndRefKey[e3];
      i[e3] = s6.refKey;
    }
    const n5 = new a8(o6, i, this, this._styleRepository);
    try {
      return await n5.parse(t8, r7);
    } catch (l5) {
      if (n5.setObsolete(), n5.release(), !g(l5))
        throw l5;
      return null;
    }
  }
  updateStyle(e3) {
    if (!e3 || 0 === e3.length || !this._styleRepository)
      return;
    const s6 = this._styleRepository;
    for (const r7 of e3) {
      const e4 = r7.type, o6 = r7.data;
      switch (e4) {
        case L.PAINTER_CHANGED:
          s6.setPaintProperties(o6.layer, o6.paint);
          break;
        case L.LAYOUT_CHANGED:
          s6.setLayoutProperties(o6.layer, o6.layout);
          break;
        case L.LAYER_REMOVED:
          s6.deleteStyleLayer(o6.layer);
          break;
        case L.LAYER_CHANGED:
          s6.setStyleLayer(o6.layer, o6.index);
          break;
        case L.SPRITES_CHANGED:
          this._spriteInfo = {};
      }
    }
  }
  setStyle(e3) {
    this._styleRepository = new l3(e3), this._spriteInfo = {}, this._glyphInfo = {};
  }
  fetchSprites(e3, t8, s6) {
    const r7 = [], o6 = this._spriteInfo;
    for (const i of e3) {
      void 0 === o6[i.name] && r7.push(i);
    }
    return 0 === r7.length ? Promise.resolve() : t8.invoke("getSprites", r7, { signal: s6 && s6.signal }).then((e4) => {
      for (const t9 in e4) {
        const s7 = e4[t9];
        o6[t9] = s7;
      }
    });
  }
  getSpriteItems() {
    return this._spriteInfo;
  }
  fetchGlyphs(e3, t8, s6, r7, o6) {
    const i = [];
    let n5 = this._glyphInfo[t8];
    return n5 ? s6.forEach((e4) => {
      n5[e4] || i.push(e4);
    }) : (n5 = this._glyphInfo[t8] = [], s6.forEach((e4) => i.push(e4))), 0 === i.length ? Promise.resolve() : r7.invoke("getGlyphs", { tileID: e3, font: t8, codePoints: i }, o6).then((e4) => {
      for (let t9 = 0; t9 < e4.length; t9++)
        e4[t9] && (n5[t9] = e4[t9]);
    });
  }
  getGlyphItems(e3) {
    return this._glyphInfo[e3];
  }
};
export {
  o5 as default
};
//# sourceMappingURL=WorkerTileHandler-55UNHDN7.js.map
