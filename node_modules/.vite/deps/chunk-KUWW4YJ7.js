import {
  c as c3
} from "./chunk-F2DXUUYL.js";
import {
  m as m2
} from "./chunk-EGR3VVZG.js";
import {
  l as l2,
  p,
  v,
  y
} from "./chunk-QFTOW2ST.js";
import {
  p as p2
} from "./chunk-B42HXLDM.js";
import {
  b3 as b2,
  g
} from "./chunk-TADZYUVR.js";
import {
  r as r2
} from "./chunk-2HDG7SIE.js";
import {
  c as c2,
  i
} from "./chunk-OO2JXX7L.js";
import {
  B
} from "./chunk-Q3R7XFM5.js";
import {
  F,
  b as b3
} from "./chunk-5Z5455ZY.js";
import {
  a as a2
} from "./chunk-D7DLEBS2.js";
import {
  s
} from "./chunk-DMJWTK32.js";
import {
  s as s4
} from "./chunk-XRL56EGK.js";
import {
  r
} from "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  s2 as s3
} from "./chunk-HFTNOKM2.js";
import {
  a,
  b,
  u
} from "./chunk-23NWA6WL.js";
import {
  s as s2
} from "./chunk-CVWDM4C7.js";
import {
  m,
  n
} from "./chunk-G5JBUC5N.js";
import {
  c,
  e as e2,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/renderers/support/ClassBreakInfo.js
var i2;
var l3 = i2 = class extends l {
  constructor(s5) {
    super(s5), this.description = null, this.label = null, this.minValue = null, this.maxValue = 0, this.symbol = null;
  }
  clone() {
    return new i2({ description: this.description, label: this.label, minValue: this.minValue, maxValue: this.maxValue, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const s5 = JSON.stringify(this.symbol);
    return `${this.minValue}.${this.maxValue}.${s5}`;
  }
};
e([d({ type: String, json: { write: true } })], l3.prototype, "description", void 0), e([d({ type: String, json: { write: true } })], l3.prototype, "label", void 0), e([d({ type: Number, json: { read: { source: "classMinValue" }, write: { target: "classMinValue" } } })], l3.prototype, "minValue", void 0), e([d({ type: Number, json: { read: { source: "classMaxValue" }, write: { target: "classMaxValue" } } })], l3.prototype, "maxValue", void 0), e([d(l2)], l3.prototype, "symbol", void 0), l3 = i2 = e([n2("esri.renderers.support.ClassBreakInfo")], l3);
var a3 = l3;

// node_modules/@arcgis/core/renderers/ClassBreaksRenderer.js
var F2;
var E = s2.getLogger("esri.renderers.ClassBreaksRenderer");
var j = "log";
var w = "percent-of-total";
var z = "field";
var T = new s({ esriNormalizeByLog: j, esriNormalizeByPercentOfTotal: w, esriNormalizeByField: z });
var _ = b(a3);
var C = F2 = class extends v(p) {
  constructor(e3) {
    super(e3), this._compiledValueExpression = { valueExpression: null, compiledFunction: null }, this.backgroundFillSymbol = null, this.classBreakInfos = null, this.defaultLabel = null, this.defaultSymbol = null, this.field = null, this.isMaxInclusive = true, this.legendOptions = null, this.normalizationField = null, this.normalizationTotal = null, this.type = "class-breaks", this.valueExpression = null, this.valueExpressionTitle = null, this._set("classBreakInfos", []);
  }
  readClassBreakInfos(e3, s5, t2) {
    if (!Array.isArray(e3))
      return;
    let o2 = s5.minValue;
    return e3.map((e4) => {
      const s6 = new a3();
      return s6.read(e4, t2), null == s6.minValue && (s6.minValue = o2), null == s6.maxValue && (s6.maxValue = s6.minValue), o2 = s6.maxValue, s6;
    });
  }
  writeClassBreakInfos(e3, s5, t2, o2) {
    const r3 = e3.map((e4) => e4.write({}, o2));
    this._areClassBreaksConsecutive() && r3.forEach((e4) => delete e4.classMinValue), s5[t2] = r3;
  }
  castField(e3) {
    return null == e3 ? e3 : "function" == typeof e3 ? (E.error(".field: field must be a string value"), null) : u(e3);
  }
  get minValue() {
    return this.classBreakInfos && this.classBreakInfos[0] && this.classBreakInfos[0].minValue || 0;
  }
  get normalizationType() {
    let e3 = this._get("normalizationType");
    const s5 = !!this.normalizationField, t2 = null != this.normalizationTotal;
    return s5 || t2 ? (e3 = s5 && z || t2 && w || null, s5 && t2 && E.warn("warning: both normalizationField and normalizationTotal are set!")) : e3 !== z && e3 !== w || (e3 = null), e3;
  }
  set normalizationType(e3) {
    this._set("normalizationType", e3);
  }
  addClassBreakInfo(e3, t2, r3) {
    let i3 = null;
    i3 = "number" == typeof e3 ? new a3({ minValue: e3, maxValue: t2, symbol: g(r3) }) : _(m(e3)), this.classBreakInfos.push(i3), 1 === this.classBreakInfos.length && this.notifyChange("minValue");
  }
  removeClassBreakInfo(e3, s5) {
    const t2 = this.classBreakInfos.length;
    for (let o2 = 0; o2 < t2; o2++) {
      const t3 = [this.classBreakInfos[o2].minValue, this.classBreakInfos[o2].maxValue];
      if (t3[0] === e3 && t3[1] === s5) {
        this.classBreakInfos.splice(o2, 1);
        break;
      }
    }
  }
  getBreakIndex(e3, s5) {
    return this.valueExpression && (t(s5) || t(s5.arcade)) && E.warn(""), this.valueExpression ? this._getBreakIndexForExpression(e3, s5) : this._getBreakIndexForField(e3);
  }
  async getClassBreakInfo(e3, s5) {
    let t2 = s5;
    this.valueExpression && (t(s5) || t(s5.arcade)) && (t2 = { ...t2, arcade: await a2() });
    const o2 = this.getBreakIndex(e3, t2);
    return -1 !== o2 ? this.classBreakInfos[o2] : null;
  }
  getSymbol(e3, s5) {
    if (this.valueExpression && (t(s5) || t(s5.arcade)))
      return void E.error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const t2 = this.getBreakIndex(e3, s5);
    return t2 > -1 ? this.classBreakInfos[t2].symbol : this.defaultSymbol;
  }
  async getSymbolAsync(e3, s5) {
    let t2 = s5;
    if (this.valueExpression && (t(s5) || t(s5.arcade))) {
      const e4 = await a2(), { arcadeUtils: s6 } = e4;
      s6.hasGeometryOperations(this.valueExpression) && await s6.enableGeometryOperations(), t2 = { ...t2, arcade: e4 };
    }
    const o2 = this.getBreakIndex(e3, t2);
    return o2 > -1 ? this.classBreakInfos[o2].symbol : this.defaultSymbol;
  }
  getSymbols() {
    const e3 = [];
    return this.classBreakInfos.forEach((s5) => {
      s5.symbol && e3.push(s5.symbol);
    }), this.defaultSymbol && e3.push(this.defaultSymbol), e3;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e3, s5) => e3 + s5.getAttributeHash(), "");
  }
  getMeshHash() {
    const e3 = JSON.stringify(this.backgroundFillSymbol), s5 = JSON.stringify(this.defaultSymbol), t2 = `${this.normalizationField}.${this.normalizationType}.${this.normalizationTotal}`;
    return `${e3}.${s5}.${this.classBreakInfos.reduce((e4, s6) => e4 + s6.getMeshHash(), "")}.${t2}.${this.field}.${this.valueExpression}`;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  clone() {
    return new F2({ field: this.field, backgroundFillSymbol: this.backgroundFillSymbol && this.backgroundFillSymbol.clone(), defaultLabel: this.defaultLabel, defaultSymbol: this.defaultSymbol && this.defaultSymbol.clone(), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, classBreakInfos: m(this.classBreakInfos), isMaxInclusive: this.isMaxInclusive, normalizationField: this.normalizationField, normalizationTotal: this.normalizationTotal, normalizationType: this.normalizationType, visualVariables: m(this.visualVariables), legendOptions: m(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
  async collectRequiredFields(e3, s5) {
    const t2 = [this.collectVVRequiredFields(e3, s5), this.collectSymbolFields(e3, s5)];
    await Promise.all(t2);
  }
  async collectSymbolFields(e3, s5) {
    const t2 = [...this.getSymbols().map((t3) => t3.collectRequiredFields(e3, s5)), b3(e3, s5, this.valueExpression)];
    F(e3, s5, this.field), F(e3, s5, this.normalizationField), await Promise.all(t2);
  }
  _getBreakIndexForExpression(e3, s5) {
    const { viewingMode: t2, scale: o2, spatialReference: r3, arcade: i3 } = c(s5, {});
    let n4 = this._compiledValueExpression.valueExpression === this.valueExpression ? this._compiledValueExpression.compiledFunction : null;
    const u2 = e2(i3).arcadeUtils;
    if (!n4) {
      const e4 = u2.createSyntaxTree(this.valueExpression);
      n4 = u2.createFunction(e4), this._compiledValueExpression.compiledFunction = n4;
    }
    this._compiledValueExpression.valueExpression = this.valueExpression;
    const c4 = u2.executeFunction(n4, u2.createExecContext(e3, u2.getViewInfo({ viewingMode: t2, scale: o2, spatialReference: r3 })));
    return this._getBreakIndexfromInfos(c4);
  }
  _getBreakIndexForField(e3) {
    const s5 = this.field, t2 = e3.attributes, o2 = this.normalizationType;
    let r3 = parseFloat(t2[s5]);
    if (o2) {
      const e4 = this.normalizationTotal, s6 = parseFloat(t2[this.normalizationField]);
      if (o2 === j)
        r3 = Math.log(r3) * Math.LOG10E;
      else if (o2 !== w || isNaN(e4)) {
        if (o2 === z && !isNaN(s6)) {
          if (isNaN(r3) || isNaN(s6))
            return -1;
          r3 /= s6;
        }
      } else
        r3 = r3 / e4 * 100;
    }
    return this._getBreakIndexfromInfos(r3);
  }
  _getBreakIndexfromInfos(e3) {
    const s5 = this.isMaxInclusive;
    if (null != e3 && "number" == typeof e3 && !isNaN(e3))
      for (let t2 = 0; t2 < this.classBreakInfos.length; t2++) {
        const o2 = [this.classBreakInfos[t2].minValue, this.classBreakInfos[t2].maxValue];
        if (o2[0] <= e3 && (s5 ? e3 <= o2[1] : e3 < o2[1]))
          return t2;
      }
    return -1;
  }
  _areClassBreaksConsecutive() {
    const e3 = this.classBreakInfos, s5 = e3.length;
    for (let t2 = 1; t2 < s5; t2++)
      if (e3[t2 - 1].maxValue !== e3[t2].minValue)
        return false;
    return true;
  }
};
e([d(y)], C.prototype, "backgroundFillSymbol", void 0), e([d({ type: [a3] })], C.prototype, "classBreakInfos", void 0), e([o("classBreakInfos")], C.prototype, "readClassBreakInfos", null), e([r("classBreakInfos")], C.prototype, "writeClassBreakInfos", null), e([d({ type: String, json: { write: true } })], C.prototype, "defaultLabel", void 0), e([d(l2)], C.prototype, "defaultSymbol", void 0), e([d({ type: String, json: { write: true } })], C.prototype, "field", void 0), e([s4("field")], C.prototype, "castField", null), e([d({ type: Boolean })], C.prototype, "isMaxInclusive", void 0), e([d({ type: p2, json: { write: true } })], C.prototype, "legendOptions", void 0), e([d({ type: Number, readOnly: true, value: null, json: { read: false, write: { overridePolicy() {
  return 0 !== this.classBreakInfos.length && this._areClassBreaksConsecutive() ? { enabled: true } : { enabled: false };
} } } })], C.prototype, "minValue", null), e([d({ type: String, json: { write: true } })], C.prototype, "normalizationField", void 0), e([d({ type: Number, cast: (e3) => a(e3), json: { write: true } })], C.prototype, "normalizationTotal", void 0), e([d({ type: T.apiValues, value: null, json: { type: T.jsonValues, read: T.read, write: T.write } })], C.prototype, "normalizationType", null), e([r2({ classBreaks: "class-breaks" })], C.prototype, "type", void 0), e([d({ type: String, json: { write: true } })], C.prototype, "valueExpression", void 0), e([d({ type: String, json: { write: true } })], C.prototype, "valueExpressionTitle", void 0), C = F2 = e([n2("esri.renderers.ClassBreaksRenderer")], C);
var N = C;

// node_modules/@arcgis/core/renderers/support/UniqueValueInfo.js
var l4;
var p3 = l4 = class extends l {
  constructor(o2) {
    super(o2), this.description = null, this.label = null, this.symbol = null, this.value = null;
  }
  castValue(o2) {
    return null == o2 || "string" == typeof o2 || "number" == typeof o2 ? o2 : `${o2}`;
  }
  clone() {
    return new l4({ value: this.value, description: this.description, label: this.label, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const o2 = JSON.stringify(this.symbol && this.symbol.toJSON());
    return `${this.value}.${o2}`;
  }
};
e([d({ type: String, json: { write: true } })], p3.prototype, "description", void 0), e([d({ type: String, json: { write: true } })], p3.prototype, "label", void 0), e([d(l2)], p3.prototype, "symbol", void 0), e([d({ json: { type: String, write: { writer: (o2, t2) => {
  t2.value = o2 == null ? void 0 : o2.toString();
} } } })], p3.prototype, "value", void 0), e([s4("value")], p3.prototype, "castValue", null), p3 = l4 = e([n2("esri.renderers.support.UniqueValueInfo")], p3);
var n3 = p3;

// node_modules/@arcgis/core/renderers/UniqueValueRenderer.js
var E2;
var M = s2.getLogger("esri.renderers.UniqueValueRenderer");
var N2 = b(n3);
var R = E2 = class extends v(p) {
  constructor(e3) {
    super(e3), this._valueInfoMap = {}, this._isDefaultSymbolDerived = false, this.type = "unique-value", this.backgroundFillSymbol = null, this.field = null, this.field2 = null, this.field3 = null, this.valueExpression = null, this.valueExpressionTitle = null, this.legendOptions = null, this.defaultLabel = null, this.fieldDelimiter = null, this.portal = null, this.styleOrigin = null, this.diff = { uniqueValueInfos(e4, t2) {
      if (!e4 && !t2)
        return;
      if (!e4 || !t2)
        return { type: "complete", oldValue: e4, newValue: t2 };
      let i3 = false;
      const r3 = { type: "collection", added: [], removed: [], changed: [], unchanged: [] };
      for (let s5 = 0; s5 < t2.length; s5++) {
        const l5 = e4.find((e5) => e5.value === t2[s5].value);
        l5 ? m2(l5, t2[s5]) ? (r3.changed.push({ type: "complete", oldValue: l5, newValue: t2[s5] }), i3 = true) : r3.unchanged.push({ oldValue: l5, newValue: t2[s5] }) : (r3.added.push(t2[s5]), i3 = true);
      }
      for (let s5 = 0; s5 < e4.length; s5++) {
        t2.find((t3) => t3.value === e4[s5].value) || (r3.removed.push(e4[s5]), i3 = true);
      }
      return i3 ? r3 : void 0;
    } }, this._set("uniqueValueInfos", []);
  }
  get _cache() {
    return { compiledFunc: null };
  }
  castField(e3) {
    return null == e3 || "function" == typeof e3 ? e3 : u(e3);
  }
  writeField(e3, t2, r3, s5) {
    "string" == typeof e3 ? t2[r3] = e3 : s5 && s5.messages ? s5.messages.push(new s3("property:unsupported", "UniqueValueRenderer.field set to a function cannot be written to JSON")) : M.error(".field: cannot write field to JSON since it's not a string value");
  }
  set defaultSymbol(e3) {
    this._isDefaultSymbolDerived = false, this._set("defaultSymbol", e3);
  }
  readPortal(e3, t2, i3) {
    return i3.portal || B.getDefault();
  }
  readStyleOrigin(e3, t2, i3) {
    if (t2.styleName)
      return Object.freeze({ styleName: t2.styleName });
    if (t2.styleUrl) {
      const e4 = i(t2.styleUrl, i3);
      return Object.freeze({ styleUrl: e4 });
    }
  }
  writeStyleOrigin(e3, t2, i3, r3) {
    e3.styleName ? t2.styleName = e3.styleName : e3.styleUrl && (t2.styleUrl = c2(e3.styleUrl, r3));
  }
  set uniqueValueInfos(e3) {
    this.styleOrigin ? M.error("#uniqueValueInfos=", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueInfos", e3), this._updateValueInfoMap());
  }
  addUniqueValueInfo(e3, i3) {
    if (this.styleOrigin)
      return void M.error("#addUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    let r3;
    r3 = "object" == typeof e3 ? N2(e3) : new n3({ value: e3, symbol: g(i3) }), this.uniqueValueInfos.push(r3), this._valueInfoMap[r3.value] = r3;
  }
  removeUniqueValueInfo(e3) {
    if (this.styleOrigin)
      M.error("#removeUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    else
      for (let t2 = 0; t2 < this.uniqueValueInfos.length; t2++) {
        if (this.uniqueValueInfos[t2].value === e3 + "") {
          delete this._valueInfoMap[e3], this.uniqueValueInfos.splice(t2, 1);
          break;
        }
      }
  }
  async getUniqueValueInfo(e3, t2) {
    let i3 = t2;
    return this.valueExpression && (t(t2) || t(t2.arcade)) && (i3 = { ...i3, arcade: await a2() }), this._getUniqueValueInfo(e3, i3);
  }
  getSymbol(e3, t2) {
    if (this.valueExpression && (t(t2) || t(t2.arcade)))
      return void M.error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const i3 = this._getUniqueValueInfo(e3, t2);
    return i3 && i3.symbol || this.defaultSymbol;
  }
  async getSymbolAsync(e3, t2) {
    let i3 = t2;
    if (this.valueExpression && (t(i3) || t(i3.arcade))) {
      const e4 = await a2(), { arcadeUtils: t3 } = e4;
      t3.hasGeometryOperations(this.valueExpression) && await t3.enableGeometryOperations(), i3 = { ...i3, arcade: e4 };
    }
    const r3 = this._getUniqueValueInfo(e3, i3);
    return r3 && r3.symbol || this.defaultSymbol;
  }
  getSymbols() {
    const e3 = [];
    for (const t2 of this.uniqueValueInfos)
      t2.symbol && e3.push(t2.symbol);
    return this.defaultSymbol && e3.push(this.defaultSymbol), e3;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e3, t2) => e3 + t2.getAttributeHash(), "");
  }
  getMeshHash() {
    return `${JSON.stringify(this.backgroundFillSymbol)}.${JSON.stringify(this.defaultSymbol)}.${this.uniqueValueInfos.reduce((e3, t2) => e3 + t2.getMeshHash(), "")}.${`${this.field}.${this.field2}.${this.field3}.${this.fieldDelimiter}`}.${this.valueExpression}`;
  }
  clone() {
    const e3 = new E2({ field: this.field, field2: this.field2, field3: this.field3, defaultLabel: this.defaultLabel, defaultSymbol: m(this.defaultSymbol), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, fieldDelimiter: this.fieldDelimiter, visualVariables: m(this.visualVariables), legendOptions: m(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone(), backgroundFillSymbol: m(this.backgroundFillSymbol) });
    this._isDefaultSymbolDerived && (e3._isDefaultSymbolDerived = true), e3._set("portal", this.portal);
    const t2 = m(this.uniqueValueInfos);
    return this.styleOrigin && (e3._set("styleOrigin", Object.freeze(m(this.styleOrigin))), Object.freeze(t2)), e3._set("uniqueValueInfos", t2), e3._updateValueInfoMap(), e3;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  async collectRequiredFields(e3, t2) {
    const i3 = [this.collectVVRequiredFields(e3, t2), this.collectSymbolFields(e3, t2)];
    await Promise.all(i3);
  }
  async collectSymbolFields(e3, t2) {
    const i3 = [...this.getSymbols().map((i4) => i4.collectRequiredFields(e3, t2)), b3(e3, t2, this.valueExpression)];
    F(e3, t2, this.field), F(e3, t2, this.field2), F(e3, t2, this.field3), await Promise.all(i3);
  }
  populateFromStyle() {
    return c3(this.styleOrigin, { portal: this.portal }).then((e3) => {
      const t2 = [];
      return this._valueInfoMap = {}, e3 && e3.data && Array.isArray(e3.data.items) && e3.data.items.forEach((i3) => {
        const r3 = new b2({ styleUrl: e3.styleUrl, styleName: e3.styleName, portal: this.portal, name: i3.name });
        this.defaultSymbol || i3.name !== e3.data.defaultItem || (this.defaultSymbol = r3, this._isDefaultSymbolDerived = true);
        const s5 = new n3({ value: i3.name, symbol: r3 });
        t2.push(s5), this._valueInfoMap[i3.name] = s5;
      }), this._set("uniqueValueInfos", Object.freeze(t2)), !this.defaultSymbol && this.uniqueValueInfos.length && (this.defaultSymbol = this.uniqueValueInfos[0].symbol, this._isDefaultSymbolDerived = true), this;
    });
  }
  _updateValueInfoMap() {
    this._valueInfoMap = {}, this.uniqueValueInfos.forEach((e3) => this._valueInfoMap[e3.value + ""] = e3);
  }
  _getUniqueValueInfo(e3, t2) {
    return this.valueExpression ? this._getUnqiueValueInfoForExpression(e3, t2) : this._getUnqiueValueInfoForFields(e3);
  }
  _getUnqiueValueInfoForExpression(e3, t2) {
    const { viewingMode: i3, scale: r3, spatialReference: s5, arcade: l5 } = c(t2, {});
    let a4 = this._cache.compiledFunc;
    const u2 = e2(l5).arcadeUtils;
    if (!a4) {
      const e4 = u2.createSyntaxTree(this.valueExpression);
      a4 = u2.createFunction(e4), this._cache.compiledFunc = a4;
    }
    const p4 = u2.executeFunction(a4, u2.createExecContext(e3, u2.getViewInfo({ viewingMode: i3, scale: r3, spatialReference: s5 })));
    return this._valueInfoMap[p4 + ""];
  }
  _getUnqiueValueInfoForFields(e3) {
    const t2 = this.field, i3 = e3.attributes;
    let r3;
    if ("function" != typeof t2 && this.field2) {
      const e4 = this.field2, s5 = this.field3, l5 = [];
      t2 && l5.push(i3[t2]), e4 && l5.push(i3[e4]), s5 && l5.push(i3[s5]), r3 = l5.join(this.fieldDelimiter || "");
    } else
      "function" == typeof t2 ? r3 = t2(e3) : t2 && (r3 = i3[t2]);
    return this._valueInfoMap[r3 + ""];
  }
  static fromPortalStyle(e3, t2) {
    const i3 = new E2(t2 && t2.properties);
    i3._set("styleOrigin", Object.freeze({ styleName: e3 })), i3._set("portal", t2 && t2.portal || B.getDefault());
    const r3 = i3.populateFromStyle();
    return r3.catch((t3) => {
      M.error(`#fromPortalStyle('${e3}'[, ...])`, "Failed to create unique value renderer from style name", t3);
    }), r3;
  }
  static fromStyleUrl(e3, t2) {
    const i3 = new E2(t2 && t2.properties);
    i3._set("styleOrigin", Object.freeze({ styleUrl: e3 }));
    const r3 = i3.populateFromStyle();
    return r3.catch((t3) => {
      M.error(`#fromStyleUrl('${e3}'[, ...])`, "Failed to create unique value renderer from style URL", t3);
    }), r3;
  }
};
e([d({ readOnly: true })], R.prototype, "_cache", null), e([r2({ uniqueValue: "unique-value" })], R.prototype, "type", void 0), e([d(y)], R.prototype, "backgroundFillSymbol", void 0), e([d({ json: { type: String, read: { source: "field1" }, write: { target: "field1" } } })], R.prototype, "field", void 0), e([s4("field")], R.prototype, "castField", null), e([r("field")], R.prototype, "writeField", null), e([d({ type: String, json: { write: true } })], R.prototype, "field2", void 0), e([d({ type: String, json: { write: true } })], R.prototype, "field3", void 0), e([d({ type: String, json: { write: true } })], R.prototype, "valueExpression", void 0), e([d({ type: String, json: { write: true } })], R.prototype, "valueExpressionTitle", void 0), e([d({ type: p2, json: { write: true } })], R.prototype, "legendOptions", void 0), e([d({ type: String, json: { write: true } })], R.prototype, "defaultLabel", void 0), e([d(n({ ...l2 }, { json: { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} }, origins: { "web-scene": { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} } } } } }))], R.prototype, "defaultSymbol", null), e([d({ type: String, json: { write: true } })], R.prototype, "fieldDelimiter", void 0), e([d({ type: B, readOnly: true })], R.prototype, "portal", void 0), e([o("portal", ["styleName"])], R.prototype, "readPortal", null), e([d({ readOnly: true, json: { write: { enabled: false, overridePolicy: () => ({ enabled: true }) } } })], R.prototype, "styleOrigin", void 0), e([o("styleOrigin", ["styleName", "styleUrl"])], R.prototype, "readStyleOrigin", null), e([r("styleOrigin", { styleName: { type: String }, styleUrl: { type: String } })], R.prototype, "writeStyleOrigin", null), e([d({ type: [n3], json: { write: { overridePolicy() {
  return this.styleOrigin ? { enabled: false } : { enabled: true };
} } } })], R.prototype, "uniqueValueInfos", null), R = E2 = e([n2("esri.renderers.UniqueValueRenderer")], R);
var P = R;

export {
  a3 as a,
  N,
  n3 as n,
  P
};
//# sourceMappingURL=chunk-KUWW4YJ7.js.map
