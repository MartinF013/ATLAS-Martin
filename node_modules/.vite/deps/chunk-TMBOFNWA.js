import {
  u
} from "./chunk-56RHM4A6.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/geometry/support/aaBoundingBox.js
function i(n) {
  return n;
}
function a(n = H) {
  return i([n[0], n[1], n[2], n[3], n[4], n[5]]);
}
function u2(n, t2, r, i2, u3, e, m2 = a()) {
  return m2[0] = n, m2[1] = t2, m2[2] = r, m2[3] = i2, m2[4] = u3, m2[5] = e, m2;
}
function m(n, r) {
  const i2 = isFinite(n[2]) || isFinite(n[5]);
  return new M(i2 ? { xmin: n[0], xmax: n[3], ymin: n[1], ymax: n[4], zmin: n[2], zmax: n[5], spatialReference: r } : { xmin: n[0], xmax: n[3], ymin: n[1], ymax: n[4], spatialReference: r });
}
function f(n, t2) {
  n[0] = Math.min(n[0], t2[0]), n[1] = Math.min(n[1], t2[1]), n[2] = Math.min(n[2], t2[2]), n[3] = Math.max(n[3], t2[3]), n[4] = Math.max(n[4], t2[4]), n[5] = Math.max(n[5], t2[5]);
}
function c(n, t2) {
  n[0] = Math.min(n[0], t2[0]), n[1] = Math.min(n[1], t2[1]), n[3] = Math.max(n[3], t2[2]), n[4] = Math.max(n[4], t2[3]);
}
function h(n, t2) {
  n[0] = Math.min(n[0], t2[0]), n[1] = Math.min(n[1], t2[1]), n[2] = Math.min(n[2], t2[2]), n[3] = Math.max(n[3], t2[0]), n[4] = Math.max(n[4], t2[1]), n[5] = Math.max(n[5], t2[2]);
}
function M2(n, t2, r = 0, i2 = t2.length / 3) {
  let a2 = n[0], u3 = n[1], e = n[2], m2 = n[3], o = n[4], f2 = n[5];
  for (let c2 = 0; c2 < i2; c2++)
    a2 = Math.min(a2, t2[r + 3 * c2]), u3 = Math.min(u3, t2[r + 3 * c2 + 1]), e = Math.min(e, t2[r + 3 * c2 + 2]), m2 = Math.max(m2, t2[r + 3 * c2]), o = Math.max(o, t2[r + 3 * c2 + 1]), f2 = Math.max(f2, t2[r + 3 * c2 + 2]);
  n[0] = a2, n[1] = u3, n[2] = e, n[3] = m2, n[4] = o, n[5] = f2;
}
function s(n, t2, r) {
  const i2 = t2.length;
  let a2 = n[0], u3 = n[1], e = n[2], m2 = n[3], o = n[4], f2 = n[5];
  if (r)
    for (let c2 = 0; c2 < i2; c2++) {
      const n2 = t2[c2];
      a2 = Math.min(a2, n2[0]), u3 = Math.min(u3, n2[1]), e = Math.min(e, n2[2]), m2 = Math.max(m2, n2[0]), o = Math.max(o, n2[1]), f2 = Math.max(f2, n2[2]);
    }
  else
    for (let c2 = 0; c2 < i2; c2++) {
      const n2 = t2[c2];
      a2 = Math.min(a2, n2[0]), u3 = Math.min(u3, n2[1]), m2 = Math.max(m2, n2[0]), o = Math.max(o, n2[1]);
    }
  n[0] = a2, n[1] = u3, n[2] = e, n[3] = m2, n[4] = o, n[5] = f2;
}
function l(n) {
  for (let t2 = 0; t2 < 6; t2++)
    if (!isFinite(n[t2]))
      return false;
  return true;
}
function I(n) {
  return n[0] >= n[3] ? 0 : n[3] - n[0];
}
function y(n) {
  return n[1] >= n[4] ? 0 : n[4] - n[1];
}
function N(n) {
  return n[2] >= n[5] ? 0 : n[5] - n[2];
}
function g(n) {
  const t2 = I(n), r = N(n), i2 = y(n);
  return Math.sqrt(t2 * t2 + r * r + i2 * i2);
}
function p(n, t2 = [0, 0, 0]) {
  return t2[0] = n[0] + I(n) / 2, t2[1] = n[1] + y(n) / 2, t2[2] = n[2] + N(n) / 2, t2;
}
function F(n, t2 = [0, 0, 0]) {
  return t2[0] = I(n), t2[1] = y(n), t2[2] = N(n), t2;
}
function z(n) {
  return Math.max(I(n), N(n), y(n));
}
function E(n, t2) {
  return t2[0] >= n[0] && t2[1] >= n[1] && t2[2] >= n[2] && t2[0] <= n[3] && t2[1] <= n[4] && t2[2] <= n[5];
}
function b(n, t2) {
  return t2[0] >= n[0] && t2[1] >= n[1] && t2[2] >= n[2] && t2[3] <= n[3] && t2[4] <= n[4] && t2[5] <= n[5];
}
function j(n, t2) {
  return Math.max(t2[0], n[0]) <= Math.min(t2[3], n[3]) && Math.max(t2[1], n[1]) <= Math.min(t2[4], n[4]) && Math.max(t2[2], n[2]) <= Math.min(t2[5], n[5]);
}
function R(t2, r) {
  return !!t(r) || j(t2, r);
}
function V(n, t2, r, i2, a2 = n) {
  return a2[0] = n[0] + t2, a2[1] = n[1] + r, a2[2] = n[2] + i2, a2[3] = n[3] + t2, a2[4] = n[4] + r, a2[5] = n[5] + i2, a2;
}
function Y(n, t2, r = n) {
  const i2 = n[0] + I(n) / 2, a2 = n[1] + y(n) / 2, u3 = n[2] + N(n) / 2;
  return r[0] = i2 + (n[0] - i2) * t2, r[1] = a2 + (n[1] - a2) * t2, r[2] = u3 + (n[2] - u3) * t2, r[3] = i2 + (n[3] - i2) * t2, r[4] = a2 + (n[4] - a2) * t2, r[5] = u3 + (n[5] - u3) * t2, r;
}
function _(n, t2) {
  return t2[0] = n[0], t2[1] = n[1], t2[2] = n[2], t2;
}
function q(n, t2, r = n) {
  return r[0] = t2[0], r[1] = t2[1], r[2] = t2[2], r !== n && (r[3] = n[3], r[4] = n[4], r[5] = n[5]), r;
}
function w(n, t2, r = n) {
  return r[3] = t2[0], r[4] = t2[1], r[5] = t2[2], r !== n && (r[0] = n[0], r[1] = n[1], r[2] = n[2]), n;
}
function A(n, t2) {
  return n[0] = t2[0], n[1] = t2[1], n[2] = t2[2], n[3] = t2[3], n[4] = t2[4], n[5] = t2[5], n;
}
function B(n) {
  return n ? A(n, D) : a(D);
}
function G(n, t2) {
  return t2 || (t2 = u()), t2[0] = n[0], t2[1] = n[1], t2[2] = n[3], t2[3] = n[4], t2;
}
function O(n, t2) {
  return n[0] = t2[0], n[1] = t2[1], n[2] = Number.NEGATIVE_INFINITY, n[3] = t2[2], n[4] = t2[3], n[5] = Number.POSITIVE_INFINITY, n;
}
function P(n) {
  return 6 === n.length;
}
function S(n) {
  return 0 === I(n) && 0 === y(n) && 0 === N(n);
}
function k(t2, r, i2) {
  if (t(t2) || t(r))
    return t2 === r;
  if (!P(t2) || !P(r))
    return false;
  if (i2) {
    for (let n = 0; n < t2.length; n++)
      if (!i2(t2[n], r[n]))
        return false;
  } else
    for (let n = 0; n < t2.length; n++)
      if (t2[n] !== r[n])
        return false;
  return true;
}
function v(n, t2, r, i2, a2, e) {
  return u2(n, t2, r, i2, a2, e, J);
}
var C = i([-1 / 0, -1 / 0, -1 / 0, 1 / 0, 1 / 0, 1 / 0]);
var D = i([1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0]);
var H = i([0, 0, 0, 0, 0, 0]);
var J = a();

export {
  a,
  u2 as u,
  m,
  f,
  c,
  h,
  M2 as M,
  s,
  l,
  I,
  y,
  N,
  g,
  p,
  F,
  z,
  E,
  b,
  j,
  R,
  V,
  Y,
  _,
  q,
  w,
  A,
  B,
  G,
  O,
  S,
  k,
  v,
  C,
  D,
  H
};
//# sourceMappingURL=chunk-TMBOFNWA.js.map
