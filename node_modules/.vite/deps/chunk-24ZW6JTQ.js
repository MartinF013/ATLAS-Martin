import {
  t as t3
} from "./chunk-X57S4DWT.js";
import {
  r as r4
} from "./chunk-D7AOY7GH.js";
import {
  p as p4
} from "./chunk-SZPDY7KN.js";
import {
  n as n4
} from "./chunk-OXEYQYNR.js";
import {
  j as j3
} from "./chunk-OXRBYKVX.js";
import {
  d as d3
} from "./chunk-T47JAOQZ.js";
import {
  m as m2
} from "./chunk-6GPADSSO.js";
import {
  d as d2
} from "./chunk-FU5UMT3R.js";
import {
  t as t2
} from "./chunk-ODX6X222.js";
import {
  K,
  b as b2,
  c
} from "./chunk-GSFXXEAM.js";
import {
  p
} from "./chunk-TMSBC6BS.js";
import {
  n as n3,
  p as p3
} from "./chunk-C7S44TP4.js";
import {
  y
} from "./chunk-WODSLTZT.js";
import {
  O
} from "./chunk-BUWXVMJU.js";
import {
  p as p2,
  v as v2
} from "./chunk-JT3LXQ47.js";
import {
  a
} from "./chunk-JJRJ6TV3.js";
import {
  U,
  l
} from "./chunk-T7BEWVV3.js";
import {
  c2
} from "./chunk-TADZYUVR.js";
import {
  B
} from "./chunk-EI4MOLML.js";
import {
  m as m3
} from "./chunk-HVM5D6S5.js";
import {
  s as s5
} from "./chunk-H7JF6Q7A.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  U as U2
} from "./chunk-65A2N4LL.js";
import {
  I,
  j as j2
} from "./chunk-5N3FSR63.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  s as s4
} from "./chunk-XRL56EGK.js";
import {
  r as r3
} from "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import {
  d,
  e as e2,
  n3 as n,
  n8 as n2,
  r2,
  t3 as t
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  f
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  S,
  b,
  s as s3,
  v
} from "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/mixins/ArcGISMapService.js
var y2 = (y3) => {
  let d4 = class extends y3 {
    constructor() {
      super(...arguments), this.capabilities = void 0, this.copyright = null, this.fullExtent = null, this.legendEnabled = true, this.spatialReference = null, this.version = void 0;
    }
    readCapabilities(e3, r5) {
      const s6 = r5.capabilities && r5.capabilities.split(",").map((e4) => e4.toLowerCase().trim());
      if (!s6)
        return { operations: { supportsExportMap: false, supportsExportTiles: false, supportsIdentify: false, supportsQuery: false, supportsTileMap: false }, exportMap: null, exportTiles: null };
      const t4 = this.type, i = s6.includes("data"), p5 = s6.includes("query"), a2 = s6.includes("map"), l2 = !!r5.exportTilesAllowed, n5 = s6.includes("tilemap"), u = "tile" !== t4 && !!r5.supportsDynamicLayers, c3 = "tile" !== t4 && (!r5.tileInfo || u), y4 = "tile" !== t4 && (!r5.tileInfo || u), d5 = "tile" !== t4, m5 = r5.cimVersion && r4.parse(r5.cimVersion), h2 = (m5 == null ? void 0 : m5.since(1, 4)) ?? false, b3 = (m5 == null ? void 0 : m5.since(2, 0)) ?? false;
      return { operations: { supportsExportMap: a2, supportsExportTiles: l2, supportsIdentify: p5, supportsQuery: i, supportsTileMap: n5 }, exportMap: a2 ? { supportsArcadeExpressionForLabeling: h2, supportsSublayersChanges: d5, supportsDynamicLayers: u, supportsSublayerVisibility: c3, supportsSublayerDefinitionExpression: y4, supportsCIMSymbols: b3 } : null, exportTiles: l2 ? { maxExportTilesCount: +r5.maxExportTilesCount } : null };
    }
    readVersion(e3, r5) {
      let s6 = r5.currentVersion;
      return s6 || (s6 = r5.hasOwnProperty("capabilities") || r5.hasOwnProperty("tables") ? 10 : r5.hasOwnProperty("supportedImageFormatTypes") ? 9.31 : 9.3), s6;
    }
    async fetchSublayerInfo(e3, r5) {
      return await this.fetchAllLayersAndTables(r5), this._allLayersAndTablesMap.get(e3);
    }
    async fetchAllLayersAndTables(e3) {
      await this.load(e3), this._allLayersAndTablesPromise || (this._allLayersAndTablesPromise = U2(j2(this.url).path + "/layers", { responseType: "json", query: { f: "json", ...this.customParameters, token: this.apiKey } }).then((e4) => {
        this._allLayersAndTablesMap = /* @__PURE__ */ new Map();
        for (const r5 of e4.data.layers)
          this._allLayersAndTablesMap.set(r5.id, r5);
        return { result: e4.data };
      }, (e4) => ({ error: e4 })));
      const o2 = await this._allLayersAndTablesPromise;
      if (f(e3), "result" in o2)
        return o2.result;
      throw o2.error;
    }
  };
  return e([d({ readOnly: true })], d4.prototype, "capabilities", void 0), e([o("service", "capabilities", ["capabilities", "exportTilesAllowed", "maxExportTilesCount", "supportsDynamicLayers", "tileInfo"])], d4.prototype, "readCapabilities", null), e([d({ json: { read: { source: "copyrightText" } } })], d4.prototype, "copyright", void 0), e([d({ type: M })], d4.prototype, "fullExtent", void 0), e([d(v2)], d4.prototype, "id", void 0), e([d({ type: Boolean, json: { origins: { service: { read: { enabled: false } } }, read: { source: "showLegend" }, write: { target: "showLegend" } } })], d4.prototype, "legendEnabled", void 0), e([d(p2)], d4.prototype, "popupEnabled", void 0), e([d({ type: k })], d4.prototype, "spatialReference", void 0), e([d({ readOnly: true })], d4.prototype, "version", void 0), e([o("version", ["currentVersion", "capabilities", "tables", "supportedImageFormatTypes"])], d4.prototype, "readVersion", null), d4 = e([n2("esri.layers.mixins.ArcGISMapService")], d4), d4;
};

// node_modules/@arcgis/core/layers/support/Sublayer.js
var k2;
function q(e3) {
  return e3 && "esriSMS" === e3.type;
}
function $(e3, r5, i) {
  var _a;
  const t4 = this.originIdOf(r5) >= t(i.origin);
  return { ignoreOrigin: true, allowNull: t4, enabled: !!i && ("map-image" === ((_a = i.layer) == null ? void 0 : _a.type) && (i.writeSublayerStructure || t4)) };
}
function J(e3, r5, i) {
  var _a;
  return { enabled: !!i && ("tile" === ((_a = i.layer) == null ? void 0 : _a.type) && this._isOverridden(r5)) };
}
function B2(e3, r5, i) {
  return { ignoreOrigin: true, enabled: i && i.writeSublayerStructure || false };
}
function Q(e3, r5, i) {
  return { ignoreOrigin: true, enabled: !!i && (i.writeSublayerStructure || this.originIdOf(r5) >= t(i.origin)) };
}
var G = s.getLogger("esri.layers.support.Sublayer");
var H = 0;
var K2 = /* @__PURE__ */ new Set();
K2.add("layer"), K2.add("parent"), K2.add("loaded"), K2.add("loadStatus"), K2.add("loadError"), K2.add("loadWarnings");
var W = k2 = class extends a(O(s5(m3))) {
  constructor(e3) {
    super(e3), this.capabilities = void 0, this.fields = null, this.fullExtent = null, this.globalIdField = null, this.legendEnabled = true, this.objectIdField = null, this.popupEnabled = true, this.popupTemplate = null, this.sourceJSON = null, this.title = null, this.typeIdField = null, this.types = null;
  }
  async load(e3) {
    return this.addResolvingPromise((async () => {
      var _a, _b;
      if (!this.layer && !this.url)
        throw new s2("sublayer:missing-layer", "Sublayer can't be loaded without being part of a layer", { sublayer: this });
      let r5 = null;
      if (!this.layer || this.originIdOf("url") > r2.SERVICE || "data-layer" === ((_a = this.source) == null ? void 0 : _a.type)) {
        r5 = (await U2(this.url, { responseType: "json", query: { f: "json" }, ...e3 })).data;
      } else {
        let i = this.id;
        "map-layer" === ((_b = this.source) == null ? void 0 : _b.type) && (i = this.source.mapLayerId), r5 = await this.layer.fetchSublayerInfo(i, e3);
      }
      r5 && (this.sourceJSON = r5, this.read({ layerDefinition: r5 }, { origin: "service" }));
    })()), this;
  }
  readCapabilities(e3, r5) {
    const i = (e3 = (r5 = r5.layerDefinition || r5).capabilities || e3) ? e3.toLowerCase().split(",").map((e4) => e4.trim()) : [], t4 = this.url ? m2(this.url) : null, o2 = i.includes(r(t4) && "MapServer" === t4.serverType ? "data" : "query");
    return { exportMap: { supportsModification: !!r5.canModifyLayer }, operations: { supportsQuery: o2 } };
  }
  set definitionExpression(e3) {
    this._setAndNotifyLayer("definitionExpression", e3);
  }
  get fieldsIndex() {
    return new d2(this.fields || []);
  }
  set floorInfo(e3) {
    this._setAndNotifyLayer("floorInfo", e3);
  }
  readGlobalIdFieldFromService(e3, r5) {
    if ((r5 = r5.layerDefinition || r5).globalIdField)
      return r5.globalIdField;
    if (r5.fields) {
      for (const i of r5.fields)
        if ("esriFieldTypeGlobalID" === i.type)
          return i.name;
    }
  }
  get id() {
    const e3 = this._get("id");
    return null == e3 ? H++ : e3;
  }
  set id(e3) {
    this._get("id") !== e3 && (false !== this.get("layer.capabilities.exportMap.supportsDynamicLayers") ? this._set("id", e3) : this._logLockedError("id", "capability not available 'layer.capabilities.exportMap.supportsDynamicLayers'"));
  }
  set labelingInfo(e3) {
    this._setAndNotifyLayer("labelingInfo", e3);
  }
  writeLabelingInfo(e3, r5, i, t4) {
    e3 && e3.length && (r5.layerDefinition = { drawingInfo: { labelingInfo: e3.map((e4) => e4.write({}, t4)) } });
  }
  set labelsVisible(e3) {
    this._setAndNotifyLayer("labelsVisible", e3);
  }
  set layer(e3) {
    this._set("layer", e3), this.sublayers && this.sublayers.forEach((r5) => r5.layer = e3);
  }
  set listMode(e3) {
    this._set("listMode", e3);
  }
  set minScale(e3) {
    this._setAndNotifyLayer("minScale", e3);
  }
  readMinScale(e3, r5) {
    return r5.minScale || r5.layerDefinition && r5.layerDefinition.minScale || 0;
  }
  set maxScale(e3) {
    this._setAndNotifyLayer("maxScale", e3);
  }
  readMaxScale(e3, r5) {
    return r5.maxScale || r5.layerDefinition && r5.layerDefinition.maxScale || 0;
  }
  get effectiveScaleRange() {
    const { minScale: e3, maxScale: r5 } = this;
    return { minScale: e3, maxScale: r5 };
  }
  readObjectIdFieldFromService(e3, r5) {
    if ((r5 = r5.layerDefinition || r5).objectIdField)
      return r5.objectIdField;
    if (r5.fields) {
      for (const i of r5.fields)
        if ("esriFieldTypeOID" === i.type)
          return i.name;
    }
  }
  set opacity(e3) {
    this._setAndNotifyLayer("opacity", e3);
  }
  readOpacity(e3, r5) {
    const i = r5.layerDefinition;
    return 1 - 0.01 * (null != i.transparency ? i.transparency : i.drawingInfo.transparency);
  }
  writeOpacity(e3, r5, i, t4) {
    r5.layerDefinition = { drawingInfo: { transparency: 100 - 100 * e3 } };
  }
  writeParent(e3, r5) {
    this.parent && this.parent !== this.layer ? r5.parentLayerId = s3(this.parent.id) : r5.parentLayerId = -1;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set renderer(e3) {
    if (e3) {
      for (const r5 of e3.getSymbols())
        if (c2(r5)) {
          G.warn("Sublayer renderer should use 2D symbols");
          break;
        }
    }
    this._setAndNotifyLayer("renderer", e3);
  }
  get source() {
    return this._get("source") || new c({ mapLayerId: this.id });
  }
  set source(e3) {
    this._setAndNotifyLayer("source", e3);
  }
  set sublayers(e3) {
    this._handleSublayersChange(e3, this._get("sublayers")), this._set("sublayers", e3);
  }
  castSublayers(e3) {
    return b(j.ofType(k2), e3);
  }
  writeSublayers(e3, r5, i) {
    this.get("sublayers.length") && (r5[i] = this.sublayers.map((e4) => e4.id).toArray().reverse());
  }
  readTypeIdField(e3, r5) {
    let i = (r5 = r5.layerDefinition || r5).typeIdField;
    if (i && r5.fields) {
      i = i.toLowerCase();
      const e4 = r5.fields.find((e5) => e5.name.toLowerCase() === i);
      e4 && (i = e4.name);
    }
    return null;
  }
  get url() {
    var _a;
    const e3 = ((_a = this.layer) == null ? void 0 : _a.parsedUrl) ?? this._lastParsedUrl, r5 = this.source;
    if (!e3)
      return null;
    if (this._lastParsedUrl = e3, "map-layer" === (r5 == null ? void 0 : r5.type))
      return `${e3.path}/${r5.mapLayerId}`;
    const i = { layer: JSON.stringify({ source: this.source }) };
    return `${e3.path}/dynamicLayer?${I(i)}`;
  }
  set url(e3) {
    e3 ? this._override("url", e3) : this._clearOverride("url");
  }
  set visible(e3) {
    this._setAndNotifyLayer("visible", e3);
  }
  writeVisible(e3, r5, i, t4) {
    r5[i] = this.getAtOrigin("defaultVisibility", "service") || e3;
  }
  clone() {
    const { store: e3 } = e2(this), r5 = new k2();
    return e2(r5).store = e3.clone(K2), this.commitProperty("url"), r5._lastParsedUrl = this._lastParsedUrl, r5;
  }
  createPopupTemplate(e3) {
    return d3(this, e3);
  }
  createQuery() {
    return new b2({ returnGeometry: true, where: this.definitionExpression || "1=1" });
  }
  async createFeatureLayer() {
    var _a, _b;
    if (this.hasOwnProperty("sublayers"))
      return null;
    const e3 = (_a = this.layer) == null ? void 0 : _a.parsedUrl, r5 = new (0, (await import("./@arcgis_core_layers_FeatureLayer.js")).default)({ url: e3.path });
    return e3 && this.source && ("map-layer" === this.source.type ? r5.layerId = this.source.mapLayerId : r5.dynamicDataSource = this.source), null != this.layer.refreshInterval && (r5.refreshInterval = this.layer.refreshInterval), this.definitionExpression && (r5.definitionExpression = this.definitionExpression), this.floorInfo && (r5.floorInfo = m(this.floorInfo)), this.originIdOf("labelingInfo") > r2.SERVICE && (r5.labelingInfo = m(this.labelingInfo)), this.originIdOf("labelsVisible") > r2.DEFAULTS && (r5.labelsVisible = this.labelsVisible), this.originIdOf("legendEnabled") > r2.DEFAULTS && (r5.legendEnabled = this.legendEnabled), this.originIdOf("visible") > r2.DEFAULTS && (r5.visible = this.visible), this.originIdOf("minScale") > r2.DEFAULTS && (r5.minScale = this.minScale), this.originIdOf("maxScale") > r2.DEFAULTS && (r5.maxScale = this.maxScale), this.originIdOf("opacity") > r2.DEFAULTS && (r5.opacity = this.opacity), this.originIdOf("popupTemplate") > r2.DEFAULTS && (r5.popupTemplate = m(this.popupTemplate)), this.originIdOf("renderer") > r2.SERVICE && (r5.renderer = m(this.renderer)), "data-layer" === ((_b = this.source) == null ? void 0 : _b.type) && (r5.dynamicDataSource = this.source.clone()), this.originIdOf("title") > r2.DEFAULTS && (r5.title = this.title), "map-image" === this.layer.type && this.layer.originIdOf("customParameters") > r2.DEFAULTS && (r5.customParameters = this.layer.customParameters), "tile" === this.layer.type && this.layer.originIdOf("customParameters") > r2.DEFAULTS && (r5.customParameters = this.layer.customParameters), r5;
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFeatureType(e3) {
    const { typeIdField: r5, types: i } = this;
    if (!r5 || !e3)
      return null;
    const t4 = e3.attributes ? e3.attributes[r5] : void 0;
    if (null == t4)
      return null;
    let o2 = null;
    return i.some((e4) => {
      const { id: r6 } = e4;
      return null != r6 && (r6.toString() === t4.toString() && (o2 = e4), !!o2);
    }), o2;
  }
  getFieldDomain(e3, r5) {
    const i = r5 && r5.feature, t4 = this.getFeatureType(i);
    if (t4) {
      const r6 = t4.domains && t4.domains[e3];
      if (r6 && "inherited" !== r6.type)
        return r6;
    }
    return this._getLayerDomain(e3);
  }
  async queryFeatures(e3 = this.createQuery(), r5) {
    var _a, _b, _c, _d, _e;
    if (await this.load(), !((_b = (_a = this.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQuery))
      throw new s2("Sublayer.queryFeatures", "this layer doesn't support queries.");
    const [{ executeQuery: i }, { default: t4 }] = await Promise.all([import("./query-AQLV5SXY.js"), import("./FeatureSet-2FGND3DZ.js")]), o2 = await i(this.url, b2.from(e3), ((_c = this.layer) == null ? void 0 : _c.spatialReference) ?? null, { ...r5, query: { ...(_d = this.layer) == null ? void 0 : _d.customParameters, token: (_e = this.layer) == null ? void 0 : _e.apiKey } }), s6 = t4.fromJSON(o2.data);
    if (s6 == null ? void 0 : s6.features)
      for (const a2 of s6.features)
        a2.sourceLayer = this;
    return s6;
  }
  toExportImageJSON(e3) {
    var _a;
    const r5 = { id: this.id, source: ((_a = this.source) == null ? void 0 : _a.toJSON()) || { mapLayerId: this.id, type: "mapLayer" } }, i = t2(e3, this.definitionExpression);
    r(i) && (r5.definitionExpression = i);
    const t4 = ["renderer", "labelingInfo", "opacity", "labelsVisible"].reduce((e4, r6) => (e4[r6] = this.originIdOf(r6), e4), {}), o2 = Object.keys(t4).some((e4) => t4[e4] > r2.SERVICE);
    if (o2) {
      const e4 = r5.drawingInfo = {};
      t4.renderer > r2.SERVICE && (e4.renderer = this.renderer ? this.renderer.toJSON() : null), t4.labelsVisible > r2.SERVICE && (e4.showLabels = this.labelsVisible), this.labelsVisible && t4.labelingInfo > r2.SERVICE && (e4.labelingInfo = this.labelingInfo ? this.labelingInfo.map((e5) => e5.write({}, { origin: "service", layer: this.layer })) : null, e4.showLabels = true), t4.opacity > r2.SERVICE && (e4.transparency = 100 - 100 * this.opacity), this._assignDefaultSymbolColors(e4.renderer);
    }
    return r5;
  }
  _assignDefaultSymbolColors(e3) {
    this._forEachSimpleMarkerSymbols(e3, (e4) => {
      e4.color || "esriSMSX" !== e4.style && "esriSMSCross" !== e4.style || (e4.outline && e4.outline.color ? e4.color = e4.outline.color : e4.color = [0, 0, 0, 0]);
    });
  }
  _forEachSimpleMarkerSymbols(e3, r5) {
    if (e3) {
      const i = "uniqueValueInfos" in e3 ? e3.uniqueValueInfos : "classBreakInfos" in e3 ? e3.classBreakInfos : [];
      for (const e4 of i)
        q(e4.symbol) && r5(e4.symbol);
      "symbol" in e3 && q(e3.symbol) && r5(e3.symbol), "defaultSymbol" in e3 && q(e3.defaultSymbol) && r5(e3.defaultSymbol);
    }
  }
  _setAndNotifyLayer(e3, r5) {
    const i = this.layer, t4 = this._get(e3);
    let o2, s6;
    switch (e3) {
      case "definitionExpression":
      case "floorInfo":
        o2 = "supportsSublayerDefinitionExpression";
      case "minScale":
      case "maxScale":
      case "visible":
        o2 = "supportsSublayerVisibility";
        break;
      case "labelingInfo":
      case "labelsVisible":
      case "opacity":
      case "renderer":
      case "source":
        o2 = "supportsDynamicLayers", s6 = "supportsModification";
    }
    const a2 = e2(this).getDefaultOrigin();
    if ("service" !== a2) {
      if (o2 && false === this.get(`layer.capabilities.exportMap.${o2}`))
        return void this._logLockedError(e3, `capability not available 'layer.capabilities.exportMap.${o2}'`);
      if (s6 && false === this.get(`capabilities.exportMap.${s6}`))
        return void this._logLockedError(e3, `capability not available 'capabilities.exportMap.${s6}'`);
    }
    "source" !== e3 || "not-loaded" === this.loadStatus ? (this._set(e3, r5), "service" !== a2 && t4 !== r5 && i && i.emit && i.emit("sublayer-update", { propertyName: e3, target: this })) : this._logLockedError(e3, "'source' can't be changed after calling sublayer.load()");
  }
  _handleSublayersChange(e3, r5) {
    r5 && (r5.forEach((e4) => {
      e4.parent = null, e4.layer = null;
    }), this.handles.removeAll()), e3 && (e3.forEach((e4) => {
      e4.parent = this, e4.layer = this.layer;
    }), this.handles.add([e3.on("after-add", ({ item: e4 }) => {
      e4.parent = this, e4.layer = this.layer;
    }), e3.on("after-remove", ({ item: e4 }) => {
      e4.parent = null, e4.layer = null;
    }), e3.on("before-changes", (e4) => {
      const r6 = this.get("layer.capabilities.exportMap.supportsSublayersChanges");
      null == r6 || r6 || (G.error(new s2("sublayer:sublayers-non-modifiable", "Sublayer can't be added, moved, or removed from the layer's sublayers", { sublayer: this, layer: this.layer })), e4.preventDefault());
    })]));
  }
  _logLockedError(e3, r5) {
    G.error(new s2("sublayer:locked", `Property '${String(e3)}' can't be changed on Sublayer from the layer '${this.layer.id}'`, { reason: r5, sublayer: this, layer: this.layer }));
  }
  _getLayerDomain(e3) {
    const r5 = this.fieldsIndex.get(e3);
    return r5 ? r5.domain : null;
  }
};
W.test = { isMapImageLayerOverridePolicy: (e3) => e3 === B2 || e3 === $, isTileImageLayerOverridePolicy: (e3) => e3 === J }, e([d({ readOnly: true })], W.prototype, "capabilities", void 0), e([o("service", "capabilities", ["layerDefinition.canModifyLayer", "layerDefinition.capabilities"])], W.prototype, "readCapabilities", null), e([d({ type: String, value: null, json: { name: "layerDefinition.definitionExpression", write: { allowNull: true, overridePolicy: $ } } })], W.prototype, "definitionExpression", null), e([d({ type: [y], json: { origins: { service: { read: { source: "layerDefinition.fields" } } } } })], W.prototype, "fields", void 0), e([d({ readOnly: true })], W.prototype, "fieldsIndex", null), e([d({ type: p4, value: null, json: { name: "layerDefinition.floorInfo", read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo", overridePolicy: $ }, origins: { "web-scene": { read: false, write: false } } } })], W.prototype, "floorInfo", null), e([d({ type: M, json: { read: { source: "layerDefinition.extent" } } })], W.prototype, "fullExtent", void 0), e([d({ type: String })], W.prototype, "globalIdField", void 0), e([o("service", "globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], W.prototype, "readGlobalIdFieldFromService", null), e([d({ type: S, json: { write: { ignoreOrigin: true } } })], W.prototype, "id", null), e([d({ value: null, type: [j3], json: { read: { source: "layerDefinition.drawingInfo.labelingInfo" }, write: { target: "layerDefinition.drawingInfo.labelingInfo", overridePolicy: B2 } } })], W.prototype, "labelingInfo", null), e([r3("labelingInfo")], W.prototype, "writeLabelingInfo", null), e([d({ type: Boolean, value: true, json: { read: { source: "layerDefinition.drawingInfo.showLabels" }, write: { target: "layerDefinition.drawingInfo.showLabels", overridePolicy: B2 } } })], W.prototype, "labelsVisible", null), e([d({ value: null })], W.prototype, "layer", null), e([d({ type: Boolean, value: true, json: { origins: { service: { read: { enabled: false } } }, read: { source: "showLegend" }, write: { target: "showLegend", overridePolicy: Q } } })], W.prototype, "legendEnabled", void 0), e([d({ type: ["show", "hide", "hide-children"], value: "show", json: { read: false, write: false, origins: { "web-scene": { read: true, write: true } } } })], W.prototype, "listMode", null), e([d({ type: Number, value: 0, json: { write: { overridePolicy: B2 } } })], W.prototype, "minScale", null), e([o("minScale", ["minScale", "layerDefinition.minScale"])], W.prototype, "readMinScale", null), e([d({ type: Number, value: 0, json: { write: { overridePolicy: B2 } } })], W.prototype, "maxScale", null), e([o("maxScale", ["maxScale", "layerDefinition.maxScale"])], W.prototype, "readMaxScale", null), e([d({ readOnly: true })], W.prototype, "effectiveScaleRange", null), e([d({ type: String })], W.prototype, "objectIdField", void 0), e([o("service", "objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], W.prototype, "readObjectIdFieldFromService", null), e([d({ type: Number, value: 1, json: { write: { target: "layerDefinition.drawingInfo.transparency", overridePolicy: B2 } } })], W.prototype, "opacity", null), e([o("opacity", ["layerDefinition.drawingInfo.transparency", "layerDefinition.transparency"])], W.prototype, "readOpacity", null), e([r3("opacity")], W.prototype, "writeOpacity", null), e([d({ json: { type: S, write: { target: "parentLayerId", writerEnsuresNonNull: true, overridePolicy: B2 } } })], W.prototype, "parent", void 0), e([r3("parent")], W.prototype, "writeParent", null), e([d({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e3, r5) => !r5.disablePopup }, write: { target: "disablePopup", overridePolicy: Q, writer(e3, r5, i) {
  r5[i] = !e3;
} } } })], W.prototype, "popupEnabled", void 0), e([d({ type: B, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy: Q } } })], W.prototype, "popupTemplate", void 0), e([d({ readOnly: true })], W.prototype, "defaultPopupTemplate", null), e([d({ types: p3, value: null, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: B2 }, origins: { "web-scene": { types: n3, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: B2 } } } } })], W.prototype, "renderer", null), e([d({ types: { key: "type", base: null, typeMap: { "data-layer": K, "map-layer": c } }, cast(e3) {
  if (e3) {
    if ("mapLayerId" in e3)
      return v(c, e3);
    if ("dataSource" in e3)
      return v(K, e3);
  }
  return e3;
}, json: { name: "layerDefinition.source", write: { overridePolicy: B2 } } })], W.prototype, "source", null), e([d()], W.prototype, "sourceJSON", void 0), e([d({ value: null, json: { type: [S], write: { target: "subLayerIds", allowNull: true, overridePolicy: B2 } } })], W.prototype, "sublayers", null), e([s4("sublayers")], W.prototype, "castSublayers", null), e([r3("sublayers")], W.prototype, "writeSublayers", null), e([d({ type: String, json: { name: "name", write: { overridePolicy: Q } } })], W.prototype, "title", void 0), e([d({ type: String })], W.prototype, "typeIdField", void 0), e([o("typeIdField", ["layerDefinition.typeIdField"])], W.prototype, "readTypeIdField", null), e([d({ type: [n4], json: { origins: { service: { read: { source: "layerDefinition.types" } } } } })], W.prototype, "types", void 0), e([d({ type: String, json: { read: { source: "layerUrl" }, write: { target: "layerUrl", overridePolicy: J } } })], W.prototype, "url", null), e([d({ type: Boolean, value: true, json: { read: { source: "defaultVisibility" }, write: { target: "defaultVisibility", overridePolicy: B2 } } })], W.prototype, "visible", null), e([r3("visible")], W.prototype, "writeVisible", null), W = k2 = e([n2("esri.layers.support.Sublayer")], W);
var X = W;

// node_modules/@arcgis/core/layers/mixins/SublayersOwner.js
var f2 = s.getLogger("esri.layers.TileLayer");
function h(e3, r5) {
  const s6 = [], t4 = {};
  return e3 ? (e3.forEach((e4) => {
    const o2 = new X();
    if (o2.read(e4, r5), t4[o2.id] = o2, null != e4.parentLayerId && -1 !== e4.parentLayerId) {
      const r6 = t4[e4.parentLayerId];
      r6.sublayers || (r6.sublayers = []), r6.sublayers.unshift(o2);
    } else
      s6.unshift(o2);
  }), s6) : s6;
}
var S2 = j.ofType(X);
function m4(e3, r5) {
  e3 && e3.forEach((e4) => {
    r5(e4), e4.sublayers && e4.sublayers.length && m4(e4.sublayers, r5);
  });
}
var E = (o2) => {
  let E2 = class extends o2 {
    constructor(...e3) {
      super(...e3), this.allSublayers = new p({ getCollections: () => [this.sublayers], getChildrenFunction: (e4) => e4.sublayers }), this.sublayersSourceJSON = { [r2.SERVICE]: {}, [r2.PORTAL_ITEM]: {}, [r2.WEB_SCENE]: {}, [r2.WEB_MAP]: {} }, this.own(l(() => this.sublayers, (e4, r5) => this._handleSublayersChange(e4, r5), U));
    }
    readSublayers(e3, r5) {
      if (!r5 || !e3)
        return;
      const { sublayersSourceJSON: s6 } = this, t4 = t(r5.origin);
      if (t4 < r2.SERVICE)
        return;
      if (s6[t4] = { context: r5, visibleLayers: e3.visibleLayers || s6[t4].visibleLayers, layers: e3.layers || s6[t4].layers }, t4 > r2.SERVICE)
        return;
      this._set("serviceSublayers", this.createSublayersForOrigin("service").sublayers);
      const { sublayers: o3, origin: a2 } = this.createSublayersForOrigin("web-document"), i = e2(this);
      i.setDefaultOrigin(a2), this._set("sublayers", new S2(o3)), i.setDefaultOrigin("user");
    }
    findSublayerById(e3) {
      return this.allSublayers.find((r5) => r5.id === e3);
    }
    createServiceSublayers() {
      return this.createSublayersForOrigin("service").sublayers;
    }
    createSublayersForOrigin(e3) {
      const r5 = t("web-document" === e3 ? "web-map" : e3);
      let s6 = r2.SERVICE, t4 = this.sublayersSourceJSON[r2.SERVICE].layers, o3 = this.sublayersSourceJSON[r2.SERVICE].context, a2 = null;
      const i = [r2.PORTAL_ITEM, r2.WEB_SCENE, r2.WEB_MAP].filter((e4) => e4 <= r5);
      for (const y3 of i) {
        const e4 = this.sublayersSourceJSON[y3];
        t3(e4.layers) && (s6 = y3, t4 = e4.layers, o3 = e4.context, e4.visibleLayers && (a2 = { visibleLayers: e4.visibleLayers, context: e4.context }));
      }
      const l2 = [r2.PORTAL_ITEM, r2.WEB_SCENE, r2.WEB_MAP].filter((e4) => e4 > s6 && e4 <= r5);
      let n5 = null;
      for (const y3 of l2) {
        const { layers: e4, visibleLayers: r6, context: s7 } = this.sublayersSourceJSON[y3];
        e4 && (n5 = { layers: e4, context: s7 }), r6 && (a2 = { visibleLayers: r6, context: s7 });
      }
      const u = h(t4, o3), p5 = /* @__PURE__ */ new Map(), f3 = /* @__PURE__ */ new Set();
      if (n5)
        for (const y3 of n5.layers)
          p5.set(y3.id, y3);
      if (a2)
        for (const y3 of a2.visibleLayers)
          f3.add(y3);
      return m4(u, (e4) => {
        n5 && e4.read(p5.get(e4.id), n5.context), a2 && e4.read({ defaultVisibility: f3.has(e4.id) }, a2.context);
      }), { origin: n(s6), sublayers: new S2({ items: u }) };
    }
    read(e3, r5) {
      super.read(e3, r5), this.readSublayers(e3, r5);
    }
    _handleSublayersChange(e3, r5) {
      r5 && (r5.forEach((e4) => {
        e4.parent = null, e4.layer = null;
      }), this.handles.remove("sublayers-owner")), e3 && (e3.forEach((e4) => {
        e4.parent = this, e4.layer = this;
      }), this.handles.add([e3.on("after-add", ({ item: e4 }) => {
        e4.parent = this, e4.layer = this;
      }), e3.on("after-remove", ({ item: e4 }) => {
        e4.parent = null, e4.layer = null;
      })], "sublayers-owner"), "tile" === this.type && this.handles.add(e3.on("before-changes", (e4) => {
        f2.error(new s2("tilelayer:sublayers-non-modifiable", "ISublayer can't be added, moved, or removed from the layer's sublayers", { layer: this })), e4.preventDefault();
      }), "sublayers-owner"));
    }
  };
  return e([d({ readOnly: true })], E2.prototype, "allSublayers", void 0), e([d({ readOnly: true, type: j.ofType(X) })], E2.prototype, "serviceSublayers", void 0), e([d({ value: null, type: S2, json: { read: false, write: { allowNull: true, ignoreOrigin: true } } })], E2.prototype, "sublayers", void 0), e([d({ readOnly: true })], E2.prototype, "sublayersSourceJSON", void 0), E2 = e([n2("esri.layers.mixins.SublayersOwner")], E2), E2;
};

export {
  y2 as y,
  X,
  E
};
//# sourceMappingURL=chunk-24ZW6JTQ.js.map
