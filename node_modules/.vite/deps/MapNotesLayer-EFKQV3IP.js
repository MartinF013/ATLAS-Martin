import {
  n as n2
} from "./chunk-AMX572WK.js";
import {
  L
} from "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import {
  An,
  en,
  rn,
  tn
} from "./chunk-PZWU5EHT.js";
import {
  h
} from "./chunk-BS7TS6UC.js";
import "./chunk-37ZVELW7.js";
import {
  Ke
} from "./chunk-7LOJJ46D.js";
import "./chunk-VNR743PA.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-SWCA522B.js";
import "./chunk-YPIBZ3CH.js";
import "./chunk-XLCZFN6R.js";
import "./chunk-OMNBM2E4.js";
import "./chunk-WKHS6QIX.js";
import "./chunk-6O7ZZEV7.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-OBCAVCXI.js";
import "./chunk-RFOZTYJH.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-L2YBXQTH.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-4XBERLPX.js";
import "./chunk-SZPDY7KN.js";
import "./chunk-Y6YGVGFR.js";
import "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import "./chunk-MZX3HN4G.js";
import "./chunk-T47JAOQZ.js";
import "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-RIWDMEW4.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import {
  y
} from "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  v
} from "./chunk-OG6CQEZJ.js";
import {
  c
} from "./chunk-X5Z3DJQ4.js";
import {
  O
} from "./chunk-BUWXVMJU.js";
import "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import {
  a
} from "./chunk-D3XXPCBB.js";
import {
  t as t3
} from "./chunk-OWBMOIIV.js";
import {
  b
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import {
  m2 as m3,
  y as y2
} from "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import {
  S,
  m as m2
} from "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  E,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import {
  r as r2
} from "./chunk-ZIHDQYKE.js";
import {
  o as o2
} from "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n,
  t6 as t2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import {
  m,
  o
} from "./chunk-G5JBUC5N.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/MapNotesLayer.js
function F(e2) {
  return e2.layers.some((e3) => null != e3.layerDefinition.visibilityField);
}
var G = new y({ name: "OBJECTID", alias: "OBJECTID", type: "oid", nullable: false, editable: false });
var _ = new y({ name: "title", alias: "Title", type: "string", nullable: true, editable: true });
var P = class extends h {
  constructor(e2) {
    super(e2), this.visibilityMode = "inherited";
  }
  initialize() {
    for (const e2 of this.graphics)
      e2.sourceLayer = this.layer;
    this.graphics.on("after-add", (e2) => {
      e2.item.sourceLayer = this.layer;
    }), this.graphics.on("after-remove", (e2) => {
      e2.item.sourceLayer = null;
    });
  }
  get sublayers() {
    return this.graphics;
  }
};
e([d({ readOnly: true })], P.prototype, "sublayers", null), e([d()], P.prototype, "layer", void 0), e([d()], P.prototype, "layerId", void 0), e([d({ readOnly: true })], P.prototype, "visibilityMode", void 0), P = e([n("esri.layers.MapNotesLayer.MapNotesSublayer")], P);
var k2 = [{ geometryType: "polygon", geometryTypeJSON: "esriGeometryPolygon", id: "polygonLayer", layerId: 0, title: "Polygons", identifyingSymbol: new S().toJSON() }, { geometryType: "polyline", geometryTypeJSON: "esriGeometryPolyline", id: "polylineLayer", layerId: 1, title: "Polylines", identifyingSymbol: new m2().toJSON() }, { geometryType: "multipoint", geometryTypeJSON: "esriGeometryMultipoint", id: "multipointLayer", layerId: 2, title: "Multipoints", identifyingSymbol: new y2().toJSON() }, { geometryType: "point", geometryTypeJSON: "esriGeometryPoint", id: "pointLayer", layerId: 3, title: "Points", identifyingSymbol: new y2().toJSON() }, { geometryType: "point", geometryTypeJSON: "esriGeometryPoint", id: "textLayer", layerId: 4, title: "Text", identifyingSymbol: new m3().toJSON() }];
var z = class extends a(t3(c(v(O(b))))) {
  constructor(e2) {
    super(e2), this.capabilities = { operations: { supportsMapNotesEditing: true } }, this.featureCollections = null, this.featureCollectionJSON = null, this.featureCollectionType = "notes", this.legendEnabled = false, this.minScale = 0, this.maxScale = 0, this.spatialReference = k.WGS84, this.sublayers = new j(k2.map((e3) => new P({ id: e3.id, layerId: e3.layerId, title: e3.title, layer: this }))), this.title = "Map Notes", this.type = "map-notes", this.visibilityMode = "inherited";
  }
  readCapabilities(e2, t4, r3) {
    return { operations: { supportsMapNotesEditing: !F(t4) && "portal-item" !== (r3 == null ? void 0 : r3.origin) } };
  }
  readFeatureCollections(e2, t4, o3) {
    if (!F(t4))
      return null;
    const i = t4.layers.map((e3) => {
      const t5 = new Ke();
      return t5.read(e3, o3), t5;
    });
    return new j({ items: i });
  }
  readLegacyfeatureCollectionJSON(e2, t4) {
    return F(t4) ? m(t4.featureCollection) : null;
  }
  readFullExtent(e2, t4) {
    if (!t4.layers.length || t4.layers.every((e3) => !e3.layerDefinition.extent))
      return new M({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: k.WGS84 });
    const r3 = k.fromJSON(t4.layers[0].layerDefinition.spatialReference);
    return t4.layers.reduce((e3, t5) => {
      const r4 = t5.layerDefinition.extent;
      return r4 ? M.fromJSON(r4).union(e3) : e3;
    }, new M({ spatialReference: r3 }));
  }
  readMinScale(e2, t4) {
    for (const r3 of t4.layers)
      if (null != r3.layerDefinition.minScale)
        return r3.layerDefinition.minScale;
    return 0;
  }
  readMaxScale(e2, t4) {
    for (const r3 of t4.layers)
      if (null != r3.layerDefinition.maxScale)
        return r3.layerDefinition.maxScale;
    return 0;
  }
  get multipointLayer() {
    return this._findSublayer("multipointLayer");
  }
  get pointLayer() {
    return this._findSublayer("pointLayer");
  }
  get polygonLayer() {
    return this._findSublayer("polygonLayer");
  }
  get polylineLayer() {
    return this._findSublayer("polylineLayer");
  }
  readSpatialReference(e2, t4) {
    return t4.layers.length ? k.fromJSON(t4.layers[0].layerDefinition.spatialReference) : k.WGS84;
  }
  readSublayers(e2, o3, i) {
    if (F(o3))
      return null;
    const a2 = [];
    let l = o3.layers.reduce((e3, t4) => Math.max(e3, t4.layerDefinition.id ?? -1), -1) + 1;
    for (const { layerDefinition: r3, featureSet: n3 } of o3.layers) {
      const e3 = r3.geometryType ?? n3.geometryType, o4 = r3.id ?? l++, i2 = k2.find((t4) => {
        var _a, _b, _c;
        return e3 === t4.geometryTypeJSON && ((_c = (_b = (_a = r3.drawingInfo) == null ? void 0 : _a.renderer) == null ? void 0 : _b.symbol) == null ? void 0 : _c.type) === t4.identifyingSymbol.type;
      });
      if (i2) {
        const e4 = new P({ id: i2.id, title: r3.name, layerId: o4, layer: this, graphics: n3.features.map(({ geometry: e5, symbol: r4, attributes: o5, popupInfo: i3 }) => g.fromJSON({ attributes: o5, geometry: e5, symbol: r4, popupTemplate: i3 })) });
        a2.push(e4);
      }
    }
    return new j(a2);
  }
  writeSublayers(e2, t4, r3, i) {
    var _a;
    const { minScale: n3, maxScale: p } = this;
    if (t(e2))
      return;
    const y3 = e2.some((e3) => e3.graphics.length > 0);
    if (!this.capabilities.operations.supportsMapNotesEditing)
      return void (y3 && ((_a = i == null ? void 0 : i.messages) == null ? void 0 : _a.push(new s("map-notes-layer:editing-not-supported", "New map notes cannot be added to this layer"))));
    const m4 = [];
    let u = this.spatialReference.toJSON();
    e:
      for (const o3 of e2)
        for (const e3 of o3.graphics)
          if (r(e3.geometry)) {
            u = e3.geometry.spatialReference.toJSON();
            break e;
          }
    for (const o3 of k2) {
      const t5 = e2.find((e3) => o3.id === e3.id);
      this._writeMapNoteSublayer(m4, t5, o3, n3, p, u, i);
    }
    o("featureCollection.layers", m4, t4);
  }
  get textLayer() {
    return this._findSublayer("textLayer");
  }
  load(e2) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e2)), Promise.resolve(this);
  }
  read(e2, t4) {
    "featureCollection" in e2 && (e2 = m(e2), Object.assign(e2, e2.featureCollection)), super.read(e2, t4);
  }
  async beforeSave() {
    if (t(this.sublayers))
      return;
    let e2 = null;
    const t4 = [];
    for (const o3 of this.sublayers)
      for (const r4 of o3.graphics)
        if (r(r4.geometry)) {
          const o4 = r4.geometry;
          e2 ? E(o4.spatialReference, e2) || (An(o4.spatialReference, e2) || en() || await tn(), r4.geometry = rn(o4, e2)) : e2 = o4.spatialReference, t4.push(r4);
        }
    const r3 = await L(t4.map((e3) => e3.geometry));
    t4.forEach((e3, t5) => e3.geometry = r3[t5]);
  }
  _findSublayer(e2) {
    var _a;
    return t(this.sublayers) ? null : ((_a = this.sublayers) == null ? void 0 : _a.find((t4) => t4.id === e2)) ?? null;
  }
  _writeMapNoteSublayer(e2, t4, r3, o3, l, n3, s2) {
    const p = [];
    if (!t(t4)) {
      for (const e3 of t4.graphics)
        this._writeMapNote(p, e3, r3.geometryType, s2);
      this._normalizeObjectIds(p, G), e2.push({ layerDefinition: { name: t4.title, drawingInfo: { renderer: { type: "simple", symbol: m(r3.identifyingSymbol) } }, id: t4.layerId, geometryType: r3.geometryTypeJSON, minScale: o3, maxScale: l, objectIdField: "OBJECTID", fields: [G.toJSON(), _.toJSON()], spatialReference: n3 }, featureSet: { features: p, geometryType: r3.geometryTypeJSON } });
    }
  }
  _writeMapNote(e2, t4, r3, o3) {
    var _a, _b;
    if (t(t4))
      return;
    const { geometry: i, symbol: n3, popupTemplate: s2 } = t4;
    if (t(i))
      return;
    if (i.type !== r3)
      return void ((_a = o3 == null ? void 0 : o3.messages) == null ? void 0 : _a.push(new t2("map-notes-layer:invalid-geometry-type", `Geometry "${i.type}" cannot be saved in "${r3}" layer`, { graphic: t4 })));
    if (t(n3))
      return void ((_b = o3 == null ? void 0 : o3.messages) == null ? void 0 : _b.push(new t2("map-notes-layer:no-symbol", "Skipping map notes with no symbol", { graphic: t4 })));
    const y3 = { attributes: { ...t4.attributes }, geometry: i.toJSON(), symbol: n3.toJSON() };
    r(s2) && (y3.popupInfo = s2.toJSON()), e2.push(y3);
  }
  _normalizeObjectIds(e2, t4) {
    const r3 = t4.name;
    let o3 = n2(r3, e2) + 1;
    const i = /* @__PURE__ */ new Set();
    for (const a2 of e2) {
      a2.attributes || (a2.attributes = {});
      const { attributes: e3 } = a2;
      (null == e3[r3] || i.has(e3[r3])) && (e3[r3] = o3++), i.add(e3[r3]);
    }
  }
};
e([d({ readOnly: true })], z.prototype, "capabilities", void 0), e([o2(["portal-item", "web-map"], "capabilities", ["layers"])], z.prototype, "readCapabilities", null), e([d({ readOnly: true })], z.prototype, "featureCollections", void 0), e([o2(["web-map", "portal-item"], "featureCollections", ["layers"])], z.prototype, "readFeatureCollections", null), e([d({ readOnly: true, json: { origins: { "web-map": { write: { enabled: true, target: "featureCollection" } } } } })], z.prototype, "featureCollectionJSON", void 0), e([o2(["web-map", "portal-item"], "featureCollectionJSON", ["featureCollection"])], z.prototype, "readLegacyfeatureCollectionJSON", null), e([d({ readOnly: true, json: { read: false, write: { enabled: true, ignoreOrigin: true } } })], z.prototype, "featureCollectionType", void 0), e([d({ json: { write: false } })], z.prototype, "fullExtent", void 0), e([o2(["web-map", "portal-item"], "fullExtent", ["layers"])], z.prototype, "readFullExtent", null), e([d({ readOnly: true, json: { origins: { "web-map": { write: { target: "featureCollection.showLegend", overridePolicy() {
  return { enabled: null != this.featureCollectionJSON };
} } } } } })], z.prototype, "legendEnabled", void 0), e([d({ type: ["show", "hide"] })], z.prototype, "listMode", void 0), e([d({ type: Number, nonNullable: true, json: { write: false } })], z.prototype, "minScale", void 0), e([o2(["web-map", "portal-item"], "minScale", ["layers"])], z.prototype, "readMinScale", null), e([d({ type: Number, nonNullable: true, json: { write: false } })], z.prototype, "maxScale", void 0), e([o2(["web-map", "portal-item"], "maxScale", ["layers"])], z.prototype, "readMaxScale", null), e([d({ readOnly: true })], z.prototype, "multipointLayer", null), e([d({ value: "ArcGISFeatureLayer", type: ["ArcGISFeatureLayer"] })], z.prototype, "operationalLayerType", void 0), e([d({ readOnly: true })], z.prototype, "pointLayer", null), e([d({ readOnly: true })], z.prototype, "polygonLayer", null), e([d({ readOnly: true })], z.prototype, "polylineLayer", null), e([d({ type: k })], z.prototype, "spatialReference", void 0), e([o2(["web-map", "portal-item"], "spatialReference", ["layers"])], z.prototype, "readSpatialReference", null), e([d({ readOnly: true, json: { origins: { "web-map": { write: { ignoreOrigin: true } } } } })], z.prototype, "sublayers", void 0), e([o2("web-map", "sublayers", ["layers"])], z.prototype, "readSublayers", null), e([r2("web-map", "sublayers")], z.prototype, "writeSublayers", null), e([d({ readOnly: true })], z.prototype, "textLayer", null), e([d()], z.prototype, "title", void 0), e([d({ readOnly: true, json: { read: false } })], z.prototype, "type", void 0), z = e([n("esri.layers.MapNotesLayer")], z);
var B = z;
export {
  B as default
};
//# sourceMappingURL=MapNotesLayer-EFKQV3IP.js.map
