import {
  n as n2
} from "./chunk-WLVMYWO2.js";
import {
  u as u2
} from "./chunk-6UGZAJSY.js";
import "./chunk-2EPPX4WN.js";
import {
  o
} from "./chunk-MV2XZ5BA.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-6GPADSSO.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  h,
  l as l2
} from "./chunk-T7BEWVV3.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-5N3FSR63.js";
import "./chunk-DMJWTK32.js";
import {
  E
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  l,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/3d/layers/VoxelLayerView3D.js
var y;
!function(e2) {
  e2[e2.API = 1] = "API", e2[e2.VerboseAPI = 2] = "VerboseAPI", e2[e2.Error = 3] = "Error";
}(y || (y = {}));
var g = s.getLogger(" esri.views.3d.layers.VoxelLayerView3D");
var V = class extends n2(u2) {
  constructor() {
    super(...arguments), this._usedMemory = 0, this._futureMemory = 0, this.type = "voxel-3d", this._wasmLayerId = -1, this._handles = new u(), this._dbgFlags = /* @__PURE__ */ new Set();
  }
  get wasmLayerId() {
    return this._wasmLayerId;
  }
  initialize() {
    var _a;
    if ("local" !== this.view.viewingMode)
      throw new s2("voxel:unsupported-viewingMode", "Voxel layers support local viewingMode only.", {});
    if (this.view._stage.renderView.renderingContext.type !== o.WEBGL2)
      throw new s2("voxel:unsupported-context", "Voxel layers are supported in WebGL2 rendering contexts only.", {});
    if (!!!((_a = this.view._stage.renderView.renderingContext.capabilities.colorBufferFloat) == null ? void 0 : _a.textureFloat))
      throw new s2("voxel:missing-color-buffer-float", "Voxel layers require the WebGL2 extension EXT_color_buffer_float", {});
    const e2 = this.layer.spatialReference;
    if (!E(e2, this.view.spatialReference))
      throw new s2("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
    const t2 = this.layer.currentVariableId, r2 = this.layer.getVolume(t2), a = this.layer.getVariable(t2);
    if (r(r2) && r(a)) {
      const e3 = r2.dimensions[0], s3 = r2.dimensions[1], t3 = r2.getZDimension();
      if (t3 > 1) {
        const i = r2.dimensions[t3], o3 = e3.size * s3.size * i.size;
        let l3 = 1;
        switch (a.renderingFormat.type) {
          case "Int16":
          case "UInt16":
            l3 = 2;
            break;
          case "Int32":
          case "UInt32":
          case "Float32":
            l3 = 4;
        }
        this._futureMemory = l3 * o3;
      }
    }
    const o2 = this.view.addVoxelLayerViewToWasm(this).then((e3) => {
      this._wasmLayerId = e3, this._suspendedHandle = l2(() => this.suspended, (e4) => {
        const s3 = this.view.voxelWasm;
        r(s3) && s3.setEnabled(this, !e4);
      }, h), this._handles.add([l2(() => this.layer.renderMode, (e4) => this._pushRenderModeToWasm(e4)), l2(() => this.layer.currentVariableId, (e4) => this._pushCurrentVariableIdToWasm(e4)), l2(() => this.layer.getDynamicSections(), (e4) => this._pushDynamicSectionsToWasm(e4)), l2(() => this.layer.getSlices(), (e4) => this._pushSlicesToWasm(e4)), l2(() => this.layer.getSections(), (e4) => this._pushSectionsToWasm(e4)), l2(() => this.layer.getVerticalExaggeration(), (e4) => this._pushVerticalExaggerationToWasm(e4)), l2(() => this.layer.getVerticalOffset(), (e4) => this._pushVerticalOffsetToWasm(e4))]);
    }).catch((e3) => {
      if (this.view.removeVoxelLayerViewFromWasm(this), this._wasmLayerId = -1, -1 === e3)
        throw new s2("voxel:addLayer-failure", "The voxel layer description was invalid.", {});
      if (-2 === e3)
        throw new s2("voxel:addLayer-failure", "The voxel layer web assembly module failed to download.", {});
    });
    this.addResolvingPromise(o2);
  }
  destroy() {
    this.view.removeVoxelLayerViewFromWasm(this), this._suspendedHandle && (this._suspendedHandle.remove(), this._suspendedHandle = null), this._handles = l(this._handles);
  }
  isUpdating() {
    const e2 = this.view.voxelWasm;
    return !(this._wasmLayerId < 0 || !r(e2)) && e2.isUpdating(this._wasmLayerId);
  }
  updatingFlagChanged() {
    this.notifyChange("updating");
  }
  getUsedMemory() {
    return this._usedMemory;
  }
  getUnloadedMemory() {
    return this._futureMemory;
  }
  ignoresMemoryFactor() {
    return true;
  }
  get performanceInfo() {
    return { nodes: 0, displayedNumberOfFeatures: 0, maximumNumberOfFeatures: 0, totalNumberOfFeatures: 0, core: null };
  }
  setUsedMemory(e2) {
    this._usedMemory = e2, this._futureMemory = 0;
  }
  captureFrustum() {
    const e2 = this.view.voxelWasm;
    r(e2) && e2.captureFrustum();
  }
  toggleFullVolumeExtentDraw() {
    const e2 = this.view.voxelWasm;
    r(e2) && e2.toggleFullVolumeExtentDraw(this);
  }
  _pushRenderModeToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(y.VerboseAPI, "VoxelLayerView3D._pushRenderModeToWasm() called, " + (r(s3) ? "have WASM" : "don't have WASM!!!"));
    !!r(s3) && s3.setRenderMode(this, e2) || this._dbg(y.Error, "VoxelLayerView3D._pushRenderModeToWasm() failed!");
  }
  _pushSlicesToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(y.VerboseAPI, "VoxelLayerView3D._pushSlicesToWasm() called, " + (r(s3) ? "have WASM" : "don't have WASM!!!"));
    !!r(s3) && s3.setSlices(this, e2) || this._dbg(y.Error, "VoxelLayerView3D._pushSlicesToWasm() failed!");
  }
  _pushSectionsToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(y.VerboseAPI, "VoxelLayerView3D._pushSectionsToWasm() called, " + (r(s3) ? "have WASM" : "don't have WASM!!!"));
    !!r(s3) && s3.setStaticSections(this, e2) || this._dbg(y.Error, "VoxelLayerView3D._pushSectionsToWasm() failed!");
  }
  _pushDynamicSectionsToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(y.VerboseAPI, "VoxelLayerView3D._pushDynamicSectionsToWasm() called, " + (r(s3) ? "have WASM" : "don't have WASM!!!"));
    !!r(s3) && s3.setDynamicSections(this, e2) || this._dbg(y.Error, "VoxelLayer._updateDynamicSections() failed!");
  }
  _pushCurrentVariableIdToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(y.VerboseAPI, "VoxelLayerView3D._pushCurrentVariableIdToWasm() called!, " + (r(s3) ? "have WASM" : "don't have WASM!!!"));
    !!r(s3) && s3.setCurrentVariable(this, e2) || this._dbg(y.Error, "VoxelLayerView3D._pushCurrentVariableIdToWasm() failed!");
  }
  _pushVerticalExaggerationToWasm(e2) {
    const s3 = this.layer.getVolumeStyle(null), t2 = this.view.voxelWasm;
    if (this._dbg(y.VerboseAPI, `VoxelLayerView3D._pushVerticalExaggerationToWasm() called, ${r(t2) ? "have WASM" : "don't have WASM!!!"}, ${r(s3) ? "have style" : "don't have style!!!"}`), t(s3))
      return;
    !!r(t2) && t2.setVerticalExaggerationAndOffset(this, s3.volumeId, e2, s3.verticalOffset) || this._dbg(y.Error, "VoxelLayerView3D._pushVerticalExaggerationToWasm() failed!");
  }
  _pushVerticalOffsetToWasm(e2) {
    const s3 = this.layer.getVolumeStyle(null), t2 = this.view.voxelWasm;
    if (this._dbg(y.VerboseAPI, `VoxelLayerView3D._pushVerticalOffsetToWasm() called, ${r(t2) ? "have WASM" : "don't have WASM!!!"}, ${r(s3) ? "have style" : "don't have style!!!"}`), t(s3))
      return;
    !!r(t2) && t2.setVerticalExaggerationAndOffset(this, s3.volumeId, s3.verticalExaggeration, e2) || this._dbg(y.Error, "VoxelLayerView3D._pushVerticalOffsetToWasm() failed!");
  }
  _dbg(e2, s3) {
    this._dbgFlags.has(e2) && (e2 === y.Error ? g.error(s3) : g.warn(s3));
  }
};
e([d()], V.prototype, "layer", void 0), e([d({ readOnly: true, aliasOf: "layer.parsedUrl.path" })], V.prototype, "baseUrl", void 0), V = e([n("esri.views.3d.layers.VoxelLayerView3D")], V);
var f = V;
export {
  f as default
};
//# sourceMappingURL=VoxelLayerView3D-N3JLSWFJ.js.map
