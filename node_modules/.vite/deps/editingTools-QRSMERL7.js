import {
  G as G6,
  _ as _5
} from "./chunk-XGSJX5XD.js";
import {
  C as C3
} from "./chunk-GL3DI4QI.js";
import {
  S as S3,
  e as e9,
  r as r10,
  y as y3
} from "./chunk-6QWEEQ62.js";
import {
  Je,
  Ke,
  Lt,
  Nt,
  Ut,
  ct,
  dt,
  gt,
  kt,
  lt,
  o as o8,
  rt,
  tt,
  ut,
  vt
} from "./chunk-V4UDBBB4.js";
import "./chunk-3MW65G3U.js";
import {
  g as g3
} from "./chunk-Q5PPQF2L.js";
import {
  G as G4
} from "./chunk-PVL2NLPX.js";
import "./chunk-ZIG56NBC.js";
import {
  C as C2,
  F as F3,
  G as G5,
  N,
  P as P2,
  T as T4,
  h as h7
} from "./chunk-RED2ALFM.js";
import {
  a as a8
} from "./chunk-2RRRGIMY.js";
import {
  t as t10
} from "./chunk-2CQUD5GK.js";
import "./chunk-FDKIF5RK.js";
import {
  S as S2
} from "./chunk-7ZQJSAEA.js";
import "./chunk-3UQ4HI6Q.js";
import {
  _ as _4
} from "./chunk-TVBLDFP3.js";
import {
  F as F2,
  O as O2,
  b as b4,
  q as q5,
  te,
  v as v6,
  w as w5
} from "./chunk-EEPTXXKK.js";
import "./chunk-OGZ4KF5L.js";
import {
  n as n9
} from "./chunk-JYMQQ22E.js";
import "./chunk-JYWDI7GA.js";
import "./chunk-MQZSD3AZ.js";
import "./chunk-5CAQC3RU.js";
import "./chunk-A5WV4QY7.js";
import "./chunk-PH7BQFVK.js";
import "./chunk-PT7GCS5M.js";
import "./chunk-ZO4P57E5.js";
import "./chunk-4OFLHC3C.js";
import "./chunk-7Y6VVOP3.js";
import {
  l as l5,
  v as v3
} from "./chunk-EQ3EWUVK.js";
import "./chunk-QFYBIFWB.js";
import {
  P as P3,
  i as i3,
  l as l9,
  m as m10
} from "./chunk-2NTPDKQY.js";
import {
  m as m9
} from "./chunk-A2XF5TZW.js";
import {
  F,
  a as a7,
  d as d9,
  e2 as e8,
  l as l7,
  l2 as l8,
  m as m4,
  m2 as m5,
  m3 as m6,
  n as n8,
  r as r9
} from "./chunk-IEHZGLM3.js";
import "./chunk-OPQ375VL.js";
import {
  x as x5
} from "./chunk-VOFRIPQR.js";
import {
  d as d7,
  d2 as d8,
  g as g2,
  v as v5
} from "./chunk-7TCJ26U5.js";
import {
  e as e7
} from "./chunk-T6BL6FYR.js";
import "./chunk-U7I6IKUN.js";
import {
  E,
  S,
  T as T2,
  X,
  c as c5,
  e as e6,
  s as s4,
  t as t6,
  t2 as t7
} from "./chunk-GVCSP4OP.js";
import {
  f as f9,
  o as o7,
  s as s5,
  y as y2
} from "./chunk-7LOTF6IL.js";
import "./chunk-PJI2LYU5.js";
import {
  C,
  D as D2,
  G as G2,
  M as M3,
  R as R2,
  b as b3,
  c as c7,
  d as d6,
  p as p4,
  w as w4,
  x as x4
} from "./chunk-22MSECLU.js";
import "./chunk-PTJ3MGYO.js";
import {
  c as c6,
  r as r8
} from "./chunk-NSEAWM6P.js";
import "./chunk-ILEVWNLM.js";
import "./chunk-3HMF3PNP.js";
import "./chunk-N5C77AAH.js";
import {
  c as c4,
  f as f8,
  r as r6,
  s as s3,
  u as u4
} from "./chunk-DSCM4HDL.js";
import "./chunk-ZGXOGFCR.js";
import {
  s as s6
} from "./chunk-WGMCNMOI.js";
import "./chunk-UV5UBITC.js";
import {
  h as h6
} from "./chunk-O2JKFSHC.js";
import "./chunk-76A4CWFG.js";
import "./chunk-KYD2B4O6.js";
import "./chunk-Y7MFFYJY.js";
import {
  h as h5
} from "./chunk-KW6WHTET.js";
import {
  m as m8
} from "./chunk-PUU4QXN5.js";
import {
  m as m7
} from "./chunk-EHWEX2VK.js";
import "./chunk-HPO2NV7P.js";
import "./chunk-22O7HU3A.js";
import "./chunk-Y75V5CF3.js";
import "./chunk-PQM6RARY.js";
import "./chunk-2Y5KPYOJ.js";
import "./chunk-BBUIX72C.js";
import "./chunk-5ZS6RUSM.js";
import "./chunk-R3PFJUIG.js";
import "./chunk-7LH2XNVI.js";
import "./chunk-PXOPYXIX.js";
import "./chunk-WSQIVEW5.js";
import "./chunk-ZTFWVZTL.js";
import "./chunk-ELZC3DZT.js";
import "./chunk-TGUQXVQU.js";
import "./chunk-4LQ6NAOX.js";
import "./chunk-K37I5IIG.js";
import "./chunk-GKYJJGE3.js";
import "./chunk-AWIG2DGF.js";
import "./chunk-3236UEJN.js";
import "./chunk-KSOWE6GO.js";
import "./chunk-TCYVDK2B.js";
import "./chunk-ZLORWBMB.js";
import "./chunk-LJAT5UYW.js";
import "./chunk-OZAI2STL.js";
import "./chunk-CNL2CHF7.js";
import "./chunk-HRAEK6P4.js";
import "./chunk-K6UIDSFF.js";
import {
  T as T3
} from "./chunk-52W4YMC2.js";
import "./chunk-MHEQOIKQ.js";
import "./chunk-AIONJO5O.js";
import "./chunk-YLSPLHY5.js";
import "./chunk-4GGQTXXY.js";
import "./chunk-2DP653N7.js";
import "./chunk-QZCFKQOH.js";
import "./chunk-QMP4VG7M.js";
import "./chunk-5RP42VZJ.js";
import "./chunk-KD6KBT2L.js";
import "./chunk-XEWFCJLT.js";
import "./chunk-ZEDAE7EU.js";
import "./chunk-YXFNNKMT.js";
import "./chunk-7OZR6JFF.js";
import "./chunk-NXOQBIK7.js";
import "./chunk-ERNXFM5T.js";
import "./chunk-6ITXWFMK.js";
import "./chunk-SV4VP57N.js";
import "./chunk-5LWMNFCG.js";
import "./chunk-PWYPPSAW.js";
import "./chunk-5EXPMKQP.js";
import "./chunk-B7F3T673.js";
import "./chunk-QXYW5CVF.js";
import "./chunk-Z7AZMEL6.js";
import "./chunk-FUKESVWQ.js";
import "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-XEIRRA3E.js";
import "./chunk-B3IXFXV6.js";
import "./chunk-XNOIZLCR.js";
import "./chunk-I22L7HNU.js";
import "./chunk-44UD36FH.js";
import "./chunk-ODYLXHP4.js";
import "./chunk-Y5AGUEHG.js";
import "./chunk-DVE4HUBR.js";
import "./chunk-RC6OMMF6.js";
import "./chunk-AWPZQDE5.js";
import "./chunk-OYNEZ5VG.js";
import "./chunk-R67CDTDF.js";
import "./chunk-UCWSHVC4.js";
import "./chunk-DHZ2TSD5.js";
import "./chunk-ZV3LDRB3.js";
import "./chunk-FAF3GP2W.js";
import "./chunk-YSWURJZW.js";
import "./chunk-5JKCNCL2.js";
import "./chunk-2YDCEMEJ.js";
import "./chunk-O7YSDCZE.js";
import "./chunk-767LZ6IM.js";
import "./chunk-TTKSAULB.js";
import "./chunk-WJDUBZ7S.js";
import "./chunk-DNPZNIDB.js";
import "./chunk-WW7VYUQW.js";
import "./chunk-FCDEMPPS.js";
import "./chunk-TEJEYVH4.js";
import "./chunk-HEZ2ATGC.js";
import "./chunk-ECNFP4CF.js";
import "./chunk-AALA53RH.js";
import "./chunk-BOVIIQLB.js";
import "./chunk-IJHFAZOW.js";
import "./chunk-DMGVDNFD.js";
import "./chunk-YAQGRU5B.js";
import "./chunk-M3GMIUQS.js";
import "./chunk-BMA2CXVS.js";
import "./chunk-46N7XS5M.js";
import "./chunk-4MKQUQD4.js";
import "./chunk-A3QLZKCF.js";
import "./chunk-OYAHQ564.js";
import "./chunk-LGILR4HN.js";
import "./chunk-I5UNY2WQ.js";
import "./chunk-EYJ2F5XB.js";
import "./chunk-5EPJG7SL.js";
import "./chunk-TR3U55RZ.js";
import "./chunk-3DCTMZI6.js";
import "./chunk-33INAWJA.js";
import "./chunk-5WOO2FX6.js";
import "./chunk-FPMD6IB4.js";
import "./chunk-J73IXFNW.js";
import "./chunk-MQBVOUKB.js";
import "./chunk-EOJGYH5X.js";
import "./chunk-PLLZPG4O.js";
import "./chunk-WQLER7IU.js";
import {
  G as G3,
  H as H2,
  X as X2
} from "./chunk-7GTYHKA3.js";
import "./chunk-MOXYEJRV.js";
import {
  h as h3
} from "./chunk-EEJIELE6.js";
import "./chunk-Y55TYMBP.js";
import "./chunk-NAB3NF54.js";
import "./chunk-MHB3L22D.js";
import {
  n as n7
} from "./chunk-MDCKEJ7B.js";
import "./chunk-MLAOYRDT.js";
import "./chunk-VMF4NMEB.js";
import "./chunk-NAIF4GWX.js";
import "./chunk-72PB636Q.js";
import "./chunk-RIOXX6J2.js";
import {
  v as v4
} from "./chunk-SOZCO2CU.js";
import {
  J,
  Z,
  _ as _3,
  p2 as p3,
  q2 as q4
} from "./chunk-53KI6WDE.js";
import {
  d as d4,
  h as h4,
  j as j4
} from "./chunk-W2HLA6I3.js";
import "./chunk-Q6AASANP.js";
import {
  c as c3,
  f as f7,
  t as t5
} from "./chunk-ZYIEYKCD.js";
import "./chunk-DLM6NKXW.js";
import "./chunk-TQLSOIYV.js";
import {
  e as e5,
  o as o6,
  t as t4
} from "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-Z7BSDVJ3.js";
import {
  t as t9
} from "./chunk-EDJZEIRN.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-3NPGGTI6.js";
import {
  t as t8,
  u as u5
} from "./chunk-G4ERZR5M.js";
import "./chunk-AMGAY4O5.js";
import "./chunk-GRW2GUB3.js";
import {
  A as A3,
  M as M2,
  b as b2,
  f as f6,
  j as j3,
  l as l4,
  o as o5,
  r as r5,
  s as s2,
  v as v2,
  w as w3
} from "./chunk-YZNDHJDJ.js";
import "./chunk-ZZCCRN4U.js";
import "./chunk-TWQ374WD.js";
import "./chunk-GT2OBOXC.js";
import "./chunk-Z3S5X75I.js";
import "./chunk-YK4ZKK2Q.js";
import "./chunk-NMRWU44S.js";
import "./chunk-LBBA3SFR.js";
import "./chunk-2KZBVPWA.js";
import "./chunk-CXIMLSDF.js";
import "./chunk-ZDSMRGKC.js";
import "./chunk-I6H66HCE.js";
import "./chunk-4P4OV7G6.js";
import "./chunk-ZUDEVIXR.js";
import {
  d as d5
} from "./chunk-RRFFPL7N.js";
import "./chunk-JYR7GBAU.js";
import "./chunk-IG4CY4XM.js";
import {
  q as q3
} from "./chunk-HB4HVKJV.js";
import "./chunk-CC32E45Q.js";
import "./chunk-V7M26XZ7.js";
import {
  l as l6
} from "./chunk-ZN2MGN4S.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import {
  n as n6
} from "./chunk-RTHP2LNT.js";
import "./chunk-XZTXACPW.js";
import "./chunk-EHYYP2L2.js";
import "./chunk-ZUEYZA7M.js";
import "./chunk-74GUBHRJ.js";
import "./chunk-E447OCKN.js";
import "./chunk-LPU5TMA4.js";
import "./chunk-25QHXOZB.js";
import "./chunk-AA7FGPNP.js";
import "./chunk-UHJVTABQ.js";
import "./chunk-W66LN57L.js";
import "./chunk-PNUWGOXY.js";
import {
  r as r7
} from "./chunk-FUQI3AAI.js";
import "./chunk-22YODLVL.js";
import "./chunk-TB42IUV7.js";
import "./chunk-ZWMYDR2G.js";
import "./chunk-ZZY5IDKU.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-6FKG7JUE.js";
import {
  Bn,
  Hn
} from "./chunk-PZWU5EHT.js";
import "./chunk-BS7TS6UC.js";
import "./chunk-37ZVELW7.js";
import "./chunk-7LOJJ46D.js";
import "./chunk-VNR743PA.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-SWCA522B.js";
import "./chunk-YPIBZ3CH.js";
import "./chunk-XLCZFN6R.js";
import "./chunk-OMNBM2E4.js";
import "./chunk-WKHS6QIX.js";
import "./chunk-6O7ZZEV7.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-OBCAVCXI.js";
import "./chunk-RFOZTYJH.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-L2YBXQTH.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import {
  h as h2
} from "./chunk-3DZ4BNVJ.js";
import "./chunk-4XBERLPX.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-SZPDY7KN.js";
import "./chunk-Y6YGVGFR.js";
import "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import "./chunk-MZX3HN4G.js";
import "./chunk-T47JAOQZ.js";
import "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-RIWDMEW4.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import {
  e as e4
} from "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-OG6CQEZJ.js";
import "./chunk-X5Z3DJQ4.js";
import "./chunk-BUWXVMJU.js";
import "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import "./chunk-D3XXPCBB.js";
import "./chunk-OWBMOIIV.js";
import "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import {
  x as x3
} from "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import {
  a as a6,
  d as d3
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  U as U2,
  a as a4,
  f as f4,
  h,
  l as l3,
  w
} from "./chunk-T7BEWVV3.js";
import {
  R,
  b,
  c as c2,
  f as f5,
  i as i2,
  m as m3,
  p as p2,
  q as q2,
  u as u3,
  x as x2
} from "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-6J6RPVFW.js";
import "./chunk-DYETG5YB.js";
import "./chunk-CLGCKZUR.js";
import {
  ce,
  ee,
  z
} from "./chunk-RN2KRYDN.js";
import "./chunk-AWWWJUTQ.js";
import "./chunk-EQNRDJV7.js";
import "./chunk-FEEXJRYO.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import {
  B,
  _ as _2,
  a as a5
} from "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  w as w2
} from "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import {
  j as j2
} from "./chunk-TT2HIXWQ.js";
import {
  n as n5
} from "./chunk-OIPX3EDD.js";
import {
  d as d2,
  i,
  x
} from "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import {
  l as l2
} from "./chunk-FVPTCNCX.js";
import {
  M,
  m as m2,
  o as o4
} from "./chunk-BPZGJQOB.js";
import {
  D,
  a as a3
} from "./chunk-ZOKX6UGH.js";
import {
  A as A2,
  G,
  H,
  P,
  T,
  U,
  _,
  e as e3,
  g,
  o as o3,
  p,
  q,
  r as r4,
  s,
  u,
  v,
  z as z2
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import {
  f as f3,
  n as n4,
  r as r3,
  t as t3
} from "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import {
  m2 as m
} from "./chunk-CHNDTVQJ.js";
import {
  f as f2
} from "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  A,
  d,
  n2,
  n8 as n3,
  o2,
  r as r2,
  t2,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  O,
  f
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  a,
  a2,
  c,
  e as e2,
  l,
  n,
  o,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/interactive/SegmentLabels.js
var S4 = 3025;
var w6 = { default: 15, far: 25 };
var P4 = class extends y {
  constructor(e11) {
    super(e11), this.context = null, this.stagedVertex = null, this.visible = true, this.edgeDistance = "default", this._messagesUnits = null, this._labelInfos = [], this._nextLabelIndex = 0;
  }
  initialize() {
    const e11 = O(async (e12) => {
      const t14 = await h2("esri/core/t9n/Units");
      f(e12), this._messagesUnits = t14;
    }), t13 = () => o(this.context, (e12) => e12.editGeometryOperations);
    this.own([l3(() => [r(this.context) && this.getCameraOrExtent(this.context), this.visible, this._edgeDistancePixels, this.stagedVertex, this._messagesUnits], () => this._update()), ...["vertex-add", "vertex-update", "vertex-remove"].map((e12) => a4(t13, e12, () => this._update())), n2(() => e11.abort())]);
  }
  destroy() {
    for (this._nextLabelIndex = 0; this._labelInfos.length; )
      this._destroyLabel(this._labelInfos.pop());
  }
  get updating() {
    return t(this._messagesUnits);
  }
  get test() {
    return { labelContents: this._labelInfos.slice(0, this._nextLabelIndex).map((e11) => e11.label.text) };
  }
  get _edgeDistancePixels() {
    return w6[this.edgeDistance];
  }
  _update() {
    this._nextLabelIndex = 0;
    const e11 = this.context;
    if (t(e11))
      return void this._destroyUnusedLabels();
    const { components: t13, geometry: s10, coordinateHelper: r15 } = e11.editGeometryOperations.data;
    if (!s10)
      return void this._destroyUnusedLabels();
    const a15 = t13.length;
    for (let o11 = 0; o11 < a15; ++o11) {
      const n12 = [];
      if (t13[o11].iterateVertices((e12) => {
        n12.push(r15.toXYZ(e12.pos));
      }), 0 === o11 && r(this.stagedVertex) && n12.push(r15.toXYZ(this.stagedVertex)), n12.length < 2)
        continue;
      const l12 = n12[0], c10 = n12[n12.length - 1];
      "polygon" === s10.type && n12.length > 2 && !G(l12, c10) && n12.push(l12);
      const p11 = 1 === a15 && !f2(n12, false, false);
      let h10 = C4, d14 = G7;
      this.toScreenPointArray(e11, l12, h10);
      for (let t14 = 1; t14 < n12.length; ++t14) {
        const s11 = n12[t14 - 1], o12 = n12[t14];
        this.toScreenPointArray(e11, o12, d14), this._addLabel(e11, s11, h10, o12, d14, p11), [h10, d14] = [d14, h10];
      }
    }
    this._destroyUnusedLabels();
  }
  _addLabel(e11, t13, s10, o11, r15, a15) {
    const { label: n12 } = this._getOrCreateLabel(e11);
    if (!this.visible || b2(s10, r15) < S4)
      return void (n12.visible = false);
    const c10 = r(e11.graphicState) ? e11.graphicState.isDraped ? "on-the-ground" : "absolute-height" : s3(e11.editGeometryOperations.data.geometry, e11.elevationInfo), { spatialReference: p11 } = e11.editGeometryOperations.data, h10 = a7(t13, o11, p11, c10), m15 = this._messagesUnits, u7 = ce(e11.view);
    n12.text = r(m15) && r(h10) ? x5(m15, h10, u7) : "", n12.visible = true;
    const v10 = r15[0] - s10[0], j8 = r15[1] - s10[1];
    a15 ? r5(V, -j8, v10) : r5(V, j8, -v10), v2(V, V), l4(V, V, this._edgeDistancePixels), A3(k, s10, r15, 0.5), s2(k, k, V), n12.position = [k[0], k[1]], Math.abs(V[0]) > Math.abs(V[1]) ? n12.anchor = V[0] > 0 ? "left" : "right" : n12.anchor = -V[1] < 0 ? "top" : "bottom";
  }
  _getOrCreateLabel(e11) {
    if (this._labelInfos.length > this._nextLabelIndex)
      return this._labelInfos[this._nextLabelIndex++];
    const t13 = new a8({ fontSize: 10, anchor: "center" });
    e11.view.overlay.items.add(t13);
    const s10 = { label: t13 };
    return this._labelInfos.push(s10), this._nextLabelIndex = this._labelInfos.length, s10;
  }
  _destroyUnusedLabels() {
    for (; this._labelInfos.length > this._nextLabelIndex; )
      this._destroyLabel(this._labelInfos.pop());
  }
  _destroyLabel({ label: e11 }) {
    o(this.context, (t13) => t13.view.overlay.items.remove(e11)), e11.destroy();
  }
};
e([d()], P4.prototype, "context", void 0), e([d()], P4.prototype, "stagedVertex", void 0), e([d()], P4.prototype, "visible", void 0), e([d()], P4.prototype, "edgeDistance", void 0), e([d()], P4.prototype, "updating", null), e([d()], P4.prototype, "_messagesUnits", void 0), e([d()], P4.prototype, "_edgeDistancePixels", null), P4 = e([n3("esri.views.interactive")], P4);
var V = n6();
var k = n6();
var C4 = i();
var G7 = i();

// node_modules/@arcgis/core/views/3d/interactive/SegmentLabels3D.js
var a9 = class extends P4 {
  getCameraOrExtent({ view: e11 }) {
    return e11.state.camera;
  }
  toScreenPointArray({ view: e11, elevationInfo: t13, editGeometryOperations: s10 }, o11, a15 = i()) {
    const { spatialReference: p11 } = s10.data.coordinateHelper;
    return m9(o11, p11, t13, e11, i4), e11.state.camera.projectToScreen(i4, a15), a15;
  }
};
a9 = e([n3("esri.views.3d.interactive.SegmentLabels3D")], a9);
var i4 = n4();

// node_modules/@arcgis/core/views/3d/interactive/visualElements/VerticesVisualElement.js
var p5 = class extends n9 {
  constructor(e11) {
    super(e11), this.view = null, this._renderOccluded = h3.OccludeAndTransparent, this._vertices = null, this._spatialReference = null, this._color = y3.colorToVec4(y3.reshapeManipulators.vertex.color), this._size = y3.reshapeManipulators.vertex.size, this._outlineColor = y3.colorToVec4(y3.reshapeManipulators.vertex.outlineColor), this._outlineSize = y3.reshapeManipulators.vertex.outlineSize, this._elevationInfo = null, this.applyProps(e11);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e11) {
    e11 !== this._renderOccluded && (this._renderOccluded = e11, this._updateMaterial(), this._updateOutlineMaterial());
  }
  get vertices() {
    return this._vertices;
  }
  set vertices(e11) {
    this._vertices = e11, this.recreateGeometry();
  }
  get spatialReference() {
    return this._spatialReference;
  }
  set spatialReference(e11) {
    this._spatialReference = e11, this.recreateGeometry();
  }
  get color() {
    return this._color;
  }
  set color(e11) {
    D(e11, this._color) || (a3(this._color, e11), this._updateMaterial());
  }
  get size() {
    return this._size;
  }
  set size(e11) {
    e11 !== this._size && (this._size = e11, this._updateMaterial());
  }
  get outlineColor() {
    return this._outlineColor;
  }
  set outlineColor(e11) {
    D(e11, this._outlineColor) || (a3(this._outlineColor, e11), this._updateOutlineMaterial());
  }
  get outlineSize() {
    return this._outlineSize;
  }
  set outlineSize(e11) {
    e11 !== this._outlineSize && (this._outlineSize = e11, this._updateOutlineMaterial());
  }
  get elevationInfo() {
    return this._elevationInfo;
  }
  set elevationInfo(e11) {
    this._elevationInfo = e11, this.recreateGeometry();
  }
  get vertexMaterialParameters() {
    return { color: this._color, transparent: this._color[3] < 1, screenSizeScale: this.size, renderOccluded: this._renderOccluded };
  }
  get vertexOutlineMaterialParameters() {
    return { color: this._outlineColor, transparent: this._outlineColor[3] < 1, screenSizeScale: this.size + 2 * this.outlineSize, renderOccluded: this._renderOccluded };
  }
  _updateMaterial() {
    this.attached && this.vertexMaterial.setParameters(this.vertexMaterialParameters);
  }
  _updateOutlineMaterial() {
    this.attached && this.vertexOutlineMaterial.setParameters(this.vertexOutlineMaterialParameters);
  }
  _createRenderGeometries() {
    const r15 = this.vertices;
    if (t(r15) || 0 === r15.length)
      return [];
    const i10 = 0.5, s10 = 0.5, a15 = h6(r15, this.spatialReference, this.view.elevationProvider, this.view.renderCoordsHelper, h5.fromElevationInfo(this.elevationInfo)), l12 = [], c10 = a15.numVertices, h10 = a15.position;
    for (let e11 = 0; e11 < c10; ++e11) {
      const r16 = o3(m11, h10[3 * e11 + 0], h10[3 * e11 + 1], h10[3 * e11 + 2]), a16 = v7(i10, r16), o11 = v7(s10, r16);
      l12.push({ vertexGeometry: a16, vertexOutlineGeometry: o11 });
    }
    return l12;
  }
  createGeometries(e11) {
    const t13 = this._createRenderGeometries();
    for (const { vertexGeometry: r15, vertexOutlineGeometry: i10 } of t13)
      e11.addGeometry(r15, this.vertexMaterial), e11.addGeometry(i10, this.vertexOutlineMaterial);
  }
  createExternalResources() {
    this.vertexMaterial = new q5({ ...this.vertexMaterialParameters, writeDepth: true, cullFace: n7.Back, screenSizeEnabled: true }), this.vertexOutlineMaterial = new q5({ ...this.vertexOutlineMaterialParameters, transparent: true, writeDepth: true, cullFace: n7.Front, screenSizeEnabled: true, shadingEnabled: false });
  }
  destroyExternalResources() {
    this.vertexMaterial = null, this.vertexOutlineMaterial = null;
  }
  forEachExternalMaterial(e11) {
    e11(this.vertexMaterial), e11(this.vertexOutlineMaterial);
  }
};
var m11 = n4();
function v7(e11, t13) {
  return T3.createSphereGeometry(e11, 16, 16, { offset: t13 });
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/draw/DrawGraphicTool3D.js
var S5 = class extends _5 {
  constructor(e11) {
    super(e11), this._activeVertexVisualElement = null, this._createGraphicState = null, this._outlineVisualElement = null, this._verticesVisualElement = null, this.geometryType = null, this.labelOptions = new c6(), this.tooltipOptions = new r8(), this.type = "draw-3d";
  }
  initialize() {
    const { mode: e11, offset: t13 } = this.elevationInfo;
    this.internalGraphicsLayer.elevationInfo = new x3({ mode: e11, offset: t13 });
  }
  normalizeCtorArgs(e11) {
    if (!e11.elevationInfo) {
      const t13 = e11.hasZ ?? true;
      return { ...e11, elevationInfo: { mode: t13 ? "absolute-height" : "on-the-ground", offset: 0 } };
    }
    return e11;
  }
  initializeGraphic(e11) {
    const i10 = this._createGraphicState = new e9({ graphic: e11 });
    return r2([this.view.maskOccludee(e11), this.view.trackGraphicState(i10), l3(() => ({ element: this._outlineVisualElement, isDraped: i10.isDraped }), ({ element: e12, isDraped: t13 }) => {
      o(e12, (e13) => e13.isDraped = t13);
    }, h)]);
  }
  makeDrawOperation() {
    const { geometryType: e11 } = this, t13 = "circle" !== e11 && "rectangle" !== e11;
    return new F({ view: this.view, manipulators: this.manipulators, geometryType: G6(e11), drawingMode: this.mode, hasZ: this.hasZ, defaultZ: this.defaultZ, snapToSceneEnabled: this.snapToScene, drawSurface: new n8(this.view, this.elevationInfo, [this.internalGraphicsLayer]), elevationDrawSurface: new r9(this.elevationInfo, this.defaultZ, this.view, this.internalGraphicsLayer), hasM: false, elevationInfo: this.elevationInfo, snappingManager: this.snappingManager, snappingVisualizer: new g3(), segmentLabels: t13 ? new a9() : null, labelOptions: this.labelOptions, tooltipOptions: this.tooltipOptions, isDraped: r(this._createGraphicState) ? this._createGraphicState.isDraped : "on-the-ground" === r6(this.hasZ, this.elevationInfo) });
  }
  onActiveVertexChanged(e11) {
    return r(this._activeVertexVisualElement) ? (this._activeVertexVisualElement.vertices = [e11], null) : (this._activeVertexVisualElement = new p5({ view: this.view, spatialReference: this.view.spatialReference, vertices: [e11], elevationInfo: this.internalGraphicsLayer.elevationInfo, renderOccluded: y3.reshapeManipulators.vertex.renderOccluded, attached: false }), this._activeVertexVisualElement.color = y3.colorToVec4(y3.reshapeManipulators.selected.color), this._activeVertexVisualElement.attached = true, n2(() => {
      this._activeVertexVisualElement = l(this._activeVertexVisualElement);
    }));
  }
  onOutlineChanged(e11) {
    if (r(this._outlineVisualElement))
      return this._outlineVisualElement.geometry = e11, null;
    const t13 = this.internalGraphicsLayer.elevationInfo;
    return this._outlineVisualElement = new S3({ view: this.view, geometry: e11, elevationInfo: t13, isDraped: r(this._createGraphicState) ? this._createGraphicState.isDraped : "on-the-ground" === r6(this.hasZ, t13), attached: false }), y3.visualElements.lineGraphics.outline.apply(this._outlineVisualElement), y3.visualElements.lineGraphics.shadowStyle.apply(this._outlineVisualElement), this._outlineVisualElement.attached = true, this._outlineVisualElement.laserlineEnabled = true, n2(() => {
      this._outlineVisualElement = l(this._outlineVisualElement);
    });
  }
  onRegularVerticesChanged(e11) {
    return r(this._verticesVisualElement) ? (this._verticesVisualElement.vertices = e11, null) : (this._verticesVisualElement = new p5({ view: this.view, spatialReference: this.view.spatialReference, vertices: e11, elevationInfo: this.internalGraphicsLayer.elevationInfo, renderOccluded: y3.reshapeManipulators.vertex.renderOccluded, attached: false }), this._verticesVisualElement.attached = true, n2(() => {
      this._verticesVisualElement = l(this._verticesVisualElement);
    }));
  }
};
e([d({ constructOnly: true })], S5.prototype, "elevationInfo", void 0), e([d({ constructOnly: true })], S5.prototype, "geometryType", void 0), e([d({ constructOnly: true, type: c6 })], S5.prototype, "labelOptions", void 0), e([d({ constructOnly: true, type: r8 })], S5.prototype, "tooltipOptions", void 0), e([d()], S5.prototype, "type", void 0), e([d({ constructOnly: true })], S5.prototype, "view", void 0), S5 = e([n3("esri.views.3d.interactive.editingTools.draw.DrawGraphicTool3D")], S5);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/ManipulatorType.js
var A4;
!function(A7) {
  A7[A7.TRANSLATE_Z = 0] = "TRANSLATE_Z", A7[A7.TRANSLATE_XY = 1] = "TRANSLATE_XY", A7[A7.SCALE = 2] = "SCALE", A7[A7.ROTATE = 3] = "ROTATE", A7[A7.SCALE_ROTATE = 4] = "SCALE_ROTATE";
}(A4 || (A4 = {}));

// node_modules/@arcgis/core/views/3d/interactive/editingTools/GrabbingState.js
var N2;
!function(N4) {
  N4[N4.NONE = 0] = "NONE", N4[N4.ANY = 1] = "ANY", N4[N4.Z = 2] = "Z", N4[N4.XY = 4] = "XY";
}(N2 || (N2 = {}));

// node_modules/@arcgis/core/views/3d/interactive/editingTools/ManipulatorState.js
var a10 = class {
  constructor() {
    this.grabbingState = N2.NONE, this.zManipulator = null, this.firstSelected = null, this.numSelected = 0, this.firstGrabbedXY = null;
  }
  update(a15) {
    this.grabbingState = N2.NONE, this.zManipulator = null, this.numSelected = 0, this.firstSelected = null, this.firstGrabbedXY = null, a15.forEachManipulator((a16, s10) => {
      if (s10 === A4.TRANSLATE_Z && (this.zManipulator = a16), a16 instanceof te && (a16.selected && (0 === this.numSelected && (this.firstSelected = a16), this.numSelected++), t(this.firstGrabbedXY) && a16.grabbing && s10 === A4.TRANSLATE_XY && (this.firstGrabbedXY = a16)), a16.grabbing)
        switch (this.grabbingState |= N2.ANY, s10) {
          case A4.TRANSLATE_Z:
            this.grabbingState |= N2.Z;
            break;
          case A4.TRANSLATE_XY:
            this.grabbingState |= N2.XY;
        }
    });
  }
};

// node_modules/@arcgis/core/views/3d/interactive/editingTools/lineGraphicVisualElementUtils.js
function b5(t13) {
  const { view: a15, graphic: n12 } = t13, i10 = new e9({ graphic: n12 }), l12 = j5(t13, i10), r15 = [l12, S6(t13, l12.visualElement, i10), a15.maskOccludee(n12), a15.trackGraphicState(i10)];
  return { visualElement: l12.visualElement, remove: () => r2(r15).remove() };
}
function j5(a15, n12) {
  const { view: i10, graphic: r15 } = a15, o11 = new S3({ view: i10, geometry: L(r15) ? r15.geometry : null, elevationInfo: u4(r15), attached: false });
  y3.visualElements.lineGraphics.shadowStyle.apply(o11);
  const s10 = () => {
    o11.attached = n12.displaying;
  };
  y3.visualElements.lineGraphics.outline.apply(o11);
  const p11 = [l3(() => n12.displaying, s10), l3(() => n12.isDraped, (e11) => {
    o11.isDraped = e11;
  }), n12.on("changed", () => o11.geometry = L(r15) ? r15.geometry : null), t2(o11)];
  return s10(), { visualElement: o11, remove: () => r2(p11).remove() };
}
function S6(i10, r15, o11) {
  const { graphic: s10, view: p11 } = i10, m15 = [], d14 = u4(s10), y7 = "on-the-ground" === d14.mode || !d14.offset && "absolute-height" !== d14.mode, E4 = new a10(), b7 = new G4({ view: p11, extensionType: y3.visualElements.zVerticalLine.extensionType, innerWidth: 1, attached: false, writeDepthEnabled: false, renderOccluded: h3.OccludeAndTransparent });
  y3.visualElements.pointGraphics.shadowStyle.apply(b7);
  const j8 = M(y3.visualElements.heightPlaneAngleCutoff), S8 = new _4({ view: p11, attached: false, angleCutoff: j8 });
  y3.visualElements.heightPlane.apply(S8);
  let T6 = 1, A7 = 1;
  const D4 = () => {
    if (E4.update(i10), !o11.displaying || y7 && (o11.isDraped || !L(s10) || !s10.geometry.hasZ))
      return r15.laserlineEnabled = false, b7.attached = false, void (S8.attached = false);
    r15.laserlineEnabled = true;
    {
      const e11 = E4.grabbingState & N2.XY ? y3.visualElements.laserlineAlphaMultiplier : 1;
      e11 !== T6 && (T6 = e11, y3.visualElements.lineGraphics.shadowStyle.apply(r15, e11), y3.visualElements.pointGraphics.shadowStyle.apply(b7, e11));
    }
    {
      const e11 = E4.grabbingState & N2.Z ? y3.visualElements.laserlineAlphaMultiplier : 1;
      e11 !== A7 && (A7 = e11, y3.visualElements.heightPlane.apply(S8, e11));
    }
    M4(b7, E4), G8(i10, r15, S8, E4);
  };
  y3.visualElements.zVerticalLine.apply(b7), m15.push(o11.on("changed", D4), l3(() => o11.displaying, D4), r15.events.on("attachment-origin-changed", D4), t2(b7), t2(S8));
  const C7 = [], O5 = () => {
    r2(C7).remove(), C7.length = 0, i10.forEachManipulator((e11) => C7.push(e11.events.on("grab-changed", D4))), i10.forEachManipulator((e11) => C7.push(e11.events.on("select-changed", D4))), D4();
  };
  return O5(), m15.push(i10.onManipulatorsChanged(O5), o2(() => r2(C7))), r2(m15);
}
function M4(e11, t13) {
  const a15 = 1 === t13.numSelected ? t13.firstSelected : t13.numSelected > 1 && r(t13.firstGrabbedXY) ? t13.firstGrabbedXY : null;
  r(a15) ? (e11.setStartEndFromWorldDownAtLocation(a15.renderLocation), e11.attached = true) : e11.attached = false;
}
function G8(e11, t13, a15, n12) {
  if (n12.numSelected > 0) {
    o3(T5, 0, 0, 0);
    let t14 = 0;
    e11.forEachManipulator((e12, a16) => {
      a16 === A4.TRANSLATE_XY && e12.selected && e12 instanceof te && (u(T5, T5, e12.renderLocation), t14++);
    }), t14 > 0 ? (a15.heightManifoldTarget = q(T5, T5, 1 / t14), a15.attached = true) : a15.attached = false;
  } else {
    const n13 = t13.attachmentOrigin;
    r(n13) && e11.view.renderCoordsHelper.toRenderCoords(n13, T5) ? (a15.heightManifoldTarget = T5, a15.attached = true) : a15.attached = false;
  }
}
function L(e11) {
  return r(e11.geometry) && ("polygon" === e11.geometry.type || "polyline" === e11.geometry.type);
}
var T5 = n4();

// node_modules/@arcgis/core/views/3d/interactive/editingTools/originGraphicVisualElementUtils.js
function M5(t13) {
  const { view: n12, graphic: i10 } = t13, o11 = new e9({ graphic: i10 }), a15 = [], r15 = C5(t13, o11, a15);
  return P5(t13, o11, a15, r15), a15.push(n12.trackGraphicState(o11)), { visualElement: r15, remove() {
    r2(a15).remove();
  } };
}
function P5(e11, n12, s10, p11) {
  const { view: m15, graphic: u7 } = e11, f11 = new G4({ view: m15, extensionType: y3.visualElements.zVerticalLine.extensionType, innerWidth: 1, attached: false, writeDepthEnabled: false, renderOccluded: h3.OccludeAndTransparent });
  y3.visualElements.zVerticalLine.apply(f11);
  const b7 = new _4({ view: m15, intersectsLineInfinite: true, attached: false });
  y3.visualElements.pointGraphics.shadowStyle.apply(b7);
  const A7 = M(y3.visualElements.heightPlaneAngleCutoff), M9 = new _4({ view: m15, attached: false, angleCutoff: A7 });
  y3.visualElements.heightPlane.apply(M9);
  const P8 = u4(e11.graphic), C7 = h5.fromElevationInfo(P8), R5 = "on-the-ground" === P8.mode || !P8.offset && "absolute-height" !== P8.mode, U5 = new a10();
  let D4 = 1, I2 = 1;
  const T6 = () => {
    U5.update(e11);
    const t13 = G9(u7), i10 = R5 && (n12.isDraped || t(t13) || !t13.hasZ);
    let r15 = true;
    if (!i10 && r(t13)) {
      const e12 = m7(t13, m15.elevationProvider, C7, m15.renderCoordsHelper);
      o3(V2, t13.x, t13.y, e12), Bn(V2, t13.spatialReference, V2, m15.renderCoordsHelper.spatialReference), f11.setStartEndFromWorldDownAtLocation(V2), b7.intersectsWorldUpAtLocation = V2;
    } else
      r15 = false;
    const s11 = U5.grabbingState & N2.Z ? y3.visualElements.laserlineAlphaMultiplier : 1;
    s11 !== D4 && (D4 = s11, y3.visualElements.heightPlane.apply(M9, s11));
    const g6 = B(B2);
    !i10 && n12.displaying && p11.calculateMapBounds(g6) && Bn(_2(g6, V2), m15.spatialReference, V2, m15.renderCoordsHelper.spatialReference) ? (M9.heightManifoldTarget = V2, M9.attached = true) : M9.attached = false;
    const y7 = U5.grabbingState & N2.XY ? y3.visualElements.laserlineAlphaMultiplier : 1;
    y7 !== I2 && (I2 = y7, y3.visualElements.pointGraphics.shadowStyle.apply(b7, y7));
    const j8 = r15 && n12.displaying && !i10;
    b7.attached = j8, f11.attached = j8;
  };
  s10.push(l3(() => [n12.displaying, n12.isDraped], T6), n12.on("changed", T6)), e11.forEachManipulator((e12) => {
    s10.push(e12.events.on("grab-changed", T6));
  }), s10.push(t2(b7)), s10.push(t2(f11)), s10.push(t2(M9)), T6();
}
function C5(e11, n12, i10) {
  const { view: o11, graphic: a15 } = e11, r15 = new S2({ view: o11, geometry: G9(a15), elevationInfo: u4(a15), attached: false });
  return R3(e11, r15, n12, i10), i10.push(t2(r15)), r15;
}
function G9(e11) {
  const t13 = e11.geometry;
  return t(t13) ? null : "point" === t13.type ? t13 : "mesh" === t13.type ? t13.anchor.clone() : null;
}
function R3(e11, t13, n12, i10) {
  const o11 = () => t13.attached = n12.displaying;
  U3(e11, t13, n12, i10), y3.visualElements.pointGraphics.outline.apply(t13), i10.push(l3(() => n12.displaying, o11, h));
}
function U3(e11, t13, i10, o11) {
  const { view: r15, graphic: s10 } = e11;
  let l12 = null;
  const p11 = (e12) => {
    r(l12) && (l12.remove(), l12 = null), i10.isDraped && r(e12) && (l12 = D3(r15, e12, () => {
      t13.geometry = e12;
    }));
  }, c10 = () => {
    const e12 = G9(s10);
    p11(e12), t13.geometry = e12;
  };
  o11.push(i10.on("changed", c10), o2(() => l12)), c10();
}
function D3(e11, t13, n12) {
  const i10 = e11.elevationProvider.spatialReference;
  Hn(t13, V2, i10);
  const o11 = V2[0], a15 = V2[1];
  return e11.elevationProvider.on("elevation-change", (e12) => {
    w2(e12.extent, o11, a15) && n12();
  });
}
var V2 = n4();
var B2 = a5();

// node_modules/@arcgis/core/views/3d/interactive/editingTools/visualElementUtils.js
function i5(i10) {
  switch (e2(i10.graphic.geometry).type) {
    case "point":
    case "mesh":
      return M5(i10);
    case "polygon":
    case "polyline":
      return b5(i10);
    default:
      return null;
  }
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/manipulations/config.js
var t11 = [1, 0.5, 0];
var a11 = 128;
var e10 = 70;
var h8 = 80;
var M6 = 0.02;
var c8 = 54;
var o9 = 100;
var I = Math.ceil(e10 / 3 * 2);
var P6 = 160;
var i6 = 0.5;
var l10 = 24;
var n10 = 9;
var p6 = P6 + 30;
var r11 = P6 + 53;
var s7 = 60;
var x6 = 23;
var b6 = 5 * Math.PI / 12;
var d10 = 1 * Math.PI / 3;
var f10 = 10;
var g4 = 0.2;
var j6 = 30;
var k2 = 53;
var m12 = 0.2;
var q6 = 0.3;
var u6 = 200;
var v8 = 3;
var w7 = 1e6;

// node_modules/@arcgis/core/views/3d/interactive/editingTools/manipulations/Manipulation.js
var t12 = class {
  constructor() {
    this._available = true;
  }
  set location(a15) {
    this._forEachManipulator3D((t13) => t13.location = a15);
  }
  set elevationAlignedLocation(a15) {
    this._forEachManipulator3D((t13) => t13.elevationAlignedLocation = a15);
  }
  set elevationInfo(a15) {
    this._forEachManipulator3D((t13) => t13.elevationInfo = a15);
  }
  get renderLocation() {
    let a15;
    return this._forEachManipulator3D((t13) => {
      a15 || (a15 = t13.renderLocation);
    }), a15;
  }
  get available() {
    return this._available;
  }
  set available(a15) {
    this._available = a15, this._forEachManipulator3D((t13) => t13.available = a15);
  }
  get hovering() {
    return this.someManipulator((a15) => a15.hovering);
  }
  get grabbing() {
    return this.someManipulator((a15) => a15.grabbing);
  }
  get dragging() {
    return this.someManipulator((a15) => a15.dragging);
  }
  hasManipulator(a15) {
    return this.someManipulator((t13) => t13 === a15);
  }
  someManipulator(a15) {
    let t13 = false;
    return this.forEachManipulator((i10) => {
      !t13 && a15(i10) && (t13 = true);
    }), t13;
  }
  _forEachManipulator3D(t13) {
    this.forEachManipulator((i10, o11) => {
      i10 instanceof te && t13(i10, o11);
    });
  }
};

// node_modules/@arcgis/core/views/3d/interactive/editingTools/manipulations/moveUtils.js
function r12(t13, r15, a15, c10) {
  const i10 = t13.graphic, o11 = (t14, e11) => r15({ action: t14, graphic: i10, dxScreen: e11.screenDeltaX, dyScreen: e11.screenDeltaY });
  return a15((t14, r16, a16) => {
    const s10 = r16.next((t15) => ("start" === t15.action && o11("start", t15), t15)).next(x4(i10, c10)).next((t15) => {
      switch (t15.action) {
        case "start":
        case "update":
          (t15.translationX || t15.translationY || t15.translationZ) && o11("update", t15);
          break;
        case "end":
          o11("end", t15);
      }
      return t15;
    });
    return a16.next(w4(i10)).next(() => {
      o11("end", { screenDeltaX: 0, screenDeltaY: 0 });
    }), s10;
  });
}
function a12(e11) {
  if (t(e11) || "polyline" !== e11.type && "polygon" !== e11.type)
    return 0;
  const n12 = ("polyline" === e11.type ? e11.paths : e11.rings)[0];
  if (!n12 || n12.length < 2)
    return 0;
  const r15 = n12[0], a15 = n12[1];
  return Math.atan2(a15[1] - r15[1], a15[0] - r15[0]);
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/manipulations/MoveXYAxisManipulation.js
var O3 = class extends t12 {
  constructor(t13) {
    super(), this._handles = new u2(), this._arrowManipulatorInfos = new Array(), this._opaqueMaterial = this._createMaterial(), this._transparentMaterial = this._createMaterial(0.5), this._angle = 0, this._scale = 1, this._radius = e10, this._updateAfterDrag = false, this.events = new n5(), this._tool = t13.tool, this._view = t13.view, null != t13.radius && (this._radius = t13.radius), this._createManipulators(), this.forEachManipulator((t14) => this._tool.manipulators.add(t14));
  }
  set orthogonalAvailable(t13) {
    this._arrowManipulatorInfos[1].manipulator.available = t13, this._arrowManipulatorInfos[3].manipulator.available = t13;
  }
  destroy() {
    this.forEachManipulator((t13) => {
      this._tool.manipulators.remove(t13), t13.destroy();
    }), this._handles = l(this._handles), this._tool = null, this._view = null, this._arrowManipulatorInfos.length = 0;
  }
  forEachManipulator(t13) {
    for (const { manipulator: a15 } of this._arrowManipulatorInfos)
      t13(a15, A4.TRANSLATE_XY);
  }
  createGraphicDragPipeline(t13, a15, r15) {
    const e11 = a15.graphic, i10 = u4(e11), s10 = e2(e11.geometry).spatialReference;
    return r12(a15, r15, (a16) => this.createDragPipeline((r16, e12, i11, o11, s11) => a16(r16, t13(r16, e12, i11, o11, s11), i11), i10, s10, e11), this._view.state.viewingMode);
  }
  createDragPipeline(t13, a15, r15, i10) {
    return r2(this._arrowManipulatorInfos.map(({ manipulator: e11 }, o11) => p4(e11, (e12, s10, n12, l12, p11) => {
      const u7 = s10.next((t14) => ({ ...t14, manipulatorType: A4.TRANSLATE_XY })).next(C(this._view, e12.elevationAlignedLocation)).next(N(this._view, e12.elevationAlignedLocation, a15, r15, i10)).next(d6(e12.location, this.angle + (o11 + 1) * Math.PI * 0.5)).next(b3());
      t13(e12, u7, n12, l12, p11);
    })));
  }
  get angle() {
    return this._angle;
  }
  set angle(t13) {
    this._angle = t13, this.dragging ? this._updateAfterDrag = true : this._updateManipulatorTransform();
  }
  get displayScale() {
    return this._scale;
  }
  set displayScale(t13) {
    this._scale = t13, this._updateManipulatorTransform();
  }
  get radius() {
    return this._radius;
  }
  set radius(t13) {
    this._radius !== t13 && (this._radius = t13, this._updateManipulators());
  }
  _updateManipulators() {
    for (let t13 = 0; t13 < this._arrowManipulatorInfos.length; t13++)
      this._updateArrowManipulator(this._arrowManipulatorInfos[t13], t13);
    this._updateManipulatorTransform();
  }
  _updateArrowManipulator({ manipulator: t13, transform: a15 }, r15) {
    const e11 = this._radius / e10, i10 = c8 * e11, o11 = i10 * Math.sqrt(3) / 2, p11 = T3.createExtrudedTriangle(o11, i10 / 2, i10 / 2, M6);
    T3.transformInPlace(p11, x2(f7.get(), o3(c3.get(), 0, -o11 / 3, 0))), t13.renderObjects = [{ geometry: p11, material: this._opaqueMaterial, stateMask: t8.Focused }, { geometry: p11, material: this._transparentMaterial, stateMask: t8.Unfocused }], t13.radius = o11 / 3 * 2 * 1.2;
    const u7 = R(f7.get(), r15 * Math.PI / 2), h10 = x2(f7.get(), o3(c3.get(), 0, o9 * e11, 0));
    u3(a15, u7, h10);
  }
  _createManipulators() {
    for (let t13 = 0; t13 < 4; t13++) {
      const a15 = this._createArrowManipulator(t13);
      this._arrowManipulatorInfos.push(a15);
    }
    this._updateManipulatorTransform();
  }
  _updateManipulatorTransform() {
    const t13 = this.angle, a15 = p2(f7.get(), t13, r3(0, 0, 1)), r15 = q2(f7.get(), o3(c3.get(), this.displayScale, this.displayScale, this.displayScale)), e11 = u3(f7.get(), r15, a15);
    for (const i10 of this._arrowManipulatorInfos) {
      const t14 = u3(f7.get(), e11, i10.transform);
      i10.manipulator.modelTransform = t14;
    }
  }
  _createArrowManipulator(t13) {
    const a15 = new te({ view: this._view, autoScaleRenderObjects: false, worldOriented: true, focusMultiplier: 1, touchMultiplier: 1, collisionType: { type: "disc", direction: r3(0, 0, 1) } }), r15 = { manipulator: a15, transform: e5() };
    return this._updateArrowManipulator(r15, t13), this._handles.add(a15.events.on("drag", (t14) => {
      this._updateAfterDrag && "end" === t14.action && !this.dragging && (this._updateManipulatorTransform(), this._updateAfterDrag = false);
    })), r15;
  }
  _createMaterial(a15 = 1) {
    const r15 = l2.toUnitRGBA(r10.main);
    return r15[3] *= a15, new m8({ color: r15, transparent: 1 !== a15, cullFace: n7.Back, renderOccluded: h3.Transparent });
  }
  get test() {
    return { arrowManipulators: this._arrowManipulatorInfos.map(({ manipulator: t13 }) => t13) };
  }
};

// node_modules/@arcgis/core/views/3d/interactive/editingTools/snapping/SnapToScene.js
var a13 = class {
  constructor() {
    this.view = null, this.elevationInfo = null, this.lastDragEvent = null, this.next = new G2(), this._enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e11) {
    if (this._enabled !== e11 && r(this.lastDragEvent)) {
      const n12 = this.lastDragEvent.mapEnd, a15 = this._snap(this.lastDragEvent.screenEnd);
      if (r(a15)) {
        const t13 = { action: "update", mapStart: this.lastDragEvent.mapStart, mapEnd: true === e11 ? a15 : n12, screenStart: this.lastDragEvent.screenEnd, screenEnd: this.lastDragEvent.screenEnd };
        this.next.execute(t13);
      }
    }
    this._enabled = e11;
  }
  _snap(n12) {
    const a15 = r(this.view) ? this.view.toMap(n12, { exclude: [] }) : null;
    return r(a15) && r(this.view) && (a15.z = c4(a15, this.view, this.elevationInfo)), a15;
  }
  createDragEventPipelineStep(e11, n12) {
    return this.view = e11, this.elevationInfo = n12, this.lastDragEvent = null, (e12) => {
      if (this.lastDragEvent = "end" !== e12.action ? { ...e12 } : null, this._enabled) {
        const n13 = this._snap(e12.screenEnd);
        return r(n13) ? { action: e12.action, mapStart: e12.mapStart, mapEnd: n13, screenStart: e12.screenStart, screenEnd: e12.screenEnd } : null;
      }
      return { action: e12.action, mapStart: e12.mapStart, mapEnd: e12.mapEnd, screenStart: e12.screenStart, screenEnd: e12.screenEnd };
    };
  }
};

// node_modules/@arcgis/core/views/3d/interactive/editingTools/manipulations/MoveXYDiscManipulation.js
var E2 = class extends t12 {
  constructor(t13) {
    super(), this._snapToScene = new a13(), this._discMaterial = this._createMaterial(), this._discMaterialTransparent = this._createMaterial(0.5), this._scale = 1, this._radius = e10, this._view = t13.view, this._tool = t13.tool, null != t13.snapToScene && (this.snapToScene = t13.snapToScene), null != t13.radius && (this._radius = t13.radius), this._createManipulator(), this.forEachManipulator((t14) => this._tool.manipulators.add(t14));
  }
  destroy() {
    this.forEachManipulator((t13) => {
      this._tool.manipulators.remove(t13), t13.destroy();
    }), this._tool = null, this._view = null, this._manipulator = null;
  }
  forEachManipulator(t13) {
    t13(this._manipulator, A4.TRANSLATE_XY);
  }
  get displayScale() {
    return this._scale;
  }
  set displayScale(t13) {
    this._scale = t13, this._updateManipulatorTransform();
  }
  get snapToScene() {
    return this._snapToScene.enabled;
  }
  set snapToScene(t13) {
    this._snapToScene.enabled = t13;
  }
  get radius() {
    return this._radius;
  }
  set radius(t13) {
    t13 !== this._radius && (this._radius = t13, this._updateManipulator());
  }
  createGraphicDragPipeline(t13, i10, a15) {
    const r15 = i10.graphic, s10 = u4(r15), o11 = e2(r15.geometry).spatialReference;
    return r12(i10, a15, (e11) => this.createDragPipeline((i11, a16, r16, s11, o12) => e11(i11, t13(i11, a16, r16, s11, o12), r16), s10, o11, r15), this._view.state.viewingMode);
  }
  createDragPipeline(t13, e11, i10, a15) {
    const r15 = this._view;
    return p4(this._manipulator, (s10, o11, n12, l12, p11) => {
      const u7 = o11.next(C(r15, s10.elevationAlignedLocation)).next(N(r15, s10.elevationAlignedLocation, e11, i10, a15)).next(this._snapToScene.createDragEventPipelineStep(r15, e11), this._snapToScene.next).next((t14) => ({ ...t14, manipulatorType: A4.TRANSLATE_XY })).next(b3());
      t13(s10, u7, n12, l12, p11);
    });
  }
  _updateManipulatorTransform() {
    const t13 = q2(f7.get(), o3(c3.get(), this.displayScale, this.displayScale, this.displayScale));
    this._manipulator.modelTransform = t13;
  }
  _createManipulator() {
    const t13 = this._view;
    this._manipulator = new te({ view: t13, worldSized: false, autoScaleRenderObjects: false, focusMultiplier: 1, touchMultiplier: 1, collisionType: { type: "disc", direction: r3(0, 0, 1) }, worldOriented: true }), this._updateManipulator();
  }
  _updateManipulator() {
    const t13 = T3.createCylinderGeometry(M6, 1, a11, r3(0, 0, 1), r3(0, 0, 0)), e11 = q2(e5(), r3(this._radius, this._radius, this._radius));
    this._manipulator.renderObjects = [{ geometry: t13, material: this._discMaterial, transform: e11, stateMask: t8.Focused }, { geometry: t13, material: this._discMaterialTransparent, transform: e11, stateMask: t8.Unfocused }], this._manipulator.radius = h8 * (this._radius / e10);
  }
  _createMaterial(e11 = 1) {
    const i10 = l2.toUnitRGBA(r10.main);
    return i10[3] *= e11, new m8({ color: i10, transparent: 1 !== e11, cullFace: n7.Back, renderOccluded: h3.Transparent });
  }
  get test() {
    return { discManipulator: this._manipulator };
  }
};

// node_modules/@arcgis/core/views/3d/interactive/editingTools/manipulations/MoveZManipulation.js
var E3 = class extends t12 {
  constructor(t13) {
    super(), this._radius = e10, this.events = new n5(), this._tool = t13.tool, this._view = t13.view, null != t13.radius && (this._radius = t13.radius), this._createManipulator(), this.forEachManipulator((t14) => this._tool.manipulators.add(t14));
  }
  destroy() {
    this.forEachManipulator((t13) => {
      this._tool.manipulators.remove(t13), t13.destroy();
    });
  }
  forEachManipulator(t13) {
    t13(this._manipulator, A4.TRANSLATE_Z);
  }
  createGraphicDragPipeline(t13, e11, r15) {
    const i10 = e2(e11.graphic.geometry).spatialReference;
    return r12(e11, r15, (e12) => this.createDragPipeline((r16, a15, i11, o11, s10) => e12(r16, t13(r16, a15, i11, o11, s10), i11), i10), this._view.state.viewingMode);
  }
  createDragPipeline(t13, e11) {
    const r15 = this._view;
    return p4(this._manipulator, (a15, i10, o11, s10, n12) => {
      const l12 = i10.next((t14) => ({ ...t14, manipulatorType: A4.TRANSLATE_Z })).next(G5(r15, a15.renderLocation, e11)).next(b3());
      t13(a15, l12, o11, s10, n12);
    });
  }
  get radius() {
    return this._radius;
  }
  set radius(t13) {
    t13 !== this._radius && (this._radius = t13, this._updateManipulator());
  }
  _updateManipulator() {
    const e11 = this._radius / e10, r15 = y3.zManipulator.height * e11, a15 = y3.zManipulator.coneHeight * e11, l12 = y3.zManipulator.coneWidth * e11, m15 = y3.zManipulator.width * e11, c10 = [r3(0, 0, 0), r3(0, 0, r15)], u7 = T3.createTubeGeometry(c10, m15 / 2, 16, false), p11 = T3.createConeGeometry(a15, l12 / 2, 16, false), d14 = [r3(0, 0, 0), r3(0, 0, r15 + a15)], h10 = (t13) => {
      const e12 = e5();
      if (c2(e12, e12, [0, 0, r15]), b(e12, e12, Math.PI / 2), t13) {
        const r16 = 1 + 2 * t13 / l12;
        i2(e12, e12, [r16, r16, r16]);
      }
      return e12;
    }, M9 = h10(0), g6 = (e12, r16) => {
      const a16 = q3(y3.zManipulator.color, r16);
      return [a16.r / 255, a16.g / 255, a16.b / 255, y3.zManipulator.color.a * e12];
    }, j8 = w5(g6(1, 0.25), h3.Occlude), w8 = w5(g6(1, 0), h3.Occlude), b7 = w5(g6(0.7, 0), y3.zManipulator.renderOccluded), U5 = w5(g6(0.85, 0), y3.zManipulator.renderOccluded);
    this._manipulator.renderObjects = [{ geometry: p11, transform: M9, material: j8, stateMask: t8.Unfocused }, { geometry: u7, material: j8, stateMask: t8.Unfocused }, { geometry: p11, transform: M9, material: w8, stateMask: t8.Focused }, { geometry: u7, material: w8, stateMask: t8.Focused }, { geometry: p11, transform: M9, material: b7, stateMask: t8.Unfocused }, { geometry: u7, material: b7, stateMask: t8.Unfocused }, { geometry: p11, transform: M9, material: U5, stateMask: t8.Focused }, { geometry: u7, material: U5, stateMask: t8.Focused }], this._manipulator.radius = m15 / 2 + 2, this._manipulator.collisionType = { type: "line", paths: [d14] };
  }
  _createManipulator() {
    const t13 = new te({ view: this._view, autoScaleRenderObjects: false, worldSized: false, selectable: false, cursor: "ns-resize", elevationInfo: this.elevationInfo, worldOriented: true, collisionPriority: 1.6 });
    t13.applyObjectTransform = (t14) => {
      const e11 = this._view.state.camera, a15 = O4;
      this._view.renderCoordsHelper.toRenderCoords(this._manipulator.elevationAlignedLocation, a15);
      const i10 = U(e11.eye, a15), o11 = e11.computeRenderPixelSizeAtDist(i10), s10 = e3(A5, a15, e11.eye);
      z2(s10, s10);
      const n12 = x7;
      this._view.renderCoordsHelper.worldUpAtPosition(O4, n12);
      const h10 = Math.abs(P(s10, n12)), f11 = _(A5, s10, n12), M9 = _(A5, f11, n12), _7 = o4(h10, 0.01, 1), g6 = 1 - Math.sqrt(1 - _7 * _7) / _7 / e11.fullWidth, j8 = this._radius / e10, w8 = y3.zManipulator.width * j8;
      q(M9, z2(M9, M9), (1 / g6 - 1) * i10 + o11 * w8), t14[12] -= A5[0], t14[13] -= A5[1], t14[14] -= A5[2];
    }, this._manipulator = t13, this._updateManipulator();
  }
  get test() {
    return { manipulator: this._manipulator };
  }
};
var O4 = n4();
var A5 = n4();
var x7 = n4();

// node_modules/@arcgis/core/views/3d/interactive/editingTools/manipulations/MoveManipulation.js
var c9 = class extends t12 {
  constructor(a15) {
    super(), this._handles = new u2(), this._angleDeferred = null, this._interactive = true;
    const { tool: t13, view: e11, snapToScene: n12, radius: s10 } = a15;
    this._view = e11, this.xyManipulation = new E2({ tool: t13, view: e11, snapToScene: n12, radius: s10 }), this.xyAxisManipulation = new O3({ tool: t13, view: e11, radius: s10 }), this.zManipulation = new E3({ tool: t13, view: e11, radius: s10 }), this.xyManipulation.available = a15.xyAvailable, this.xyAxisManipulation.available = a15.xyAxisAvailable, this.zManipulation.available = a15.zAvailable, this._autoHideXYAxis(), this.forEachManipulator((i10) => {
      this._handles.add(i10.events.on("grab-changed", () => this._updateManipulatorInteractivity()));
    });
  }
  destroy() {
    this._handles.destroy(), this.xyManipulation.destroy(), this.xyAxisManipulation.destroy(), this.zManipulation.destroy();
  }
  createGraphicDragPipeline(i10, t13, e11) {
    return r2([this.xyManipulation.createGraphicDragPipeline((a15, t14, e12, n12, s10) => i10(d11.XY, a15, t14, e12, n12, s10), t13, e11), this.xyAxisManipulation.createGraphicDragPipeline((a15, t14, e12, n12, s10) => i10(d11.XY_AXIS, a15, t14, e12, n12, s10), t13, e11), this.zManipulation.createGraphicDragPipeline((a15, t14, e12, n12, s10) => i10(d11.Z, a15, t14, e12, n12, s10), t13, e11)]);
  }
  createDragPipeline(i10, t13, e11, n12) {
    return r2([this.xyManipulation.createDragPipeline((a15, t14, e12, n13, s10) => i10(d11.XY, a15, t14, e12, n13, s10), t13, e11, n12), this.xyAxisManipulation.createDragPipeline((a15, t14, e12, n13, s10) => i10(d11.XY_AXIS, a15, t14, e12, n13, s10), t13, e11, n12), this.zManipulation.createDragPipeline((a15, t14, e12, n13, s10) => i10(d11.Z, a15, t14, e12, n13, s10), e11)]);
  }
  set snapToScene(i10) {
    this.xyManipulation.snapToScene = i10;
  }
  set angle(i10) {
    this._angleDeferred = null, this.xyAxisManipulation.angle = i10;
  }
  set angleDeferred(i10) {
    this.xyAxisVisible ? this.angle = i10() : this._angleDeferred = i10;
  }
  set interactive(i10) {
    this._interactive !== i10 && (this._interactive = i10, this._updateManipulatorInteractivity());
  }
  set radius(i10) {
    this.xyAxisManipulation.radius = i10, this.xyManipulation.radius = i10, this.zManipulation.radius = i10;
  }
  set displayScale(i10) {
    this.xyManipulation.displayScale = i10, this.xyAxisManipulation.displayScale = i10;
  }
  forEachManipulator(i10) {
    this.xyManipulation.forEachManipulator((a15) => i10(a15, A4.TRANSLATE_XY)), this.xyAxisManipulation.forEachManipulator((a15) => i10(a15, A4.TRANSLATE_XY)), this.zManipulation.forEachManipulator((a15) => i10(a15, A4.TRANSLATE_Z));
  }
  get xyAxisVisible() {
    const i10 = this.xyManipulation.someManipulator((i11) => i11.focused) || this.xyAxisManipulation.someManipulator((i11) => i11.focused);
    return this._view.inputManager && "touch" === this._view.inputManager.latestPointerType || i10;
  }
  _autoHideXYAxis() {
    const i10 = this.xyAxisManipulation, a15 = this.xyManipulation;
    if (a("esri-mobile"))
      return;
    const s10 = [];
    a15.forEachManipulator((i11) => s10.push(i11)), i10.forEachManipulator((i11) => s10.push(i11));
    const o11 = () => {
      const a16 = [];
      this.xyAxisVisible ? r(this._angleDeferred) && (this.angle = this._angleDeferred()) : i10.forEachManipulator((i11) => a16.push(i11.disableDisplay())), this._handles.remove(M7), this._handles.add(a16, M7);
    };
    for (const t13 of s10)
      this._handles.add(t13.events.on("focus-changed", o11));
    this._view.inputManager && this._handles.add(f4(() => {
      var _a;
      return (_a = this._view.inputManager) == null ? void 0 : _a.latestPointerType;
    }, o11)), o11();
  }
  _updateManipulatorInteractivity() {
    const i10 = this.grabbing;
    this.forEachManipulator((a15) => {
      a15.interactive = !i10 && this._interactive || a15.grabbing;
    });
  }
  static radiusForSymbol(i10) {
    const a15 = r(i10) && "point-3d" === i10.type && i10.symbolLayers;
    return !!a15 && a15.length > 0 && a15.some((i11) => "icon" === i11.type) ? I : e10;
  }
};
var M7 = "disable-xy-axis-display";
var d11;
!function(i10) {
  i10[i10.XY = 0] = "XY", i10[i10.XY_AXIS = 1] = "XY_AXIS", i10[i10.Z = 2] = "Z";
}(d11 || (d11 = {}));

// node_modules/@arcgis/core/views/3d/interactive/editingTools/manipulations/MoveXYGraphicManipulation.js
var l11 = class extends t12 {
  constructor(t13) {
    super(), this._view = t13.view, this._tool = t13.tool, this._graphicState = t13.graphicState, this._createManipulator(), this.forEachManipulator((t14) => this._tool.manipulators.add(t14));
  }
  destroy() {
    this.forEachManipulator((t13) => {
      this._tool.manipulators.remove(t13), t13.destroy();
    }), this._tool = null, this._view = null, this._manipulator = null, this._graphicState = null;
  }
  forEachManipulator(t13) {
    t13(this._manipulator, A4.TRANSLATE_XY);
  }
  createGraphicDragPipeline(t13) {
    return r12(this._graphicState, t13, (t14) => this.createDragPipeline(t14), this._view.state.viewingMode);
  }
  createDragPipeline(e11) {
    const r15 = this._view, a15 = this._graphicState.graphic, p11 = r(a15.geometry) ? a15.geometry.spatialReference : null;
    return p4(this._manipulator, (t13, o11, l12, h10, c10) => {
      const m15 = o11.next(h7(c10, r15, a15, p11)).next(D2()).next(b3());
      e11(t13, m15, l12, h10, c10);
    });
  }
  _createManipulator() {
    const t13 = this._view, i10 = this._graphicState.graphic;
    this._manipulator = new C3({ graphic: i10, view: t13, selectable: true, cursor: "move" });
  }
};

// node_modules/@arcgis/core/views/interactive/tooltip/TranslateTooltipInfos.js
var i7 = class extends e8 {
  constructor(t13) {
    super(t13), this.type = "translate-graphic", this.distance = y2;
  }
};
e([d()], i7.prototype, "type", void 0), e([d()], i7.prototype, "distance", void 0), i7 = e([n3("esri.views.interactive.tooltip.TranslateGraphicTooltipInfo")], i7);
var p7 = class extends e8 {
  constructor(t13) {
    super(t13), this.type = "translate-z", this.distance = y2;
  }
};
e([d()], p7.prototype, "type", void 0), e([d()], p7.prototype, "distance", void 0), p7 = e([n3("esri.views.interactive.tooltip.TranslateZTooltipInfo")], p7);
var a14 = class extends e8 {
  constructor(t13) {
    super(t13), this.type = "translate-vertex", this.distance = y2, this.elevation = null, this.area = null, this.totalLength = null;
  }
};
e([d()], a14.prototype, "type", void 0), e([d()], a14.prototype, "distance", void 0), e([d()], a14.prototype, "elevation", void 0), e([d()], a14.prototype, "area", void 0), e([d()], a14.prototype, "totalLength", void 0), a14 = e([n3("esri.views.interactive.tooltip.TranslateVertexTooltipInfo")], a14);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/moveGraphic/GraphicMoveTool.js
var V3 = class {
  constructor(t13) {
    this.allGraphics = t13, this.type = "graphic-move-start";
  }
};
var L2 = class {
  constructor(t13, i10, e11) {
    this.dx = t13, this.dy = i10, this.allGraphics = e11, this.type = "graphic-move";
  }
};
var N3 = class {
  constructor(t13) {
    this.allGraphics = t13, this.type = "graphic-move-stop";
  }
};
var F4 = class extends a6(n5.EventedMixin(c7)) {
  constructor(t13) {
    super(t13), this.graphics = new j2(), this.enableZ = true, this.tooltipOptions = new r8(), this.type = "move-3d", this._snappingPipeline = new d7(), this._tooltip = null;
  }
  initialize() {
    const { graphics: t13, view: i10 } = this;
    this.own([t13.on("change", () => this._refreshManipulators()), l3(() => this.tooltipOptions.enabled, (t14) => {
      this._tooltip = t14 ? new m4({ view: i10 }) : l(this._tooltip);
    }, w)]), this._refreshManipulators(), this.finishToolCreation();
  }
  destroy() {
    this._tooltip = l(this._tooltip), this.graphics.removeAll(), this._set("view", null);
  }
  get updating() {
    return this.updatingHandles.updating;
  }
  reset() {
  }
  _refreshManipulators() {
    this.handles.removeAll(), this._moveManipulation && this._moveManipulation.destroy(), this.manipulators.removeAll();
    const t13 = this.graphics.toArray().filter((t14) => i3(t14) === P3.SUPPORTED).map((t14) => new B3(t14));
    t13.length && (this._createManipulators(t13), this._createVisualElements(t13), this.handles.add(t13.map((t14) => this.view.trackGraphicState(t14.state))), this._updateMoveManipulation(t13));
  }
  _createManipulators(t13) {
    for (const i10 of t13) {
      const e11 = i10.state;
      i10.manipulationXY = new l11({ tool: this, view: this.view, graphicState: e11 }), i10.manipulationXY.forEachManipulator((t14) => this.handles.add([t14.events.on("immediate-click", (t15) => {
        this.emit("immediate-click", { ...t15, graphic: e11.graphic }), t15.stopPropagation();
      }), t14.events.on("grab-changed", ({ action: t15 }) => {
        const { tooltipOptions: i11, _tooltip: e12 } = this;
        t(e12) || ("focus" === t15 ? e12.info = new i7({ tooltipOptions: i11 }) : e12.clear());
      })])), this.handles.add(i10.manipulationXY.createDragPipeline((i11, e12, o11, n12) => this._buildDragEventPipeline(t13, d11.XY, i11, e12, o11, n12)));
    }
    this._createMoveManipulation(t13);
  }
  _createMoveManipulation(t13) {
    const i10 = new c9({ tool: this, view: this.view, snapToScene: false, xyAvailable: true, xyAxisAvailable: true, zAvailable: true, radius: 1 === t13.length ? c9.radiusForSymbol(t13[0].graphic.symbol) : e10 });
    this._moveManipulation = i10, i10.elevationInfo = { mode: "absolute-height", offset: 0 }, i10.forEachManipulator((t14, e12) => {
      this.handles.add(t14.events.on("immediate-click", (e13) => {
        i10.zManipulation.hasManipulator(t14) || 1 !== this.graphics.length || this.emit("immediate-click", { ...e13, graphic: this.graphics.getItemAt(0) }), e13.stopPropagation();
      })), e12 === A4.TRANSLATE_XY && this.handles.add(t14.events.on("focus-changed", ({ action: t15 }) => {
        const { tooltipOptions: i11, _tooltip: e13 } = this;
        t(e13) || ("focus" === t15 ? e13.info = new i7({ tooltipOptions: i11 }) : e13.clear());
      })), e12 === A4.TRANSLATE_Z && this.handles.add(t14.events.on("focus-changed", ({ action: t15 }) => {
        const { tooltipOptions: i11, _tooltip: e13 } = this;
        t(e13) || ("focus" === t15 ? e13.info = new p7({ tooltipOptions: i11 }) : e13.clear());
      }));
    });
    const e11 = () => this._updateMoveManipulation(t13);
    for (const n12 of t13)
      this.handles.add([n12.state.on("changed", e11), l3(() => n12.state.displaying, e11)]);
    const o11 = t13[t13.length - 1];
    this.handles.add(o11.state.on("changed", () => this._updateMoveManipulationAngle(o11))), this.handles.add(i10.createDragPipeline((i11, e12, o12, n12, a15) => this._buildDragEventPipeline(t13, i11, e12, o12, n12, a15), u4(o11.graphic), e2(o11.graphic.geometry).spatialReference, o11.graphic)), this._updateMoveManipulationAngle(o11);
  }
  _createVisualElements(t13) {
    for (const i10 of t13) {
      const e11 = i10.graphic, o11 = i5({ view: this.view, graphic: e11, forEachManipulator: (t14) => {
        i10.manipulationXY.forEachManipulator(t14), this._moveManipulation.forEachManipulator(t14);
      }, onManipulatorsChanged: () => n2() });
      t(o11) || (i10.geometryRepresentation = o11.visualElement, i10.geometryRepresentation instanceof S3 && this.handles.add([i10.geometryRepresentation.events.on("attachment-origin-changed", () => {
        i10.state.isDraped || this._updateMoveManipulation(t13);
      }), l3(() => i10.state.isDraped, () => this._updateMoveManipulation(t13))]), this.handles.add(o11));
    }
  }
  _updateMoveManipulationAngle(t13) {
    this._moveManipulation.angleDeferred = () => a12(t13.graphic.geometry);
  }
  _updateMoveManipulation(t13) {
    const i10 = v4(0, 0, 0, this.view.spatialReference);
    let e11 = 0, o11 = false;
    const n12 = this._moveManipulation;
    for (const a15 of t13) {
      if (!a15.state.displaying)
        continue;
      const t14 = a15.state.graphic;
      this.enableZ && t10(t14) && (o11 = true);
      const n13 = a15.geometryRepresentation instanceof S3 && !a15.state.isDraped ? a15.geometryRepresentation.attachmentOrigin : F2(this.view, t14);
      r(n13) && (i10.x += n13.x, i10.y += n13.y, i10.z += n13.z, e11++);
    }
    e11 > 0 ? (i10.x /= e11, i10.y /= e11, i10.z /= e11, n12.location = i10, n12.xyManipulation.available = true, n12.xyAxisManipulation.available = true, n12.zManipulation.available = o11) : n12.available = false;
  }
  _buildDragEventPipeline(t13, i10, e11, o11, n12, a15) {
    const s10 = [], r15 = [];
    let p11 = null, l12 = null;
    const h10 = () => {
      for (const t14 of s10)
        t14.dragging = false;
      s10.length = 0, r15.length = 0, p11 = null, l12 = null, this._moveManipulation.interactive = true;
    };
    if (1 === t13.length && i10 === d11.XY) {
      const i11 = t13[0].graphic;
      o11 = this._buildSnappingPipelineSteps(i11, u4(i11), o11, n12, a15);
    }
    const c10 = o11.next((i11) => {
      if ("start" === i11.action) {
        s10.length = 0, r15.length = 0;
        for (const i12 of t13)
          i12.dragging || !i12.manipulationXY.hasManipulator(e11) && i12.manipulationXY.grabbing || (s10.push(i12), r15.push(i12.graphic), i12.dragging = true);
        if (0 !== r15.length && (this._moveManipulation.interactive = false, p11 = R2(r15, this.view.state.viewingMode), l12 = M3(r15), this.emit("graphic-move-start", new V3(r15)), this.destroyed))
          return null;
      }
      return 0 !== r15.length ? i11 : null;
    }).next((t14) => p11(t14)).next((e12) => this._updateMoveTooltip(e12, i10, t13)).next((t14) => {
      switch (t14.action) {
        case "start":
        case "update":
          if (t14.translationX || t14.translationY || t14.translationZ) {
            const i11 = this.view.toScreen(t14.mapStart), e12 = this.view.toScreen(t14.mapEnd), o12 = e12.x - i11.x, n13 = e12.y - i11.y;
            if (this.emit("graphic-move", new L2(o12, n13, r15)), this.destroyed)
              return null;
          }
          break;
        case "end":
          if (this.emit("graphic-move-stop", new N3(r15)), this.destroyed)
            return null;
          h10();
      }
    });
    return n12.next((t14) => l12(t14)).next(() => {
      if (this.emit("graphic-move-stop", new N3(r15)), this.destroyed)
        return null;
      h10();
    }), c10;
  }
  _updateMoveTooltip(t13, i10, e11) {
    const { tooltipOptions: o11, _tooltip: n12 } = this;
    if (t(n12))
      return t13;
    if (n12.clear(), i10 === d11.XY || i10 === d11.XY_AXIS)
      if ("end" === t13.action)
        n12.info = new i7({ tooltipOptions: o11 });
      else {
        const i11 = 0 === e11.length ? "absolute-height" : e11[0].state.isDraped ? "on-the-ground" : "absolute-height", a15 = d9(t13.mapStart, t13.mapEnd, i11);
        r(a15) && (n12.info = new i7({ tooltipOptions: o11, distance: a15 }));
      }
    return i10 === d11.Z && ("end" === t13.action ? n12.info = new p7({ tooltipOptions: o11 }) : o(d8(t13.mapStart, t13.mapEnd), (t14) => {
      n12.info = new p7({ tooltipOptions: o11, distance: t14 });
    })), t13;
  }
  _buildSnappingPipelineSteps(t13, i10, e11, o11, n12) {
    const a15 = t13.geometry;
    if (t(a15) || "point" !== a15.type && "mesh" !== a15.type)
      return e11;
    const r15 = ("point" === a15.type ? a15 : a15.anchor).clone(), p11 = new e7({ elevationInfo: i10, pointer: n12, editGeometryOperations: S.fromGeometry(r15, this.view.state.viewingMode), visualizer: new g3(), excludeFeature: t13 }), l12 = this.snappingManager;
    return e11.next((i11) => {
      r15.z = f8(this.view, r15, u4(t13), { mode: "absolute-height", offset: 0 });
      return { ...i11, snapOrigin: p11.coordinateHelper.pointToVector(r15) };
    }).next(this._snappingPipeline.createSnapDragEventPipelineStep({ snappingContext: p11, snappingManager: l12, cancel: o11, updatingHandles: this.updatingHandles }), this._snappingPipeline.next);
  }
  get test() {
    return { tooltip: this._tooltip };
  }
};
e([d({ constructOnly: true, nonNullable: true })], F4.prototype, "view", void 0), e([d()], F4.prototype, "graphics", void 0), e([d({ constructOnly: true, nonNullable: true })], F4.prototype, "enableZ", void 0), e([d({ constructOnly: true, type: r8 })], F4.prototype, "tooltipOptions", void 0), e([d({ constructOnly: true })], F4.prototype, "snappingManager", void 0), e([d()], F4.prototype, "type", void 0), e([d()], F4.prototype, "updating", null), F4 = e([n3("esri.views.3d.interactive.editingTools.graphicMove3D.GraphicMoveTool")], F4);
var B3 = class {
  constructor(t13) {
    this.state = null, this.geometryRepresentation = null, this.manipulationXY = null, this.dragging = false, this.state = new e9({ graphic: t13 });
  }
  get graphic() {
    return this.state.graphic;
  }
};

// node_modules/@arcgis/core/views/3d/interactive/editingTools/reshapeGraphic/edgeOffsetUtils.js
function j7(e11, r15, o11) {
  const n12 = "on-the-ground" === o11.mode ? T2.XY : T2.XYZ;
  return new X(e11, n12, r15, 0);
}
function h9(r15, o11, n12) {
  const s10 = n4();
  if (!r15.renderCoordsHelper.toRenderCoords(o11, s10))
    return null;
  const c10 = y4(r15, o11, Z(n12.plane)), i10 = y4(r15, o11, n12.edgeDirection);
  if (t(c10) || t(i10))
    return null;
  const u7 = _(n4(), c10, i10);
  return _3(s10, u7, p3());
}
function y4(e11, r15, o11) {
  const n12 = v4(r15.x + o11[0], r15.y + o11[1], r15.z + o11[2], r15.spatialReference), t13 = n4(), c10 = n4();
  return e11.renderCoordsHelper.toRenderCoords(r15, t13) && e11.renderCoordsHelper.toRenderCoords(n12, c10) ? H(c10, t13, c10) : null;
}
function C6(e11, r15, o11) {
  const c10 = Z(e11), i10 = H(n4(), r15, o11), p11 = _(n4(), i10, c10), m15 = _(n4(), i10, p11);
  return t4(i10[0], i10[1], i10[2], 0, p11[0], p11[1], p11[2], 0, m15[0], m15[1], m15[2], 0, 0, 0, 0, 1);
}
function R4(e11, n12, t13) {
  const s10 = t13.projectToRenderScreen(e11, x()), d14 = t13.projectToRenderScreen(n12, x());
  return r(s10) && r(d14) ? v(e3(s10, s10, d14)) : 0;
}

// node_modules/@arcgis/core/views/interactive/tooltip/ReshapeTooltipInfos.js
var p8 = class extends e8 {
  constructor(o11) {
    super(o11), this.type = "reshape-edge-offset", this.distance = y2;
  }
};
e([d()], p8.prototype, "type", void 0), e([d()], p8.prototype, "distance", void 0), p8 = e([n3("esri.views.interactive.tooltip.ReshapeEdgeOffsetTooltipInfo")], p8);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/reshapeGraphic/ReshapeOperation.js
var He = class extends n5.EventedMixin(d3) {
  constructor(e11) {
    super(e11), this._vertexManipulatorMaterial = w5(y3.colorToVec4(y3.reshapeManipulators.vertex.color), y3.reshapeManipulators.vertex.renderOccluded), this._vertexManipulatorOutlineMaterial = b4(y3.colorToVec4(y3.reshapeManipulators.vertex.outlineColor), y3.reshapeManipulators.vertex.renderOccluded), this._vertexManipulatorHoverOutlineMaterial = b4(y3.colorToVec4(y3.reshapeManipulators.vertex.hoverOutlineColor), y3.reshapeManipulators.vertex.renderOccluded), this._edgeManipulatorMaterial = w5(y3.colorToVec4(y3.reshapeManipulators.edge.color), y3.reshapeManipulators.edge.renderOccluded), this._edgeManipulatorOutlineMaterial = b4(y3.colorToVec4(y3.reshapeManipulators.edge.outlineColor), y3.reshapeManipulators.edge.renderOccluded), this._edgeOffsetManipulatorMaterial = w5(y3.colorToVec4(y3.reshapeManipulators.edgeOffset.color), y3.reshapeManipulators.edgeOffset.renderOccluded, false), this._edgeOffsetManipulatorHoverMaterial = w5(y3.colorToVec4(y3.reshapeManipulators.edgeOffset.hoverColor), y3.reshapeManipulators.edgeOffset.renderOccluded, false), this._selectedManipulatorMaterial = w5(y3.colorToVec4(y3.reshapeManipulators.selected.color), y3.reshapeManipulators.selected.renderOccluded), this._selectedManipulatorOutlineMaterial = b4(y3.colorToVec4(y3.reshapeManipulators.selected.outlineColor), y3.reshapeManipulators.selected.renderOccluded), this._selectedManipulatorHoverOutlineMaterial = b4(y3.colorToVec4(y3.reshapeManipulators.selected.hoverOutlineColor), y3.reshapeManipulators.selected.renderOccluded), this._selectedIndex = 0, this._vertexManipulatorGeometry = null, this._vertexManipulatorOutlineGeometry = null, this._edgeManipulatorGeometry = null, this._edgeManipulatorOutlineGeometry = null, this._edgeOffsetManipulatorGeometryInside = null, this._edgeOffsetManipulatorGeometryOutside = null, this._manipulatorHandles = new u2(), this._manipulatorInfos = [], this._editGeometryOperations = null, this._graphicMoveManipulation = null, this._moveManipulation = null, this._numGrabbing = 0, this._numDragging = 0, this._reshapeEventState = Pe.NONE, this._outlineVisualElement = null, this._segmentLabels = null, this.outputGeometry = null, this._snappingPipeline = new d7(), this._snappingPipelineHandle = new d7(), this._vertexLaserLineVisualElement = null;
  }
  initialize() {
    const { graphic: e11, view: t13 } = this, i10 = this._graphicState = new e9({ graphic: e11 });
    this._tooltip = new m4({ view: t13 }), this.own([l3(() => i10.displaying, (e12) => {
      for (const t14 of this._manipulatorInfos)
        t14.manipulator.available = e12;
    }), l3(() => ({ labels: this._segmentLabels, enabled: this._labelOptions.enabled, edgeOffsetEnabled: this.enableEdgeOffset }), ({ labels: e12, enabled: t14, edgeOffsetEnabled: i11 }) => {
      r(e12) && (e12.visible = t14, e12.edgeDistance = i11 ? "far" : "default");
    }, h), f4(() => !this._tooltipOptions.enabled, () => this._tooltip.clear(), h), this.view.trackGraphicState(i10)]);
  }
  destroy() {
    this._segmentLabels = l(this._segmentLabels), this._tooltip = l(this._tooltip), this._editGeometryOperations = l(this._editGeometryOperations), this._moveManipulation = l(this._moveManipulation), this._graphicMoveManipulation = l(this._graphicMoveManipulation), this._manipulatorHandles = l(this._manipulatorHandles), this.manipulators.removeAll(), this._manipulatorInfos = [], this._resetGrabbingDragging();
  }
  get inputGeometry() {
    return r(this._editGeometryOperations) ? this._editGeometryOperations.data.geometry : null;
  }
  set inputGeometry(e11) {
    this._recreateEditGeometryAndManipulators(e11);
  }
  get updating() {
    return this.updatingHandles.updating;
  }
  get manipulators() {
    return this.tool.manipulators;
  }
  get view() {
    return this.tool.view;
  }
  get graphic() {
    return this.tool.graphic;
  }
  get enableZShape() {
    return this.tool.enableZShape;
  }
  get enableZVertex() {
    return this.tool.enableZVertex;
  }
  get enableMoveGraphic() {
    return this.tool.enableMoveGraphic;
  }
  get enableMidpoints() {
    return this.tool.enableMidpoints;
  }
  get enableEdgeOffset() {
    return this.tool.enableEdgeOffset;
  }
  get _labelOptions() {
    return this.tool.labelOptions;
  }
  get _tooltipOptions() {
    return this.tool.tooltipOptions;
  }
  removeSelectedVertices() {
    const e11 = this._manipulatorInfos.filter((e12) => e12.manipulator.selected && "vertex" === e12.type);
    this._removeVertices(e11);
  }
  manipulatorSelectionChanged() {
    this.emit("manipulators-changed");
  }
  _removeManipulators() {
    this._moveManipulation = l(this._moveManipulation), this._graphicMoveManipulation = l(this._graphicMoveManipulation), this._manipulatorHandles.removeAll(), this.manipulators.removeAll(), this._manipulatorInfos = [];
  }
  _resetGrabbingDragging() {
    this._numGrabbing = 0, this._numDragging = 0;
  }
  _createManipulators() {
    if (t(this._editGeometryOperations))
      return;
    const e11 = u4(this.graphic);
    for (const t13 of this._editGeometryOperations.data.components) {
      for (const i10 of t13.vertices)
        this._createVertexOrEdgeManipulator(i10, e11);
      for (const i10 of t13.edges)
        this._createVertexOrEdgeManipulator(i10, e11);
    }
    this._createGraphicMoveManipulators(e11);
  }
  get canRedo() {
    return r(this._editGeometryOperations) && this._editGeometryOperations.canRedo;
  }
  get canUndo() {
    return r(this._editGeometryOperations) && this._editGeometryOperations.canUndo;
  }
  redo() {
    if (t(this._editGeometryOperations))
      return null;
    const e11 = this._editGeometryOperations.redo();
    return r(e11) && (this.outputGeometry = this._editGeometryOperations.data.geometry, this._recreateManipulators()), e11;
  }
  undo() {
    if (t(this._editGeometryOperations))
      return null;
    this.emit("undo");
    const e11 = this._editGeometryOperations.undo();
    return r(e11) && (this.outputGeometry = this._editGeometryOperations.data.geometry, this._recreateManipulators()), e11;
  }
  _recreateManipulators() {
    this._removeManipulators(), this._resetGrabbingDragging(), this._tooltip.clear(), this._createManipulators();
  }
  _recreateEditGeometryAndManipulators(e11 = this.inputGeometry) {
    this._removeManipulators(), this._resetGrabbingDragging(), this._tooltip.clear(), t(e11) || (l(this._editGeometryOperations), this._editGeometryOperations = S.fromGeometry(e11, this.view.state.viewingMode), this._createManipulators(), l(this._segmentLabels), this._segmentLabels = new a9({ context: { view: this.view, editGeometryOperations: this._editGeometryOperations, elevationInfo: u4(this.graphic), labelOptions: this._labelOptions, graphic: this.graphic, graphicState: this._graphicState }, visible: this._labelOptions.enabled }));
  }
  _perGraphicManipulatorDragAction(e11, t13) {
    if ("end" === t13.action)
      return t13;
    let i10 = 0;
    const a15 = [], o11 = this._manipulatorInfos.some((e12) => "vertex" === e12.type && e12.manipulator.selected), n12 = e11 === je.SELECTED_OR_ALL && o11;
    for (const r15 of this._manipulatorInfos)
      "vertex" === r15.type && (r15.manipulator.grabbing || n12 && !r15.manipulator.selected || a15.push(r15), i10++);
    if (0 === a15.length)
      return t13;
    this._moveVertices(a15, t13);
    if (a15.length === i10) {
      if (this._updateEventState(Pe.MOVING), this.destroyed)
        return t13;
      this.emit("move", { type: "move", dx: t13.screenDeltaX, dy: t13.screenDeltaY, mover: this.graphic });
    } else {
      if (this._updateEventState(Pe.RESHAPING), this.destroyed)
        return t13;
      this.emit("reshape", { type: "reshape", mover: this.graphic });
    }
    return t13;
  }
  _isMultiVertexSelection() {
    let e11 = 0;
    for (const t13 of this._manipulatorInfos)
      "vertex" === t13.type && t13.manipulator.selected && e11++;
    return e11 > 1;
  }
  _perVertexManipulatorDragAction(e11) {
    if (this._updateEventState(Pe.RESHAPING), this.destroyed)
      return;
    const { mapDeltaX: t13, mapDeltaY: i10, mapDeltaZ: a15 } = e11;
    if (!t13 && !i10 && !a15)
      return;
    const o11 = [];
    for (const n12 of this._manipulatorInfos)
      "vertex" === n12.type && (n12.manipulator.selected && !n12.manipulator.grabbing || n12 === e11.info) && o11.push(n12);
    this._moveVertices(o11, e11, E.ACCUMULATE_STEPS), this.emit("reshape", { type: "reshape", mover: this.graphic });
  }
  _updateEventState(e11) {
    if (e11 === this._reshapeEventState)
      return false;
    switch (e11) {
      case Pe.NONE:
        if (0 !== this._numGrabbing || 0 !== this._numDragging)
          return false;
        switch (this._reshapeEventState) {
          case Pe.MOVING:
            this.emit("move", { type: "move-stop", dx: 0, dy: 0, mover: this.graphic });
            break;
          case Pe.RESHAPING:
            this.emit("reshape", { type: "reshape-stop", mover: this.graphic });
        }
        break;
      case Pe.MOVING:
        switch (this._reshapeEventState) {
          case Pe.NONE:
            this.emit("move", { type: "move-start", dx: 0, dy: 0, mover: this.graphic });
            break;
          case Pe.RESHAPING:
            this.emit("reshape", { type: "reshape-stop", mover: this.graphic }), this.destroyed || this.emit("move", { type: "move-start", dx: 0, dy: 0, mover: this.graphic });
        }
        break;
      case Pe.RESHAPING:
        switch (this._reshapeEventState) {
          case Pe.NONE:
            this.emit("reshape", { type: "reshape-start", mover: this.graphic });
            break;
          case Pe.MOVING:
            this.emit("move", { type: "move-stop", dx: 0, dy: 0, mover: this.graphic }), this.destroyed || this.emit("reshape", { type: "reshape-start", mover: this.graphic });
        }
    }
    if (this.destroyed)
      return false;
    const t13 = this._reshapeEventState !== e11;
    return this._reshapeEventState = e11, t13;
  }
  _createGraphicMoveManipulators(e11) {
    const { graphic: t13, handles: i10, tool: a15, view: o11 } = this, n12 = this._graphicState;
    if (this._graphicMoveManipulation = new l11({ tool: a15, view: o11, graphicState: n12 }), this.enableMoveGraphic) {
      let e12 = null;
      this._manipulatorHandles.add(this._graphicMoveManipulation.createDragPipeline((t14, i11, a16) => {
        i11.next((e13) => this._trackNumDragging(e13)).next((t15) => ("start" === t15.action && (e12 = e2(this._editGeometryOperations).createUndoGroup()), t15)).next((e13) => this._perGraphicManipulatorDragAction(je.ALL, e13)).next((e13) => (this._updateTranslateGraphicTooltip(d11.XY, e13), e13)).next((t15) => {
          "end" === t15.action && (this._tooltip.clear(), e12 = a2(e12));
        }), a16.next(this._cancelDragOperation(() => e12 = a2(e12)));
      }));
    } else
      this._graphicMoveManipulation.forEachManipulator((e12) => {
        e12.grabbable = false, e12.cursor = null;
      });
    this._graphicMoveManipulation.forEachManipulator((e12) => this._manipulatorHandles.add([this._watchAndUpdateGrabState(e12, false), e12.events.on("immediate-click", (e13) => {
      this._manipulatorInfos.some((e14) => e14.manipulator.selected) ? this._clearSelection() : this.emit("immediate-click", { ...e13, graphic: this.graphic }), e13.stopPropagation();
    })])), this._moveManipulation = new c9({ tool: a15, view: o11, xyAvailable: true, xyAxisAvailable: true, zAvailable: this.enableZShape && t10(t13), snapToScene: false, radius: c9.radiusForSymbol(t13.symbol) }), this._moveManipulation.forEachManipulator((e12, a16) => {
      i10.add([this._watchAndUpdateGrabState(e12, false), e12.events.on("immediate-click", (i11) => {
        this._moveManipulation.zManipulation.hasManipulator(e12) || this._manipulatorInfos.some((e13) => e13.manipulator.selected) || this.emit("immediate-click", { ...i11, graphic: t13 }), i11.stopPropagation();
      })]), i10.add(e12.events.on("focus-changed", ({ action: e13 }) => {
        "focus" === e13 && this._tooltipOptions.enabled ? this._updateTranslateTooltip(a16 === A4.TRANSLATE_Z ? d11.Z : d11.XY) : this._tooltip.clear();
      }));
    }), this._moveManipulation.elevationInfo = { mode: "absolute-height", offset: 0 };
    const r15 = e2(t13.geometry).spatialReference;
    i10.add([this._moveManipulation.createDragPipeline((i11, o12, n13, r16, s10) => {
      const l13 = n13.next((e12) => this._trackNumDragging(e12)).next((e12) => {
        const t14 = this._manipulatorInfos.filter((e13) => "vertex" === e13.type && e13.manipulator.selected);
        return e12.manipulatorType === A4.TRANSLATE_XY && 1 === t14.length ? { ...e12, info: t14[0], snapOrigin: t14[0].handle.pos } : { ...e12, info: null };
      }).next(this._snappingPipelineHandle.createSnapDragEventPipelineStep({ predicate: (e12) => !!e12.info, cancel: r16, snappingManager: a15.snappingManager, snappingContext: new e7({ editGeometryOperations: e2(this._editGeometryOperations), elevationInfo: e11, pointer: s10, excludeFeature: t13, visualizer: new g3() }), updatingHandles: this.updatingHandles }), this._snappingPipelineHandle.next).next(D2()).next((e12) => this._perGraphicManipulatorDragAction(je.SELECTED_OR_ALL, e12)).next((e12) => (this._updateTranslateTooltip(i11, e12), e12));
      return r16.next(this._cancelDragOperation()), l13;
    }, e11, r15, t13), l3(() => n12 == null ? void 0 : n12.displaying, () => {
      this._updateMoveManipulationPosition();
    }, h), n12.on("changed", () => this._updateMoveManipulationPosition()), l3(() => n12 == null ? void 0 : n12.isDraped, (e12) => {
      const t14 = "align-move-manipulation";
      e12 ? i10.add(this.view.elevationProvider.on("elevation-change", () => this._updateMoveManipulationPosition()), t14) : i10.remove(t14);
    }, h)]), this._updateMoveManipulationPosition();
    const l12 = i5({ view: o11, graphic: t13, forEachManipulator: (e12) => {
      if (!this.destroyed) {
        r(this._graphicMoveManipulation) && this._graphicMoveManipulation.forEachManipulator(e12);
        for (const t14 of this._manipulatorInfos)
          e12(t14.manipulator, A4.TRANSLATE_XY);
        this._moveManipulation.forEachManipulator(e12);
      }
    }, onManipulatorsChanged: (e12) => this.on("manipulators-changed", e12) });
    r(l12) && (this._outlineVisualElement = l12.visualElement instanceof S3 ? l12.visualElement : null), r(this._outlineVisualElement) && this._manipulatorHandles.add([this._outlineVisualElement.events.on("attachment-origin-changed", () => {
      n12.isDraped || this._updateMoveManipulationPosition();
    }), l3(() => n12.isDraped, () => this._updateMoveManipulationPosition())]), this._manipulatorHandles.add(l12);
  }
  _createEdgeOffsetManipulator(e11, t13 = u4(this.graphic)) {
    const i10 = y3.reshapeManipulators.edgeOffset, a15 = i10.size / 2, n12 = a15 + i10.collisionPadding;
    if (t(this._edgeOffsetManipulatorGeometryInside) || t(this._edgeOffsetManipulatorGeometryOutside)) {
      const e12 = a15 / n12, t14 = e12 * Math.sqrt(3) / 2;
      this._edgeOffsetManipulatorGeometryInside = T3.createExtrudedTriangle(t14, e12 / 2, e12 / 2, i10.height, i10.offset), this._edgeOffsetManipulatorGeometryOutside = T3.createExtrudedTriangle(-t14, e12 / 2, e12 / 2, i10.height, -i10.offset);
    }
    const r15 = [{ geometry: this._edgeOffsetManipulatorGeometryInside, material: this._edgeOffsetManipulatorMaterial, stateMask: t8.Unfocused }, { geometry: this._edgeOffsetManipulatorGeometryInside, material: this._edgeOffsetManipulatorHoverMaterial, stateMask: t8.Focused }, { geometry: this._edgeOffsetManipulatorGeometryOutside, material: this._edgeOffsetManipulatorMaterial, stateMask: t8.Unfocused }, { geometry: this._edgeOffsetManipulatorGeometryOutside, material: this._edgeOffsetManipulatorHoverMaterial, stateMask: t8.Focused }], p11 = new te({ view: this.view, renderObjects: r15, elevationInfo: "on-the-ground" !== t13.mode || d5(this.graphic.symbol) ? { mode: "absolute-height", offset: 0 } : t13, worldOriented: false, focusMultiplier: 1, radius: n12, available: !(!this.graphic.visible || !this.graphic.layer.visible), collisionType: { type: "disc", direction: r3(0, 0, 1) }, collisionPriority: 1 }), h10 = new te({ view: this.view, renderObjects: [], worldSized: true, worldOriented: false, available: !(!this.graphic.visible || !this.graphic.layer.visible), collisionPriority: -10, cursor: this.enableMoveGraphic ? "move" : "default" }), d14 = { manipulator: p11, handle: e11, locationUpdateHandle: null, type: "edge", selectedIndex: 0, edgeManipulator: h10, elevationInfo: t13, visibilityHandle: null };
    this._autoHideEdgeOffsetManipulator(d14, i10.minSquaredEdgeLength), this._updateEdgeOffsetManipulator(d14);
    const u7 = this._getManipulatorInfoFromHandle(d14.handle.leftVertex).manipulator.events.on("location-update", () => this._updateEdgeOffsetManipulator(d14)), c10 = this._getManipulatorInfoFromHandle(d14.handle.rightVertex).manipulator.events.on("location-update", () => this._updateEdgeOffsetManipulator(d14));
    d14.locationUpdateHandle = r2([u7, c10]), this._manipulatorHandles.add(d14.locationUpdateHandle, p11), this._manipulatorHandles.add([this._watchAndUpdateGrabState(p11, true), this._watchAndUpdateGrabState(h10, true)], p11), this._manipulatorHandles.add(p4(p11, this._createEdgeOffsetPipeline(d14, t13)), p11), this._manipulatorHandles.add(p4(h10, (e12, i11, a16, o11) => {
      if ("touch" === o11) {
        this._createEdgeOffsetPipeline(d14, t13)(e12, i11, a16);
      } else if (this.enableMoveGraphic) {
        const o12 = this.graphic, n13 = r(o12.geometry) ? o12.geometry.spatialReference : null;
        i11.next((e13) => this._trackNumDragging(e13)).next(C(this.view, e12.elevationAlignedLocation)).next(N(this.view, e12.elevationAlignedLocation, t13, n13, o12)).next(b3()).next(D2()).next((e13) => this._perGraphicManipulatorDragAction(je.ALL, e13)).next((e13) => (this._updateTranslateGraphicTooltip(d11.XY, e13), e13)).next((e13) => {
          "end" === e13.action && this._tooltip.clear();
        }), a16.next(this._cancelDragOperation());
      }
    }), p11);
    const m15 = (e12) => {
      this._manipulatorInfos.some((e13) => e13.manipulator.selected) ? this._clearSelection() : this.emit("immediate-click", { ...e12, graphic: this.graphic }), e12.stopPropagation();
    };
    return this._manipulatorHandles.add([p11.events.on("immediate-click", m15), h10.events.on("immediate-click", m15), p11.events.on("focus-changed", ({ action: e12 }) => {
      const t14 = this._tooltipOptions;
      "focus" === e12 && t14.enabled ? this._tooltip.info = new p8({ tooltipOptions: t14 }) : this._tooltip.clear();
    })], p11), this._manipulatorInfos.push(d14), this.manipulators.add(p11), this.manipulators.add(h10), this.emit("manipulators-changed"), d14;
  }
  _autoHideEdgeOffsetManipulator(e11, t13) {
    const i10 = e11.manipulator, a15 = e11.edgeManipulator, n12 = () => {
      a2(e11.visibilityHandle);
      const n13 = R4(this._getManipulatorInfoFromHandle(e11.handle.leftVertex).manipulator.renderLocation, this._getManipulatorInfoFromHandle(e11.handle.rightVertex).manipulator.renderLocation, this.view.state.camera) < t13;
      (!i10.focused && !a15.focused || n13) && (i10.grabbable = !n13, a15.grabbable = !n13, e11.visibilityHandle = r2([i10.disableDisplay(), { remove: () => {
        i10.grabbable = true, a15.grabbable = this.enableMoveGraphic;
      } }]));
    };
    this._manipulatorHandles.add([i10.events.on("focus-changed", n12), a15.events.on("focus-changed", n12), { remove: () => {
      a2(e11.visibilityHandle), this.manipulators.remove(a15);
    } }], i10), n12();
  }
  _updateEdgeOffsetManipulator(e11) {
    this._updateManipulatorPosition(e11);
    const t13 = e2(this._editGeometryOperations).data.coordinateHelper, i10 = h9(this.view, e11.manipulator.elevationAlignedLocation, j7(t13, e11.handle, e2(e11.manipulator.elevationInfo))), a15 = this._getManipulatorInfoFromHandle(e11.handle.leftVertex).manipulator.renderLocation, o11 = this._getManipulatorInfoFromHandle(e11.handle.rightVertex).manipulator.renderLocation, n12 = r(i10) ? C6(i10, a15, o11) : o6;
    e11.manipulator.modelTransform = n12, e11.edgeManipulator.elevationAlignedLocation = e11.manipulator.elevationAlignedLocation, e11.edgeManipulator.modelTransform = n12;
    const r15 = s(e3(Te, a15, o11)) / 2;
    e11.edgeManipulator.collisionType = { type: "line", paths: [[[-r15, 0, 0], [r15, 0, 0]]] };
  }
  _createEdgeOffsetPipeline(e11, t13) {
    return (i10, a15, o11) => {
      this._clearSelection();
      const { step: n12, cleanup: r15 } = this._initializeEdgeOffset(e11, t13);
      a15.next((e12) => this._trackNumDragging(e12)).next(C(this.view, i10.elevationAlignedLocation)).next(n12).next(T4(this.view)).next(F3(this.view, e2(this._editGeometryOperations).data.spatialReference)).next(D2()).next(this._applyComputeEdgeOffsetDistanceStep()).next(this._applyEdgeOffsetStep(e11)).next(this._showEdgeOffsetTooltip()).next((e12) => {
        "end" === e12.action && r15();
      }), o11.next((e12) => (r15(), e12)).next((e12) => (this._tooltip.clear(), e12)).next(this._cancelDragOperation());
    };
  }
  _initializeEdgeOffset(e11, t13) {
    const i10 = e2(this._editGeometryOperations), a15 = j7(i10.data.coordinateHelper, e11.handle, t13), r15 = i10.createUndoGroup(), s10 = h9(this.view, e11.manipulator.elevationAlignedLocation, a15);
    a15.requiresSplitEdgeLeft && this._splitEdgeManipulator(this._getManipulatorInfoFromHandle(e11.handle.leftVertex.leftEdge), 1), a15.requiresSplitEdgeRight && this._splitEdgeManipulator(this._getManipulatorInfoFromHandle(e11.handle.rightVertex.rightEdge), 0);
    const d14 = () => new m({ paths: [[e11.handle.leftVertex.pos, e11.handle.rightVertex.pos]], spatialReference: e2(this._editGeometryOperations).data.spatialReference }), u7 = new S3({ view: this.view, isDraped: this._graphicState.isDraped, geometry: d14(), elevationInfo: e11.elevationInfo, width: y3.visualElements.lineGraphics.outline.width, color: y3.colorToVec4(r10.main), attached: true });
    let m15;
    const g6 = () => {
      this._cleanEdgeOffsetCollapsedEdges(e11), m15 = a2(m15);
    }, _7 = this.on("undo", g6);
    return m15 = r2([t2(u7), l3(() => this._graphicState.isDraped, (e12) => u7.isDraped = e12), this._graphicState.on("changed", () => u7.geometry = d14()), r15, _7]), { step: (e12) => t(a15) || t(s10) ? (g6(), null) : { ...e12, operation: a15, plane: s10 }, cleanup: g6 };
  }
  _applyEdgeOffsetStep(e11) {
    return (t13) => {
      if (this.destroyed || t(t13.operation))
        return t13;
      this._updateEventState(Pe.RESHAPING);
      const { mapDeltaX: i10, mapDeltaY: a15, mapDeltaZ: o11 } = t13;
      return (i10 || a15 || o11) && (this._offsetEdge(e11, t13), this.emit("reshape", { type: "reshape", mover: this.graphic })), t13;
    };
  }
  _applyComputeEdgeOffsetDistanceStep() {
    return (e11) => {
      const { operation: t13, mapEnd: i10 } = e11;
      if (t(t13) || t(i10))
        return e11;
      const a15 = t13.signedDistanceToPoint(i10);
      return { ...e11, signedDistance: a15 };
    };
  }
  _showEdgeOffsetTooltip() {
    return (e11) => {
      const { mapEnd: t13, signedDistance: i10, operation: a15 } = e11, o11 = this._tooltip, n12 = this._tooltipOptions;
      if (!n12.enabled || t(i10))
        return o11.clear(), e11;
      const r15 = Ae(this._graphicState.isDraped, -i10, t13, a15.plane, e2(this._editGeometryOperations).data.coordinateHelper);
      return t(o11.info) || "reshape-edge-offset" !== o11.info.type ? o11.info = new p8({ tooltipOptions: n12, distance: r15 }) : o11.info.distance = r15, e11;
    };
  }
  _cleanEdgeOffsetCollapsedEdges(e11) {
    var _a, _b;
    const t13 = (_a = e11.handle.leftVertex.leftEdge) == null ? void 0 : _a.leftVertex, i10 = e11.handle.leftVertex, a15 = (_b = e11.handle.rightVertex.rightEdge) == null ? void 0 : _b.rightVertex, o11 = e11.handle.rightVertex, n12 = e2(this._editGeometryOperations).data.coordinateHelper, r15 = 1e-6, s10 = [];
    t13 && n12.distance(t13.pos, i10.pos) < r15 && s10.push(this._getManipulatorInfoFromHandle(i10)), (n12.distance(i10.pos, o11.pos) < r15 || a15 && n12.distance(a15.pos, o11.pos) < r15) && s10.push(this._getManipulatorInfoFromHandle(o11)), s10.length && this._removeVertices(s10);
  }
  _computeVertexManipulatorSizeAndOutline(e11) {
    const t13 = e11.size / 2, i10 = t13 + e11.collisionPadding;
    return { size: t13 / i10, outlineSize: (t13 + e11.outlineSize) / i10 };
  }
  _createVertexOrEdgeManipulator(e11, t13 = u4(this.graphic)) {
    if ("edge" === e11.type) {
      if (this.enableEdgeOffset)
        return this._createEdgeOffsetManipulator(e11, t13);
      if (!this.enableMidpoints)
        return null;
    }
    if (t(this._vertexManipulatorGeometry) || t(this._vertexManipulatorOutlineGeometry)) {
      const { size: e12, outlineSize: t14 } = this._computeVertexManipulatorSizeAndOutline(y3.reshapeManipulators.vertex);
      this._vertexManipulatorGeometry = T3.createSphereGeometry(e12, 16, 16), this._vertexManipulatorOutlineGeometry = T3.createSphereGeometry(t14, 16, 16);
    }
    if (t(this._edgeManipulatorGeometry) || t(this._edgeManipulatorOutlineGeometry)) {
      const { size: e12, outlineSize: t14 } = this._computeVertexManipulatorSizeAndOutline(y3.reshapeManipulators.edge);
      this._edgeManipulatorGeometry = T3.createSphereGeometry(e12, 16, 16), this._edgeManipulatorOutlineGeometry = T3.createSphereGeometry(t14, 16, 16);
    }
    const i10 = r(this.graphic.geometry) && "point" === this.graphic.geometry.type ? [] : [{ geometry: this._vertexManipulatorGeometry, material: this._vertexManipulatorMaterial, stateMask: Le.Vertex | t8.Unselected }, { geometry: this._vertexManipulatorOutlineGeometry, material: this._vertexManipulatorOutlineMaterial, stateMask: Le.Vertex | t8.Unfocused | t8.Unselected }, { geometry: this._vertexManipulatorOutlineGeometry, material: this._vertexManipulatorHoverOutlineMaterial, stateMask: Le.Vertex | t8.Focused | t8.Unselected }, { geometry: this._vertexManipulatorGeometry, material: this._selectedManipulatorMaterial, stateMask: t8.Selected }, { geometry: this._vertexManipulatorOutlineGeometry, material: this._selectedManipulatorOutlineMaterial, stateMask: t8.Selected | t8.Unfocused }, { geometry: this._vertexManipulatorOutlineGeometry, material: this._selectedManipulatorHoverOutlineMaterial, stateMask: t8.Selected | t8.Focused }];
    this.enableMidpoints && i10.push({ geometry: this._edgeManipulatorGeometry, material: this._vertexManipulatorMaterial, stateMask: Le.Edge | t8.Focused | t8.Unselected }, { geometry: this._edgeManipulatorOutlineGeometry, material: this._vertexManipulatorHoverOutlineMaterial, stateMask: Le.Edge | t8.Focused | t8.Unselected }, { geometry: this._edgeManipulatorGeometry, material: this._edgeManipulatorMaterial, stateMask: Le.Edge | t8.Unfocused | t8.Unselected }, { geometry: this._edgeManipulatorOutlineGeometry, material: this._edgeManipulatorOutlineMaterial, stateMask: Le.Edge | t8.Unfocused | t8.Unselected });
    const a15 = new te({ view: this.view, renderObjects: i10, elevationInfo: t13, focusMultiplier: 1, touchMultiplier: 1, available: !(!this.graphic.visible || !this.graphic.layer.visible) });
    this._setTypeSpecificManipulatorSettings(a15, e11, t13);
    const n12 = "edge" === e11.type ? { manipulator: a15, handle: e11, locationUpdateHandle: null, type: "edge", selectedIndex: 0 } : { manipulator: a15, handle: e11, type: "vertex", selectedIndex: 0 };
    if (this._manipulatorInfos.push(n12), this.manipulators.add(a15), this._updateManipulatorPosition(n12), "edge" === n12.type) {
      const e12 = this._getManipulatorInfoFromHandle(n12.handle.leftVertex).manipulator.events.on("location-update", () => this._updateManipulatorPosition(n12)), t14 = this._getManipulatorInfoFromHandle(n12.handle.rightVertex).manipulator.events.on("location-update", () => this._updateManipulatorPosition(n12));
      n12.locationUpdateHandle = r2([e12, t14]), this._manipulatorHandles.add(n12.locationUpdateHandle, a15);
    }
    this._manipulatorHandles.add(this._watchAndUpdateGrabState(a15, true), a15);
    const r15 = p4(a15, (e12, i11, a16, o11) => {
      let r16 = null;
      i11.next((e13) => this._trackNumDragging(e13)).next((e13) => {
        if ("start" === e13.action && (r16 = e2(this._editGeometryOperations).createUndoGroup()), "edge" === n12.type) {
          const t14 = this._splitEdgeManipulator(n12);
          return { ...e13, info: t14, snapOrigin: t14.handle.pos };
        }
        return { ...e13, info: n12, snapOrigin: n12.handle.pos };
      }).next(C(this.view, e12.elevationAlignedLocation)).next(P2(this.view, this.graphic, e12.elevationAlignedLocation, e12.location.spatialReference, this.graphic)).next(this._snappingPipeline.createSnapDragEventPipelineStep({ predicate: () => !this._isMultiVertexSelection(), cancel: a16, snappingManager: this.tool.snappingManager, snappingContext: new e7({ editGeometryOperations: e2(this._editGeometryOperations), elevationInfo: t13, pointer: o11, excludeFeature: this.graphic, visualizer: new g3() }), updatingHandles: this.updatingHandles }), this._snappingPipeline.next).next(D2()).next((t14) => {
        this._perVertexManipulatorDragAction(t14), "end" === t14.action && (r16 = a2(r16)), this._updateTranslateVertexTooltip(e12, d11.XY, t14);
      }), a16.next(this._cancelDragOperation(() => r16 = a2(r16)));
    });
    return this._manipulatorHandles.add([r15, a15.events.on("immediate-click", (e12) => this._manipulatorClickCallback(e12, n12)), a15.events.on("select-changed", () => {
      n12.selectedIndex = ++this._selectedIndex, this._updateMoveManipulationPosition();
    }), a15.events.on("focus-changed", ({ action: e12 }) => {
      "focus" === e12 && "edge" !== n12.type ? this._updateTranslateVertexTooltip(a15, d11.XY) : this._tooltip.clear();
    })], a15), this.emit("manipulators-changed"), n12;
  }
  _trackNumDragging(e11) {
    switch (e11.action) {
      case "start":
        this._numDragging++;
        break;
      case "end":
        this._numDragging--;
    }
    return e11;
  }
  _cancelDragOperation(e11) {
    return () => {
      switch (this._numDragging--, this.undo(), this.outputGeometry = r(this._editGeometryOperations) ? this._editGeometryOperations.data.geometry : null, r(this.tool.snappingManager) && this.tool.snappingManager.doneSnapping(), this._tooltip.clear(), this._reshapeEventState) {
        case Pe.NONE:
          break;
        case Pe.MOVING:
          this.emit("move", { type: "move", dx: 0, dy: 0, mover: this.graphic });
          break;
        case Pe.RESHAPING:
          this.emit("reshape", { type: "reshape", mover: this.graphic });
      }
      e11 && e11(), this.destroyed || this._updateEventState(Pe.NONE);
    };
  }
  _setTypeSpecificManipulatorSettings(e11, t13, i10) {
    switch (t13.type) {
      case "vertex":
        e11.state = Le.Vertex, e11.selectable = true, e11.cursor = "move", e11.collisionPriority = 2, e11.radius = y3.reshapeManipulators.vertex.size / 2 + y3.reshapeManipulators.vertex.collisionPadding, e11.elevationInfo = i10, e11.interactive = r(this.graphic.geometry) && "point" !== this.graphic.geometry.type;
        break;
      case "edge":
        e11.state = Le.Edge, e11.selectable = false, e11.cursor = "copy", e11.collisionPriority = -1, e11.radius = y3.reshapeManipulators.edge.size / 2 + y3.reshapeManipulators.edge.collisionPadding, e11.elevationInfo = "on-the-ground" !== i10.mode || d5(this.graphic.symbol) ? { mode: "absolute-height", offset: 0 } : i10;
    }
  }
  _watchAndUpdateGrabState(e11, t13) {
    return e11.events.on("grab-changed", (i10) => this._onGrabStateChanged(e11, t13, i10.action, i10.pointerType));
  }
  _onGrabStateChanged(e11, t13, i10, a15 = "mouse") {
    if ("start" === i10)
      t13 && this._updateSelection(e11), this._numGrabbing++;
    else if (this._numGrabbing--, this._updateEventState(Pe.NONE), this.destroyed)
      return;
    this._moveManipulation.interactive = !this._numGrabbing, ("touch" !== a15 || this.enableEdgeOffset) && (this._manipulatorInfos.forEach((e12) => {
      e12.manipulator.interactive = !this._numGrabbing && r(this.graphic.geometry) && "point" !== this.graphic.geometry.type, "edgeManipulator" in e12 && (e12.edgeManipulator.interactive = !this._numGrabbing);
    }), e2(this._graphicMoveManipulation).forEachManipulator((e12) => e12.interactive = !this._numGrabbing));
  }
  _clearSelection() {
    for (const e11 of this._manipulatorInfos)
      e11.manipulator.grabbing || (e11.manipulator.selected = false);
  }
  _updateSelection(e11) {
    e11.grabbing && !e11.selected && e11.selectable && (this._clearSelection(), e11.selected = true, this.emit("manipulators-changed"));
  }
  _removeManipulator(e11) {
    e11 && (e11.manipulator.grabbing && this._onGrabStateChanged(e11.manipulator, false, "end"), this._manipulatorHandles.remove(e11.manipulator), this._manipulatorInfos.splice(this._manipulatorInfos.indexOf(e11), 1), this.manipulators.remove(e11.manipulator), this.emit("manipulators-changed"));
  }
  _getManipulatorInfoFromHandle(e11) {
    if (e11) {
      for (const t13 of this._manipulatorInfos)
        if (e11 === t13.handle)
          return t13;
    }
    return null;
  }
  _updateManipulatorPosition(e11) {
    if (!e11)
      return;
    const t13 = e2(this._editGeometryOperations);
    if ("vertex" === e11.type)
      e11.manipulator.location = t13.data.coordinateHelper.vectorToDehydratedPoint(e11.handle.pos, De), e11.manipulator.grabbing && r(this._vertexLaserLineVisualElement) && (this._vertexLaserLineVisualElement.visualElement.intersectsWorldUpAtLocation = e11.manipulator.renderLocation);
    else if ("edge" === e11.type) {
      const i10 = this._getManipulatorInfoFromHandle(e11.handle.leftVertex).manipulator, a15 = this._getManipulatorInfoFromHandle(e11.handle.rightVertex).manipulator;
      if (r(e11.manipulator.elevationInfo) && "on-the-ground" === e11.manipulator.elevationInfo.mode) {
        const o11 = i10.location, n12 = a15.location, r15 = 0.5, s10 = o11.x + r15 * (n12.x - o11.x), l12 = o11.y + r15 * (n12.y - o11.y), p11 = o11.hasZ && n12.hasZ ? 0 : void 0;
        e11.manipulator.location = v4(s10, l12, p11, t13.data.spatialReference);
      } else
        A2(Te, i10.renderLocation, a15.renderLocation, 0.5), e11.manipulator.renderLocation = Te;
    }
  }
  _splitEdgeManipulator(e11, t13 = 0.5) {
    const i10 = e2(this._editGeometryOperations), a15 = e2(i10.splitEdge(e11.handle, t13).createdVertex);
    e11.locationUpdateHandle.remove(), e11.locationUpdateHandle = void 0;
    const o11 = u4(this.graphic);
    let n12;
    this.enableEdgeOffset ? (this._removeManipulator(e11), n12 = this._createVertexOrEdgeManipulator(a15)) : (n12 = e11, n12.handle = a15, n12.type = "vertex", this._setTypeSpecificManipulatorSettings(e11.manipulator, e11.handle, o11)), a15.leftEdge && this._createVertexOrEdgeManipulator(a15.leftEdge), a15.rightEdge && this._createVertexOrEdgeManipulator(a15.rightEdge), this.outputGeometry = i10.data.geometry, this._updateManipulatorPosition(n12), this.enableEdgeOffset || this._updateTranslateVertexTooltip(n12.manipulator, d11.XY), this._updateSelection(e11.manipulator);
    const r15 = this._updateEventState(Pe.RESHAPING), s10 = i10.data.coordinateHelper.vectorToArray(n12.handle.pos), l12 = i10.data.components.indexOf(a15.component);
    return this.emit("vertex-add", { type: "vertex-add", vertices: [{ coordinates: s10, componentIndex: l12, vertexIndex: e2(a15.index) }], added: s10 }), r15 && this._updateEventState(Pe.NONE), n12;
  }
  _updateMoveManipulationPosition() {
    const e11 = o3(Te, 0, 0, 0);
    let t13 = 0, i10 = false, a15 = null, o11 = null;
    for (const n12 of this._manipulatorInfos)
      "vertex" === n12.type && (n12.manipulator.selected ? (t13++, u(e11, e11, n12.manipulator.renderLocation), t(a15) || n12.selectedIndex > a15.selectedIndex ? (o11 = a15, a15 = n12) : (t(o11) || n12.selectedIndex > o11.selectedIndex) && (o11 = n12)) : i10 = true);
    if (0 !== t13) {
      const e12 = this._graphicState.displaying;
      this._moveManipulation.xyManipulation.available = e12, this._moveManipulation.xyAxisManipulation.available = e12, this._moveManipulation.zManipulation.available = e12 && this.enableZVertex && t10(this.graphic), this._moveManipulation.xyAxisManipulation.orthogonalAvailable = e12 && 1 !== t13;
    } else {
      const e12 = this._graphicState.displaying && this.enableMoveGraphic;
      this._moveManipulation.xyManipulation.available = e12, this._moveManipulation.xyAxisManipulation.available = e12, this._moveManipulation.xyAxisManipulation.orthogonalAvailable = e12, this._moveManipulation.zManipulation.available = e12 && this.enableZShape && t10(this.graphic);
    }
    if (0 !== t13) {
      let e12 = 0;
      if (r(a15)) {
        const t14 = a15.handle.pos, i11 = r(o11) ? o11.handle.pos : a15.handle.leftEdge && a15.handle.leftEdge.leftVertex ? a15.handle.leftEdge.leftVertex.pos : null, n12 = t(o11) && a15.handle.rightEdge && a15.handle.rightEdge.rightVertex ? a15.handle.rightEdge.rightVertex.pos : null;
        i11 && n12 ? this._moveManipulation.xyAxisManipulation.available = false : i11 ? e12 = we(i11, t14) : n12 && (e12 = we(t14, n12));
      }
      this._moveManipulation.angle = e12, this._moveManipulation.radius = I;
    } else
      this._moveManipulation.angleDeferred = () => a12(e2(this.graphic.geometry)), this._moveManipulation.radius = c9.radiusForSymbol(this.graphic.symbol);
    0 !== t13 && i10 ? (q(e11, e11, 1 / t13), De.spatialReference = e2(this._editGeometryOperations).data.spatialReference, De.hasZ = true, this.view.renderCoordsHelper.fromRenderCoords(e11, De), this._moveManipulation.elevationAlignedLocation = De) : r(this._outlineVisualElement) && !this._graphicState.isDraped && r(this._outlineVisualElement.attachmentOrigin) ? this._moveManipulation.elevationAlignedLocation = this._outlineVisualElement.attachmentOrigin : v6(this.view, this._moveManipulation, this.graphic);
  }
  _removeVertices(e11) {
    const t13 = [], i10 = e2(this._editGeometryOperations);
    for (const a15 of e11)
      if ("vertex" === a15.type && i10.canRemoveVertex()) {
        t13.push(a15.handle), this._removeManipulator(a15), this._removeManipulator(this._getManipulatorInfoFromHandle(a15.handle.leftEdge)), this._removeManipulator(this._getManipulatorInfoFromHandle(a15.handle.rightEdge));
        const e12 = e2(i10.removeVertices([a15.handle]).removedVertices[0].createdEdge);
        e12 && this._createVertexOrEdgeManipulator(e12);
      }
    if (t13.length > 0) {
      const e12 = t13.map((e13) => {
        const t14 = i10.data.components.indexOf(e13.component);
        return { coordinates: i10.data.coordinateHelper.vectorToArray(e13.pos), componentIndex: t14, vertexIndex: e2(e13.index) };
      });
      this.outputGeometry = i10.data.geometry;
      const a15 = this._updateEventState(Pe.RESHAPING);
      if (this.destroyed)
        return;
      if (this.emit("vertex-remove", { type: "vertex-remove", removed: e12.map((e13) => e13.coordinates), vertices: e12 }), this.destroyed)
        return;
      if (a15 && (this._updateEventState(Pe.NONE), this.destroyed))
        return;
      this._updateMoveManipulationPosition();
    }
  }
  _moveVertices(e11, t13, i10 = "start" === t13.action ? E.NEW_STEP : E.ACCUMULATE_STEPS) {
    const a15 = e2(this._editGeometryOperations);
    a15.moveVertices(e11.map((e12) => e12.handle), t13.mapDeltaX, t13.mapDeltaY, t13.mapDeltaZ, i10), this.outputGeometry = a15.data.geometry;
    for (const o11 of e11)
      this._updateManipulatorPosition(o11);
  }
  _offsetEdge(e11, t13) {
    if (t(t13.operation) || t(t13.signedDistance))
      return;
    const i10 = e2(this._editGeometryOperations), a15 = t13.operation.clone();
    a15.distance = t13.signedDistance, i10.updateVertices([e11.handle.leftVertex, e11.handle.rightVertex], a15), this.outputGeometry = i10.data.geometry, this._updateManipulatorPosition(this._getManipulatorInfoFromHandle(e11.handle.leftVertex)), this._updateManipulatorPosition(this._getManipulatorInfoFromHandle(e11.handle.rightVertex));
  }
  _manipulatorClickCallback(e11, t13) {
    e11.shiftKey || this._clearSelection(), "vertex" === t13.type && (t13.manipulator.selected = !t13.manipulator.selected, e11.button === t9.Right && this._removeVertices([t13])), "edge" === t13.type && e11.button === t9.Left && this._splitEdgeManipulator(t13), e11.stopPropagation();
  }
  _updateTranslateTooltip(e11, t13) {
    const i10 = this._manipulatorInfos.filter((e12) => "vertex" === e12.type && e12.manipulator.selected);
    1 === i10.length ? this._updateTranslateVertexTooltip(i10[0].manipulator, e11, t13) : this._updateTranslateGraphicTooltip(e11, t13);
  }
  _updateTranslateGraphicTooltip(e11, t13) {
    const i10 = this._tooltipOptions;
    if (!i10.enabled)
      return;
    const a15 = e11 === d11.Z, o11 = a15 ? new p7({ tooltipOptions: i10 }) : new i7({ tooltipOptions: i10 });
    if (r(t13) && "end" !== t13.action) {
      const { mapStart: e12, mapEnd: i11 } = t13, n12 = a15 ? d8(e12, i11) : d9(e12, i11, this._graphicState.isDraped ? "on-the-ground" : "absolute-height");
      o11.distance = r(n12) ? n12 : y2;
    }
    this._tooltip.info = o11;
  }
  _updateTranslateVertexTooltip(e11, t13, i10) {
    const a15 = this._tooltipOptions;
    if (!a15.enabled)
      return;
    const o11 = t13 === d11.Z, n12 = new a14({ tooltipOptions: a15 });
    if (r(i10) && "end" !== i10.action) {
      const { mapStart: e12, mapEnd: t14 } = i10, a16 = o11 ? d8(e12, t14) : d9(e12, t14, this._graphicState.isDraped ? "on-the-ground" : "absolute-height");
      n12.distance = r(a16) ? a16 : y2;
    }
    const r15 = v5(e11.elevationAlignedLocation);
    r(r15) && (n12.elevation = { mode: "absolute-height", ...r15 });
    const { geometry: l12 } = this.graphic;
    r(l12) && !o11 && (n12.area = "polygon" === l12.type ? m5(l12, this._graphicState.isDraped) : null, n12.totalLength = "polyline" === l12.type ? m6(l12, this._graphicState.isDraped ? "on-the-ground" : "absolute-height") : null), this._tooltip.info = n12;
  }
  get test() {
    return { segmentLabels: this._segmentLabels, tooltip: this._tooltip };
  }
};
function we(e11, t13) {
  return Math.atan2(t13[1] - e11[1], t13[0] - e11[0]) + Math.PI / 2;
}
function Ae(e11, t13, i10, a15, o11) {
  if (e11) {
    const e12 = o11.toXYZ(o11.pointToVector(i10)), n12 = J(a15, e12, c3.get()), r15 = l7(n12, e12, o11.spatialReference);
    if (r(r15))
      return o7(r15.value * Math.sign(t13), r15.unit);
  }
  return o7(t13 * z(i10.spatialReference), "meters");
}
e([d()], He.prototype, "_segmentLabels", void 0), e([d({ constructOnly: true })], He.prototype, "tool", void 0), e([d()], He.prototype, "_tooltip", void 0), e([d()], He.prototype, "inputGeometry", null), e([d()], He.prototype, "outputGeometry", void 0), e([d({ readOnly: true })], He.prototype, "updating", null), e([d()], He.prototype, "manipulators", null), e([d()], He.prototype, "view", null), e([d()], He.prototype, "graphic", null), e([d()], He.prototype, "enableZShape", null), e([d()], He.prototype, "enableZVertex", null), e([d()], He.prototype, "enableMoveGraphic", null), e([d()], He.prototype, "enableMidpoints", null), e([d()], He.prototype, "enableEdgeOffset", null), e([d()], He.prototype, "_labelOptions", null), e([d()], He.prototype, "_tooltipOptions", null), He = e([n3("esri.views.3d.interactive.editingTools.reshapeGraphic.ReshapeOperation")], He);
var De = v4(0, 0, null, null);
var Te = n4();
var Le;
var Pe;
var je;
!function(e11) {
  e11.Vertex = u5.Custom1, e11.Edge = u5.Custom2;
}(Le || (Le = {})), function(e11) {
  e11[e11.NONE = 0] = "NONE", e11[e11.MOVING = 1] = "MOVING", e11[e11.RESHAPING = 2] = "RESHAPING";
}(Pe || (Pe = {})), function(e11) {
  e11[e11.ALL = 0] = "ALL", e11[e11.SELECTED_OR_ALL = 1] = "SELECTED_OR_ALL";
}(je || (je = {}));

// node_modules/@arcgis/core/views/3d/interactive/editingTools/reshapeGraphic/GraphicReshapeTool.js
var v9 = class extends n5.EventedMixin(c7) {
  constructor(e11) {
    super(e11), this._handles = new u2(), this._internalGeometryUpdate = false, this.enableZShape = true, this.enableZVertex = true, this.enableMoveGraphic = true, this.enableMidpoints = true, this.enableEdgeOffset = false, this.type = "reshape-3d", this.labelOptions = new c6(), this.tooltipOptions = new r8(), this.snappingManager = null, this.automaticManipulatorSelection = false;
  }
  initialize() {
    const e11 = this._reshapeOperation = new He({ tool: this });
    this.own([e11.on("reshape", (e12) => {
      "reshape" === e12.type && this._onReshapeGeometryChanged(), this.emit("reshape", e12);
    }), e11.on("move", (e12) => {
      "move" === e12.type && this._onReshapeGeometryChanged(), this.emit("move", e12);
    }), e11.on("vertex-add", (e12) => {
      this._onReshapeGeometryChanged(), this.emit("vertex-add", e12);
    }), e11.on("vertex-remove", (e12) => {
      this._onReshapeGeometryChanged(), this.emit("vertex-remove", e12);
    }), e11.on("immediate-click", (e12) => this.emit("immediate-click", e12)), this.view.on("pointer-down", ["Shift"], (e12) => {
      e12.stopPropagation();
    }), l3(() => this.graphic, () => this._updateGraphic(), w)]), this.finishToolCreation();
  }
  destroy() {
    this._handles = l(this._handles), this._reshapeOperation = l(this._reshapeOperation);
  }
  get updating() {
    var _a;
    return ((_a = this._reshapeOperation) == null ? void 0 : _a.updating) ?? false;
  }
  _updateGeometry() {
    const e11 = m10(this.graphic);
    this._reshapeOperation.inputGeometry = r(e11) ? e11.clone() : null;
  }
  _updateGraphic() {
    if (this._handles.remove("onGraphicGeometryChange"), this._updateGeometry(), l9(this.graphic) !== P3.SUPPORTED)
      return;
    const e11 = l3(() => {
      var _a;
      return (_a = this.graphic) == null ? void 0 : _a.geometry;
    }, () => {
      false === this._internalGeometryUpdate && this._updateGeometry();
    }, U2);
    this._handles.add(e11, "onGraphicGeometryChange");
  }
  manipulatorSelectionChanged() {
    this._reshapeOperation && this._reshapeOperation.manipulatorSelectionChanged();
  }
  _updateGeometryInternally(e11) {
    this._internalGeometryUpdate = true, this.graphic.geometry = e11, this._internalGeometryUpdate = false;
  }
  _onReshapeGeometryChanged() {
    t(this.graphic) || this._updateGeometryInternally(this._reshapeOperation.outputGeometry.clone());
  }
  get canUndo() {
    return this._reshapeOperation.canUndo ?? false;
  }
  undo() {
    r(this.snappingManager) && this.snappingManager.doneSnapping(), r(this._reshapeOperation.undo()) && this._updateGeometryInternally(this._reshapeOperation.outputGeometry.clone());
  }
  get canRedo() {
    return this._reshapeOperation.canRedo ?? false;
  }
  redo() {
    r(this.snappingManager) && this.snappingManager.doneSnapping(), r(this._reshapeOperation.redo()) && this._updateGeometryInternally(this._reshapeOperation.outputGeometry.clone());
  }
  onInputEvent(e11) {
    "key-down" !== e11.type || "Delete" !== e11.key && "Backspace" !== e11.key || this._reshapeOperation.removeSelectedVertices();
  }
  reset() {
  }
  get test() {
    return { snappingManager: this.snappingManager, reshapeOperation: this._reshapeOperation };
  }
};
e([d()], v9.prototype, "_reshapeOperation", void 0), e([d({ constructOnly: true, nonNullable: true })], v9.prototype, "view", void 0), e([d({ constructOnly: true })], v9.prototype, "graphic", void 0), e([d({ constructOnly: true, nonNullable: true })], v9.prototype, "enableZShape", void 0), e([d({ constructOnly: true, nonNullable: true })], v9.prototype, "enableZVertex", void 0), e([d({ constructOnly: true, nonNullable: true })], v9.prototype, "enableMoveGraphic", void 0), e([d({ constructOnly: true, nonNullable: true })], v9.prototype, "enableMidpoints", void 0), e([d({ constructOnly: true, nonNullable: true })], v9.prototype, "enableEdgeOffset", void 0), e([d()], v9.prototype, "type", void 0), e([d({ constructOnly: true, type: c6 })], v9.prototype, "labelOptions", void 0), e([d({ constructOnly: true, type: r8 })], v9.prototype, "tooltipOptions", void 0), e([d({ constructOnly: true })], v9.prototype, "snappingManager", void 0), e([d()], v9.prototype, "updating", null), e([d()], v9.prototype, "automaticManipulatorSelection", void 0), v9 = e([n3("esri.views.3d.interactive.editingTools.graphicReshape3D.GraphicReshapeTool")], v9);

// node_modules/@arcgis/core/views/interactive/tooltip/TransformTooltipInfos.js
var r13 = class extends e8 {
  constructor(o11) {
    super(o11), this.type = "transform-rotate", this.rotationType = "geographic";
  }
};
e([d()], r13.prototype, "type", void 0), e([d()], r13.prototype, "rotation", void 0), e([d()], r13.prototype, "rotationPrecision", void 0), e([d()], r13.prototype, "orientation", void 0), e([d()], r13.prototype, "orientationPrecision", void 0), e([d()], r13.prototype, "rotationType", void 0), r13 = e([n3("esri.views.interactive.tooltip.TransformRotateTooltipInfo")], r13);
var s8 = class extends e8 {
  constructor(o11) {
    super(o11), this.type = "transform-scale", this.sizeUnit = null, this.sizePrecision = null;
  }
};
e([d()], s8.prototype, "type", void 0), e([d()], s8.prototype, "scale", void 0), e([d()], s8.prototype, "size", void 0), e([d()], s8.prototype, "sizeUnit", void 0), e([d()], s8.prototype, "sizePrecision", void 0), s8 = e([n3("esri.views.interactive.tooltip.TransformScaleTooltipInfo")], s8);
var p9 = class extends e8 {
  constructor(o11) {
    super(o11), this.type = "transform-absolute", this.orientationEnabled = true, this.orientationPrecision = null, this.rotationType = "geographic", this.sizeUnit = null, this.sizeEnabled = true, this.sizePrecision = null;
  }
};
e([d()], p9.prototype, "type", void 0), e([d()], p9.prototype, "orientation", void 0), e([d()], p9.prototype, "orientationEnabled", void 0), e([d()], p9.prototype, "orientationPrecision", void 0), e([d()], p9.prototype, "rotationType", void 0), e([d()], p9.prototype, "size", void 0), e([d()], p9.prototype, "sizeUnit", void 0), e([d()], p9.prototype, "sizeEnabled", void 0), e([d()], p9.prototype, "sizePrecision", void 0), p9 = e([n3("esri.views.interactive.tooltip.TransformAbsoluteTooltipInfo")], p9);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transformGraphic/GraphicScaleRotateTransform.js
var Dt;
var St;
!function(t13) {
  t13.ScaleIn = u5.Custom2, t13.ScaleOut = u5.Custom3, t13.RotateLeft = u5.Custom4, t13.RotateRight = u5.Custom5, t13.Unlocked = u5.Custom7, t13.DelayedFocused = u5.Custom8, t13.TouchInput = u5.Custom12;
}(Dt || (Dt = {}));
var vt2 = class {
  constructor({ adapter: t13, tooltipOptions: i10, mode: o11, tool: r15 }) {
    this.mode = null, this._handles = new u2(), this._scaleRotateDragData = null, this._activeAnimation = null, this.events = new n5(), this.getFocused = () => this._ringManipulator.focused, this.getScale = () => r(this._scaleRotateDragData) && "scale" === this._scaleRotateDragData.mode ? this.adapter.scale : 1, this.tool = r15, this.mode = o11, this.adapter = t13, this._tooltipOptions = i10, this._tooltip = new m4({ view: r15.view }), this._createManipulator(), this._updateDragState(), this._updateManipulatorTransform(), this._handles.add(f4(() => !this._tooltipOptions.enabled, () => this._tooltip.clear(), h));
  }
  get angle() {
    return this.adapter.angle;
  }
  get scale() {
    return this.adapter.scale;
  }
  set location(t13) {
    this._ringManipulator.location = t13;
  }
  set elevationAlignedLocation(t13) {
    this._ringManipulator.elevationAlignedLocation = t13;
  }
  get grabbing() {
    return this._ringManipulator.grabbing;
  }
  set interactive(t13) {
    this._ringManipulator.interactive = t13;
  }
  destroy() {
    r(this._activeAnimation) && (this._activeAnimation.frameTask.remove(), this._activeAnimation = null), this._handles = l(this._handles), this.tool.manipulators.remove(this._ringManipulator), this._ringManipulator = null, this._tooltip = l(this._tooltip);
  }
  startAnimation(t13) {
    this.cancelActiveAnimation(), t13.start();
    const e11 = A({ update: ({ deltaTime: e12 }) => {
      t13.update(e12) && this.cancelActiveAnimation();
    } });
    this._activeAnimation = { ...t13, frameTask: e11 };
  }
  cancelActiveAnimation() {
    r(this._activeAnimation) && (this._activeAnimation.frameTask.remove(), this._activeAnimation = l(this._activeAnimation));
  }
  forEachManipulator(t13) {
    t13(this._ringManipulator, A4.SCALE_ROTATE);
  }
  _createManipulator() {
    const e11 = this._createRingManipulator();
    this._ringManipulator = e11, this.tool.manipulators.add(e11);
    const a15 = this.tool.graphicState.graphic, r15 = p4(e11, (e12, r16, n12) => {
      this._scaleRotateDragData = null;
      const l12 = this.adapter.startInteraction(), c10 = { mode: "none", origin: t3(e12.renderLocation), initialAngle: this.adapter.angle, angle: 0, angleDir: 0, scaleDir: 0 };
      this._scaleRotateDragData = c10, this._updateDragState();
      const h10 = c3.get();
      this.tool.view.renderCoordsHelper.worldUpAtPosition(e12.renderLocation, h10), r16.next(C2(this.tool.view, _3(e12.renderLocation, h10, p3()))).next((e13) => {
        const r17 = Z(e13.plane), n13 = O2(e13.renderStart, e13.renderEnd, c10.origin, r17), h11 = r7.shortestSignedDiff(c10.angle, n13);
        c10.angleDir = o4(c10.angleDir + h11, -q6, q6), c10.angle = n13;
        const p11 = yt(c10, e13), u7 = p11 - this.adapter.scale;
        if (c10.scaleDir = o4(c10.scaleDir + u7, -m12, m12), this._onScaleChanged(), "none" === c10.mode) {
          const t13 = this.mode || bt(e13, e13.plane, c10.origin, this.tool.view.state.camera);
          if (r(t13)) {
            switch (t13) {
              case "rotate":
                this.tool.emit("graphic-rotate-start", { graphic: a15, angle: 0 }), this.tool.emit("record-undo", { record: this.adapter.createUndoRecord() });
                break;
              case "scale":
                this.tool.emit("graphic-scale-start", { graphic: a15, xScale: 1, yScale: 1 }), this.tool.emit("record-undo", { record: this.adapter.createUndoRecord() });
            }
            c10.mode = t13;
          }
        }
        switch (c10.mode) {
          case "rotate":
            l12.state.angle = c10.initialAngle + n13;
            break;
          case "scale":
            l12.state.scale = p11, this._onScaleChanged();
        }
        switch (this._updateDragState(), this._updateManipulatorTransform(), e13.action) {
          case "start":
          case "update":
            switch (c10.mode) {
              case "rotate":
                this.tool.emit("graphic-rotate", { graphic: a15, angle: m2(c10.angle) });
                break;
              case "scale":
                this.tool.emit("graphic-scale", { graphic: a15, xScale: p11, yScale: p11 });
            }
            break;
          case "end":
            switch (c10.mode) {
              case "rotate":
                this.tool.emit("graphic-rotate-stop", { graphic: a15, angle: m2(c10.angle) });
                break;
              case "scale":
                this.tool.emit("graphic-scale-stop", { graphic: a15, xScale: p11, yScale: p11 });
            }
        }
        return "end" === e13.action && (this.startAnimation(Rt(this, () => this._onScaleChanged())), this._scaleRotateDragData = null, this._updateDragState(), l12.done()), e13;
      }).next(this._updateTooltipPipelineStep(c10)), n12.next(() => {
        if (l12.cancel(), r(this._scaleRotateDragData)) {
          switch (this._scaleRotateDragData.mode) {
            case "none":
              break;
            case "rotate":
              this.tool.emit("graphic-rotate-stop", { graphic: a15, angle: 0 });
              break;
            case "scale":
              this.tool.emit("graphic-scale-stop", { graphic: a15, xScale: 1, yScale: 1 });
          }
          this.startAnimation(Rt(this, () => this._onScaleChanged())), this._scaleRotateDragData = null, this._updateDragState();
        }
        this._updateFocusTooltip();
      });
    });
    this._handles.add([r15, e11.events.on("focus-changed", (t13) => {
      "focus" === t13.action ? this.startAnimation(jt(this, () => this._updateDelayedFocusedState())) : this._updateDelayedFocusedState();
    }), e11.events.on("immediate-click", (t13) => {
      t13.stopPropagation();
    }), l3(() => {
      var _a;
      return (_a = this.tool.graphicState) == null ? void 0 : _a.displaying;
    }, (t13) => this._ringManipulator.available = t13, h)]);
  }
  _updateTooltipPipelineStep(t13) {
    return (e11) => {
      const a15 = this._tooltipOptions;
      if (!a15.enabled)
        return e11;
      if ("end" === e11.action)
        return this._updateFocusTooltip(), e11;
      const i10 = this._tooltip, o11 = this._tooltipOptions.visualVariables, r15 = r(o11) ? o11.size : null, h10 = r(o11) ? o11.rotation : null;
      switch (t13.mode) {
        case "scale":
          i10.info = new s8({ tooltipOptions: a15, scale: { value: this.adapter.scale }, size: o7(c(this.adapter.size, -1), "meters"), sizeUnit: r(r15) ? r15.unit : null, sizePrecision: r(r15) ? kt2(r15.valueType) : null });
          break;
        case "rotate": {
          const t14 = r(h10) ? kt2(h10.valueType) : null, e12 = r(h10) ? h10.rotationType : "geographic";
          i10.info = new r13({ tooltipOptions: a15, rotation: f9(c(-this.adapter.relativeAngle, 0), "radians", "geographic"), rotationPrecision: t14, orientation: f9(-this.adapter.angle, "radians", "geographic"), orientationPrecision: t14, rotationType: e12 });
        }
      }
      return e11;
    };
  }
  _updateFocusTooltip() {
    if (!this._tooltipOptions.enabled)
      return;
    if (this.getFocused()) {
      const t13 = this._tooltipOptions.visualVariables, e11 = r(t13) ? t13.rotation : null, a15 = r(t13) ? t13.size : null;
      this._tooltip.info = new p9({ tooltipOptions: this._tooltipOptions, orientation: f9(-this.adapter.angle, "radians", "geographic"), orientationEnabled: null == this.mode || "rotate" === this.mode, orientationPrecision: r(e11) ? kt2(e11.valueType) : null, rotationType: r(e11) ? e11.rotationType : "geographic", size: o7(c(this.adapter.size, -1), "meters"), sizeUnit: r(a15) ? a15.unit : null, sizeEnabled: null == this.mode || "scale" === this.mode, sizePrecision: r(a15) ? kt2(a15.valueType) : null });
    } else
      this._tooltip.clear();
  }
  _onScaleChanged() {
    this.events.emit("scale-changed"), this._updateManipulatorTransform();
  }
  _updateDelayedFocusedState() {
    this._ringManipulator.updateStateEnabled(Dt.DelayedFocused, this.getFocused()), this._updateFocusTooltip();
  }
  _updateDragState() {
    if (this._ringManipulator.updateStateEnabled(Dt.Unlocked, !(r(this._scaleRotateDragData) && "none" !== this._scaleRotateDragData.mode)), r(this._scaleRotateDragData))
      switch (this._scaleRotateDragData.mode) {
        case "rotate":
          this._ringManipulator.updateStateEnabled(Dt.ScaleIn | Dt.ScaleOut, false), this._ringManipulator.updateStateEnabled(Dt.RotateLeft, this._scaleRotateDragData.angleDir < 0), this._ringManipulator.updateStateEnabled(Dt.RotateRight, this._scaleRotateDragData.angleDir >= 0);
          break;
        case "scale":
          this._ringManipulator.updateStateEnabled(Dt.RotateLeft | Dt.RotateRight, false), this._ringManipulator.updateStateEnabled(Dt.ScaleIn, this._scaleRotateDragData.scaleDir < 0), this._ringManipulator.updateStateEnabled(Dt.ScaleOut, this._scaleRotateDragData.scaleDir >= 0);
      }
    else
      this._ringManipulator.updateStateEnabled(Dt.ScaleIn | Dt.ScaleOut | Dt.RotateLeft | Dt.RotateRight, false);
  }
  _updateManipulatorTransform() {
    const t13 = p2(f7.get(), this.adapter.angle, r3(0, 0, 1)), e11 = this.getScale(), a15 = q2(f7.get(), o3(c3.get(), e11, e11, e11));
    this._ringManipulator.modelTransform = u3(f7.get(), a15, t13);
  }
  _createRingManipulator() {
    const t13 = (t14, e12, a16) => {
      const i11 = [], o12 = Math.ceil(a11 * (e12 - t14) / (2 * Math.PI));
      for (let s11 = 0; s11 < o12 + 1; s11++) {
        const r16 = t14 + s11 * (e12 - t14) / o12;
        i11.push(r3(a16 * Math.cos(r16), a16 * Math.sin(r16), 0));
      }
      return i11;
    }, e11 = (e12) => t13(0, 2 * Math.PI, e12), a15 = (t14) => [[-t14 / 2, 0], [t14 / 2, 0], [t14 / 2, i6 / 2], [-t14 / 2, i6 / 2]], i10 = (t14, e12) => T3.createPathExtrusionGeometry(a15(e12), t14, [], [], false), o11 = e11(P6), s10 = i10(o11, l10), r15 = { left: [], right: [] }, n12 = [];
    for (let j8 = 0; j8 < 2; j8++) {
      const e12 = j8 * Math.PI - Math.PI / 4, a16 = Math.PI / 2 - b6, o12 = e12 + a16, s11 = e12 + Math.PI / 2 - a16, l13 = t13(o12, s11, p6), c11 = i10(l13, n10);
      n12.push(l13), n12.push(t13(o12, s11, r11 - l10 / 2)), r15.left.push(c11), r15.right.push(c11);
      for (let t14 = 0; t14 < 2; t14++) {
        const e13 = 0 === t14, a17 = e5();
        if (e13) {
          i2(a17, a17, [1, -1, 1]), f5(a17, a17, -o12, [0, 0, 1]);
          const t15 = Math.round(g4 * (l13.length - 1));
          a17[12] = l13[t15][0], a17[13] = l13[t15][1], a17[14] = l13[t15][2];
        } else {
          f5(a17, a17, s11, [0, 0, 1]);
          const t15 = Math.round((1 - g4) * (l13.length - 1));
          a17[12] = l13[t15][0], a17[13] = l13[t15][1], a17[14] = l13[t15][2];
        }
        const i11 = T3.createExtrudedTriangle(s7, 0, x6, i6);
        T3.transformInPlace(i11, a17), (e13 ? r15.left : r15.right).push(i11);
      }
    }
    const l12 = [];
    for (let M9 = 0; M9 < 2; M9++) {
      const e12 = M9 * Math.PI - Math.PI / 4, a16 = Math.PI / 2 - d10, o12 = e12 + a16, s11 = e12 + Math.PI / 2 - a16, r16 = t13(o12, s11, r11);
      l12.push(i10(r16, n10));
    }
    const c10 = e11(P6 + j6), h10 = e11(P6 + k2), p11 = i10(c10, n10), u7 = i10(h10, n10), d14 = e11(P6 - j6), g6 = e11(P6 - k2), m15 = i10(d14, n10), _7 = i10(g6, n10), f11 = this._createMaterial(), v10 = this._createMaterial(0.66), y7 = this._createMaterial(0.5), b7 = this._createMaterial(0.33);
    let T6 = [{ geometry: s10, material: f11, stateMask: Dt.DelayedFocused }, { geometry: s10, material: y7, stateMask: t8.None }];
    this.mode && "scale" !== this.mode || (T6 = T6.concat([{ geometry: l12, material: f11, stateMask: Dt.DelayedFocused | Dt.Unlocked }, { geometry: p11, material: v10, stateMask: Dt.DelayedFocused | Dt.ScaleIn }, { geometry: u7, material: b7, stateMask: Dt.DelayedFocused | Dt.ScaleIn }, { geometry: m15, material: v10, stateMask: Dt.DelayedFocused | Dt.ScaleOut }, { geometry: _7, material: b7, stateMask: Dt.DelayedFocused | Dt.ScaleOut }])), this.mode && "rotate" !== this.mode || (T6 = T6.concat([{ geometry: r15.right, material: f11, stateMask: Dt.DelayedFocused | Dt.Unlocked }, { geometry: r15.left, material: f11, stateMask: Dt.DelayedFocused | Dt.RotateLeft }, { geometry: r15.right, material: f11, stateMask: Dt.DelayedFocused | Dt.RotateRight }]));
    const R5 = [o11, ...n12];
    return new te({ view: this.tool.view, renderObjects: T6, autoScaleRenderObjects: false, worldOriented: true, radius: l10, focusMultiplier: 1, touchMultiplier: 1.5, elevationInfo: u4(this.tool.graphicState.graphic), collisionType: { type: "ribbon", paths: R5, direction: r3(0, 0, 1) } });
  }
  _createMaterial(t13 = 1) {
    const e11 = e4([...t11, t13]);
    return new m8({ color: e11, transparent: 1 !== t13, cullFace: n7.Back, renderOccluded: h3.Transparent });
  }
  get test() {
    return { ringManipulator: this._ringManipulator, tooltip: this._tooltip };
  }
};
function yt(t13, e11) {
  const a15 = e3(c3.get(), e11.renderStart, t13.origin), i10 = e3(c3.get(), e11.renderEnd, t13.origin), o11 = s(a15), s10 = s(i10);
  return 0 === o11 ? 0 : s10 / o11;
}
function bt(t13, e11, a15, i10) {
  const { renderStart: o11, renderEnd: s10 } = t13, r15 = Tt(o11, i10, c3.get()), n12 = Tt(s10, i10, c3.get());
  if (p(r15, n12) < f10 * f10)
    return null;
  const l12 = e3(c3.get(), o11, a15), c10 = _(c3.get(), l12, Z(e11)), h10 = o11, p11 = u(c3.get(), h10, c10), u7 = Tt(a15, i10, c3.get()), d14 = r15, g6 = Tt(p11, i10, c3.get()), m15 = e3(c3.get(), g6, d14), _7 = e3(c3.get(), r15, u7), f11 = j4(d14, m15), M9 = j4(u7, _7);
  return h4(f11, n12) < h4(M9, n12) ? "rotate" : "scale";
}
function Tt(t13, e11, a15) {
  return e11.projectToScreen(t13, wt), o3(a15, wt[0], wt[1], 0);
}
function Rt(t13, e11) {
  let a15 = null, i10 = 1;
  const o11 = () => i10;
  return { start: () => {
    i10 = t13.getScale(), a15 = t13.getScale, t13.getScale = o11, e11();
  }, update: (t14) => (i10 += ((i10 + 1) / 2 - i10) * Math.min(t14 * v8, 1), e11(), Math.abs(i10 - 1) < 0.01 ? St.STOP : St.CONTINUE), destroy: () => {
    t13.getScale = a15, e11();
  } };
}
function jt(t13, e11) {
  let a15 = 0, i10 = null;
  const o11 = () => false;
  return { start: () => {
    i10 = t13.getFocused, t13.getFocused = o11, a15 = 0, e11();
  }, update: (t14) => (a15 += t14, !i10() || a15 > u6 ? St.STOP : St.CONTINUE), destroy: () => {
    t13.getFocused = i10, e11();
  } };
}
function kt2(t13) {
  switch (t13) {
    case "integer":
    case "long":
      return 0;
    default:
      return null;
  }
}
!function(t13) {
  t13[t13.CONTINUE = 0] = "CONTINUE", t13[t13.STOP = 1] = "STOP";
}(St || (St = {}));
var wt = i();

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transformGraphic/undoRecords.js
function r14(t13) {
  return r(t13.geometry) && "mesh" === t13.geometry.type ? o10(t13.geometry) : n11(t13);
}
function o10(t13) {
  return r(t13.transform) ? m13(t13, t13.transform) : i8(t13);
}
function n11(e11) {
  let r15 = e11.geometry, o11 = n;
  return { undo(e12) {
    o11 = e12.geometry, e12.geometry = r15;
  }, redo(e12) {
    r15 = e12.geometry, e12.geometry = o11;
  } };
}
function m13(t13, r15) {
  let o11 = r15.clone(), n12 = null;
  return { undo: (r16) => {
    n12 = r(t13.transform) ? t13.transform.clone() : null, t13.transform = o11, r16.notifyGeometryChanged();
  }, redo: (r16) => {
    o11 = r(t13.transform) ? t13.transform.clone() : null, t13.transform = n12, r16.notifyGeometryChanged();
  } };
}
function i8(e11) {
  let t13, r15 = e11.vertexAttributes.clonePositional();
  return { undo: (o11) => {
    t13 = e11.vertexAttributes.clonePositional(), e11.vertexAttributes = r15, o11.notifyGeometryChanged();
  }, redo: (o11) => {
    r15 = e11.vertexAttributes.clonePositional(), e11.vertexAttributes = t13, o11.notifyGeometryChanged();
  } };
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transformGraphic/ScaleRotateMeshAdapter.js
var d12 = class extends d3 {
  constructor(t13) {
    super(t13), this.interactionState = null;
  }
  initialize() {
    this.own([f4(() => r(this.interactionState) && this.interactionState.angle !== this.interactionState.previousAngle ? { interactionState: this.interactionState, angle: this.interactionState.state.angle } : null, ({ interactionState: t13 }) => {
      this._updateMeshRotation(t13);
    }, U2), f4(() => r(this.interactionState) && this.interactionState.scale !== this.interactionState.previousScale ? { interactionState: this.interactionState, scale: this.interactionState.state.scale } : null, ({ interactionState: t13 }) => {
      this._updateMeshSize(t13);
    }, U2)]);
  }
  get angle() {
    const t13 = this.geometry.transform;
    if (t(t13))
      return 0;
    const e11 = l5(t13.rotation)[2];
    return Math.abs(e11) > 0.999999 ? M(v3(t13.rotation)) * Math.sign(e11) : 0;
  }
  get scale() {
    return r(this.interactionState) ? this.interactionState.scale : 1;
  }
  startInteraction() {
    const t13 = new y5({ angle: this.angle });
    this.interactionState = t13;
    const e11 = () => this.interactionState = null;
    return { state: t13, done: e11, cancel: () => {
      t13.cancel(), e11();
    } };
  }
  createUndoRecord() {
    return r14(this.graphic);
  }
  _updateMeshRotation(t13) {
    const e11 = this.geometry.anchor, i10 = this.viewingMode === l6.Global, { angle: o11, previousAngle: a15 } = t13;
    this.geometry.rotate(0, 0, m2(o11 - a15), { origin: e11, geographic: i10 }), t13.previousAngle = o11, r(this.geometry.transform) && this.graphic.notifyMeshTransformChanged(), this.graphic.notifyGeometryChanged();
  }
  _updateMeshSize(t13) {
    const e11 = this.geometry.anchor, i10 = this.viewingMode === l6.Global, { scale: o11, previousScale: r15 } = t13;
    this.geometry.scale(o11 / r15, { origin: e11, geographic: i10 }), t13.previousScale = o11, r(this.geometry.transform) && this.graphic.notifyMeshTransformChanged(), this.graphic.notifyGeometryChanged();
  }
};
e([d({ constructOnly: true })], d12.prototype, "graphic", void 0), e([d({ constructOnly: true })], d12.prototype, "geometry", void 0), e([d({ constructOnly: true })], d12.prototype, "viewingMode", void 0), e([d()], d12.prototype, "angle", null), e([d()], d12.prototype, "scale", null), e([d()], d12.prototype, "interactionState", void 0), d12 = e([n3("esri.views.3d.interactive.editingTools.transformGraphic.ScaleRotateMeshAdapter")], d12);
var y5 = class extends y {
  constructor(t13) {
    super(t13), this.angle = 0, this.initialAngle = 0, this.previousAngle = 0, this.previousScale = 1, this.scale = 1, this.initialAngle = t13.angle, this.previousAngle = t13.angle;
  }
  get state() {
    const { angle: t13, scale: e11 } = this;
    return { angle: t13, scale: e11 };
  }
  cancel() {
    this.angle = this.initialAngle, this.scale = 1;
  }
};
e([d()], y5.prototype, "angle", void 0), e([d()], y5.prototype, "initialAngle", void 0), e([d()], y5.prototype, "previousAngle", void 0), e([d()], y5.prototype, "previousScale", void 0), e([d()], y5.prototype, "scale", void 0), e([d()], y5.prototype, "state", null), y5 = e([n3("InteractionState")], y5);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transformGraphic/ScaleRotateObjectSymbol3DAdapter.js
var y6 = class extends d3 {
  constructor(t13) {
    super(t13), this.sizeAxis = null, this.interactionState = null;
  }
  initialize() {
    this.own(f4(() => r(this.interactionState) ? this.interactionState.state : null, (t13) => {
      this._updateSymbol(t13);
    }, U2));
  }
  get angle() {
    return r(this.interactionState) ? this.interactionState.angle : r(this._orientationReferenceSymbolLayer) ? g5(this._orientationReferenceSymbolLayer.heading) : 0;
  }
  get scale() {
    return r(this.interactionState) ? this.interactionState.scale : 1;
  }
  get relativeAngle() {
    return this.angle - this.initialAngle;
  }
  get initialAngle() {
    return r(this.interactionState) ? this.interactionState.initialAngle : 0;
  }
  get size() {
    const t13 = this._sizeReferenceSymbolLayer;
    if (t(t13))
      return null;
    const e11 = this.findLayerView(), i10 = this._graphicSymbol;
    if (t(e11) || t(i10) || "point-3d" !== i10.type)
      return null;
    const o11 = e11.getSymbolLayerSize(i10, t13);
    if ("size" in o11 && r(o11.size))
      return o11.size;
    const r15 = this.sizeAxis;
    return "width" in o11 && r(o11.width) && (t(r15) || "width" === r15 || "all" === r15 || "width-and-depth" === r15) ? o11.width : "depth" in o11 && r(t13.depth) && (t(r15) || "depth" === r15 || "all" === r15 || "width-and-depth" === r15) ? o11.depth : "height" in o11 && r(t13.height) && (t(r15) || "height" === r15 || "all" === r15) ? o11.height : null;
  }
  get _sizeReferenceSymbolLayer() {
    const t13 = this._graphicSymbol;
    return t(t13) || 0 === t13.symbolLayers.length ? null : t13.symbolLayers.find((t14) => "object" === t14.type);
  }
  get _orientationReferenceSymbolLayer() {
    const t13 = this._graphicSymbol;
    return t(t13) || 0 === t13.symbolLayers.length ? null : t13.symbolLayers.find((t14) => "object" === t14.type && r(t14.heading));
  }
  get _graphicSymbol() {
    return r(this.graphic) && r(this.graphic.symbol) && "point-3d" === this.graphic.symbol.type ? this.graphic.symbol : null;
  }
  set _graphicSymbol(t13) {
    this.graphic.symbol = t13;
  }
  startInteraction() {
    const t13 = this._graphicSymbol, e11 = this.findLayerView();
    if (r(this.interactionState) || t(t13) || t(e11))
      return m14;
    const i10 = t13.symbolLayers.map((i11) => "object" === i11.type ? e11.getSymbolLayerSize(t13, i11) : null).toArray(), o11 = t13.clone(), r15 = this.angle, l12 = new d13({ originalSymbol: o11, angle: r15, initialSizes: i10 });
    this.interactionState = l12;
    const a15 = () => this.interactionState = null;
    return { state: l12, done: a15, cancel: () => {
      this._graphicSymbol = o11, a15();
    } };
  }
  createUndoRecord() {
    let t13 = this.graphic.symbol, e11 = null;
    return { undo: (i10) => {
      e11 = i10.symbol, i10.symbol = t13;
    }, redo: (i10) => {
      t13 = i10.symbol, i10.symbol = e11;
    } };
  }
  _updateSymbol({ scale: t13, angle: e11, originalSymbol: i10, initialSizes: o11 }) {
    const a15 = this._graphicSymbol;
    if (t(a15) || "point-3d" !== a15.type)
      return;
    const c10 = a15.clone(), h10 = -m2(e11 - this.initialAngle);
    let p11 = false;
    this._forEachObjectSymbolLayerPair(i10, c10, (e12, i11, r15) => {
      const s10 = c(e12.heading, 0) + h10;
      i11.heading !== s10 && (i11.heading = s10, p11 = true);
      const a16 = o11[r15];
      if (r(a16) && "width" in a16) {
        a16.width = this.sizeFilter(a16.width), a16.height = this.sizeFilter(a16.height), a16.depth = this.sizeFilter(a16.depth);
        const e13 = a16.width * t13;
        i11.width !== e13 && (i11.width = e13, p11 = true);
        const o12 = a16.depth * t13;
        i11.depth !== o12 && (i11.depth = o12, p11 = true);
        const r16 = a16.height * t13;
        i11.height !== r16 && (i11.height = r16, p11 = true);
      }
    }), p11 && (this._graphicSymbol = c10);
  }
  _forEachObjectSymbolLayerPair(t13, e11, i10) {
    t13.symbolLayers.forEach((t14, o11) => {
      const r15 = e11.symbolLayers.getItemAt(o11);
      "object" === t14.type && "object" === r15.type && i10(t14, r15, o11);
    });
  }
};
function g5(t13) {
  return -M(t13);
}
e([d()], y6.prototype, "angle", null), e([d()], y6.prototype, "scale", null), e([d()], y6.prototype, "relativeAngle", null), e([d()], y6.prototype, "initialAngle", null), e([d()], y6.prototype, "size", null), e([d()], y6.prototype, "sizeAxis", void 0), e([d({ constructOnly: true })], y6.prototype, "graphic", void 0), e([d()], y6.prototype, "interactionState", void 0), e([d({ constructOnly: true })], y6.prototype, "findLayerView", void 0), e([d({ constructOnly: true })], y6.prototype, "sizeFilter", void 0), e([d()], y6.prototype, "_sizeReferenceSymbolLayer", null), e([d()], y6.prototype, "_orientationReferenceSymbolLayer", null), e([d()], y6.prototype, "_graphicSymbol", null), y6 = e([n3("esri.views.3d.interactive.editingTools.transformGraphic.ScaleRotateObjectSymbol3DAdapter")], y6);
var m14 = { state: { angle: 0, scale: 0 }, done: () => {
}, cancel: () => {
} };
var d13 = class extends y {
  constructor(t13) {
    super(t13), this.angle = 0, this.initialAngle = 0, this.scale = 1, this.initialAngle = t13.angle;
  }
  get state() {
    const { originalSymbol: t13, angle: e11, initialAngle: i10, scale: o11, initialSizes: r15 } = this;
    return { originalSymbol: t13, angle: e11, initialAngle: i10, scale: o11, initialSizes: r15 };
  }
};
e([d()], d13.prototype, "originalSymbol", void 0), e([d()], d13.prototype, "angle", void 0), e([d()], d13.prototype, "initialAngle", void 0), e([d()], d13.prototype, "initialSizes", void 0), e([d()], d13.prototype, "scale", void 0), e([d()], d13.prototype, "state", null), d13 = e([n3("InteractionState")], d13);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transformGraphic/GraphicTransformTool.js
var k3 = class extends a6(n5.EventedMixin(c7)) {
  constructor(t13) {
    super(t13), this.enableZ = true, this.enableRotation = true, this.enableScaling = true, this.tooltipOptions = new r8(), this.type = "transform-3d", this._scaleRotate = null, this._snappingPipeline = new d7(), this._tooltip = null;
  }
  initialize() {
    const { graphic: t13, view: e11 } = this;
    this.graphicState = new e9({ graphic: t13 }), this.own(l3(() => this.tooltipOptions.enabled, (t14) => {
      this._tooltip = t14 ? new m4({ view: e11 }) : l(this._tooltip);
    }, w)), this._moveManipulation = new c9({ tool: this, view: e11, snapToScene: this.snapToScene, xyAvailable: true, xyAxisAvailable: true, zAvailable: this.enableZ && t10(t13), radius: c9.radiusForSymbol(t13.symbol) }), this._moveManipulation.forEachManipulator((e12, i11) => this.handles.add([e12.events.on("immediate-click", (e13) => {
      this.emit("immediate-click", { ...e13, graphic: t13 }), e13.stopPropagation();
    }), e12.events.on("focus-changed", ({ action: t14 }) => {
      const { tooltipOptions: e13, _tooltip: a15 } = this;
      if (!t(a15) && (a15.clear(), "focus" === t14)) {
        const t15 = i11 === A4.TRANSLATE_Z ? p7 : i7;
        a15.info = new t15({ tooltipOptions: e13 });
      }
    })])), this._moveManipulation.elevationInfo = u4(t13);
    const i10 = t13.geometry;
    if (this._moveManipulation.createGraphicDragPipeline((a15, n12, r15, p11, l12) => (r(i10) && a15 === d11.XY && (r15 = r15.next(this._snappingPipeline.createSnapDragEventPipelineStep({ snappingContext: new e7({ elevationInfo: u4(t13), pointer: l12, editGeometryOperations: S.fromGeometry(new j({ spatialReference: i10.spatialReference }), e11.state.viewingMode), visualizer: new g3(), excludeFeature: t13 }), snappingManager: this.snappingManager, updatingHandles: this.updatingHandles, cancel: p11 }), this._snappingPipeline.next)), r15 = r15.next((t14) => {
      const { tooltipOptions: e12, _tooltip: i11 } = this;
      if (t(i11))
        return t14;
      const { mapStart: n13, mapEnd: r16 } = t14;
      i11.clear();
      const p12 = a15 === d11.Z ? p7 : i7;
      if ("end" === t14.action)
        i11.info = new p12({ tooltipOptions: e12 });
      else {
        const t15 = a15 === d11.Z ? d8(n13, r16) : d9(n13, r16, this.graphicState.isDraped ? "on-the-ground" : "absolute-height");
        r(t15) && (i11.info = new p12({ tooltipOptions: e12, distance: t15 }));
      }
      return t14;
    })), this.graphicState, (t14) => {
      const { action: e12, graphic: i11, dxScreen: a15, dyScreen: o11 } = t14, s10 = { graphic: i11, dxScreen: a15, dyScreen: o11 };
      switch (e12) {
        case "start":
          this.emit("graphic-translate-start", s10), this.emit("record-undo", { record: this._createGeometryUndoRecord() });
          break;
        case "update":
          this.emit("graphic-translate", s10);
          break;
        case "end":
          this.emit("graphic-translate-stop", s10);
      }
    }), this._moveManipulation.angle = r(this._scaleRotate) ? this._scaleRotate.angle : 0, this._scaleRotateAdapter = this._createScaleRotateAdapter(), this.handles.add(l3(() => this._scaleRotateAdapter.angle, () => this._updateMoveAngle())), this.enableScaling || this.enableRotation) {
      const t14 = this.enableScaling && this.enableRotation ? null : this.enableScaling ? "scale" : "rotate";
      this._scaleRotate = new vt2({ tool: this, mode: t14, adapter: this._scaleRotateAdapter, tooltipOptions: this.tooltipOptions }), this.handles.add(this._scaleRotate.events.on("scale-changed", () => this._onScaleChanged()));
    }
    this.handles.add([i5({ view: this.view, graphic: this.graphic, forEachManipulator: (t14) => this._forEachManipulator(t14), onManipulatorsChanged: () => n2() }), this.graphicState.on("changed", () => this._onGeometryChanged()), this._hideManipulatorsForGraphicState(), l3(() => e11.scale, () => this._updateMoveAngle())]), this.handles.add(this.view.trackGraphicState(this.graphicState)), this._onGeometryChanged(), this._updateMoveAngle(), this._forEachManipulator((t14) => {
      t14 instanceof te && this.handles.add(t14.events.on("grab-changed", () => this._updateManipulatorsInteractive()));
    }), this.finishToolCreation();
  }
  destroy() {
    this._tooltip = l(this._tooltip), this._moveManipulation.destroy(), this._scaleRotate = l(this._scaleRotate), this._scaleRotateAdapter = l(this._scaleRotateAdapter), this._set("view", null), this._set("graphic", null);
  }
  _updateManipulatorsInteractive() {
    t(this._scaleRotate) || (this._scaleRotate.interactive = !this._moveManipulation.grabbing, this._moveManipulation.interactive = !this._scaleRotate.grabbing);
  }
  _createScaleRotateAdapter() {
    return r(this.graphic.geometry) && "mesh" === this.graphic.geometry.type ? new d12({ graphic: this.graphic, geometry: this.graphic.geometry, viewingMode: this.view.state.viewingMode }) : new y6({ graphic: this.graphic, sizeFilter: (t13) => this._enforceNonZeroSize(t13), findLayerView: () => this.view.allLayerViews.find((t13) => t13.layer === this.graphic.layer), sizeAxis: r(this.tooltipOptions.visualVariables) && r(this.tooltipOptions.visualVariables.size) ? this.tooltipOptions.visualVariables.size.axis : null });
  }
  _forEachManipulator(t13) {
    this._moveManipulation.forEachManipulator(t13), r(this._scaleRotate) && this._scaleRotate.forEachManipulator(t13);
  }
  _hideManipulatorsForGraphicState() {
    return l3(() => this.graphicState.displaying, (t13) => {
      this._forEachManipulator((e11) => e11.available = t13), this._moveManipulation.zManipulation.available = t13 && this.enableZ && t10(this.graphic);
    });
  }
  _createGeometryUndoRecord() {
    return r14(this.graphic);
  }
  set snapToScene(t13) {
    this._moveManipulation && (this._moveManipulation.snapToScene = t13), this._set("snapToScene", t13);
  }
  get updating() {
    return this.updatingHandles.updating;
  }
  set location(t13) {
    this._moveManipulation.location = t13, r(this._scaleRotate) && (this._scaleRotate.location = t13);
  }
  set elevationAlignedLocation(t13) {
    this._moveManipulation.elevationAlignedLocation = t13, r(this._scaleRotate) && (this._scaleRotate.elevationAlignedLocation = t13);
  }
  reset() {
  }
  onHide() {
    r(this._scaleRotate) && this._scaleRotate.cancelActiveAnimation();
  }
  _onScaleChanged() {
    if (t(this._scaleRotate))
      return;
    const t13 = this._scaleRotate.getScale();
    this._moveManipulation.displayScale = t13;
  }
  _updateMoveAngle() {
    this.view.state.viewingMode === l6.Local || this.view.scale < w7 ? this._moveManipulation.angle = this._scaleRotateAdapter.angle : this._moveManipulation.angle = 0;
  }
  _onGeometryChanged() {
    v6(this.view, this, this.graphic);
  }
  _enforceNonZeroSize(t13) {
    return t13 || this.view.state.camera.computeRenderPixelSizeAt(this._moveManipulation.renderLocation);
  }
  get test() {
    return { discManipulator: this._moveManipulation.xyManipulation.test.discManipulator, zManipulator: this._moveManipulation.zManipulation.test.manipulator, ringManipulator: r(this._scaleRotate) ? this._scaleRotate.test.ringManipulator : null, arrowManipulators: this._moveManipulation.xyAxisManipulation.test.arrowManipulators, scaleRotateAdapter: this._scaleRotateAdapter, scaleRotateTransform: this._scaleRotate, tooltip: this._tooltip };
  }
};
e([d({ constructOnly: true, nonNullable: true })], k3.prototype, "view", void 0), e([d({ constructOnly: true, nonNullable: true })], k3.prototype, "graphic", void 0), e([d({ constructOnly: true, nonNullable: true })], k3.prototype, "enableZ", void 0), e([d()], k3.prototype, "enableRotation", void 0), e([d()], k3.prototype, "enableScaling", void 0), e([d({ constructOnly: true, type: r8 })], k3.prototype, "tooltipOptions", void 0), e([d()], k3.prototype, "graphicState", void 0), e([d({ value: false })], k3.prototype, "snapToScene", null), e([d({ constructOnly: true })], k3.prototype, "snappingManager", void 0), e([d({ readOnly: true })], k3.prototype, "type", void 0), e([d({ readOnly: true })], k3.prototype, "updating", null), k3 = e([n3("esri.views.3d.interactive.editingTools.graphicTransform3D.GraphicTransformTool")], k3);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transformGraphic/PreserveAspectRatio.js
var s9 = class {
  constructor() {
    this.lastDragEvent = null, this.next = new G2(), this._enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(a15) {
    if (this._enabled !== a15 && r(this.lastDragEvent)) {
      const t13 = { ...this.lastDragEvent, action: "update" };
      a15 && this._adjustScaleFactors(t13), this.next.execute(t13);
    }
    this._enabled = a15;
  }
  createDragEventPipelineStep() {
    return this.lastDragEvent = null, (t13) => (this.lastDragEvent = "end" !== t13.action ? { ...t13 } : null, this._enabled && this._adjustScaleFactors(t13), t13);
  }
  _adjustScaleFactors(t13) {
    const e11 = lt(t13.handle) ? Math.max(Math.abs(t13.factor1), Math.abs(t13.factor2)) : 0 === t13.handle.direction[0] ? Math.abs(t13.factor2) : Math.abs(t13.factor1);
    t13.factor1 = t13.factor1 < 0 ? -e11 : e11, t13.factor2 = t13.factor2 < 0 ? -e11 : e11;
  }
  get test() {
    return { _adjustScaleFactors: (t13) => this._adjustScaleFactors(t13) };
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/support/editPlaneUtils.js
function S7(s10, o11) {
  return _6(s10, o11, false);
}
function Y(s10, o11) {
  return _6(s10, o11, true);
}
function _6(s10, o11, i10) {
  if (s10 instanceof t6) {
    if (s10.operation instanceof t7)
      return P7(s10.operation, o11, i10), true;
    if (s10.operation instanceof s4)
      return U4(s10.operation, o11, i10), true;
    if (s10.operation instanceof c5)
      return q7(s10.operation, o11, i10), true;
  }
  return false;
}
function P7(s10, o11, i10 = false) {
  const t13 = i10 ? -1 : 1, n12 = r3(t13 * s10.dx, t13 * s10.dy, t13 * s10.dz);
  u(o11.origin, o11.origin, n12);
}
function U4(s10, o11, i10 = false) {
  const t13 = i10 ? -s10.angle : s10.angle;
  T(o11.basis1, o11.basis1, f3, t13), T(o11.basis2, o11.basis2, f3, t13);
}
function q7(s10, o11, t13 = false) {
  const n12 = t13 ? 1 / s10.factor1 : s10.factor1, r15 = t13 ? 1 / s10.factor2 : s10.factor2;
  q(o11.basis1, o11.basis1, n12), q(o11.basis2, o11.basis2, r15), w3(o11.origin, o11.origin, s10.origin, s10.axis1, n12), w3(o11.origin, o11.origin, s10.origin, s10.axis2, r15);
}
function A6(s10, o11, i10, b7) {
  b7 || (b7 = G3());
  const f11 = r5(t5.get(), s10[1], -s10[0]), u7 = r5(t5.get(), Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), m15 = r5(t5.get(), Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), p11 = t5.get();
  o11.components.forEach((o12) => o12.vertices.forEach((o13) => {
    const i11 = o13.pos;
    r5(p11, j3(s10, i11), j3(f11, i11)), f6(u7, u7, p11), M2(m15, m15, p11);
  }));
  const I2 = 1e-6, d14 = r5(t5.get(), m15[0] - u7[0] < I2 ? i10 / 2 : 0, m15[1] - u7[1] < I2 ? i10 / 2 : 0);
  return o5(u7, u7, d14), s2(m15, m15, d14), l4(b7.basis1, s10, (m15[0] - u7[0]) / 2), l4(b7.basis2, f11, (m15[1] - u7[1]) / 2), r5(b7.origin, u7[0] * s10[0] + u7[1] * f11[0], u7[0] * s10[1] + u7[1] * f11[1]), s2(b7.origin, b7.origin, b7.basis1), s2(b7.origin, b7.origin, b7.basis2), b7;
}
function G10(s10, o11, i10, t13 = 0, n12) {
  n12 || (n12 = G3()), o11.toRenderCoords(s10.origin, i10, n12.origin);
  const r15 = c3.get();
  u(r15, s10.origin, s10.basis1), u(r15, r15, s10.basis2), o11.toRenderCoords(r15, i10, r15);
  const a15 = c3.get();
  u(a15, s10.origin, s10.basis1), e3(a15, a15, s10.basis2), o11.toRenderCoords(a15, i10, a15);
  const e11 = c3.get();
  e3(e11, s10.origin, s10.basis1), e3(e11, e11, s10.basis2), o11.toRenderCoords(e11, i10, e11);
  const c10 = c3.get();
  e3(c10, s10.origin, s10.basis1), u(c10, c10, s10.basis2), o11.toRenderCoords(c10, i10, c10);
  const g6 = A2(c3.get(), r15, a15, 0.5);
  e3(g6, g6, n12.origin);
  const f11 = A2(c3.get(), e11, c10, 0.5);
  e3(f11, n12.origin, f11), A2(n12.basis1, g6, f11, 0.5);
  const j8 = A2(c3.get(), c10, r15, 0.5);
  e3(j8, j8, n12.origin);
  const l12 = A2(c3.get(), a15, e11, 0.5);
  e3(l12, n12.origin, l12), A2(n12.basis2, j8, l12, 0.5);
  const x8 = _(c3.get(), n12.basis1, n12.basis2), V4 = _(x8, x8, n12.basis1);
  return z2(V4, V4), q(n12.basis2, V4, P(n12.basis2, V4)), q(n12.basis1, n12.basis1, 1 + t13 / s(n12.basis1)), q(n12.basis2, n12.basis2, 1 + t13 / s(n12.basis2)), H2(n12), n12;
}
function M8(i10, t13, n12, r15) {
  const a15 = c3.get();
  e3(a15, e3(a15, i10.origin, i10.basis1), i10.basis2);
  const e11 = c3.get();
  g(e11, a15, i10.basis1, 2);
  const c10 = c3.get();
  g(c10, e11, i10.basis2, 2);
  const g6 = c3.get();
  g(g6, a15, i10.basis2, 2), a15[2] = e11[2] = c10[2] = g6[2] = t13;
  const b7 = r15 ? "on-the-ground" : "absolute-height", f11 = s5(l8(a15, e11, n12, b7), l8(g6, c10, n12, b7)), u7 = s5(l8(e11, c10, n12, b7), l8(a15, g6, n12, b7));
  return t(u7) || t(f11) ? null : [f11, u7];
}

// node_modules/@arcgis/core/views/interactive/tooltip/ExtentTooltipInfos.js
var i9 = class extends e8 {
  constructor(t13) {
    super(t13), this.type = "extent-rotate", this.angle = 0;
  }
};
e([d()], i9.prototype, "type", void 0), e([d()], i9.prototype, "angle", void 0), i9 = e([n3("esri.views.interactive.tooltip.ExtentRotateTooltipInfo")], i9);
var p10 = class extends e8 {
  constructor(t13) {
    super(t13), this.type = "extent-scale", this.xScale = 0, this.yScale = 0, this.xSize = y2, this.ySize = y2;
  }
};
e([d()], p10.prototype, "type", void 0), e([d()], p10.prototype, "xScale", void 0), e([d()], p10.prototype, "yScale", void 0), e([d()], p10.prototype, "xSize", void 0), e([d()], p10.prototype, "ySize", void 0), p10 = e([n3("esri.views.interactive.tooltip.ExtentScaleTooltipInfo")], p10);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transformGraphic/ExtentTransformTool.js
var Zt = class extends n5.EventedMixin(c7) {
  constructor(t13) {
    super(t13), this.enableZ = true, this.enableRotation = true, this.enableScaling = true, this.tooltipOptions = new r8(), this._preserveAspectRatio = new s9(), this.grabbing = false, this.inputState = null, this.type = "transform-3d", this.handles = new u2(), this.moveZManipulator = null, this.resizeManipulators = null, this.rotateManipulator = null, this.attachmentOrigin = null, this.outlineVisualElement = null, this.mapBounds = G3(), this.mapBoundsStart = G3(), this.zmax = 0, this.sizeStart = null, this.displayBounds = G3(), this.displayBoundsStart = G3(), this.displayBoundsMarginStart = 0, this.resizeHandles = [{ direction: [1, 0] }, { direction: [1, 1] }, { direction: [0, 1] }, { direction: [-1, 1] }, { direction: [-1, 0] }, { direction: [-1, -1] }, { direction: [0, -1] }, { direction: [1, -1] }], this._moveXYTooltipInfo = null, this._moveZTooltipInfo = null, this._rotateTooltipInfo = null, this._scaleTooltipInfo = null, this._startAngle = 0, this._endAngle = 0, this._startScale = n6(), this._endScale = n6();
  }
  initialize() {
    const { view: t13, graphic: e11, manipulators: i10, handles: s10 } = this, r15 = this.graphicState = new e9({ graphic: e11 }), n12 = e11.geometry;
    this.editGeometryOperations = S.fromGeometry(n12, t13.state.viewingMode), this.graphicMoveManipulation = new l11({ tool: this, view: t13, graphicState: r15 }), this.moveZManipulator = ut(t13, Ut.CENTER_ON_CALLOUT), this.moveZManipulator.state |= kt, s10.add([this._createMoveXYGraphicDragPipeline(), l3(() => this.enableZ, () => this._updateManipulatorAvailability(this.moveZManipulator, A4.TRANSLATE_Z)), this._createMoveZDragPipeline()]), i10.add(this.moveZManipulator), this.resizeManipulators = this.resizeHandles.map((e12) => {
      const i11 = gt(t13, e12);
      return s10.add([l3(() => this.enableScaling, () => this._updateManipulatorAvailability(i11, A4.SCALE)), i11.events.on("grab-changed", (t14) => this._onResizeGrab(t14)), this._createResizeDragPipeline(i11, e12)]), i11;
    }), i10.addMany(this.resizeManipulators), this.rotateManipulatorTexture = o8(t13.toolViewManager.textures), this.rotateManipulator = dt(t13, this.rotateManipulatorTexture.texture), s10.add([l3(() => this.enableRotation, () => this._updateManipulatorAvailability(this.rotateManipulator, A4.ROTATE)), this.rotateManipulator.events.on("grab-changed", (t14) => {
      this._onRotateGrab(t14);
    }), this._createRotateDragPipeline(this.rotateManipulator)]), i10.add(this.rotateManipulator), this._calculateMapBounds(), this._updateDisplayBounds();
    const p11 = i5({ view: t13, graphic: e11, forEachManipulator: (t14) => this._forEachManipulator(t14), onManipulatorsChanged: () => n2() });
    r(p11) && (this.outlineVisualElement = p11.visualElement instanceof S3 ? p11.visualElement : null), r(this.outlineVisualElement) && s10.add(this.outlineVisualElement.events.on("attachment-origin-changed", () => this._updateDisplayBounds())), s10.add(p11), s10.add([r15.on("changed", () => this._onGeometryChanged()), l3(() => r15.displaying, () => this._updateAllManipulatorAvailability()), l3(() => r15.isDraped, () => this._graphicDrapedChanged(), h), t13.trackGraphicState(r15)]);
    const l12 = t13.pointsOfInterest;
    l12 && s10.add(l3(() => l12.centerOnSurfaceFrequent.location, () => this._updateDisplayBounds()));
    const d14 = (t14) => {
      s10.add(t14.events.on("grab-changed", () => {
        this.grabbing = t14.grabbing, this._updateAllManipulatorAvailability();
      }));
    };
    this._forEachManipulator(d14);
    const u7 = (t14, i11) => {
      s10.add(t14.events.on("immediate-click", (t15) => {
        i11 === A4.TRANSLATE_XY && this.emit("immediate-click", { ...t15, graphic: e11 }), t15.stopPropagation();
      }));
    };
    this._forEachManipulator(u7), this._onGeometryChanged(), this._updateAllManipulatorAvailability(), this._initializeTooltip(), this.finishToolCreation();
  }
  destroy() {
    this.mapBounds = null, this.displayBounds = null, this.rotateManipulatorTexture.release(), this.handles.destroy(), this.graphicMoveManipulation.destroy(), this.editGeometryOperations.destroy(), this._tooltip.destroy(), this._set("view", null), this._set("graphic", null);
  }
  _initializeTooltip() {
    const { handles: t13, view: e11 } = this, i10 = this._tooltip = new m4({ view: e11 }), a15 = () => {
      i10.info = this._getUpdatedTooltipInfo();
    };
    t13.add([this.on("graphic-translate-start", a15), this.on("graphic-translate", a15), this.on("graphic-translate-stop", () => {
      this._moveXYTooltipInfo = null, this._moveZTooltipInfo = null, this._tooltip.clear();
    }), this.on("graphic-rotate-start", (t14) => {
      this._startAngle = t14.angle, a15();
    }), this.on("graphic-rotate", (t14) => {
      this._endAngle = t14.angle, a15();
    }), this.on("graphic-rotate-stop", () => {
      this._startAngle = 0, this._endAngle = 0, a15();
    }), this.on("graphic-scale-start", (t14) => {
      r5(this._startScale, t14.xScale, t14.yScale), r5(this._endScale, t14.xScale, t14.yScale), a15();
    }), this.on("graphic-scale", (t14) => {
      r5(this._endScale, t14.xScale, t14.yScale), a15();
    }), this.on("graphic-scale-stop", () => {
      r5(this._startScale, 0, 0), r5(this._endScale, 0, 0), a15();
    })]), this._forEachManipulator((e12) => {
      t13.add([e12.events.on("focus-changed", a15), e12.events.on("grab-changed", a15), e12.events.on("drag", (t14) => {
        "cancel" === t14.action ? this._tooltip.clear() : a15();
      })]);
    });
  }
  _getUpdatedTooltipInfo() {
    return this.tooltipOptions.enabled ? this.graphicMoveManipulation.grabbing || this.graphicMoveManipulation.dragging ? this._computeMoveXYTooltipInfo() : this.moveZManipulator.focused ? this._computeMoveZTooltipInfo() : this.rotateManipulator.focused ? this._computeRotateTooltipInfo() : this.resizeManipulators.some((t13) => t13.focused) ? this._computeScaleTooltipInfo() : null : null;
  }
  _computeMoveXYTooltipInfo() {
    return this._moveXYTooltipInfo = c(this._moveXYTooltipInfo, () => new i7({ tooltipOptions: this.tooltipOptions }));
  }
  _computeMoveZTooltipInfo() {
    const t13 = this._moveZTooltipInfo = c(this._moveZTooltipInfo, () => new p7({ tooltipOptions: this.tooltipOptions })), e11 = this._moveUnit;
    if (this.moveZManipulator.dragging) {
      const e12 = this.mapBoundsStart.origin, i10 = this.mapBounds.origin, a15 = g2(e12, i10, this.view.spatialReference);
      if (t(a15))
        return null;
      t13.distance = a15;
    } else
      t13.distance = o7(0, e11);
    return t13;
  }
  _computeRotateTooltipInfo() {
    const t13 = this._rotateTooltipInfo = c(this._rotateTooltipInfo, () => new i9({ tooltipOptions: this.tooltipOptions }));
    return t13.angle = this._startAngle - this._endAngle, t13;
  }
  _computeScaleTooltipInfo() {
    const t13 = this.graphic.geometry;
    if (t(t13))
      return null;
    const e11 = this._scaleTooltipInfo = c(this._scaleTooltipInfo, () => new p10({ tooltipOptions: this.tooltipOptions })), i10 = M8(this.mapBounds, this.zmax, t13.spatialReference, this.graphicState.isDraped);
    return t(i10) ? null : (e11.xSize = i10[0], e11.ySize = i10[1], r(this.sizeStart) && this.resizeManipulators.some((t14) => t14.dragging) ? (e11.xScale = i10[0].value / this.sizeStart[0].value, e11.yScale = i10[1].value / this.sizeStart[1].value) : (e11.xScale = 1, e11.yScale = 1), e11);
  }
  _graphicDrapedChanged() {
    this.handles.remove(Ct), this._updateDisplayBounds(), this.graphicState.isDraped && this.handles.add(this.view.elevationProvider.on("elevation-change", (t13) => {
      r(this.attachmentOrigin) && w2(t13.extent, this.attachmentOrigin.x, this.attachmentOrigin.y) && this._updateDisplayBounds();
    }), Ct);
  }
  _updateAllManipulatorAvailability() {
    this._forEachManipulator((t13, e11) => this._updateManipulatorAvailability(t13, e11));
  }
  _updateManipulatorAvailability(t13, e11) {
    const i10 = this.grabbing && !t13.grabbing;
    if (t13.interactive = !i10, t13 instanceof te) {
      const a15 = this.graphicState.displaying, s10 = this.enableZ && t10(this.graphic);
      switch (e11) {
        case A4.ROTATE:
          t13.available = a15 && this.enableRotation;
          break;
        case A4.SCALE:
          t13.available = a15 && (this.enableScaling || this.enableRotation || s10), t13.interactive = !i10 && this.enableScaling, t13.state = this.enableScaling ? Nt : vt;
          break;
        case A4.TRANSLATE_Z:
          t13.available = a15 && s10;
          break;
        default:
          t13.available = a15;
      }
    }
  }
  _forEachManipulator(t13) {
    this.graphicMoveManipulation.forEachManipulator(t13), this.resizeManipulators.forEach((e11) => t13(e11, A4.SCALE)), t13(this.rotateManipulator, A4.ROTATE), t13(this.moveZManipulator, A4.TRANSLATE_Z);
  }
  get preserveAspectRatio() {
    return this._preserveAspectRatio.enabled;
  }
  set preserveAspectRatio(t13) {
    this._preserveAspectRatio.enabled = t13, this._set("preserveAspectRatio", t13);
  }
  get _moveUnit() {
    return c(ee(this.view.spatialReference), "meters");
  }
  reset() {
  }
  _onGeometryChanged() {
    this._updateDisplayBounds();
  }
  _calculateMapBounds() {
    const t13 = this.graphic.geometry, e11 = this.editGeometryOperations.data, i10 = e11.components[0].edges[0], a15 = o5(t5.get(), i10.leftVertex.pos, i10.rightVertex.pos);
    v2(a15, a15);
    const s10 = c(F2(this.view, this.graphic), () => t13.extent.center);
    let o11 = Xt * this.view.pixelSizeAt(s10);
    const n12 = this.view.spatialReference, p11 = t13.spatialReference;
    n12.equals(p11) || (o11 *= z(n12) / z(p11)), A6(a15, e11, o11, this.mapBounds), this._calculateZMax();
  }
  _calculateZMax() {
    const t13 = this.editGeometryOperations.data;
    if (!t13.geometry.hasZ)
      return void (this.zmax = 0);
    const e11 = t13.coordinateHelper;
    let i10 = Number.NEGATIVE_INFINITY;
    for (const a15 of t13.components)
      for (const t14 of a15.vertices) {
        const a16 = e11.getZ(t14.pos);
        i10 = Math.max(a16, i10);
      }
    this.zmax = i10;
  }
  _updateDisplayBounds() {
    const t13 = this.graphic.geometry;
    if (t(t13))
      return;
    const e11 = r(this.outlineVisualElement) && !this.graphicState.isDraped && r(this.outlineVisualElement.attachmentOrigin) ? this.outlineVisualElement.attachmentOrigin : F2(this.view, this.graphic);
    this.attachmentOrigin = c(e11, t13.extent.center);
    const i10 = r(e11) ? e11.z : m7(this.mapBounds.origin, this.view.elevationProvider, h5.fromElevationInfo(u4(this.graphic)), this.view.renderCoordsHelper), a15 = X2(this.mapBounds);
    a15.origin[2] = i10, G10(a15, this.view.renderCoordsHelper, t13.spatialReference, this.displayBoundsMargin, this.displayBounds), this._updateManipulators();
  }
  get displayBoundsMargin() {
    const t13 = this.view.pointsOfInterest, e11 = t13 ? t13.centerOnSurfaceFrequent.location : this.editGeometryOperations.data.geometry.extent.center;
    return kt3 * this.view.pixelSizeAt(e11);
  }
  _createMoveXYGraphicDragPipeline() {
    return this.graphicMoveManipulation.createDragPipeline((t13, e11, i10) => this._applyGraphicMoveSteps(e11, i10, d11.XY));
  }
  _createMoveZDragPipeline() {
    const t13 = this.view, e11 = this.editGeometryOperations.data.spatialReference;
    return p4(this.moveZManipulator, (i10, a15, s10) => {
      const o11 = t3(i10.renderLocation), r15 = a15.next(G5(t13, o11, e11)).next(b3());
      this._applyGraphicMoveSteps(r15, s10, d11.Z);
    });
  }
  _applyGraphicMoveSteps(t13, e11, i10) {
    const a15 = t13.next((t14) => ("start" === t14.action && (this.inputState = { type: "move" }, X2(this.mapBounds, this.mapBoundsStart), this._calculateSizeStart(), this.emit("graphic-translate-start", { graphic: this.graphic, dxScreen: t14.screenDeltaX, dyScreen: t14.screenDeltaY })), t14)).next(D2()).next(this._moveDragUpdateGeometry()).next((t14) => {
      const e12 = { graphic: this.graphic, dxScreen: t14.screenDeltaX, dyScreen: t14.screenDeltaY };
      switch (t14.action) {
        case "start":
        case "update":
          (t14.mapEnd.x - t14.mapStart.x || t14.mapEnd.y - t14.mapStart.y || t14.mapEnd.z - t14.mapStart.z) && this.emit("graphic-translate", e12);
          break;
        case "end":
          this.inputState = null, this.emit("graphic-translate-stop", e12);
      }
      return t14;
    }).next((t14) => this._updateMoveTooltip(t14, i10));
    return e11.next(() => {
      r(this.inputState) && this.emit("graphic-translate-stop", { graphic: this.graphic, dxScreen: 0, dyScreen: 0 }), this._cancel();
    }), a15;
  }
  _calculateSizeStart() {
    t(this.graphic.geometry) ? this.sizeStart = null : this.sizeStart = M8(this.mapBoundsStart, this.zmax, this.graphic.geometry.spatialReference, this.graphicState.isDraped);
  }
  _moveDragUpdateGeometry() {
    return (t13) => {
      if (t(this.inputState) || "move" !== this.inputState.type)
        return t13;
      const e11 = [];
      for (const s10 of this.editGeometryOperations.data.components)
        e11.push(...s10.vertices);
      const i10 = "start" === t13.action ? E.NEW_STEP : E.ACCUMULATE_STEPS, a15 = this.editGeometryOperations.moveVertices(e11, t13.mapDeltaX, t13.mapDeltaY, t13.mapDeltaZ, i10);
      return S7(a15, this.mapBounds), this.graphic.geometry = this.editGeometryOperations.data.geometry, t13;
    };
  }
  _updateMoveTooltip(t13, e11) {
    if (e11 === d11.XY || e11 === d11.XY_AXIS) {
      const e12 = d9(t13.mapStart, t13.mapEnd, this.graphicState.isDraped ? "on-the-ground" : "absolute-height");
      r(e12) && r(this._moveXYTooltipInfo) && (this._moveXYTooltipInfo.distance = e12);
    }
    return t13;
  }
  _onResizeGrab(t13) {
    if ("start" !== t13.action)
      return;
    const e11 = this._calculatePickRay(t13.screenPoint);
    q4(this.displayBounds.plane, e11, c3.get()) && (X2(this.displayBounds, this.displayBoundsStart), X2(this.mapBounds, this.mapBoundsStart), this._calculateSizeStart(), this.displayBoundsMarginStart = this.displayBoundsMargin, this.inputState = { type: "resize" });
  }
  _createResizeDragPipeline(t13, e11) {
    return p4(t13, (t14, i10, a15) => {
      t(this.inputState) || (i10.next((t15) => ("start" === t15.action && this.emit("graphic-scale-start", { graphic: this.graphic, xScale: 1, yScale: 1 }), t15)).next(C2(this.view, this.displayBoundsStart.plane)).next((t15) => ({ ...t15, handle: e11 })).next(this._resizeDragRenderPlaneToFactors()).next(this._preserveAspectRatio.createDragEventPipelineStep(), this._preserveAspectRatio.next).next(this._resizeDragUpdateGeometry()).next((t15) => {
        const e12 = { graphic: this.graphic, xScale: t15.factor1, yScale: t15.factor2 };
        switch (t15.action) {
          case "start":
          case "update":
            this.emit("graphic-scale", e12);
            break;
          case "end":
            this.inputState = null, this.emit("graphic-scale-stop", e12);
        }
        return t15;
      }), a15.next(() => {
        r(this.inputState) && this.emit("graphic-scale-stop", { graphic: this.graphic, xScale: 1, yScale: 1 }), this._cancel();
      }));
    });
  }
  _resizeDragRenderPlaneToFactors() {
    return (t13) => {
      const e11 = this.displayBoundsStart, i10 = t13.handle.direction, a15 = this.displayBoundsMargin, s10 = this.displayBoundsMarginStart, o11 = r4(c3.get(), e11.origin);
      g(o11, o11, e11.basis1, -i10[0]), g(o11, o11, e11.basis2, -i10[1]);
      const r15 = e3(c3.get(), t13.renderEnd, o11), n12 = e3(c3.get(), t13.renderStart, o11), p11 = lt(t13.handle), l12 = ct(e11), h10 = ct(this.displayBounds) / l12, c10 = (t14, e12) => {
        if (0 === t14)
          return 1;
        let i11 = s(e12), o12 = 0.5 * t14 * P(e12, r15) / i11;
        const l13 = o12 < 0 ? -1 : 1;
        if (p11) {
          o12 += (i11 - 0.5 * t14 * P(e12, n12) / i11) * l13 * h10;
        }
        const c11 = i11 < 1.5 * s10 ? 1 : Yt;
        return i11 = Math.max(i11 - s10, Yt), l13 > 0 && (o12 -= a15), l13 * Math.max(l13 * (o12 / i11), c11);
      };
      return { ...t13, factor1: c10(i10[0], e11.basis1), factor2: c10(i10[1], e11.basis2) };
    };
  }
  _resizeDragUpdateGeometry() {
    return (t13) => {
      const e11 = r4(n4(), this.mapBoundsStart.origin);
      g(e11, e11, this.mapBoundsStart.basis1, -t13.handle.direction[0]), g(e11, e11, this.mapBoundsStart.basis2, -t13.handle.direction[1]);
      const i10 = r5(n6(), this.mapBoundsStart.basis1[0], this.mapBoundsStart.basis1[1]);
      v2(i10, i10);
      const a15 = [];
      for (const r15 of this.editGeometryOperations.data.components)
        a15.push(...r15.vertices);
      const s10 = "start" === t13.action ? E.NEW_STEP : E.ACCUMULATE_STEPS, o11 = this.editGeometryOperations.scaleVertices(a15, e11, i10, t13.factor1, t13.factor2, s10, e6.REPLACE);
      return X2(this.mapBoundsStart, this.mapBounds), S7(o11, this.mapBounds), this.graphic.geometry = this.editGeometryOperations.data.geometry, t13;
    };
  }
  _onRotateGrab(t13) {
    if ("start" !== t13.action)
      return;
    const e11 = Ke(this.displayBounds, this.view.renderCoordsHelper, Lt.HEADING, p3()), i10 = this._calculatePickRay(t13.screenPoint);
    q4(e11, i10, c3.get()) && (X2(this.displayBounds, this.displayBoundsStart), X2(this.mapBounds, this.mapBoundsStart), this._calculateSizeStart(), this.inputState = { type: "rotate", rotatePlane: e11 });
  }
  _createRotateDragPipeline(t13) {
    return p4(t13, (t14, e11, i10) => {
      const a15 = this.inputState;
      t(a15) || (e11.next((t15) => ("start" === t15.action && this.emit("graphic-rotate-start", { graphic: this.graphic, angle: 0 }), t15)).next(C2(this.view, a15.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a15)).next(this._rotateDragUpdateGeometry()).next((t15) => {
        const e12 = { graphic: this.graphic, angle: m2(t15.rotateAngle) };
        switch (t15.action) {
          case "start":
          case "update":
            this.emit("graphic-rotate", e12);
            break;
          case "end":
            this.inputState = null, this.emit("graphic-rotate-stop", e12);
        }
        return t15;
      }), i10.next(() => {
        r(this.inputState) && this.emit("graphic-rotate-stop", { graphic: this.graphic, angle: 0 }), this._cancel();
      }));
    });
  }
  _rotateDragRenderPlaneToRotate(t13) {
    return (e11) => {
      const i10 = Z(t13.rotatePlane), a15 = O2(e11.renderStart, e11.renderEnd, this.displayBounds.origin, i10);
      return { ...e11, rotateAxis: i10, rotateAngle: a15 };
    };
  }
  _rotateDragUpdateGeometry() {
    return (t13) => {
      const e11 = r4(n4(), this.mapBoundsStart.origin), i10 = [];
      for (const o11 of this.editGeometryOperations.data.components)
        i10.push(...o11.vertices);
      const a15 = "start" === t13.action ? E.NEW_STEP : E.ACCUMULATE_STEPS, s10 = this.editGeometryOperations.rotateVertices(i10, e11, t13.rotateAngle, a15, e6.REPLACE);
      return X2(this.mapBoundsStart, this.mapBounds), S7(s10, this.mapBounds), this.graphic.geometry = this.editGeometryOperations.data.geometry, t13;
    };
  }
  _calculatePickRay(t13) {
    const e11 = d4(), i10 = d2(t13);
    return s6(this.view.state.camera, i10, e11), z2(e11.direction, e11.direction), e11;
  }
  _updateManipulators() {
    if (!this.visible)
      return;
    const t13 = Je(this.displayBounds, f7.get());
    rt(this.rotateManipulator, t13, this.displayBounds, this.view.renderCoordsHelper), this._updateZMoveHandle(this.moveZManipulator, t13), this.resizeManipulators.forEach((e11, i10) => {
      tt(e11, this.resizeHandles[i10], t13, this.displayBounds);
    });
  }
  _updateZMoveHandle(t13, e11) {
    const i10 = this.displayBounds, a15 = { basis: i10.basis1, direction: -1, position: e3(c3.get(), i10.origin, i10.basis1), edge: 2 }, s10 = f7.get();
    m3(s10, e11, a15.edge * Math.PI / 2), s10[12] = 0, s10[13] = 0, s10[14] = 0, t13.modelTransform = s10, t13.renderLocation = a15.position;
  }
  _cancel() {
    const t13 = this.editGeometryOperations.lastOperation;
    t(t13) || (this.editGeometryOperations.undo(), this.graphic.geometry = this.editGeometryOperations.data.geometry, Y(t13, this.mapBounds), this._updateDisplayBounds(), this.inputState = null);
  }
  get canUndo() {
    return this.editGeometryOperations.canUndo;
  }
  undo() {
    if (r(this.inputState))
      this.view.activeTool = null;
    else if (this.canUndo) {
      const t13 = this.editGeometryOperations.undo();
      this.graphic.geometry = this.editGeometryOperations.data.geometry, Y(e2(t13), this.mapBounds), this._updateDisplayBounds();
    }
  }
  get canRedo() {
    return this.editGeometryOperations.canRedo;
  }
  redo() {
    if (this.canRedo) {
      const t13 = this.editGeometryOperations.redo();
      this.graphic.geometry = this.editGeometryOperations.data.geometry, S7(e2(t13), this.mapBounds), this._updateDisplayBounds();
    }
  }
  get test() {
    return { resizeManipulators: this.resizeManipulators, rotateManipulator: this.rotateManipulator, moveZManipulator: this.moveZManipulator, tooltip: this._tooltip };
  }
};
e([d({ constructOnly: true, nonNullable: true })], Zt.prototype, "view", void 0), e([d({ constructOnly: true, nonNullable: true })], Zt.prototype, "graphic", void 0), e([d({ constructOnly: true, nonNullable: true })], Zt.prototype, "enableZ", void 0), e([d()], Zt.prototype, "enableRotation", void 0), e([d()], Zt.prototype, "enableScaling", void 0), e([d({ constructOnly: true, type: r8 })], Zt.prototype, "tooltipOptions", void 0), e([d()], Zt.prototype, "preserveAspectRatio", null), e([d()], Zt.prototype, "grabbing", void 0), e([d()], Zt.prototype, "inputState", void 0), e([d({ readOnly: true })], Zt.prototype, "type", void 0), e([d()], Zt.prototype, "_moveUnit", null), Zt = e([n3("esri.views.3d.interactive.editingTools.graphicTransform3D.ExtentTransformTool")], Zt);
var Ct = "draped-elevation-changes";
var kt3 = 10;
var Xt = 80;
var Yt = 1e-6;
export {
  S5 as DrawGraphicTool3D,
  Zt as ExtentTransformTool,
  F4 as GraphicMoveTool,
  v9 as GraphicReshapeTool,
  k3 as GraphicTransformTool
};
//# sourceMappingURL=editingTools-QRSMERL7.js.map
