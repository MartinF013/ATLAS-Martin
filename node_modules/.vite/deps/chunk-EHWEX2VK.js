import {
  F,
  a,
  i
} from "./chunk-HPO2NV7P.js";
import {
  t as t3
} from "./chunk-22O7HU3A.js";
import {
  _e
} from "./chunk-Y75V5CF3.js";
import {
  r as r2
} from "./chunk-7LH2XNVI.js";
import {
  g
} from "./chunk-7OZR6JFF.js";
import {
  c as c2,
  l as l2
} from "./chunk-5EPJG7SL.js";
import {
  c as c3
} from "./chunk-MDCKEJ7B.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  e
} from "./chunk-YFBAFAZ2.js";
import {
  H
} from "./chunk-YZNDHJDJ.js";
import {
  l as l3
} from "./chunk-ZN2MGN4S.js";
import {
  Un,
  ne,
  qn
} from "./chunk-PZWU5EHT.js";
import {
  _,
  l
} from "./chunk-U7B2WKBH.js";
import {
  n as n2
} from "./chunk-ASC3X65B.js";
import {
  n as n3
} from "./chunk-P6G64ARX.js";
import {
  p
} from "./chunk-RN2KRYDN.js";
import {
  o
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";
import {
  c,
  r,
  t,
  t3 as t2
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/elevationAlignmentUtils.js
function f(e2, t5, n4, o2, r4, s, a3, l4, c4, u, f2) {
  const d3 = O2[f2.mode];
  let m2, p3, g3 = 0;
  if (Un(e2, t5, n4, o2, c4.spatialReference, r4, l4))
    return d3.requiresAlignment(f2) ? (g3 = d3.applyElevationAlignmentBuffer(o2, r4, s, a3, l4, c4, u, f2), m2 = s, p3 = a3) : (m2 = o2, p3 = r4), Un(m2, c4.spatialReference, p3, s, u.spatialReference, a3, l4) ? g3 : void 0;
}
function d(n4, o2, r4, i2, s) {
  const l4 = (t3(n4) ? n4.z : a(n4) ? n4.array[n4.offset + 2] : n4[2]) || 0;
  switch (r4.mode) {
    case "on-the-ground": {
      const e2 = c(i(o2, n4, "ground"), 0);
      return s.verticalDistanceToGround = 0, s.sampledElevation = e2, void (s.z = e2);
    }
    case "relative-to-ground": {
      const e2 = c(i(o2, n4, "ground"), 0), a3 = r4.geometryZWithOffset(l4, i2);
      return s.verticalDistanceToGround = a3, s.sampledElevation = e2, void (s.z = a3 + e2);
    }
    case "relative-to-scene": {
      const e2 = c(i(o2, n4, "scene"), 0), a3 = r4.geometryZWithOffset(l4, i2);
      return s.verticalDistanceToGround = a3, s.sampledElevation = e2, void (s.z = a3 + e2);
    }
    case "absolute-height": {
      const e2 = r4.geometryZWithOffset(l4, i2), a3 = c(i(o2, n4, "ground"), 0);
      return s.verticalDistanceToGround = e2 - a3, s.sampledElevation = a3, void (s.z = e2);
    }
    default:
      return n3(r4.mode), void (s.z = 0);
  }
}
function m(e2, t5, n4, o2) {
  return d(e2, t5, n4, o2, z), z.z;
}
function p2(e2, t5, n4) {
  return null == t5 || null == n4 ? e2.definedChanged : "on-the-ground" === t5 && "on-the-ground" === n4 ? e2.staysOnTheGround : t5 === n4 || "on-the-ground" !== t5 && "on-the-ground" !== n4 ? x.UPDATE : e2.onTheGroundChanged;
}
function g2(e2) {
  return "relative-to-ground" === e2 || "relative-to-scene" === e2;
}
function v(e2) {
  return "absolute-height" !== e2;
}
function h(e2, t5, o2, r4, i2) {
  d(t5, o2, i2, r4, z), F(e2, z.verticalDistanceToGround);
  const a3 = z.sampledElevation, c4 = n2(U, e2.transformation);
  C[0] = t5.x, C[1] = t5.y, C[2] = z.z;
  return qn(t5.spatialReference, C, c4, r4.spatialReference) ? e2.transformation = c4 : console.warn("Could not locate symbol object properly, it might be misplaced"), a3;
}
function E(e2, n4, o2, r4, i2, s) {
  let a3 = 0;
  const l4 = s.spatialReference;
  n4 *= 3, r4 *= 3;
  for (let c4 = 0; c4 < i2; ++c4) {
    const i3 = e2[n4 + 0], c5 = e2[n4 + 1], u = e2[n4 + 2], f2 = c(s.getElevation(i3, c5, u, l4, "ground"), 0);
    a3 += f2, o2[r4 + 0] = i3, o2[r4 + 1] = c5, o2[r4 + 2] = f2, n4 += 3, r4 += 3;
  }
  return a3 / i2;
}
function y(e2, n4, o2, r4, i2, s, a3, l4) {
  let c4 = 0;
  const u = l4.calculateOffsetRenderUnits(a3), f2 = l4.featureExpressionInfoContext, d3 = s.spatialReference;
  n4 *= 3, r4 *= 3;
  for (let m2 = 0; m2 < i2; ++m2) {
    const i3 = e2[n4 + 0], a4 = e2[n4 + 1], l5 = e2[n4 + 2], m3 = c(s.getElevation(i3, a4, l5, d3, "ground"), 0);
    c4 += m3, o2[r4 + 0] = i3, o2[r4 + 1] = a4, o2[r4 + 2] = null == f2 ? l5 + m3 + u : m3 + u, n4 += 3, r4 += 3;
  }
  return c4 / i2;
}
function A(e2, n4, o2, r4, i2, s, a3, l4) {
  let c4 = 0;
  const u = l4.calculateOffsetRenderUnits(a3), f2 = l4.featureExpressionInfoContext, d3 = s.spatialReference;
  n4 *= 3, r4 *= 3;
  for (let m2 = 0; m2 < i2; ++m2) {
    const i3 = e2[n4 + 0], a4 = e2[n4 + 1], l5 = e2[n4 + 2], m3 = c(s.getElevation(i3, a4, l5, d3, "scene"), 0);
    c4 += m3, o2[r4 + 0] = i3, o2[r4 + 1] = a4, o2[r4 + 2] = null == f2 ? l5 + m3 + u : m3 + u, n4 += 3, r4 += 3;
  }
  return c4 / i2;
}
function R(e2) {
  const t5 = e2.meterUnitOffset, n4 = e2.featureExpressionInfoContext;
  return 0 !== t5 || null != n4;
}
function T(e2, t5, n4, o2, r4, i2, s, a3) {
  const l4 = a3.calculateOffsetRenderUnits(s), c4 = a3.featureExpressionInfoContext;
  t5 *= 3, o2 *= 3;
  for (let u = 0; u < r4; ++u) {
    const r5 = e2[t5 + 0], i3 = e2[t5 + 1], s2 = e2[t5 + 2];
    n4[o2 + 0] = r5, n4[o2 + 1] = i3, n4[o2 + 2] = null == c4 ? s2 + l4 : l4, t5 += 3, o2 += 3;
  }
  return 0;
}
var j = class {
  constructor() {
    this.verticalDistanceToGround = 0, this.sampledElevation = 0, this.z = 0;
  }
};
var x;
!function(e2) {
  e2[e2.NONE = 0] = "NONE", e2[e2.UPDATE = 1] = "UPDATE", e2[e2.RECREATE = 2] = "RECREATE";
}(x || (x = {}));
var O2 = { "absolute-height": { applyElevationAlignmentBuffer: T, requiresAlignment: R }, "on-the-ground": { applyElevationAlignmentBuffer: E, requiresAlignment: () => true }, "relative-to-ground": { applyElevationAlignmentBuffer: y, requiresAlignment: () => true }, "relative-to-scene": { applyElevationAlignmentBuffer: A, requiresAlignment: () => true } };
var U = e();
var z = new j();
var C = n();

// node_modules/@arcgis/core/views/3d/layers/graphics/constants.js
var r3 = 1.2;
var t4 = l;
var a2 = _;

// node_modules/@arcgis/core/views/3d/layers/graphics/lineUtils.js
function O3(t5) {
  const e2 = [], o2 = [];
  I(t5, o2, e2);
  const n4 = o2[0][1].data, r4 = e2[0][1].length, i2 = new Uint16Array(r4);
  return j2(t5, o2, e2), S(t5, o2, e2, i2), w(t5, o2, e2, i2), U2(t5, o2, e2, i2), F2(t5, o2, e2, i2), v2(t5, o2, e2, i2), C2(t5, o2, e2, n4), new g(o2, e2, c3.Line);
}
function R2(t5, e2, o2, n4) {
  const r4 = "polygon" === t5.type ? c2.CCW_IS_HOLE : c2.NONE, i2 = "polygon" === t5.type ? t5.rings : t5.paths, { position: a3, outlines: s } = l2(i2, t5.hasZ, r4), u = new Float64Array(a3.length), c4 = f(a3, t5.spatialReference, 0, u, 0, a3, 0, a3.length / 3, e2, o2, n4), f2 = null != c4;
  return { lines: f2 ? b(s, a3, u) : [], projectionSuccess: f2, sampledElevation: c4 };
}
function b(t5, e2, o2) {
  const n4 = new Array();
  for (const { index: r4, count: i2 } of t5) {
    if (i2 <= 1)
      continue;
    const t6 = 3 * r4, a3 = t6 + 3 * i2;
    n4.push({ position: e2.subarray(t6, a3), mapPosition: o2 ? o2.subarray(t6, a3) : void 0 });
  }
  return n4;
}
function d2(t5, e2) {
  const o2 = "polygon" === t5.type ? c2.CCW_IS_HOLE : c2.NONE, n4 = "polygon" === t5.type ? t5.rings : t5.paths, { position: r4, outlines: i2 } = l2(n4, false, o2), a3 = Un(r4, t5.spatialReference, 0, r4, e2, 0, r4.length / 3);
  for (let s = 2; s < r4.length; s += 3)
    r4[s] = _e;
  return { lines: a3 ? b(i2, r4) : [], projectionSuccess: a3 };
}
function I(t5, e2, o2) {
  const { attributeData: { position: r4 }, removeDuplicateStartEnd: i2 } = t5, a3 = D(r4) && i2 === P.REMOVE, s = r4.length / 3 - (a3 ? 1 : 0), u = new Uint32Array(2 * (s - 1)), c4 = a3 ? t2(r4, 0, r4.length - 3) : r4;
  let l4 = 0;
  for (let n4 = 0; n4 < s - 1; n4++)
    u[l4++] = n4, u[l4++] = n4 + 1;
  e2.push([O.POSITION, { size: 3, data: c4, exclusive: a3 }]), o2.push([O.POSITION, u]);
}
function j2(e2, o2, n4) {
  const r4 = e2.attributeData.mapPosition;
  t(r4) || (n4.push([O.MAPPOS, n4[0][1]]), o2.push([O.MAPPOS, { size: 3, data: r4 }]));
}
function S(t5, n4, r4, i2) {
  if (r(t5.attributeData.colorFeature))
    return;
  const a3 = t5.attributeData.color;
  n4.push([O.COLOR, { size: 4, data: c(a3, a2) }]), r4.push([O.COLOR, i2]);
}
function U2(e2, o2, n4, r4) {
  const i2 = e2.attributeData.colorFeature;
  t(i2) || (o2.push([O.COLORFEATUREATTRIBUTE, { size: 1, data: new Float32Array([i2]) }]), n4.push([O.COLOR, r4]));
}
function w(t5, n4, r4, i2) {
  if (r(t5.attributeData.sizeFeature))
    return;
  const a3 = t5.attributeData.size;
  n4.push([O.SIZE, { size: 1, data: [c(a3, 1)] }]), r4.push([O.SIZE, i2]);
}
function F2(e2, o2, n4, r4) {
  const i2 = e2.attributeData.sizeFeature;
  t(i2) || (o2.push([O.SIZEFEATUREATTRIBUTE, { size: 1, data: new Float32Array([i2]) }]), n4.push([O.SIZEFEATUREATTRIBUTE, r4]));
}
function v2(e2, o2, n4, r4) {
  const i2 = e2.attributeData.opacityFeature;
  t(i2) || (o2.push([O.OPACITYFEATUREATTRIBUTE, { size: 1, data: new Float32Array([i2]) }]), n4.push([O.OPACITYFEATUREATTRIBUTE, r4]));
}
function C2(e2, o2, n4, a3) {
  if (t(e2.overlayInfo) || e2.overlayInfo.renderCoordsHelper.viewingMode !== l3.Global || !e2.overlayInfo.spatialReference.isGeographic)
    return;
  const s = new Float64Array(a3.length), l4 = p(e2.overlayInfo.spatialReference);
  for (let t5 = 0; t5 < s.length; t5 += 3)
    ne(a3, t5, s, t5, l4);
  const p3 = a3.length / 3, m2 = new Float32Array(p3 + 1);
  let h2 = z2, E2 = N, T2 = 0, g3 = 0;
  o(h2, s[g3++], s[g3++], s[g3++]), m2[0] = 0;
  for (let t5 = 1; t5 < p3 + 1; ++t5)
    t5 === p3 && (g3 = 0), o(E2, s[g3++], s[g3++], s[g3++]), T2 += H(h2, E2), m2[t5] = T2, [h2, E2] = [E2, h2];
  o2.push([O.DISTANCETOSTART, { size: 1, data: m2 }]), n4.push([O.DISTANCETOSTART, n4[0][1]]);
}
function D(t5) {
  const e2 = t5.length;
  return t5[0] === t5[e2 - 3] && t5[1] === t5[e2 - 2] && t5[2] === t5[e2 - 1];
}
var P;
!function(t5) {
  t5[t5.KEEP = 0] = "KEEP", t5[t5.REMOVE = 1] = "REMOVE";
}(P || (P = {}));
var z2 = n();
var N = n();
function L(t5) {
  switch (t5) {
    case "butt":
      return r2.BUTT;
    case "square":
      return r2.SQUARE;
    case "round":
      return r2.ROUND;
    default:
      return null;
  }
}

export {
  f,
  d,
  m,
  p2 as p,
  g2 as g,
  v,
  h,
  j,
  x,
  r3 as r,
  t4 as t,
  O3 as O,
  R2 as R,
  d2,
  P,
  L
};
//# sourceMappingURL=chunk-EHWEX2VK.js.map
