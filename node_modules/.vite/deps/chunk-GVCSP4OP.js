import {
  b,
  j as j5
} from "./chunk-N5C77AAH.js";
import {
  A as A3,
  V,
  W,
  Z,
  _ as _2,
  p2 as p
} from "./chunk-53KI6WDE.js";
import {
  a as a3,
  f
} from "./chunk-W2HLA6I3.js";
import {
  A as A2,
  I,
  a as a2,
  j as j4,
  m as m2,
  o,
  v as v2,
  w
} from "./chunk-YZNDHJDJ.js";
import {
  l
} from "./chunk-ZN2MGN4S.js";
import {
  e as e4,
  n as n4,
  r as r5
} from "./chunk-RTHP2LNT.js";
import {
  e as e3,
  n as n3,
  r as r4
} from "./chunk-U7B2WKBH.js";
import {
  n as n2
} from "./chunk-OIPX3EDD.js";
import {
  M
} from "./chunk-BPZGJQOB.js";
import {
  a,
  j as j3
} from "./chunk-ZOKX6UGH.js";
import {
  A,
  G,
  H,
  P,
  _,
  j as j2,
  q,
  r as r3,
  u,
  x,
  z
} from "./chunk-PKZEO23A.js";
import {
  e as e2,
  n,
  r as r2
} from "./chunk-AIRC226G.js";
import {
  m2 as m
} from "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  R
} from "./chunk-3NMRL5CR.js";
import {
  F,
  e,
  i2 as i,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/interactive/coordinateHelper.js
var m3;
!function(e7) {
  e7[e7.Z = 0] = "Z", e7[e7.M = 1] = "M";
}(m3 || (m3 = {}));
var Z2 = class {
  constructor(e7) {
    this.spatialReference = e7;
  }
  createVector() {
    return this._tag(n4());
  }
  pointToVector(e7) {
    return this._tag(r5(e7.x, e7.y));
  }
  arrayToVector(e7) {
    return this._tag(r5(e7[0], e7[1]));
  }
  vectorToArray(e7) {
    return [e7[0], e7[1]];
  }
  pointToArray(e7) {
    return [e7.x, e7.y];
  }
  vectorToPoint(e7, t5 = new j()) {
    return t5.x = e7[0], t5.y = e7[1], t5.z = void 0, t5.m = void 0, t5.spatialReference = this.spatialReference, t5;
  }
  arrayToPoint(e7, t5 = new j()) {
    return t5.x = e7[0], t5.y = e7[1], t5.z = void 0, t5.m = void 0, t5.spatialReference = this.spatialReference, t5;
  }
  vectorToDehydratedPoint(e7, t5 = { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }) {
    return t5.x = e7[0], t5.y = e7[1], t5.z = void 0, t5.m = void 0, t5.hasZ = false, t5.hasM = false, t5.spatialReference = this.spatialReference, t5;
  }
  lerp(t5, r8, a4, i4) {
    return A2(i4, t5, r8, a4);
  }
  addDelta(e7, t5, r8) {
    e7[0] += t5, e7[1] += r8;
  }
  distance(e7, r8) {
    return m2(e7, r8);
  }
  getZ(e7, t5) {
    return t5;
  }
  hasZ() {
    return false;
  }
  getM(e7, t5) {
    return t5;
  }
  hasM() {
    return false;
  }
  clone(e7) {
    return this._tag(e4(e7));
  }
  copy(e7, t5) {
    return a2(t5, e7);
  }
  fromXYZ(e7) {
    return this._tag(r5(e7[0], e7[1]));
  }
  toXYZ(e7, t5 = 0) {
    return r2(e7[0], e7[1], t5);
  }
  _tag(e7) {
    return e7;
  }
};
var g = class {
  constructor(e7, t5) {
    this.valueType = e7, this.spatialReference = t5;
  }
  createVector() {
    return this._tag(n());
  }
  pointToVector(e7) {
    return this._tag(r2(e7.x, e7.y, this.valueType === m3.Z ? e7.z : e7.m));
  }
  arrayToVector(e7) {
    return this._tag(r2(e7[0], e7[1], e7[2] || 0));
  }
  vectorToArray(e7) {
    return [e7[0], e7[1], e7[2]];
  }
  pointToArray(e7) {
    return this.valueType === m3.Z ? [e7.x, e7.y, e7.z] : [e7.x, e7.y, e7.m];
  }
  vectorToPoint(e7, t5 = new j()) {
    return t5.x = e7[0], t5.y = e7[1], t5.z = this.valueType === m3.Z ? e7[2] : void 0, t5.m = this.valueType === m3.M ? e7[2] : void 0, t5.spatialReference = this.spatialReference, t5;
  }
  arrayToPoint(e7, t5 = new j()) {
    return t5.x = e7[0], t5.y = e7[1], t5.z = this.valueType === m3.Z ? e7[2] : void 0, t5.m = this.valueType === m3.M ? e7[2] : void 0, t5.spatialReference = this.spatialReference, t5;
  }
  vectorToDehydratedPoint(e7, t5 = { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }) {
    const r8 = this.valueType === m3.Z, a4 = this.valueType === m3.M;
    return t5.x = e7[0], t5.y = e7[1], t5.z = r8 ? e7[2] : void 0, t5.m = a4 ? e7[2] : void 0, t5.hasZ = r8, t5.hasM = a4, t5.spatialReference = this.spatialReference, t5;
  }
  lerp(e7, t5, r8, a4) {
    return A(a4, e7, t5, r8);
  }
  addDelta(e7, t5, r8, a4) {
    e7[0] += t5, e7[1] += r8, this.valueType === m3.Z && (e7[2] += a4);
  }
  distance(e7, r8) {
    return this.valueType === m3.Z ? x(e7, r8) : m2(e7, r8);
  }
  getZ(e7, t5) {
    return this.valueType === m3.Z ? e7[2] : t5;
  }
  hasZ() {
    return this.valueType === m3.Z;
  }
  getM(e7, t5) {
    return this.valueType === m3.M ? e7[2] : t5;
  }
  hasM() {
    return this.valueType === m3.M;
  }
  clone(e7) {
    return this._tag(e2(e7));
  }
  copy(e7, t5) {
    return r3(t5, e7);
  }
  fromXYZ(e7, t5 = 0, r8 = 0) {
    return this._tag(r2(e7[0], e7[1], this.valueType === m3.Z ? e7.length > 2 ? e7[2] : t5 : r8));
  }
  toXYZ(e7, t5 = 0) {
    return this._tag(r2(e7[0], e7[1], this.valueType === m3.Z ? e7[2] : t5));
  }
  _tag(e7) {
    return e7;
  }
};
var R2 = class {
  constructor(e7) {
    this.spatialReference = e7;
  }
  createVector() {
    return this._tag(n3());
  }
  pointToVector(e7) {
    return this._tag(r4(e7.x, e7.y, e7.z, e7.m));
  }
  arrayToVector(e7) {
    return this._tag(r4(e7[0], e7[1], e7[2] || 0, e7[3] || 0));
  }
  vectorToArray(e7) {
    return [e7[0], e7[1], e7[2], e7[3]];
  }
  pointToArray(e7) {
    return [e7.x, e7.y, e7.z, e7.m];
  }
  vectorToPoint(e7, t5 = new j()) {
    return t5.x = e7[0], t5.y = e7[1], t5.z = e7[2], t5.m = e7[3], t5.spatialReference = this.spatialReference, t5;
  }
  arrayToPoint(e7, t5 = new j()) {
    return t5.x = e7[0], t5.y = e7[1], t5.z = e7[2], t5.m = e7[3], t5.spatialReference = this.spatialReference, t5;
  }
  vectorToDehydratedPoint(e7, t5 = { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }) {
    return t5.x = e7[0], t5.y = e7[1], t5.z = e7[2], t5.m = e7[3], t5.hasZ = true, t5.hasM = true, t5.spatialReference = this.spatialReference, t5;
  }
  lerp(e7, t5, r8, a4) {
    return j3(a4, e7, t5, r8);
  }
  addDelta(e7, t5, r8, a4) {
    e7[0] += t5, e7[1] += r8, e7[2] += a4;
  }
  distance(e7, t5) {
    return x(e7, t5);
  }
  getZ(e7) {
    return e7[2];
  }
  hasZ() {
    return true;
  }
  getM(e7) {
    return e7[3];
  }
  hasM() {
    return true;
  }
  clone(e7) {
    return this._tag(e3(e7));
  }
  copy(e7, t5) {
    return a(t5, e7);
  }
  fromXYZ(e7, t5 = 0, r8 = 0) {
    return this._tag(r4(e7[0], e7[1], e7.length > 2 ? e7[2] : t5, r8));
  }
  toXYZ(e7) {
    return r2(e7[0], e7[1], e7[2]);
  }
  _tag(e7) {
    return e7;
  }
};
function x2(e7, t5, r8) {
  return e7 && t5 ? new R2(r8) : t5 ? new g(m3.M, r8) : e7 ? new g(m3.Z, r8) : new Z2(r8);
}

// node_modules/@arcgis/core/views/interactive/editGeometry/unnormalizationHelper.js
function e5(o2, r8) {
  if (!r8.supported)
    return;
  let e7 = 1 / 0, p4 = -1 / 0;
  const n5 = r8.upperBoundX - r8.lowerBoundX;
  o2.forEach((o3) => {
    let u3 = o3.pos[0];
    for (; u3 < r8.lowerBoundX; )
      u3 += n5;
    for (; u3 > r8.upperBoundX; )
      u3 -= n5;
    e7 = Math.min(e7, u3), p4 = Math.max(p4, u3), o3.pos[0] = u3;
  });
  const u2 = p4 - e7;
  n5 - u2 < u2 && o2.forEach((o3) => {
    o3.pos[0] < 0 && (o3.pos[0] += n5);
  });
}
function p2(e7, p4) {
  const n5 = R(e7);
  return p4 === l.Global && n5 ? { supported: true, lowerBoundX: n5.valid[0], upperBoundX: n5.valid[1] } : { supported: false, lowerBoundX: null, upperBoundX: null };
}

// node_modules/@arcgis/core/views/interactive/editGeometry/EditGeometry.js
var c = class {
  constructor(e7) {
    this.component = e7, this.leftEdge = null, this.rightEdge = null, this.type = "vertex", this.index = null;
  }
  get pos() {
    return this._pos;
  }
  set pos(e7) {
    this._pos = e7, this.component.unnormalizeVertexPositions();
  }
};
var l2 = class {
  constructor(e7, t5, s2) {
    this.component = e7, this.leftVertex = t5, this.rightVertex = s2, this.type = "edge", t5.rightEdge = this, s2.leftEdge = this;
  }
};
var p3 = class {
  constructor(e7, t5) {
    this.spatialReference = e7, this.viewingMode = t5, this.vertices = [], this.edges = [];
  }
  unnormalizeVertexPositions() {
    this.vertices.length <= 1 || e5(this.vertices, p2(this.spatialReference, this.viewingMode));
  }
  updateVertexIndex(e7, t5) {
    if (0 === this.vertices.length)
      return;
    const s2 = this.vertices[0];
    let i4 = null, r8 = e7, o2 = t5;
    do {
      i4 = r8, i4.index = o2++, r8 = i4.rightEdge ? i4.rightEdge.rightVertex : null;
    } while (null != r8 && r8 !== s2);
    i4.leftEdge && i4 !== this.vertices[this.vertices.length - 1] && this.swapVertices(this.vertices.indexOf(i4), this.vertices.length - 1);
  }
  getFirstVertex() {
    return 0 === this.vertices.length ? null : this.vertices[0];
  }
  getLastVertex() {
    return 0 === this.vertices.length ? null : this.vertices[this.vertices.length - 1];
  }
  isClosed() {
    return this.vertices.length > 2 && null !== this.vertices[0].leftEdge;
  }
  swapVertices(e7, t5) {
    const s2 = this.vertices[e7];
    this.vertices[e7] = this.vertices[t5], this.vertices[t5] = s2;
  }
  iterateVertices(e7) {
    if (0 === this.vertices.length)
      return;
    const t5 = this.vertices[0];
    let i4 = t5;
    do {
      e7(i4, i4.index), i4 = r(i4.rightEdge) ? i4.rightEdge.rightVertex : null;
    } while (i4 !== t5 && null != i4);
  }
};
var g2 = class extends n2 {
  constructor(e7, t5) {
    super(), this.type = e7, this.coordinateHelper = t5, this._geometry = null, this.dirty = true, this.components = [];
  }
  get geometry() {
    if (this.dirty) {
      switch (this.type) {
        case "point":
          this._geometry = this._toPoint();
          break;
        case "polyline":
          this._geometry = this._toPolyline();
          break;
        case "polygon":
          this._geometry = this._toPolygon();
      }
      this.dirty = false;
    }
    return this._geometry;
  }
  get spatialReference() {
    return this.coordinateHelper.spatialReference;
  }
  notifyChanges(e7) {
    this.dirty = true, this.emit("change", e7);
  }
  _toPoint() {
    return 0 === this.components.length || 0 === this.components[0].vertices.length ? null : this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos);
  }
  _toPolyline() {
    const e7 = [], t5 = this.coordinateHelper.vectorToArray;
    for (const s2 of this.components) {
      if (s2.vertices.length < 1)
        continue;
      const i4 = [];
      let r8 = s2.vertices.find((e8) => null == e8.leftEdge);
      const o2 = r8;
      do {
        i4.push(t5(r8.pos)), r8 = r8.rightEdge ? r8.rightEdge.rightVertex : null;
      } while (r8 && r8 !== o2);
      e7.push(i4);
    }
    return new m({ paths: e7, spatialReference: this.spatialReference, hasZ: this.coordinateHelper.hasZ(), hasM: this.coordinateHelper.hasM() });
  }
  _toPolygon() {
    const e7 = [], t5 = this.coordinateHelper.vectorToArray;
    for (const i4 of this.components) {
      if (i4.vertices.length < 1)
        continue;
      const r8 = [], o2 = i4.vertices[0];
      let n5 = o2;
      const h = n5;
      do {
        r8.push(t5(n5.pos)), n5 = r(n5.rightEdge) ? n5.rightEdge.rightVertex : null;
      } while (n5 && n5 !== h);
      i4.isClosed() && r8.push(t5(o2.pos)), e7.push(r8);
    }
    return new v({ rings: e7, spatialReference: this.spatialReference, hasZ: this.coordinateHelper.hasZ(), hasM: this.coordinateHelper.hasM() });
  }
  static fromGeometry(t5, s2) {
    const i4 = t5.spatialReference, r8 = x2(t5.hasZ, t5.hasM, i4), n5 = new g2(t5.type, r8);
    switch (t5.type) {
      case "polygon": {
        const o2 = t5.rings;
        for (let t6 = 0; t6 < o2.length; ++t6) {
          const h = o2[t6], g3 = new p3(i4, s2), a4 = h.length > 2 && i(h[0], h[h.length - 1]), d2 = a4 ? h.length - 1 : h.length;
          for (let e7 = 0; e7 < d2; ++e7) {
            const t7 = r8.arrayToVector(h[e7]), s3 = new c(g3);
            g3.vertices.push(s3), s3.pos = t7, s3.index = e7;
          }
          const u2 = g3.vertices.length - 1;
          for (let e7 = 0; e7 < u2; ++e7) {
            const t7 = g3.vertices[e7], s3 = g3.vertices[e7 + 1], i5 = new l2(g3, t7, s3);
            g3.edges.push(i5);
          }
          if (a4) {
            const e7 = new l2(g3, g3.vertices[g3.vertices.length - 1], g3.vertices[0]);
            g3.edges.push(e7);
          }
          n5.components.push(g3);
        }
        break;
      }
      case "polyline":
        for (const e7 of t5.paths) {
          const t6 = new p3(i4, s2), o2 = e7.length;
          for (let s3 = 0; s3 < o2; ++s3) {
            const i5 = r8.arrayToVector(e7[s3]), o3 = new c(t6);
            t6.vertices.push(o3), o3.pos = i5, o3.index = s3;
          }
          const h = t6.vertices.length - 1;
          for (let e8 = 0; e8 < h; ++e8) {
            const s3 = t6.vertices[e8], i5 = t6.vertices[e8 + 1], r9 = new l2(t6, s3, i5);
            t6.edges.push(r9);
          }
          n5.components.push(t6);
        }
        break;
      case "point": {
        const e7 = new p3(i4, s2), o2 = new c(e7);
        o2.index = 0, o2.pos = r8.pointToVector(t5), e7.vertices.push(o2), n5.components.push(e7);
        break;
      }
    }
    return n5;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/interfaces.js
var E;
!function(E2) {
  E2[E2.NEW_STEP = 0] = "NEW_STEP", E2[E2.ACCUMULATE_STEPS = 1] = "ACCUMULATE_STEPS";
}(E || (E = {}));

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/AppendVertex.js
var d = class {
  constructor(e7, t5, i4) {
    this.editGeometry = e7, this.component = t5, this.pos = i4, this.addedVertex = null, this.originalEdge = null, this.left = null, this.right = null;
  }
  apply() {
    let d2 = "redo";
    t(this.addedVertex) && (d2 = "apply", this.addedVertex = new c(this.component));
    const h = this.component.getLastVertex();
    if (t(h))
      this.component.vertices.push(this.addedVertex), this.addedVertex.pos = this.pos, this.addedVertex.index = 0;
    else {
      let i4 = null;
      h.rightEdge && (this.originalEdge = h.rightEdge, i4 = this.originalEdge.rightVertex, this.component.edges.splice(this.component.edges.indexOf(this.originalEdge), 1)), this.component.vertices.push(this.addedVertex), this.addedVertex.pos = this.pos, t(this.left) && (this.left = new l2(this.component, h, this.addedVertex)), this.component.edges.push(this.left), h.rightEdge = this.left, r(this.originalEdge) && r(i4) && (t(this.right) && (this.right = new l2(this.component, this.addedVertex, i4)), this.component.edges.push(this.right), i4.leftEdge = this.right), this.component.updateVertexIndex(this.addedVertex, h.index + 1);
    }
    this.editGeometry.notifyChanges({ operation: d2, addedVertices: [this.addedVertex] });
  }
  undo() {
    if (t(this.addedVertex))
      return null;
    this.component.vertices.splice(this.component.vertices.indexOf(this.addedVertex), 1), r(this.left) && (this.component.edges.splice(this.component.edges.indexOf(this.left), 1), this.left.leftVertex.rightEdge = null), r(this.right) && (this.component.edges.splice(this.component.edges.indexOf(this.right), 1), this.right.rightVertex.leftEdge = null), r(this.originalEdge) && (this.component.edges.push(this.originalEdge), this.originalEdge.leftVertex.rightEdge = this.originalEdge, this.originalEdge.rightVertex.leftEdge = this.originalEdge), r(this.left) ? this.component.updateVertexIndex(this.left.leftVertex, this.left.leftVertex.index) : this.component.updateVertexIndex(this.addedVertex, 0), this.editGeometry.notifyChanges({ operation: "undo", removedVertices: [this.addedVertex] });
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/UpdateVertices.js
var t2 = class {
  constructor(t5, e7, i4) {
    this.editGeometry = t5, this.vertices = e7, this.operation = i4, this.undone = false;
  }
  apply() {
    this.vertices.forEach((t5) => this.operation.apply(t5)), this.editGeometry.components.forEach((t5) => t5.unnormalizeVertexPositions()), this.editGeometry.notifyChanges({ operation: this.undone ? "redo" : "apply", updatedVertices: this.vertices });
  }
  undo() {
    this.vertices.forEach((t5) => this.operation.undo(t5)), this.editGeometry.notifyChanges({ operation: "undo", updatedVertices: this.vertices }), this.undone = true;
  }
  canAccumulate(t5) {
    if (this.undone || t5.vertices.length !== this.vertices.length)
      return false;
    for (let e7 = 0; e7 < t5.vertices.length; ++e7)
      if (t5.vertices[e7] !== this.vertices[e7])
        return false;
    return this.operation.canAccumulate(t5.operation);
  }
  accumulate(e7) {
    return !!(e7 instanceof t2 && this.canAccumulate(e7)) && (this.vertices.forEach((t5) => this.operation.accumulate(t5, e7.operation)), this.operation.accumulateParams(e7.operation), this.editGeometry.components.forEach((t5) => t5.unnormalizeVertexPositions()), this.editGeometry.notifyChanges({ operation: "apply", updatedVertices: this.vertices }), true);
  }
};
var e6;
!function(t5) {
  t5[t5.CUMULATIVE = 0] = "CUMULATIVE", t5[t5.REPLACE = 1] = "REPLACE";
}(e6 || (e6 = {}));

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/RemoveVertices.js
var r6 = class {
  constructor(e7, t5, r8 = 0) {
    this.editGeometry = e7, this.vertices = t5, this.minNumberOfVertices = r8, this.removedVertices = null;
  }
  apply() {
    let t5 = "redo";
    null == this.removedVertices ? (this.removedVertices = [], this.vertices.forEach((t6) => {
      const r8 = this._removeVertex(t6);
      r(r8) && this.removedVertices.push(r8);
    }), t5 = "apply") : this.removedVertices.forEach((e7) => {
      this._removeVertex(e7.removedVertex);
    }), this.editGeometry.notifyChanges({ operation: t5, removedVertices: this.vertices });
  }
  undo() {
    this.removedVertices.forEach((e7) => {
      this._undoRemoveVertex(e7);
    }), this.editGeometry.notifyChanges({ operation: "undo", addedVertices: this.vertices });
  }
  accumulate() {
    return false;
  }
  _removeVertex(e7) {
    const r8 = e7.component;
    if (r8.vertices.length <= this.minNumberOfVertices)
      return null;
    const i4 = { removedVertex: e7, createdEdge: null }, s2 = e7.leftEdge, d2 = e7.rightEdge;
    return r8.vertices.splice(r8.vertices.indexOf(e7), 1), s2 && (r8.edges.splice(r8.edges.indexOf(s2), 1), s2.leftVertex.rightEdge = null), d2 && (r8.edges.splice(r8.edges.indexOf(d2), 1), d2.rightVertex.leftEdge = null), 0 === e7.index && d2 && this.vertices.length > 0 && r8.swapVertices(r8.vertices.indexOf(d2.rightVertex), 0), s2 && d2 && (i4.createdEdge = new l2(r8, s2.leftVertex, d2.rightVertex), r8.edges.push(i4.createdEdge)), d2 && r8.updateVertexIndex(d2.rightVertex, d2.rightVertex.index - 1), i4;
  }
  _undoRemoveVertex(e7) {
    const t5 = e7.removedVertex, r8 = e7.removedVertex.component, i4 = t5.leftEdge, s2 = t5.rightEdge;
    e7.createdEdge && r8.edges.splice(r8.edges.indexOf(e7.createdEdge), 1), r8.vertices.push(t5), i4 && (r8.edges.push(i4), i4.leftVertex.rightEdge = i4), s2 && (r8.edges.push(s2), s2.rightVertex.leftEdge = s2), r8.updateVertexIndex(t5, t5.index);
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/SplitEdge.js
var r7 = class {
  constructor(e7, t5, i4) {
    this.editGeometry = e7, this.edge = t5, this.t = i4, this.createdVertex = null, this.left = null, this.right = null;
  }
  apply() {
    let r8 = "redo";
    const s2 = this.edge, d2 = s2.component, h = s2.leftVertex, g3 = s2.rightVertex;
    d2.edges.splice(d2.edges.indexOf(s2), 1), t(this.createdVertex) && (r8 = "apply", this.createdVertex = new c(s2.component)), d2.vertices.push(this.createdVertex), this.createdVertex.pos = this.editGeometry.coordinateHelper.lerp(s2.leftVertex.pos, s2.rightVertex.pos, this.t, this.editGeometry.coordinateHelper.createVector()), t(this.left) && (this.left = new l2(d2, h, this.createdVertex)), this.left.leftVertex.leftEdge ? d2.edges.push(this.left) : d2.edges.unshift(this.left), h.rightEdge = this.left, t(this.right) && (this.right = new l2(d2, this.createdVertex, g3)), d2.edges.push(this.right), g3.leftEdge = this.right, d2.updateVertexIndex(this.createdVertex, h.index + 1), this.editGeometry.notifyChanges({ operation: r8, addedVertices: [this.createdVertex] });
  }
  undo() {
    if (t(this.createdVertex) || t(this.left) || t(this.right))
      return null;
    const t5 = this.edge, i4 = t5.component, r8 = this.createdVertex.leftEdge, s2 = this.createdVertex.rightEdge, d2 = r8.leftVertex, h = s2.rightVertex;
    i4.vertices.splice(i4.vertices.indexOf(this.createdVertex), 1), i4.edges.splice(i4.edges.indexOf(this.left), 1), i4.edges.splice(i4.edges.indexOf(this.right), 1), this.edge.leftVertex.leftEdge ? i4.edges.push(this.edge) : i4.edges.unshift(this.edge), d2.rightEdge = t5, h.leftEdge = t5, i4.updateVertexIndex(d2, d2.index), this.editGeometry.notifyChanges({ operation: "undo", removedVertices: [this.createdVertex] });
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/SetVertexPosition.js
var i2 = class {
  constructor(t5, e7, i4) {
    this.editGeometry = t5, this.vertex = e7, this.pos = i4;
  }
  apply() {
    const e7 = t(this.originalPosition);
    e7 && (this.originalPosition = this.vertex.pos), this._apply(e7 ? "apply" : "redo");
  }
  undo() {
    this.vertex.pos = e(this.originalPosition), this.editGeometry.notifyChanges({ operation: "undo", updatedVertices: [this.vertex] });
  }
  accumulate(t5) {
    return t5 instanceof i2 && t5.vertex === this.vertex && (this.pos = t5.pos, this._apply("apply"), true);
  }
  _apply(t5) {
    this.vertex.pos = this.pos, this.editGeometry.components.forEach((t6) => t6.unnormalizeVertexPositions()), this.editGeometry.notifyChanges({ operation: t5, updatedVertices: [this.vertex] });
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/CloseComponent.js
var i3 = class {
  constructor(e7, t5) {
    this.editGeometry = e7, this.component = t5, this.createdEdge = null;
  }
  apply() {
    let e7 = "redo";
    if (t(this.createdEdge)) {
      e7 = "apply";
      const i4 = this.component.getFirstVertex(), o2 = this.component.getLastVertex();
      if (this.component.isClosed() || this.component.vertices.length < 3 || t(i4) || t(o2))
        return;
      this.createdEdge = new l2(this.component, o2, i4);
    }
    this.createdEdge.leftVertex.rightEdge = this.createdEdge, this.createdEdge.rightVertex.leftEdge = this.createdEdge, this.component.edges.push(this.createdEdge), this.editGeometry.notifyChanges({ operation: e7 });
  }
  undo() {
    t(this.createdEdge) || (F(this.component.edges, this.createdEdge), this.createdEdge.leftVertex.rightEdge = null, this.createdEdge.rightVertex.leftEdge = null, this.editGeometry.notifyChanges({ operation: "undo" }));
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/MoveVertex.js
var t3 = class {
  constructor(t5, s2, d2, h) {
    this.helper = t5, this.dx = s2, this.dy = d2, this.dz = h;
  }
  _move(t5, s2, d2, h) {
    this.helper.addDelta(t5.pos, s2, d2, h);
  }
  apply(t5) {
    this._move(t5, this.dx, this.dy, this.dz);
  }
  undo(t5) {
    this._move(t5, -this.dx, -this.dy, -this.dz);
  }
  canAccumulate(s2) {
    return s2 instanceof t3;
  }
  accumulate(t5, s2) {
    this._move(t5, s2.dx, s2.dy, s2.dz);
  }
  accumulateParams(t5) {
    this.dx += t5.dx, this.dy += t5.dy, this.dz += t5.dz;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/OffsetEdgeVertex.js
var X = class {
  constructor(t5, i4, e7, s2 = 0, n5 = Z3.IMMEDIATE) {
    this.helper = t5, this.planeType = i4, this.edge = e7, this.distance = s2, this._plane = p(), this._offsetPlane = p(), this._minDistance = -1 / 0, this._maxDistance = 1 / 0, n5 === Z3.IMMEDIATE && this._initialize();
  }
  get plane() {
    return this._plane;
  }
  get requiresSplitEdgeLeft() {
    return !this._left.isOriginalDirection;
  }
  get requiresSplitEdgeRight() {
    return !this._right.isOriginalDirection;
  }
  get edgeDirection() {
    return this._edgeDirection;
  }
  _initialize() {
    this._initializeNeighbors(), this._initializePlane(), this._initializeDistanceConstraints();
  }
  _initializeNeighbors() {
    var _a, _b, _c, _d;
    const t5 = this._toXYZ(this.edge.leftVertex.pos), i4 = this._toXYZ((_b = (_a = this.edge.leftVertex.leftEdge) == null ? void 0 : _a.leftVertex) == null ? void 0 : _b.pos), e7 = this._toXYZ(this.edge.rightVertex.pos), s2 = this._toXYZ((_d = (_c = this.edge.rightVertex.rightEdge) == null ? void 0 : _c.rightVertex) == null ? void 0 : _d.pos);
    this._edgeDirection = H(n(), t5, e7), this._left = this._computeNeighbor(t5, i4, this._edgeDirection), this._right = this._computeNeighbor(e7, s2, this._edgeDirection);
  }
  _toXYZ(t5) {
    return r(t5) ? this.helper.toXYZ(t5) : null;
  }
  _computeNeighbor(t5, i4, s2) {
    if (t(i4))
      return { start: t5, end: i4, direction: r2(-s2[1], s2[0], 0), isOriginalDirection: true };
    const n5 = H(n(), t5, i4), r8 = !this._passesBisectingAngleThreshold(n5, s2);
    return { start: t5, end: i4, direction: r8 ? this._bisectVectorsPerpendicular(s2, n5) : n5, isOriginalDirection: !r8 };
  }
  _passesBisectingAngleThreshold(t5, i4) {
    const e7 = Math.abs(a3(i4, t5));
    return e7 >= Y && e7 <= Math.PI - Y;
  }
  _bisectVectorsPerpendicular(t5, i4) {
    const e7 = P(t5, i4) < 0 ? t5 : j2(n(), t5), s2 = Math.abs(P(e7, i4));
    if (!(s2 < 1e-3 || s2 > 0.999))
      return this._bisectDirection(e7, i4);
    const n5 = _(n(), e7, [0, 0, 1]);
    return z(n5, n5);
  }
  _bisectDirection(t5, i4) {
    const e7 = u(n(), t5, i4);
    return z(e7, e7);
  }
  _initializePlane() {
    const t5 = this._computeNormalDirection(this._left), i4 = this._computeNormalDirection(this._right);
    P(t5, i4) < 0 && j2(i4, i4), _2(this._left.start, this._bisectDirection(t5, i4), this._plane);
  }
  _computeNormalDirection(t5) {
    const i4 = _(n(), t5.direction, this._edgeDirection);
    z(i4, i4);
    const e7 = _(n(), this._edgeDirection, i4);
    return this.planeType === T.XY && (e7[2] = 0), z(e7, e7);
  }
  _initializeDistanceConstraints() {
    r(this._left.end) && !this.requiresSplitEdgeLeft && this._updateDistanceConstraint(W(this._plane, this._left.end)), r(this._right.end) && !this.requiresSplitEdgeRight && this._updateDistanceConstraint(W(this._plane, this._right.end)), this._updateIntersectDistanceConstraint(this._plane);
  }
  _updateDistanceConstraint(t5) {
    t5 <= 0 && (this._minDistance = Math.max(this._minDistance, t5)), t5 >= 0 && (this._maxDistance = Math.min(this._maxDistance, t5));
  }
  _updateIntersectDistanceConstraint(t5) {
    const i4 = Z(t5), e7 = this._edgeDirection, a4 = u(n(), this._left.start, this._left.direction), o2 = u(n(), this._right.start, this._right.direction), c3 = this._pointInBasis2D(n4(), i4, e7, this._left.start), _3 = this._pointInBasis2D(n4(), i4, e7, a4), l3 = this._pointInBasis2D(n4(), i4, e7, this._right.start), d2 = this._pointInBasis2D(n4(), i4, e7, o2), [f2] = j5({ start: _3, end: c3, type: b.LINE }, { start: d2, end: l3, type: b.LINE });
    if (!f2)
      return;
    const u2 = o(n4(), c3, _3);
    v2(u2, u2);
    const D = o(n4(), f2, _3), E2 = j4(u2, D), b2 = u(n(), a4, q(n(), this._left.direction, -E2)), I2 = W(t5, b2);
    this._updateDistanceConstraint(I2);
  }
  _pointInBasis2D(t5, i4, e7, s2) {
    return t5[0] = f(i4, s2), t5[1] = f(e7, s2), t5;
  }
  _offset(t5, e7) {
    Number.isFinite(this._minDistance) && (e7 = Math.max(this._minDistance, e7)), Number.isFinite(this._maxDistance) && (e7 = Math.min(this._maxDistance, e7)), A3(this._offsetPlane, this._plane), this._offsetPlane[3] -= e7;
    const s2 = (t6, e8, s3) => r(e8) && V(this._offsetPlane, t6, u(n(), t6, e8), s3), n5 = n();
    (t5 === this.edge.leftVertex ? s2(this._left.start, this._left.direction, n5) : s2(this._right.start, this._right.direction, n5)) && this.helper.copy(this.helper.fromXYZ(n5, void 0, this.helper.getM(t5.pos)), t5.pos);
  }
  signedDistanceToPoint(t5) {
    return W(this.plane, this.helper.toXYZ(this.helper.pointToVector(t5)));
  }
  apply(t5) {
    this._offset(t5, this.distance);
  }
  undo(t5) {
    this._offset(t5, 0);
  }
  canAccumulate(t5) {
    return t5 instanceof X && this.edge.leftVertex.index === t5.edge.leftVertex.index && this.edge.rightVertex.index === t5.edge.rightVertex.index && this.edge.component === t5.edge.component && this._maybeEqualsVec3(this._left.direction, t5._left.direction) && this._maybeEqualsVec3(this._right.direction, t5._right.direction) && G(Z(this._plane), Z(t5._plane));
  }
  accumulate(t5, i4) {
    const e7 = this._plane[3] - i4._plane[3] + i4.distance;
    this._offset(t5, e7);
  }
  accumulateParams(t5) {
    const i4 = t5.distance - t5._plane[3];
    this.distance = i4 + this._plane[3];
  }
  clone() {
    const t5 = new X(this.helper, this.planeType, this.edge, this.distance, Z3.DEFERRED);
    return A3(t5._plane, this._plane), A3(t5._offsetPlane, this._offsetPlane), t5._maxDistance = this._maxDistance, t5._minDistance = this._minDistance, t5._left = this._cloneNeighbor(this._left), t5._right = this._cloneNeighbor(this._right), t5._edgeDirection = r3(n(), this._edgeDirection), t5;
  }
  _maybeEqualsVec3(t5, s2) {
    return t(t5) && t(s2) || r(t5) && r(s2) && G(t5, s2);
  }
  _cloneNeighbor({ start: t5, end: e7, direction: s2, isOriginalDirection: n5 }) {
    return { start: r3(n(), t5), end: r(e7) ? r3(n(), e7) : null, direction: r3(n(), s2), isOriginalDirection: n5 };
  }
};
var Y = M(15);
var T;
var Z3;
!function(t5) {
  t5[t5.XYZ = 0] = "XYZ", t5[t5.XY = 1] = "XY";
}(T || (T = {})), function(t5) {
  t5[t5.IMMEDIATE = 0] = "IMMEDIATE", t5[t5.DEFERRED = 1] = "DEFERRED";
}(Z3 || (Z3 = {}));

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/RotateVertex.js
var s = class {
  constructor(t5, a4, s2 = e6.CUMULATIVE) {
    this.origin = t5, this.angle = a4, this.accumulationType = s2;
  }
  _rotate(t5, i4) {
    I(t5.pos, t5.pos, this.origin, i4);
  }
  apply(t5) {
    this._rotate(t5, this.angle);
  }
  undo(t5) {
    this._rotate(t5, -this.angle);
  }
  canAccumulate(a4) {
    return a4 instanceof s && i(this.origin, a4.origin);
  }
  accumulate(t5, a4) {
    const s2 = a4.accumulationType === e6.REPLACE;
    this._rotate(t5, s2 ? a4.angle - this.angle : a4.angle);
  }
  accumulateParams(t5) {
    const a4 = t5.accumulationType === e6.REPLACE;
    this.angle = a4 ? t5.angle : this.angle + t5.angle;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/ScaleVertex.js
var c2 = class {
  constructor(t5, a4, c3, o2, r8 = e6.CUMULATIVE) {
    this.origin = t5, this.axis1 = a4, this.factor1 = c3, this.factor2 = o2, this.accumulationType = r8, this.axis2 = r5(a4[1], -a4[0]);
  }
  _scale(t5, s2, i4) {
    w(t5.pos, t5.pos, this.origin, this.axis1, s2), w(t5.pos, t5.pos, this.origin, this.axis2, i4);
  }
  apply(t5) {
    this._scale(t5, this.factor1, this.factor2);
  }
  undo(t5) {
    this._scale(t5, 1 / this.factor1, 1 / this.factor2);
  }
  canAccumulate(s2) {
    return s2 instanceof c2 && i(this.origin, s2.origin) && i(this.axis1, s2.axis1);
  }
  accumulate(t5, s2) {
    s2.accumulationType === e6.REPLACE ? this._scale(t5, s2.factor1 / this.factor1, s2.factor2 / this.factor2) : this._scale(t5, s2.factor1, s2.factor2);
  }
  accumulateParams(t5) {
    const s2 = t5.accumulationType === e6.REPLACE;
    this.factor1 = s2 ? t5.factor1 : this.factor1 * t5.factor1, this.factor2 = s2 ? t5.factor2 : this.factor2 * t5.factor2;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/UndoGroup.js
var t4 = class {
  constructor() {
    this.operations = [], this.closed = false;
  }
  close() {
    this.closed = true;
  }
  apply() {
    for (const t5 of this.operations)
      t5.apply();
  }
  undo() {
    for (let t5 = this.operations.length - 1; t5 >= 0; t5--)
      this.operations[t5].undo();
  }
  accumulate(t5) {
    if (this.closed)
      return false;
    const o2 = this.operations.length ? this.operations[this.operations.length - 1] : null;
    return o2 && o2.accumulate(t5) || (this.operations.push(t5), t5.apply()), true;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/EditGeometryOperations.js
var S = class extends n2 {
  constructor(e7) {
    super(), this.data = e7, this.undoStack = [], this.redoStack = [], this.listener = this.data.on("change", (e8) => {
      e8.addedVertices && this.emit("vertex-add", { type: "vertex-add", vertices: e8.addedVertices, operation: e8.operation }), e8.removedVertices && this.emit("vertex-remove", { type: "vertex-remove", vertices: e8.removedVertices, operation: e8.operation }), e8.updatedVertices && this.emit("vertex-update", { type: "vertex-update", vertices: e8.updatedVertices, operation: e8.operation });
    });
  }
  destroy() {
    this.listener.remove();
  }
  splitEdge(e7, t5) {
    return this._apply(new r7(this.data, e7, t5));
  }
  updateVertices(e7, t5, r8 = E.ACCUMULATE_STEPS) {
    return this._apply(new t2(this.data, e7, t5), r8);
  }
  moveVertices(e7, t5, r8, s2, i4 = E.ACCUMULATE_STEPS) {
    return this.updateVertices(e7, new t3(this.data.coordinateHelper, t5, r8, s2), i4);
  }
  scaleVertices(e7, t5, r8, s2, i4, a4 = E.ACCUMULATE_STEPS, p4 = e6.CUMULATIVE) {
    return this.updateVertices(e7, new c2(t5, r8, s2, i4, p4), a4);
  }
  rotateVertices(e7, t5, r8, s2 = E.ACCUMULATE_STEPS, i4 = e6.CUMULATIVE) {
    return this.updateVertices(e7, new s(t5, r8, i4), s2);
  }
  removeVertices(e7) {
    return this._apply(new r6(this.data, e7, this._minNumVerticesPerType));
  }
  appendVertex(e7) {
    return 0 === this.data.components.length ? null : this._apply(new d(this.data, this.data.components[0], e7));
  }
  setVertexPosition(e7, t5) {
    return this._apply(new i2(this.data, e7, t5));
  }
  offsetEdge(e7, t5, r8, s2 = E.ACCUMULATE_STEPS) {
    return this.updateVertices([t5.leftVertex, t5.rightVertex], new X(this.data.coordinateHelper, e7, t5, r8), s2);
  }
  closeComponent(e7) {
    return this.data.components.includes(e7) ? this._apply(new i3(this.data, e7)) : null;
  }
  canRemoveVertex() {
    return this.data.components[0].vertices.length > this._minNumVerticesPerType;
  }
  createUndoGroup() {
    const e7 = new t4();
    return this._apply(e7), { remove: () => e7.close() };
  }
  undo() {
    if (this.undoStack.length > 0) {
      const e7 = this.undoStack.pop();
      return e7.undo(), this.redoStack.push(e7), e7;
    }
    return null;
  }
  redo() {
    if (this.redoStack.length > 0) {
      const e7 = this.redoStack.pop();
      return e7.apply(), this.undoStack.push(e7), e7;
    }
    return null;
  }
  get canUndo() {
    return this.undoStack.length > 0;
  }
  get canRedo() {
    return this.redoStack.length > 0;
  }
  get lastOperation() {
    return this.undoStack.length > 0 ? this.undoStack[this.undoStack.length - 1] : null;
  }
  get _minNumVerticesPerType() {
    switch (this.data.type) {
      case "point":
        return 1;
      case "polyline":
        return 2;
      case "polygon":
        return 3;
      default:
        return 0;
    }
  }
  _apply(e7, r8 = E.ACCUMULATE_STEPS) {
    return r8 !== E.NEW_STEP && !t(this.lastOperation) && this.lastOperation.accumulate(e7) || (e7.apply(), this.undoStack.push(e7), this.redoStack = []), e7;
  }
  static fromGeometry(e7, t5) {
    return new S(g2.fromGeometry(e7, t5));
  }
};

export {
  x2 as x,
  p3 as p,
  g2 as g,
  E,
  t2 as t,
  e6 as e,
  t3 as t2,
  X,
  T,
  s,
  c2 as c,
  S
};
//# sourceMappingURL=chunk-GVCSP4OP.js.map
