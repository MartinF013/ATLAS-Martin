{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/environment/CloudsTechniqueConfiguration.js", "../../@arcgis/core/chunks/Clouds.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{_ as e}from\"../../../chunks/tslib.es6.js\";import{parameter as s,ShaderTechniqueConfiguration as o}from\"../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration.js\";var t;!function(e){e[e.SIXTEEN=0]=\"SIXTEEN\",e[e.HUNDRED=1]=\"HUNDRED\",e[e.TWOHUNDRED=2]=\"TWOHUNDRED\",e[e.COUNT=3]=\"COUNT\"}(t||(t={}));class r extends o{constructor(){super(...arguments),this.steps=t.SIXTEEN}}e([s({count:t.COUNT})],r.prototype,\"steps\",void 0);export{r as CloudsTechniqueConfiguration,t as RayMarchingSteps};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{c as t}from\"./mat3f64.js\";import{RayMarchingSteps as e}from\"../views/3d/environment/CloudsTechniqueConfiguration.js\";import{ATLAS_SIZE as a,TILE_ROWS as o,TILE_SIZE as i,TEXTURE_SCALE as n,WEATHER_MAP_SCALE as r}from\"../views/3d/environment/NoiseTextureAtlasDimensions.js\";import{ScreenSpacePass as s}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";import{FloatUniform as l}from\"../views/3d/webgl-engine/core/shaderModules/FloatUniform.js\";import{NoParameters as c,glsl as d}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix3DrawUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Matrix3DrawUniform.js\";import{ShaderBuilder as f}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DUniform.js\";class p extends c{constructor(){super(...arguments),this.viewMatrix=t()}}function g(t){const c=new f;return c.include(s,!1),c.fragment.uniforms.add(new l(\"cloudRadius\")),c.fragment.uniforms.add(new l(\"halfCubeMapSize\")),c.fragment.uniforms.add(new l(\"power\")),c.fragment.uniforms.add(new l(\"sigmaE\")),c.fragment.uniforms.add(new l(\"density\")),c.fragment.uniforms.add(new l(\"cloudSize\")),c.fragment.uniforms.add(new l(\"detailSize\")),c.fragment.uniforms.add(new l(\"smoothness\")),c.fragment.uniforms.add(new l(\"cloudHeight\")),c.fragment.uniforms.add(new l(\"coverage\")),c.fragment.uniforms.add(new u(\"view\",(t=>t.viewMatrix))),c.fragment.uniforms.add(new m(\"cloudShapeTexture\")),c.fragment.code.add(d`\n    const int STEPS = ${t.steps===e.SIXTEEN?d`16`:t.steps===e.HUNDRED?d`100`:d`200`};\n    const int STEPS_LIGHT = 6;\n    const float stepL = 300.0 / float(STEPS_LIGHT);\n    const float cloudStart = 1500.0;\n\n    vec3 rayDirection(vec2 fragCoord) {\n      vec2 xy = fragCoord - halfCubeMapSize;\n      return normalize(vec3(-xy, -halfCubeMapSize));\n    }\n\n    float remap(float x, float low1, float high1, float low2, float high2) {\n      return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n    }\n\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }`),c.fragment.code.add(d`\n    float getCloudShape(vec3 pos, float pOffset) {\n      const float textureWidth = ${d.float(a)};\n      const float dataWidth = ${d.float(a)};\n      const float tileRows = ${d.float(o)};\n      const vec3 atlasDimensions = vec3(${d.float(i)}, ${d.float(i)}, tileRows * tileRows);\n\n      //Change from Y being height to Z being height\n      vec3 p = float(${d.float(n)}) * pos.xzy;\n\n      //Pixel coordinates of point in the 3D data\n      vec3 coord = vec3(mod(p - pOffset * atlasDimensions, atlasDimensions));\n      float f = fract(coord.z);\n      float level = floor(coord.z);\n      float tileY = floor(level / tileRows);\n      float tileX = level - tileY * tileRows;\n\n      //The data coordinates are offset by the x and y tile, the two boundary cells between each tile pair and the initial boundary cell on the first row/column\n      vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n      vec2 pixel = coord.xy + offset;\n      vec2 data = texture2D(cloudShapeTexture, mod(pixel, dataWidth) / textureWidth).xy;\n\n      return 1.0 - mix(data.x, data.y, f);\n    }\n\n    float getCloudMap(vec2 p){\n      // Non-power-of-two textures can't be tiled using WebGL1\n      // Get fractional part of uv to tile\n      // Shift the texture center to origin to avoid seam artifacts\n      vec2 uv = fract((${d.float(r)} * p) / ${d.float(a)} + 0.5);\n\n      return texture2D(cloudShapeTexture, uv).a;\n    }\n    `),c.fragment.code.add(d`float clouds(vec3 p) {\nfloat cloud = saturate(0.5 * mix(0.0, 1.0, min(2.0 * coverage, 1.0)));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat cloudMap = getCloudMap(cloudSize * p.xy);\ncloud = mix(cloud, min(2.0 * (coverage), 1.0) * cloudMap, min(2.0 * (1.0 - coverage), 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat shape = getCloudShape(8.0 * cloudSize * p, 0.0);\ncloud = saturate(remap(cloud, smoothness * shape, 1.0, 0.0, 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat heightFraction = saturate((length(p) - cloudRadius - cloudStart) / cloudHeight);\ncloud *= saturate(remap(heightFraction, 0.0, 0.25, 0.0, 1.0)) * smoothstep(1.0, 0.25, heightFraction);\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nreturn density * saturate(remap(cloud, 0.35 * smoothness * getCloudShape(detailSize * p, 0.0), 1.0, 0.0, 1.0));\n}`),c.fragment.code.add(d`vec2 sphereIntersections(vec3 start, vec3 dir, float radius) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = dot(start, start) - (radius * radius);\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}\nfloat HenyeyGreenstein(float g, float costh) {\nreturn (1.0 / (4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * costh, 1.5));\n}`),c.fragment.code.add(\"\\n    vec3 multipleOctaves(float extinction, float mu, float stepL) {\\n      float attenuation = 1.0;\\n      float contribution = 1.0;\\n      float phaseAttenuation = 1.0;\\n      vec3 luminance = vec3(0);\\n\\n      for (int i = 0; i < 4; i++) {\\n        float phase = mix(HenyeyGreenstein(0.0, mu), HenyeyGreenstein(0.3 * phaseAttenuation, mu), 0.7);\\n        luminance += contribution * phase * exp(-stepL * extinction * sigmaE * attenuation);\\n        attenuation *= 0.2;\\n        contribution *= 0.6;\\n        phaseAttenuation *= 0.5;\\n      }\\n\\n      return luminance;\\n    }\"),c.fragment.code.add(d`vec3 lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection) {\nfloat lightRayDensity = clouds(p);\nlightRayDensity += clouds(p + sunDirection * 1.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 2.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 3.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 4.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 5.0 * stepL);\nvec3 beersLaw = multipleOctaves(lightRayDensity, mu, stepL);\nreturn mix(beersLaw * 2.0 * (1.0 - (exp(-stepL * lightRayDensity * 2.0 * sigmaE ))), beersLaw, 0.5 + 0.5 * mu);\n}`),c.fragment.code.add(d`vec3 mainRay(vec3 org, vec3 dir, vec3 sunDirection, float distToStart, float totalDistance, out float totalTransmittance) {\nif (dir.z < 0.0) {\nreturn vec3(0);\n}\ntotalTransmittance = 1.0;\nfloat stepS = totalDistance / float(STEPS);\nfloat cameraHeight = length(org);\nfloat mu = 0.5 + 0.5 * dot(sunDirection, dir);\nfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\nvec3 p = org + distToStart  * dir;\nfloat dist = distToStart;\nvec3 color = vec3(0.0);\nfor (int i = 0; i < STEPS; i++) {\nfloat sampleDensity = clouds(p);\nfloat sampleSigmaE = sampleDensity * sigmaE;\nif (sampleDensity > 0.0 ) {\nfloat ambient = mix((1.2), (1.6), saturate((length(p) - cloudRadius - cloudStart) / cloudHeight));\nvec3 luminance = sampleDensity * (ambient + power * phaseFunction * lightRay(org, p, phaseFunction, mu, sunDirection));\nfloat transmittance = exp(-sampleSigmaE * stepS);\ncolor += totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE;\ntotalTransmittance *= transmittance;\nif (totalTransmittance <= 0.001) {\ntotalTransmittance = 0.0;\nbreak;\n}\n}\ndist += stepS;\np = org + dir * dist;\n}\nreturn color;\n}`),c.fragment.code.add(d`void main() {\nvec3 rayDir = rayDirection(gl_FragCoord.xy);\nrayDir = normalize(view * rayDir);\nvec3 viewPos = vec3(0, 0, cloudRadius + 1.0);\nbool hitsPlanet = rayDir.z < 0.0;\nif (hitsPlanet) {\ngl_FragColor = vec4(vec3(0), 1);\nreturn;\n}\nvec2 rayStartIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart);\nvec2 rayEndIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart + cloudHeight);\nfloat distToStart = rayStartIntersect.y;\nfloat totalDistance = rayEndIntersect.y - distToStart;\nfloat totalTransmittance = 1.0;\nvec3 sunDirection = normalize(vec3(0, 0, 1));\nvec3 col = 0.5 * mainRay(viewPos, rayDir, sunDirection, distToStart, totalDistance, totalTransmittance).rgb;\ngl_FragColor = vec4(col, totalTransmittance);\n}`),c}const h=Object.freeze(Object.defineProperty({__proto__:null,CloudsDrawParameters:p,build:g},Symbol.toStringTag,{value:\"Module\"}));export{p as C,h as a,g as b};\n"],
  "mappings": "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",
  "names": ["t", "e", "r", "e", "t", "c", "o", "s", "r"]
}
