import {
  i
} from "./chunk-E3V32BOJ.js";
import {
  a
} from "./chunk-DVE4HUBR.js";
import {
  m
} from "./chunk-RC6OMMF6.js";
import {
  o
} from "./chunk-OYNEZ5VG.js";
import {
  m as m2
} from "./chunk-DMGVDNFD.js";
import {
  a as a2
} from "./chunk-I5UNY2WQ.js";
import {
  n
} from "./chunk-NAB3NF54.js";
import {
  O
} from "./chunk-VMF4NMEB.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js
function m3(m4, c) {
  const i2 = m4.fragment;
  if (c.hasVertexTangents ? (m4.attributes.add(O.TANGENT, "vec4"), m4.varyings.add("vTangent", "vec4"), c.doubleSidedMode === i.WindingOrder ? i2.code.add(n`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;
vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`) : i2.code.add(n`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = vTangent.w;
vec3 tangent = normalize(vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`)) : (m4.extensions.add("GL_OES_standard_derivatives"), i2.code.add(n`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {
vec3 Q1 = dFdx(pos);
vec3 Q2 = dFdy(pos);
vec2 stx = dFdx(st);
vec2 sty = dFdy(st);
float det = stx.t * sty.s - sty.t * stx.s;
vec3 T = stx.t * Q2 - sty.t * Q1;
T = T - normal * dot(normal, T);
T *= inversesqrt(max(dot(T,T), 1.e-10));
vec3 B = sign(det) * cross(normal, T);
return mat3(T, B, normal);
}`)), c.textureCoordinateType !== o.None) {
    m4.include(a, c);
    const e = c.supportsTextureAtlas;
    i2.uniforms.add(c.pbrTextureBindType === a2.Pass ? m2("normalTexture", (e2) => e2.textureNormal, e) : m("normalTexture", (e2) => e2.textureNormal, e)), i2.code.add(n`
    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {
      vtc.uv = uv;
      ${c.supportsTextureAtlas ? "vtc.size = normalTextureSize;" : ""}
      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;
      return tangentSpace * rawNormal;
    }
  `);
  }
}

export {
  m3 as m
};
//# sourceMappingURL=chunk-444THZYK.js.map
