import {
  p
} from "./chunk-CNL2CHF7.js";
import {
  e
} from "./chunk-O7YSDCZE.js";
import {
  a
} from "./chunk-767LZ6IM.js";
import {
  r
} from "./chunk-FCDEMPPS.js";
import {
  o
} from "./chunk-TEJEYVH4.js";
import {
  t
} from "./chunk-HEZ2ATGC.js";
import {
  e as e2
} from "./chunk-AALA53RH.js";
import {
  u
} from "./chunk-IJHFAZOW.js";
import {
  d
} from "./chunk-YAQGRU5B.js";
import {
  o as o2
} from "./chunk-A3QLZKCF.js";
import {
  i2 as i
} from "./chunk-I5UNY2WQ.js";
import {
  n
} from "./chunk-NAB3NF54.js";
import {
  O
} from "./chunk-VMF4NMEB.js";

// node_modules/@arcgis/core/chunks/NativeLine.glsl.js
function m(m2) {
  const u3 = new i();
  u3.include(r), u3.include(e, m2), u3.include(p, m2), d(u3, m2);
  const { vertex: v, fragment: h } = u3;
  return m2.stippleEnabled && (u3.attributes.add(O.UV0, "vec2"), u3.attributes.add(O.AUXPOS1, "vec3"), v.uniforms.add(new e2("viewport", (e3, o3) => o3.camera.fullViewport))), u3.attributes.add(O.POSITION, "vec3"), u3.varyings.add("vpos", "vec3"), v.code.add(n`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`), m2.stippleEnabled && (v.code.add(n`vec4 vpos2 = transformPosition(proj, view, auxpos1);
vec2 ndcToPixel = viewport.zw * 0.5;
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`), m2.draped ? v.uniforms.add(new o2("worldToScreenRatio", (e3, o3) => 1 / o3.screenToPCSRatio)) : v.code.add(n`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`), v.code.add(n`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`), m2.draped ? v.code.add(n`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`) : v.code.add(n`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`), v.code.add(n`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)), v.code.add(n`}`), m2.output === o.Highlight && u3.include(a), u3.include(u, m2), h.uniforms.add(new o2("alphaCoverage", (e3, o3) => Math.min(1, e3.width * o3.camera.pixelRatio))), m2.hasVertexColors || h.uniforms.add(new e2("constantColor", (e3) => e3.color)), h.code.add(n`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${m2.hasVertexColors ? "vColor" : "constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${n.float(t)}) {
      discard;
    }

    ${m2.output === o.Color ? n`gl_FragColor = highlightSlice(finalColor, vpos);` : ""}
    ${m2.output === o.Highlight ? n`outputHighlight();` : ""}
  }
  `), u3;
}
var u2 = Object.freeze(Object.defineProperty({ __proto__: null, build: m }, Symbol.toStringTag, { value: "Module" }));

export {
  m,
  u2 as u
};
//# sourceMappingURL=chunk-OZAI2STL.js.map
