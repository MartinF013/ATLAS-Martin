import {
  m,
  p
} from "./chunk-Z6EP2GTZ.js";
import {
  a
} from "./chunk-PZG7CR4Y.js";
import {
  s
} from "./chunk-DMJWTK32.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";

// node_modules/@arcgis/core/rest/support/ClassificationDefinition.js
var c = new s({ classBreaksDef: "class-breaks-definition", uniqueValueDef: "unique-value-definition" });
var l2 = class extends l {
  constructor() {
    super(...arguments), this.baseSymbol = null, this.colorRamp = null, this.type = null;
  }
};
e([d({ type: a, json: { write: true } })], l2.prototype, "baseSymbol", void 0), e([d({ types: m, json: { read: { reader: p }, write: true } })], l2.prototype, "colorRamp", void 0), e([d({ json: { read: c.read, write: c.write } })], l2.prototype, "type", void 0), l2 = e([n("esri.rest.support.ClassificationDefinition")], l2);
var m2 = l2;

// node_modules/@arcgis/core/rest/support/ClassBreaksDefinition.js
var o = new s({ esriClassifyEqualInterval: "equal-interval", esriClassifyManual: "manual", esriClassifyNaturalBreaks: "natural-breaks", esriClassifyQuantile: "quantile", esriClassifyStandardDeviation: "standard-deviation", esriClassifyDefinedInterval: "defined-interval" });
var a2 = new s({ esriNormalizeByLog: "log", esriNormalizeByPercentOfTotal: "percent-of-total", esriNormalizeByField: "field" });
var n2 = class extends m2 {
  constructor() {
    super(...arguments), this.breakCount = null, this.classificationField = null, this.classificationMethod = null, this.normalizationField = null, this.normalizationType = null, this.type = "class-breaks-definition";
  }
  set standardDeviationInterval(e3) {
    "standard-deviation" === this.classificationMethod && this._set("standardDeviationInterval", e3);
  }
  set definedInterval(e3) {
    "defined-interval" === this.classificationMethod && this._set("definedInterval", e3);
  }
};
e([d({ json: { write: true } })], n2.prototype, "breakCount", void 0), e([d({ json: { write: true } })], n2.prototype, "classificationField", void 0), e([d({ type: String, json: { read: o.read, write: o.write } })], n2.prototype, "classificationMethod", void 0), e([d({ json: { write: true } })], n2.prototype, "normalizationField", void 0), e([d({ json: { read: a2.read, write: a2.write } })], n2.prototype, "normalizationType", void 0), e([d({ value: null, json: { write: true } })], n2.prototype, "standardDeviationInterval", null), e([d({ value: null, json: { write: true } })], n2.prototype, "definedInterval", null), e([d()], n2.prototype, "type", void 0), n2 = e([n("esri.rest.support.ClassBreaksDefinition")], n2);
var l3 = n2;

// node_modules/@arcgis/core/rest/support/generateRendererUtils.js
function e2(e3, l4) {
  return Number(e3.toFixed(l4));
}
function t(e3) {
  const { normalizationTotal: l4 } = e3;
  return { classBreaks: n3(e3), normalizationTotal: l4 };
}
function n3(l4) {
  const t2 = l4.definition, { classificationMethod: n4, breakCount: o3, normalizationType: r2, definedInterval: h2 } = t2, m3 = [];
  let b = l4.values;
  if (0 === b.length)
    return [];
  b = b.sort((e3, l5) => e3 - l5);
  const V = b[0], p2 = b[b.length - 1];
  if ("equal-interval" === n4)
    if (b.length >= o3) {
      const l5 = (p2 - V) / o3;
      let t3 = V;
      for (let n5 = 1; n5 < o3; n5++) {
        const u2 = e2(V + n5 * l5, 6);
        m3.push({ minValue: t3, maxValue: u2, label: a3(t3, u2, r2) }), t3 = u2;
      }
      m3.push({ minValue: t3, maxValue: p2, label: a3(t3, p2, r2) });
    } else
      b.forEach((e3) => {
        m3.push({ minValue: e3, maxValue: e3, label: a3(e3, e3, r2) });
      });
  else if ("natural-breaks" === n4) {
    const t3 = u(b), n5 = l4.valueFrequency || t3.valueFrequency, i2 = s2(t3.uniqueValues, n5, o3);
    let c3 = V;
    for (let l5 = 1; l5 < o3; l5++)
      if (t3.uniqueValues.length > l5) {
        const n6 = e2(t3.uniqueValues[i2[l5]], 6);
        m3.push({ minValue: c3, maxValue: n6, label: a3(c3, n6, r2) }), c3 = n6;
      }
    m3.push({ minValue: c3, maxValue: p2, label: a3(c3, p2, r2) });
  } else if ("quantile" === n4)
    if (b.length >= o3 && V !== p2) {
      let e3 = V, l5 = Math.ceil(b.length / o3), t3 = 0;
      for (let n5 = 1; n5 < o3; n5++) {
        let u2 = l5 + t3 - 1;
        u2 > b.length && (u2 = b.length - 1), u2 < 0 && (u2 = 0), m3.push({ minValue: e3, maxValue: b[u2], label: a3(e3, b[u2], r2) }), e3 = b[u2], t3 += l5, l5 = Math.ceil((b.length - t3) / (o3 - n5));
      }
      m3.push({ minValue: e3, maxValue: p2, label: a3(e3, p2, r2) });
    } else {
      let e3 = -1;
      for (let l5 = 0; l5 < b.length; l5++) {
        const t3 = b[l5];
        t3 !== e3 && (e3 = t3, m3.push({ minValue: e3, maxValue: t3, label: a3(e3, t3, r2) }), e3 = t3);
      }
    }
  else if ("standard-deviation" === n4) {
    const l5 = c2(b), t3 = f(b, l5);
    if (0 === t3)
      m3.push({ minValue: b[0], maxValue: b[0], label: a3(b[0], b[0], r2) });
    else {
      const n5 = i(V, p2, o3, l5, t3) * t3;
      let u2 = 0, s3 = V;
      for (let t4 = o3; t4 >= 1; t4--) {
        const o4 = e2(l5 - (t4 - 0.5) * n5, 6);
        m3.push({ minValue: s3, maxValue: o4, label: a3(s3, o4, r2) }), s3 = o4, u2++;
      }
      let c3 = e2(l5 + 0.5 * n5, 6);
      m3.push({ minValue: s3, maxValue: c3, label: a3(s3, c3, r2) }), s3 = c3, u2++;
      for (let t4 = 1; t4 <= o3; t4++)
        c3 = u2 === 2 * o3 ? p2 : e2(l5 + (t4 + 0.5) * n5, 6), m3.push({ minValue: s3, maxValue: c3, label: a3(s3, c3, r2) }), s3 = c3, u2++;
    }
  } else if ("defined-interval" === n4) {
    if (!h2)
      return m3;
    const l5 = b[0], t3 = b[b.length - 1], n5 = Math.ceil((t3 - l5) / h2);
    let u2 = l5;
    for (let s3 = 1; s3 < n5; s3++) {
      const t4 = e2(l5 + s3 * h2, 6);
      m3.push({ minValue: u2, maxValue: t4, label: a3(u2, t4, r2) }), u2 = t4;
    }
    m3.push({ minValue: u2, maxValue: t3, label: a3(u2, t3, r2) });
  }
  return m3;
}
function a3(e3, l4, t2) {
  let n4 = null;
  return n4 = e3 === l4 ? t2 && "percent-of-total" === t2 ? e3 + "%" : e3.toString() : t2 && "percent-of-total" === t2 ? e3 + "% - " + l4 + "%" : e3 + " - " + l4, n4;
}
function u(e3) {
  const l4 = [], t2 = [];
  let n4 = Number.MIN_VALUE, a4 = 1, u2 = -1;
  for (let s3 = 0; s3 < e3.length; s3++) {
    const o3 = e3[s3];
    o3 === n4 ? (a4++, t2[u2] = a4) : null !== o3 && (l4.push(o3), n4 = o3, a4 = 1, t2.push(a4), u2++);
  }
  return { uniqueValues: l4, valueFrequency: t2 };
}
function s2(e3, l4, t2) {
  const n4 = e3.length, a4 = [];
  t2 > n4 && (t2 = n4);
  for (let s3 = 0; s3 < t2; s3++)
    a4.push(Math.round(s3 * n4 / t2 - 1));
  a4.push(n4 - 1);
  let u2 = o2(a4, e3, l4, t2);
  return r(u2.mean, u2.sdcm, a4, e3, l4, t2) && (u2 = o2(a4, e3, l4, t2)), a4;
}
function o2(e3, l4, t2, n4) {
  let a4 = [], u2 = [], s3 = [], o3 = 0;
  const r2 = [], i2 = [];
  for (let b = 0; b < n4; b++) {
    const n5 = h(b, e3, l4, t2);
    r2.push(n5.sbMean), i2.push(n5.sbSdcm), o3 += i2[b];
  }
  let c3, f2 = o3, m3 = true;
  for (; m3 || o3 < f2; ) {
    m3 = false, a4 = [];
    for (let l5 = 0; l5 < n4; l5++)
      a4.push(e3[l5]);
    for (let t3 = 0; t3 < n4; t3++)
      for (let a5 = e3[t3] + 1; a5 <= e3[t3 + 1]; a5++)
        if (c3 = l4[a5], t3 > 0 && a5 !== e3[t3 + 1] && Math.abs(c3 - r2[t3]) > Math.abs(c3 - r2[t3 - 1]))
          e3[t3] = a5;
        else if (t3 < n4 - 1 && e3[t3] !== a5 - 1 && Math.abs(c3 - r2[t3]) > Math.abs(c3 - r2[t3 + 1])) {
          e3[t3 + 1] = a5 - 1;
          break;
        }
    f2 = o3, o3 = 0, u2 = [], s3 = [];
    for (let a5 = 0; a5 < n4; a5++) {
      u2.push(r2[a5]), s3.push(i2[a5]);
      const n5 = h(a5, e3, l4, t2);
      r2[a5] = n5.sbMean, i2[a5] = n5.sbSdcm, o3 += i2[a5];
    }
  }
  if (o3 > f2) {
    for (let l5 = 0; l5 < n4; l5++)
      e3[l5] = a4[l5], r2[l5] = u2[l5], i2[l5] = s3[l5];
    o3 = f2;
  }
  return { mean: r2, sdcm: i2 };
}
function r(e3, l4, t2, n4, a4, u2) {
  let s3 = 0, o3 = 0, r2 = 0, i2 = 0, c3 = true;
  for (let f2 = 0; f2 < 2 && c3; f2++) {
    0 === f2 && (c3 = false);
    for (let f3 = 0; f3 < u2 - 1; f3++)
      for (; t2[f3 + 1] + 1 !== t2[f3 + 2]; ) {
        t2[f3 + 1] = t2[f3 + 1] + 1;
        const u3 = h(f3, t2, n4, a4);
        r2 = u3.sbMean, s3 = u3.sbSdcm;
        const m3 = h(f3 + 1, t2, n4, a4);
        if (i2 = m3.sbMean, o3 = m3.sbSdcm, !(s3 + o3 < l4[f3] + l4[f3 + 1])) {
          t2[f3 + 1] = t2[f3 + 1] - 1;
          break;
        }
        l4[f3] = s3, l4[f3 + 1] = o3, e3[f3] = r2, e3[f3 + 1] = i2, c3 = true;
      }
    for (let f3 = u2 - 1; f3 > 0; f3--)
      for (; t2[f3] !== t2[f3 - 1] + 1; ) {
        t2[f3] = t2[f3] - 1;
        const u3 = h(f3 - 1, t2, n4, a4);
        r2 = u3.sbMean, s3 = u3.sbSdcm;
        const m3 = h(f3, t2, n4, a4);
        if (i2 = m3.sbMean, o3 = m3.sbSdcm, !(s3 + o3 < l4[f3 - 1] + l4[f3])) {
          t2[f3] = t2[f3] + 1;
          break;
        }
        l4[f3 - 1] = s3, l4[f3] = o3, e3[f3 - 1] = r2, e3[f3] = i2, c3 = true;
      }
  }
  return c3;
}
function i(e3, l4, t2, n4, a4) {
  let u2 = Math.max(n4 - e3, l4 - n4) / a4 / t2;
  return u2 = u2 >= 1 ? 1 : u2 >= 0.5 ? 0.5 : 0.25, u2;
}
function c2(e3) {
  let l4 = 0;
  for (let t2 = 0; t2 < e3.length; t2++)
    l4 += e3[t2];
  return l4 /= e3.length, l4;
}
function f(e3, l4) {
  let t2 = 0;
  for (let n4 = 0; n4 < e3.length; n4++) {
    const a4 = e3[n4];
    t2 += (a4 - l4) * (a4 - l4);
  }
  t2 /= e3.length;
  return Math.sqrt(t2);
}
function h(e3, l4, t2, n4) {
  let a4 = 0, u2 = 0;
  for (let r2 = l4[e3] + 1; r2 <= l4[e3 + 1]; r2++) {
    const e4 = n4[r2];
    a4 += t2[r2] * e4, u2 += e4;
  }
  u2 <= 0 && console.log("Exception in Natural Breaks calculation");
  const s3 = a4 / u2;
  let o3 = 0;
  for (let r2 = l4[e3] + 1; r2 <= l4[e3 + 1]; r2++)
    o3 += n4[r2] * (t2[r2] - s3) ** 2;
  return { sbMean: s3, sbSdcm: o3 };
}

export {
  l3 as l,
  t
};
//# sourceMappingURL=chunk-DGELARKE.js.map
