import {
  C,
  D as D4,
  F as F2,
  S,
  a as a7,
  e as e5,
  f as f3,
  s as s4,
  s2 as s5,
  te,
  w
} from "./chunk-XVC34HIT.js";
import {
  n as n7
} from "./chunk-5SHHATAH.js";
import {
  b as b3,
  je
} from "./chunk-3ITGQWSQ.js";
import {
  E as E3,
  b as b2,
  d as d2,
  e as e3,
  g as g2
} from "./chunk-AZ33IVEJ.js";
import {
  c as c3,
  o as o8
} from "./chunk-23E5E222.js";
import {
  f as f2
} from "./chunk-DYRM6FXE.js";
import {
  o as o9,
  t as t5
} from "./chunk-UVXRU6XP.js";
import {
  E as E4,
  F,
  Fe,
  Ke,
  Le,
  Me,
  Ne,
  Oe,
  P,
  Se,
  a as a6,
  ce,
  ct,
  h as h5,
  he,
  it,
  ke,
  me,
  st,
  ue,
  xe
} from "./chunk-RHH23PAT.js";
import {
  B as B2
} from "./chunk-HPO2NV7P.js";
import {
  A as A5,
  e as e6
} from "./chunk-HTS3HEEU.js";
import {
  t as t2
} from "./chunk-LAHCYKZK.js";
import {
  t2 as t3
} from "./chunk-AIONJO5O.js";
import {
  c as c2
} from "./chunk-5LWMNFCG.js";
import {
  r as r7
} from "./chunk-EPNT7GPS.js";
import {
  o as o7
} from "./chunk-OYNEZ5VG.js";
import {
  n as n6
} from "./chunk-KETNREBT.js";
import {
  o as o4
} from "./chunk-TR3U55RZ.js";
import {
  U,
  i,
  t as t4,
  x
} from "./chunk-WQLER7IU.js";
import {
  V
} from "./chunk-MOXYEJRV.js";
import {
  o as o6
} from "./chunk-MDCKEJ7B.js";
import {
  v as v3
} from "./chunk-SOZCO2CU.js";
import {
  E as E2,
  k2 as k
} from "./chunk-W2HLA6I3.js";
import {
  e as e2,
  r as r5
} from "./chunk-YFBAFAZ2.js";
import {
  e as e4
} from "./chunk-MEW2XKT2.js";
import {
  a as a4
} from "./chunk-3NPGGTI6.js";
import {
  l as l4
} from "./chunk-ZN2MGN4S.js";
import {
  L as L2
} from "./chunk-JZY7CGEI.js";
import {
  An,
  Bn,
  Un,
  _n,
  bn,
  vn,
  zn
} from "./chunk-PZWU5EHT.js";
import {
  s as s3
} from "./chunk-CQSGZXR7.js";
import {
  o as o5
} from "./chunk-7ZPDA3EC.js";
import {
  m
} from "./chunk-EGR3VVZG.js";
import {
  r as r4
} from "./chunk-U7B2WKBH.js";
import {
  r as r6
} from "./chunk-WKRVG5MO.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  h,
  l as l3
} from "./chunk-T7BEWVV3.js";
import {
  I,
  j as j2,
  u as u3
} from "./chunk-ASC3X65B.js";
import {
  b,
  h as h4
} from "./chunk-2EZYA7VW.js";
import {
  W
} from "./chunk-RN2KRYDN.js";
import {
  g as g3
} from "./chunk-BLINZ65M.js";
import {
  A as A4,
  h as h3
} from "./chunk-TADZYUVR.js";
import {
  A as A3,
  B,
  D as D3,
  G,
  H,
  M,
  a as a3
} from "./chunk-TMBOFNWA.js";
import {
  D as D2,
  E,
  h as h2,
  u as u4
} from "./chunk-56RHM4A6.js";
import {
  y as y2
} from "./chunk-5Z5455ZY.js";
import {
  a as a5
} from "./chunk-D7DLEBS2.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  n as n5
} from "./chunk-OIPX3EDD.js";
import {
  l as l2
} from "./chunk-FVPTCNCX.js";
import {
  r as r3
} from "./chunk-ZOKX6UGH.js";
import {
  L,
  O,
  o as o3,
  r as r2,
  u
} from "./chunk-PKZEO23A.js";
import {
  n as n4
} from "./chunk-AIRC226G.js";
import {
  A as A2,
  d,
  n4 as n,
  n8 as n3,
  v as v2,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  D,
  f,
  g,
  v
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  n as n2
} from "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  A2 as A,
  a,
  a2,
  c,
  l,
  o,
  o2,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SGeometryUtil.js
function i2(t8, r9, n11, a12) {
  const m2 = r9.getComponentAabb(n11, t8, p), s7 = r9.getObjectTransform(n11);
  for (let c7 = 0; c7 < 8; ++c7)
    b4[0] = 1 & c7 ? m2[0] : m2[3], b4[1] = 2 & c7 ? m2[1] : m2[4], b4[2] = 4 & c7 ? m2[2] : m2[5], O(b4, b4, s7.rotationScale), u(b4, b4, s7.position), a12[3 * c7] = b4[0], a12[3 * c7 + 1] = b4[1], a12[3 * c7 + 2] = b4[2];
  return a12;
}
function u5(e7, o11, r9) {
  const a12 = new Float64Array(24);
  return (u7) => {
    let l6 = u7.meta.featureExtents;
    if (t(l6)) {
      l6 = new Float64Array(6 * u7.meta.featureIds.length), u7.meta.featureExtents = l6;
      for (let t8 = 0; t8 < l6.length; t8 += 6)
        l6[t8] = Number.POSITIVE_INFINITY;
    }
    const p2 = new Float64Array(l6.buffer, 6 * u7.index * Float64Array.BYTES_PER_ELEMENT, 6);
    return p2[0] === Number.POSITIVE_INFINITY && (i2(u7.index, r9, u7.meta.objectHandle, a12), Un(a12, o11, 0, a12, e7, 0, 8) ? (A3(p2, D3), M(p2, a12, 0, 8)) : A3(p2, H)), p2;
  };
}
function l5(t8, r9, n11, a12) {
  const m2 = r9.getComponentAabb(n11, t8, p), s7 = r9.getObjectTransform(n11);
  a12[0] = 0, a12[1] = 0, a12[2] = 0;
  for (let c7 = 0; c7 < 8; ++c7)
    b4[0] = 1 & c7 ? m2[0] : m2[3], b4[1] = 2 & c7 ? m2[1] : m2[4], b4[2] = m2[5], O(b4, b4, s7.rotationScale), u(b4, b4, s7.position), a12[0] += b4[0], a12[1] += b4[1], a12[2] += b4[2];
  return a12[0] /= 8, a12[1] /= 8, a12[2] /= 8, a12;
}
var p = a3();
var b4 = n4();

// node_modules/@arcgis/core/views/3d/layers/II3SMeshView3D.js
var I2;
var L3;
!function(I3) {
  I3[I3.VISIBLE_ONLY = 0] = "VISIBLE_ONLY", I3[I3.ALL = 1] = "ALL", I3[I3.ALL_IN_CLIPPING_AREA = 2] = "ALL_IN_CLIPPING_AREA";
}(I2 || (I2 = {})), function(I3) {
  I3[I3.EXIT = 0] = "EXIT", I3[I3.CONTINUE = 1] = "CONTINUE", I3[I3.SKIP = 2] = "SKIP";
}(L3 || (L3 = {}));

// node_modules/@arcgis/core/views/3d/support/LimitGraphicsMap.js
var i3 = class extends n5 {
  constructor(e7) {
    super(), this._limit = e7, this._all = new s5(), this._active = new a8(this), this._pending = /* @__PURE__ */ new Map(), this._handle = this._all.on("change", (e8) => this._handleChanges(e8));
  }
  destroy() {
    this._handle.remove();
  }
  get length() {
    return this._active.length;
  }
  toArray() {
    return this._active.toArray();
  }
  find(e7) {
    return this._active.find(e7);
  }
  forEach(e7) {
    this._active.forEach(e7);
  }
  addMany(e7) {
    this._all.addMany(e7);
  }
  removeManyByObjectId(e7) {
    this._all.removeManyByObjectId(e7);
  }
  _handleChanges(e7) {
    let t8 = e7.removed;
    if (this._pending.size > 0) {
      t8 = new Array();
      for (const s8 of e7.removed)
        this._pending.delete(s8.objectId) || t8.push(s8);
    }
    let s7 = this._limit - this._active.length + t8.length;
    s7 < e7.added.length && (this._active.removeMany(t8), t8 = [], h6.reset(1 - this._limit / (this._active.length + e7.added.length)), this._active.forEach((e8) => {
      h6.sample() && (t8.push(e8), this._pending.set(e8.objectId, e8));
    }), s7 = this._limit - this._active.length + t8.length);
    let i7 = e7.added;
    if (s7 < e7.added.length) {
      i7 = new Array(), h6.reset(s7 / e7.added.length);
      for (const t9 of e7.added)
        h6.sample() ? i7.push(t9) : this._pending.set(t9.objectId, t9);
    }
    const n11 = s7 - i7.length;
    n11 > 0 && this._pending.size > 0 && (h6.reset(n11 / this._pending.size), this._pending.forEach((e8) => {
      h6.sample() && (i7.push(e8), this._pending.delete(e8.objectId));
    })), this._active.addAndRemove(i7, t8);
  }
};
var n8 = class {
  constructor() {
    this.percentage = 1, this.last = -1, this.index = 0;
  }
  reset(e7) {
    this.percentage = e7, this.last = -1;
  }
  sample() {
    const e7 = Math.floor(this.index * this.percentage);
    return ++this.index, e7 !== this.last && (this.last = e7, true);
  }
};
var h6 = new n8();
var a8 = class {
  constructor(e7) {
    this._parent = e7, this._map = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._map.size;
  }
  forEach(e7) {
    this._map.forEach((t8) => e7(t8));
  }
  find(e7) {
    let s7;
    return n2(this._map, (t8) => !!e7(t8) && (s7 = t8, true)), s7;
  }
  toArray() {
    return [...this._map.values()];
  }
  addAndRemove(e7, t8) {
    for (const s7 of e7)
      this._map.set(s7.objectId, s7);
    for (const s7 of t8)
      this._map.delete(s7.objectId);
    (e7.length > 0 || t8.length > 0) && this._parent.emit("change", { added: e7, removed: t8 });
  }
  removeMany(e7) {
    for (const t8 of e7)
      this._map.delete(t8.objectId);
    e7.length > 0 && this._parent.emit("change", { added: [], removed: e7 });
  }
};

// node_modules/@arcgis/core/views/3d/layers/I3SMeshViewLabeler.js
var _ = class extends y {
  constructor(e7) {
    super(e7), this.loadedGraphics = new i3(5e4), this.slicePlaneEnabled = false, this._renderingInfo = { symbol: new h3() }, this._handles = new u2(), this._graphicsByNode = /* @__PURE__ */ new Map(), this._scaleVisibility = new b3({ layerScaleEnabled: false });
  }
  initialize() {
    this._graphicsCore = new je({ owner: this, layer: this.layer, preferredUpdatePolicy: o6.ASYNC, elevationFeatureExpressionEnabled: false, graphicSymbolSupported: false, getRenderingInfoWithoutRenderer: true, hasZ: true, hasM: false });
    const e7 = this.view.basemapTerrain;
    this._scaleVisibility.setup(this, this.layer, (e8, i8, t9) => this._graphicsCore.spatialIndex.queryGraphicUIDsInExtent(e8, i8, t9), this._graphicsCore, e7);
    const i7 = this.view.labeler.addGraphicsOwner(this._graphicsCore, this._scaleVisibility, { emptySymbolLabelSupported: true, elevationInfoOverride: { mode: "absolute-height", offset: 0 }, disablePlacement: { logEntityDescription: "3D Object Scene Layer features" } }), t8 = this.view.deconflictor.addGraphicsOwner(this._graphicsCore);
    this._graphicsCore.setup({ labeler: i7, deconflictor: t8, scaleVisibility: this._scaleVisibility }).then(() => this._graphicsCore.startCreateGraphics()).catch(() => {
    }), this._handles.add(l3(() => this.layer.labelingInfo, (e8, i8) => {
      m(e8, i8) && this._graphicsCore.updateLabelingInfo();
    }));
  }
  destroy() {
    this._handles = l(this._handles), this._scaleVisibility = l(this._scaleVisibility), this._graphicsCore = l(this._graphicsCore), this.loadedGraphics = l(this.loadedGraphics), this.view = null;
  }
  addNodeMeta(e7, t8) {
    let r9 = 0;
    const s7 = e7.filteredIds, a12 = this.view.spatialReference, l6 = e7.featureIds.map((l7, p2) => {
      l5(p2, this.collection, e7.objectHandle, C2);
      const c7 = v3(0, 0, 0, a12);
      this.view.renderCoordsHelper.fromRenderCoords(C2, c7);
      const n11 = t8(p2, e7);
      let h7 = false;
      return t(s7) ? h7 = true : r9 < s7.length && l7 === s7[r9] && (h7 = true, r9++), { objectId: l7, uid: g3.generateUID(), attributes: n11, visible: h7, geometry: c7 };
    });
    this.loadedGraphics.addMany(l6), this._graphicsByNode.set(e7.node.index, l6);
  }
  updateLabelPositions(e7) {
    const i7 = this._graphicsByNode.get(e7.node.index);
    let t8 = 0;
    const r9 = this.view.spatialReference, s7 = [];
    for (let o11 = 0; o11 < e7.featureIds.length; o11++) {
      const l6 = i7[t8];
      if (e7.featureIds[o11] === l6.objectId) {
        if (t8++, l5(o11, this.collection, e7.objectHandle, C2), this.view.renderCoordsHelper.fromRenderCoords(C2, C2, r9), r(l6.geometry) && "point" === l6.geometry.type && l6.geometry.x === C2[0] && l6.geometry.y === C2[1] && l6.geometry.z === C2[2])
          continue;
        r(l6.geometry) && "point" === l6.geometry.type ? (l6.geometry.x = C2[0], l6.geometry.y = C2[1], l6.geometry.z = C2[2]) : l6.geometry = v3(C2[0], C2[1], C2[2], r9), s7.push(l6.uid);
      }
    }
    this._graphicsCore.updateLabelingInfo(s7);
  }
  setNodeMetaAttributes(e7, i7) {
    const t8 = this._graphicsByNode.get(e7.node.index), r9 = new Array(t8.length);
    for (let s7 = 0; s7 < t8.length; s7++) {
      const o11 = t8[s7];
      o11.attributes = i7(s7, e7), r9[s7] = o11.uid;
    }
    this._graphicsCore.updateLabelingInfo(r9);
  }
  applyFilterChange(e7) {
    const i7 = this._graphicsByNode.get(e7.node.index);
    if (i7)
      if (t(e7.filteredIds))
        for (const t8 of i7)
          t8.visible || (t8.visible = true, v4.graphic = t8, v4.property = "visible", v4.oldValue = false, v4.newValue = true, this._graphicsCore.graphicUpdateHandler(v4));
      else {
        let t8 = 0;
        for (const r9 of i7) {
          const i8 = r9.visible;
          t8 < e7.filteredIds.length && r9.objectId === e7.filteredIds[t8] ? (r9.visible = true, t8++) : r9.visible = false, i8 !== r9.visible && (v4.graphic = r9, v4.property = "visible", v4.oldValue = i8, v4.newValue = r9.visible, this._graphicsCore.graphicUpdateHandler(v4));
        }
      }
  }
  removeNodeMeta(e7) {
    this.loadedGraphics.removeManyByObjectId(e7.featureIds);
  }
  getRenderingInfo() {
    return this._renderingInfo;
  }
  notifyGraphicGeometryChanged() {
  }
  notifyGraphicVisibilityChanged() {
  }
  get updatePolicy() {
    return this._graphicsCore.effectiveUpdatePolicy;
  }
  get usedMemory() {
    return this._graphicsCore.usedMemory;
  }
  get unloadedMemoryEstimate() {
    return this._graphicsCore.unprocessedMemoryEstimate;
  }
  get test() {
    return { graphicsCore: this._graphicsCore };
  }
};
e([d()], _.prototype, "view", void 0), e([d()], _.prototype, "layer", void 0), e([d()], _.prototype, "collection", void 0), e([d()], _.prototype, "loadedGraphics", void 0), e([d({ aliasOf: "_graphicsCore.updating" })], _.prototype, "updating", void 0), e([d()], _.prototype, "slicePlaneEnabled", void 0), e([d()], _.prototype, "_graphicsCore", void 0), _ = e([n3("esri.views.3d.layers.I3SMeshViewLabeler")], _);
var v4 = { graphic: null, property: null, oldValue: null, newValue: null };
var C2 = n4();
var j3 = _;

// node_modules/@arcgis/core/views/3d/layers/I3SMeshWorkerHandle.js
var i4 = s.getLogger("esri.views.3d.layers.I3SMeshWorkerHandle");
var u6 = class extends n6 {
  constructor(s7) {
    super("SceneLayerWorker", "process", { process: (s8) => [s8.geometryBuffer] }, s7, { hasInitialize: true });
  }
  setModifications(s7, e7, t8, o11) {
    const p2 = { context: s7, modifications: c4(e7, t8, o11), isGeodetic: o11.isGeographic };
    this.broadcast(p2, "setModifications");
  }
  setLegacySchema(s7, e7) {
    const t8 = JSON.stringify(e7);
    this.broadcast({ context: s7, jsonSchema: t8 }, "setLegacySchema");
  }
  destroyContext(s7) {
    return this.broadcast(s7, "destroyContext");
  }
};
var n9 = new n({ deallocator: null });
var a9 = [0, 0, 0];
function c4(s7, t8, o11) {
  n9.clear();
  let u7 = 1 / 0, c7 = 1 / 0, f4 = -1 / 0, l6 = -1 / 0, m2 = false;
  for (const e7 of t8) {
    const s8 = "clip" === e7.type ? e3.Inside : "mask" === e7.type ? e3.Outside : e3.Replace, t9 = e7.geometry;
    let d4 = (s9) => s9;
    if (t9.spatialReference) {
      if (!An(t9.spatialReference, o11)) {
        i4.warn("Can't project modification polygon into layer spatial reference, ignoring modification");
        continue;
      }
      d4 = (s9) => (Bn(s9, t9.spatialReference, a9, o11), a9);
    } else
      t9.hasZ || (a9[2] = 0, d4 = (s9) => (a9[0] = s9[0], a9[1] = s9[1], a9));
    m2 = m2 || s8 === e3.Outside, n9.push(s8), n9.push(t9.rings.length);
    for (const e8 of t9.rings) {
      n9.push(e8.length);
      for (const s9 of e8) {
        const e9 = d4(s9);
        n9.push(e9[0]), n9.push(e9[1]), n9.push(e9[2]), u7 = Math.min(u7, e9[0]), c7 = Math.min(c7, e9[1]), f4 = Math.max(f4, e9[0]), l6 = Math.max(l6, e9[1]);
      }
    }
  }
  if (r(s7))
    if (m2) {
      const e7 = 1e-4;
      n9.push(e3.Inside), n9.push(2), n9.push(4), n9.push(u7 - e7), n9.push(c7 - e7), n9.push(0), n9.push(f4 + e7), n9.push(c7 - e7), n9.push(0), n9.push(f4 + e7), n9.push(l6 + e7), n9.push(0), n9.push(u7 - e7), n9.push(l6 + e7), n9.push(0), n9.push(4), n9.push(s7[0]), n9.push(s7[1]), n9.push(0), n9.push(s7[2]), n9.push(s7[1]), n9.push(0), n9.push(s7[2]), n9.push(s7[3]), n9.push(0), n9.push(s7[0]), n9.push(s7[3]), n9.push(0);
    } else
      n9.push(e3.Outside), n9.push(1), n9.push(4), n9.push(s7[0]), n9.push(s7[1]), n9.push(0), n9.push(s7[2]), n9.push(s7[1]), n9.push(0), n9.push(s7[2]), n9.push(s7[3]), n9.push(0), n9.push(s7[0]), n9.push(s7[3]), n9.push(0);
  n9.push(e3.Finished);
  const d3 = new Float64Array(n9.length);
  for (let e7 = 0; e7 < n9.length; ++e7)
    d3[e7] = n9.getItemAt(e7);
  return d3;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/Highlights.js
var s6 = class {
  constructor() {
    this.ids = /* @__PURE__ */ new Set(), this.paused = false;
  }
};
var i5 = class {
  constructor({ collection: e7, forAllFeatures: t8, forAllFeaturesOfNode: s7 }) {
    this.highlights = [], this.collection = e7, this.forAllFeatures = t8, this.forAllFeaturesOfNode = s7;
  }
  destroy() {
    this.highlights.forEach((e7) => this._releaseSet(e7)), this.highlights = null;
  }
  acquireSet() {
    const t8 = new s6();
    this.highlights.push(t8);
    const i7 = { remove: () => {
      this._releaseSet(t8), A(this.highlights, t8);
    }, pause: () => {
      this._releaseSet(t8), t8.paused = true;
    }, resume: () => {
      t8.paused = false, this._initializeSet(t8);
    } };
    return { set: t8, handle: i7 };
  }
  setFeatureIds(e7, t8) {
    t8.forEach((t9) => e7.ids.add(t9)), this._initializeSet(e7);
  }
  _initializeSet(e7) {
    this.forAllFeatures((s7, i7, h7) => (e7.ids.has(s7) && this.collection.addComponentHighlight(h7.objectHandle, i7), L3.CONTINUE));
  }
  _releaseSet(e7) {
    this.forAllFeatures((s7, i7, h7) => (e7.ids.has(s7) && this.collection.removeComponentHighlight(h7.objectHandle, i7), L3.CONTINUE));
  }
  objectCreated(e7) {
    this.highlights.forEach((s7) => {
      s7.paused || this.forAllFeaturesOfNode(e7, (i7, h7) => (s7.ids.has(i7) && this.collection.addComponentHighlight(e7.objectHandle, h7), L3.CONTINUE));
    });
  }
  objectDeleted(e7) {
    this.collection.clearHighlights(e7.objectHandle);
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SAsyncElevationUpdater.js
var i6 = class extends y {
  constructor(e7, s7) {
    super({}), this._updateElevation = s7, this.running = false, this._nodeSet = /* @__PURE__ */ new Set(), this.own(e7.registerTask(L2.ELEVATION_ALIGNMENT, this));
  }
  normalizeCtorArgs() {
    return {};
  }
  schedule(e7) {
    this._nodeSet.add(e7), this.running = true;
  }
  remove(e7) {
    this._nodeSet.delete(e7), this._updateRunning();
  }
  runTask(e7) {
    const s7 = this._nodeSet;
    for (const r9 of s7)
      if (s7.delete(r9), this._updateElevation(r9), e7.madeProgress(), e7.done)
        break;
    this._updateRunning();
  }
  _updateRunning() {
    this.running = this._nodeSet.size > 0;
  }
};
e([d()], i6.prototype, "running", void 0), i6 = e([n3("esri.views.3d.layers.i3s.I3SAsyncElevationUpdater.ts")], i6);

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SCrossfadeHelper.js
var t6 = class {
  constructor() {
    this.lodCrossfadeSignedDuration = 0;
  }
};
var a10 = class {
  constructor(e7) {
    this.view = e7, this._preRenderFrameTaskHandle = null, this._currentFrameStartTime = null, this._numFadingNodes = 0;
  }
  get updating() {
    return this._numFadingNodes > 0;
  }
  stopNodeFading(s7) {
    null != s7.lodCrossfadeProgress && (this._numFadingNodes--, s7.lodCrossfadeProgress = null, 0 === this._numFadingNodes && (null != this._preRenderFrameTaskHandle && (this._preRenderFrameTaskHandle = a2(this._preRenderFrameTaskHandle)), this.view.notifyLODUpdate(), this.view.notifyUpdate()));
  }
  _startNodeFading(e7, s7, o11) {
    0 === this._numFadingNodes && (this._preRenderFrameTaskHandle = A2({ preRender: (e8) => this._updateAllNodeFading(e8) }), this.view.notifyLODUpdate()), null == e7.lodCrossfadeProgress && (this._numFadingNodes++, this.view.notifyUpdate()), e7.lodCrossfadeSignedDuration = o11, e7.lodCrossfadeProgress = s7;
  }
  _updateAllNodeFading(e7) {
    const o11 = this.view.nodeCrossfadingEnabled;
    this.view.foreachCrossfadeNode((d3, i7) => {
      if (r(i7) && r(i7.lodCrossfadeProgress)) {
        const s7 = i7.lodCrossfadeSignedDuration, t8 = s7 > 0 ? this.view.fullOpacity : 0, a12 = e7.deltaTime / s7, r9 = i7.lodCrossfadeProgress + Math.abs(a12), n11 = !o11 || r9 >= 1 || 0 === s7, l6 = t8 - (n11 ? 0 : s7 > 0 ? 1 : -1) * (1 - r9);
        n11 ? (this.stopNodeFading(i7), s7 < 0 && this.view.markNodeToRemove(d3)) : i7.lodCrossfadeProgress = r9, this.view.setNodeOpacityByIndex(d3, l6);
      }
    }), this.view.removeMarkedNodes();
  }
  stopAllNodeFading() {
    this.view.foreachCrossfadeNode((e7, o11) => {
      if (r(o11) && r(o11.lodCrossfadeProgress)) {
        this.stopNodeFading(o11);
        const s7 = o11.lodCrossfadeSignedDuration;
        s7 < 0 && this.view.markNodeToRemove(e7);
        const d3 = s7 > 0 ? this.view.fullOpacity : 0;
        this.view.setNodeOpacityByIndex(e7, d3);
      }
    }), this.view.removeMarkedNodes();
  }
  fadeNode(e7, s7, o11, d3) {
    null == this._currentFrameStartTime && (this._currentFrameStartTime = Date.now());
    const t8 = this.view, a12 = t8.nodeCrossfadingEnabled, n11 = o11 === a7.FadeIn ? t8.fullOpacity : 0, l6 = a12 ? d3 ? o11 === a7.FadeIn ? t8.lodCrossfadeinDuration : t8.lodCrossfadeoutDuration : t8.lodCrossfadeUncoveredDuration : 0, h7 = this.view.getNodeOpacityByIndex(e7);
    if (a12 && h7 !== n11 && l6 > 0) {
      const e8 = 1 - Math.abs(n11 - h7);
      this._startNodeFading(s7, e8, r8(o11) * l6);
    } else
      this.stopNodeFading(s7), this.view.setNodeOpacityByIndex(e7, n11), o11 === a7.FadeOut && this.view.removeNode(e7);
  }
  isNodeFullyFadedIn(e7) {
    const s7 = this.view.getNodeCrossfadeMetaData(e7);
    return t(s7) || null == s7.lodCrossfadeProgress && this.view.getNodeOpacityByIndex(e7) === this.view.fullOpacity;
  }
};
function r8(e7) {
  return e7 === a7.FadeIn ? 1 : -1;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SElevationProvider.js
var E5 = D2();
var g4 = e2();
var j4 = n4();
var b5 = n4();
var R = n4();
var w2 = s.getLogger("esri.views.3d.layers.i3s.I3SElevationProvider");
var S2 = class extends n5.EventedMixin(y) {
  constructor(e7) {
    super(e7), this.tmpEvent = { spatialReference: null, extent: E5, context: "scene" };
  }
  initialize() {
    this.view = this.layerView.view, this.renderCoordsHelper = this.view.renderCoordsHelper, this.intersector = x(this.view.state.viewingMode), this.intersector.options.store = t4.MIN;
    const e7 = this.layerView.i3slayer.fullExtent;
    t(e7) ? w2.error("I3SElevationProvider expected fullExtent on I3SLayer.") : (this.zmin = e7.zmin, this.zmax = e7.zmax), this.tmpEvent.context = this.intersectionHandler.isGround ? "ground" : "scene";
  }
  getElevation(e7, t8, r9, s7) {
    if (j4[0] = e7, j4[1] = t8, j4[2] = r9, !this.renderCoordsHelper.toRenderCoords(j4, s7, j4))
      return w2.error("could not project point to compute elevation"), null;
    const i7 = this.layerView.elevationOffset, o11 = this.zmin + i7, n11 = this.zmax + i7;
    return this.renderCoordsHelper.setAltitude(b5, n11, j4), this.renderCoordsHelper.setAltitude(R, o11, j4), this.intersector.reset(b5, R, null), this.intersectionHandler.intersect(this.intersector, null, b5, R), this.intersector.results.min.getIntersectionPoint(j4) ? this.renderCoordsHelper.getAltitude(j4) : null;
  }
  layerChanged() {
    this.spatialReference && (this.tmpEvent.extent = this._computeLayerExtent(), this.tmpEvent.spatialReference = this.spatialReference, this.emit("elevation-change", this.tmpEvent));
  }
  objectChanged(e7) {
    this.spatialReference && (this.tmpEvent.extent = this._computeObjectExtent(e7), this.tmpEvent.spatialReference = this.spatialReference, this.emit("elevation-change", this.tmpEvent));
  }
  _computeObjectExtent(e7) {
    return D2(E5), this._expandExtent(e7, E5), E5;
  }
  _computeLayerExtent() {
    D2(E5);
    for (const e7 of this.layerView.getVisibleNodes())
      this._expandExtent(e7, E5);
    return E5;
  }
  _expandExtent(e7, t8) {
    const r9 = e7.visibilityObb || e7.serviceObbInRenderSR;
    if (r(r9)) {
      I(g4, r9.quaternion), g4[12] = r9.center[0], g4[13] = r9.center[1], g4[14] = r9.center[2];
      for (let e8 = 0; e8 < 8; ++e8)
        j4[0] = 1 & e8 ? r9.halfSize[0] : -r9.halfSize[0], j4[1] = 2 & e8 ? r9.halfSize[1] : -r9.halfSize[1], j4[2] = 4 & e8 ? r9.halfSize[2] : -r9.halfSize[2], L(j4, j4, g4), this.renderCoordsHelper.fromRenderCoords(j4, j4, this.spatialReference), h2(t8, j4, t8);
    } else {
      const r10 = k(e7.renderMbs), s7 = r2(b5, E2(e7.renderMbs));
      s7[0] -= r10, s7[1] -= r10, s7[2] -= r10;
      const i7 = r2(R, E2(e7.renderMbs));
      i7[0] += r10, i7[1] += r10, i7[2] += r10;
      for (let e8 = 0; e8 < 8; ++e8)
        j4[0] = 1 & e8 ? s7[0] : i7[0], j4[1] = 2 & e8 ? s7[1] : i7[1], j4[2] = 4 & e8 ? s7[2] : i7[2], this.renderCoordsHelper.fromRenderCoords(j4, j4, this.spatialReference), h2(t8, j4, t8);
    }
  }
};
e([d({ constructOnly: true })], S2.prototype, "layerView", void 0), e([d({ constructOnly: true })], S2.prototype, "intersectionHandler", void 0), e([d()], S2.prototype, "view", void 0), e([d({ readOnly: true, aliasOf: "view.elevationProvider.spatialReference" })], S2.prototype, "spatialReference", void 0), S2 = e([n3("esri.views.3d.layers.i3s.I3SElevationProvider")], S2);
var z = S2;

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SIntersectionHandler.js
var c5 = class {
  constructor(e7) {
    this.type = i.I3S, this._needVerticalOffset = false, this.layerUid = e7.layerUid, this.sublayerUid = e7.sublayerUid, this.collection = e7.collection, this.traverseNodeHierarchy = e7.traverseNodeHierarchy, this.slicePlaneEnabled = e7.slicePlaneEnabled, this.isGround = e7.isGround;
  }
  updateElevationAlignState(e7, t8) {
    this._needVerticalOffset = e7 && t8 === l4.Global;
  }
  intersect(r9, l6, c7, u7) {
    const f4 = r9.results, m2 = r9.options.store === t4.ALL, h7 = r9.ray.direction, p2 = r9.tolerance;
    let y3 = (e7) => e7, g5 = (e7) => e7;
    const O2 = V(r(r9.verticalOffset) ? r9.verticalOffset : this._needVerticalOffset ? 0 : null);
    r(r9.verticalOffset) && r(O2) && (y3 = (e7) => O2.applyToMbs(e7), g5 = (e7) => O2.applyToObb(e7)), this.traverseNodeHierarchy((d3, a12) => {
      if (0 === d3.childrenLoaded)
        return false;
      const v5 = r(d3.serviceObbInRenderSR) && st(d3.serviceObbInRenderSR) ? d3.serviceObbInRenderSR : null;
      return !(r(v5) && !P(g5(v5), c7, h7, p2)) && (a12 && (r(v5) || !ct(d3.renderMbs) || b6(y3(d3.renderMbs), c7, h7, p2)) && (t(d3.geometryObb) || P(g5(d3.geometryObb), c7, h7, p2)) && this.collection.intersect(a12, c7, u7, p2, O2, (e7, t8, i7, s7) => {
        if (t8 >= 0) {
          if (null != l6 && !l6(c7, u7, t8))
            return;
          const n11 = (r10) => {
            const n12 = { layerUid: this.layerUid, sublayerUid: this.sublayerUid, nodeIndex: d3.index, componentIndex: e7, triangleNr: s7 };
            r10.set(this.type, n12, t8, i7);
          };
          if (this.isGround && (null == f4.ground.dist || t8 < f4.ground.dist) && n11(f4.ground), r9.options.isFiltered)
            return;
          if ((null == f4.min.dist || t8 < f4.min.dist) && n11(f4.min), (null == f4.max.dist || t8 > f4.max.dist) && n11(f4.max), m2) {
            const e8 = U(r9.ray);
            n11(e8), r9.results.all.push(e8);
          }
        }
      }), true);
    });
  }
};
function b6(e7, t8, r9, i7 = 0) {
  const s7 = e7[3] + i7, n11 = t8[0] - e7[0], o11 = t8[1] - e7[1], l6 = t8[2] - e7[2], d3 = r9[0], a12 = r9[1], c7 = r9[2], b7 = d3 * n11 + a12 * o11 + c7 * l6;
  return b7 * b7 - (d3 * d3 + a12 * a12 + c7 * c7) * (n11 * n11 + o11 * o11 + l6 * l6 - s7 * s7) >= 0;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/IDBCache.js
var o10 = 14;
var n10 = class {
  constructor(t8, s7, r9 = o10) {
    this._version = r9, this._db = null, this._quotaReductionPromise = null, this._gcCounter = 0, this._hit = 0, this._miss = 0, this._destroyed = false, this.gcFrequency = 50, this.maxByteSize = o5.GIGABYTES, this.quotaReductionFactor = 0.2, this._dbName = t8, this._storeName = s7;
  }
  init() {
    return Promise.resolve().then(() => {
      const e7 = indexedDB.open(this._dbName, this._version);
      return e7.onupgradeneeded = (t8) => {
        const s7 = e7.result, r9 = e7.transaction, i7 = s7.objectStoreNames.contains(this._storeName) ? r9.objectStore(this._storeName) : s7.createObjectStore(this._storeName), o11 = s7.objectStoreNames.contains("last_access") ? r9.objectStore("last_access") : s7.createObjectStore("last_access");
        o11.indexNames.contains("date") || o11.createIndex("date", "date", { unique: false }), o11.indexNames.contains("byteSize") || o11.createIndex("byteSize", "byteSize", { unique: false }), t8.oldVersion < this._version && (i7.clear(), o11.clear());
      }, a11(e7);
    }).then((e7) => {
      this._destroyed ? e7.close() : this._db = e7;
    });
  }
  destroy() {
    this._db && (this._db.close(), this._db = null), this._destroyed = true;
  }
  get initialized() {
    return null != this._db;
  }
  getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  put(e7, s7) {
    if (null == this._db)
      return Promise.reject(new s2("indexedb:not-initialized", "IndexedDB Cache is not initialized"));
    return (null != this._quotaReductionPromise ? this._quotaReductionPromise : Promise.resolve()).then(() => this._put(e7, s7)).catch((t8) => {
      if (t8 && "QuotaExceededError" === t8.name)
        return null == this._quotaReductionPromise && (this._quotaReductionPromise = this._getCacheSize().then((e8) => this._removeLeastRecentlyAccessed(s7.byteSize + Math.ceil(e8 * this.quotaReductionFactor))), this._quotaReductionPromise.then(() => this._quotaReductionPromise = null, () => this._quotaReductionPromise = null)), this._quotaReductionPromise.then(() => this._put(e7, s7));
      throw t8;
    }).then(() => {
      this._gcCounter--, this._gcCounter < 0 && null != this._db && (this._gcCounter = this.gcFrequency, this._getCacheSize().then((e8) => this._removeLeastRecentlyAccessed(e8 - this.maxByteSize)));
    });
  }
  get(e7, t8) {
    if (null == this._db)
      return Promise.resolve(null);
    let o11 = null;
    return Promise.resolve().then(() => {
      const s7 = this._db.transaction(this._storeName, "readonly");
      o11 = v(t8, () => {
        s7.abort();
      });
      return a11(s7.objectStore(this._storeName).get(e7));
    }).then((t9) => {
      if (null == t9)
        ++this._miss;
      else if (this._db) {
        ++this._hit;
        this._db.transaction("last_access", "readwrite").objectStore("last_access").put({ date: Date.now(), byteSize: t9.byteSize }, e7);
      }
      return r(o11) && o11.remove(), t9;
    }).catch(() => (++this._miss, f(t8), r(o11) && o11.remove(), null));
  }
  remove(e7) {
    return null == this._db ? Promise.resolve() : Promise.resolve().then(async () => {
      const t8 = this._db.transaction([this._storeName, "last_access"], "readwrite"), s7 = t8.objectStore(this._storeName), r9 = t8.objectStore("last_access"), i7 = s7.delete(e7), o11 = r9.delete(e7);
      await Promise.all([a11(i7), a11(o11), c6(t8)]);
    });
  }
  _put(e7, t8) {
    const s7 = this._db.transaction([this._storeName, "last_access"], "readwrite"), r9 = s7.objectStore(this._storeName), i7 = s7.objectStore("last_access"), o11 = r9.put(t8, e7), n11 = i7.put({ date: Date.now(), byteSize: t8.byteSize }, e7);
    return Promise.all([a11(o11), a11(n11), c6(s7)]);
  }
  _removeLeastRecentlyAccessed(e7) {
    if (e7 <= 0 || !this._db)
      return;
    const t8 = this._db.transaction([this._storeName, "last_access"], "readwrite"), s7 = t8.objectStore(this._storeName), r9 = t8.objectStore("last_access");
    let i7 = 0;
    const o11 = r9.index("date").openCursor(null, "next");
    return o11.onsuccess = () => {
      const t9 = o11.result;
      null != t9 && (null != t9.value.byteSize && (i7 += t9.value.byteSize), s7.delete(t9.primaryKey), r9.delete(t9.primaryKey), i7 < e7 && t9.continue());
    }, c6(t8);
  }
  _getCacheSize() {
    const e7 = this._db.transaction("last_access"), t8 = e7.objectStore("last_access");
    let s7 = 0;
    const r9 = t8.index("byteSize").openKeyCursor();
    return r9.onsuccess = () => {
      const e8 = r9.result;
      if (!e8)
        return;
      const t9 = e8.key;
      null != t9 && (s7 += t9), e8.continue();
    }, c6(e7).then(() => s7);
  }
};
function c6(e7) {
  return new Promise((t8, s7) => {
    e7.oncomplete = () => t8(), e7.onerror = () => s7(e7.error), e7.onabort = () => s7(e7.error);
  });
}
function a11(e7) {
  return new Promise((t8, s7) => {
    "done" === e7.readyState ? null != e7.error ? s7(e7.error) : t8(e7.result) : (e7.onsuccess = () => t8(e7.result), e7.onerror = () => s7(e7.error));
  });
}

// node_modules/@arcgis/core/views/3d/layers/i3s/IDBMockCache.js
var t7 = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map(), this._miss = 0, this._hit = 0, this.initialized = true;
  }
  init() {
    return Promise.resolve();
  }
  async get(t8, s7) {
    return this._data.has(t8) ? (this._hit++, this._data.get(t8)) : (this._miss++, null);
  }
  destroy() {
  }
  put(t8, s7) {
    return this._data.set(t8, s7), Promise.resolve();
  }
  remove(t8) {
    return this._data.delete(t8), Promise.resolve();
  }
  getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
};

// node_modules/@arcgis/core/views/3d/layers/I3SMeshView3D.js
var ht = s.getLogger("esri.views.3d.layers.SceneLayerView3D");
var ct2 = [1, 1, 1, 1];
var ut = class extends t6 {
  constructor(e7, t8, i7, s7, r9, o11, a12) {
    super(), this.node = e7, this.featureIds = t8, this.objectHandle = i7, this.cachedRendererVersion = s7, this.attributeInfo = r9, this.material = o11, this.textures = a12, this.cachedEdgeMaterials = new Array(), this.edgeMemoryUsage = 0, this.cachedSymbology = null;
  }
};
var _t;
!function(e7) {
  e7[e7.CastShadows = 4] = "CastShadows", e7[e7.Pickable = 5] = "Pickable";
}(_t || (_t = {}));
var mt = 19;
var gt = 100 * o5.MEGABYTES;
var pt = (t8) => {
  let r9 = class extends t8 {
    constructor(...e7) {
      super(e7), this._elevationProvider = null, this._intersectionHandler = null, this._nodeId2Meta = /* @__PURE__ */ new Map(), this._nodeId2MetaReloading = /* @__PURE__ */ new Map(), this._i3sWasmLoaded = false, this._snappingSourcesTrackers = [], this._hasLoadedPBRTextures = false, this._asyncModuleLoading = 0, this._addTasks = /* @__PURE__ */ new Map(), this._rendererVersion = 0, this._colorVariable = null, this._opacityVariable = null, this._rendererFields = null, this._symbologyFields = null, this._symbologyOverride = null, this._symbologyOverrideFields = null, this._symbolInfos = /* @__PURE__ */ new Map(), this._idbCache = a("enable-feature:idb-mock-cache") ? new t7() : new n10("esri-scenelayer-cache", "geometries"), this.holeFilling = "auto", this._hasColors = false, this._hasTextures = false, this._hasData = false, this.filter = null, this.slicePlaneEnabled = false, this._modifications = new Array(), this._layerUrl = "", this._cacheKeySuffix = null, this._elevationTask = null, this._arcade = null, this._tmpAttributeOnlyGraphic = new g3(null, null, {}), this._crossfadeHelper = new a10(this);
    }
    get lodCrossfadeoutDuration() {
      return 0;
    }
    get lodCrossfadeinDuration() {
      return 0;
    }
    get lodCrossfadeUncoveredDuration() {
      return 0;
    }
    get layerUid() {
      return this.i3slayer && this.i3slayer.uid;
    }
    get sublayerUid() {
      return null;
    }
    get hasTexturesOrVertexColors() {
      return this._hasData ? this._hasTextures || this._hasColors ? "yes" : "probably-not" : "unknown";
    }
    get rendererTextureUsage() {
      return Fe(this._currentRenderer) ? this._usePBR() || this._hasLoadedPBRTextures ? s4.AllTexturesPBR : s4.AllTextures : this._usePBR() || this._hasLoadedPBRTextures ? s4.GeometryTexturesPBR : s4.GeometryTextures;
    }
    get elevationOffset() {
      const e7 = null != this.i3slayer ? this.i3slayer.elevationInfo : null;
      if (null != e7 && "absolute-height" === e7.mode) {
        const t9 = W(this.i3slayer.spatialReference), i7 = r6(e7.unit);
        return c(e7.offset, 0) * i7 / t9;
      }
      return 0;
    }
    get elevationInfo() {
      const e7 = null != this.i3slayer ? this.i3slayer.elevationInfo : null;
      if (null == e7)
        return { mode: Nt.Absolute, offset: 0 };
      const t9 = W(this.i3slayer.spatialReference), i7 = r6(e7.unit), s7 = c(e7.offset, 0) * i7 / t9;
      switch (e7.mode) {
        case "absolute-height":
          return { mode: Nt.Absolute, offset: s7 };
        case "relative-to-ground":
          return { mode: Nt.RelativeToGround, offset: s7 };
        case "on-the-ground":
          return { mode: Nt.OnTheGround, offset: 0 };
        default:
          return { mode: Nt.Absolute, offset: 0 };
      }
    }
    get supportedTextureEncodings() {
      return D4(this.view._stage.renderView.capabilities);
    }
    get uncompressedTextureDownsamplingEnabled() {
      var _a;
      const e7 = (_a = this.view) == null ? void 0 : _a.qualitySettings.sceneService.uncompressedTextureDownsamplingEnabled, t9 = 0 == (this.supportedTextureEncodings & e5.DDS_S3TC);
      return e7 && t9;
    }
    initialize() {
      this._preLoadBasis(), this.addResolvingPromise(this.i3slayer.indexInfo);
      const e7 = this.view.resourceController;
      if (this.attributeOverrides = new f3(this.i3slayer, e7.memoryController), this._worker = new u6((t10) => e7.schedule(t10)), this.addResolvingPromise(this._worker.promise), this._worker.setLegacySchema(this.layerUid, this.i3slayer.store.defaultGeometrySchema), Ne(this.i3slayer), ke(this.i3slayer, this.view), this._layerUrl = this.i3slayer.parsedUrl.path, this._controller = new te({ layerView: this }), this.gpuMemoryEstimate = 0, this.texMemoryEstimate = 0, this.geoMemoryEstimate = 0, this._stage = this.view._stage, this._collection = this._stage.renderView.componentObjectCollection, this._highlights = new i5({ collection: this._collection, forAllFeatures: (e8) => this._forAllFeatures(e8, null, I2.ALL), forAllFeaturesOfNode: (e8, t10) => this._forAllFeaturesOfNode(e8, t10) }), this._isIntegratedMesh || !this.i3slayer.store.defaultGeometrySchema)
        this._hasComponentData = false;
      else {
        const e8 = this.i3slayer.store.defaultGeometrySchema.featureAttributes;
        this._hasComponentData = !!(e8 && e8.faceRange && e8.id);
      }
      this._hasVertexColors = null != this.i3slayer.store.defaultGeometrySchema.vertexAttributes.color && (null == this.i3slayer.cachedDrawingInfo || !this.i3slayer.cachedDrawingInfo.color), this._isIntegratedMesh || (this._edgeView = this._stage.renderView.ensureEdgeView());
      const t9 = this.view.resourceController.memoryController.newCache(this.i3slayer.uid, (e8) => this._deleteComponentObject(e8));
      this._memCache = t9;
      const i7 = (e8) => r(this._controller.index) && r(this._controller.index.rootNode) ? this._controller.index.traverse(this._controller.index.rootNode, (t10) => {
        const i8 = t10.index, s8 = this._nodeId2Meta.get(i8) || this._nodeId2MetaReloading.get(i8);
        return e8(t10, r(s8) ? s8.objectHandle : null);
      }) : () => {
      };
      this._intersectionHandler = new c5({ layerUid: this.layerUid, sublayerUid: this.sublayerUid, collection: this._collection, slicePlaneEnabled: this.slicePlaneEnabled, isGround: this._isIntegratedMesh, traverseNodeHierarchy: i7 }), this._elevationProvider = new z({ layerView: this, intersectionHandler: this._intersectionHandler }), this._hasLoadedPBRTextures = this._usePBR(), this.updatingHandles.add(() => this.view.clippingArea, () => this._clippingAreaChanged(), h), this.updatingHandles.add(() => this.fullOpacity, (e8) => this._opacityChange(e8)), this.updatingHandles.add(() => this.slicePlaneEnabled, (e8) => this._slicePlaneEnabledChange(e8)), this.updatingHandles.add(() => this.elevationOffset, (e8, t10) => {
        this._reloadAll(t10), this._controller.invalidateVisibilityObbs();
      }), this.updatingHandles.add(() => this.elevationInfo, (e8, t10) => this._elevationInfoChanged(e8, t10), h), this.updatingHandles.add(() => this.filter, () => this._filterChange(), h), this.updatingHandles.add(() => this.view.qualitySettings.physicallyBasedRenderingEnabled, () => this._updatePBR());
      const s7 = () => {
        this._reloadAll(), this.clearMemCache();
      };
      this.updatingHandles.add(() => this.rendererTextureUsage, s7), this.updatingHandles.add(() => this.uncompressedTextureDownsamplingEnabled, s7), this.updatingHandles.add(() => this.suspended, (e8) => this._suspendedChange(e8), h), this.updatingHandles.add(() => this.i3slayer.labelsVisible, () => this._labelingChanged(), h), this.updatingHandles.add(() => this.i3slayer.labelingInfo, () => this._labelingChanged(), h), this.updatingHandles.add(() => this._modifications, () => this._modificationsChanged(), h), this.handles.add([l3(() => t3.I3S_TREE_SHOW_TILES, (e8) => {
        if (e8 && !this._treeDebugger) {
          const e9 = this._controller.crsIndex;
          import("./I3STreeDebugger-6WIFAK4L.js").then(({ I3STreeDebugger: t10 }) => {
            !this._treeDebugger && t3.I3S_TREE_SHOW_TILES && (this._treeDebugger = new t10({ lv: this, view: this.view, nodeSR: e9 }));
          });
        } else
          e8 || t3.I3S_TREE_SHOW_TILES || (this._treeDebugger = l(this._treeDebugger));
      }, h), l3(() => t3.I3S_SHOW_MODIFICATIONS, () => this._showModifications(), h)]), this._cacheKeySuffix = xe(this.i3slayer.spatialReference, this.view.renderSpatialReference), this._idbCache.init().catch((e8) => ht.warn(`Failed to initialize IndexedDB cache: ${e8}`));
    }
    destroy() {
      this._clearAddTasks(), this._elevationTask = l(this._elevationTask), this.attributeOverrides = l(this.attributeOverrides), this._elevationProvider && (this._elevationProvider.layerChanged(), this.view.elevationProvider.unregister(this._elevationProvider), this._elevationProvider = null), this._intersectionHandler && (this._stage.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler), this._intersectionHandler = null);
      const e7 = this._worker;
      e7 && (e7.destroyContext(this.i3slayer.uid).then(() => e7.destroy()), this._worker = null), this._removeAllNodeDataFromStage(), this._memCache = l(this._memCache), this._collection = null, this._stage = null, this._edgeView = null, this._labeler = l(this._labeler), this._treeDebugger = l(this._treeDebugger), this._controller = l(this._controller), this._highlights.destroy(), this._nodeId2Meta.clear(), this._nodeId2MetaReloading.clear(), this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle.remove(), this._visibleGeometryChangedSchedulerHandle = null);
    }
    _memEstimateTextureAdded(e7) {
      const t9 = e7.estimatedTexMemRequired;
      return this.gpuMemoryEstimate += t9, this.texMemoryEstimate += t9, t9;
    }
    _memEstimateTextureRemoved(e7) {
      if (r(e7)) {
        const t9 = e7.estimatedTexMemRequired;
        this.gpuMemoryEstimate -= t9, this.texMemoryEstimate -= t9;
      }
    }
    _memEstimateGeometryAdded(e7) {
      const t9 = this._collection.getObjectGPUMemoryUsage(e7);
      return this.gpuMemoryEstimate += t9, this.geoMemoryEstimate += t9, t9;
    }
    _memEstimateGeometryRemoved(e7) {
      const t9 = this._collection.getObjectGPUMemoryUsage(e7);
      this.gpuMemoryEstimate -= t9, this.geoMemoryEstimate -= t9;
    }
    isNodeLoaded(e7) {
      return this._nodeId2Meta.has(e7);
    }
    isNodeReloading(e7) {
      return this._nodeId2MetaReloading.has(e7);
    }
    getUsedMemory() {
      let e7 = r(this._labeler) ? this._labeler.usedMemory : 0;
      return this._nodeId2Meta.forEach((t9) => e7 += r(t9) ? t9.node.memory : 0), this._nodeId2MetaReloading.forEach((t9) => e7 += r(t9) ? t9.node.memory : 0), e7;
    }
    getUnloadedMemory() {
      return (r(this._controller) ? this._controller.unloadedMemoryEstimate : 0) + (r(this._labeler) ? this._labeler.unloadedMemoryEstimate : 0);
    }
    ignoresMemoryFactor() {
      return false;
    }
    _labelingChanged() {
      if (!(s3(this.i3slayer) && this._supportsLabeling))
        return void (r(this._labeler) && (this._labeler.destroy(), this._labeler = null));
      if (r(this._labeler))
        return;
      const e7 = new j3({ view: this.view, layer: this.i3slayer, collection: this._collection });
      this._nodeId2Meta.forEach((t9) => r(t9) && this._addMetaToLabeler(e7, t9)), this._labeler = e7;
    }
    _loadAsyncModule(e7) {
      return ++this._asyncModuleLoading, e7.then((e8) => (--this._asyncModuleLoading, e8), (e8) => {
        throw --this._asyncModuleLoading, e8;
      });
    }
    _modificationsChanged() {
      if (!this._i3sWasmLoaded && this.hasModifications)
        return this._i3sWasmLoaded = g2().then(() => {
          this._i3sWasmLoaded = true, this._modificationsChanged(), this.notifyUpdate();
        }), void this.notifyUpdate();
      if (true !== this._i3sWasmLoaded)
        return;
      const e7 = this.i3slayer.uid, t9 = this.i3slayer.spatialReference;
      this._worker.setModifications(e7, this._layerClippingArea, this._modifications, t9);
      const i7 = c4(this._layerClippingArea, this._modifications, t9);
      b2({ context: e7, modifications: i7, isGeodetic: t9.isGeographic }), this._controller.modificationsChanged();
      const s7 = this.hasModifications ? new n() : null;
      this._nodeId2Meta.forEach((e8, t10) => {
        t(e8) ? (this._nodeId2Meta.delete(t10), this._controller.updateLoadStatus(t10, false)) : e8.node.hasModifications ? (this._nodeId2Meta.delete(t10), this._nodeId2MetaReloading.set(t10, e8)) : r(s7) && s7.push(e8.node);
      }), r(s7) && this._nodeId2MetaReloading.forEach((e8) => s7.push(e8.node)), r(s7) && s7.length > 0 && (this.updateNodeModificationStatus(s7), s7.forAll((e8) => {
        if (e8.imModificationImpact !== o8.Culled) {
          const t10 = this._nodeId2Meta.get(e8.index);
          this._controller.invalidateGeometryVisibility(e8.index), r(t10) ? (this._nodeId2Meta.delete(e8.index), this._nodeId2MetaReloading.set(e8.index, t10)) : this._nodeId2Meta.has(e8.index) && (this._nodeId2Meta.delete(e8.index), this._controller.updateLoadStatus(e8.index, false));
        }
      })), this.clearMemCache(), this._controller.restartNodeLoading(), this._showModifications();
    }
    _showModifications() {
      if (r(this._modificationGraphics) && (this.view.graphics.removeMany(this._modificationGraphics), this._modificationGraphics = null), !t3.I3S_SHOW_MODIFICATIONS || 0 === this._modifications.length)
        return;
      const e7 = { clip: [227, 227, 79, 0.8], mask: [227, 139, 79, 0.8], replace: [139, 227, 79, 0.8] }, t9 = { type: "simple-fill", outline: { color: [255, 255, 255], width: 1 } };
      this._modificationGraphics = new Array();
      for (const s7 of this._modifications) {
        s7.geometry.spatialReference = this.i3slayer.spatialReference;
        const r10 = { ...t9, color: e7[s7.type] };
        this._modificationGraphics.push(new g3({ geometry: s7.geometry, symbol: r10 }));
      }
      this.view.graphics.addMany(this._modificationGraphics);
    }
    _addMetaToLabeler(e7, t9) {
      e7.addNodeMeta(t9, (e8, t10) => this._createAttributes(e8, t10));
    }
    _suspendedChange(e7) {
      e7 ? (this._removeAllNodeDataFromStage(), this.view.elevationProvider && this.view.elevationProvider.unregister(this._elevationProvider), this._stage.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler)) : (this.view.elevationProvider.register(this._elevationContext, this._elevationProvider), this._stage.sceneIntersectionHelper.addIntersectionHandler(this._intersectionHandler));
    }
    getLoadedAttributes(e7) {
      const t9 = this._nodeId2Meta.get(e7);
      if (r(t9) && r(t9.attributeInfo))
        return t9.attributeInfo.loadedAttributes;
    }
    getAttributeData(e7) {
      const t9 = this._nodeId2Meta.get(e7);
      if (r(t9) && r(t9.attributeInfo))
        return t9.attributeInfo.attributeData;
    }
    setAttributeData(e7, t9) {
      const i7 = this._nodeId2Meta.get(e7);
      r(i7) && r(i7.attributeInfo) && (i7.attributeInfo.attributeData = t9, this._attributeValuesChanged(i7));
    }
    async updateAttributes(e7, t9, i7) {
      const s7 = this._nodeId2Meta.get(e7);
      r(s7) && (await this.attributeOverrides.apply(s7.featureIds, t9, i7), s7.attributeInfo = t9, this._attributeValuesChanged(s7));
    }
    _attributeValuesChanged(e7) {
      e7.cachedRendererVersion = this._getInvalidRendererVersion(), e7.filteredIds = null, r(this._labeler) && this._labeler.setNodeMetaAttributes(e7, (e8, t9) => this._createAttributes(e8, t9)), this._updateEngineObject(e7);
    }
    clearMemCache() {
      r(this._memCache) && this._memCache.clear();
    }
    getVisibleNodes() {
      const e7 = new Array();
      return this._nodeId2Meta.forEach((t9) => r(t9) && e7.push(t9.node)), e7;
    }
    getLoadedNodeIndices(e7) {
      this._nodeId2Meta.forEach((t9, i7) => e7.push(i7)), this._nodeId2MetaReloading.forEach((t9, i7) => e7.push(i7));
    }
    _preLoadBasis() {
      !a("disable-feature:i3s-basis") && 0 != (this.supportedTextureEncodings & e5.Basis) && o(this.i3slayer.textureSetDefinitions, (e7) => e7.some((e8) => e8.formats.some((e9) => "basis" === e9.format || "ktx2" === e9.format))) && c2();
    }
    _getVertexBufferLayout(e7, t9) {
      const i7 = { hasTexture: Ot(e7.params.material), hasNormals: t9.normal, hasRegions: t9.uvRegion };
      return o4(o9(this._getGeometryParameters(i7)));
    }
    _getObjectIdField() {
      return this.i3slayer.objectIdField || "OBJECTID";
    }
    _findGraphicNodeAndIndex(e7) {
      const t9 = n7(this.i3slayer.fieldsIndex, e7.attributes, this._getObjectIdField());
      let i7 = null;
      return n2(this._nodeId2Meta, (e8) => {
        if (t(e8))
          return false;
        const s7 = e8.featureIds.indexOf(t9);
        return -1 !== s7 && (i7 = { node: e8.node, index: s7 }, true);
      }), i7;
    }
    _getGraphicIndices(e7, t9) {
      const i7 = this._nodeId2Meta.get(e7.index);
      if (t(i7))
        return [];
      const s7 = [], r10 = this._getObjectIdField(), o11 = this.i3slayer.fieldsIndex;
      for (const a12 of t9) {
        const e8 = n7(o11, a12.attributes, r10), t10 = i7.featureIds.indexOf(e8);
        -1 !== t10 && s7.push(t10);
      }
      return s7;
    }
    whenGraphicBounds(e7) {
      const t9 = this._findGraphicNodeAndIndex(e7);
      if (!t9)
        return Promise.reject();
      const i7 = this._getAABB(t9.node.index, t9.index);
      return t(i7) ? Promise.reject() : Promise.resolve({ boundingBox: i7, screenSpaceObjects: [] });
    }
    getAABBFromIntersectorTarget(e7) {
      return null == e7.nodeIndex || null == e7.componentIndex ? null : this._getAABB(e7.nodeIndex, e7.componentIndex);
    }
    _getAABB(e7, t9) {
      const i7 = this._nodeId2Meta.get(e7);
      if (t(i7) || null == i7.featureIds || t9 >= i7.featureIds.length)
        return null;
      const s7 = i7.objectHandle, r10 = i2(t9, this._collection, s7, new Float64Array(24)), o11 = this.view.renderSpatialReference, a12 = this.view.spatialReference;
      if (!Un(r10, o11, 0, r10, a12, 0, 8))
        return null;
      const n11 = B();
      return M(n11, r10, 0, 8), n11;
    }
    whenGraphicAttributes(e7, t9) {
      return Se(this.i3slayer, e7, this._getObjectIdField(), t9, () => [...this._nodeId2Meta.values()].filter(r));
    }
    getGraphicFromIntersectorTarget(e7) {
      if (null == e7.nodeIndex || null == e7.componentIndex)
        return null;
      const t9 = this._nodeId2Meta.get(e7.nodeIndex);
      return t(t9) || null == t9.featureIds || e7.componentIndex >= t9.featureIds.length ? null : this._createGraphic(e7.componentIndex, t9);
    }
    _getCacheKey(e7) {
      return `${this._layerUrl}/v${mt}/${e7.id}${this._cacheKeySuffix}`;
    }
    _getMemCacheKey(e7, t9 = this.elevationOffset) {
      return e7 + "#" + t9;
    }
    get _idbCacheEnabled() {
      return !this._controller.disableIDBCache && !this.hasModifications && 0 === this.elevationOffset && null != this._cacheKeySuffix;
    }
    loadCachedGPUData(e7) {
      return r(this._memCache) ? this._memCache.pop(this._getMemCacheKey(e7.index)) : null;
    }
    deleteCachedGPUData(e7) {
      r(e7) && this._deleteComponentObject(e7);
    }
    _cacheGPUData(e7, t9 = this.elevationOffset) {
      if (t(this._memCache))
        return void this._deleteComponentObject(e7);
      const i7 = this._controller.indexDepth - e7.node.level;
      this._memCache.put(this._getMemCacheKey(e7.node.index, t9), e7, e7.node.memory, i7);
    }
    loadMissingTextures(e7, t9, i7, s7) {
      const r10 = (e7 == null ? void 0 : e7.filter((e8, i8) => {
        if (0 == (e8.usage & this.rendererTextureUsage))
          return false;
        if (t(t9))
          return true;
        const s8 = w(e8.encodings, this.supportedTextureEncodings), r11 = t9[i8];
        return !!(t(r11) || null == r11.data || s8 && r11.encoding !== s8.encoding);
      })) ?? [];
      return 0 === r10.length ? Promise.resolve(false) : i7(r10, s7).then((i8) => {
        let s8 = 0;
        for (let r11 = 0; r11 < e7.length; r11++)
          s8 < i8.length && i8[s8].id === e7[r11].id && (t9[r11] = i8[s8], s8++);
        return true;
      });
    }
    loadCachedNodeData(e7, t9, i7) {
      return this._idbCacheEnabled ? this._idbCache.get(this._getCacheKey(e7), t9).then((s7) => null == s7 ? null : s7.nodeVersion !== e7.version ? (this._idbCache.remove(this._getCacheKey(e7)), null) : (this.elevationInfo.mode === Nt.Absolute && (e7.geometryObb = s7.geometryObb), this.loadMissingTextures(s7.requiredTextures, s7.textureData, i7, t9).then((i8) => (i8 && this._idbCache.initialized && r(s7.textureData) && (s7.byteSize = jt(s7.transformedGeometry, s7.textureData), s7.textureData.every(wt) && Tt(e7, s7) && this._idbCache.put(this._getCacheKey(e7), s7).catch((t10) => ht.warn(`Failed to update node with textures in IndexedDB cache: ${e7.id}: ${t10}`))), f(t9), s7)))) : Promise.resolve(null);
    }
    addNode(e7, t9, i7) {
      return St(t9) ? null == t9.geometryBuffer ? (this._addNodeMeta(e7.index, null), Promise.resolve()) : this._addData(e7, t9.attributeDataInfo, () => this._transformNode(e7, t9, i7).then((s7) => this._safeReschedule(() => {
        if (t(s7))
          return e7.hasModifications = false, this._addCachedNodeData(e7, null, i7);
        e7.hasModifications = s7.transformedGeometry.hasModifications;
        const { obb: r10, componentOffsets: o11, featureIds: a12, transformedGeometry: n11 } = s7, l6 = this._controller.crsIndex, d3 = this.view.renderSpatialReference, h7 = a6(e7.mbs, this.elevationOffset, l6, d3), _2 = E4([r10.center.x, r10.center.y, r10.center.z], [r10.extents.x, r10.extents.y, r10.extents.z], [r10.orientation.x, r10.orientation.y, r10.orientation.z, r10.orientation.w]);
        L(_2.center, _2.center, h7), this.elevationInfo.mode === Nt.Absolute && (e7.geometryObb = _2), t9.geometryData.componentOffsets = o11, a12 && (t9.geometryData.featureIds = Array.from(a12));
        const m2 = { nodeVersion: e7.version, geometryData: t9.geometryData, requiredTextures: t9.requiredTextures, textureData: t9.textureData, transformedGeometry: n11, globalTrafo: h7, geometryObb: _2, byteSize: jt(n11, t9.textureData) };
        if (this._idbCacheEnabled && this._idbCache.initialized && Tt(e7, m2)) {
          const t10 = r(m2.textureData) ? m2.textureData.map((e8) => wt(e8) ? e8 : null) : null;
          this._idbCache.put(this._getCacheKey(e7), { ...m2, textureData: t10 }).catch((t11) => ht.warn(`Failed to store node in IndexedDB cache: ${e7.id}: ${t11}`));
        }
        return this._addCachedNodeData(e7, m2, i7);
      }, i7))) : Promise.reject();
    }
    computeVisibilityObb(e7) {
      return it(e7, this.view.renderSpatialReference, this._controller.crsIndex, this.i3slayer.spatialReference, this.elevationOffset, this._modifications);
    }
    _transformNode(e7, t9, i7) {
      const s7 = t9.geometryData.geometries, r10 = new Array(s7.length);
      for (let u7 = 0; u7 < s7.length; ++u7)
        r10[u7] = this._getVertexBufferLayout(s7[u7], t9.geometryDescriptor);
      const o11 = e7.mbs, a12 = this.elevationOffset, n11 = this._controller.crsIndex, l6 = this._controller.crsVertex, d3 = this.view.renderSpatialReference, h7 = h5(o11, a12, n11), c7 = a6(o11, a12, n11, d3), _2 = _n(n11, l6), m2 = _n(l6, d3);
      if (t(_2) || t(m2))
        return Promise.resolve(null);
      const g5 = { context: this.i3slayer.uid, geometryBuffer: t9.geometryBuffer, geometryData: t9.geometryData, geometryDescriptor: t9.geometryDescriptor, layouts: r10, localOrigin: h7, globalTrafo: c7, mbs: o11, obb: e7.serviceObb, elevationOffset: a12, needNormals: !this._isIntegratedMesh && this._controller.isMeshPyramid, normalReferenceFrame: this.i3slayer.normalReferenceFrame || "none", indexToVertexProjector: _2, vertexToRenderProjector: m2 };
      return this._worker.invoke(g5, i7);
    }
    get supportsNodeCrossFading() {
      var _a, _b;
      return !((_b = (_a = this.view) == null ? void 0 : _a._stage) == null ? void 0 : _b.renderView.shadowsEnabled);
    }
    get nodeCrossfadingEnabled() {
      return this.supportsNodeCrossFading && (this.lodCrossfadeinDuration > 0 || this.lodCrossfadeoutDuration > 0 || this.lodCrossfadeUncoveredDuration > 0);
    }
    get nodeFadeoutEnabled() {
      return this.supportsNodeCrossFading && this.lodCrossfadeoutDuration > 0;
    }
    _setNewNodeOpacity(e7) {
      const t9 = this.nodeCrossfadingEnabled ? 0 : this.fullOpacity;
      this._setNodeOpacity(e7, t9);
    }
    addCachedGPUData(e7, t9, i7) {
      if (this.elevationInfo.mode === Nt.Absolute && (e7.geometryObb = F(this._collection.getComponentObb(t9.objectHandle))), !this._controller.isGeometryVisible(e7))
        return void this._cacheGPUData(t9);
      r(this._labeler) && this._addMetaToLabeler(this._labeler, t9);
      const s7 = e7.index;
      this._addNodeMeta(s7, t9), this.updateNodeState(s7, i7), this._collection.setObjectVisibility(t9.objectHandle, t5.Visible), this._updateMaterial(t9), this._setNewNodeOpacity(t9), this.elevationInfo.mode !== Nt.Absolute && this._scheduleElevationAlign(e7.index), this._updateEngineObject(t9), this._highlights.objectCreated(t9), r(this._treeDebugger) && this._treeDebugger.update();
    }
    addCachedNodeData(e7, t9, i7, s7) {
      return this._addData(e7, i7, () => this._addCachedNodeData(e7, t9, s7));
    }
    async _addCachedNodeData(e7, t9, i7) {
      var _a;
      if (this.suspended || !this._controller.isGeometryVisible(e7))
        return void this._removeNodeStageData(e7.index, this.elevationOffset, this._nodeId2MetaReloading);
      if (t(t9))
        return void this._addNodeMeta(e7.index, null);
      const s7 = this._addTasks.get(e7.index), { geometryData: r10, transformedGeometry: o11, globalTrafo: n11 } = t9;
      await this.attributeOverrides.apply(r10.featureIds, s7.attributeInfo, i7);
      const l6 = r(t9.textureData) ? t9.textureData.filter((e8) => r(e8) && 0 != (e8.usage & this.rendererTextureUsage)) : [];
      !a("disable-feature:i3s-basis") && l6.some((e8) => r(e8) && (e8.encoding === e5.Basis || e8.encoding === e5.KTX2)) && await c2(), e7.memory = 0;
      const { componentOffsets: d3, geometries: h7, featureIds: _2 } = r10, m2 = this._collection, g5 = h7[0], { layout: p2, indices: f4, interleavedVertexData: b7, positionData: y3, hasColors: v5 } = o11, I3 = this._materialParameters(g5, p2), M2 = d3 || new Uint32Array([0, f4 ? f4.length : b7.byteLength / p2[0].stride]), C3 = { vertices: { data: b7, count: b7.byteLength / p2[0].stride, layoutParameters: I3.geometryParams }, positionData: { positions: y3.data, indices: y3.indices }, indices: f4, componentOffsets: M2 }, E6 = g5.transformation ? r5(g5.transformation) : e2();
      u3(E6, n11, E6);
      const D5 = j2(n4(), E6), A6 = a4(e4(), E6), R2 = this.view.renderSpatialReference, N = this.view.basemapTerrain.spatialReference, F3 = n4(), V2 = [1, 1, 1];
      vn(D5, R2, V2, N) || ht.errorOnce("Unsupported coordinate system for IM overlay"), Bn(D5, R2, F3, N);
      const H2 = m2.createObject({ toMapSpace: r4(F3[0], F3[1], V2[0], V2[1]), geometry: C3, obb: t9.geometryObb, transform: { position: D5, rotationScale: A6 } }), G2 = I3.geometryParams.textureCoordinates === o7.Atlas, { textures: B3, texturePromise: q } = this._initMaterialAndTextures(H2, I3.material, l6, G2);
      e7.memory += this._memEstimateGeometryAdded(H2), e7.memory += B3.reduce((e8, t10) => e8 + (r(t10) ? this._memEstimateTextureAdded(t10) : 0), 0);
      const z2 = !!I3.material.hasParametersFromSource, K = "blend" !== I3.material.alphaMode && I3.material.metallicRoughness.baseColorFactor[3] >= 1, W2 = new ut(e7, _2, H2, this._getInvalidRendererVersion(), s7.attributeInfo, { hasParametersFromSource: z2, isOpaque: K }, B3);
      s7.meta = W2, !this._hasTextures && ((_a = t9.requiredTextures) == null ? void 0 : _a.some(({ usage: e8 }) => 0 != (e8 & s4.ColorTextures))) && (this._hasTextures = true), this._hasData = true, this._hasColors = this._hasColors || v5, this._hasTextures = this._hasTextures || !!e7.resources.texture, this.notifyChange("hasTexturesOrVertexColors");
      const $ = this.slicePlaneEnabled;
      return Promise.all([this._addOrUpdateEdgeRendering(W2), q]).then(([t10, s8]) => (r(t10) && t10.updateObjectVisibility(W2.objectHandle, false).catch(this._logEdgeViewError), this._safeReschedule(() => {
        const i8 = this._addTasks.get(e7.index);
        if (!i8)
          return;
        if (this._addNodeMeta(e7.index, W2), i8.meta = null, this.suspended)
          return void this._removeNodeStageData(e7.index, this.elevationOffset);
        m2.setObjectVisibility(H2, t5.Visible), r(t10) && t10.updateObjectVisibility(W2.objectHandle, true).catch(this._logEdgeViewError), W2.attributeInfo = i8.attributeInfo;
        const s9 = W2.cachedRendererVersion !== this._rendererVersion, r11 = $ !== this.slicePlaneEnabled;
        this._updateElevationOffsets(W2);
        const o12 = W2.elevationOffsets;
        this._updateComponentData(W2);
        const a12 = this._applyFiltersToNode(W2);
        (s9 || r(t10) && (r11 || a12 || o12)) && this._addOrUpdateEdgeRendering(W2), r(this._labeler) && this._addMetaToLabeler(this._labeler, W2), this._visibleGeometryChanged(W2, ft.ADD), this._highlights.objectCreated(W2), this._updateMaterial(W2), this._setNewNodeOpacity(W2), r(this._treeDebugger) && this._treeDebugger.update();
      }, i7))).catch((e8) => {
        throw r(s7.meta) && (this._cacheGPUData(s7.meta), s7.meta = null), e8;
      });
    }
    _addNodeMeta(e7, t9) {
      if (this._removeNodeStageData(e7, this.elevationOffset, this._nodeId2MetaReloading), this._nodeId2Meta.has(e7)) {
        ht.error("Removing duplicated node");
        const t10 = this._nodeId2Meta.get(e7);
        r(t10) && this._deleteComponentObject(t10);
      } else
        this._controller.updateLoadStatus(e7, true);
      r(t9) && (t9.lodCrossfadeProgress = null, this.nodeCrossfadingEnabled && Rt(t9.cachedEdgeMaterials, 0)), this._nodeId2Meta.set(e7, t9);
    }
    _updateElevationOffsets(e7) {
      const t9 = this.view.renderSpatialReference, i7 = this.elevationInfo;
      if (t(t9) || i7.mode === Nt.Absolute)
        return void (e7.elevationOffsets = null);
      const s7 = this.view.basemapTerrain, r10 = this._collection.getObjectTransform(e7.objectHandle);
      e7.elevationOffsets = e7.elevationOffsets ?? [];
      const o11 = Ft, a12 = Pt;
      for (let n11 = 0; n11 < e7.featureIds.length; n11++) {
        this._collection.getComponentAabb(e7.objectHandle, n11, a12, true), o3(o11, (a12[0] + a12[3]) / 2, (a12[1] + a12[4]) / 2, a12[2]), O(o11, o11, r10.rotationScale), u(o11, o11, r10.position);
        const l6 = s7.getElevation(o11[0], o11[1], o11[2], t9), d3 = i7.mode === Nt.OnTheGround ? this.view.renderCoordsHelper.getAltitude(o11) : 0;
        e7.elevationOffsets[n11] = i7.offset + (r(l6) ? l6 - d3 : 0);
      }
    }
    _elevationChanged(e7) {
      const t9 = this._controller.crsIndex;
      zn(e7.extent, e7.spatialReference, xt, t9);
      const i7 = this._controller.updateElevationChanged(xt, t9);
      t(i7) || i7.forAll((e8) => {
        r(this._nodeId2Meta.get(e8)) && this._scheduleElevationAlign(e8);
      });
    }
    _scheduleElevationAlign(e7) {
      let t9 = this._elevationTask;
      t(t9) && (t9 = new i6(this.view.resourceController.scheduler, (e8) => {
        const t10 = this._nodeId2Meta.get(e8);
        r(t10) && (this._updateElevationOffsets(t10), this._updateComponentData(t10), this._updateEdgeRendering(t10), r(this._labeler) && this._labeler.updateLabelPositions(t10));
      }), this._elevationTask = t9), t9.schedule(e7);
    }
    _elevationInfoChanged(e7, t9) {
      const i7 = e7.mode !== Nt.Absolute, s7 = null != t9 && t9 !== e7 && t9.mode !== Nt.Absolute;
      i7 && !s7 ? (this.handles.add(this.view.basemapTerrain.on("elevation-change", (e8) => this._elevationChanged(e8)), "elevation"), this._controller.removeAllGeometryObbs()) : s7 && !i7 && this.handles.remove("elevation"), this._intersectionHandler.updateElevationAlignState(i7, this.view.state.viewingMode), this._nodeId2Meta.forEach((e8) => {
        r(e8) && (s7 && !i7 && (e8.node.geometryObb = F(this._collection.getComponentObb(e8.objectHandle))), this._updateElevationOffsets(e8), this._updateComponentData(e8), this._updateEdgeRendering(e8), r(this._labeler) && this._labeler.updateLabelPositions(e8));
      });
    }
    _safeReschedule(e7, t9) {
      return f(t9), this._controller.reschedule(e7, t9);
    }
    _materialParameters(e7, t9) {
      const i7 = r(e7.params.material) ? e7.params.material : F2(), s7 = t9.some((e8) => "uvRegion" === e8.name), r10 = t9.some((e8) => "normalCompressed" === e8.name), o11 = Ot(i7);
      return { geometryParams: this._getGeometryParameters({ hasTexture: o11, hasNormals: r10, hasRegions: s7 }), material: i7 };
    }
    _initMaterialAndTextures(e7, t9, i7, s7) {
      const r10 = this._stage.renderView, o11 = i7.map((e8) => C(e8, t9, s7, r10));
      this._stage.addMany(o11);
      let a12 = null;
      return this._collection.updateMaterial(e7, (e8) => {
        a12 = S(e8, t9, o11, i7, this.view._stage.renderView.textureRepository, { rendererTextureUsage: this.rendererTextureUsage, usePBR: this._usePBR(), isIntegratedMesh: this._isIntegratedMesh, slicePlaneEnabled: this.slicePlaneEnabled, viewSpatialReference: this.view.spatialReference }), this._updateMaterialOverlay(e8);
      }), { textures: o11, texturePromise: a12 };
    }
    _getGeometryParameters(e7) {
      return { textureCoordinates: e7.hasTexture ? e7.hasRegions ? o7.Atlas : o7.Default : o7.None, colors: this._hasVertexColors, normals: e7.hasNormals && !this._isIntegratedMesh };
    }
    _addData(e7, t9, i7) {
      let s7 = this._addTasks.get(e7.index);
      return s7 ? s7.attributeInfo = t9 : (s7 = { ...D(), attributeInfo: t9, meta: null }, this._addTasks.set(e7.index, s7), i7().then(s7.resolve, s7.reject).then(() => this._addTasks.delete(e7.index)).catch((t10) => {
        throw this._addTasks.delete(e7.index), t10;
      })), s7.promise;
    }
    _clearAddTasks() {
      this._addTasks.forEach((e7) => {
        r(e7.meta) && (this._cacheGPUData(e7.meta), e7.meta = null);
      }), this._addTasks.clear();
    }
    _clippingAreaChanged() {
      const e7 = this.view.renderSpatialReference, t9 = this.i3slayer.spatialReference, i7 = u4();
      this._renderClippingArea = e6(this.view.clippingArea, i7, e7) ? i7 : null;
      const s7 = u4();
      this._layerClippingArea = e6(this.view.clippingArea, s7, t9) ? s7 : null, this._filterChange(), this._controller && this._controller.updateClippingArea(this.view.clippingArea), this._isIntegratedMesh && this._modificationsChanged();
    }
    _geometryFilterChange() {
      this._controller.geometryFilterChanged(this.hasGeometryFilter);
    }
    get hasGeometryFilter() {
      return false;
    }
    _filterChange() {
      this._applyFilters(false);
    }
    _applyFilters(e7) {
      this._filters = this.getFilters(), e7 ? this._controller && this._controller.requestUpdate() : this._nodeId2Meta.forEach((e8) => {
        r(e8) && this._applyFiltersToNode(e8) && (this._addOrUpdateEdgeRendering(e8), this._visibleGeometryChanged(e8, ft.UPDATE));
      });
    }
    getFilters() {
      const e7 = [], t9 = this._renderClippingArea;
      return r(t9) && e7.push((e8, i7) => this._boundingRectFilter(e8, i7, t9)), e7;
    }
    addSqlFilter(e7, t9, i7) {
      if (r(t9)) {
        const s7 = t9.fieldNames;
        e7.push((e8, r10) => this._sqlFilter(e8, r10, t9, s7, i7));
      }
    }
    _sqlFilter(e7, t9, i7, s7, r10) {
      const o11 = {}, a12 = this._createLayerGraphic(o11), n11 = this.i3slayer.objectIdField, l6 = t9.featureIds, d3 = r(t9.attributeInfo) && t9.attributeInfo.attributeData;
      s7.every((e8) => null != d3[e8] || e8 === n11) && ce(e7, l6, (e8) => {
        o11[n11] = l6[e8];
        for (const i8 of s7)
          i8 !== n11 && (o11[i8] = Me(d3[i8], e8));
        try {
          return i7.testFeature(a12);
        } catch (t10) {
          return r10(t10), false;
        }
      });
    }
    _boundingRectNodeTest(e7, t9) {
      return bn(e7.node.mbs, this._controller.crsIndex, Et, this.view.renderSpatialReference), me(t9, Et);
    }
    _boundingRectFeatureTest(e7, t9, i7) {
      return this._collection.getComponentAabb(e7.objectHandle, t9, bt), G(bt, yt), E(i7, yt);
    }
    _boundingRectFilter(e7, t9, i7) {
      const s7 = this._collection, r10 = this._boundingRectNodeTest(t9, i7);
      if (r10 === he.INSIDE)
        return;
      if (r10 === he.OUTSIDE)
        return void (e7.length = 0);
      const o11 = s7.getComponentCount(t9.objectHandle);
      if (o11.invisible + o11.visible !== t9.featureIds.length)
        return;
      const a12 = this._transformClippingArea(vt, i7, t9.objectHandle);
      ce(e7, t9.featureIds, (e8) => this._boundingRectFeatureTest(t9, e8, a12));
    }
    _transformClippingArea(e7, t9, i7) {
      const s7 = this._collection.getObjectTransform(i7), r10 = s7.position, o11 = s7.rotationScale;
      return e7[0] = (t9[0] - r10[0]) / o11[0], e7[1] = (t9[1] - r10[1]) / o11[4], e7[2] = (t9[2] - r10[0]) / o11[0], e7[3] = (t9[3] - r10[1]) / o11[4], e7;
    }
    _addOrUpdateEdgeRendering(e7, t9 = true) {
      const i7 = this._edgeView;
      if (t(i7))
        return Promise.resolve(null);
      const s7 = e7.objectHandle, r10 = i7.hasObject(s7), { hasEdges: o11, perFeatureEdgeMaterials: a12 } = this._getFilteredEdgeMaterials(e7), n11 = { hasSlicePlane: this.slicePlaneEnabled };
      if (o11 && r10) {
        if (this.nodeCrossfadingEnabled) {
          Rt(a12, this.getNodeOpacity(e7));
        }
        return i7.updateAllComponentMaterials(s7, a12, n11, t9).catch(this._logEdgeViewError), i7.updateObjectVisibility(s7, true).catch(this._logEdgeViewError), i7.updateAllVerticalOffsets(s7, e7.elevationOffsets).catch(this._logEdgeViewError), Promise.resolve(i7);
      }
      return o11 && !r10 ? this._collection.addEdges(s7, i7, a12, n11).then((t10) => (e7.edgeMemoryUsage = t10, e7.node.memory += t10, i7.updateAllVerticalOffsets(s7, e7.elevationOffsets).catch(this._logEdgeViewError), i7)) : (!o11 && r10 && (e7.node.memory -= e7.edgeMemoryUsage, e7.edgeMemoryUsage = 0, i7.removeObject(s7)), Promise.resolve(null));
    }
    _logEdgeViewError(e7) {
      g(e7) || ht.error("Error while processing edges. Edges on this layer might not diplay correctly", this.i3slayer, e7);
    }
    _applyFiltersToNode(e7) {
      return !!this._applyFiltersToNodeComponents(e7) && (r(this._labeler) && this._labeler.applyFilterChange(e7), true);
    }
    _applyFiltersToNodeComponents(e7) {
      const t9 = this._collection, i7 = 0 === t9.getComponentCount(e7.objectHandle).invisible;
      if (t9.setAllComponentVisibilities(e7.objectHandle, "all"), 0 === this._filters.length)
        return e7.filteredIds = null, !i7;
      if (this._updateCachedFilteredIds(e7), e7.filteredIds === e7.featureIds)
        return !i7;
      const s7 = this._computeFilteredComponentIndices(e7);
      return t9.setAllComponentVisibilities(e7.objectHandle, s7), true;
    }
    _updateCachedFilteredIds(e7) {
      null != e7.filteredIds && e7.appliedFilters === this._filters || (e7.filteredIds = this._computeFilteredIds(e7), e7.appliedFilters = this._filters);
    }
    _computeFilteredIds(e7) {
      const t9 = e7.featureIds.slice();
      for (const i7 of this._filters)
        if (i7(t9, e7), 0 === t9.length)
          break;
      return t9.length === e7.featureIds.length ? e7.featureIds : t9;
    }
    _computeFilteredComponentIndices(e7) {
      const t9 = new Array();
      return e7.featureIds.forEach((i7, s7) => {
        e7.filteredIds[t9.length] === i7 && t9.push(s7);
      }), t9;
    }
    _removeAllNodeDataFromStage(e7 = this.elevationOffset) {
      this._nodeId2Meta.forEach((t9, i7) => this._removeNodeStageData(i7, e7)), this._nodeId2MetaReloading.forEach((t9, i7) => this._removeNodeStageData(i7, e7, this._nodeId2MetaReloading)), this._elevationTask = l(this._elevationTask);
    }
    removeNode(e7) {
      const t9 = this.elevationOffset;
      this._removeNodeStageData(e7, t9), this._removeNodeStageData(e7, t9, this._nodeId2MetaReloading), r(this._elevationTask) && this._elevationTask.remove(e7);
    }
    _removeNodeStageData(e7, t9, i7 = this._nodeId2Meta) {
      i7.has(e7) && this._controller.updateLoadStatus(e7, false);
      const s7 = i7.get(e7);
      t(s7) ? i7.delete(e7) : (this._collection.setObjectVisibility(s7.objectHandle, t5.Hidden), r(this._edgeView) && this._edgeView.hasObject(s7.objectHandle) && this._edgeView.updateObjectVisibility(s7.objectHandle, false).catch(this._logEdgeViewError), this._visibleGeometryChanged(s7, ft.REMOVE), r(this._labeler) && this._labeler.removeNodeMeta(s7), i7.delete(e7), this._highlights.objectDeleted(s7), i7 === this._nodeId2Meta ? (this._cacheGPUData(s7, t9), this.nodeCrossfadingEnabled && this._crossfadeHelper.stopNodeFading(s7)) : this._deleteComponentObject(s7), r(this._treeDebugger) && this._treeDebugger.update());
    }
    _deleteComponentObject(e7) {
      if (r(this._edgeView) && this._edgeView.removeObject(e7.objectHandle), this._memEstimateGeometryRemoved(e7.objectHandle), this._collection.destroyObject(e7.objectHandle), e7.textures)
        for (const t9 of e7.textures)
          this._memEstimateTextureRemoved(t9), this._stage.remove(t9);
    }
    updateNodeState(e7, t9) {
      const i7 = this._nodeId2Meta.get(e7);
      r(i7) && this._collection.updateMaterial(i7.objectHandle, (e8) => e8.polygonOffsetEnabled = t9 === c3.Hole);
    }
    _invalidateAllSymbols() {
      this._rendererVersion = Le(this._rendererVersion, 1), this._controller && this._controller.requestUpdate();
    }
    _getInvalidRendererVersion() {
      return Le(this._rendererVersion, -1);
    }
    async _rendererChange(e7) {
      if (this._currentRenderer = e7, this.notifyChange("rendererTextureUsage"), this._rendererVersion = Le(this._rendererVersion, 1), this._rendererFields = null, this._colorVariable = null, this._opacityVariable = null, this._invalidateAllSymbols(), e7 && (this._rendererFields = await e7.getRequiredFields(this.i3slayer.fieldsIndex)), this._updateSymbologyFields(), !this._arcade && e7 && "arcadeRequired" in e7 && e7.arcadeRequired && (this._arcade = await a5()), e7 && "visualVariables" in e7 && e7.visualVariables)
        for (const t9 of e7.visualVariables)
          "color" === t9.type ? this._colorVariable = t9 : "opacity" === t9.type ? this._opacityVariable = t9 : ht.warn(`Unsupported visual variable type for 3D Object Scene Services: ${t9.type}`);
      if (e7)
        for (const t9 of e7.getSymbols())
          "mesh-3d" !== t9.type && ht.error(`Symbols of type '${t9.type}' are not supported for 3D Object Scene Services.`);
      this._controller && this._controller.requestUpdate();
    }
    _getCachedEdgeMaterials(e7) {
      return this._hasComponentData && e7.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(e7), e7.cachedEdgeMaterials;
    }
    _getComponentParameters(e7) {
      this._hasComponentData && e7.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(e7);
      const t9 = e7.cachedSymbology;
      return (i7, s7) => {
        var _a;
        const r10 = 5 * i7;
        r3(s7.externalColor, t9[r10 + 0] / 255, t9[r10 + 1] / 255, t9[r10 + 2] / 255, t9[r10 + 3] / 255), s7.externalColorMixMode = t9[r10 + 4] & (1 << _t.CastShadows) - 1, s7.castShadows = 0 != (t9[r10 + 4] & 1 << _t.CastShadows), s7.pickable = 0 != (t9[r10 + 4] & 1 << _t.Pickable), s7.elevationOffset = ((_a = e7.elevationOffsets) == null ? void 0 : _a[i7]) ?? 0;
      };
    }
    _getSymbolInfo(e7, t9) {
      const i7 = e7 && e7.getSymbol(t9, { arcade: this._arcade });
      if (!(i7 instanceof A4))
        return null;
      const s7 = i7.id;
      if (this._symbolInfos.has(s7))
        return this._symbolInfos.get(s7);
      const r10 = Ke(i7);
      return this._symbolInfos.set(s7, r10), r10;
    }
    _setSymbologyOverride(e7, t9) {
      this._symbologyOverride !== e7 && (this._symbologyOverride = e7, this._symbologyOverrideFields = t9, this._invalidateAllSymbols(), this._updateSymbologyFields());
    }
    _updateSymbologyFields() {
      this._symbologyFields = r(this._symbologyOverrideFields) && this._symbologyOverrideFields.length > 0 ? r(this._rendererFields) && this._rendererFields.length > 0 ? y2(this.i3slayer.fieldsIndex, [...this._rendererFields, ...this._symbologyOverrideFields]) : this._symbologyOverrideFields : this._rendererFields;
    }
    _updateCachedRendererData(e7) {
      if (e7.cachedRendererVersion = this._rendererVersion, !this._hasComponentData)
        return;
      const t9 = this._tmpAttributeOnlyGraphic, i7 = {};
      t9.attributes = i7;
      const s7 = this._currentRenderer, r10 = r(e7.attributeInfo) && e7.attributeInfo.attributeData, o11 = null != e7.featureIds ? this.i3slayer.objectIdField : null, a12 = null != r10 && r(this._symbologyFields) && this._symbologyFields.length > 0, n11 = a12 ? [] : null, l6 = a12 ? [] : null;
      if (a12 && r(this._symbologyFields))
        for (const c7 of this._symbologyFields) {
          const e8 = r10[c7];
          e8 && (n11.push(c7), l6.push(e8));
        }
      e7.cachedSymbology || (e7.cachedSymbology = new Uint8Array(5 * e7.featureIds.length));
      const d3 = { color: Mt, castShadows: true, pickable: true, colorMixMode: r7.Multiply, edgeMaterial: null }, h7 = this.fullOpacity, _2 = this.nodeCrossfadingEnabled ? this.getNodeOpacity(e7) : h7;
      let m2 = null, g5 = A5.OPAQUE, p2 = Oe, f4 = 0;
      for (let b7 = 0; b7 < e7.featureIds.length; b7++) {
        if (null != o11 && (i7[o11] = e7.featureIds[b7]), a12)
          for (let e8 = 0; e8 < n11.length; e8++)
            i7[n11[e8]] = Me(l6[e8], b7);
        const r11 = this._getSymbolInfo(s7, t9);
        let h8 = null, y3 = null;
        if (s7 && "visualVariables" in s7) {
          if (this._colorVariable) {
            const e8 = b(this._colorVariable, t9, { color: Ct, arcade: this._arcade });
            e8 && (h8 = Mt, h8[0] = e8.r / 255, h8[1] = e8.g / 255, h8[2] = e8.b / 255, this._opacityVariable || null === e8.a || (y3 = e8.a));
          }
          this._opacityVariable && (y3 = h4(this._opacityVariable, t9, { arcade: this._arcade }));
        }
        if (r11 && r11.material) {
          const e8 = r11.material;
          h8 = t(h8) || t(y3) ? B2(h8, y3, e8.color, e8.alpha, ct2, Mt) : B2(h8, y3, null, null, ct2, Mt);
        }
        if (t(h8) && (h8 = Mt, h8[0] = 1, h8[1] = 1, h8[2] = 1, h8[3] = 1), d3.pickable = true, d3.castShadows = !r11 || r11.castShadows, d3.colorMixMode = r11 && r11.material ? r11.material.colorMixMode : r7.Multiply, d3.edgeMaterial = r11 ? r11.edgeMaterial : null, r(this._symbologyOverride) && (d3.color = h8, this._symbologyOverride(t9, d3), h8 = d3.color), r(d3.edgeMaterial)) {
          const t10 = h8[3] <= 0 ? A5.INVISIBLE : h8[3] >= 1 && (e7.material.isOpaque || d3.colorMixMode === r7.Replace) ? A5.OPAQUE : A5.TRANSPARENT;
          d3.edgeMaterial === m2 && t10 === g5 || (p2 = { ...d3.edgeMaterial, opacity: _2, objectTransparency: t10 }, m2 = d3.edgeMaterial, g5 = t10), e7.cachedEdgeMaterials[b7] = p2;
        } else
          e7.cachedEdgeMaterials[b7] = Oe;
        e7.cachedSymbology[f4 + 0] = Math.round(255 * h8[0]), e7.cachedSymbology[f4 + 1] = Math.round(255 * h8[1]), e7.cachedSymbology[f4 + 2] = Math.round(255 * h8[2]), e7.cachedSymbology[f4 + 3] = Math.round(255 * h8[3]), e7.cachedSymbology[f4 + 4] = d3.colorMixMode | +d3.castShadows << _t.CastShadows | +d3.pickable << _t.Pickable, f4 += 5;
      }
    }
    _getFilteredEdgeMaterials(e7) {
      const t9 = this._getCachedEdgeMaterials(e7);
      if (this.nodeCrossfadingEnabled || Rt(t9, this.fullOpacity), t(e7.filteredIds)) {
        return { hasEdges: t9.some((e8) => e8 !== Oe), perFeatureEdgeMaterials: t9 };
      }
      let i7 = 0, s7 = false;
      const r10 = t9.map((t10, r11) => e7.featureIds[r11] !== e7.filteredIds[i7] ? Oe : (s7 = s7 || t10 !== Oe, i7++, t10));
      return { hasEdges: s7, perFeatureEdgeMaterials: r10 };
    }
    _updateComponentData(e7) {
      if (!this._hasComponentData)
        return;
      const t9 = e7.objectHandle, i7 = this._getComponentParameters(e7);
      this._collection.setComponentData(t9, i7), this._stage.renderView.requestRender();
    }
    _reloadAll(e7 = this.elevationOffset) {
      this._removeAllNodeDataFromStage(e7), null != this._controller && this._controller.restartNodeLoading();
    }
    _opacityChange(e7) {
      this.nodeCrossfadingEnabled && this._crossfadeHelper.stopAllNodeFading(), this._nodeId2Meta.forEach((t9) => {
        t(t9) || (this._collection.updateMaterial(t9.objectHandle, (t10) => t10.objectOpacity = e7), Rt(t9.cachedEdgeMaterials, e7), this._updateEdgeRendering(t9));
      });
    }
    _updateMaterial(e7) {
      this._collection.updateMaterial(e7.objectHandle, (e8) => {
        e8.commonMaterialParameters.hasSlicePlane = this.slicePlaneEnabled, e8.usePBR = this._usePBR(), this._updateMaterialOverlay(e8);
      });
    }
    _updateMaterialOverlay(e7) {
    }
    _updateEngineObject(e7) {
      this._updateComponentData(e7), this._applyFiltersToNode(e7), this._addOrUpdateEdgeRendering(e7), this._visibleGeometryChanged(e7, ft.UPDATE);
    }
    _slicePlaneEnabledChange(e7) {
      this._intersectionHandler && (this._intersectionHandler.slicePlaneEnabled = e7), r(this._labeler) && (this._labeler.slicePlaneEnabled = e7), this._nodeId2Meta.forEach((t9) => {
        t(t9) || (this._collection.updateMaterial(t9.objectHandle, (t10) => {
          t10.commonMaterialParameters.hasSlicePlane = e7;
        }), this._updateEdgeRendering(t9, false));
      });
    }
    _updatePBR() {
      this._nodeId2Meta.forEach((e7) => {
        t(e7) || this._collection.updateMaterial(e7.objectHandle, (e8) => {
          e8.usePBR = this._usePBR();
        });
      }), this._hasLoadedPBRTextures = true;
    }
    _usePBR() {
      return !this._isIntegratedMesh && this.view.qualitySettings.physicallyBasedRenderingEnabled;
    }
    _updateEdgeRendering(e7, t9 = true) {
      r(this._edgeView) && this._edgeView.hasObject(e7.objectHandle) && this._addOrUpdateEdgeRendering(e7, t9);
    }
    _forAllNodes(e7) {
      this._nodeId2Meta.forEach(e7);
    }
    _forAllFeatures(e7, t9, i7 = I2.VISIBLE_ONLY) {
      n2(this._nodeId2Meta, (s7) => {
        if (t(s7))
          return false;
        if (r(t9)) {
          switch (t9(s7)) {
            case L3.EXIT:
              return true;
            case L3.SKIP:
              return false;
          }
        }
        let r10 = L3.CONTINUE;
        switch (i7) {
          case I2.ALL:
            r10 = this._forAllFeaturesOfNode(s7, e7);
            break;
          case I2.VISIBLE_ONLY:
            r10 = this._forVisibleFeaturesOfNode(s7, e7);
            break;
          case I2.ALL_IN_CLIPPING_AREA:
            r10 = this._forAllFeaturesOfNodeInClippingArea(s7, e7);
        }
        return r10 === L3.EXIT;
      });
    }
    _forAllFeaturesOfNode(e7, t9) {
      let i7 = L3.CONTINUE;
      const s7 = e7.featureIds;
      for (let r10 = 0; r10 < s7.length; r10++)
        if (i7 = t9(s7[r10], r10, e7), i7 === L3.EXIT)
          return i7;
      return i7;
    }
    _forVisibleFeaturesOfNode(e7, t9) {
      let i7 = L3.CONTINUE;
      const s7 = e7.featureIds;
      return this._collection.forEachVisibleComponent(e7.objectHandle, (r10) => (i7 = t9(s7[r10], r10, e7), i7 === L3.CONTINUE)), i7;
    }
    _forAllFeaturesOfNodeInClippingArea(e7, t9) {
      if (t(this._renderClippingArea))
        return this._forAllFeaturesOfNode(e7, t9);
      const i7 = this._boundingRectNodeTest(e7, this._renderClippingArea);
      if (i7 === he.OUTSIDE)
        return L3.CONTINUE;
      if (i7 === he.INSIDE)
        return this._forAllFeaturesOfNode(e7, t9);
      const s7 = L3.CONTINUE, r10 = e7.featureIds, o11 = e7.objectHandle, a12 = ue(this._renderClippingArea, this._collection.getObjectTransform(o11));
      for (let n11 = 0; n11 < r10.length; n11++) {
        if (!this._boundingRectFeatureTest(e7, n11, a12))
          continue;
        const i8 = t9(r10[n11], n11, e7);
        if (i8 === L3.EXIT)
          return i8;
      }
      return s7;
    }
    _createAttributes(e7, t9) {
      const i7 = {};
      null != t9.featureIds && (i7[this._getObjectIdField()] = t9.featureIds[e7]);
      const s7 = r(t9.attributeInfo) && t9.attributeInfo.attributeData;
      if (r(s7))
        for (const r10 of Object.keys(s7))
          i7[r10] = Me(s7[r10], e7);
      return i7;
    }
    _createGraphic(e7, t9) {
      return this._createLayerGraphic(this._createAttributes(e7, t9));
    }
    highlight(e7) {
      const t9 = this._highlights;
      if ("number" == typeof e7 || e7 instanceof g3 ? e7 = [e7] : e7 instanceof j && (e7 = e7.toArray()), Array.isArray(e7) && e7.length > 0) {
        if (e7[0] instanceof g3) {
          const i7 = e7, s7 = this.i3slayer.fieldsIndex, r10 = this._getObjectIdField(), o11 = i7.map((e8) => n7(s7, e8.attributes, r10)), { set: a12, handle: n11 } = t9.acquireSet();
          return t9.setFeatureIds(a12, o11), n11;
        }
        if ("number" == typeof e7[0]) {
          const i7 = e7, { set: s7, handle: r10 } = t9.acquireSet();
          return t9.setFeatureIds(s7, i7), r10;
        }
      }
      return At;
    }
    _visibleGeometryChanged(e7, t9) {
      this._elevationProvider && (this._elevationProvider.objectChanged(e7.node), null == this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle = v2(() => {
        this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle = null;
      })), this._updateSnappingSources(e7, t9));
    }
    get performanceInfo() {
      const e7 = { displayedNumberOfFeatures: 0, maximumNumberOfFeatures: 0, totalNumberOfFeatures: 0, core: null, index: 0, nodes: this._nodeId2Meta.size, "Total GPU Memory Estimate": (this.gpuMemoryEstimate / 1048576).toFixed(1) + "MB", "Geometry Memory Estimate": (this.geoMemoryEstimate / 1048576).toFixed(1) + "MB", "Texture Memory Estimate": (this.texMemoryEstimate / 1048576).toFixed(1) + "MB", "Unloaded Memory Estimate": (this.getUnloadedMemory() / 1048576).toFixed(1) + "MB" };
      return r(this._memCache) && (e7.MemCache = Math.round(100 * this._memCache.hitRate) + "% hit"), this._controller && (this._idbCacheEnabled && (e7.IDBCache = Math.round(100 * this._idbCache.getHitRate()) + "% hit"), this._controller.updateStats(e7)), e7;
    }
    get test() {
      const e7 = this;
      return { controller: this._controller, labeler: this._labeler, get visibleObjectIds() {
        const t9 = [];
        return e7._forAllFeatures((e8) => (t9.push(e8), L3.CONTINUE), null, I2.VISIBLE_ONLY), t9.sort((e8, t10) => e8 - t10), t9;
      }, get numNodes() {
        return e7._nodeId2Meta.size;
      } };
    }
    getNodeOpacityByIndex(e7) {
      const t9 = this._nodeId2Meta.get(e7);
      return this.getNodeOpacity(t9);
    }
    getNodeOpacity(e7) {
      return r(e7) ? this._collection.getMaterial(e7.objectHandle).objectOpacity : 0;
    }
    isNodeFullyFadedIn(e7) {
      return this._crossfadeHelper.isNodeFullyFadedIn(e7);
    }
    getNodeCrossfadeMetaData(e7) {
      return this._nodeId2Meta.get(e7);
    }
    markNodeToRemove(e7) {
      this._controller && this._controller.markNodeToRemove(e7);
    }
    removeMarkedNodes() {
      this._controller && this._controller.removeMarkedNodes();
    }
    foreachCrossfadeNode(e7) {
      this._nodeId2Meta.forEach((t9, i7) => e7(i7, t9));
    }
    fadeNode(e7, t9, i7) {
      if (!this.nodeCrossfadingEnabled)
        return;
      const s7 = this._nodeId2Meta.get(e7);
      r(s7) && this._crossfadeHelper.fadeNode(e7, s7, t9, i7);
    }
    setNodeOpacityByIndex(e7, t9) {
      const i7 = this._nodeId2Meta.get(e7);
      r(i7) && this._setNodeOpacity(i7, t9);
    }
    _setNodeOpacity(e7, t9) {
      this._collection.updateMaterial(e7.objectHandle, (e8) => e8.objectOpacity = t9), this._setNodeEdgeOpacity(e7, t9);
    }
    _setNodeEdgeOpacity(e7, t9) {
      if (t(this._edgeView) || !e7.cachedEdgeMaterials)
        return;
      Rt(e7.cachedEdgeMaterials, t9);
      const i7 = e7.objectHandle;
      this._edgeView.hasObject(i7) && this._edgeView.updateAllComponentOpacities(i7, t9).catch(this._logEdgeViewError);
    }
    get hasModifications() {
      return this._isIntegratedMesh && r(this._layerClippingArea) || this._modifications && this._modifications.length > 0;
    }
    updateNodeModificationStatus(e7) {
      const t9 = e7.length;
      if (!this.hasModifications || t9 <= 0 || true !== this._i3sWasmLoaded)
        return;
      const i7 = this.i3slayer.uid, s7 = Dt(e7);
      if (r(s7)) {
        const t10 = { context: i7, buffer: s7.buffer };
        E3(t10);
        const r10 = new Float64Array(s7.buffer);
        e7.forAll((e8, t11) => {
          const i8 = r10[t11], s8 = d2(i8);
          e8.imModificationImpact = s8, s8 !== o8.Unmodified && this._controller.invalidateGeometryVisibility(e8.index);
        });
      }
    }
    notifyUpdate() {
      this.notifyChange("updating");
    }
    notifyLODUpdate() {
      this._controller.notifyLODUpdate();
    }
    isUpdating() {
      return !(!this._controller || !this._controller.updating) || !!this._visibleGeometryChangedSchedulerHandle || r(this._labeler) && this._labeler.updating || this._crossfadeHelper.updating || this._i3sWasmLoaded instanceof Promise || this._asyncModuleLoading > 0 || r(this._elevationTask) && this._elevationTask.running;
    }
    trackSnappingSources(e7) {
      const t9 = { events: e7, fetchEdgeLocations: async (e8, t10, i7) => {
        const s7 = this._nodeId2Meta.get(e8);
        if (t(s7))
          throw new Error("invalid-node");
        const { origin: r10, buffer: o11 } = await this._collection.extractEdgeInformation(s7.objectHandle, t10, i7);
        return { locations: o11, type: "components", objectIds: s7.featureIds, origin: r10 };
      }, remove: () => {
        A(this._snappingSourcesTrackers, t9);
      } };
      return this._snappingSourcesTrackers.push(t9), this._nodeId2Meta.forEach((t10, i7) => {
        t(t10) || e7.add(i7, t10.node.renderMbs);
      }), t9;
    }
    _updateSnappingSources(e7, t9) {
      const { index: i7, renderMbs: s7 } = e7.node;
      for (const r10 of this._snappingSourcesTrackers)
        t9 !== ft.REMOVE && t9 !== ft.UPDATE || r10.events.remove(i7), t9 !== ft.ADD && t9 !== ft.UPDATE || r10.events.add(i7, s7);
    }
  };
  return e([d()], r9.prototype, "_hasLoadedPBRTextures", void 0), e([d()], r9.prototype, "_asyncModuleLoading", void 0), e([d()], r9.prototype, "_visibleGeometryChangedSchedulerHandle", void 0), e([d()], r9.prototype, "view", void 0), e([d()], r9.prototype, "i3slayer", void 0), e([d()], r9.prototype, "_controller", void 0), e([d()], r9.prototype, "_labeler", void 0), e([d()], r9.prototype, "updating", void 0), e([d()], r9.prototype, "suspended", void 0), e([d()], r9.prototype, "holeFilling", void 0), e([d(t2)], r9.prototype, "updatingProgress", void 0), e([d({ readOnly: true, aliasOf: "_controller.updatingProgress" })], r9.prototype, "updatingProgressValue", void 0), e([d({ readOnly: true })], r9.prototype, "hasTexturesOrVertexColors", null), e([d({ readOnly: true })], r9.prototype, "rendererTextureUsage", null), e([d()], r9.prototype, "filter", void 0), e([d({ readOnly: true })], r9.prototype, "elevationOffset", null), e([d({ readOnly: true })], r9.prototype, "elevationInfo", null), e([d({ type: Boolean })], r9.prototype, "slicePlaneEnabled", void 0), e([d()], r9.prototype, "supportedTextureEncodings", null), e([d()], r9.prototype, "uncompressedTextureDownsamplingEnabled", null), e([d({ type: [f2] })], r9.prototype, "_modifications", void 0), e([d()], r9.prototype, "_elevationTask", void 0), r9 = e([n3("esri.views.3d.layers.I3SMeshView3D")], r9), r9;
};
var ft;
!function(e7) {
  e7[e7.ADD = 0] = "ADD", e7[e7.REMOVE = 1] = "REMOVE", e7[e7.UPDATE = 2] = "UPDATE";
}(ft || (ft = {}));
var bt = a3();
var yt = u4();
var vt = u4();
var It = E4();
var Mt = [0, 0, 0, 0];
var Ct = new l2([0, 0, 0, 0]);
var Et = [0, 0, 0, 0];
var xt = u4();
function Ot(e7) {
  if (t(e7))
    return false;
  const t8 = e7.metallicRoughness;
  return t8 && t8.baseColorTextureId >= 0 || t8 && t8.metallicRoughnessTextureId >= 0 || e7.normalTextureId >= 0 || e7.emissiveTextureId >= 0 || e7.occlusionTextureId >= 0;
}
function St(e7) {
  return "geometryData" in e7;
}
function wt(e7) {
  return r(e7) && o2(e7.data);
}
function jt(e7, t8) {
  let i7 = 1024 + e7.interleavedVertexData.byteLength + (e7.indices ? e7.indices.byteLength : 0) + e7.positionData.data.byteLength + e7.positionData.indices.byteLength;
  if (r(t8))
    for (const s7 of t8)
      r(s7) && o2(s7.data) && (i7 += s7.data.byteLength);
  return i7;
}
function Tt(e7, t8) {
  return t8.byteSize > gt ? (ht.warn(`Node is too big to store in IndexedDB cache: ${e7.id} (${t8.byteSize} bytes)`), false) : t8.byteSize > 0;
}
function Dt(e7) {
  if (0 === e7.length)
    return null;
  const t8 = 10 * e7.length, i7 = new Float64Array(t8);
  return e7.forAll((e8, t9) => {
    let s7 = e8.serviceObb;
    t(s7) && (s7 = It, r2(s7.center, e8.mbs), s7.halfSize[0] = s7.halfSize[1] = s7.halfSize[2] = e8.mbs[3]);
    const r9 = 10 * t9;
    i7[r9 + 0] = s7.center[0], i7[r9 + 1] = s7.center[1], i7[r9 + 2] = s7.center[2], i7[r9 + 3] = s7.halfSize[0], i7[r9 + 4] = s7.halfSize[1], i7[r9 + 5] = s7.halfSize[2], i7[r9 + 6] = s7.quaternion[0], i7[r9 + 7] = s7.quaternion[1], i7[r9 + 8] = s7.quaternion[2], i7[r9 + 9] = s7.quaternion[3];
  }), i7;
}
var At = { remove() {
}, pause() {
}, resume() {
} };
function Rt(e7, t8) {
  e7.forEach((e8) => e8.opacity = t8);
}
var Nt;
!function(e7) {
  e7[e7.Absolute = 0] = "Absolute", e7[e7.RelativeToGround = 1] = "RelativeToGround", e7[e7.OnTheGround = 2] = "OnTheGround";
}(Nt || (Nt = {}));
var Ft = n4();
var Pt = a3();

export {
  u5 as u,
  I2 as I,
  L3 as L,
  pt
};
//# sourceMappingURL=chunk-536JSWCC.js.map
