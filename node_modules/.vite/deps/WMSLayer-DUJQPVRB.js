import {
  l as l2
} from "./chunk-HO3HYBW5.js";
import {
  o as o2
} from "./chunk-YYT2VL2H.js";
import {
  r as r4
} from "./chunk-TUZ3FLXS.js";
import {
  a as a3
} from "./chunk-6O7ZZEV7.js";
import "./chunk-J6DXGG2A.js";
import {
  I
} from "./chunk-6GPADSSO.js";
import {
  p
} from "./chunk-TMSBC6BS.js";
import {
  n as n2
} from "./chunk-RIWDMEW4.js";
import {
  v
} from "./chunk-OG6CQEZJ.js";
import {
  c as c2
} from "./chunk-X5Z3DJQ4.js";
import {
  O,
  S as S2
} from "./chunk-BUWXVMJU.js";
import {
  c,
  f
} from "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import {
  a as a2
} from "./chunk-D3XXPCBB.js";
import {
  t as t2
} from "./chunk-OWBMOIIV.js";
import {
  b as b2
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import {
  a
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  l
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-RN2KRYDN.js";
import {
  g as g2
} from "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import {
  B
} from "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import {
  s as s4
} from "./chunk-H7JF6Q7A.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import {
  U as U2
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  Bt,
  j as j2,
  y
} from "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import {
  s
} from "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  E,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import {
  s as s3
} from "./chunk-XRL56EGK.js";
import {
  r as r3
} from "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import {
  g
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  w
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  S,
  b
} from "./chunk-23NWA6WL.js";
import {
  r as r2
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/support/WMSSublayer.js
var y2;
var d2 = 0;
var h = y2 = class extends s4(S2) {
  constructor(e2) {
    super(e2), this._sublayersHandles = new u(), this.dimensions = null, this.fullExtents = null, this.featureInfoFormat = null, this.featureInfoUrl = null, this.legendUrl = null, this.legendEnabled = true, this.maxScale = 0, this.minScale = 0, this.popupEnabled = false, this.queryable = false, this.spatialReferences = null;
  }
  get description() {
    return this._get("description");
  }
  set description(e2) {
    this._set("description", e2);
  }
  get fullExtent() {
    return this._get("fullExtent");
  }
  set fullExtent(e2) {
    this._set("fullExtent", e2);
  }
  readExtent(e2, t3) {
    return (e2 = t3.extent) ? M.fromJSON(e2) : null;
  }
  get id() {
    const e2 = this._get("id");
    return null == e2 ? d2++ : e2;
  }
  set id(e2) {
    this._set("id", e2);
  }
  readLegendUrl(e2, t3) {
    return t3 ? t3.legendUrl || t3.legendURL : null;
  }
  set layer(e2) {
    this._set("layer", e2), this.sublayers && this.sublayers.forEach((t3) => t3.layer = e2);
  }
  get effectiveScaleRange() {
    const { minScale: e2, maxScale: t3 } = this;
    return { minScale: e2, maxScale: t3 };
  }
  get name() {
    return this._get("name");
  }
  set name(e2) {
    this._set("name", e2);
  }
  set sublayers(e2) {
    const t3 = this._get("sublayers");
    t3 && (t3.forEach((e3) => {
      e3.layer = null;
    }), this._sublayersHandles.removeAll(), this._sublayersHandles = null), e2 && (e2.forEach((e3) => {
      e3.parent = this, e3.layer = this.layer;
    }), this._sublayersHandles.add([e2.on("after-add", ({ item: e3 }) => {
      e3.parent = this, e3.layer = this.layer;
    }), e2.on("after-remove", ({ item: e3 }) => {
      e3.parent = null, e3.layer = null;
    })])), this._set("sublayers", e2);
  }
  castSublayers(e2) {
    return b(j.ofType(y2), e2);
  }
  get title() {
    return this._get("title");
  }
  set title(e2) {
    this._set("title", e2);
  }
  get visible() {
    return this._get("visible");
  }
  set visible(e2) {
    this._setAndNotifyLayer("visible", e2);
  }
  clone() {
    const e2 = new y2();
    return this.hasOwnProperty("description") && (e2.description = this.description), this.hasOwnProperty("fullExtent") && (e2.fullExtent = this.fullExtent.clone()), this.hasOwnProperty("fullExtents") && (e2.fullExtents = this.fullExtents.map((e3) => e3.clone())), this.hasOwnProperty("featureInfoFormat") && (e2.featureInfoFormat = this.featureInfoFormat), this.hasOwnProperty("featureInfoUrl") && (e2.featureInfoUrl = this.featureInfoUrl), this.hasOwnProperty("legendUrl") && (e2.legendUrl = this.legendUrl), this.hasOwnProperty("legendEnabled") && (e2.legendEnabled = this.legendEnabled), this.hasOwnProperty("layer") && (e2.layer = this.layer), this.hasOwnProperty("name") && (e2.name = this.name), this.hasOwnProperty("parent") && (e2.parent = this.parent), this.hasOwnProperty("queryable") && (e2.queryable = this.queryable), this.hasOwnProperty("sublayers") && (e2.sublayers = this.sublayers && this.sublayers.map((e3) => e3.clone())), this.hasOwnProperty("spatialReferences") && (e2.spatialReferences = this.spatialReferences.map((e3) => e3)), this.hasOwnProperty("visible") && (e2.visible = this.visible), this.hasOwnProperty("title") && (e2.title = this.title), e2;
  }
  _setAndNotifyLayer(e2, t3) {
    const r5 = this.layer;
    this._get(e2) !== t3 && (this._set(e2, t3), r5 && r5.emit("wms-sublayer-update", { propertyName: e2, id: this.id }));
  }
};
e([d()], h.prototype, "description", null), e([d({ readOnly: true })], h.prototype, "dimensions", void 0), e([d({ value: null })], h.prototype, "fullExtent", null), e([o("fullExtent", ["extent"])], h.prototype, "readExtent", null), e([d()], h.prototype, "fullExtents", void 0), e([d()], h.prototype, "featureInfoFormat", void 0), e([d()], h.prototype, "featureInfoUrl", void 0), e([d({ type: Number, json: { write: { enabled: false, overridePolicy: () => ({ ignoreOrigin: true, enabled: true }) } } })], h.prototype, "id", null), e([d({ type: String, json: { origins: { "web-document": { read: { source: ["legendUrl", "legendURL"] }, write: { target: "legendUrl", ignoreOrigin: true } } }, read: { source: "legendURL" }, write: { ignoreOrigin: true } } })], h.prototype, "legendUrl", void 0), e([o(["web-document"], "legendUrl")], h.prototype, "readLegendUrl", null), e([d({ value: true, type: Boolean, json: { read: { source: "showLegend" }, write: { target: "showLegend" }, origins: { "web-map": { read: false, write: false }, "web-scene": { read: false, write: false } } } })], h.prototype, "legendEnabled", void 0), e([d({ value: null })], h.prototype, "layer", null), e([d()], h.prototype, "maxScale", void 0), e([d()], h.prototype, "minScale", void 0), e([d({ readOnly: true })], h.prototype, "effectiveScaleRange", null), e([d({ type: String, value: null, json: { read: { source: "name" }, write: { ignoreOrigin: true } } })], h.prototype, "name", null), e([d()], h.prototype, "parent", void 0), e([d({ type: Boolean, json: { read: { source: "showPopup" }, write: { ignoreOrigin: true, target: "showPopup" } } })], h.prototype, "popupEnabled", void 0), e([d({ type: Boolean, json: { write: { ignoreOrigin: true } } })], h.prototype, "queryable", void 0), e([d()], h.prototype, "sublayers", null), e([s3("sublayers")], h.prototype, "castSublayers", null), e([d({ type: [Number], json: { read: { source: "spatialReferences" } } })], h.prototype, "spatialReferences", void 0), e([d({ type: String, value: null, json: { write: { ignoreOrigin: true } } })], h.prototype, "title", null), e([d({ type: Boolean, value: true, json: { read: { source: "defaultVisibility" } } })], h.prototype, "visible", null), h = y2 = e([n("esri.layers.support.WMSSublayer")], h);
var c3 = h;

// node_modules/@arcgis/core/layers/support/wmsUtils.js
var a4 = { 84: 4326, 83: 4269, 27: 4267 };
function o3(t3) {
  if (!t3)
    return null;
  const n3 = { idCounter: -1 };
  if ("string" == typeof t3) {
    t3 = new DOMParser().parseFromString(t3, "text/xml");
  }
  const i = t3.documentElement;
  if ("ServiceExceptionReport" === i.nodeName) {
    const t4 = Array.prototype.slice.call(i.childNodes).map((e2) => e2.textContent).join("\r\n");
    throw new s2("wmslayer:wms-capabilities-xml-is-not-valid", "The server returned errors when the WMS capabilities were requested.", t4);
  }
  const s5 = d3("Capability", i), a5 = d3("Service", i), o4 = d3("Request", s5);
  if (!s5 || !a5 || !o4)
    return null;
  const l4 = d3("Layer", s5);
  if (!l4)
    return null;
  const m3 = "WMS_Capabilities" === i.nodeName || "WMT_MS_Capabilities" === i.nodeName ? i.getAttribute("version") : "1.3.0", f3 = h2("Title", a5, "") || h2("Name", a5, ""), p3 = h2("AccessConstraints", a5, ""), x2 = /^none$/i.test(p3) ? "" : p3, b4 = h2("Abstract", a5, ""), E3 = parseInt(h2("MaxWidth", a5, "5000"), 10), S3 = parseInt(h2("MaxHeight", a5, "5000"), 10), w3 = g3(o4, "GetMap"), I2 = N(o4, "GetMap"), F2 = y3(l4, m3, n3);
  let M3, C2 = 0;
  if (Array.prototype.slice.call(s5.childNodes).forEach((e2) => {
    "Layer" === e2.nodeName && (0 === C2 ? M3 = e2 : 1 === C2 ? (F2.name && (F2.name = "", F2.sublayers.push(y3(M3, m3, n3))), F2.sublayers.push(y3(e2, m3, n3))) : F2.sublayers.push(y3(e2, m3, n3)), C2++);
  }), !F2)
    return null;
  let T2, R2;
  const V3 = F2.fullExtents;
  if (T2 = F2.sublayers, T2 || (T2 = []), 0 === T2.length && T2.push(F2), R2 = F2.extent, !R2) {
    const e2 = new M(T2[0].extent);
    F2.extent = e2.toJSON(), R2 = F2.extent;
  }
  const U4 = F2.spatialReferences.length > 0 ? F2.spatialReferences : u2(F2), _2 = N(o4, "GetFeatureInfo");
  let v3;
  if (_2) {
    const e2 = g3(o4, "GetFeatureInfo");
    e2.includes("text/html") ? v3 = "text/html" : e2.includes("text/plain") && (v3 = "text/plain");
  }
  if (!v3) {
    const e2 = (t4) => {
      t4 && (t4.queryable = false, t4.sublayers && t4.sublayers.forEach((t5) => {
        e2(t5);
      }));
    };
    e2(F2);
  }
  const O3 = c4(T2), q = F2.minScale || 0, B2 = F2.maxScale || 0, D2 = F2.dimensions, j3 = O3.reduce((e2, t4) => e2.concat(t4.dimensions), []), k2 = D2.concat(j3).filter(L);
  let X = null;
  if (k2.length > 0) {
    let e2 = Number.POSITIVE_INFINITY, t4 = Number.NEGATIVE_INFINITY;
    k2.forEach((n4) => {
      const { extent: r5 } = n4;
      A(r5) ? r5.forEach((n5) => {
        e2 = Math.min(e2, n5.getTime()), t4 = Math.max(t4, n5.getTime());
      }) : r5.forEach((n5) => {
        e2 = Math.min(e2, n5.min.getTime()), t4 = Math.max(t4, n5.max.getTime());
      });
    }), X = { startTimeField: null, endTimeField: null, trackIdField: null, timeExtent: [e2, t4] };
  }
  return { copyright: x2, description: b4, dimensions: D2, extent: R2, fullExtents: V3, featureInfoFormat: v3, featureInfoUrl: _2, mapUrl: I2, maxWidth: E3, maxHeight: S3, maxScale: B2, minScale: q, layers: O3, spatialReferences: U4, supportedImageFormatTypes: w3, timeInfo: X, title: f3, version: m3 };
}
function l3(e2) {
  return e2.length ? e2.filter((e3) => e3.popupEnabled && e3.name && e3.queryable).map((e3) => e3.name).join(",") : "";
}
function u2(e2) {
  if (e2.spatialReferences.length > 0)
    return e2.spatialReferences;
  if (e2.sublayers)
    for (const t3 of e2.sublayers) {
      const e3 = u2(t3);
      if (e3.length > 0)
        return e3;
    }
  return [];
}
function c4(e2) {
  let t3 = [];
  return e2.forEach((e3) => {
    t3.push(e3), e3.sublayers && e3.sublayers.length && (t3 = t3.concat(c4(e3.sublayers)), delete e3.sublayers);
  }), t3;
}
function m2(e2, t3, n3) {
  return t3.getAttribute(e2) ?? n3;
}
function f2(e2, t3, n3, r5) {
  const i = d3(e2, n3);
  return i ? m2(t3, i, r5) : r5;
}
function d3(e2, t3) {
  for (let n3 = 0; n3 < t3.childNodes.length; n3++) {
    const r5 = t3.childNodes[n3];
    if (E2(r5) && r5.nodeName === e2)
      return r5;
  }
  return null;
}
function p2(e2, t3) {
  const n3 = [];
  for (let r5 = 0; r5 < t3.childNodes.length; r5++) {
    const i = t3.childNodes[r5];
    E2(i) && i.nodeName === e2 && n3.push(i);
  }
  return n3;
}
function h2(e2, t3, n3) {
  const r5 = d3(e2, t3);
  return r5 ? r5.textContent : n3;
}
function x(e2, t3, n3) {
  if (!e2)
    return null;
  const s5 = parseFloat(e2.getAttribute("minx")), a5 = parseFloat(e2.getAttribute("miny")), o4 = parseFloat(e2.getAttribute("maxx")), l4 = parseFloat(e2.getAttribute("maxy"));
  let u3, c5, m3, f3;
  n3 ? (u3 = isNaN(a5) ? -Number.MAX_VALUE : a5, c5 = isNaN(s5) ? -Number.MAX_VALUE : s5, m3 = isNaN(l4) ? Number.MAX_VALUE : l4, f3 = isNaN(o4) ? Number.MAX_VALUE : o4) : (u3 = isNaN(s5) ? -Number.MAX_VALUE : s5, c5 = isNaN(a5) ? -Number.MAX_VALUE : a5, m3 = isNaN(o4) ? Number.MAX_VALUE : o4, f3 = isNaN(l4) ? Number.MAX_VALUE : l4);
  const d4 = new k({ wkid: t3 });
  return new M({ xmin: u3, ymin: c5, xmax: m3, ymax: f3, spatialReference: d4 });
}
function N(e2, t3) {
  const n3 = d3(t3, e2);
  if (n3) {
    const e3 = d3("DCPType", n3);
    if (e3) {
      const t4 = d3("HTTP", e3);
      if (t4) {
        const e4 = d3("Get", t4);
        if (e4) {
          let t5 = f2("OnlineResource", "xlink:href", e4, null);
          if (t5)
            return t5.indexOf("&") === t5.length - 1 && (t5 = t5.substring(0, t5.length - 1)), F(t5, ["service", "request"]);
        }
      }
    }
  }
  return null;
}
function g3(e2, t3) {
  const n3 = p2("Operation", e2);
  if (0 === n3.length) {
    return p2("Format", d3(t3, e2)).map((e3) => e3.textContent);
  }
  const r5 = [];
  return n3.forEach((e3) => {
    if (e3.getAttribute("name") === t3) {
      p2("Format", e3).forEach((e4) => {
        r5.push(e4.textContent);
      });
    }
  }), r5;
}
function b3(e2, t3, n3) {
  const r5 = d3(t3, e2);
  if (!r5)
    return n3;
  const { textContent: i } = r5;
  if (null == i || "" === i)
    return n3;
  const s5 = Number(i);
  return isNaN(s5) ? n3 : s5;
}
function y3(e2, t3, n3) {
  if (!e2)
    return null;
  const o4 = { id: n3.idCounter++, fullExtents: [], parentLayerId: null, queryable: "1" === e2.getAttribute("queryable"), spatialReferences: [], sublayers: null }, l4 = d3("LatLonBoundingBox", e2), u3 = d3("EX_GeographicBoundingBox", e2);
  let c5 = null;
  l4 && (c5 = x(l4, 4326)), u3 && (c5 = new M(0, 0, 0, 0, new k({ wkid: 4326 })), c5.xmin = parseFloat(h2("westBoundLongitude", u3, "0")), c5.ymin = parseFloat(h2("southBoundLatitude", u3, "0")), c5.xmax = parseFloat(h2("eastBoundLongitude", u3, "0")), c5.ymax = parseFloat(h2("northBoundLatitude", u3, "0"))), l4 || u3 || (c5 = new M(-180, -90, 180, 90, new k({ wkid: 4326 }))), o4.minScale = b3(e2, "MaxScaleDenominator", 0), o4.maxScale = b3(e2, "MinScaleDenominator", 0);
  const f3 = ["1.0.0", "1.1.0", "1.1.1"].includes(t3) ? "SRS" : "CRS";
  return Array.prototype.slice.call(e2.childNodes).forEach((e3) => {
    if ("Name" === e3.nodeName)
      o4.name = e3.textContent || "";
    else if ("Title" === e3.nodeName)
      o4.title = e3.textContent || "";
    else if ("Abstract" === e3.nodeName)
      o4.description = e3.textContent || "";
    else if ("BoundingBox" === e3.nodeName) {
      const n4 = e3.getAttribute(f3);
      if (n4 && 0 === n4.indexOf("EPSG:")) {
        const r6 = parseInt(n4.substring(5), 10);
        0 === r6 || isNaN(r6) || c5 || (c5 = "1.3.0" === t3 ? x(e3, r6, o2(r6)) : x(e3, r6));
      }
      const r5 = n4 && n4.indexOf(":");
      if (r5 && r5 > -1) {
        let i = parseInt(n4.substring(r5 + 1, n4.length), 10);
        0 === i || isNaN(i) || (i = a4[i] ? a4[i] : i);
        const l5 = "1.3.0" === t3 ? x(e3, i, o2(i)) : x(e3, i);
        o4.fullExtents.push(l5);
      }
    } else if (e3.nodeName === f3) {
      e3.textContent.split(" ").forEach((e4) => {
        const t4 = e4.includes(":") ? parseInt(e4.split(":")[1], 10) : parseInt(e4, 10);
        if (0 !== t4 && !isNaN(t4)) {
          const e5 = a4[t4] ? a4[t4] : t4;
          o4.spatialReferences.includes(e5) || o4.spatialReferences.push(e5);
        }
      });
    } else if ("Style" !== e3.nodeName || o4.legendURL) {
      if ("Layer" === e3.nodeName) {
        const r5 = y3(e3, t3, n3);
        r5 && (r5.parentLayerId = o4.id, o4.sublayers || (o4.sublayers = []), o4.sublayers.push(r5));
      }
    } else {
      const t4 = d3("LegendURL", e3);
      if (t4) {
        const e4 = d3("OnlineResource", t4);
        e4 && (o4.legendURL = e4.getAttribute("xlink:href"));
      }
    }
  }), o4.extent = c5 == null ? void 0 : c5.toJSON(), o4.dimensions = p2("Dimension", e2).filter((e3) => e3.getAttribute("name") && e3.getAttribute("units") && e3.textContent).map((e3) => {
    const t4 = e3.getAttribute("name"), n4 = e3.getAttribute("units"), r5 = e3.textContent, i = e3.getAttribute("unitSymbol"), s5 = e3.getAttribute("default"), a5 = "0" !== m2("default", e3, "0"), o5 = "0" !== m2("nearestValue", e3, "0"), l5 = "0" !== m2("current", e3, "0");
    if (L({ name: t4, units: n4 })) {
      return { name: "time", units: "ISO8601", extent: T(r5), default: T(s5), multipleValues: a5, nearestValue: o5, current: l5 };
    }
    if (w2({ name: t4, units: n4 })) {
      return { name: "elevation", units: n4, extent: M2(r5), unitSymbol: i, default: M2(s5), multipleValues: a5, nearestValue: o5 };
    }
    return { name: t4, units: n4, extent: C(r5), unitSymbol: i, default: C(s5), multipleValues: a5, nearestValue: o5 };
  }), o4;
}
function A(e2) {
  return Array.isArray(e2) && e2.length > 0 && e2[0] instanceof Date;
}
function E2(e2) {
  return e2.nodeType === Node.ELEMENT_NODE;
}
function w2(e2) {
  return /^elevation$/i.test(e2.name) && /^(epsg|crs):\d+$/i.test(e2.units);
}
function L(e2) {
  return /^time$/i.test(e2.name) && /^iso8601$/i.test(e2.units);
}
function F(e2, t3) {
  const r5 = [], i = j2(e2);
  for (const n3 in i.query)
    i.query.hasOwnProperty(n3) && (t3.includes(n3.toLowerCase()) || r5.push(n3 + "=" + i.query[n3]));
  return i.path + (r5.length ? "?" + r5.join("&") : "");
}
function M2(e2) {
  if (!e2)
    return null;
  const t3 = e2.includes("/"), n3 = e2.split(",");
  return t3 ? n3.map((e3) => {
    const t4 = e3.split("/");
    if (t4.length < 2)
      return null;
    return { min: parseFloat(t4[0]), max: parseFloat(t4[1]), resolution: t4.length >= 3 && "0" !== t4[2] ? parseFloat(t4[2]) : void 0 };
  }).filter((e3) => e3) : n3.map((e3) => parseFloat(e3));
}
function C(e2) {
  if (!e2)
    return null;
  const t3 = e2.includes("/"), n3 = e2.split(",");
  return t3 ? n3.map((e3) => {
    const t4 = e3.split("/");
    if (t4.length < 2)
      return null;
    return { min: t4[0], max: t4[1], resolution: t4.length >= 3 && "0" !== t4[2] ? t4[2] : void 0 };
  }).filter((e3) => e3) : n3;
}
function T(e2) {
  if (!e2)
    return null;
  const t3 = e2.includes("/"), n3 = e2.split(",");
  return t3 ? n3.map((e3) => {
    const t4 = e3.split("/");
    if (t4.length < 2)
      return null;
    return { min: new Date(t4[0]), max: new Date(t4[1]), resolution: t4.length >= 3 && "0" !== t4[2] ? R(t4[2]) : void 0 };
  }).filter((e3) => e3) : n3.map((e3) => new Date(e3));
}
function R(e2) {
  const t3 = /(?:p(\d+y|\d+(?:.|,)\d+y)?(\d+m|\d+(?:.|,)\d+m)?(\d+d|\d+(?:.|,)\d+d)?)?(?:t(\d+h|\d+(?:.|,)\d+h)?(\d+m|\d+(?:.|,)\d+m)?(\d+s|\d+(?:.|,)\d+s)?)?/i, n3 = e2.match(t3);
  if (!n3)
    return null;
  return { years: V(n3[1]), months: V(n3[2]), days: V(n3[3]), hours: V(n3[4]), minutes: V(n3[5]), seconds: V(n3[6]) };
}
function V(e2) {
  if (!e2)
    return 0;
  const t3 = /(?:\d+(?:.|,)\d+|\d+)/, n3 = e2.match(t3);
  if (!n3)
    return 0;
  const r5 = n3[0].replace(",", ".");
  return Number(r5);
}
function U3(e2) {
  return e2.toISOString().replace(/\.[0-9]{3}/, "");
}
var _ = /* @__PURE__ */ new Set([102100, 3857, 102113, 900913]);
var v2 = /* @__PURE__ */ new Set([3395, 54004]);
function O2(e2, n3) {
  let r5 = e2.wkid;
  return t(n3) ? r5 : (!n3.includes(r5) && e2.latestWkid && (r5 = e2.latestWkid), _.has(r5) ? n3.find((e3) => _.has(e3)) || n3.find((e3) => v2.has(e3)) || 102100 : r5);
}

// node_modules/@arcgis/core/layers/WMSLayer.js
var D = new s({ bmp: "image/bmp", gif: "image/gif", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml" }, { ignoreUnknown: false });
var G = class extends a(a2(a3(n2(t2(c2(v(O(b2)))))))) {
  constructor(...e2) {
    super(...e2), this.allSublayers = new p({ getCollections: () => [this.sublayers], getChildrenFunction: (e3) => e3.sublayers }), this.customParameters = null, this.customLayerParameters = null, this.copyright = null, this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.featureInfoFormat = null, this.featureInfoUrl = null, this.imageFormat = null, this.imageMaxHeight = 2048, this.imageMaxWidth = 2048, this.imageTransparency = true, this.legendEnabled = true, this.mapUrl = null, this.isReference = null, this.operationalLayerType = "WMS", this.spatialReference = null, this.spatialReferences = null, this.sublayers = null, this.type = "wms", this.url = null, this.version = null;
    const r5 = "wms-sublayer";
    this.own(l(() => this.sublayers, (e3, t3) => {
      if (t3) {
        for (const e4 of t3)
          e4.layer = null;
        this.handles.remove(r5);
      }
      if (e3) {
        for (const r6 of e3)
          r6.parent = this, r6.layer = this;
        this.handles.add([e3.on("after-add", ({ item: e4 }) => {
          e4.parent = this, e4.layer = this;
        }), e3.on("after-remove", ({ item: e4 }) => {
          e4.parent = null, e4.layer = null;
        })], r5);
      }
    }, U));
  }
  normalizeCtorArgs(e2, r5) {
    return "string" == typeof e2 ? { url: e2, ...r5 } : e2;
  }
  load(e2) {
    const r5 = r(e2) ? e2.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WMS"] }, e2).catch(w).then(() => this._fetchService(r5))), Promise.resolve(this);
  }
  readFullExtentFromItemOrMap(e2, r5) {
    const t3 = r5.extent;
    return new M({ xmin: t3[0][0], ymin: t3[0][1], xmax: t3[1][0], ymax: t3[1][1] });
  }
  writeFullExtent(e2, r5) {
    r5.extent = [[e2.xmin, e2.ymin], [e2.xmax, e2.ymax]];
  }
  readImageFormat(e2, r5) {
    const t3 = r5.supportedImageFormatTypes;
    return t3 && t3.includes("image/png") ? "image/png" : t3 && t3[0];
  }
  readSpatialReferenceFromItemOrDocument(e2, r5) {
    return new k(r5.spatialReferences[0]);
  }
  writeSpatialReferences(e2, r5) {
    const t3 = this.spatialReference && this.spatialReference.wkid;
    e2 && t3 ? (r5.spatialReferences = e2.filter((e3) => e3 !== t3), r5.spatialReferences.unshift(t3)) : r5.spatialReferences = e2;
  }
  readSublayersFromItemOrMap(e2, r5, t3) {
    return V2(r5.layers, t3, r5.visibleLayers);
  }
  readSublayers(e2, r5, t3) {
    return V2(r5.layers, t3);
  }
  writeSublayers(e2, r5, t3, s5) {
    r5.layers = [];
    const o4 = /* @__PURE__ */ new Map(), i = e2.flatten(({ sublayers: e3 }) => e3 && e3.toArray()).toArray();
    i.forEach((e3) => {
      "number" == typeof e3.parent.id && (o4.has(e3.parent.id) ? o4.get(e3.parent.id).push(e3.id) : o4.set(e3.parent.id, [e3.id]));
    }), i.forEach((e3) => {
      const t4 = { sublayer: e3, ...s5 }, i2 = e3.write({ parentLayerId: "number" == typeof e3.parent.id ? e3.parent.id : -1 }, t4);
      if (o4.has(e3.id) && (i2.sublayerIds = o4.get(e3.id)), !e3.sublayers && e3.name) {
        const s6 = e3.write({}, t4);
        delete s6.id, r5.layers.push(s6);
      }
    }), r5.visibleLayers = i.filter((e3) => e3.visible && !e3.sublayers).map((e3) => e3.name);
  }
  createExportImageParameters(e2, r5, t3, s5) {
    const o4 = s5 && s5.pixelRatio || 1, i = r4({ extent: e2, width: r5 }) * o4, a5 = new l2({ layer: this, scale: i }), { xmin: n3, ymin: p3, xmax: l4, ymax: m3, spatialReference: u3 } = e2, c5 = O2(u3, this.spatialReferences), y4 = "1.3.0" === this.version && o2(c5) ? `${p3},${n3},${m3},${l4}` : `${n3},${p3},${l4},${m3}`, d4 = a5.toJSON();
    return { bbox: y4, ["1.3.0" === this.version ? "crs" : "srs"]: isNaN(c5) ? void 0 : "EPSG:" + c5, ...d4 };
  }
  async fetchImage(e2, r5, t3, s5) {
    var _a, _b;
    const i = this.mapUrl, a5 = this.createExportImageParameters(e2, r5, t3, s5);
    if (!a5.layers) {
      const e3 = document.createElement("canvas");
      return e3.width = r5, e3.height = t3, e3;
    }
    const n3 = (_a = s5 == null ? void 0 : s5.timeExtent) == null ? void 0 : _a.start, p3 = (_b = s5 == null ? void 0 : s5.timeExtent) == null ? void 0 : _b.end, l4 = r(n3) && r(p3) ? n3.getTime() === p3.getTime() ? U3(n3) : `${U3(n3)}/${U3(p3)}` : void 0, u3 = { responseType: "image", query: this._mixCustomParameters({ width: r5, height: t3, ...a5, time: l4, ...this.refreshParameters }), signal: s5 == null ? void 0 : s5.signal };
    return U2(i, u3).then((e3) => e3.data);
  }
  fetchFeatureInfo(e2, r5, o4, i, a5) {
    const n3 = r4({ extent: e2, width: r5 }), p3 = new l2({ layer: this, scale: n3 }), l4 = l3(p3.visibleSublayers);
    if (!this.featureInfoUrl || !l4)
      return null;
    const m3 = "1.3.0" === this.version ? { I: i, J: a5 } : { x: i, y: a5 }, u3 = { query_layers: l4, request: "GetFeatureInfo", info_format: this.featureInfoFormat, feature_count: 25, width: r5, height: o4, ...m3 }, c5 = { ...this.createExportImageParameters(e2, r5, o4), ...u3 }, y4 = this._mixCustomParameters(c5), d4 = Bt(this.featureInfoUrl, y4), h3 = document.createElement("iframe");
    h3.src = d4, h3.style.border = "none", h3.style.margin = "0", h3.style.width = "100%", h3.setAttribute("sandbox", "");
    const g4 = new B({ title: this.title, content: h3 });
    return new g2({ sourceLayer: this, popupTemplate: g4 });
  }
  findSublayerById(e2) {
    return this.allSublayers.find((r5) => r5.id === e2);
  }
  findSublayerByName(e2) {
    return this.allSublayers.find((r5) => r5.name === e2);
  }
  serviceSupportsSpatialReference(e2) {
    return I(this.url) || this.spatialReferences.some((r5) => {
      const t3 = 900913 === r5 ? k.WebMercator : new k({ wkid: r5 });
      return E(t3, e2);
    });
  }
  async _fetchService(e2) {
    if (!this.resourceInfo) {
      this.parsedUrl.query && this.parsedUrl.query.service && (this.parsedUrl.query.SERVICE = this.parsedUrl.query.service, delete this.parsedUrl.query.service), this.parsedUrl.query && this.parsedUrl.query.request && (this.parsedUrl.query.REQUEST = this.parsedUrl.query.request, delete this.parsedUrl.query.request);
      const r5 = await U2(this.parsedUrl.path, { query: { SERVICE: "WMS", REQUEST: "GetCapabilities", ...this.parsedUrl.query, ...this.customParameters }, responseType: "xml", signal: e2 });
      this.resourceInfo = o3(r5.data);
    }
    if (this.parsedUrl) {
      const e3 = new y(this.parsedUrl.path);
      "https" !== e3.scheme || e3.port && "443" !== e3.port || r2.request.httpsDomains.includes(e3.host) || r2.request.httpsDomains.push(e3.host);
    }
    this.read(this.resourceInfo, { origin: "service" });
  }
  _mixCustomParameters(e2) {
    if (!this.customLayerParameters && !this.customParameters)
      return e2;
    const r5 = { ...this.customParameters, ...this.customLayerParameters };
    for (const t3 in r5)
      e2[t3.toLowerCase()] = r5[t3];
    return e2;
  }
};
function J(e2, r5) {
  return e2.some((e3) => {
    for (const t3 in e3)
      if (g(e3, t3, null, r5))
        return true;
    return false;
  });
}
function V2(e2, r5, t3) {
  const s5 = /* @__PURE__ */ new Map();
  e2.every((e3) => null == e3.id) && (e2 = m(e2)).forEach((e3, r6) => e3.id = r6);
  for (const i of e2) {
    const e3 = new c3();
    e3.read(i, r5), -1 === (t3 == null ? void 0 : t3.indexOf(e3.name)) && (e3.visible = false), s5.set(e3.id, e3);
  }
  const o4 = [];
  for (const a5 of e2) {
    const e3 = s5.get(a5.id);
    if (null != a5.parentLayerId && a5.parentLayerId >= 0) {
      const r6 = s5.get(a5.parentLayerId);
      r6.sublayers || (r6.sublayers = new j()), r6.sublayers.unshift(e3);
    } else
      o4.unshift(e3);
  }
  return o4;
}
e([d({ readOnly: true })], G.prototype, "allSublayers", void 0), e([d({ json: { type: Object, write: true } })], G.prototype, "customParameters", void 0), e([d({ json: { type: Object, write: true } })], G.prototype, "customLayerParameters", void 0), e([d({ type: String, json: { write: true } })], G.prototype, "copyright", void 0), e([d()], G.prototype, "description", void 0), e([d({ readOnly: true })], G.prototype, "dimensions", void 0), e([d({ json: { type: [[Number]], read: { source: "extent" }, write: { target: "extent" }, origins: { "web-document": { write: { ignoreOrigin: true } }, "portal-item": { write: { ignoreOrigin: true } } } } })], G.prototype, "fullExtent", void 0), e([o(["web-document", "portal-item"], "fullExtent", ["extent"])], G.prototype, "readFullExtentFromItemOrMap", null), e([r3(["web-document", "portal-item"], "fullExtent", { extent: { type: [[Number]] } })], G.prototype, "writeFullExtent", null), e([d()], G.prototype, "fullExtents", void 0), e([d({ type: String, json: { write: { ignoreOrigin: true } } })], G.prototype, "featureInfoFormat", void 0), e([d({ type: String, json: { write: { ignoreOrigin: true } } })], G.prototype, "featureInfoUrl", void 0), e([d({ type: String, json: { origins: { "web-document": { default: "image/png", type: D.jsonValues, read: { reader: D.read, source: "format" }, write: { writer: D.write, target: "format" } } } } })], G.prototype, "imageFormat", void 0), e([o("imageFormat", ["supportedImageFormatTypes"])], G.prototype, "readImageFormat", null), e([d({ type: Number, json: { read: { source: "maxHeight" }, write: { target: "maxHeight" } } })], G.prototype, "imageMaxHeight", void 0), e([d({ type: Number, json: { read: { source: "maxWidth" }, write: { target: "maxWidth" } } })], G.prototype, "imageMaxWidth", void 0), e([d()], G.prototype, "imageTransparency", void 0), e([d(c)], G.prototype, "legendEnabled", void 0), e([d({ type: ["show", "hide", "hide-children"] })], G.prototype, "listMode", void 0), e([d({ type: String, json: { write: { ignoreOrigin: true } } })], G.prototype, "mapUrl", void 0), e([d({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], G.prototype, "isReference", void 0), e([d({ type: ["WMS"] })], G.prototype, "operationalLayerType", void 0), e([d()], G.prototype, "resourceInfo", void 0), e([d({ type: k, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, write: false } })], G.prototype, "spatialReference", void 0), e([o(["web-document", "portal-item"], "spatialReference", ["spatialReferences"])], G.prototype, "readSpatialReferenceFromItemOrDocument", null), e([d({ type: [S], json: { read: false, origins: { service: { read: true }, "web-document": { read: false, write: { ignoreOrigin: true } }, "portal-item": { read: false, write: { ignoreOrigin: true } } } } })], G.prototype, "spatialReferences", void 0), e([r3(["web-document", "portal-item"], "spatialReferences")], G.prototype, "writeSpatialReferences", null), e([d({ type: j.ofType(c3), json: { write: { target: "layers", overridePolicy(e2, r5, t3) {
  if (J(this.allSublayers, t3))
    return { ignoreOrigin: true };
} } } })], G.prototype, "sublayers", void 0), e([o(["web-document", "portal-item"], "sublayers", ["layers", "visibleLayers"])], G.prototype, "readSublayersFromItemOrMap", null), e([o("service", "sublayers", ["layers"])], G.prototype, "readSublayers", null), e([r3("sublayers", { layers: { type: [c3] }, visibleLayers: { type: [String] } })], G.prototype, "writeSublayers", null), e([d({ json: { read: false }, readOnly: true, value: "wms" })], G.prototype, "type", void 0), e([d(f)], G.prototype, "url", void 0), e([d({ type: String, json: { write: { ignoreOrigin: true } } })], G.prototype, "version", void 0), G = e([n("esri.layers.WMSLayer")], G);
var Q = G;
export {
  Q as default
};
//# sourceMappingURL=WMSLayer-DUJQPVRB.js.map
