import {
  c as c2
} from "./chunk-GTBTSR4X.js";
import "./chunk-QJN4GT4E.js";
import {
  r as r4
} from "./chunk-TUZ3FLXS.js";
import {
  n as n2
} from "./chunk-POPR7XUB.js";
import {
  e as e2
} from "./chunk-VNR743PA.js";
import {
  a as a3
} from "./chunk-6O7ZZEV7.js";
import "./chunk-J6DXGG2A.js";
import {
  E,
  X,
  y as y2
} from "./chunk-24ZW6JTQ.js";
import {
  n as n4
} from "./chunk-X57S4DWT.js";
import "./chunk-D7AOY7GH.js";
import "./chunk-SZPDY7KN.js";
import {
  i
} from "./chunk-Y6YGVGFR.js";
import {
  p
} from "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import {
  o as o2
} from "./chunk-MZX3HN4G.js";
import "./chunk-T47JAOQZ.js";
import "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-TMSBC6BS.js";
import {
  n as n3
} from "./chunk-RIWDMEW4.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  v
} from "./chunk-OG6CQEZJ.js";
import {
  c
} from "./chunk-X5Z3DJQ4.js";
import {
  O
} from "./chunk-BUWXVMJU.js";
import {
  f
} from "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import {
  y
} from "./chunk-TBT57L4K.js";
import {
  a as a2
} from "./chunk-D3XXPCBB.js";
import {
  t as t2
} from "./chunk-OWBMOIIV.js";
import {
  b
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import {
  a
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import {
  r as r3
} from "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n,
  r2,
  t3 as t
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  g,
  w
} from "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  S
} from "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/MapImageLayer.js
var q = class extends a2(a3(t2(E(y2(p(c(v(O(n3(i(o2(a(b))))))))))))) {
  constructor(...e3) {
    super(...e3), this.datesInUnknownTimezone = false, this.dpi = 96, this.gdbVersion = null, this.imageFormat = "png24", this.imageMaxHeight = 2048, this.imageMaxWidth = 2048, this.imageTransparency = true, this.isReference = null, this.labelsVisible = false, this.operationalLayerType = "ArcGISMapServiceLayer", this.sourceJSON = null, this.sublayers = null, this.type = "map-image", this.url = null;
  }
  normalizeCtorArgs(e3, r5) {
    return "string" == typeof e3 ? { url: e3, ...r5 } : e3;
  }
  load(e3) {
    const r5 = r(e3) ? e3.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Map Service"] }, e3).catch(w).then(() => this._fetchService(r5))), Promise.resolve(this);
  }
  readImageFormat(e3, r5) {
    const t3 = r5.supportedImageFormatTypes;
    return t3 && t3.includes("PNG32") ? "png32" : "png24";
  }
  writeSublayers(e3, r5, t3, o3) {
    if (!this.loaded || !e3)
      return;
    const i2 = e3.slice().reverse().flatten(({ sublayers: e4 }) => e4 && e4.toArray().reverse()).toArray();
    let s2 = false;
    if (this.capabilities && this.capabilities.operations.supportsExportMap && this.capabilities.exportMap.supportsDynamicLayers) {
      const e4 = t(o3.origin);
      if (e4 === r2.PORTAL_ITEM) {
        const e5 = this.createSublayersForOrigin("service").sublayers;
        s2 = n4(i2, e5, r2.SERVICE);
      } else if (e4 > r2.PORTAL_ITEM) {
        const e5 = this.createSublayersForOrigin("portal-item");
        s2 = n4(i2, e5.sublayers, t(e5.origin));
      }
    }
    const a4 = [], p2 = { writeSublayerStructure: s2, ...o3 };
    let n5 = s2;
    i2.forEach((e4) => {
      const r6 = e4.write({}, p2);
      a4.push(r6), n5 = n5 || "user" === e4.originOf("visible");
    });
    a4.some((e4) => Object.keys(e4).length > 1) && (r5.layers = a4), n5 && (r5.visibleLayers = i2.filter((e4) => e4.visible).map((e4) => e4.id));
  }
  createExportImageParameters(e3, r5, t3, o3) {
    const i2 = o3 && o3.pixelRatio || 1;
    e3 && this.version >= 10 && (e3 = e3.clone().shiftCentralMeridian());
    const s2 = new c2({ layer: this, floors: o3 == null ? void 0 : o3.floors, scale: r4({ extent: e3, width: r5 }) * i2 }), a4 = s2.toJSON();
    s2.destroy();
    const p2 = !o3 || !o3.rotation || this.version < 10.3 ? {} : { rotation: -o3.rotation }, n5 = e3 && e3.spatialReference, m = n5.wkid || JSON.stringify(n5.toJSON());
    a4.dpi *= i2;
    const l = {};
    if (o3 == null ? void 0 : o3.timeExtent) {
      const { start: e4, end: r6 } = o3.timeExtent.toJSON();
      l.time = e4 && r6 && e4 === r6 ? "" + e4 : `${null == e4 ? "null" : e4},${null == r6 ? "null" : r6}`;
    } else
      this.timeInfo && !this.timeInfo.hasLiveData && (l.time = "null,null");
    return { bbox: e3 && e3.xmin + "," + e3.ymin + "," + e3.xmax + "," + e3.ymax, bboxSR: m, imageSR: m, size: r5 + "," + t3, ...a4, ...p2, ...l };
  }
  async fetchImage(e3, t3, i2, s2) {
    const a4 = { responseType: "image", signal: (s2 == null ? void 0 : s2.signal) ?? null, query: { ...this.parsedUrl.query, ...this.createExportImageParameters(e3, t3, i2, s2), f: "image", ...this.refreshParameters, ...this.customParameters, token: this.apiKey } }, p2 = this.parsedUrl.path + "/export";
    if (null != a4.query.dynamicLayers && !this.capabilities.exportMap.supportsDynamicLayers)
      throw new s("mapimagelayer:dynamiclayer-not-supported", `service ${this.url} doesn't support dynamic layers, which is required to be able to change the sublayer's order, rendering, labeling or source.`, { query: a4.query });
    return U(p2, a4).then((e4) => e4.data).catch((e4) => {
      if (g(e4))
        throw e4;
      throw new s("mapimagelayer:image-fetch-error", `Unable to load image: ${p2}`, { error: e4 });
    });
  }
  async fetchRecomputedExtents(e3 = {}) {
    const o3 = { ...e3, query: { returnUpdates: true, f: "json", ...this.customParameters, token: this.apiKey } }, { data: i2 } = await U(this.url, o3), { extent: s2, fullExtent: a4, timeExtent: p2 } = i2, n5 = s2 || a4;
    return { fullExtent: n5 && M.fromJSON(n5), timeExtent: p2 && y.fromJSON({ start: p2[0], end: p2[1] }) };
  }
  loadAll() {
    return n2(this, (e3) => {
      e3(this.allSublayers);
    });
  }
  serviceSupportsSpatialReference(e3) {
    return e2(this, e3);
  }
  async _fetchService(e3) {
    if (this.sourceJSON)
      return void this.read(this.sourceJSON, { origin: "service", url: this.parsedUrl });
    const { data: t3, ssl: o3 } = await U(this.parsedUrl.path, { query: { f: "json", ...this.parsedUrl.query, ...this.customParameters, token: this.apiKey }, signal: e3 });
    o3 && (this.url = this.url.replace(/^http:/i, "https:")), this.sourceJSON = t3, this.read(t3, { origin: "service", url: this.parsedUrl });
  }
};
e([d({ type: Boolean })], q.prototype, "datesInUnknownTimezone", void 0), e([d()], q.prototype, "dpi", void 0), e([d()], q.prototype, "gdbVersion", void 0), e([d()], q.prototype, "imageFormat", void 0), e([o("imageFormat", ["supportedImageFormatTypes"])], q.prototype, "readImageFormat", null), e([d({ json: { origins: { service: { read: { source: "maxImageHeight" } } } } })], q.prototype, "imageMaxHeight", void 0), e([d({ json: { origins: { service: { read: { source: "maxImageWidth" } } } } })], q.prototype, "imageMaxWidth", void 0), e([d()], q.prototype, "imageTransparency", void 0), e([d({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], q.prototype, "isReference", void 0), e([d({ json: { read: false, write: false } })], q.prototype, "labelsVisible", void 0), e([d({ type: ["ArcGISMapServiceLayer"] })], q.prototype, "operationalLayerType", void 0), e([d({ json: { read: false, write: false } })], q.prototype, "popupEnabled", void 0), e([d()], q.prototype, "sourceJSON", void 0), e([d({ json: { write: { ignoreOrigin: true } } })], q.prototype, "sublayers", void 0), e([r3("sublayers", { layers: { type: [X] }, visibleLayers: { type: [S] } })], q.prototype, "writeSublayers", null), e([d({ type: ["show", "hide", "hide-children"] })], q.prototype, "listMode", void 0), e([d({ json: { read: false }, readOnly: true, value: "map-image" })], q.prototype, "type", void 0), e([d(f)], q.prototype, "url", void 0), q = e([n("esri.layers.MapImageLayer")], q);
var F = q;
export {
  F as default
};
//# sourceMappingURL=MapImageLayer-CAL6DE2P.js.map
