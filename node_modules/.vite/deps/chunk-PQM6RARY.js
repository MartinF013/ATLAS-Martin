import {
  r as r6
} from "./chunk-4GGQTXXY.js";
import {
  G
} from "./chunk-XEWFCJLT.js";
import {
  e as e5,
  r as r5
} from "./chunk-EEJIELE6.js";
import {
  c as c2,
  f
} from "./chunk-Y55TYMBP.js";
import {
  o as o3,
  u as u3
} from "./chunk-MDCKEJ7B.js";
import {
  e as e4
} from "./chunk-NAIF4GWX.js";
import {
  l as l2
} from "./chunk-53KI6WDE.js";
import {
  O,
  _
} from "./chunk-W2HLA6I3.js";
import {
  e as e3,
  o as o2,
  r as r4
} from "./chunk-YFBAFAZ2.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  n as n4,
  u as u2
} from "./chunk-ASC3X65B.js";
import {
  n as n3
} from "./chunk-OIPX3EDD.js";
import {
  A,
  L,
  o,
  r as r3,
  x
} from "./chunk-PKZEO23A.js";
import {
  n as n2,
  r as r2,
  t as t2
} from "./chunk-AIRC226G.js";
import {
  e3 as e2,
  n4 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-5EQKHR4M.js";
import {
  c,
  l,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GeometryRecord.js
var o4 = class {
  constructor() {
    this._disposed = false;
  }
  get disposed() {
    return this._disposed;
  }
  get shaderTransformation() {
    return this._shaderTransformation;
  }
  acquire(t3, r7, i, o5, e7, a) {
    this.id = e2(), this.geometry = t3, this.material = r7, this.transformation = i, this.instanceParameters = o5, this.origin = e7, this._shaderTransformation = a, this._disposed = false;
  }
  release() {
    this._disposed = false;
  }
  dispose() {
    this._disposed = true;
  }
  getStaticTransformation() {
    return this.transformation;
  }
  getShaderTransformation() {
    return r(this._shaderTransformation) ? this._shaderTransformation(this.transformation) : this.transformation;
  }
  computeAttachmentOrigin(t3) {
    return !!(this.material.computeAttachmentOrigin ? this.material.computeAttachmentOrigin(this.geometry, t3) : this.geometry.computeAttachmentOrigin(t3)) && (L(t3, t3, this.getStaticTransformation()), true);
  }
};
o4.pool = new e(o4);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DirtyEvents.js
var e6 = ["layerObjectAdded", "layerObjectRemoved", "layerObjectsAdded", "layerObjectsRemoved", "shaderTransformationChanged", "objectTransformation", "visibilityChanged", "occlusionChanged", "highlightChanged", "objectGeometryAdded", "objectGeometryRemoved", "vertexAttrsUpdated"];

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/WebGLLayer.js
var l3 = class extends r5 {
  constructor(s, r7 = "") {
    super(), this.apiLayerUid = r7, this.type = e5.Layer, this.events = new n3(), this.isSliceable = false, this._objects = new n(), this._stageHandles = new u(), this.apiLayerUid = r7, this.isVisible = (s == null ? void 0 : s.isVisible) ?? true, this.isPickable = (s == null ? void 0 : s.isPickable) ?? true, this.updatePolicy = (s == null ? void 0 : s.updatePolicy) ?? o3.ASYNC;
  }
  get objects() {
    return this._objects;
  }
  destroy() {
    this.detachStage(), this._stage = null;
  }
  attachStage(e7) {
    this.detachStage(), this._stage = e7;
    for (const t3 of e6)
      this._stageHandles.add(this.events.on(t3, (s) => e7.handleEvent(t3, s)));
  }
  detachStage() {
    this._stageHandles.removeAll(), this.invalidateSpatialQueryAccelerator();
  }
  add(e7) {
    this._objects.push(e7), e7.parentLayer = this, this.events.emit("layerObjectAdded", { layer: this, object: e7 }), r(this._octree) && this._octree.add([e7]);
  }
  remove(e7) {
    this._objects.removeUnordered(e7) && (e7.parentLayer = null, this.events.emit("layerObjectRemoved", { layer: this, object: e7 }), r(this._octree) && this._octree.remove([e7]));
  }
  addMany(e7) {
    this._objects.pushArray(e7);
    for (const t3 of e7)
      t3.parentLayer = this;
    this.events.emit("layerObjectsAdded", { layer: this, objects: e7 }), r(this._octree) && this._octree.add(e7);
  }
  removeMany(e7) {
    const t3 = new Array();
    if (this._objects.removeUnorderedMany(e7, e7.length, t3), 0 !== t3.length) {
      for (const e8 of t3)
        e8.parentLayer = null;
      this.events.emit("layerObjectsRemoved", { layer: this, objects: t3 }), r(this._octree) && this._octree.remove(t3);
    }
  }
  sync() {
    r(this._stage) && this.updatePolicy !== o3.SYNC && this._stage.syncLayer(this.id);
  }
  notifyObjectBBChanged(e7, t3) {
    r(this._octree) && this._octree.update(e7, t3);
  }
  getSpatialQueryAccelerator() {
    return t(this._octree) && this._objects.length > 50 && this._createOctree(), this._octree;
  }
  shaderTransformationChanged() {
    this.invalidateSpatialQueryAccelerator(), this.events.emit("shaderTransformationChanged", this);
  }
  invalidateSpatialQueryAccelerator() {
    this._octree = l(this._octree);
  }
  _createOctree() {
    this._octree = new G((e7) => e7.boundingVolumeWorldSpace.bounds), this._octree.add(this._objects.data, this._objects.length);
  }
};
function y(e7) {
  return r(e7) && e7.type === e5.Layer;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Object3D.js
var O2 = class extends r5 {
  constructor(t3 = {}) {
    super(), this.type = e5.Object, this._geometryRecords = new Array(), this._geometries = new Array(), this._objectTransformation = e3(), this._bvObjectSpace = new R(), this._bvWorldSpace = new R(), this._bvDirty = true, this._hasVolatileTransformation = false, this._visible = true, this.castShadow = null == t3.castShadow || t3.castShadow, this.metadata = t3.metadata, this.metadata && this.metadata.isElevationSource && (this.metadata.lastValidElevationBB = new L2()), this.transformation = e3();
    const { geometries: e7, materials: s, transformations: i, origins: r7 } = t3;
    if (Array.isArray(e7)) {
      e4(s.length === e7.length, "Object3D: materials don't match geometries"), e4(i.length === e7.length, "Object3D: transformations don't match geometries"), this._geometryRecords.length = e7.length, this._geometries.length = e7.length;
      for (let t4 = 0; t4 < e7.length; t4++)
        this._geometries[t4] = e7[t4], this._geometryRecords[t4] = o4.pool.acquire(e7[t4], s[t4], r4(i[t4]), { highlights: null, occludees: null, visible: this._visible }, r7 && r7[t4]);
    }
  }
  get geometryRecords() {
    return this._geometryRecords;
  }
  get geometries() {
    return this._geometries;
  }
  get transformation() {
    return this._objectTransformation;
  }
  set transformation(t3) {
    n4(this._objectTransformation, t3), this._invalidateBoundingVolume(), this._emit("objectTransformation", this);
  }
  dispose() {
    this._geometryRecords.length = 0, this._geometries.length = 0;
  }
  get parentLayer() {
    return this._parentLayer;
  }
  set parentLayer(t3) {
    e4(null == this._parentLayer || null == t3, "Object3D can only be added to a single Layer"), this._parentLayer = t3;
  }
  addGeometry(e7, s, i, r7, o5) {
    i = i || o2, this._geometries.push(e7);
    const a = o4.pool.acquire(e7, s, i, { highlights: null, occludees: null, visible: this._visible }, r7, o5);
    return this._geometryRecords.push(a), this._hasVolatileTransformation = this._hasVolatileTransformation || r(a.shaderTransformation), this._emit("objectGeometryAdded", { object: this, record: a }), this._invalidateBoundingVolume(), a;
  }
  removeGeometry(e7) {
    const s = this._geometryRecords.splice(e7, 1)[0];
    return this._hasVolatileTransformation = r(s.shaderTransformation) ? this._geometryRecords.some((e8) => r(e8.shaderTransformation)) : this._hasVolatileTransformation, s.dispose(), this._geometries.splice(e7, 1), this._emit("objectGeometryRemoved", { object: this, record: s }), this._invalidateBoundingVolume(), s;
  }
  removeAllGeometries() {
    for (; this.geometryRecords.length > 0; )
      this.removeGeometry(0);
  }
  geometryVertexAttrsUpdated(t3) {
    this._emit("vertexAttrsUpdated", { object: this, record: t3 }), this._invalidateBoundingVolume();
  }
  get isVisible() {
    return this._visible;
  }
  setVisible(t3) {
    if (this._visible !== t3) {
      this._visible = t3;
      for (const t4 of this._geometryRecords)
        t4.instanceParameters.visible = this._visible;
      this._emit("visibilityChanged", this);
    }
  }
  maskOccludee() {
    const t3 = new r6(u3.MaskOccludee);
    for (const e7 of this._geometryRecords)
      e7.instanceParameters.occludees = c2(e7.instanceParameters.occludees, t3);
    return this._emit("occlusionChanged", this), t3;
  }
  removeOcclude(t3) {
    for (const e7 of this._geometryRecords)
      e7.instanceParameters.occludees = f(e7.instanceParameters.occludees, t3);
    this._emit("occlusionChanged", this);
  }
  highlight() {
    const t3 = new r6(u3.Highlight);
    for (const e7 of this._geometryRecords)
      e7.instanceParameters.highlights = c2(e7.instanceParameters.highlights, t3);
    return this._emit("highlightChanged", this), t3;
  }
  removeHighlight(t3) {
    for (const e7 of this._geometryRecords)
      e7.instanceParameters.highlights = f(e7.instanceParameters.highlights, t3);
    this._emit("highlightChanged", this);
  }
  getCombinedStaticTransformation(t3, s) {
    return u2(c(s, e3()), this.transformation, t3.getStaticTransformation());
  }
  _getCombinedShaderTransformation(t3, e7) {
    return e7 = e7 || e3(), u2(e7, this.transformation, t3.getShaderTransformation()), e7;
  }
  hasVolativeTransformation() {
    return this._hasVolatileTransformation;
  }
  get boundingVolumeWorldSpace() {
    return this._validateBoundingVolume(), this._bvWorldSpace;
  }
  get boundingVolumeObjectSpace() {
    return this._validateBoundingVolume(), this._bvObjectSpace;
  }
  _validateBoundingVolume() {
    if (!this._bvDirty && !this._hasVolatileTransformation)
      return;
    this._bvObjectSpace.init(), this._bvWorldSpace.init();
    for (let s = 0; s < this._geometryRecords.length; ++s) {
      const e8 = this._geometries[s], i2 = this._geometryRecords[s], r8 = e8.boundingInfo;
      r(r8) && (this._calculateTransformedBoundingVolume(r8, this._bvObjectSpace, i2.getShaderTransformation()), this._calculateTransformedBoundingVolume(r8, this._bvWorldSpace, this._getCombinedShaderTransformation(i2)));
    }
    A(this._bvObjectSpace.bounds, this._bvObjectSpace.min, this._bvObjectSpace.max, 0.5), A(this._bvWorldSpace.bounds, this._bvWorldSpace.min, this._bvWorldSpace.max, 0.5);
    const e7 = n2(), i = n2(), r7 = l2(this.transformation);
    for (let t3 = 0; t3 < this._geometryRecords.length; ++t3) {
      const o5 = this._geometries[t3].boundingInfo;
      if (t(o5))
        continue;
      const a = this._geometryRecords[t3].getShaderTransformation(), n5 = l2(a);
      L(e7, o5.getCenter(), a);
      const h = x(e7, this._bvObjectSpace.bounds), l4 = o5.getBSRadius() * n5;
      this._bvObjectSpace.bounds[3] = Math.max(this._bvObjectSpace.bounds[3], h + l4), L(i, e7, this.transformation);
      const d = x(i, this._bvWorldSpace.bounds), g = l4 * r7;
      this._bvWorldSpace.bounds[3] = Math.max(this._bvWorldSpace.bounds[3], d + g);
    }
    this._bvDirty = false;
  }
  _calculateTransformedBoundingVolume(t3, e7, s) {
    const i = t3.getBBMin(), r7 = t3.getBBMax(), o5 = t2(i), a = t2(r7);
    L(o5, o5, s), L(a, a, s);
    for (let n5 = 0; n5 < 3; ++n5)
      e7.min[n5] = Math.min(e7.min[n5], o5[n5], a[n5]), e7.max[n5] = Math.max(e7.max[n5], o5[n5], a[n5]);
    for (let n5 = 0; n5 < 3; ++n5) {
      r3(o5, i), r3(a, r7), o5[n5] = r7[n5], a[n5] = i[n5], L(o5, o5, s), L(a, a, s);
      for (let t4 = 0; t4 < 3; ++t4)
        e7.min[t4] = Math.min(e7.min[t4], o5[t4], a[t4]), e7.max[t4] = Math.max(e7.max[t4], o5[t4], a[t4]);
    }
  }
  _invalidateBoundingVolume() {
    this._bvDirty = true, r(this._parentLayer) && this._parentLayer.notifyObjectBBChanged(this, this._bvWorldSpace.bounds);
  }
  _emit(e7, s) {
    r(this._parentLayer) && this._parentLayer.events.emit(e7, s);
  }
  get test() {
    const t3 = this;
    return { hasGeometry: (e7) => t3._geometries.includes(e7), getGeometryIndex: (e7) => t3._geometries.indexOf(e7) };
  }
};
var L2 = class {
  constructor() {
    this.min = r2(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this.max = r2(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  }
  isEmpty() {
    return this.max[0] < this.min[0] && this.max[1] < this.min[1] && this.max[2] < this.min[2];
  }
};
var R = class extends L2 {
  constructor() {
    super(...arguments), this.bounds = _();
  }
  init() {
    o(this.min, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), o(this.max, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), O(this.bounds);
  }
};

export {
  o4 as o,
  O2 as O,
  l3 as l,
  y
};
//# sourceMappingURL=chunk-PQM6RARY.js.map
