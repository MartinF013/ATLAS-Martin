import {
  G
} from "./chunk-22MSECLU.js";
import {
  c as c2,
  u as u2
} from "./chunk-DSCM4HDL.js";
import {
  s as s2
} from "./chunk-WGMCNMOI.js";
import {
  i as i2,
  t as t3,
  x
} from "./chunk-WQLER7IU.js";
import {
  j
} from "./chunk-MOXYEJRV.js";
import {
  _ as _2,
  p2 as p,
  q2
} from "./chunk-53KI6WDE.js";
import {
  d as d2,
  e as e2
} from "./chunk-W2HLA6I3.js";
import {
  t as t2
} from "./chunk-ZYIEYKCD.js";
import {
  Pn
} from "./chunk-PZWU5EHT.js";
import {
  d,
  i,
  l
} from "./chunk-NWRK6QLX.js";
import {
  P,
  _,
  e,
  q,
  r as r2,
  s,
  u
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";
import {
  c,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/interactive/editingTools/dragEventPipeline3D.js
function C(e3, r3) {
  return D(e3, () => r3);
}
function T(e3) {
  return D(e3, (e4) => e4.plane);
}
function D(t4, s3) {
  const c3 = n(), l2 = n();
  let i3 = false;
  return (a) => {
    const u3 = s3(a);
    if ("start" === a.action) {
      const r3 = d(a.screenStart, l(t2.get())), s4 = s2(t4.state.camera, r3, L);
      r(s4) && (i3 = q2(u3, s4, c3));
    }
    if (!i3)
      return null;
    const p2 = d(a.screenEnd, l(t2.get())), m = s2(t4.state.camera, p2, L);
    return t(m) ? null : q2(u3, m, l2) ? { ...a, renderStart: c3, renderEnd: l2, plane: u3, ray: m } : null;
  };
}
function M(t4, n2, o, c3 = null, l2 = null) {
  let i3 = null;
  return (a) => {
    if ("start" === a.action && (i3 = t4.sceneIntersectionHelper.intersectElevationFromScreen(i(a.screenStart.x, a.screenStart.y), n2, o, l2), r(i3) && r(c3) && !Pn(i3, i3, c3)))
      return null;
    if (t(i3))
      return null;
    const u3 = t4.sceneIntersectionHelper.intersectElevationFromScreen(i(a.screenEnd.x, a.screenEnd.y), n2, o, l2);
    return r(u3) ? r(c3) && !Pn(u3, u3, c3) ? null : { ...a, mapStart: i3, mapEnd: u3 } : null;
  };
}
function N(e3, r3, t4, n2 = null, o = null) {
  return M(e3, t4, c2(r3, e3, t4), n2, o);
}
function P2(e3, r3, t4, n2 = null, o = null) {
  return N(e3, t4, u2(r3), n2, o);
}
function h(r3, t4, n2, o) {
  const s3 = t4.toMap(r3.screenStart, { include: [n2] });
  return r(s3) ? P2(t4, n2, s3, o) : null;
}
function k(e3, r3) {
  const t4 = J, n2 = K, o = p();
  e3.renderCoordsHelper.worldUpAtPosition(r3, t4);
  const s3 = _(o, t4, e(n2, r3, e3.state.camera.eye));
  return _(s3, s3, t4), _2(r3, s3, o);
}
function G2(e3, r3, t4) {
  let n2 = null;
  const o = new G();
  return o.next(C(e3, k(e3, r3))).next(A(e3, r3)).next(F(e3, t4)).next((e4) => {
    e4.mapEnd.x = e4.mapStart.x, e4.mapEnd.y = e4.mapStart.y, n2 = e4;
  }), (e4) => (n2 = null, o.execute(e4), n2);
}
function A(e3, r3) {
  const t4 = n(), n2 = s(r3);
  e3.renderCoordsHelper.worldUpAtPosition(r3, t4);
  const o = n(), s3 = n(), m = (o2) => {
    if (e(o2, o2, r3), e2(t4, o2, o2), "global" === e3.viewingMode) {
      s(o2) * Math.sign(P(t4, o2)) < 1e-3 - n2 && e(o2, q(o2, t4, 1e-3), r3);
    }
    return u(o2, o2, r3), o2;
  };
  return (e4) => (e4.renderStart = m(r2(o, e4.renderStart)), e4.renderEnd = m(r2(s3, e4.renderEnd)), e4);
}
function F(r3, t4) {
  const n2 = r3.renderCoordsHelper;
  return (r4) => {
    const o = n2.fromRenderCoords(r4.renderStart, t4), s3 = n2.fromRenderCoords(r4.renderEnd, t4);
    return r(o) && r(s3) ? { ...r4, mapStart: o, mapEnd: s3 } : null;
  };
}
var q3;
function z(r3) {
  let t4 = null;
  return (n2) => {
    switch (n2.action) {
      case "start":
        t4 = r3.disableDisplay();
        break;
      case "end":
      case "cancel":
        r(t4) && (t4.remove(), t4 = null);
    }
    return n2;
  };
}
function B(o, c3 = null) {
  const l2 = x(o.state.viewingMode);
  l2.options.selectionMode = true, l2.options.store = t3.MIN, l2.options.hud = false;
  const i3 = i(), a = { requiresGroundFeedback: true, enableDraped: true, exclude: /* @__PURE__ */ new Set() }, u3 = n(), p2 = c(c3, o.spatialReference), m = (e3) => {
    o.map.ground && o.map.ground.opacity < 1 ? a.exclude.add(j) : a.exclude.delete(j), o.sceneIntersectionHelper.intersectIntersectorScreen(d(e3, i3), l2, a);
    const r3 = l2.results.min;
    let t4;
    if (r3.getIntersectionPoint(u3))
      t4 = r3.intersector === i2.TERRAIN ? q3.GROUND : q3.OTHER;
    else {
      if (!l2.results.ground.getIntersectionPoint(u3))
        return null;
      t4 = q3.GROUND;
    }
    return { location: o.renderCoordsHelper.fromRenderCoords(u3, p2), surfaceType: t4 };
  };
  let f;
  return (t4) => {
    if ("start" === t4.action) {
      const r3 = m(t4.screenStart);
      f = r(r3) ? r3.location : null;
    }
    if (t(f))
      return null;
    const n2 = m(t4.screenEnd);
    return r(n2) && r(n2.location) ? { ...t4, mapStart: f, mapEnd: n2.location, surfaceType: n2.surfaceType } : null;
  };
}
!function(e3) {
  e3[e3.GROUND = 0] = "GROUND", e3[e3.OTHER = 1] = "OTHER";
}(q3 || (q3 = {}));
var J = n();
var K = n();
var L = d2();

export {
  C,
  T,
  N,
  P2 as P,
  h,
  G2 as G,
  F,
  q3 as q,
  z,
  B
};
//# sourceMappingURL=chunk-RED2ALFM.js.map
