import {
  D,
  h as h4
} from "./chunk-WK7SHMYW.js";
import "./chunk-GL3DI4QI.js";
import "./chunk-4OFLHC3C.js";
import {
  e as e4
} from "./chunk-KXA3AZ4N.js";
import {
  g as g2
} from "./chunk-2OSYZ3IL.js";
import {
  h as h3
} from "./chunk-CRCA6KDA.js";
import {
  e as e2
} from "./chunk-T6BL6FYR.js";
import {
  S
} from "./chunk-GVCSP4OP.js";
import "./chunk-PJI2LYU5.js";
import {
  s as s3
} from "./chunk-PTJ3MGYO.js";
import "./chunk-YDPQRKY4.js";
import {
  e as e3
} from "./chunk-XKY65LLM.js";
import "./chunk-ILEVWNLM.js";
import "./chunk-3HMF3PNP.js";
import "./chunk-N5C77AAH.js";
import "./chunk-DSCM4HDL.js";
import "./chunk-53KI6WDE.js";
import "./chunk-W2HLA6I3.js";
import "./chunk-ZYIEYKCD.js";
import "./chunk-TQLSOIYV.js";
import "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-RBVTRJPJ.js";
import "./chunk-YZNDHJDJ.js";
import {
  g as g3
} from "./chunk-Z3S5X75I.js";
import "./chunk-NMRWU44S.js";
import "./chunk-V7M26XZ7.js";
import {
  l as l2
} from "./chunk-ZN2MGN4S.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-PZWU5EHT.js";
import {
  h as h2
} from "./chunk-BS7TS6UC.js";
import "./chunk-37ZVELW7.js";
import "./chunk-YL26MZEL.js";
import "./chunk-YG6VFATO.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-D3XXPCBB.js";
import "./chunk-OWBMOIIV.js";
import "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  P,
  f
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import {
  y
} from "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import {
  j as j2
} from "./chunk-TT2HIXWQ.js";
import {
  n as n2
} from "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import {
  m2
} from "./chunk-CHNDTVQJ.js";
import {
  i,
  t as t2,
  u
} from "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  O
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  h,
  l,
  m,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/draw/support/Reshape.js
var A = class {
  constructor(e5, t3, i2) {
    this.graphic = e5, this.mover = t3, this.selected = i2, this.type = "reshape-start";
  }
};
var U = class {
  constructor(e5, t3, i2) {
    this.graphic = e5, this.mover = t3, this.selected = i2, this.type = "reshape";
  }
};
var T = class {
  constructor(e5, t3, i2) {
    this.graphic = e5, this.mover = t3, this.selected = i2, this.type = "reshape-stop";
  }
};
var D2 = class {
  constructor(e5, t3, i2) {
    this.mover = e5, this.dx = t3, this.dy = i2, this.type = "move-start";
  }
};
var F = class {
  constructor(e5, t3, i2) {
    this.mover = e5, this.dx = t3, this.dy = i2, this.type = "move";
  }
};
var z = class {
  constructor(e5, t3, i2) {
    this.mover = e5, this.dx = t3, this.dy = i2, this.type = "move-stop";
  }
};
var L = class {
  constructor(e5) {
    this.added = e5, this.type = "vertex-select";
  }
};
var P2 = class {
  constructor(e5) {
    this.removed = e5, this.type = "vertex-deselect";
  }
};
var K = class {
  constructor(e5, t3, i2, s4) {
    this.added = e5, this.graphic = t3, this.oldGraphic = i2, this.vertices = s4, this.type = "vertex-add";
  }
};
var N = class {
  constructor(e5, t3, i2, s4) {
    this.removed = e5, this.graphic = t3, this.oldGraphic = i2, this.vertices = s4, this.type = "vertex-remove";
  }
};
var q = h3.reshapeGraphics;
var B = { vertices: { default: new y({ style: "circle", size: q.vertex.size, color: q.vertex.color, outline: { color: q.vertex.outlineColor, width: 1 } }), hover: new y({ style: "circle", size: q.vertex.hoverSize, color: q.vertex.hoverColor, outline: { color: q.vertex.hoverOutlineColor, width: 1 } }), selected: new y({ style: "circle", size: q.selected.size, color: q.selected.color, outline: { color: q.selected.outlineColor, width: 1 } }) }, midpoints: { default: new y({ style: "circle", size: q.midpoint.size, color: q.midpoint.color, outline: { color: q.midpoint.outlineColor, width: 1 } }), hover: new y({ style: "circle", size: q.midpoint.size, color: q.midpoint.color, outline: { color: q.midpoint.outlineColor, width: 1 } }) } };
var J = "esri.views.draw.support.Reshape";
var Q = s.getLogger(J);
var W = class extends n2.EventedAccessor {
  constructor(e5) {
    super(e5), this._activeOperationInfo = null, this._editGeometryOperations = null, this._handles = new u2(), this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._snappingTask = null, this._stagedVertex = null, this._viewHandles = new u2(), this.callbacks = { onReshapeStart() {
    }, onReshape() {
    }, onReshapeStop() {
    }, onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onGraphicClick() {
    } }, this.enableMidpoints = true, this.enableMovement = true, this.enableVertices = true, this.graphic = null, this.layer = null, this.midpointGraphics = new j2(), this.midpointSymbol = new y({ style: "circle", size: 6, color: [200, 200, 200], outline: { color: [100, 100, 100], width: 1 } }), this.selectedVertices = [], this.snappingManager = null, this.type = "reshape", this.vertexGraphics = new j2(), this.view = null;
  }
  initialize() {
    this._highlightHelper = new h4({ view: this.view }), this._setup(), this._handles.add([f(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.ready;
    }, () => {
      const { layer: e5, view: t3 } = this;
      e4(t3, e5), this._viewHandles.add(t3.on("key-down", (e6) => this._keyDownHandler(e6), g3.TOOL));
    }, { once: true, initial: true }), P(() => this.graphic, () => this.refresh()), P(() => this.layer, (e5, t3) => {
      t3 && (this._clearSelection(), this._resetGraphics(t3)), this.refresh();
    }), P(() => this.enableMidpoints, () => this.refresh())]);
  }
  destroy() {
    var _a;
    this._reset(), (_a = this._mover) == null ? void 0 : _a.destroy(), this._mover = null, this._handles = l(this._handles), this._viewHandles = l(this._viewHandles);
  }
  set highlightsEnabled(e5) {
    var _a;
    (_a = this._highlightHelper) == null ? void 0 : _a.removeAll(), this._set("highlightsEnabled", e5), this._setUpHighlights();
  }
  get state() {
    const e5 = !!this.get("view.ready"), t3 = !(!this.get("graphic") || !this.get("layer"));
    return e5 && t3 ? "active" : e5 ? "ready" : "disabled";
  }
  set symbols(e5) {
    const { midpoints: t3 = B.midpoints, vertices: i2 = B.vertices } = e5 || {};
    this._set("symbols", { midpoints: t3, vertices: i2 });
  }
  isUIGraphic(e5) {
    const t3 = [];
    return this.graphic && t3.push(this.graphic), t3.concat(this.vertexGraphics.items, this.midpointGraphics.items), t3.length && t3.includes(e5);
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphic = null;
  }
  clearSelection() {
    this._clearSelection();
  }
  removeSelectedVertices() {
    this.selectedVertices.length && this._removeVertices(this.selectedVertices);
  }
  _setup() {
    const { graphic: e5, layer: t3 } = this;
    if (!t3 || !e5 || t(e5.geometry))
      return;
    const i2 = e5.geometry;
    "mesh" !== i2.type && "extent" !== i2.type ? ("polygon" === i2.type && u(i2), this._setUpHighlights(), this._setupGraphics(), this._setupMover()) : this._logGeometryTypeError();
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphic && this._highlightHelper.add(this.graphic);
  }
  _setUpGeometryHelper() {
    const e5 = this.graphic.geometry;
    if (t(e5) || "mesh" === e5.type || "extent" === e5.type)
      return void this._logGeometryTypeError();
    const t3 = "multipoint" === e5.type ? new m2({ paths: e5.points, spatialReference: e5.spatialReference }) : e5;
    this._editGeometryOperations = S.fromGeometry(t3, l2.Local);
  }
  _saveSnappingContextForHandle(e5, t3) {
    var _a;
    this._snappingGraphicsLayer = new h2({ listMode: "hide", internal: true, title: "Reshape snapping layer" }), this.view.map.layers.add(this._snappingGraphicsLayer), this._snappingContext = new e2({ editGeometryOperations: this._editGeometryOperations, elevationInfo: { mode: "on-the-ground", offset: 0 }, pointer: ((_a = t3.viewEvent) == null ? void 0 : _a.pointerType) || "mouse", excludeFeature: this.graphic, visualizer: new g2(this._snappingGraphicsLayer), vertexHandle: this._getVertexFromEditGeometry(e5) });
  }
  _reset() {
    this._clearSelection(), this._highlightHelper.removeAll(), this._resetGraphics(), this._resetSnappingStateVars(), this._activeOperationInfo = null, this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetSnappingStateVars() {
    r(this.snappingManager) && this.snappingManager.doneSnapping(), r(this._snappingGraphicsLayer) && (this.view.map.layers.remove(this._snappingGraphicsLayer), this._snappingGraphicsLayer.destroy()), this._editGeometryOperations = l(this._editGeometryOperations), this._snappingTask = h(this._snappingTask), this._snappingTask = null, this._snappingContext = null, this._stagedVertex = null;
  }
  _resetGraphics(e5) {
    this._removeMidpointGraphics(e5), this._removeVertexGraphics(e5), this._set("selectedVertices", []);
  }
  _removeMidpointGraphics(e5) {
    const t3 = e5 || this.layer;
    t3 && t3.removeMany(this.midpointGraphics.items), this.midpointGraphics.items.forEach((e6) => e6.destroy()), this.midpointGraphics.removeAll();
  }
  _removeVertexGraphics(e5) {
    const t3 = e5 || this.layer;
    t3 && t3.removeMany(this.vertexGraphics.items), this.vertexGraphics.items.forEach((e6) => e6.destroy()), this.vertexGraphics.removeAll();
  }
  _getCoordinatesForUI(e5) {
    const t3 = t2(e5.clone());
    if ("polygon" === e5.type)
      for (const i2 of t3) {
        const e6 = i2[i2.length - 1];
        i2[0][0] === e6[0] && i2[0][1] === e6[1] && i2.length > 2 && i2.pop();
      }
    return t3;
  }
  _setupGraphics() {
    const e5 = this.graphic.geometry;
    if (r(e5) && ("polyline" === e5.type || "polygon" === e5.type)) {
      const t3 = this._getCoordinatesForUI(e5);
      this.enableMidpoints && this._setUpMidpointGraphics(t3), this.enableVertices && this._setUpVertexGraphics(t3);
    }
  }
  _setUpMidpointGraphics(e5) {
    this._removeMidpointGraphics();
    const t3 = this._createMidpointGraphics(e5);
    this.midpointGraphics.addMany(t3), this.layer.addMany(t3);
  }
  _setUpVertexGraphics(e5) {
    this._removeVertexGraphics();
    const t3 = this._createVertexGraphics(e5);
    this.vertexGraphics.addMany(t3), this._storeRelatedVertexIndices(), this.layer.addMany(t3);
  }
  _createVertexGraphics(e5) {
    const { _graphicAttributes: i2, symbols: s4, view: { spatialReference: r2 } } = this, o = [];
    return e5 == null ? void 0 : e5.forEach((e6, n3) => {
      e6.forEach((e7, a) => {
        var _a;
        const [h5, c] = e7;
        o.push(new g({ geometry: new j({ x: h5, y: c, spatialReference: r2 }), symbol: (_a = s4 == null ? void 0 : s4.vertices) == null ? void 0 : _a.default, attributes: { ...i2, pathIndex: n3, pointIndex: a } }));
      });
    }), o;
  }
  _createMidpointGraphics(e5) {
    const { _graphicAttributes: i2, symbols: s4, view: { spatialReference: r2 } } = this, o = [];
    return e5 == null ? void 0 : e5.forEach((e6, n3) => {
      e6.forEach((a, h5) => {
        const [c, p] = a, d2 = e6[h5 + 1] ? h5 + 1 : 0;
        if ("polygon" === m(this.graphic.geometry, "type") || 0 !== d2) {
          const [a2, l3] = e6[d2], [m3, v] = i([c, p], [a2, l3]);
          o.push(new g({ geometry: new j({ x: m3, y: v, spatialReference: r2 }), symbol: s4.midpoints.default, attributes: { ...i2, pathIndex: n3, pointIndexStart: h5, pointIndexEnd: d2 } }));
        }
      });
    }), o;
  }
  _storeRelatedVertexIndices() {
    const e5 = this.vertexGraphics.items;
    if (!e5)
      return;
    const t3 = e5.map(({ geometry: e6 }) => ({ x: e6.x, y: e6.y }));
    for (let i2 = 0; i2 < t3.length; i2++) {
      const s4 = [];
      for (let e6 = 0; e6 < t3.length; e6++) {
        if (i2 === e6)
          continue;
        const r2 = t3[i2], o = t3[e6];
        r2.x === o.x && r2.y === o.y && s4.push(e6);
      }
      e5[i2].attributes.relatedGraphicIndices = s4;
    }
  }
  _setupMover() {
    const { enableMovement: e5, graphic: t3, midpointGraphics: i2, vertexGraphics: s4, view: r2 } = this, o = s4.concat(i2).items;
    e5 && o.push(t3), this._mover = new D({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, graphics: o, view: r2, callbacks: { onGraphicClick: (e6) => this._onGraphicClickCallback(e6), onGraphicMoveStart: (e6) => this._onGraphicMoveStartCallback(e6), onGraphicMove: (e6) => this._onGraphicMoveCallback(e6), onGraphicMoveStop: (e6) => this._onGraphicMoveStopCallback(e6), onGraphicPointerOver: (e6) => this._onGraphicPointerOverCallback(e6), onGraphicPointerOut: (e6) => this._onGraphicPointerOutCallback(e6) } });
  }
  _onGraphicClickCallback(e5) {
    e5.viewEvent.stopPropagation();
    const t3 = e5.graphic;
    if (t3 === this.graphic)
      this.clearSelection(), this.emit("graphic-click", e5), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(e5);
    else if (this._isMidpoint(t3)) {
      if (2 === e5.viewEvent.button)
        return;
      const i2 = this.graphic.clone(), s4 = this._createVertexFromMidpoint(t3);
      this.refresh(), this._emitVertexAddEvent([t3], i2, s4);
    } else if (this._isVertex(t3))
      if (e5.viewEvent.stopPropagation(), 2 === e5.viewEvent.button)
        this._removeVertices(t3);
      else {
        e5.viewEvent.native.shiftKey || this._clearSelection(), this.selectedVertices.includes(t3) ? this._removeFromSelection(t3, true) : this._addToSelection(t3);
      }
  }
  _setUpOperation(e5) {
    const { graphic: t3, dx: i2, dy: s4 } = e5, r2 = t3 === this.graphic;
    this._resetSnappingStateVars(), this._setUpGeometryHelper(), this._saveSnappingContextForHandle(t3, e5), this._activeOperationInfo = { target: this.graphic, mover: t3, operationType: r2 ? "move" : "reshape", totalDx: i2, totalDy: s4 };
  }
  _onGraphicMoveStartCallback(e5) {
    const t3 = e5.graphic, { dx: i2, dy: s4 } = e5;
    if (t3 === this.graphic)
      return this._clearSelection(), this._resetGraphics(), this._setUpOperation(e5), this._emitMoveStartEvent(i2, s4), void ("point" === this._editGeometryOperations.data.type && this._onHandleMove(t3, i2, s4, e5, () => this._emitMoveEvent(i2, s4)));
    if (!this.selectedVertices.includes(t3)) {
      if (this._clearSelection(), this._isMidpoint(t3)) {
        const e6 = this.graphic.clone(), i3 = this._createVertexFromMidpoint(t3);
        this._emitVertexAddEvent([t3], e6, i3);
      }
      this._addToSelection(t3);
    }
    this._setUpOperation(e5), this._emitReshapeStartEvent(t3), this._onHandleMove(t3, i2, s4, e5, () => this._emitReshapeEvent(t3));
  }
  _onGraphicMoveCallback(e5) {
    const { graphic: t3, dx: i2, dy: s4 } = e5;
    this._activeOperationInfo.totalDx += i2, this._activeOperationInfo.totalDy += s4;
    const { operationType: r2 } = this._activeOperationInfo;
    "move" === r2 ? "point" === this._editGeometryOperations.data.type ? this._onHandleMove(t3, i2, s4, e5, () => this._emitMoveEvent(i2, s4)) : this._emitMoveEvent(i2, s4) : this._onHandleMove(t3, i2, s4, e5, () => this._emitReshapeEvent(t3));
  }
  _onGraphicMoveStopCallback(e5) {
    const { graphic: t3, dx: i2, dy: s4 } = e5;
    this._activeOperationInfo.totalDx += i2, this._activeOperationInfo.totalDy += s4, this._onHandleMove(t3, i2, s4, e5, () => t3 === this.graphic ? this._emitMoveStopEvent() : this._emitReshapeStopEvent(t3)), this._resetSnappingStateVars(), this._activeOperationInfo = null, this._isMidpoint(t3) && this.refresh();
  }
  _updateMidpointGraphicLocations(e5) {
    for (const t3 of this.midpointGraphics) {
      const { pathIndex: i2, pointIndexStart: s4, pointIndexEnd: r2 } = t3.attributes, [o, n3] = e5[i2][s4], [a, h5] = e5[i2][r2], [c, p] = i([o, n3], [a, h5]);
      t3.geometry = new j({ x: c, y: p, spatialReference: this.view.spatialReference });
    }
  }
  _getIndicesForVertexGraphic({ attributes: e5 }) {
    return [(e5 == null ? void 0 : e5.pathIndex) || 0, (e5 == null ? void 0 : e5.pointIndex) || 0];
  }
  _getVertexFromEditGeometry(e5) {
    const [t3, i2] = this._getIndicesForVertexGraphic(e5);
    return this._editGeometryOperations.data.components[t3].vertices[i2];
  }
  _onHandleMove(e5, t3, i2, s4, r2) {
    if (h(this._snappingTask), !this._snappingContext)
      return;
    const o = e5.geometry, n3 = "graphic-move-stop" === s4.type;
    if (r(this.snappingManager) && this.selectedVertices.length < 2 && !n3) {
      const s5 = this.snappingManager;
      this._stagedVertex = s5.update(o, this._snappingContext), this._syncGeometryAfterVertexMove(e5, new j(this._stagedVertex), t3, i2, n3), r2(), this._snappingTask = O(async (a) => {
        const h5 = await s5.snap(o, this._snappingContext, a);
        h5.valid && (this._stagedVertex = h5.apply(), this._syncGeometryAfterVertexMove(e5, new j(this._stagedVertex), t3, i2, n3), r2());
      });
    } else {
      const s5 = r(this._stagedVertex) ? new j(this._stagedVertex) : o;
      this._syncGeometryAfterVertexMove(e5, s5, t3, i2, n3), r2();
    }
  }
  async _syncGeometryAfterVertexMove(e5, t3, i2, s4, r2 = false) {
    const o = this._editGeometryOperations.data.geometry;
    if ("point" === o.type)
      e5.geometry = t3;
    else {
      const { x: n3, y: a } = t3, [h5, c] = this._getIndicesForVertexGraphic(e5);
      let p = t2(o);
      const l3 = p[h5].length - 1;
      p[h5][c] = [n3, a], "polygon" === o.type && (0 === c ? p[h5][l3] = [n3, a] : c === l3 && (p[h5][0] = [n3, a])), this._isVertex(e5) && (p = this._moveRelatedCoordinates(p, e5, n3, a), p = this._moveSelectedHandleCoordinates(p, e5, i2, s4, "polygon" === o.type), this._updateMidpointGraphicLocations(p)), this.graphic.geometry = o.clone();
      const d2 = this._getVertexFromEditGeometry(e5), m3 = n3 - d2.pos[0], v = a - d2.pos[1];
      this._editGeometryOperations.moveVertices([d2], m3, v, 0), r2 && (this._mover ? this._mover.updateGeometry(this._mover.graphics.indexOf(e5), t3) : e5.geometry = t3);
    }
  }
  _moveRelatedCoordinates(e5, t3, i2, s4) {
    const { relatedGraphicIndices: r2 } = t3.attributes;
    for (const o of r2) {
      const r3 = this.vertexGraphics.getItemAt(o), { pathIndex: n3, pointIndex: a } = r3.attributes;
      e5[n3][a] = [i2, s4], r3.geometry = t3.geometry;
    }
    return e5;
  }
  _moveSelectedHandleCoordinates(e5, t3, i2, s4, r2) {
    for (const o of this.selectedVertices)
      if (o !== t3) {
        const { pathIndex: t4, pointIndex: n3, relatedGraphicIndices: a } = o.attributes, h5 = s3(o.geometry, i2, s4, this.view), c = e5[t4].length - 1;
        e5[t4][n3] = [h5.x, h5.y], o.geometry = h5, r2 && (0 === n3 ? e5[t4][c] = [h5.x, h5.y] : n3 === c && (e5[t4][0] = [h5.x, h5.y]));
        for (const i3 of a) {
          const t5 = this.vertexGraphics.getItemAt(i3), { pathIndex: s5, pointIndex: r3 } = t5.attributes;
          e5[s5][r3] = [h5.x, h5.y], t5.geometry = h5;
        }
      }
    return e5;
  }
  _onGraphicPointerOverCallback(e5) {
    const t3 = e5.graphic;
    this._isVertex(t3) && !this._isSelected(t3) && (t3.symbol = this.symbols.vertices.hover), this._updateHoverCursor(t3);
  }
  _onGraphicPointerOutCallback(e5) {
    const t3 = e5.graphic;
    this._isVertex(t3) && !this._isSelected(t3) && (t3.symbol = this.symbols.vertices.default), this.view.cursor = "default";
  }
  _createVertexFromMidpoint(e5) {
    const { _graphicAttributes: t3, graphic: i2 } = this, s4 = i2.geometry;
    if (t(s4) || "polygon" !== s4.type && "polyline" !== s4.type)
      return [];
    const r2 = s4.clone(), o = [], { pathIndex: n3, pointIndexStart: a, pointIndexEnd: c } = e5.attributes, { x: p, y: l3 } = e5.geometry, d2 = 0 === c ? a + 1 : c, m3 = t2(r2);
    return m3[n3].splice(d2, 0, [p, l3]), e5.attributes = { ...t3, pathIndex: n3, pointIndex: d2, relatedGraphicIndices: [] }, o.push({ coordinates: m3[n3][d2], componentIndex: n3, vertexIndex: d2 }), this.graphic.geometry = r2, o;
  }
  _addToSelection(e5) {
    e5 instanceof g && (e5 = [e5]);
    for (const t3 of e5)
      t3.symbol = this.symbols.vertices.selected;
    this._set("selectedVertices", this.selectedVertices.concat(e5)), this._emitSelectEvent(e5);
  }
  _removeFromSelection(e5, i2) {
    const { vertices: s4 } = this.symbols, r2 = i2 ? s4.hover : s4.default;
    e5 instanceof g && (e5 = [e5]);
    for (const t3 of e5)
      this.selectedVertices.splice(this.selectedVertices.indexOf(t3), 1), this._set("selectedVertices", this.selectedVertices), t3.set("symbol", r2);
    this._emitDeselectEvent(e5);
  }
  _clearSelection() {
    if (this.selectedVertices.length) {
      const e5 = this.selectedVertices;
      for (const t3 of this.selectedVertices)
        t3.set("symbol", this.symbols.vertices.default);
      this._set("selectedVertices", []), this._emitDeselectEvent(e5);
    }
  }
  _keyDownHandler(e5) {
    e3.delete.includes(e5.key) && !e5.repeat && this.selectedVertices.length && this._removeVertices(this.selectedVertices);
  }
  _removeVertices(e5) {
    const i2 = this.graphic.geometry;
    if (t(i2) || "polygon" !== i2.type && "polyline" !== i2.type)
      return;
    if ("polygon" === i2.type && this.vertexGraphics.length < 4 || this.vertexGraphics.length < 3)
      return;
    e5 instanceof g && (e5 = [e5]);
    const s4 = this.graphic.clone(), r2 = i2.clone();
    let o = t2(r2);
    const n3 = [];
    e5 instanceof g && (e5 = [e5]);
    for (const t3 of e5) {
      const { x: e6, y: i3 } = t3.geometry;
      for (let t4 = 0; t4 < o.length; t4++) {
        const s5 = o[t4];
        for (let r3 = 0; r3 < s5.length; r3++) {
          const [a, h5] = s5[r3];
          e6 === a && i3 === h5 && (n3.push({ coordinates: o[t4][r3], componentIndex: t4, vertexIndex: r3 }), o[t4].splice(Number(r3), 1));
        }
      }
    }
    if ("polygon" === r2.type)
      o = o.filter((e6) => {
        if (e6.length < 2)
          return false;
        const [t3, i3] = e6[0], [s5, r3] = e6[e6.length - 1];
        return (2 !== e6.length || t3 !== s5 || i3 !== r3) && (t3 === s5 && i3 === r3 || e6.push(e6[0]), true);
      }), r2.rings = o;
    else {
      for (const e6 of o)
        1 === e6.length && o.splice(o.indexOf(e6), 1);
      r2.paths = o;
    }
    this.graphic.geometry = r2, this.refresh(), this._emitVertexRemoveEvent(e5, s4, n3);
  }
  _isVertex(e5) {
    return this.vertexGraphics.includes(e5);
  }
  _isSelected(e5) {
    return this._isVertex(e5) && this.selectedVertices.includes(e5);
  }
  _isMidpoint(e5) {
    return this.midpointGraphics.includes(e5);
  }
  _updateHoverCursor(e5) {
    this.view.cursor = this._isMidpoint(e5) ? "copy" : "move";
  }
  _emitMoveStartEvent(e5, t3) {
    const i2 = new D2(this.graphic, e5, t3);
    this.emit("move-start", i2), this.callbacks.onMoveStart && this.callbacks.onMoveStart(i2);
  }
  _emitMoveEvent(e5, t3) {
    const i2 = new F(this.graphic, e5, t3);
    this.emit("move", i2), this.callbacks.onMove && this.callbacks.onMove(i2);
  }
  _emitMoveStopEvent() {
    const { totalDx: e5, totalDy: t3 } = this._activeOperationInfo, i2 = new z(this.graphic, e5, t3);
    this.emit("move-stop", i2), this.callbacks.onMoveStop && this.callbacks.onMoveStop(i2);
  }
  _emitReshapeStartEvent(e5) {
    const t3 = new A(this.graphic, e5, this.selectedVertices);
    this.emit("reshape-start", t3), this.callbacks.onReshapeStart && this.callbacks.onReshapeStart(t3);
  }
  _emitReshapeEvent(e5) {
    const t3 = new U(this.graphic, e5, this.selectedVertices);
    this.emit("reshape", t3), this.callbacks.onReshape && this.callbacks.onReshape(t3);
  }
  _emitReshapeStopEvent(e5) {
    const t3 = new T(this.graphic, e5, this.selectedVertices);
    this.emit("reshape-stop", t3), this.callbacks.onReshapeStop && this.callbacks.onReshapeStop(t3);
  }
  _emitSelectEvent(e5) {
    const t3 = new L(e5);
    this.emit("select", t3), this.callbacks.onVertexSelect && this.callbacks.onVertexSelect(t3);
  }
  _emitDeselectEvent(e5) {
    const t3 = new P2(e5);
    this.emit("deselect", t3), this.callbacks.onVertexDeselect && this.callbacks.onVertexDeselect(t3);
  }
  _emitVertexAddEvent(e5, t3, i2) {
    const s4 = new K(e5, this.graphic, t3, i2);
    this.emit("vertex-add", s4), this.callbacks.onVertexAdd && this.callbacks.onVertexAdd(s4);
  }
  _emitVertexRemoveEvent(e5, t3, i2) {
    const s4 = new N(e5, this.graphic, t3, i2);
    this.emit("vertex-remove", s4), this.callbacks.onVertexRemove && this.callbacks.onVertexRemove(s4);
  }
  _logGeometryTypeError() {
    Q.error(new s2("reshape:invalid-geometry", "Reshape operation not supported for the provided graphic. The geometry type is not supported."));
  }
};
e([d()], W.prototype, "callbacks", void 0), e([d()], W.prototype, "enableMidpoints", void 0), e([d()], W.prototype, "enableMovement", void 0), e([d()], W.prototype, "enableVertices", void 0), e([d()], W.prototype, "graphic", void 0), e([d({ value: true })], W.prototype, "highlightsEnabled", null), e([d()], W.prototype, "layer", void 0), e([d({ readOnly: true })], W.prototype, "midpointGraphics", void 0), e([d()], W.prototype, "midpointSymbol", void 0), e([d({ readOnly: true })], W.prototype, "selectedVertices", void 0), e([d()], W.prototype, "snappingManager", void 0), e([d({ readOnly: true })], W.prototype, "state", null), e([d({ value: B })], W.prototype, "symbols", null), e([d({ readOnly: true })], W.prototype, "type", void 0), e([d({ readOnly: true })], W.prototype, "vertexGraphics", void 0), e([d()], W.prototype, "view", void 0), W = e([n(J)], W);
var X = W;
export {
  X as default
};
//# sourceMappingURL=Reshape-JQQNUJPH.js.map
