{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/environment/CloudsCompositionParameters.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderModules/TextureCubePassUniform.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{c as t}from\"../../../chunks/mat4f64.js\";import{c as a}from\"../../../chunks/vec3f64.js\";class r{constructor(){this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=a(),this.parallax={anchorPointClouds:a(),cloudsHeight:1e5,radiusCurvatureCorrectionFactor:0,transform:t()},this.parallaxNew={anchorPointClouds:a(),cloudsHeight:1e5,radiusCurvatureCorrectionFactor:0,transform:t()},this.crossFade={enabled:!1,factor:0,distanceThresholdFactor:.3},this.fadeInOut={stage:o.FINISHED,factor:0,distanceThresholdFactor:.6},this.fadeIn={stage:s.FINISHED,factor:0,distanceThresholdFactor:2},this.fadeInOutHeight={stage:e.FINISHED,factor:-1}}}var s,o,e;!function(t){t[t.FINISHED=0]=\"FINISHED\",t[t.CHANGE_ANCHOR=1]=\"CHANGE_ANCHOR\",t[t.FADE_IN=2]=\"FADE_IN\"}(s||(s={})),function(t){t[t.FINISHED=0]=\"FINISHED\",t[t.FADE_OUT=1]=\"FADE_OUT\",t[t.SWITCH=2]=\"SWITCH\",t[t.FADE_IN=3]=\"FADE_IN\"}(o||(o={})),function(t){t[t.FINISHED=0]=\"FINISHED\",t[t.HEIGHT_FADE=1]=\"HEIGHT_FADE\"}(e||(e={}));export{r as CloudsCompositionParameters,e as FadeHeightStages,o as FadeInOutStages,s as FadeInStages};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{Uniform as e}from\"./Uniform.js\";import{BindType as r}from\"../shaderTechnique/BindType.js\";class s extends e{constructor(e,s){super(e,\"samplerCube\",r.Pass,((r,o,t)=>r.bindTexture(e,s(o,t))))}}export{s as TextureCubePassUniform};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{clamp as o}from\"../../../../../../core/mathUtils.js\";import{isSome as t}from\"../../../../../../core/maybe.js\";import{a}from\"../../../../../../chunks/vec2.js\";import{Z as e,a as r}from\"../../../../../../chunks/vec2f64.js\";import{earth as i}from\"../../../../../../geometry/support/Ellipsoid.js\";import{FadeInOutStages as c}from\"../../../../environment/CloudsCompositionParameters.js\";import{BooleanPassUniform as n}from\"../../shaderModules/BooleanPassUniform.js\";import{Float2PassUniform as d}from\"../../shaderModules/Float2PassUniform.js\";import{Float3PassUniform as l}from\"../../shaderModules/Float3PassUniform.js\";import{FloatPassUniform as s}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as u}from\"../../shaderModules/interfaces.js\";import{Matrix4PassUniform as m}from\"../../shaderModules/Matrix4PassUniform.js\";import{TextureCubePassUniform as C}from\"../../shaderModules/TextureCubePassUniform.js\";function v(r){const v=r.fragment;v.uniforms.add([new m(\"rotationMatrixClouds\",((o,t)=>t.clouds.parallax.transform)),new m(\"rotationMatrixCloudsCrossFade\",((o,t)=>t.clouds.parallaxNew.transform)),new l(\"anchorPosition\",((o,t)=>t.clouds.parallax.anchorPointClouds)),new l(\"anchorPositionCrossFade\",((o,t)=>t.clouds.parallaxNew.anchorPointClouds)),new d(\"cloudVariables\",((o,r)=>t(r.clouds.data)?a(h,r.clouds.data.coverage,r.clouds.data.absorption):e)),new s(\"cloudsHeight\",((o,t)=>t.clouds.parallax.cloudsHeight)),new s(\"radiusCurvatureCorrectionFactor\",((o,t)=>t.clouds.parallax.radiusCurvatureCorrectionFactor)),new s(\"totalFadeInOut\",((t,a)=>a.clouds.fadeInOut.stage===c.FINISHED?a.clouds.fadeInOutHeight.factor+Math.max(o(a.clouds.fadeIn.factor,0,1)):a.clouds.fadeInOutHeight.factor+Math.max(o(a.clouds.fadeInOut.factor,0,1)))),new s(\"crossFadeAnchorFactor\",((t,a)=>o(a.clouds.crossFade.factor,0,1))),new C(\"cubeMap\",((o,a)=>t(a.clouds.data)?a.clouds.data.cubeMap.colorTexture:null)),new n(\"crossFade\",((o,t)=>t.clouds.crossFade.enabled))]),v.constants.add(\"planetRadius\",\"float\",i.radius),v.code.add(u`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)\n{\nfloat radiusClouds = planetRadius + cloudsHeight;\nfloat B = 2.0 * dot(cameraPosition, dir);\nfloat C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;\nfloat det = B * B - 4.0 * C;\nfloat pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));\nvec3 intersectionPont = cameraPosition + dir * pointIntDist;\nintersectionPont =  intersectionPont - spherePos;\nreturn intersectionPont;\n}`),v.code.add(u`vec3 correctForPlanetCurvature(vec3 dir)\n{\ndir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;\nreturn dir;\n}`),v.code.add(u`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)\n{\nreturn (rotMat * vec4(inVec, 0.0)).xyz;\n}`),v.uniforms.add([new l(\"lightingMainDirection\",((o,t)=>t.lighting.lightingMainDirection)),new l(\"lightingMainIntensity\",((o,t)=>t.lighting.mainLight.intensity))]),v.code.add(u`const float SUNSET_TRANSITION_FACTOR = 0.3;\nconst vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);\nconst float RIM_SCATTERING_FACTOR = 140.0;\nconst float BACKLIGHT_FACTOR = 0.2;\nconst float BACKLIGHT_SCATTERING_FACTOR = 10.0;\nconst float BACKLIGHT_TRANSITION_FACTOR = 0.3;\nvec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)\n{\nfloat upDotLight = dot(normalize(cameraPosition), normalize(lightingMainDirection));\nfloat dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(lightingMainDirection)), 0.0);\nfloat sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);\nvec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);\nvec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);\nvec3 combinedLight = clamp((lightingMainIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));\nvec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));\nfloat scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);\nfloat rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);\nvec3 directSunScattering = RIM_COLOR * rimLightIntensity * pow(dirDotLight, RIM_SCATTERING_FACTOR) * scatteringMod;\nfloat additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;\nreturn vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);\n}`),v.code.add(u`vec4 getCloudData(vec3 rayDir)\n{\nvec4 cloudData = textureCube(cubeMap, rayDir);\nfloat mu = dot(rayDir, vec3(0, 0, 1));\nreturn mix(vec4(vec3(clamp(1.0 - cloudVariables.y, 0.6, 1.0)), 0.0), cloudData, smoothstep(-0.01, mix(0.0, 0.075, cloudVariables.x), abs(mu)));\n}`),v.code.add(u`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected);\nfloat totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudData.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);\n}`),v.code.add(u`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected);\nvec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\nintersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);\nworldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));\nworldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\ncloudData = getCloudData(worldRayRotatedCorrected);\nvec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\ncloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);\nfloat totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudColor.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(cloudColor.rgb, totalTransmittance);\n}`),v.code.add(u`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)\n{\nreturn crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);\n}`)}const h=r();export{v as CloudsParallaxShading};\n"],
  "mappings": "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",
  "names": ["r", "o", "s", "e", "s", "e", "r", "o", "r", "v", "e", "o", "a", "s", "n"]
}
