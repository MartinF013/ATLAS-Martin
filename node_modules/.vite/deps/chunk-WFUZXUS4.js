import {
  s as s2,
  t
} from "./chunk-OZT6RDST.js";
import {
  B
} from "./chunk-5Z5455ZY.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";

// node_modules/@arcgis/core/layers/graphics/sources/geojson/geojson.js
var r = { LineString: "esriGeometryPolyline", MultiLineString: "esriGeometryPolyline", MultiPoint: "esriGeometryMultipoint", Point: "esriGeometryPoint", Polygon: "esriGeometryPolygon", MultiPolygon: "esriGeometryPolygon" };
function i(e) {
  return r[e];
}
function* s3(e) {
  switch (e.type) {
    case "Feature":
      yield e;
      break;
    case "FeatureCollection":
      for (const t2 of e.features)
        t2 && (yield t2);
  }
}
function* c(e) {
  if (!e)
    return null;
  switch (e.type) {
    case "Point":
      yield e.coordinates;
      break;
    case "LineString":
    case "MultiPoint":
      yield* e.coordinates;
      break;
    case "MultiLineString":
    case "Polygon":
      for (const t2 of e.coordinates)
        yield* t2;
      break;
    case "MultiPolygon":
      for (const t2 of e.coordinates)
        for (const e2 of t2)
          yield* e2;
  }
}
function* u(e, o = {}) {
  const { geometryType: r2, objectIdField: s4 } = o;
  for (const c2 of e) {
    const { geometry: e2, properties: u2, id: l2 } = c2;
    if (e2 && i(e2.type) !== r2)
      continue;
    const f2 = u2 || {};
    let a2 = f2[s4] ?? null;
    s4 && null != l2 && !f2[s4] && (f2[s4] = a2 = l2);
    const y2 = new s2(e2 ? d(new t(), e2, o) : null, f2, null, a2);
    yield y2;
  }
}
function l(e) {
  for (const t2 of e)
    if (t2.length > 2)
      return true;
  return false;
}
function f(e) {
  return !y(e);
}
function a(e) {
  return y(e);
}
function y(e) {
  let t2 = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n], r2 = e[(n + 1) % e.length];
    t2 += o[0] * r2[1] - r2[0] * o[1];
  }
  return t2 <= 0;
}
function p(e) {
  const t2 = e[0], n = e[e.length - 1];
  return t2[0] === n[0] && t2[1] === n[1] && t2[2] === n[2] || e.push(t2), e;
}
function d(e, t2, n) {
  switch (t2.type) {
    case "LineString":
      return g(e, t2, n);
    case "MultiLineString":
      return m(e, t2, n);
    case "MultiPoint":
      return h(e, t2, n);
    case "MultiPolygon":
      return w(e, t2, n);
    case "Point":
      return P(e, t2, n);
    case "Polygon":
      return b(e, t2, n);
  }
}
function g(e, t2, n) {
  return F(e, t2.coordinates, n), e;
}
function m(e, t2, n) {
  for (const o of t2.coordinates)
    F(e, o, n);
  return e;
}
function h(e, t2, n) {
  return F(e, t2.coordinates, n), e;
}
function w(e, t2, n) {
  for (const o of t2.coordinates) {
    j(e, o[0], n);
    for (let t3 = 1; t3 < o.length; t3++)
      S(e, o[t3], n);
  }
  return e;
}
function P(e, t2, n) {
  return M(e, t2.coordinates, n), e;
}
function b(e, t2, n) {
  const o = t2.coordinates;
  j(e, o[0], n);
  for (let r2 = 1; r2 < o.length; r2++)
    S(e, o[r2], n);
  return e;
}
function j(e, t2, n) {
  const o = p(t2);
  f(o) ? G(e, o, n) : F(e, o, n);
}
function S(e, t2, n) {
  const o = p(t2);
  a(o) ? G(e, o, n) : F(e, o, n);
}
function F(e, t2, n) {
  for (const o of t2)
    M(e, o, n);
  e.lengths.push(t2.length);
}
function G(e, t2, n) {
  for (let o = t2.length - 1; o >= 0; o--)
    M(e, t2[o], n);
  e.lengths.push(t2.length);
}
function M(e, t2, n) {
  const [o, r2, i2] = t2;
  e.coords.push(o, r2), n.hasZ && e.coords.push(i2 || 0);
}
function k(e) {
  switch (typeof e) {
    case "string":
      return "esriFieldTypeString";
    case "number":
      return "esriFieldTypeDouble";
    default:
      return "unknown";
  }
}
function O(t2) {
  if (!t2)
    throw new s("geojson-layer:empty", "GeoJSON data is empty");
  if ("Feature" !== t2.type && "FeatureCollection" !== t2.type)
    throw new s("geojson-layer:unsupported-geojson-object", "missing or not supported GeoJSON object type", { data: t2 });
  const { crs: n } = t2;
  if (!n)
    return;
  const o = "string" == typeof n ? n : "name" === n.type ? n.properties.name : "EPSG" === n.type ? n.properties.code : null, r2 = new RegExp(".*(CRS84H?|4326)$", "i");
  if (!o || !r2.test(o))
    throw new s("geojson-layer:unsupported-crs", "unsupported GeoJSON 'crs' member", { crs: n });
}
function T(e, t2 = {}) {
  const n = [], r2 = /* @__PURE__ */ new Set(), u2 = /* @__PURE__ */ new Set();
  let f2, a2 = false, y2 = null, p2 = false, { geometryType: d2 = null } = t2, g2 = false;
  for (const o of s3(e)) {
    const { geometry: e2, properties: t3, id: s4 } = o;
    if (!e2 || (d2 || (d2 = i(e2.type)), i(e2.type) === d2)) {
      if (!a2) {
        a2 = l(c(e2));
      }
      if (p2 || (p2 = null != s4, p2 && (f2 = typeof s4, y2 = Object.keys(t3).filter((e3) => t3[e3] === s4))), p2 && null != s4 && (y2.length > 1 ? y2 = y2.filter((e3) => t3[e3] === s4) : 1 === y2.length && (y2 = t3[y2[0]] === s4 ? y2 : [])), !g2 && t3) {
        let e3 = true;
        for (const o2 in t3) {
          if (r2.has(o2))
            continue;
          const i2 = t3[o2];
          if (null == i2) {
            e3 = false, u2.add(o2);
            continue;
          }
          const s5 = k(i2);
          "unknown" !== s5 ? (u2.delete(o2), r2.add(o2), n.push({ name: o2, alias: o2, type: s5 })) : u2.add(o2);
        }
        g2 = e3;
      }
    }
  }
  const m2 = y2 && 1 === y2.length && y2[0] || null;
  if (m2) {
    for (const i2 of n)
      if (i2.name === m2 && B(i2)) {
        i2.type = "esriFieldTypeOID";
        break;
      }
  }
  return { fields: n, geometryType: d2, hasZ: a2, objectIdFieldName: m2, objectIdFieldType: f2, unknownFields: Array.from(u2) };
}
function L(e, t2) {
  return Array.from(u(s3(e), t2));
}

export {
  i,
  O,
  T,
  L
};
//# sourceMappingURL=chunk-WFUZXUS4.js.map
