import {
  c as c2,
  i as i2,
  l as l4,
  o as o2,
  r as r3
} from "./chunk-YEGLNVAS.js";
import {
  t as t2
} from "./chunk-EYP4YHHR.js";
import {
  f
} from "./chunk-VKEKAYXP.js";
import {
  u as u2
} from "./chunk-6UGZAJSY.js";
import {
  v
} from "./chunk-YZ46FBEM.js";
import {
  o
} from "./chunk-JX3YCNPL.js";
import "./chunk-JERZLQLG.js";
import "./chunk-JWKDNFWF.js";
import "./chunk-ATJYWC6C.js";
import "./chunk-KXE4LGFJ.js";
import "./chunk-SASFTPK5.js";
import "./chunk-436X6OVY.js";
import "./chunk-UJS24K6P.js";
import "./chunk-RB2H3SKO.js";
import "./chunk-UKBGUXUQ.js";
import "./chunk-AKNCAMEF.js";
import "./chunk-UGLXR5OV.js";
import "./chunk-RGZ7VIMW.js";
import {
  I as I2
} from "./chunk-6FQZDXGD.js";
import {
  l as l3
} from "./chunk-57NDR3D3.js";
import {
  a as a2,
  i
} from "./chunk-PNNMRFHO.js";
import "./chunk-4V2P7IXX.js";
import "./chunk-SF7Z6XNR.js";
import "./chunk-YRAX326I.js";
import "./chunk-HH3D3A65.js";
import "./chunk-OA3NMCNZ.js";
import "./chunk-YDPQRKY4.js";
import {
  p
} from "./chunk-BBO6WYBO.js";
import {
  h as h2
} from "./chunk-TH2ECCFL.js";
import {
  l as l2
} from "./chunk-TCBD6DES.js";
import "./chunk-CMKLTW5X.js";
import "./chunk-G2GJVIQC.js";
import {
  a as a3,
  m as m3,
  s as s2
} from "./chunk-5CPRHNFX.js";
import {
  r as r2
} from "./chunk-567AWHAB.js";
import "./chunk-TZD2AXJG.js";
import "./chunk-FZCDFXBT.js";
import "./chunk-KD6KBT2L.js";
import "./chunk-RVR2DEVB.js";
import "./chunk-AS3OSZXK.js";
import {
  c,
  e as e5
} from "./chunk-IYLBVJ6T.js";
import "./chunk-YXFNNKMT.js";
import {
  L
} from "./chunk-YSQDB5AA.js";
import "./chunk-Z7AZMEL6.js";
import "./chunk-FUKESVWQ.js";
import "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-33INAWJA.js";
import {
  I,
  O,
  R
} from "./chunk-FPMD6IB4.js";
import "./chunk-RIOXX6J2.js";
import {
  e as e6
} from "./chunk-MEW2XKT2.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-MV2XZ5BA.js";
import {
  e as e3
} from "./chunk-PQO66WZ2.js";
import "./chunk-3NPGGTI6.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-4P4OV7G6.js";
import "./chunk-ZUDEVIXR.js";
import "./chunk-IG4CY4XM.js";
import "./chunk-HB4HVKJV.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-ZZY5IDKU.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import {
  S
} from "./chunk-HR2OX32D.js";
import {
  e as e4
} from "./chunk-ORGMKDYR.js";
import {
  a,
  m as m2
} from "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  h,
  l
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-RN2KRYDN.js";
import {
  g as g2
} from "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  u
} from "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import {
  n as n2
} from "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  E
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  D,
  g
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  e as e2,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var r4 = 512;
var o3 = 1e-6;
var n3 = (e7, i4) => e7 + 1 / (1 << 2 * i4);
var a4 = class {
  constructor(i4, t5) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e4(40, (e7) => e7.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i4.acquireTile, this.releaseTile = i4.releaseTile, this.tileInfoView = i4.tileInfoView, this._container = t5;
  }
  destroy() {
    for (const [e7, i4] of this._tiles)
      i4.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e7) {
    this._updateCacheSize(e7);
    const i4 = this.tileInfoView, t5 = i4.getTileCoverage(e7.state, 0, "smallest"), { spans: r5, lodInfo: o4 } = t5, { level: n5 } = o4, a5 = this._tiles, c4 = /* @__PURE__ */ new Set(), h4 = /* @__PURE__ */ new Set();
    for (const { row: s3, colFrom: _3, colTo: f3 } of r5)
      for (let e8 = _3; e8 <= f3; e8++) {
        const i5 = e3.getId(n5, s3, o4.normalizeCol(e8), o4.getWorldForColumn(e8)), t6 = this._getOrAcquireTile(i5);
        c4.add(i5), t6.processed() ? this._addToContainer(t6) : h4.add(new e3(i5));
      }
    for (const [s3, l5] of a5)
      l5.isCoverage = c4.has(s3);
    for (const s3 of h4)
      this._findPlaceholdersForMissingTiles(s3, c4);
    let d2 = false;
    for (const [s3, l5] of a5)
      l5.neededForCoverage = c4.has(s3), l5.neededForCoverage || l5.isHoldingForFade && i4.intersects(t5, l5.key) && c4.add(s3), l5.isFading && (d2 = true);
    for (const [s3, l5] of this._tiles)
      c4.has(s3) || this._releaseTile(s3);
    return l2.pool.release(t5), !d2;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  _findPlaceholdersForMissingTiles(e7, i4) {
    const t5 = [];
    for (const [l5, r5] of this._tiles)
      this._addPlaceholderChild(t5, r5, e7, i4);
    const s3 = t5.reduce(n3, 0);
    Math.abs(1 - s3) < o3 || this._addPlaceholderParent(e7.id, i4);
  }
  _addPlaceholderChild(e7, i4, t5, s3) {
    i4.key.level <= t5.level || !i4.hasData() || h3(t5, i4.key) && (this._addToContainer(i4), s3.add(i4.id), e7.push(i4.key.level - t5.level));
  }
  _addPlaceholderParent(e7, i4) {
    const t5 = this._tiles;
    let s3 = e7;
    for (; ; ) {
      if (s3 = c3(s3), !s3 || i4.has(s3))
        return;
      const e8 = t5.get(s3);
      if (e8 && e8.hasData())
        return this._addToContainer(e8), void i4.add(e8.id);
    }
  }
  _getOrAcquireTile(e7) {
    let i4 = this._tiles.get(e7);
    return i4 || (i4 = this._tileCache.pop(e7), i4 || (i4 = this.acquireTile(new e3(e7))), this._tiles.set(e7, i4), i4);
  }
  _releaseTile(e7) {
    const i4 = this._tiles.get(e7);
    this.releaseTile(i4), this._removeFromContainer(i4), this._tiles.delete(e7), i4.hasData() ? this._tileCache.put(e7, i4, 1) : i4.dispose();
  }
  _addToContainer(e7) {
    let s3;
    const l5 = [], r5 = this._container;
    if (r5.contains(e7))
      return;
    const o4 = this._visibleTiles;
    for (const [t5, n5] of o4)
      this._canConnectDirectly(e7, n5) && l5.push(n5), t(s3) && this._canConnectDirectly(n5, e7) && (s3 = n5);
    if (r(s3)) {
      for (const i4 of l5)
        s3.childrenTiles.delete(i4), e7.childrenTiles.add(i4), i4.parentTile = e7;
      s3.childrenTiles.add(e7), e7.parentTile = s3;
    } else
      for (const i4 of l5)
        e7.childrenTiles.add(i4), i4.parentTile = e7;
    o4.set(e7.id, e7), r5.addChild(e7);
  }
  _removeFromContainer(e7) {
    if (this._visibleTiles.delete(e7.id), this._container.removeChild(e7), r(e7.parentTile)) {
      e7.parentTile.childrenTiles.delete(e7);
      for (const i4 of e7.childrenTiles)
        r(e7.parentTile) && e7.parentTile.childrenTiles.add(i4);
    }
    for (const i4 of e7.childrenTiles)
      i4.parentTile = e7.parentTile;
    e7.parentTile = null, e7.childrenTiles.clear();
  }
  _canConnectDirectly(e7, i4) {
    const t5 = e7.key;
    let { level: s3, row: l5, col: r5, world: o4 } = i4.key;
    const n5 = this._visibleTiles;
    for (; s3 > 0; ) {
      if (s3--, l5 >>= 1, r5 >>= 1, t5.level === s3 && t5.row === l5 && t5.col === r5 && t5.world === o4)
        return true;
      if (n5.has(`${s3}/${l5}/${r5}/${o4}`))
        return false;
    }
    return false;
  }
  _updateCacheSize(e7) {
    const i4 = e7.state.size;
    if (i4[0] === this._viewSize[0] && i4[1] === this._viewSize[1])
      return;
    const t5 = Math.ceil(i4[0] / r4) + 1, s3 = Math.ceil(i4[1] / r4) + 1;
    this._viewSize[0] = i4[0], this._viewSize[1] = i4[1], this._tileCache.maxSize = 5 * t5 * s3;
  }
};
function c3(e7) {
  const [i4, t5, s3, l5] = e7.split("/"), r5 = parseInt(i4, 10);
  return 0 === r5 ? null : `${r5 - 1}/${parseInt(t5, 10) >> 1}/${parseInt(s3, 10) >> 1}/${parseInt(l5, 10)}`;
}
function h3(e7, i4) {
  const t5 = i4.level - e7.level;
  return e7.row === i4.row >> t5 && e7.col === i4.col >> t5 && e7.world === i4.world;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var n4 = 0.5;
var _ = 1e-6;
var m4 = class extends n2 {
  constructor(t5, e7) {
    super(), this.styleRepository = t5, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._completed = false, this._symbolRepository = new r3(4096, e7, () => new s2()), this._symbolDeclutterer = new i2(e7, this._symbolRepository, (t6, e8, i4) => new l4(t6, e8, i4, this.styleRepository, this._zoom, this._viewState.rotation), (t6, e8) => {
      t6.allSymbolsFadingOut = true, t6.lastOpacityUpdate = e8, a3(t6, e8, true), t6.decluttered = true, t6.requestRender();
    }, (t6, e8) => this.styleRepository.getStyleLayerByUID(t6.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e8.styleLayerUID).z, (t6) => {
      const e8 = this.styleRepository.getStyleLayerByUID(t6);
      if (this._zoom + _ < e8.minzoom || this._zoom - _ >= e8.maxzoom)
        return false;
      const i4 = e8.getLayoutProperty("visibility");
      return !i4 || i4.getValue() !== i.NONE;
    });
  }
  addTile(t5) {
    t5.decluttered = false, this._tileToHandle.set(t5, t5.on("symbols-changed", () => {
      this._symbolRepository.add(t5), this.restartDeclutter();
    })), this._symbolRepository.add(t5), this.restartDeclutter();
  }
  removeTile(t5) {
    const e7 = this._tileToHandle.get(t5);
    e7 && (this._symbolRepository.removeTile(t5), this.restartDeclutter(), e7.remove(), this._tileToHandle.delete(t5));
  }
  update(t5, e7) {
    return this._zoom = t5, this._viewState = { scale: e7.scale, rotation: e7.rotation, center: [e7.center[0], e7.center[1]], size: [e7.size[0], e7.size[1]] }, this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t5) => t5.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t5) {
    this._symbolRepository.deleteStyleLayers(t5);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    r(this._stableNotificationHandle) && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this.emit("fade-complete");
    }, (1 + n4) * e5);
  }
  _notifyUnstable() {
    r(this._stableNotificationHandle) && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this.emit("fade-start");
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t3 = class extends r2 {
  _createTransforms() {
    return { dvs: e6(), tileMat3: e6() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var _2 = 1e-6;
function f2(e7, t5) {
  if (e7) {
    const s3 = e7.getLayoutProperty("visibility");
    if (!s3 || s3.getValue() !== i.NONE && (void 0 === e7.minzoom || e7.minzoom < t5 + _2) && (void 0 === e7.maxzoom || e7.maxzoom >= t5 - _2))
      return true;
  }
  return false;
}
var b = class extends o {
  constructor(e7) {
    super(e7), this._backgroundTiles = [], this._pointToCallbacks = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.removeAllChildren(), this._spriteMosaic && (this._spriteMosaic.dispose(), this._spriteMosaic = null), this._glyphMosaic && (this._glyphMosaic.dispose(), this._glyphMosaic = null), r(this._symbolFader) && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [], this._pointToCallbacks.clear();
  }
  setStyleResources(e7, r5, i4) {
    if (this._spriteMosaic = e7, this._glyphMosaic = r5, this._styleRepository = i4, t(this._symbolFader)) {
      const e8 = new m4(this._styleRepository, this.children);
      e8.on("fade-start", () => {
        this.emit("fade-start"), this.requestRender();
      }), e8.on("fade-complete", () => {
        this.emit("fade-complete"), this.requestRender();
      }), this._symbolFader = e8;
    }
    e2(this._symbolFader).styleRepository = i4;
  }
  setSpriteMosaic(e7) {
    this._spriteMosaic.dispose(), this._spriteMosaic = e7;
  }
  deleteStyleLayers(t5) {
    r(this._symbolFader) && this._symbolFader.deleteStyleLayers(t5);
  }
  async hitTest(e7) {
    const t5 = D();
    return this._pointToCallbacks.set(e7, t5), this.requestRender(), t5.promise;
  }
  enterTileInvalidation() {
    for (const e7 of this.children)
      e7.invalidating = true;
  }
  createRenderParams(e7) {
    return { ...super.createRenderParams(e7), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e7) {
    !this.visible || e7.drawPhase !== I2.MAP && e7.drawPhase !== I2.DEBUG || void 0 === this._spriteMosaic || super.doRender(e7);
  }
  addChild(t5) {
    return super.addChild(t5), r(this._symbolFader) ? this._symbolFader.addTile(t5) : t5.decluttered = true, this.requestRender(), t5;
  }
  removeChild(t5) {
    return r(this._symbolFader) && this._symbolFader.removeTile(t5), this.requestRender(), super.removeChild(t5);
  }
  renderChildren(e7) {
    const { drawPhase: t5 } = e7;
    if (t5 !== I2.DEBUG) {
      if (this._doRender(e7), this._pointToCallbacks.size > 0) {
        e7.drawPhase = I2.HITTEST;
        const s3 = e7.painter.effects.hittestVTL;
        s3.bind(e7), this._doRender(e7), s3.draw(e7, this._pointToCallbacks), s3.unbind(e7), e7.drawPhase = t5;
      }
    } else
      super.renderChildren(e7);
  }
  removeAllChildren() {
    for (let t5 = 0; t5 < this.children.length; t5++) {
      const s3 = this.children[t5];
      r(this._symbolFader) && this._symbolFader.removeTile(s3), s3.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e7) => e7.neededForCoverage && e7.hasData());
  }
  restartDeclutter() {
    r(this._symbolFader) && this._symbolFader.restartDeclutter();
  }
  _doRender(e7) {
    const { context: t5 } = e7, s3 = this._styleRepository;
    if (!s3)
      return;
    const r5 = s3.layers;
    let i4 = true;
    e7.drawPhase === I2.HITTEST && (i4 = false), s3.backgroundBucketIds.length > 0 && (e7.renderPass = "background", this._renderBackgroundLayers(e7, s3.backgroundBucketIds)), super.renderChildren(e7), e7.drawPhase === I2.MAP && this._fade(e7.displayLevel, e7.state);
    const o4 = this.children.filter((e8) => e8.visible && e8.hasData());
    if (!o4 || 0 === o4.length)
      return t5.bindVAO(), t5.setStencilTestEnabled(true), void t5.setBlendingEnabled(true);
    for (const l5 of o4)
      l5.triangleCount = 0;
    t5.setStencilWriteMask(0), t5.setColorMask(true, true, true, true), t5.setStencilOp(O.KEEP, O.KEEP, O.REPLACE), t5.setStencilTestEnabled(true), t5.setBlendingEnabled(false), t5.setDepthTestEnabled(true), t5.setDepthWriteEnabled(true), t5.setDepthFunction(I.LEQUAL), t5.setClearDepth(1), t5.clear(t5.gl.DEPTH_BUFFER_BIT), e7.renderPass = "opaque";
    for (let l5 = r5.length - 1; l5 >= 0; l5--)
      this._renderStyleLayer(r5[l5], e7, o4);
    t5.setDepthWriteEnabled(false), t5.setBlendingEnabled(i4), t5.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e7.renderPass = "translucent";
    for (let l5 = 0; l5 < r5.length; l5++)
      this._renderStyleLayer(r5[l5], e7, o4);
    t5.setDepthTestEnabled(false), e7.renderPass = "symbol";
    for (let l5 = 0; l5 < r5.length; l5++)
      this._renderStyleLayer(r5[l5], e7, o4);
    t5.bindVAO(), t5.setStencilTestEnabled(true), t5.setBlendingEnabled(true);
  }
  _fade(t5, s3) {
    r(this._symbolFader) && (this._symbolFader.update(t5, s3) || this.requestRender());
  }
  _renderStyleLayer(e7, t5, s3) {
    const { painter: r5, renderPass: i4 } = t5;
    if (void 0 === e7)
      return;
    const o4 = e7.getLayoutProperty("visibility");
    if (o4 && o4.getValue() === i.NONE)
      return;
    let a5;
    switch (e7.type) {
      case a2.BACKGROUND:
        return;
      case a2.FILL:
        if ("opaque" !== i4 && "translucent" !== t5.renderPass)
          return;
        a5 = "vtlFill";
        break;
      case a2.LINE:
        if ("translucent" !== i4)
          return;
        a5 = "vtlLine";
        break;
      case a2.CIRCLE:
        if ("symbol" !== i4)
          return;
        a5 = "vtlCircle";
        break;
      case a2.SYMBOL:
        if ("symbol" !== i4)
          return;
        a5 = "vtlSymbol";
    }
    if (s3 = e7.type === a2.SYMBOL ? s3.filter((e8) => e8.decluttered) : s3.filter((e8) => e8.neededForCoverage), "vtlSymbol" !== a5) {
      const r6 = t5.displayLevel;
      if (0 === s3.length || void 0 !== e7.minzoom && e7.minzoom >= r6 + _2 || void 0 !== e7.maxzoom && e7.maxzoom < r6 - _2)
        return;
    }
    const d2 = e7.uid;
    t5.styleLayerUID = d2, t5.styleLayer = e7;
    for (const l5 of s3)
      if (l5.layerData.has(d2)) {
        r5.renderObjects(t5, s3, a5);
        break;
      }
  }
  _renderBackgroundLayers(t5, s3) {
    const { context: r5, displayLevel: o4, painter: l5, state: h4 } = t5, u3 = this._styleRepository;
    let _3 = false;
    for (const e7 of s3) {
      if (u3.getLayerById(e7).type === a2.BACKGROUND && f2(u3.getLayerById(e7), o4)) {
        _3 = true;
        break;
      }
    }
    if (!_3)
      return;
    const b3 = this._tileInfoView.getTileCoverage(t5.state, 0, "smallest"), { spans: g3, lodInfo: T } = b3, { level: E2 } = T, C = u(), L3 = [];
    if (this._renderPasses) {
      const s4 = this._renderPasses[0];
      r(this._clippingInfos) && (s4.brushes[0].prepareState(t5, this._clippingInfos[0]), s4.brushes[0].drawMany(t5, this._clippingInfos));
    }
    const v2 = this._backgroundTiles;
    let S2, P = 0;
    for (const { row: e7, colFrom: n5, colTo: a5 } of g3)
      for (let t6 = n5; t6 <= a5; t6++) {
        if (P < v2.length)
          S2 = v2[P], S2.key.set(E2, e7, T.normalizeCol(t6), T.getWorldForColumn(t6)), this._tileInfoView.getTileBounds(C, S2.key, false), S2.x = C[0], S2.y = C[3];
        else {
          const s4 = new e3(E2, e7, T.normalizeCol(t6), T.getWorldForColumn(t6)), r6 = this._tileInfoView.getTileBounds(u(), s4);
          S2 = new t3(s4, r6[0], r6[3], 512, 512, 4096, 4096), v2.push(S2);
        }
        S2.setTransform(h4, this._tileInfoView.getTileResolution(S2.key)), L3.push(S2), P++;
      }
    r5.setStencilWriteMask(0), r5.setColorMask(true, true, true, true), r5.setStencilOp(O.KEEP, O.KEEP, O.REPLACE), r5.setStencilFunction(I.EQUAL, 0, 255);
    let R2 = true;
    t5.drawPhase === I2.HITTEST && (R2 = false), r5.setStencilTestEnabled(R2);
    for (const e7 of s3) {
      const s4 = u3.getLayerById(e7);
      s4.type === a2.BACKGROUND && f2(s4, o4) && (t5.styleLayerUID = s4.uid, t5.styleLayer = s4, l5.renderObjects(t5, L3, "vtlBackground"));
    }
    l2.pool.release(b3);
  }
};

// node_modules/@arcgis/core/views/2d/layers/support/Display.js
var i3 = class extends t2 {
  constructor(e7) {
    super(), this.requestRender = this.requestRender.bind(this), this._layerView = e7, this._canvas = document.createElement("canvas"), this._context = this._canvas.getContext("2d"), this._bitmap = new v(null, "standard", false), this.addChild(this._bitmap);
  }
  doRender(t5) {
    const e7 = t5.state, i4 = this._createCustomRenderParams(t5), a5 = this._canvas, s3 = this._bitmap, n5 = window.devicePixelRatio;
    a5.width = e7.size[0] * n5, a5.height = e7.size[1] * n5, s3.resolution = e7.resolution;
    const o4 = e7.clone();
    o4.pixelRatio = n5, s3.pixelRatio = n5, i4.state = o4, s3.x = e7.viewpoint.targetGeometry.x - Math.abs(e7.extent.xmax - e7.extent.xmin) / 2, s3.y = e7.viewpoint.targetGeometry.y + Math.abs(e7.extent.ymax - e7.extent.ymin) / 2, this._layerView.render(i4), s3.source = a5, s3.rotation = e7.rotation, super.doRender({ ...t5, state: o4 });
  }
  _createCustomRenderParams(t5) {
    return { globalOpacity: t5.globalOpacity, state: t5.state, stationary: t5.stationary, pixelRatio: window.devicePixelRatio, context: this._context };
  }
};

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t4 = class extends h2 {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e7) {
    const l5 = e3.pool.acquire(e7), t5 = 0 === l5.level ? null : e3.getId(l5.level - 1, l5.row >> 1, l5.col >> 1, l5.world);
    return e3.pool.release(l5), t5;
  }
  getTileCoverage(e7, l5, s3) {
    const t5 = super.getTileCoverage(e7, l5, s3);
    if (!t5)
      return t5;
    const o4 = 1 << t5.lodInfo.level;
    return t5.spans = t5.spans.filter((e8) => e8.row >= 0 && e8.row < o4), t5;
  }
  scaleToLevel(e7) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e7])
      return this._levelByScale[e7];
    {
      const l5 = this._fullCacheLodInfos;
      if (e7 > l5[0].scale)
        return l5[0].level;
      let s3, t5;
      for (let o4 = 0; o4 < l5.length - 1; o4++)
        if (t5 = l5[o4 + 1], e7 > t5.scale)
          return s3 = l5[o4], s3.level + (s3.scale - e7) / (s3.scale - t5.scale);
      return l5[l5.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l5) {
    let s3;
    if (0 === l5[0].level)
      s3 = l5.map((e7) => ({ level: e7.level, resolution: e7.resolution, scale: e7.scale }));
    else {
      const l6 = this.tileInfo.size[0], t5 = this.tileInfo.spatialReference;
      s3 = S.create({ size: l6, spatialReference: t5 }).lods.map((e7) => ({ level: e7.level, resolution: e7.resolution, scale: e7.scale }));
    }
    for (let e7 = 0; e7 < s3.length; e7++)
      this._levelByScale[s3[e7].scale] = s3[e7].level;
    this._fullCacheLodInfos = s3;
  }
};

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var Q = s.getLogger("esri.views.2d.layers.VectorTileLayerView2D");
var L2 = class extends f(u2) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._isTileHandlerReady = false, this.fading = false;
  }
  async hitTest(e7, i4) {
    if (!this._tileHandlerPromise)
      return null;
    await this._tileHandlerPromise;
    const s3 = await this._vectorTileContainer.hitTest(i4);
    if (!s3 || 0 === s3.length)
      return null;
    const r5 = s3[0] - 1, a5 = this._styleRepository, l5 = a5.getStyleLayerByUID(r5);
    if (!l5)
      return null;
    const n5 = a5.getStyleLayerIndex(l5.id);
    return [{ type: "graphic", mapPoint: e7, layer: this.layer, graphic: new g2({ attributes: { layerId: n5, layerName: l5.id, layerUID: r5 }, layer: this.layer, sourceLayer: this.layer }) }];
  }
  update(e7) {
    if (this._tileHandlerPromise && this._isTileHandlerReady)
      return e7.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e7.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.state = e7.state, this._parseQueue.state = e7.state, this._tileManager.update(e7) || this.requestUpdate(), this._parseQueue.resume(), this._fetchQueue.resume()));
  }
  attach() {
    const { style: e7 } = this.layer.currentStyleInfo;
    this._styleRepository = new l3(e7), this._tileInfoView = new t4(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new b(this._tileInfoView), this._tileHandler = new c2(this.layer, this._styleRepository, window.devicePixelRatio || 1), this.container.addChild(this._vectorTileContainer), this._start(), this.handles.add([this._vectorTileContainer.on("fade-start", () => {
      this.fading = true, this.notifyChange("updating"), this.requestUpdate();
    }), this._vectorTileContainer.on("fade-complete", () => {
      var _a;
      (_a = this._collisionBoxesDisplay) == null ? void 0 : _a.requestRender(), this.fading = false, this.notifyChange("updating"), this.requestUpdate();
    }), l(() => this.layer.symbolCollisionBoxesVisible, (e8) => {
      e8 ? (this._collisionBoxesDisplay = new i3({ render: (e9) => this._renderCollisionBoxes(e9.context) }), this.container.addChild(this._collisionBoxesDisplay)) : (this.container.removeChild(this._collisionBoxesDisplay), this._collisionBoxesDisplay = null);
    }, h), this.layer.on("paint-change", (e8) => {
      if (e8.isDataDriven)
        this._styleChanges.push({ type: L.PAINTER_CHANGED, data: e8 }), this.notifyChange("updating"), this.requestUpdate();
      else {
        const t5 = this._styleRepository, i4 = t5.getLayerById(e8.layer);
        if (!i4)
          return;
        const s3 = i4.type === a2.SYMBOL;
        t5.setPaintProperties(e8.layer, e8.paint), s3 && this._vectorTileContainer.restartDeclutter(), this._vectorTileContainer.requestRender();
      }
    }), this.layer.on("layout-change", (e8) => {
      const t5 = this._styleRepository, i4 = t5.getLayerById(e8.layer);
      if (!i4)
        return;
      const s3 = m2(i4.layout, e8.layout);
      if (!t(s3)) {
        if (a(s3, "visibility") && 1 === b2(s3))
          return t5.setLayoutProperties(e8.layer, e8.layout), i4.type === a2.SYMBOL && this._vectorTileContainer.restartDeclutter(), void this._vectorTileContainer.requestRender();
        this._styleChanges.push({ type: L.LAYOUT_CHANGED, data: e8 }), this.notifyChange("updating"), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e8) => {
      const t5 = this._styleRepository, i4 = t5.getLayerById(e8.layer);
      i4 && (t5.setStyleLayerVisibility(e8.layer, e8.visibility), i4.type === a2.SYMBOL && this._vectorTileContainer.restartDeclutter(), this._vectorTileContainer.requestRender());
    }), this.layer.on("style-layer-change", (e8) => {
      this._styleChanges.push({ type: L.LAYER_CHANGED, data: e8 }), this.notifyChange("updating"), this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e8) => {
      this._styleChanges.push({ type: L.LAYER_REMOVED, data: e8 }), this.notifyChange("updating"), this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e8) => {
      this._newSpriteSource = e8.spriteSource, this._styleChanges.push({ type: L.SPRITES_CHANGED, data: null });
      const t5 = this._styleRepository.layers;
      for (const i4 of t5)
        switch (i4.type) {
          case a2.SYMBOL:
            i4.getLayoutProperty("icon-image") && this._styleChanges.push({ type: L.LAYOUT_CHANGED, data: { layer: i4.id, layout: i4.layout } });
            break;
          case a2.LINE:
            i4.getPaintProperty("line-pattern") && this._styleChanges.push({ type: L.PAINTER_CHANGED, data: { layer: i4.id, paint: i4.paint, isDataDriven: i4.isPainterDataDriven() } });
            break;
          case a2.FILL:
            i4.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: L.PAINTER_CHANGED, data: { layer: i4.id, paint: i4.paint, isDataDriven: i4.isPainterDataDriven() } });
        }
      this.notifyChange("updating"), this.requestUpdate();
    })], this.declaredClass);
  }
  detach() {
    var _a, _b;
    this._stop(), this.container.removeAllChildren(), (_a = this._vectorTileContainer) == null ? void 0 : _a.destroy(), this._vectorTileContainer = null, (_b = this._tileHandler) == null ? void 0 : _b.destroy(), this._tileHandler = null, this.handles.remove(this.declaredClass);
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this._collisionBoxesDisplay && this._vectorTileContainer.restartDeclutter(), this.requestUpdate();
  }
  supportsSpatialReference(e7) {
    var _a;
    return E((_a = this.layer.tileInfo) == null ? void 0 : _a.spatialReference, e7);
  }
  canResume() {
    let e7 = super.canResume();
    const { currentStyleInfo: t5 } = this.layer;
    if (e7 && (t5 == null ? void 0 : t5.layerDefinition)) {
      const i4 = this.view.scale, { minScale: s3, maxScale: r5 } = t5.layerDefinition;
      t5 && t5.layerDefinition && (s3 && s3 < i4 && (e7 = false), r5 && r5 > i4 && (e7 = false));
    }
    return e7;
  }
  isUpdating() {
    const e7 = this._vectorTileContainer.children;
    return !this._isTileHandlerReady || !this._fetchQueue || !this._parseQueue || this._fetchQueue.updating || this._parseQueue.updating || e7.length > 0 && e7.some((e8) => e8.invalidating) || this.fading;
  }
  acquireTile(e7) {
    const t5 = this._createVectorTile(e7);
    return this._tileHandlerPromise.then(() => {
      this._fetchQueue.push(t5.key).then((e8) => this._parseQueue.push({ key: t5.key, data: e8 })).then((e8) => {
        t5.once("attach", () => this.requestUpdate()), t5.setData(e8), this.requestUpdate(), this.notifyChange("updating");
      }).catch((e8) => {
        this.notifyChange("updating"), g(e8) || Q.error(e8);
      });
    }), t5;
  }
  releaseTile(e7) {
    const t5 = e7.key.id;
    this._fetchQueue.abort(t5), this._parseQueue.abort(t5), this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new a4({ acquireTile: (e8) => this.acquireTile(e8), releaseTile: (e8) => this.releaseTile(e8), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo)
      return;
    const e7 = new AbortController(), t5 = this._tileHandler.start({ signal: e7.signal }).then(() => {
      this._fetchQueue = new p({ tileInfoView: this._tileInfoView, process: (e8, t6) => this._getTileData(e8, t6), concurrency: 15 }), this._parseQueue = new p({ tileInfoView: this._tileInfoView, process: (e8, t6) => this._parseTileData(e8, t6), concurrency: 8 }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e8) => {
      this._vectorTileContainer.setStyleResources(e8, this._tileHandler.glyphMosaic, this._styleRepository), this.requestUpdate();
    }), this._tileHandlerAbortController = e7, this._tileHandlerPromise = t5;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer)
      return;
    const e7 = this._tileHandlerAbortController;
    e7 && e7.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue && (this._fetchQueue.destroy(), this._fetchQueue = null), this._parseQueue && (this._parseQueue.destroy(), this._parseQueue = null), this._tileManager && (this._tileManager.destroy(), this._tileManager = null), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e7, t5) {
    const i4 = await this._tileHandler.fetchTileData(e7, t5);
    return this.notifyChange("updating"), i4;
  }
  async _parseTileData(e7, t5) {
    return this._tileHandler.parseTileData(e7, t5);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._tileManager.clearCache();
    const e7 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e7);
    } catch (l5) {
      Q.error("error applying vector-tiles style update", l5.message), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true;
    }
    const t5 = this._styleRepository, i4 = [];
    e7.forEach((e8) => {
      if (e8.type !== L.LAYER_REMOVED)
        return;
      const s4 = e8.data, r6 = t5.getLayerById(s4.layer);
      r6 && i4.push(r6.uid);
    });
    const s3 = [];
    let r5;
    e7.forEach((e8) => {
      const i5 = e8.type, a6 = e8.data;
      switch (i5) {
        case L.PAINTER_CHANGED:
          t5.setPaintProperties(a6.layer, a6.paint), r5 = a6.layer;
          break;
        case L.LAYOUT_CHANGED:
          t5.setLayoutProperties(a6.layer, a6.layout), r5 = a6.layer;
          break;
        case L.LAYER_REMOVED:
          return void t5.deleteStyleLayer(a6.layer);
        case L.LAYER_CHANGED:
          t5.setStyleLayer(a6.layer, a6.index), r5 = a6.layer.id;
          break;
        case L.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(this._newSpriteSource)), this._newSpriteSource = null, r5 = null;
      }
      const l5 = t5.getLayerById(r5);
      l5 && s3.push(l5.uid);
    });
    const a5 = this._vectorTileContainer.children;
    if (i4.length > 0) {
      this._vectorTileContainer.deleteStyleLayers(i4);
      for (const e8 of a5)
        e8.deleteLayerData(i4);
    }
    if (this._fetchQueue.resume(), this._parseQueue.resume(), s3.length > 0) {
      const e8 = [];
      for (const t6 of a5) {
        const i5 = this._fetchQueue.push(t6.key).then((e9) => this._parseQueue.push({ key: t6.key, data: e9, styleLayerUIDs: s3 })).then((e9) => t6.setData(e9));
        e8.push(i5);
      }
      await Promise.all(e8);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.notifyChange("updating"), this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e7 } = this.layer.currentStyleInfo, t5 = m(e7);
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this.notifyChange("updating"), this._styleRepository = new l3(t5), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s3 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, t5), await this._tileHandlerPromise;
    } catch (l5) {
      if (!g(l5))
        throw l5;
    }
    if (s3.aborted)
      return this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.notifyChange("updating"), void this.requestUpdate();
    const r5 = await this._tileHandler.spriteMosaic;
    this._vectorTileContainer.setStyleResources(r5, this._tileHandler.glyphMosaic, this._styleRepository), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.notifyChange("updating"), this.requestUpdate();
  }
  _createVectorTile(e7) {
    const t5 = this._tileInfoView.getTileBounds(u(), e7);
    return new m3(e7, t5[0], t5[3], 512, 512, this._styleRepository);
  }
  _renderCollisionBoxes(e7) {
    for (const t5 of this._vectorTileContainer.children)
      if (t5.symbols) {
        const i4 = [];
        for (const [e8, s3] of t5.symbols)
          i4.push(...s3);
        o2(e7, i4);
      }
  }
};
function b2(e7) {
  if (t(e7))
    return 0;
  switch (e7.type) {
    case "partial":
      return Object.keys(e7.diff).length;
    case "complete":
      return Math.max(Object.keys(e7.oldValue).length, Object.keys(e7.newValue).length);
    case "collection":
      return Object.keys(e7.added).length + Object.keys(e7.changed).length + Object.keys(e7.removed).length;
  }
}
e([d()], L2.prototype, "_fetchQueue", void 0), e([d()], L2.prototype, "_parseQueue", void 0), e([d()], L2.prototype, "_isTileHandlerReady", void 0), e([d()], L2.prototype, "fading", void 0), L2 = e([n("esri.views.2d.layers.VectorTileLayerView2D")], L2);
var I3 = L2;
export {
  I3 as default
};
//# sourceMappingURL=VectorTileLayerView2D-NT37AQ3U.js.map
