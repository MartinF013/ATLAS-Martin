import {
  t
} from "./chunk-ZWMYDR2G.js";
import {
  L
} from "./chunk-4I3W4KD5.js";
import {
  r as r2
} from "./chunk-S4ZKPFDU.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  G,
  j
} from "./chunk-5N3FSR63.js";
import {
  v
} from "./chunk-4PRVTUEZ.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/rest/operations/urlUtils.js
function t2(n) {
  const o = {};
  for (const e in n) {
    if ("declaredClass" === e)
      continue;
    const r3 = n[e];
    if (null != r3 && "function" != typeof r3)
      if (Array.isArray(r3)) {
        o[e] = [];
        for (let n2 = 0; n2 < r3.length; n2++)
          o[e][n2] = t2(r3[n2]);
      } else
        "object" == typeof r3 ? r3.toJSON && (o[e] = JSON.stringify(r3)) : o[e] = r3;
  }
  return o;
}

// node_modules/@arcgis/core/rest/query/operations/query.js
var l = "Layer does not support extent calculation.";
function m(e, t3) {
  if (t3 && "extent" === e.type)
    return `${e.xmin},${e.ymin},${e.xmax},${e.ymax}`;
  if (t3 && "point" === e.type)
    return `${e.x},${e.y}`;
  const r3 = e.toJSON();
  return delete r3.spatialReference, JSON.stringify(r3);
}
function y(e, r3) {
  const n = e.geometry, o = e.toJSON();
  delete o.compactGeometryEnabled, delete o.defaultSpatialReferenceEnabled;
  const a = o;
  let s, u, l2;
  if (r(n) && (u = n.spatialReference, l2 = n.spatialReference.wkid || JSON.stringify(n.spatialReference), a.geometryType = v(n), a.geometry = m(n, e.compactGeometryEnabled), a.inSR = l2), o.groupByFieldsForStatistics && (a.groupByFieldsForStatistics = o.groupByFieldsForStatistics.join(",")), o.objectIds && (a.objectIds = o.objectIds.join(",")), o.orderByFields && (a.orderByFields = o.orderByFields.join(",")), !o.outFields || !o.returnDistinctValues && ((r3 == null ? void 0 : r3.returnCountOnly) || (r3 == null ? void 0 : r3.returnExtentOnly) || (r3 == null ? void 0 : r3.returnIdsOnly)) ? delete a.outFields : o.outFields.includes("*") ? a.outFields = "*" : a.outFields = o.outFields.join(","), o.outSR ? (a.outSR = o.outSR.wkid || JSON.stringify(o.outSR), s = e.outSpatialReference) : n && (o.returnGeometry || o.returnCentroid) && (a.outSR = a.inSR, s = u), o.returnGeometry && delete o.returnGeometry, o.outStatistics && (a.outStatistics = JSON.stringify(o.outStatistics)), o.pixelSize && (a.pixelSize = JSON.stringify(o.pixelSize)), o.quantizationParameters && (e.defaultSpatialReferenceEnabled && r(u) && r(e.quantizationParameters) && r(e.quantizationParameters.extent) && u.equals(e.quantizationParameters.extent.spatialReference) && delete o.quantizationParameters.extent.spatialReference, a.quantizationParameters = JSON.stringify(o.quantizationParameters)), o.parameterValues && (a.parameterValues = JSON.stringify(o.parameterValues)), o.rangeValues && (a.rangeValues = JSON.stringify(o.rangeValues)), o.dynamicDataSource && (a.layer = JSON.stringify({ source: o.dynamicDataSource }), delete o.dynamicDataSource), o.timeExtent) {
    const e2 = o.timeExtent, { start: t3, end: r4 } = e2;
    null == t3 && null == r4 || (a.time = t3 === r4 ? t3 : `${null == t3 ? "null" : t3},${null == r4 ? "null" : r4}`), delete o.timeExtent;
  }
  return e.defaultSpatialReferenceEnabled && r(u) && r(s) && u.equals(s) && (a.defaultSR = a.inSR, delete a.inSR, delete a.outSR), a;
}
async function c(e, r3, n, i) {
  const o = r(r3.timeExtent) && r3.timeExtent.isEmpty ? { data: { features: [] } } : await E(e, r3, "json", i);
  return r2(r3, n, o.data), o;
}
async function d(e, r3, n, i) {
  if (r(r3.timeExtent) && r3.timeExtent.isEmpty)
    return { data: n.createFeatureResult() };
  const o = await f(e, r3, i), a = o;
  return a.data = t(o.data, n), a;
}
function f(e, t3, r3) {
  return E(e, t3, "pbf", r3);
}
function p(e, r3, n) {
  return r(r3.timeExtent) && r3.timeExtent.isEmpty ? Promise.resolve({ data: { objectIds: [] } }) : E(e, r3, "json", n, { returnIdsOnly: true });
}
function S(e, r3, n) {
  return r(r3.timeExtent) && r3.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0 } }) : E(e, r3, "json", n, { returnIdsOnly: true, returnCountOnly: true });
}
function x(e, r3, n) {
  return r(r3.timeExtent) && r3.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0, extent: null } }) : E(e, r3, "json", n, { returnExtentOnly: true, returnCountOnly: true }).then((e2) => {
    const t3 = e2.data;
    if (t3.hasOwnProperty("extent"))
      return e2;
    if (t3.features)
      throw new Error(l);
    if (t3.hasOwnProperty("count"))
      throw new Error(l);
    return e2;
  });
}
function E(i, s, u, l2 = {}, m2 = {}) {
  const c2 = "string" == typeof i ? j(i) : i, d2 = s.geometry ? [s.geometry] : [];
  return l2.responseType = "pbf" === u ? "array-buffer" : "json", L(d2, null, l2).then((n) => {
    const i2 = n && n[0];
    r(i2) && ((s = s.clone()).geometry = i2);
    const o = t2({ ...c2.query, f: u, ...m2, ...y(s, m2) });
    return U(G(c2.path, "query"), { ...l2, query: { ...o, ...l2.query } });
  });
}

export {
  t2 as t,
  m,
  y,
  c,
  d,
  f,
  p,
  S,
  x,
  E
};
//# sourceMappingURL=chunk-TB42IUV7.js.map
