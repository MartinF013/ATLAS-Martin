import {
  a as a4,
  c,
  d as d4,
  h as h2,
  i as i4,
  n as n8,
  o as o4,
  s as s4,
  t as t3
} from "./chunk-23E5E222.js";
import {
  a as a6,
  t as t4
} from "./chunk-E452MYWA.js";
import {
  a as a5
} from "./chunk-PMQUXI6L.js";
import {
  A as A2,
  Be,
  E as E2,
  F as F2,
  I as I2,
  Le,
  O as O2,
  Pe,
  Re,
  ct,
  ft,
  he,
  lt,
  me,
  se,
  st,
  ve
} from "./chunk-RHH23PAT.js";
import {
  h as h3,
  i as i5,
  o as o5
} from "./chunk-KW6WHTET.js";
import {
  m as m5
} from "./chunk-EHWEX2VK.js";
import {
  e as e5
} from "./chunk-HTS3HEEU.js";
import {
  I,
  w as w2
} from "./chunk-7CXXTQLM.js";
import {
  H,
  P as P2,
  s2 as s3
} from "./chunk-ZEDAE7EU.js";
import {
  L as L2
} from "./chunk-5LWMNFCG.js";
import {
  u as u5
} from "./chunk-DVE4HUBR.js";
import {
  o as o3
} from "./chunk-HEZ2ATGC.js";
import {
  D
} from "./chunk-FPMD6IB4.js";
import {
  C,
  n as n7
} from "./chunk-MDCKEJ7B.js";
import {
  v as v2
} from "./chunk-SOZCO2CU.js";
import {
  C as C2
} from "./chunk-W2HLA6I3.js";
import {
  c as c2,
  r as r2
} from "./chunk-V7M26XZ7.js";
import {
  o as o2
} from "./chunk-ZN2MGN4S.js";
import {
  L,
  i as i2,
  w
} from "./chunk-JZY7CGEI.js";
import {
  bn,
  zn
} from "./chunk-PZWU5EHT.js";
import {
  n as n6,
  t as t2
} from "./chunk-7ZPDA3EC.js";
import {
  e as e4
} from "./chunk-U7B2WKBH.js";
import {
  a as a3,
  i as i3,
  u as u4
} from "./chunk-QKRZMDWG.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  h,
  l
} from "./chunk-T7BEWVV3.js";
import {
  O,
  p as p2
} from "./chunk-RN2KRYDN.js";
import {
  g as g2,
  u as u3
} from "./chunk-56RHM4A6.js";
import {
  m as m4
} from "./chunk-FTLBKDGL.js";
import {
  n as n5
} from "./chunk-OIPX3EDD.js";
import {
  m as m3
} from "./chunk-OOZMA7DN.js";
import {
  U as U2
} from "./chunk-65A2N4LL.js";
import {
  Q
} from "./chunk-5N3FSR63.js";
import {
  i,
  o
} from "./chunk-BPZGJQOB.js";
import {
  a as a2
} from "./chunk-ZOKX6UGH.js";
import {
  P,
  e as e3,
  p as p3,
  q,
  s as s2,
  u,
  v,
  x
} from "./chunk-PKZEO23A.js";
import {
  n as n4
} from "./chunk-AIRC226G.js";
import {
  T
} from "./chunk-3NMRL5CR.js";
import {
  d as d3,
  n4 as n,
  n8 as n3,
  y3 as y2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  E,
  N,
  d as d2,
  g,
  k,
  y
} from "./chunk-U3PSONS6.js";
import {
  n as n2
} from "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m as m2
} from "./chunk-G5JBUC5N.js";
import {
  A2 as A,
  F,
  a,
  d2 as d,
  e as e2,
  m,
  p,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SFrameTask.js
var r3 = class {
  constructor(t6) {
    this.referenceCount = 0, this.callbacks = [], this.runIndex = 0, this.handle = t6.registerTask(L.I3S_CONTROLLER, this);
  }
  destroy() {
    this.handle && (this.handle.remove(), this.handle = null);
  }
  get running() {
    for (const t6 of this.callbacks)
      if (t6.needsUpdate())
        return true;
    return false;
  }
  runTask(t6) {
    this._sort();
    const e7 = this.callbacks, r7 = { numIndexLoading: 0, numNodesLoading: 0 };
    for (let s8 = 0; s8 < e7.length && !t6.done; ++s8)
      e7[s8].priority = e7[s8].update(t6, r7), this.runIndex = s8;
  }
  _sort() {
    const t6 = this.callbacks;
    let e7 = t6.length;
    for (let r7 = this.runIndex; r7 > 0; r7--) {
      const s8 = t6[r7 - 1];
      let n10 = r7;
      for (; n10 < t6.length && s8.priority <= t6[n10].priority && (n10 !== e7 || s8.priority < t6[n10].priority); )
        t6[n10 - 1] = t6[n10], n10++;
      t6[n10 - 1] = s8, e7 = n10 - 1;
    }
    this.runIndex = 0;
  }
  add(t6) {
    this._sort(), t6.priority = 1 / 0, this.callbacks.unshift(t6);
  }
  remove(e7) {
    A(this.callbacks, e7), this.runIndex = this.callbacks.length, this._sort();
  }
};
var s5 = /* @__PURE__ */ new Map();
function n9(t6, e7) {
  let n10 = s5.get(t6);
  return null == n10 && (n10 = new r3(t6), s5.set(t6, n10)), n10.add(e7), { remove: () => {
    if (null == n10)
      return;
    n10.remove(e7);
    n10.callbacks.length > 0 || (s5.delete(t6), n10.destroy()), n10 = null;
  } };
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SIndex.js
var b = class {
  constructor(e7, t6, i6, s8, n10) {
    this.childOffset = e7, this.childCount = t6, this.visibilityCache = i6, this.ref = s8, this.node = n10, this.useAsHole = 0, this.filterImpact = n8.NotChecked;
  }
};
var p4 = class {
  constructor(e7, t6, i6, n10, r7, o6, d5, l2, h5, u6, c3, g4, m6, _) {
    this.streamDataController = i6, this.viewportQueries = n10, this.logger = r7, this.holeFilling = o6, this._isLoaded = d5, this._isReloading = l2, this._isSelected = h5, this._enable = u6, this._needsUpdate = c3, this._canRequest = g4, this._computeVisibilityObb = m6, this._computeNodeFiltering = _, this._dirty = true, this._nodePages = [], this.nodeCount = 0, this.nodesPerPage = 0, this.rootIndex = 0, this.lodMetric = a4.None, this._lodConversion = (e8) => e8, this.urlPrefix = "", this._loading = /* @__PURE__ */ new Set(), this._failedNodes = /* @__PURE__ */ new Set(), this._failedPages = /* @__PURE__ */ new Set(), this._indexMissing = 1, this._maxUnloadedPrio = Number.NEGATIVE_INFINITY, this._maxProcessingPrio = Number.POSITIVE_INFINITY, this._nodeTraversalState = /* @__PURE__ */ new Map(), this._version = I3(0), this._visibilityCacheVersion = I3(0), this._maxLevel = 1, this._featureEstimate = { estimate: 0, leavesReached: false }, this._unloadedMemoryEstimate = 0, this._missing = new n({ deallocator: null }), this._prefetch = new n({ deallocator: null }), this._updates = new N2(this._missing), this._imModificationUncategorized = new n({ deallocator: null }), this.ignoreServiceObb = false, this.progressiveLoadPenalty = 0, this._pageQueue = [], this.needNodeElevationRange = false, this.layerHasModifications = false, this._layerHasFilter = false, this.logLayer = e7, e7.serviceUpdateTimeStamp && e7.serviceUpdateTimeStamp.lastUpdate && (this.lastUpdate = `${e7.serviceUpdateTimeStamp.lastUpdate}`), this._maxLodLevel = this.viewportQueries ? this.viewportQueries.maxLodLevel : 1, this._init(t6);
  }
  _init(e7) {
    if ("page" === e7.type) {
      switch (this.urlPrefix = e7.urlPrefix, this.nodesPerPage = e7.pageSize, this.rootIndex = e7.rootIndex, e7.lodMetric) {
        case "maxScreenThreshold":
          this.lodMetric = a4.MaxScreenThreshold;
          break;
        case "maxScreenThresholdSQ":
          this.lodMetric = a4.MaxScreenThreshold, this._lodConversion = V;
      }
      this._addPage(S(this.rootIndex, this.nodesPerPage), e7.rootPage), this._updateParentsAndLevel();
    } else if ("node" === e7.type) {
      this.urlPrefix = e7.urlPrefix, this._nodePages.push({ nodes: [], children: [], parents: [] }), this._makeRefNode(new t3(e7.rootNode.id, null), -1);
      const t6 = this._validateNode(e7.rootNode.id, e7.rootNode);
      t6 && this._addNode(t6, 0);
    }
  }
  _loadPage(e7) {
    this._loading.add(e7);
    const t6 = this.urlPrefix + e7;
    this.streamDataController.request(t6, "json").then((t7) => {
      this._pageQueue.push({ pageIndex: e7, page: t7 });
    }).catch((t7) => {
      this._loading.delete(e7), g(t7) || (this._failedPages.add(e7), this.logger.error("#loadPage()", this.logLayer, `Error when loading page ${e7}`, t7));
    });
  }
  _addQueuedPages(e7) {
    for (; this._pageQueue.length > 0 && !e7.done; ) {
      const { pageIndex: t6, page: i6 } = this._pageQueue.shift();
      this._addPage(t6, i6), this._loading.delete(t6), e7.madeProgress();
    }
    this._updateParentsAndLevel();
  }
  _addPage(e7, t6) {
    for (let r7 = this._nodePages.length; r7 < e7; r7++)
      this._nodePages[r7] = null;
    const i6 = [], s8 = [], n10 = t6.nodes.map((t7, n11) => {
      const a8 = i6.length, d5 = t7.children ? t7.children.length : 0;
      s8.push(-1);
      for (let e8 = 0; e8 < d5; e8++)
        i6.push(t7.children[e8]);
      const h5 = `${t7.index}`, u6 = F2(t7.obb), c3 = e4([u6.center[0], u6.center[1], u6.center[2], s2(u6.halfSize)]), g4 = t7.mesh && t7.mesh.attribute, m6 = t7.mesh && t7.mesh.geometry, _ = t7.mesh && t7.mesh.material, f3 = { hasSharedResource: false, hasFeatureData: !!m6, attributes: g4 && null != g4.resource ? `${g4.resource}` : null, geometry: m6 && null != m6.resource ? `${m6.resource}` : null, texture: _ && null != _.resource ? `${_.resource}` : null, geometryDefinition: m6 ? m6.definition : -1, materialDefinition: _ ? _.definition : -1 }, p7 = new h2(h5, e7 * this.nodesPerPage + n11, c3, d5, 0, f3, this.lastUpdate, this.lodMetric, this._lodConversion(t7.lodThreshold), m6 ? m6.featureCount : null);
      return p7.serviceObb = u6, p7.visibilityObb = this._computeVisibilityObb(p7), p7.vertexCount = m6 ? m6.vertexCount : 0, new b(a8, d5, x2(this._visibilityCacheVersion), null, p7);
    });
    this._nodePages[e7] = { nodes: n10, children: i6, parents: s8 }, this.nodeCount += n10.length;
  }
  _updateParentsAndLevel() {
    const t6 = new Array(), i6 = (i7, s8, n10) => {
      const r7 = this._getPage(i7);
      if (r(r7)) {
        const o6 = L3(i7, this.nodesPerPage);
        r7.parents[o6] = s8;
        const a8 = r7.nodes[o6].node;
        r(a8) && (a8.level = n10, t6.push(i7));
      }
    };
    for (i6(this.rootIndex, -1, 0); t6.length; ) {
      const s8 = t6.pop(), n10 = this.getNode(s8);
      if (r(n10))
        for (let e7 = 0; e7 < n10.childCount; e7++) {
          i6(this.getChildIndex(n10.index, e7), s8, n10.level + 1), this._maxLevel = Math.max(this._maxLevel, n10.level + 1);
        }
    }
  }
  _getPage(e7) {
    return this._nodePages[S(e7, this.nodesPerPage)];
  }
  _getNodeInternal(e7) {
    const i6 = this._getPage(e7);
    return t(i6) ? null : i6.nodes[L3(e7, this.nodesPerPage)];
  }
  _addNode(t6, s8) {
    null != t6.children && this.populateChildren(s8, t6.children);
    const n10 = this.getParent(s8), r7 = r(n10) ? n10.level + 1 : 0;
    this._maxLevel = Math.max(this._maxLevel, t6.children ? r7 + 1 : r7);
    const { lodMetric: a8, maxError: d5 } = E3(t6.lodSelection), h5 = e2(this._getNodeInternal(s8));
    return h5.node = new h2(t6.id, s8, e4(t6.mbs), h5.childCount, r7, t6.resources, t6.version, a8, d5, t6.numFeatures), t6.obb && (h5.node.serviceObb = F2(t6.obb)), h5.node.visibilityObb = this._computeVisibilityObb(h5.node), r(h5.ref) && (null == h5.ref.mbs && (h5.ref.mbs = t6.mbs), h5.node.renderMbs = h5.ref.renderMbs, h5.node.serviceObbInRenderSR = h5.ref.serviceObbInRenderSR, h5.ref.visibilityObb = h5.node.visibilityObb), h5.node;
  }
  _makeRefNode(e7, t6) {
    const i6 = this._nodePages[0], s8 = i6.nodes.length;
    return i6.nodes.push(new b(0, 0, x2(this._visibilityCacheVersion), e7, null)), this.nodeCount++, i6.parents.push(t6), ft(e7.renderMbs), lt(e7.serviceObbInRenderSR), s8;
  }
  populateChildren(e7, t6) {
    const s8 = e2(this._getNodeInternal(e7)), n10 = e2(this._getPage(e7));
    s8.childOffset = n10.children.length, s8.childCount = t6.length;
    for (let i6 = 0; i6 < t6.length; i6++) {
      const s9 = this._makeRefNode(t6[i6], e7);
      n10.children.push(s9);
    }
  }
  getNode(t6) {
    const i6 = this._getNodeInternal(t6);
    return r(i6) ? i6.node : null;
  }
  getIndexById(t6) {
    let i6;
    return this._forAllNodes((s8, n10) => {
      (r(s8.node) && s8.node.id === t6 || r(s8.ref) && s8.ref.id === t6) && (i6 = n10);
    }), i6;
  }
  getNodeById(e7) {
    const t6 = this.getIndexById(e7);
    return t6 >= 0 ? this.getNode(t6) : null;
  }
  getChildIndex(e7, i6) {
    const s8 = this._getPage(e7);
    if (t(s8))
      return -1;
    const n10 = s8.nodes[L3(e7, this.nodesPerPage)];
    return s8.children[n10.childOffset + i6];
  }
  getParentIndex(t6) {
    const i6 = this._getPage(t6);
    return r(i6) ? i6.parents[L3(t6, this.nodesPerPage)] : -1;
  }
  getParent(e7) {
    return (e7 = this.getParentIndex(e7)) >= 0 ? this.getNode(e7) : null;
  }
  isLeaf(t6) {
    const i6 = this._getNodeInternal(t6);
    return r(i6) && 0 === i6.childCount;
  }
  get rootNode() {
    return this.getNode(this.rootIndex);
  }
  get size() {
    return this.nodeCount;
  }
  removeAllGeometryObbs() {
    this._forAllNodes((t6) => {
      r(t6.node) && (t6.node.geometryObb = null);
    });
  }
  invalidateVisibilityCache() {
    this._visibilityCacheVersion = I3(this._visibilityCacheVersion);
  }
  invalidateNodeVisibilityCache(t6) {
    const i6 = this._getNodeInternal(t6);
    r(i6) && this.invalidateNodeVisibilityCacheInternal(i6);
  }
  invalidateNodeVisibilityCacheInternal(e7) {
    e7.visibilityCache = x2(this._visibilityCacheVersion);
  }
  invalidateBoundingVolumeCache(t6) {
    const i6 = this._getNodeInternal(t6);
    r(i6) && (P3(i6), this.invalidateNodeVisibilityCacheInternal(i6));
  }
  updateElevationChanged(i6) {
    const s8 = this._getNodeInternal(i6);
    if (t(s8))
      return;
    if (!this.needNodeElevationRange)
      return void this.invalidateBoundingVolumeCache(i6);
    const n10 = r(s8.node) ? s8.node : s8.ref;
    if (t(n10))
      return;
    const r7 = n10.elevationRange;
    t(r7) || (r7.valid = false);
  }
  invalidateGeometryVisibility(t6) {
    const i6 = this._getNodeInternal(t6);
    r(i6) && r(i6.node) && (i6.node.geometryObb = null, ft(i6.node.renderMbs), lt(i6.node.serviceObbInRenderSR));
  }
  invalidateVisibilityObbs() {
    t(this.rootNode) || this.traverse(this.rootNode, (e7) => (e7.visibilityObb = this._computeVisibilityObb(e7), e7.geometryObb = null, true));
  }
  _updateElevationRange(i6) {
    const s8 = this._getNodeInternal(i6);
    if (t(s8))
      return null;
    const n10 = r(s8.node) ? s8.node : s8.ref;
    if (t(n10))
      return null;
    const r7 = n10.elevationRange;
    if (r(r7) && r7.valid)
      return r7;
    const o6 = new i4();
    let a8 = false;
    for (let e7 = 0; e7 < s8.childCount; e7++) {
      const s9 = this._updateElevationRange(this.getChildIndex(i6, e7));
      t(s9) ? a8 = true : (o6.min = Math.min(o6.min, s9.min), o6.max = Math.max(o6.max, s9.max));
    }
    if (0 === s8.childCount || a8 && r(s8.node) && s8.node.resources.geometry) {
      const t6 = this.viewportQueries.getElevationRange(n10);
      r(t6) && (o6.min = Math.min(o6.min, t6.min), o6.max = Math.max(o6.max, t6.max));
    }
    return r(r7) && r7.min === o6.min && r7.max === o6.max ? (r7.valid = true, r7) : (o6.valid = true, n10.elevationRange = o6, this.invalidateBoundingVolumeCache(i6), o6);
  }
  isNodeVisible(i6) {
    const s8 = this._getNodeInternal(i6);
    if (t(s8) || r(s8.ref) && !s8.ref.mbs)
      return true;
    if (this.needNodeElevationRange && this._updateElevationRange(i6), !w3(s8.visibilityCache, this._visibilityCacheVersion)) {
      const i7 = s8.node, n10 = r(i7) && (t(s8.ref) || r(i7.visibilityObb)) ? i7 : r(s8.ref) ? s8.ref : null;
      if (this._layerHasFilter && this._computeNodeFiltering && (r(i7) || r(s8.ref)) && s8.filterImpact === n8.NotChecked) {
        const t6 = r(i7) ? i7.mbs : r(s8.ref) ? s8.ref.mbs : null;
        s8.filterImpact = null != t6 ? this._computeNodeFiltering(t6) : n8.Unmodified;
      }
      const r7 = r(i7) && s8.filterImpact === n8.Culled, o6 = !(r(i7) && i7.imModificationImpact === o4.Culled) && (!n10 || this.viewportQueries.isNodeVisible(n10)) && !r7;
      return s8.visibilityCache = C3(o6, this._visibilityCacheVersion), o6;
    }
    return M(s8.visibilityCache);
  }
  isGeometryVisible(t6) {
    if (!this.isNodeVisible(t6))
      return false;
    const i6 = this._getNodeInternal(t6);
    return !(r(i6) && r(i6.node) && r(i6.node.geometryObb) && (!this.layerHasModifications || i6.node.imModificationImpact !== o4.NotChecked)) || this.viewportQueries.isGeometryVisible(i6.node);
  }
  _traverseCoverage(s8, n10, r7, o6, a8) {
    const d5 = this._getPage(s8);
    if (t(d5) || 0 === n10.childCount)
      return;
    const l2 = n10.childOffset + n10.childCount, h5 = new Array();
    for (let t6 = n10.childOffset; t6 < l2; ++t6) {
      const i6 = d5.children[t6], s9 = this._getNodeInternal(i6);
      r(s9) && r(s9.node) && this.isGeometryVisible(i6) && h5.push(s9);
    }
    o6 /= h5.length;
    for (const e7 of h5) {
      const t6 = e2(e7.node).index;
      this._isLoaded(t6) || this._isReloading(t6) ? (a8.delta = Math.max(a8.delta, r7), a8.coverage += o6) : this._traverseCoverage(t6, e7, r7 + 1, o6, a8);
    }
  }
  useNodeAsHole(e7) {
    if ("off" === this.holeFilling)
      return false;
    const i6 = this._getNodeInternal(e7);
    if (t(i6))
      return false;
    if ("always" === this.holeFilling)
      return true;
    if (w3(i6.useAsHole, this._version))
      return M(i6.useAsHole);
    const s8 = { delta: 0, coverage: 0 };
    this._traverseCoverage(e7, i6, 0, 1, s8);
    const n10 = s8.delta * s8.coverage <= 0.5;
    return i6.useAsHole = C3(n10, this._version), n10;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  get dirty() {
    return this._dirty;
  }
  destroy() {
    this._updates.add.prune(), this._updates.update.prune();
  }
  requestUpdate() {
    this._dirty = true, this._indexMissing = 1, this._version = I3(this._version);
  }
  imModificationsChanged(t6) {
    this.layerHasModifications = t6, this._forAllNodes(({ node: t7 }) => {
      r(t7) && (t7.imModificationImpact = o4.NotChecked, t7.visibilityObb = this._computeVisibilityObb(t7), t7.hasModifications && this.invalidateGeometryVisibility(t7.index));
    }), this.invalidateVisibilityCache();
  }
  layerFilterChanged(t6) {
    this._layerHasFilter = t6, this._forAllNodes((t7) => {
      if (r(t7)) {
        t7.filterImpact = n8.NotChecked;
        const i6 = t7.node;
        r(i6) && this.invalidateNodeVisibilityCache(i6.index);
      }
    }), this.invalidateVisibilityCache();
  }
  update(s8, n10, r7) {
    if (!this._dirty)
      return;
    this._pageQueue.length > 0 && this._addQueuedPages(n10), this._maxUnloadedPrio = Number.NEGATIVE_INFINITY, this._maxProcessingPrio = Number.NEGATIVE_INFINITY, this._missing.clear(), this._prefetch.clear(), this._updates.reset(s8), y3.clear();
    let o6 = true;
    const a8 = new O3(), d5 = new O3(), l2 = this._imModificationUncategorized;
    l2.clear();
    const h5 = /* @__PURE__ */ new Set(), u6 = (u7, g5, m6) => {
      if (t(g5)) {
        let e7 = this._entryPriority(u7);
        e7 === 1 / 0 && (e7 = this._entryPriority(m6));
        const t6 = S(u7, this.nodesPerPage);
        return y3.set(t6, Math.max(e7, y3.get(t6) || 0)), this._loading.has(t6) || this._failedPages.has(t6) || this._missing.push(t6), void (this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e7));
      }
      const _ = g5.node;
      if (this._updateNodeFeatureEstimate(_, d5), t(_)) {
        const e7 = this._entryPriority(u7);
        return this._loading.has(u7) || this._failedNodes.has(u7) || (this._missing.push(u7), y3.set(u7, e7)), void (this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e7));
      }
      const f3 = e2(this._getPage(u7));
      if (0 === this._missing.length && 0 === this.nodesPerPage)
        for (let t6 = 0; t6 < g5.childCount; t6++) {
          const i6 = f3.children[g5.childOffset + t6], s9 = this._getNodeInternal(i6);
          !r(s9) || s9.node || this._loading.has(i6) || this._failedNodes.has(i6) || (y3.set(i6, this._entryPriority(i6)), this._prefetch.push(i6));
        }
      if (_.failed || !_.resources.hasFeatureData)
        return void (o6 && g5.childCount > 0 && this._isSelected(_) && (o6 = false));
      if (h5.add(_.id), this._isLoaded(u7)) {
        if (a8.known += _.memory, ++a8.knownNodes, this._isSelected(_) ? g5.childCount > 0 && (o6 = false) : (a8.unremoved += _.memory, o6 = false), this._needsUpdate(_)) {
          const e7 = this._entryPriority(u7);
          y3.set(u7, e7), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e7), this._updates.update.push(u7);
        }
        return;
      }
      if (_.memory && (a8.known += _.memory, ++a8.knownNodes), !this._isSelected(_))
        return void (this._isReloading(u7) && this._updates.remove.push(u7));
      if (g5.childCount > 0 && (o6 = false), _.memory ? (a8.missing += _.memory, a8.known += _.memory, ++a8.knownNodes) : ++a8.missingNodes, s8.includes(_.index))
        return this._maxProcessingPrio = Math.max(this._maxProcessingPrio, this._entryPriority(u7)), void (this._updates.cancel = this._updates.cancel.filter((e7) => e7 !== _.index));
      if (!n10.done && this._enable(_))
        return void n10.madeProgress();
      const v3 = this._entryPriority(u7);
      y3.set(u7, v3), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, v3), this._updates.add.push(u7), this.layerHasModifications && r7 && r(_) && _.imModificationImpact === o4.NotChecked && l2.push(u7);
    };
    this.traverseVisible(u6);
    const g4 = this._updates.add;
    g4.length > 0 && this.layerHasModifications && (l2.length > 0 && r7(l2), g4.filterInPlace((e7) => {
      const i6 = this._getNodeInternal(e7), s9 = t(i6) || t(i6.node) || i6.node.imModificationImpact !== o4.Culled;
      return s9 || this.invalidateNodeVisibilityCache(e7), s9;
    })), this._unloadedMemoryEstimate = a8.missing - a8.unremoved, a8.knownNodes > 3 && a8.missingNodes > 0 && (this._unloadedMemoryEstimate += a8.known / a8.knownNodes * a8.missingNodes), this._unloadedMemoryEstimate = 0.8 * Math.max(0, this._unloadedMemoryEstimate), this._featureEstimate.estimate = this._computeFeatureEstimate(d5), this._featureEstimate.leavesReached = o6, this._missing.sort((e7, t6) => e7 - t6), this._missing.filterInPlace((e7, t6) => t6 < 1 || this._missing.data[t6 - 1] !== e7), this._missing.sort((e7, t6) => y3.get(e7) - y3.get(t6)), this._missing.length > 0 && (this._maxUnloadedPrio = y3.get(this._missing.back()), this._prefetch.clear()), this._updates.add.filterInPlace((e7) => y3.get(e7) >= this._maxUnloadedPrio).sort((e7, t6) => y3.get(e7) - y3.get(t6)), this._updates.update.sort((e7, t6) => y3.get(e7) - y3.get(t6)), this._indexMissing = this._loading.size + this._missing.length, this._dirty = this._indexMissing > 0, y3.clear();
  }
  checkFeatureTarget(e7, t6) {
    const i6 = this.viewportQueries.updateScreenSpaceErrorBias(t6);
    let s8 = t6, n10 = t6, r7 = i6, o6 = 10;
    for (; o6--; ) {
      const i7 = new O3();
      this._updateFeatureEstimate(s8, i7);
      if (this._computeFeatureEstimate(i7) <= e7) {
        if (s8 >= t6 || i7.missingNodes > 0 || 0 === o6)
          break;
        r7 = s8, s8 = 0.5 * (s8 + n10);
      } else
        n10 = s8, s8 = 0.5 * (s8 + r7);
    }
    return this._version = I3(this._version), this.viewportQueries.updateScreenSpaceErrorBias(i6), Math.min(t6, s8);
  }
  _updateFeatureEstimate(t6, i6) {
    this._version = I3(this._version), this.viewportQueries.updateScreenSpaceErrorBias(t6), this.traverseVisible((t7, s8) => this._updateNodeFeatureEstimate(r(s8) && s8.node, i6));
  }
  _updateNodeFeatureEstimate(i6, s8) {
    if (!(t(i6) || i6.failed || t(i6.numFeatures)))
      return this._isLoaded(i6.index) ? (s8.known += i6.numFeatures, ++s8.knownNodes, void (this._isSelected(i6) || (s8.unremoved += i6.numFeatures))) : void (this._isSelected(i6) && (r(i6.numFeatures) ? (s8.missing += i6.numFeatures, s8.known += i6.numFeatures, ++s8.knownNodes) : ++s8.missingNodes));
  }
  _computeFeatureEstimate(e7) {
    let t6 = e7.known - e7.unremoved;
    return e7.knownNodes > 3 && e7.missingNodes > 0 && (t6 += e7.known / e7.knownNodes * e7.missingNodes), Math.max(0, t6);
  }
  load() {
    return this._load(this._missing);
  }
  prefetch() {
    return this._prefetch.sort((e7, t6) => y3.get(e7) - y3.get(t6)), this._load(this._prefetch);
  }
  _load(e7) {
    if (0 === e7.length || !this._canRequest())
      return false;
    for (; e7.length > 0 && this._canRequest(); )
      0 === this.nodesPerPage ? this._loadNode(e7.pop()) : this._loadPage(e7.pop());
    return true;
  }
  isLoading() {
    return this._indexMissing > 0;
  }
  getIndexLoading() {
    return this._loading.size;
  }
  getIndexMissing() {
    return this._indexMissing;
  }
  getUnloadedMemoryEstimate() {
    return this._unloadedMemoryEstimate;
  }
  get updates() {
    return this._updates;
  }
  get featureEstimate() {
    return this._featureEstimate;
  }
  nodeTraversalState(e7) {
    if (t(e7))
      return null;
    let i6 = this._nodeTraversalState.get(e7.index);
    if (i6 && w3(i6.version, this._version))
      return i6;
    const s8 = this.viewportQueries.getLodLevel(e7), n10 = this.viewportQueries.hasLOD(e7);
    let r7 = true;
    if (n10) {
      const t6 = this.getParentIndex(e7.index);
      if (t6 >= 0) {
        const e8 = this._nodeTraversalState.get(t6);
        r7 = e8 && s8 > e8.lodLevel;
      } else
        r7 = s8 > 0;
    } else
      r7 = 0 === e7.childCount;
    return i6 ? (i6.lodLevel = s8, i6.isChosen = r7, i6.version = C3(true, this._version), i6) : (i6 = new d4(n10, r7, s8, C3(true, this._version)), this._nodeTraversalState.set(e7.index, i6), i6);
  }
  _loadNode(e7) {
    this._loading.add(e7);
    const s8 = e2(this._getNodeInternal(e7)).ref;
    if (t(s8))
      return void this._failedNodes.add(e7);
    const r7 = s8.id, o6 = this.urlPrefix + r7, a8 = () => {
      this._loading.delete(e7), 0 === this._missing.length && 0 === this._loading.size && this.requestUpdate();
    };
    this.streamDataController.request(o6, "json").then((t6) => {
      a8();
      const i6 = this._validateNode(r7, t6);
      if (null == i6)
        return;
      i6.obb && this.invalidateNodeVisibilityCache(e7);
      const s9 = this._addNode(i6, e7);
      this.nodeTraversalState(s9);
    }, (t6) => {
      a8(), g(t6) || (this.logger.error("#loadNode()", this.logLayer, "Error loading node: " + o6), this._failedNodes.add(e7));
    });
  }
  _validateNode(e7, t6) {
    if (null == t6 || "object" != typeof t6 || t6.id !== e7)
      return this.logger.error("#validateNode()", this.logLayer, `Invalid node. Wrong type or wrong id "${e7}"`), null;
    if (!Array.isArray(t6.mbs))
      return this.logger.error("#validateNode()", this.logLayer, `Invalid bounding volume on node ${e7}.`), null;
    t6.sharedResource && "./shared" !== t6.sharedResource.href && "./shared/" !== t6.sharedResource.href && this.logger.warn("#validateNode()", this.logLayer, `Invalid shared resource href on node "${e7}"`), null == t6.geometryData || Array.isArray(t6.geometryData) && 1 === t6.geometryData.length && "./geometries/0" === t6.geometryData[0].href || this.logger.warn("#validateNode()", this.logLayer, `Invalid geometry data on node "${e7}"`), null == t6.attributeData || Array.isArray(t6.attributeData) && !t6.attributeData.some((e8, t7) => e8.href !== `./attributes/f_${t7}/0`) || this.logger.warn("#validateNode()", this.logLayer, `Invalid attribute data on node "${e7}"`), t6.featureData && t6.featureData.length > 1 && this.logger.warn("#validateNode()", this.logLayer, `Node ${e7} has ${t6.featureData.length} bundles. Only the first bundle will be loaded.`);
    const i6 = t6.hasOwnProperty("obb") && !this.ignoreServiceObb ? t6.obb : null, s8 = t6.featureData && 1 === t6.featureData.length && t6.featureData[0].featureRange ? t6.featureData[0].featureRange[1] - t6.featureData[0].featureRange[0] + 1 : null, n10 = (t7) => {
      if (null == t7)
        return null;
      const i7 = (t8) => this.logger.error("#validateNode()", this.logLayer, `Invalid node reference on node ${e7}: ${t8}`);
      if ("number" == typeof t7.id)
        i7(`id ${t7.id} is a number instead of a string.`);
      else if ("string" != typeof t7.id || !Array.isArray(t7.mbs))
        return i7("Missing or invalid id."), null;
      if (!Array.isArray(t7.mbs))
        return i7(`Invalid bounding volume on reference ${t7.id}.`), null;
      t7.href && t7.href !== "../" + t7.id && this.logger.error("#validateNode()", this.logLayer, `Invalid node href on node "${e7}"`);
      const s9 = t7.hasOwnProperty("obb") && !this.ignoreServiceObb ? t7.obb : null, n11 = new t3(`${t7.id}`, t7.mbs);
      return n11.serviceObb = s9, n11.visibilityObb = this._computeVisibilityObb(n11), n11;
    }, r7 = Array.isArray(t6.children) ? t6.children.map(n10).filter((e8) => null != e8) : null;
    return { id: e7, mbs: t6.mbs, obb: i6, children: r7, resources: { hasFeatureData: t6.featureData && t6.featureData.length > 0, hasSharedResource: null != t6.sharedResource, attributes: t6.attributeData ? e7 : null, texture: t6.textureData && t6.textureData.length > 0 ? e7 : null, geometry: null != t6.geometryData ? e7 : null }, version: "string" == typeof t6.version ? t6.version : null, lodSelection: Array.isArray(t6.lodSelection) ? t6.lodSelection : null, numFeatures: s8 };
  }
  resetFailedNodes() {
    this._failedNodes.clear(), this._failedPages.clear(), this._forAllNodes((t6) => {
      r(t6.node) && (t6.node.failed = false);
    });
  }
  _entryPriority(i6) {
    const s8 = this._getNodeInternal(i6), n10 = this.getParentIndex(i6);
    if (t(s8) || n10 < 0 && null == s8.node)
      return n10 < 0 ? 1 / 0 : this._entryPriority(n10);
    let r7 = 0;
    if (s8.node && n10 >= 0) {
      const e7 = this._nodeTraversalState.get(n10);
      null != e7 && (r7 = e7.lodLevel);
    }
    let o6 = this.progressiveLoadPenalty;
    for (let e7 = i6; e7 >= 0; e7 = this.getParentIndex(e7))
      if (this._isLoaded(e7)) {
        o6 = 0;
        break;
      }
    const a8 = r(s8.ref) ? this.viewportQueries.distToPOI(s8.ref) : r(s8.node) ? this.viewportQueries.distToPOI(s8.node) : 0;
    return -a8 - r7 * (a8 + this.progressiveLoadPenalty) + o6;
  }
  traverseVisible(e7) {
    const i6 = this._getNodeInternal(this.rootIndex);
    t(i6) ? e7(this.rootIndex, null, null) : this._traverseVisible(this.rootIndex, -1, i6, e7);
  }
  _traverseVisible(t6, s8, n10, r7) {
    if (n10.node && 0 === n10.childCount)
      return void (this.isGeometryVisible(t6) && r7(t6, n10, s8));
    if (!this.isNodeVisible(t6))
      return;
    if (r7(t6, n10, s8), null == n10.node)
      return;
    const o6 = this.nodeTraversalState(n10.node);
    if (o6.nodeHasLOD && o6.lodLevel === this._maxLodLevel)
      return;
    const a8 = e2(this._getPage(t6));
    for (let i6 = 0; i6 < n10.childCount; i6++) {
      const s9 = a8.children[n10.childOffset + i6], o7 = this._getNodeInternal(s9);
      r(o7) ? this._traverseVisible(s9, t6, o7, r7) : r7(s9, null, t6);
    }
  }
  traverse(e7, t6) {
    t6(e7) && this.traverseChildren(e7, t6);
  }
  traverseChildren(t6, i6) {
    const s8 = t6.index, n10 = this._getNodeInternal(s8);
    r(n10) && this._traverseChildren(s8, n10, i6);
  }
  _traverseChildren(i6, s8, n10) {
    const r7 = this._getPage(i6);
    if (t(r7))
      return;
    const o6 = s8.childOffset + s8.childCount;
    for (let t6 = s8.childOffset; t6 < o6; ++t6) {
      const i7 = r7.children[t6], s9 = this._getNodeInternal(i7);
      r(s9) && r(s9.node) && n10(s9.node) && this._traverseChildren(i7, s9, n10);
    }
  }
  updateChildrenLoaded(t6, i6) {
    let s8 = this.getNode(t6);
    for (; r(s8); )
      s8.childrenLoaded += i6, s8 = this.getParent(s8.index);
  }
  checkChildrenLoadedInvariant() {
    if (t(this.rootNode))
      return true;
    const e7 = [], i6 = (t6) => {
      let s8 = this._isLoaded(t6.index) || this._isReloading(t6.index) ? 1 : 0;
      return this.traverseChildren(t6, (e8) => (s8 += i6(e8), false)), t6.childrenLoaded !== s8 && e7.push(t6.index), s8;
    };
    return i6(this.rootNode), e7.length && this.logger.error("childrenLoaded invariant broken at following nodes: " + e7.join(",")), e7.length > 0;
  }
  updateStats(e7) {
    if (this._updates.add.length > 0 && (e7.nodes += " + " + this._updates.add.length), (this._indexMissing || this._prefetch.length > 0) && (e7.index += " + " + this._indexMissing || this._prefetch.length), e7.prio = this._maxProcessingPrio, this._featureEstimate.estimate) {
      const t6 = this._featureEstimate.estimate - e7.features;
      t6 > 0 ? e7.features += " + " + t6 : t6 < 0 && (e7.features += " - " + -t6);
    }
  }
  getPriority() {
    return Math.max(this._maxProcessingPrio, this._maxUnloadedPrio);
  }
  updateElevationInfo(t6, i6) {
    this.needNodeElevationRange = i6 && t6 && ("relative-to-ground" === t6.mode || "on-the-ground" === t6.mode), this._forAllNodes((t7) => {
      P3(t7), r(t7.node) && (t7.node.elevationRange = null), r(t7.ref) && (t7.ref.elevationRange = null);
    }), this.viewportQueries.updateElevationInfo(t6);
  }
  _forAllNodes(e7) {
    for (let t6 = 0; t6 < this._nodePages.length; t6++) {
      const i6 = this._nodePages[t6];
      if (i6) {
        const s8 = t6 * this.nodesPerPage;
        for (let t7 = 0; t7 < i6.nodes.length; t7++)
          e7(i6.nodes[t7], s8 + t7);
      }
    }
  }
  get test() {
    return { addNode: (e7, t6) => this._addNode(e7, t6) };
  }
};
var y3 = /* @__PURE__ */ new Map();
var N2 = class {
  constructor(e7) {
    this.missing = e7, this.update = new n({ deallocator: null }), this.add = new n({ deallocator: null }), this.remove = new n({ deallocator: null }), this.cancel = [];
  }
  reset(e7) {
    this.add.clear(), this.update.clear(), this.cancel = e7;
  }
};
function P3(t6) {
  r(t6.node) && (ft(t6.node.renderMbs), lt(t6.node.serviceObbInRenderSR)), r(t6.ref) && (ft(t6.ref.renderMbs), lt(t6.ref.serviceObbInRenderSR));
}
function x2(e7) {
  return Le(e7, -2);
}
function I3(e7) {
  return Le(e7, 2);
}
function C3(e7, t6) {
  return t6 + (e7 ? 1 : 0);
}
function w3(e7, t6) {
  return (-2 & e7) === t6;
}
function M(e7) {
  return 1 == (1 & e7);
}
function S(e7, t6) {
  return 0 === t6 ? 0 : e7 / t6 | 0;
}
function L3(e7, t6) {
  return 0 === t6 ? e7 : e7 % t6;
}
var R = [["maxScreenThreshold", a4.MaxScreenThreshold], ["screenSpaceRelative", a4.ScreenSpaceRelative], ["removedFeatureDiameter", a4.RemovedFeatureDiameter], ["distanceRangeFromDefaultCamera", a4.DistanceRangeFromDefaultCamera]];
function E3(e7) {
  if (e7) {
    for (let t6 = 0; t6 < e7.length; t6++)
      for (const i6 of R)
        if (i6[0] === e7[t6].metricType)
          return { lodMetric: i6[1], maxError: e7[t6].maxError };
  }
  return { lodMetric: a4.None, maxError: 0 };
}
var O3 = class {
  constructor() {
    this.known = 0, this.knownNodes = 0, this.missing = 0, this.missingNodes = 0, this.unremoved = 0;
  }
};
function V(e7) {
  return Math.sqrt(e7 * (4 / Math.PI));
}

// node_modules/@arcgis/core/views/3d/layers/support/I3SLayerView.js
var a7;
!function(a8) {
  a8[a8.FadeIn = 0] = "FadeIn", a8[a8.FadeOut = 1] = "FadeOut";
}(a7 || (a7 = {}));

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SLodHandling.js
var t5 = class {
  constructor(e7) {
    this.layerView = e7, this._lodGlobalDirty = false;
  }
  startNodeLoading(e7, i6, o6, s8) {
    this._maxLodLevel = s8.maxLodLevel, this._index = o6, this._isNodeInScaleBounds = e7, this._removeNodes = i6;
  }
  shouldLoadNode(i6) {
    if (t(i6))
      return false;
    const o6 = this._index.nodeTraversalState(i6);
    return !!this._isChosenMaxLOD(o6) || !!o6.isChosen && this._childrenRequireLoading(i6);
  }
  setLodGlobalDirty() {
    this._lodGlobalDirty = true;
  }
  get requiresLODGlobalHandling() {
    return null != this._index && true === this._lodGlobalDirty;
  }
  lodGlobalHandling(e7) {
    if (!this.requiresLODGlobalHandling)
      return false;
    this._lodGlobalDirty = false;
    const i6 = this.layerView.view.resourceController.memoryController.usedMemory, o6 = Math.max(0, Math.floor(10 * (i6 - 1)));
    r4.clear(), this._lodGlobalHandling(this._index.rootNode, o6, false, this.layerView.nodeCrossfadingEnabled);
    const s8 = r4.length;
    this._removeNodes(r4, e7);
    const d5 = r4.length < s8;
    return 0 !== r4.length && (this._lodGlobalDirty = true), r4.clear(), d5;
  }
  _lodGlobalHandling(o6, t6, l2, n10) {
    if (t(o6))
      return false;
    const a8 = o6.index, h5 = this._index, u6 = this.layerView, c3 = h5.nodeTraversalState(o6), _ = this._isChosenMaxLOD(c3), x5 = !o6.resources.hasFeatureData;
    if (_ && x5)
      return o6.childrenLoaded > 0 && this._removeChildrenRecursive(o6), true;
    const L4 = u6.isNodeLoaded(a8);
    if (n10 && L4 && _) {
      const e7 = !l2 && this.hasNoVisibleChildren(o6);
      u6.fadeNode(a8, a7.FadeIn, !e7);
    }
    const N3 = L4 && (!u6.isNodeFullyFadedIn || u6.isNodeFullyFadedIn(a8));
    if (L4 && (u6.updateNodeState(a8, _ ? c.Leaf : c.Hole), _))
      return N3 && this._removeChildrenRecursive(o6), N3;
    const m6 = o6.childCount > 0;
    let y6 = m6;
    if (m6)
      for (let e7 = 0; e7 < o6.childCount; e7++) {
        const o7 = h5.getChildIndex(a8, e7), s8 = h5.getNode(o7);
        if (r(s8)) {
          !(!h5.isGeometryVisible(o7) || this._lodGlobalHandling(s8, t6, l2 || N3, n10)) && this._isNodeInScaleBounds(s8) && (y6 = false);
        } else
          h5.isNodeVisible(o7) && (y6 = false);
      }
    const b4 = L4 && !_ && (y6 || r4.length < t6);
    b4 && r4.push(a8), !n10 || b4 || !L4 || l2 || y6 || u6.fadeNode(a8, a7.FadeIn, false);
    const f3 = !o6.resources.hasFeatureData;
    return y6 || N3 && !b4 || f3;
  }
  _removeChildrenRecursive(e7) {
    this._index.traverseChildren(e7, (e8) => ((this.layerView.isNodeLoaded(e8.index) || this.layerView.isNodeReloading(e8.index)) && r4.push(e8.index), e8.childrenLoaded > 0));
  }
  hasNoVisibleChildren(e7) {
    let i6 = true;
    return this._index.traverseChildren(e7, (e8) => !(!i6 || !this._index.isNodeVisible(e8.index)) && (this.layerView.isNodeLoaded(e8.index) ? (i6 = false, false) : e8.childrenLoaded > 0)), i6;
  }
  _childrenRequireLoading(e7) {
    let i6 = false, o6 = true;
    return this._index.traverseChildren(e7, (e8) => {
      if (!o6 || !this._index.isNodeVisible(e8.index))
        return false;
      const s8 = this._index.nodeTraversalState(e8);
      return this._isChosenMaxLOD(s8) && this._index.isGeometryVisible(e8.index) && (i6 = true), this.layerView.isNodeLoaded(e8.index) ? (o6 = false, false) : e8.childrenLoaded > 0;
    }), o6 && i6;
  }
  _isChosenMaxLOD(e7) {
    return e7.isChosen && (!e7.nodeHasLOD || e7.lodLevel === this._maxLodLevel);
  }
};
var r4 = new n({ deallocator: null });

// node_modules/@arcgis/core/views/3d/layers/i3s/enums.js
var e6;
var s6;
!function(e7) {
  e7[e7.KTX2 = 1] = "KTX2", e7[e7.Basis = 2] = "Basis", e7[e7.DDS_S3TC = 4] = "DDS_S3TC", e7[e7.PNG = 8] = "PNG", e7[e7.JPG = 16] = "JPG", e7[e7.KTX_ETC2 = 32] = "KTX_ETC2";
}(e6 || (e6 = {})), function(e7) {
  e7[e7.None = 0] = "None", e7[e7.Color = 1] = "Color", e7[e7.MetallicRoughness = 2] = "MetallicRoughness", e7[e7.Normal = 4] = "Normal", e7[e7.Occlusion = 8] = "Occlusion", e7[e7.Emissive = 16] = "Emissive", e7[e7.AlphaMask = 32] = "AlphaMask", e7[e7.ColorTextures = 19] = "ColorTextures", e7[e7.GeometryTextures = 36] = "GeometryTextures", e7[e7.GeometryTexturesPBR = 44] = "GeometryTexturesPBR", e7[e7.AllTextures = 37] = "AllTextures", e7[e7.AllTexturesPBR = 63] = "AllTexturesPBR";
}(s6 || (s6 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/material/RenderTexture.js
var r5 = class {
  constructor(t6, r7) {
    this._textureRep = t6, this._disposed = false;
    const i6 = this._textureRep.acquire(r7);
    k(i6) ? (i6.then((t7) => {
      this._disposed ? p(t7) : this._textureRef = t7;
    }), this.loadPromise = i6) : this._textureRef = i6;
  }
  dispose() {
    this._textureRef = p(this._textureRef), this._disposed = true;
  }
  get glTexture() {
    return r(this._textureRef) ? this._textureRef.glTexture : null;
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SMaterialUtil.js
function h4(e7, a8) {
  const o6 = /* @__PURE__ */ new Map(), t6 = (e8, a9) => {
    if (t(e8))
      return -1;
    if (o6.has(e8.id)) {
      const r8 = o6.get(e8.id);
      return r8.usage |= a9, r8.id;
    }
    const r7 = o6.size;
    return o6.set(e8.id, { id: r7, usage: a9 }), r7;
  }, l2 = a8.pbrMetallicRoughness, u6 = l2 && l2.baseColorFactor, c3 = a8.emissiveFactor, d5 = null == a8.normalTexture && null == a8.emissiveTexture && null == a8.occlusionTexture && (!l2 || null == l2.metallicRoughnessTexture && 1 === l2.roughnessFactor && (1 === l2.metallicFactor || 0 === l2.metallicFactor)), g4 = d5 ? u5[0] : l2 ? l2.metallicFactor : 1, p7 = d5 ? u5[1] : l2 ? l2.roughnessFactor : 1, h5 = "mask" === a8.alphaMode ? s6.Color | s6.AlphaMask : s6.Color, x5 = { baseColorFactor: u6 ? [u6[0], u6[1], u6[2], u6[3]] : [1, 1, 1, 1], baseColorTextureId: t6(l2 && l2.baseColorTexture, h5), metallicRoughnessTextureId: t6(l2 && l2.metallicRoughnessTexture, s6.MetallicRoughness), metallicFactor: g4, roughnessFactor: p7 }, b4 = { alphaMode: a8.alphaMode, alphaCutoff: a8.alphaCutoff, doubleSided: a8.doubleSided, cullFace: "none" === a8.cullFace ? n7.None : "back" === a8.cullFace ? n7.Back : "front" === a8.cullFace ? n7.Front : void 0, normalTextureId: t6(a8.normalTexture, s6.Normal), emissiveTextureId: t6(a8.emissiveTexture, s6.Emissive), occlusionTextureId: t6(a8.occlusionTexture, s6.Occlusion), emissiveFactor: c3 ? [c3[0], c3[1], c3[2]] : [0, 0, 0], metallicRoughness: x5, wrapTextures: false, hasParametersFromSource: d5 }, F4 = [];
  return o6.forEach(({ usage: a9 }, o7) => {
    const s8 = r(e7) && e7[o7] && e7[o7].formats, t7 = s8 ? f(s8.map(({ name: e8, format: a10 }) => ({ name: e8, encoding: T2[a10] }))) : [];
    F4.push({ id: o7, usage: a9, encodings: t7 });
  }), { material: b4, textures: F4 };
}
function f(e7) {
  return e7.sort((e8, a8) => e8.encoding - a8.encoding);
}
var T2 = { ktx2: e6.KTX2, basis: e6.Basis, dds: e6.DDS_S3TC, png: e6.PNG, jpg: e6.JPG, "ktx-etc2": e6.KTX_ETC2 };
var x3 = { [L2.KTX2_ENCODING]: e6.Basis, [L2.BASIS_ENCODING]: e6.Basis, [L2.DDS_ENCODING]: e6.DDS_S3TC, "image/png": e6.PNG, "image/jpg": e6.JPG, "image/jpeg": e6.JPG, "image/ktx": e6.KTX_ETC2 };
function b2(e7) {
  const o6 = e7 && e7.materialDefinitions ? Object.keys(e7.materialDefinitions)[0] : null, r7 = e7 && e7.textureDefinitions ? Object.keys(e7.textureDefinitions)[0] : null, s8 = o6 && e7.materialDefinitions[o6], t6 = r7 && e7.textureDefinitions[r7], l2 = F3();
  if (null != s8) {
    const e8 = s8.params;
    e8.diffuse && (l2.metallicRoughness.baseColorFactor = [e8.diffuse[0], e8.diffuse[1], e8.diffuse[2], 1]), null != e8.doubleSided && (l2.doubleSided = e8.doubleSided, l2.cullFace = e8.doubleSided ? n7.None : n7.Back), "none" !== e8.cullFace && "front" !== e8.cullFace && "back" !== e8.cullFace || (l2.cullFace = "none" === e8.cullFace ? n7.None : "back" === e8.cullFace ? n7.Back : n7.Front), e8.transparency && (l2.metallicRoughness.baseColorFactor[3] = o(1 - e8.transparency, 0, 1)), (e8.useVertexColorAlpha || l2.metallicRoughness.baseColorFactor[3] < 1) && (l2.alphaMode = "blend");
  }
  const i6 = [];
  if (null != t6) {
    const e8 = 0;
    !t6.wrap || "repeat" !== t6.wrap[0] && "repeat" !== t6.wrap[1] || (l2.wrapTextures = true);
    let a8 = s6.Color;
    "rgba" === t6.channels && (l2.alphaMode = "blend", a8 |= s6.AlphaMask);
    const o7 = t6.images.length - 1, r8 = t6.images[o7], s9 = (e9) => e9 && e9.split("/").pop(), u6 = Array.isArray(t6.encoding) ? f(t6.encoding.map((e9, a9) => ({ name: s9(r8.href[a9]), encoding: x3[e9] || 0 }))) : [{ name: s9(r8.href), encoding: x3[t6.encoding] || 0 }];
    i6.push({ id: e8, usage: a8, encodings: u6 }), l2.metallicRoughness.baseColorTextureId = e8;
  }
  return { material: l2, textures: i6 };
}
var F3 = () => ({ alphaMode: "opaque", alphaCutoff: o3, doubleSided: true, cullFace: n7.None, normalTextureId: -1, emissiveTextureId: -1, occlusionTextureId: -1, emissiveFactor: [0, 0, 0], metallicRoughness: { baseColorFactor: [0.8, 0.8, 0.8, 1], baseColorTextureId: -1, metallicRoughnessTextureId: -1, metallicFactor: 0, roughnessFactor: 0.6 }, wrapTextures: false, hasParametersFromSource: true });
function C4(e7, a8, r7, t6) {
  if (t(e7) || null == e7.data)
    return null;
  const l2 = e7.data, i6 = !(l2 instanceof HTMLImageElement) || i(l2.width) && i(l2.height), u6 = t6.renderingContext.parameters.maxMaxAnisotropy, c3 = r7 && !t6.capabilities.shaderTextureLOD ? 1 : u6, m6 = i6 && !e7.downsampled && c3 > 1, d5 = r7 || !a8.wrapTextures ? P4 : M2, p7 = E4(e7.encoding), h5 = e7.usage & s6.Color ? "opaque" === a8.alphaMode ? 3 : 4 : 3;
  return new L2(l2, { mipmap: m6, maxAnisotropy: c3, encoding: p7, wrap: d5, components: h5, noUnpackFlip: true });
}
var P4 = { s: D.CLAMP_TO_EDGE, t: D.CLAMP_TO_EDGE };
var M2 = { s: D.REPEAT, t: D.REPEAT };
function S2(e7, o6, s8, t6, i6, m6) {
  const g4 = m6.rendererTextureUsage, p7 = (e8) => R2(t6, s8, e8 & g4), h5 = o6.metallicRoughness.baseColorFactor, f3 = o(o6.metallicRoughness.baseColorFactor[3], 0, 1);
  e7.baseColor = [h5[0], h5[1], h5[2], f3], e7.hasParametersFromSource = !!o6.hasParametersFromSource, e7.usePBR = m6.usePBR, e7.mrrFactors = [o6.metallicRoughness.metallicFactor, o6.metallicRoughness.roughnessFactor, o6.hasParametersFromSource ? 0.2 : 0.5], e7.emissiveFactor = o6.emissiveFactor, e7.isIntegratedMesh = m6.isIntegratedMesh, e7.textureAlphaCutoff = "mask" === o6.alphaMode ? o6.alphaCutoff : o3, e7.alphaDiscardMode = "opaque" === o6.alphaMode ? C.Opaque : "mask" === o6.alphaMode ? C.Mask : C.MaskBlend;
  const T4 = [], x5 = p7(s6.Color | s6.AlphaMask);
  r(x5) && (e7.baseColorTexture = new r5(i6, x5), T4.push(e7.baseColorTexture.loadPromise));
  const b4 = p7(s6.MetallicRoughness);
  r(b4) && (e7.metallicRoughnessTexture = new r5(i6, b4), T4.push(e7.metallicRoughnessTexture.loadPromise));
  const F4 = p7(s6.Emissive);
  r(F4) && (e7.emissionTexture = new r5(i6, F4), T4.push(e7.emissionTexture.loadPromise));
  const C6 = p7(s6.Occlusion);
  r(C6) && (e7.occlusionTexture = new r5(i6, C6), T4.push(e7.occlusionTexture.loadPromise));
  const P5 = p7(s6.Normal);
  return r(P5) && (e7.normalTexture = new r5(i6, P5), T4.push(e7.normalTexture.loadPromise)), e7.commonMaterialParameters.hasSlicePlane = m6.slicePlaneEnabled, e7.commonMaterialParameters.doubleSided = o6.doubleSided, e7.commonMaterialParameters.cullFace = o6.cullFace, e7.ellipsoidMode = a5(m6.viewSpatialReference), Promise.all(T4);
}
function D2(a8) {
  const o6 = !!a8.compressedTextureS3TC, r7 = !!a8.compressedTextureETC, s8 = a("disable-feature:i3s-basis") ? 0 : e6.Basis | e6.KTX2, n10 = e6.JPG | e6.PNG, l2 = s8 | e6.DDS_S3TC;
  return n10 | (o6 ? l2 : 0) | (r7 ? s8 : 0);
}
function w4(e7, a8) {
  return e7.find((e8) => 0 != (e8.encoding & a8));
}
function R2(e7, a8, o6) {
  if (t(e7) || o6 === s6.None)
    return null;
  for (let s8 = 0; s8 < e7.length; s8++) {
    const t6 = e7[s8];
    if (r(t6) && 0 != (t6.usage & o6)) {
      const e8 = a8[s8];
      return r(e8) ? e8.id : null;
    }
  }
  return null;
}
function E4(e7) {
  switch (e7) {
    case e6.KTX2:
      return L2.KTX2_ENCODING;
    case e6.Basis:
      return L2.BASIS_ENCODING;
    case e6.DDS_S3TC:
      return L2.DDS_ENCODING;
    case e6.PNG:
      return "image/png";
    case e6.JPG:
      return "image/jpeg";
    case e6.KTX_ETC2:
      return "image/ktx";
    default:
      return "";
  }
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNodeLoader.js
var g3 = class {
  constructor(e7, t6, r7, i6, o6, n10) {
    if (this.streamDataController = t6, this.logger = r7, this.defaultGeometrySchema = i6, this.requiredAttributes = o6, this.options = n10, this.logLayer = e7, this.layerUrl = e7.parsedUrl.path, this.geometryDefinitions = e7.geometryDefinitions, e7.materialDefinitions) {
      const t7 = e7.textureSetDefinitions;
      this.materialAndTextures = e7.materialDefinitions.map((e8) => h4(t7, e8));
    }
  }
  _load(e7, t6, r7) {
    return this.streamDataController.request(e7, t6, r7);
  }
  _loadAttribute(e7, t6, r7) {
    const i6 = `${this.layerUrl}/nodes/${e7.resources.attributes}/attributes/${t6.key}/0`;
    return this._load(i6, "binary", r7).then((e8) => I(t6, e8));
  }
  loadAttributes(e7, t6, r7) {
    return E(t6.map((t7) => this._loadAttribute(e7, t7.attributeStorageInfo, r7))).then((r8) => {
      const i6 = {};
      for (let o6 = 0; o6 < t6.length; ++o6)
        if (r8[o6].value)
          i6[t6[o6].name] = r8[o6].value;
        else {
          if (g(r8[o6].error))
            throw r8[o6].error;
          this.logger.error("#loadAttributes", this.logLayer, `Failed to load attributeData for '${t6[o6].name}' on node '${e7.id}'`, r8[o6].error);
        }
      return i6;
    });
  }
  async loadNodeData(r7, i6) {
    const s8 = null != this.requiredAttributes && r7.resources.attributes ? a3(this.loadAttributes(r7, this.requiredAttributes, i6)) : null, { bufferDefinition: a8, bufferIndex: u6 } = x4(this.geometryDefinitions, r7), l2 = !!r7.resources.geometry, f3 = l2 ? a3(this._loadGeometry(r7.resources.geometry, u6, i6)) : null, c3 = r7.resources.hasSharedResource ? await this._loadShared(r7, i6) : null, h5 = this.materialAndTextures && r7.resources.materialDefinition >= 0 ? this.materialAndTextures[r7.resources.materialDefinition] : null != c3 ? b2(c3) : null, g4 = h5 && h5.material, A4 = h5 && h5.textures, _ = `${r7.id}`, w5 = !l2 && this.options.loadFeatureData, T4 = w5 ? await this._loadFeatureData(_, i6) : null, $2 = w5 ? b3(T4) : y4(g4), j2 = t($2) && D3(T4), I5 = null != A4 && A4.length > 0 ? a3(this.loadTextures(r7, A4, i6)) : null;
    let U3 = null, S3 = null;
    if (f3) {
      U3 = i3(await f3);
      const e7 = p5(this.defaultGeometrySchema, c3);
      S3 = w2(a8, e7);
    }
    const q2 = I5 ? i3(await I5) : null, v3 = s8 ? i3(await s8) : {}, B2 = v3 ? { attributeData: v3, loadedAttributes: this.requiredAttributes } : null;
    if (r($2))
      return { geometryData: $2, attributeDataInfo: B2, geometryBuffer: U3, geometryDescriptor: S3, requiredTextures: A4, textureData: q2 };
    if (r(j2))
      return { pointData: j2, attributeDataInfo: B2, geometryBuffer: U3, geometryDescriptor: S3, requiredTextures: A4, textureData: q2 };
    throw new Error();
  }
  static _addAbsoluteHrefTexture(e7, t6) {
    const r7 = e7.textureDefinitions;
    if (null != r7)
      for (const i6 of Object.keys(r7))
        for (const e8 of r7[i6].images)
          Array.isArray(e8.href) ? e8.hrefConcat = e8.href.map((e9) => Q(e9, t6)) : e8.hrefConcat = Q(e8.href, t6);
  }
  static _fixTextureEncodings(e7) {
    const t6 = e7.textureDefinitions;
    if (null != t6)
      for (const r7 in t6) {
        const e8 = t6[r7];
        if (Array.isArray(e8.encoding))
          for (let t7 = 0; t7 < e8.encoding.length; t7++) {
            const r8 = e8.encoding[t7];
            "data:" === r8.substring(0, 5) && (e8.encoding[t7] = r8.substring(5));
          }
        else {
          const t7 = e8.encoding;
          "data:" === t7.substring(0, 5) && (e8.encoding = t7.substring(5));
        }
      }
  }
  _loadShared(e7, t6) {
    const r7 = `${this.layerUrl}/nodes/${e7.resources.geometry}/shared`;
    return this._load(r7, "json", t6).then((e8) => (g3._fixTextureEncodings(e8), g3._addAbsoluteHrefTexture(e8, r7), e8));
  }
  _loadTexture(e7, t6, r7, i6, o6, n10) {
    let s8 = false;
    return o6 === e6.DDS_S3TC || o6 === e6.KTX2 || o6 === e6.Basis ? this._load(e7, "binary", n10).then((e8) => ({ id: t6, usage: r7, data: e8, encoding: o6, downsampled: s8 })) : this._load(e7, "image", n10).then((e8) => {
      let n11 = e8;
      const a8 = 4096, u6 = 2;
      if (i6 && e8.width * e8.height >= a8) {
        const t7 = Math.ceil(e8.width / u6), r8 = Math.ceil(e8.height / u6), i7 = document.createElement("canvas");
        i7.width = t7, i7.height = r8;
        i7.getContext("2d").drawImage(e8, 0, 0, t7, r8), n11 = i7, s8 = true;
      }
      return { id: t6, usage: r7, data: n11, encoding: o6, downsampled: s8 };
    });
  }
  loadTextures(e7, t6, r7) {
    const i6 = this.options.uncompressedTextureDownsamplingEnabled, o6 = this.options.textureUsageMask;
    return Promise.all(t6.map((t7) => {
      if (0 == (t7.usage & o6))
        return null;
      const n10 = w4(t7.encodings, this.options.textureEncodings);
      if (null == n10)
        return this.logger.error("#loadTextures", this.logLayer, `No known encoding for texture found on node ${e7.id}`), Promise.reject();
      const s8 = e7.resources.texture || e7.id, a8 = `${this.layerUrl}/nodes/${s8}/textures/${n10.name}`;
      return this._loadTexture(a8, t7.id, t7.usage, i6, n10.encoding, r7);
    }));
  }
  _loadFeatureData(e7, t6) {
    const r7 = `${this.layerUrl}/nodes/${e7}/features/0`;
    return this._load(r7, "json", t6);
  }
  _loadGeometry(e7, t6, r7) {
    const i6 = `${this.layerUrl}/nodes/${e7}/geometries/${t6}`;
    return this._load(i6, "binary", r7);
  }
};
function y4(e7) {
  return { featureIds: [], geometries: [{ type: "ArrayBufferView", params: { material: e7 } }], featureDataPosition: [0, 0, 0] };
}
function b3(e7) {
  for (const t6 of e7.featureData) {
    const e8 = t6.geometries;
    if (null != e8)
      for (const r7 of e8)
        return { featureIds: [t6.id], featureDataPosition: t6.position, geometries: [r7] };
  }
  return null;
}
function D3(e7) {
  const t6 = new Array();
  for (const r7 of e7.featureData)
    null != r7.position && t6.push({ featureIds: [r7.id], featureDataPosition: r7.position, geometries: null });
  return t6;
}
function p5(e7, t6) {
  if (!e7 || !t6 || !t6.materialDefinitions)
    return e7;
  const r7 = Object.keys(t6.materialDefinitions)[0];
  return !t6.materialDefinitions[r7].params.vertexRegions && e7.vertexAttributes.region && delete (e7 = m2(e7)).vertexAttributes.region, e7;
}
function x4(e7, t6) {
  const i6 = { bufferDefinition: null, bufferIndex: 0 };
  if (null == e7 || t6.resources.geometryDefinition < 0)
    return i6;
  const o6 = t6.resources.geometryDefinition >= 0 ? e7[t6.resources.geometryDefinition].geometryBuffers : null;
  if (null == o6)
    return i6;
  for (let n10 = 0; n10 < o6.length; n10++) {
    const e8 = o6[n10];
    if (null == e8.compressedAttributes)
      i6.bufferIndex = n10, i6.bufferDefinition = o6[n10];
    else if ("draco" === e8.compressedAttributes.encoding && !a("disable-feature:i3s-draco"))
      return i6.bufferIndex = n10, i6.bufferDefinition = e8, i6;
  }
  return i6;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SStreamDataController.js
var r6 = class {
  constructor(e7, t6) {
    this.requester = e7, this.apiKey = t6, this.activeRequests = /* @__PURE__ */ new Set();
  }
  get busy() {
    return this.requester.busy;
  }
  request(r7, s8, o6) {
    const l2 = new AbortController(), a8 = d2(o6, () => l2.abort()), n10 = { signal: l2.signal, query: { token: this.apiKey } }, i6 = this.requester.request(r7, s8, n10), u6 = { response: i6, abortController: l2, abortHandle: a8 };
    return this.activeRequests.add(u6), N(i6, () => {
      var _a;
      u6.abortController = null, (_a = u6.abortHandle) == null ? void 0 : _a.remove(), u6.abortHandle = null, this.activeRequests.delete(u6);
    }), i6;
  }
  cancelAll() {
    this.activeRequests.forEach((e7) => {
      var _a, _b;
      (_a = e7.abortController) == null ? void 0 : _a.abort(), e7.abortController = null, (_b = e7.abortHandle) == null ? void 0 : _b.remove();
    }), this.activeRequests.clear();
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SViewportQueries.js
var I4 = 1e5;
var A3 = class {
  constructor(e7, t6, i6, s8, r7, n10, o6, a8, h5 = {}) {
    this._indexSR = e7, this._renderCoordsHelper = t6, this.clippingArea = r7, this._elevationProvider = n10, this._viewingMode = o6, this._options = h5, this._frustum = H(), this._useFrustumCulling = false, this._poi = n4(), this.minDistance = 1 / 0, this.maxDistance = 0, this.maxLodLevel = 2, this._tmpObb = E2(), this._tmp1 = n4(), this._tmp2 = n4(), this._tmp3 = n4(), this._tmp0 = n4(), this._screenspaceErrorBias = h5.screenspaceErrorBias || 1, this._progressiveLoadFactor = h5.progressiveLoadFactor || 1, this.updateCamera(i6, s8), this.engineSR = this._renderCoordsHelper.spatialReference, this.updateElevationInfo(a8), this._tmpPoint = v2(0, 0, 0, e7), this._isECEFOBBInLocalMode = this._indexSR.isWGS84 && (this.engineSR.isWebMercator || T(this.engineSR)), this._indexSREllipsoidRadius = p2(this._indexSR).radius;
  }
  updateElevationInfo(e7) {
    null != e7 ? (this._elevationContext = h3.fromElevationInfo(e7), this._elevationContext.updateFeatureExpressionInfoContext(o5(i5(e7, false)))) : this._elevationContext = null;
  }
  updateCamera(e7, t6) {
    this._useFrustumCulling = t6, t6 && s3(e7.viewMatrix, e7.projectionMatrix, this._frustum), this._screenSizeFactor = 1 / (e7.perScreenPixelRatio / 2), this._camPos = e7.eye, this.minDistance = 1 / 0, this.maxDistance = 0;
  }
  setPointOfInterest(e7) {
    this._poi = e7;
  }
  updateScreenSpaceErrorBias(e7) {
    const t6 = this._screenspaceErrorBias;
    return this._screenspaceErrorBias = e7, t6;
  }
  updateClippingArea(e7) {
    this.clippingArea = e7;
  }
  getElevationRange(i6) {
    if (t(this._elevationContext))
      return null;
    const s8 = i6.mbs[0], r7 = i6.mbs[1], n10 = i6.mbs[2], o6 = i6.mbs[3], a8 = "relative-to-scene" === this._elevationContext.mode ? "scene" : "ground";
    if (this._elevationProvider.getSphereElevationBounds)
      return this._elevationProvider.getSphereElevationBounds(s8, r7, n10, o6, this._indexSR, a8);
    const h5 = this._elevationProvider.getElevation(s8, r7, n10, this._indexSR, a8);
    return r(h5) ? { min: h5, max: h5 } : null;
  }
  getRenderMbs(e7) {
    const t6 = e7.renderMbs;
    return ct(t6) || (a2(t6, e7.mbs), this._elevationContext && t6[3] < I4 && (this._tmpPoint.x = t6[0], this._tmpPoint.y = t6[1], this._tmpPoint.z = t6[2], t6[2] = m5(this._tmpPoint, this._elevationProvider, this._elevationContext, this._renderCoordsHelper)), bn(t6, this._indexSR, t6, this.engineSR)), t6;
  }
  getVisibilityObb(i6) {
    if (r(i6.visibilityObb))
      return i6.visibilityObb;
    const s8 = i6.serviceObb, r7 = 0.01 * this._indexSREllipsoidRadius;
    return t(s8) || !st(s8) || this._isECEFOBBInLocalMode && s8.halfSize.some((e7) => e7 > r7) ? null : (i6.serviceObbInRenderSR = this._computeRenderObb(s8, i6.serviceObbInRenderSR, i6.mbs[3], i6.elevationRange), i6.serviceObbInRenderSR);
  }
  _computeRenderObb(i6, s8, r7, n10) {
    if (t(s8))
      s8 = E2();
    else if (st(s8))
      return s8;
    let o6 = 0, a8 = 0;
    if (this._elevationContext && r(n10) && Number.isFinite(n10.min))
      switch (this._elevationContext.mode) {
        case "relative-to-ground":
          o6 = this._elevationContext.geometryZWithOffset(i6.center[2], this._renderCoordsHelper) + n10.min - i6.center[2], a8 = n10.max - n10.min;
          break;
        case "on-the-ground":
          o6 = n10.min - i6.center[2], a8 = n10.max - n10.min;
      }
    else
      this._elevationContext && r7 < I4 && (this._tmpPoint.x = i6.center[0], this._tmpPoint.y = i6.center[1], this._tmpPoint.z = i6.center[2], o6 = m5(this._tmpPoint, this._elevationProvider, this._elevationContext, this._renderCoordsHelper) - i6.center[2]);
    return a8 > 0 ? (Be(i6, this._indexSR, this._tmpObb, this.engineSR, o6), Pe(this._tmpObb, 0, a8, this._viewingMode, s8)) : Be(i6, this._indexSR, s8, this.engineSR, o6), s8;
  }
  isNodeVisible(e7) {
    const i6 = this.getRenderMbs(e7);
    if (!this._isMBSinClippingArea(i6))
      return false;
    if (!this._useFrustumCulling)
      return true;
    const s8 = this.getVisibilityObb(e7);
    return r(s8) ? O2(s8, this._frustum) : P2(this._frustum, C2(i6));
  }
  isGeometryVisible(e7) {
    if (!this._useFrustumCulling)
      return true;
    const i6 = e7.geometryObb;
    return r(i6) ? O2(i6, this._frustum) : this.isNodeVisible(e7);
  }
  _isMBSinClippingArea(t6) {
    return !!t(this.clippingArea) || me(this.clippingArea, t6) !== he.OUTSIDE;
  }
  _screenSpaceDiameterMbs(e7, t6) {
    const s8 = this.getRenderMbs(e7), r7 = Math.sqrt(p3(s8, this._camPos)), n10 = r7 - s8[3];
    return this._updateMinMaxDistance(r7), n10 < 0 ? 0.5 * Number.MAX_VALUE : t6 / n10 * this._screenSizeFactor;
  }
  calcCameraDistance(e7) {
    return this.calcCameraDistanceToCenter(e7) - this.getRenderMbs(e7)[3];
  }
  calcCameraDistanceToCenter(e7) {
    const t6 = this.getRenderMbs(e7), i6 = x(t6, this._camPos);
    return this._updateMinMaxDistance(i6), i6;
  }
  calcAngleDependentLoD(e7) {
    const t6 = this.getRenderMbs(e7), i6 = t6[3], n10 = (Math.abs(t6[0] * (t6[0] - this._camPos[0]) + t6[1] * (t6[1] - this._camPos[1]) + t6[2] * (t6[2] - this._camPos[2])) / s2(t6) + i6) / x(t6, this._camPos);
    return Math.min(1, n10);
  }
  hasLOD(e7) {
    return e7.lodMetric !== a4.None;
  }
  _getDistancePlanarMode(e7, t6) {
    const i6 = e7[0] - t6[0], s8 = e7[1] - t6[1], r7 = e7[2] - t6[2], n10 = i6 * i6 + s8 * s8, o6 = t6[3];
    if (n10 <= o6 * o6)
      return Math.abs(r7);
    const a8 = Math.sqrt(n10) - o6;
    return Math.sqrt(r7 * r7 + a8 * a8);
  }
  _getDistanceGlobeMode(e7, t6) {
    const m6 = s2(t6), p7 = s2(e7) - m6;
    q(this._tmp0, e7, P(e7, t6) / v(e7));
    const l2 = p3(t6, this._tmp0), _ = t6[3];
    if (l2 <= _ * _)
      return Math.abs(p7);
    {
      const i6 = q(this._tmp0, t6, 1 / m6), a8 = m6, l3 = _ * _ / 2 / a8, u6 = q(this._tmp1, i6, a8 - l3), d5 = e7, g4 = e3(this._tmp2, d5, u6), b4 = e3(this._tmp2, g4, q(this._tmp3, i6, P(i6, g4))), v3 = u(this._tmp2, u6, q(this._tmp2, b4, _ / s2(b4)));
      let x5 = x(d5, v3);
      if (p7 >= 2e5) {
        const e8 = e3(this._tmp1, d5, v3);
        let t7 = P(e8, i6) / s2(e8);
        t7 < 0.08 && (t7 = 1e-4), x5 /= t7;
      }
      return x5;
    }
  }
  _getDistance(e7, t6) {
    return this.engineSR === O(this.engineSR) ? this._getDistanceGlobeMode(e7, t6) : this._getDistancePlanarMode(e7, t6);
  }
  _updateMinMaxDistance(e7) {
    e7 > 0 ? (this.minDistance = Math.min(this.minDistance, e7), this.maxDistance = Math.max(this.maxDistance, e7)) : (this.minDistance = 0, this.maxDistance = Math.max(this.maxDistance, -e7));
  }
  getLodLevel(e7) {
    if (e7.lodMetric === a4.None)
      return 0;
    if (0 === e7.childCount)
      return this.maxLodLevel;
    if (this._useFrustumCulling && this._progressiveLoadFactor < 1) {
      const t6 = this._progressiveLoadFactor * this._screenspaceErrorBias, i6 = this._screenspaceErrorBias;
      return this.evaluateLODmetric(e7, t6) ? this.evaluateLODmetric(e7, i6) ? 2 : 1 : 0;
    }
    return this.evaluateLODmetric(e7, this._screenspaceErrorBias) ? this.maxLodLevel : 0;
  }
  evaluateLODmetric(e7, t6) {
    switch (e7.lodMetric) {
      case a4.ScreenSpaceRelative: {
        const i6 = this.getRenderMbs(e7), s8 = this._getDistance(this._camPos, i6), r7 = 2 * s8 / this._screenSizeFactor, n10 = s8 + i6[3];
        return this._updateMinMaxDistance(n10), e7.maxError * t6 <= r7;
      }
      case a4.MaxScreenThreshold: {
        let i6 = this._screenSpaceDiameterMbs(e7, e7.mbs[3] * t6);
        return this._options.angleDependentLoD && (i6 *= this.calcAngleDependentLoD(e7)), i6 < e7.maxError;
      }
      case a4.RemovedFeatureDiameter:
        return this._screenSpaceDiameterMbs(e7, e7.maxError) * t6 < 10;
      case a4.DistanceRangeFromDefaultCamera:
        return this.calcCameraDistance(e7) > e7.maxError * t6;
    }
    return false;
  }
  distToPOI(e7) {
    const t6 = this.getRenderMbs(e7);
    return x(t6, this._poi) - t6[3];
  }
  distCameraToPOI() {
    return x(this._camPos, this._poi);
  }
};

// node_modules/@arcgis/core/layers/graphics/controllers/I3SOnDemandController.js
var Q2 = s.getLogger("esri.layers.graphics.controllers.I3SOnDemandController");
var T3 = 100;
var E5 = 2;
var H2 = 1e4;
var B = 1e-4;
var k2 = 1.2;
var R3 = 500;
var z = 1.5;
var K = class extends m4(y2) {
  constructor(e7) {
    super(e7), this.screenSizeFactor = 0, this.featureTarget = 5e4, this.fixedFeatureTarget = false, this.updating = true, this.updatingProgress = 1, this.leavesReached = false, this.scaleVisibilityEnabled = true, this._featureLOD = 1, this._stableFeatureLOD = false, this._isIdle = false, this._cameraDirty = true, this._invisibleDirty = false, this._newLoadingNodes = new n({ deallocator: null }), this._loadedNodeScales = /* @__PURE__ */ new Map(), this._modificationsNodeFilteringArray = new n(), this._downloadingCount = 0, this._loadingNodes = /* @__PURE__ */ new Map(), this._updatingNodes = /* @__PURE__ */ new Map(), this._progressMaxNumNodes = 1, this._requiredAttributes = new Array(), this._requiredAttributesDirty = true, this._updatesDisabled = false, this.disableIDBCache = false, this._disableMemCache = false, this._restartNodeLoading = false, this._fields = null, this._attributeStorageInfo = null, this._handles = new u2(), this._idleQueue = new i2(), this._elevationUpdateNodes = new n({ deallocator: null }), this._errorCount = 0;
  }
  get isMeshPyramid() {
    return "mesh-pyramids" === this.layer.profile || "MeshPyramid" === this.layer.store.lodType;
  }
  get isGraphics3D() {
    return "points" === this.layer.profile;
  }
  get useMaximumNumberOfFeatures() {
    return !this.isMeshPyramid && (t(this.layer.priority) || "High" === this.layer.priority);
  }
  get indexStreamController() {
    const e7 = this.layerView.view.resourceController.createStreamDataRequester(A2.I3S_INDEX);
    return new r6(e7, this.layer.apiKey);
  }
  get dataStreamController() {
    const e7 = this.layerView.view.resourceController.createStreamDataRequester(A2.I3S_DATA);
    return new r6(e7, this.layer.apiKey);
  }
  get crsVertex() {
    return Re(this.layer);
  }
  get crsIndex() {
    return ve(this.layer);
  }
  get layer() {
    return this.layerView.i3slayer;
  }
  get rootNodeVisible() {
    if (r(this._index)) {
      const e7 = this._index.rootNode;
      if (r(e7))
        return this._updateViewData(), this._index.isNodeVisible(e7.index);
    }
    return true;
  }
  get index() {
    return this._index;
  }
  initialize() {
    const { layerView: e7, layer: t6 } = this;
    this._disableMemCache = !e7.loadCachedGPUData || !e7.addCachedGPUData, this._lodHandling = new t5(e7), this._defaultGeometrySchema = t6.store.defaultGeometrySchema, this.disableIDBCache = a("disable-feature:idb-cache"), "fields" in t6 && (this._fields = t6.fields, this._attributeStorageInfo = t6.attributeStorageInfo), this.addResolvingPromise(Promise.all([t6.indexInfo, t6.when(), e7.when()]).then(([i6]) => {
      if (this.destroyed || !e7 || e7.destroyed)
        return;
      const { view: s8 } = e7, { resourceController: r7 } = s8;
      this._setClippingArea(s8.clippingArea), this.own([l(() => {
        var _a, _b;
        return (_b = (_a = s8 == null ? void 0 : s8.pointsOfInterest) == null ? void 0 : _a.focus) == null ? void 0 : _b.renderLocation;
      }, (e8) => this._pointOfInterestChanged(e8), h), l(() => r7.memoryController.memoryFactor, () => this._setCameraDirty(), U), l(() => e7.suspended, (e8) => {
        const t7 = e8 ? () => this._updateViewData() : () => this._updateIdleState(true), i7 = e8 ? () => {
        } : () => this._updateIdleState(false);
        this._idleStateCallbacks ? (e8 && this.cancelNodeLoading(), this.restartNodeLoading(), this._idleStateCallbacks.idleBegin = t7, this._idleStateCallbacks.idleEnd = i7) : this._idleStateCallbacks = r7.scheduler.registerIdleStateCallbacks(t7, i7);
      }, h), n9(e7.view.resourceController.scheduler, { update: (e8, t7) => this._frame(e8, t7), needsUpdate: () => this.updating }), l(() => e7.uncompressedTextureDownsamplingEnabled, () => this.restartNodeLoading()), l(() => [this.featureTarget, this.fixedFeatureTarget], () => {
        this._setCameraDirty(), this._stableFeatureLOD = false;
      }), l(() => {
        var _a;
        return (_a = s8.state) == null ? void 0 : _a.contentCamera;
      }, () => this._setCameraDirty()), l(() => t6.elevationInfo, (e8) => this._elevationInfoChanged(e8)), l(() => t6.effectiveScaleRange, () => this._scaleBoundsChanged()), l(() => e7.lodFactor, () => this._setCameraDirty()), l(() => e7.availableFields, () => this._requiredFieldsChange()), l(() => e7.holeFilling, (e8) => r(this._index) && (this._index.holeFilling = e8))]), this._updateScaleHandles(), this._viewportQueries = new A3(this.crsIndex, s8.renderCoordsHelper, s8.state.contentCamera, !s8.state.fixedContentCamera || this.isGraphics3D, this._clippingArea, this.isMeshPyramid ? s8.basemapTerrain : s8.elevationProvider, o2(s8.viewingMode), this.layer.elevationInfo, { progressiveLoadFactor: this._getProgressiveLoadFactor(), screenspaceErrorBias: this.lod, angleDependentLoD: this.lod < 0.5 }), this._index = new p4(t6, i6, this.indexStreamController, this._viewportQueries, Q2, e7.holeFilling, (t7) => e7.isNodeLoaded(t7), (t7) => e7.isNodeReloading(t7), (e8) => this._shouldLoadNode(e8), (e8) => this._enableFromGPUCache(e8, c.Leaf), (e8) => this._needsUpdate(e8), () => !this.indexStreamController.busy, (t7) => e7.computeVisibilityObb ? e7.computeVisibilityObb(t7) : null, (e7 == null ? void 0 : e7.computeNodeFiltering) ? (t7) => e7.computeNodeFiltering(t7) : void 0), this._index.updateElevationInfo(this.layer.elevationInfo, this.isMeshPyramid), this._index.imModificationsChanged(!!e7.hasModifications), this._startNodeLoading();
    })), this._tmpPoint = v2(0, 0, 0, this.crsIndex);
  }
  updateNodeModificationStatus(e7) {
    const t6 = this._index, i6 = this.layerView;
    r(t6) && (i6 == null ? void 0 : i6.updateNodeModificationStatus) && (this._modificationsNodeFilteringArray.clear(), e7.forAll((e8) => {
      const i7 = t6.getNode(e8);
      r(i7) && this._modificationsNodeFilteringArray.push(i7);
    }), i6.updateNodeModificationStatus(this._modificationsNodeFilteringArray), this._invisibleDirty = true);
  }
  destroy() {
    this.cancelNodeLoading(), this._idleStateCallbacks && (this._isIdle = false, this._idleStateCallbacks.remove(), this._idleStateCallbacks = null), this._handles.destroy(), this._nodeLoader = null, X.prune(), r($) && ($.hide(), $ = null);
  }
  _getRequiredAttributes() {
    if (null == this._attributeStorageInfo || !this._fields || !this.layerView.availableFields)
      return [];
    const e7 = this._attributeStorageInfo, t6 = this._fields, i6 = this.layer.objectIdField;
    return this.layerView.availableFields.map((i7) => {
      const s8 = W(e7, i7), r7 = W(t6, i7);
      return s8 >= 0 && r7 >= 0 ? { index: s8, name: t6[r7].name, field: t6[r7], attributeStorageInfo: e7[s8] } : null;
    }).filter((e8) => null != e8 && e8.name !== i6);
  }
  _requiredFieldsChange() {
    const e7 = this._getRequiredAttributes();
    J(this._requiredAttributes, e7) || (this._requiredAttributes = e7, this._requiredAttributesDirty = false, this.restartNodeLoading());
  }
  requestUpdate() {
    this._requiredAttributesDirty = true, this.restartNodeLoading();
  }
  _setClippingArea(e7) {
    const t6 = u3();
    e5(e7, t6, this.layerView.view.renderSpatialReference) ? this._clippingArea = t6 : this._clippingArea = null;
  }
  _pointOfInterestChanged(e7) {
    r(this._viewportQueries) && (this._viewportQueries.setPointOfInterest(e7), r(this._index) && (this._index.progressiveLoadPenalty = Y.distancePenalty * this._viewportQueries.distCameraToPOI(), this._index.requestUpdate()));
  }
  updateClippingArea(e7) {
    this._setClippingArea(e7), r(this._viewportQueries) && r(this._index) && (this._viewportQueries.updateClippingArea(this._clippingArea), this._index.invalidateVisibilityCache()), this._setCameraDirty();
  }
  _setCameraDirty() {
    this._cameraDirty = true, this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating();
  }
  updateElevationChanged(e7, t6) {
    const i6 = this._index;
    if (t(i6) || t(i6.rootNode))
      return null;
    const s8 = this._elevationUpdateNodes;
    return s8.clear(), se(e7, t6, i6.rootNode, this.crsIndex, i6, (e8) => s8.push(e8.index)), s8.length && (s8.forAll((e8) => i6.updateElevationChanged(e8)), this._setCameraDirty()), s8;
  }
  getParentIndex(e7) {
    return r(this._index) && this._index.getParentIndex(e7);
  }
  removeAllGeometryObbs() {
    r(this._index) && this._index.removeAllGeometryObbs();
  }
  _elevationInfoChanged(e7) {
    t(this._index) || (this._index.updateElevationInfo(e7, this.isMeshPyramid), this._setCameraDirty());
  }
  _updateScaleHandles() {
    const e7 = "scale-bounds";
    this._handles.remove(e7), this.areScaleBoundsActive && this._handles.add(this.layerView.view.basemapTerrain.on("scale-change", (e8) => this._scaleUpdateHandler(e8)), e7);
  }
  _scaleBoundsChanged() {
    this.areScaleBoundsActive || this._loadedNodeScales.clear(), this._updateScaleHandles(), this._setCameraDirty();
  }
  _scaleUpdateHandler(e7) {
    this._updateScaleInBoundingRect(e7.extent, e7.spatialReference), this._setCameraDirty();
  }
  _updateScaleInBoundingRect(e7, t6) {
    const i6 = this._index;
    if (t(i6))
      return;
    const s8 = i6.rootNode;
    !t(s8) && zn(e7, t6, Z, this.crsIndex) && this._loadedNodeScales.forEach((e8, t7) => {
      const s9 = i6.getNode(t7);
      r(s9) && g2(Z, s9.mbs) && this._loadedNodeScales.set(t7, this._computeScale(s9));
    });
  }
  restartNodeLoading() {
    this._restartNodeLoading = true, this.cancelNodeLoading(), this._evaluateUpdating();
  }
  schedule(e7, t6) {
    return this._idleQueue.push(e7, t6);
  }
  reschedule(e7, t6) {
    return this._idleQueue.unshift(e7, t6);
  }
  get isIntegratedMesh() {
    return "integrated-mesh" === this.layer.type;
  }
  get areScaleBoundsActive() {
    const { minScale: e7, maxScale: t6 } = r2(this.layer);
    return this.scaleVisibilityEnabled && (e7 > 0 || t6 > 0);
  }
  get unloadedMemoryEstimate() {
    return t(this._index) || this.layerView.suspended ? 0 : this._index.getUnloadedMemoryEstimate() * this.lodDropFactor;
  }
  get indexDepth() {
    return r(this._index) ? this._index.maxLevel : 0;
  }
  set disableMemCache(e7) {
    this.layerView.loadCachedGPUData && this.layerView.addCachedGPUData || (this._disableMemCache = true), this._disableMemCache = e7;
  }
  _frame(e7, t6) {
    return this.layerView.suspended ? (this._updateViewData(), this._evaluateUpdating(), -1 / 0) : !this.layerView.visible || t(this._index) ? -1 / 0 : (this._processLogError(e7, t6), this._index.getPriority());
  }
  _processLogError(e7, t6) {
    try {
      this._process(e7, t6);
    } catch (i6) {
      this._errorCount < 50 ? Q2.error("Error during processing: " + i6) : 50 === this._errorCount && Q2.error("Too many errors for this layer. Further errors will not be displayed."), this._errorCount++;
    }
  }
  _process(e7, t6) {
    this._restartNodeLoading && this._startNodeLoading(), null == this._nodeLoader || t(this._index) || (this._updateViewData(), this._invisibleDirty && this._removeInvisibleNodes(e7) && (this._invisibleDirty = false), this.isIntegratedMesh && (e7.enabled = false), e7.run(() => this._processIndex(e7)), this._updateFeatureLOD(), e7.run(() => this._processCache(e7)), this.isIntegratedMesh && (e7.enabled = true), e7.run(() => this._processNodes(e7, t6)), this._idleQueue.runTask(e7), e7.run(() => this._prefetchIndex()), t6.numIndexLoading += this._index.getIndexLoading(), t6.numNodesLoading += this._downloadingCount, e7.run(() => this._lodHandling.lodGlobalHandling(e7)), this._evaluateUpdating());
  }
  _processIndex(e7) {
    if (t(this._index))
      return false;
    if (this._index.dirty) {
      this._newLoadingNodes.clear(), this._index.update(Array.from(this._loadingNodes.keys()), e7, (e8) => this.updateNodeModificationStatus(e8)), this._disableMemCache || (this._newLoadingNodes.pushArray(this._index.updates.add.data, this._index.updates.add.length), this._newLoadingNodes.pushArray(this._index.updates.missing.data, this._index.updates.missing.length));
      const t6 = this._index.featureEstimate.leavesReached;
      this._index.isLoading() || t6 === this._get("leavesReached") || this._set("leavesReached", t6);
    }
    return this._index.load();
  }
  _prefetchIndex() {
    return !(t(this._index) || this._loadingNodes.size > 0 || this._index.updates.add.length > 0) && this._index.prefetch();
  }
  _updateFeatureLOD() {
    if (!this.useMaximumNumberOfFeatures || t(this._index) || t(this._viewportQueries))
      return;
    const e7 = !this._index.isLoading(), t6 = this.featureTarget * this.baseLOD, i6 = this._index.featureEstimate;
    if (i6.estimate = i6.estimate || t6 / 2, this._index.getIndexMissing() > R3) {
      if (this._featureLOD <= B)
        return;
      this._featureLOD /= z, this._stableFeatureLOD = false;
    } else if (e7 && i6.estimate < t6) {
      if (i6.leavesReached || this._featureLOD >= H2 || this._stableFeatureLOD)
        return;
      const e8 = Math.min(10, Math.max(t6 / i6.estimate, 1.001));
      this._featureLOD *= e8;
      const s8 = this.lod, r7 = this._index.checkFeatureTarget(t6, s8);
      r7 !== s8 && (this._featureLOD = r7 / this.baseLOD, this._stableFeatureLOD = true);
    } else {
      if (!(i6.estimate > t6 * k2 || e7 && i6.estimate > t6))
        return;
      if (this._featureLOD <= B)
        return;
      this._featureLOD /= 1 + 0.25 * (i6.estimate / t6 - 1), this._stableFeatureLOD = false;
    }
    this._featureLOD = Math.min(H2, Math.max(B, this._featureLOD)), this._viewportQueries.updateScreenSpaceErrorBias(this.lod), this._index.requestUpdate();
  }
  _processCache(e7) {
    const t6 = this._index;
    if (t(t6))
      return false;
    for (; this._newLoadingNodes.length > 0 && !e7.done; ) {
      const i6 = this._newLoadingNodes.pop();
      for (let s8 = t6.getParent(i6); r(s8) && (!this.layerView.isNodeLoaded(s8.index) && this._isNodeInScaleBounds(s8)); s8 = t6.getParent(s8.index))
        if (this._enableFromGPUCache(s8, c.Hole)) {
          e7.madeProgress();
          break;
        }
    }
    return e7.hasProgressed;
  }
  _processNodes(e7, t6) {
    if (t(this._index))
      return false;
    let i6 = (this._isIdle ? T3 : E5) - this._loadingNodes.size;
    const s8 = this._index.updates;
    for (s8.cancel.forEach(this._cancelNode, this), s8.cancel = []; s8.remove.length > 0 && !e7.done; )
      this.layerView.removeNode(s8.remove.pop()), e7.madeProgress();
    for (; s8.update.length > 0 && !e7.done; ) {
      const t7 = this._index.getNode(s8.update.pop());
      r(t7) && (this._updateLoadedNode(t7), e7.madeProgress());
    }
    for (; s8.add.length > 0 && !e7.done && i6 > 0; ) {
      --i6;
      const r7 = this._index.getNode(s8.add.back());
      if (t(r7) || r7.cacheState !== s4.Cached && !this._hasNodeLoadToken(t6))
        break;
      s8.add.pop(), this._loadNode(r7), e7.madeProgress();
    }
    return e7.hasProgressed;
  }
  _cancelAllNodes() {
    this._loadingNodes.forEach((e7) => e7.abort()), this._loadingNodes.clear(), this._updatingNodes.forEach((e7) => e7.abort()), this._updatingNodes.clear();
  }
  _cancelNode(e7) {
    const t6 = this._loadingNodes.get(e7);
    t6 && (t6.abort(), this._loadingNodes.delete(e7));
  }
  _hasNodeLoadToken(e7) {
    return !(!this._isIdle && e7.numNodesLoading + this._loadingNodes.size >= E5) && (this._downloadingCount < I2 && !this.dataStreamController.busy);
  }
  _evaluateUpdating() {
    let e7 = false, t6 = 0;
    if (this.layerView.suspended)
      e7 = this._cameraDirty, t6 = e7 ? 0 : 1;
    else {
      const i6 = (r(this._index) ? this._index.getIndexMissing() : 0) + 3 * (r(this._index) ? this._index.updates.add.length : 0) + 2 * this._loadingNodes.size;
      e7 = !!(i6 > 0 || this._updatingNodes.size > 0 || this._restartNodeLoading || this._cameraDirty || this._idleQueue.running || this._lodHandling && this._lodHandling.requiresLODGlobalHandling), 0 === i6 && (this._progressMaxNumNodes = 1), this._progressMaxNumNodes = Math.max(i6, this._progressMaxNumNodes), t6 = 1 - i6 / this._progressMaxNumNodes;
    }
    this.updating = e7, this.updatingProgress = t6;
  }
  _updateViewData() {
    if (!this._cameraDirty || t(this._index) || t(this._viewportQueries))
      return;
    const e7 = this.layerView.view, { contentCamera: t6, fixedContentCamera: i6 } = e7.state;
    this.screenSizeFactor = 1 / (t6.perScreenPixelRatio / 2), this._viewportQueries.updateCamera(t6, !i6 || this.isGraphics3D), this._viewportQueries.setPointOfInterest(e7.pointsOfInterest.focus.renderLocation), this._viewportQueries.updateScreenSpaceErrorBias(this.lod), this._index.invalidateVisibilityCache(), this._index.progressiveLoadPenalty = Y.distancePenalty * this._viewportQueries.distCameraToPOI(), this._index.requestUpdate(), this._stableFeatureLOD = false, this._invisibleDirty = true, this._cameraDirty = false, this.notifyChange("rootNodeVisible");
  }
  _getProgressiveLoadFactor() {
    return this.layerView.view.resourceController.memoryController.memoryFactor < 1 ? 1 : this.layerView.progressiveLoadFactor;
  }
  get lod() {
    return this._featureLOD * this.baseLOD;
  }
  get baseLOD() {
    const e7 = this.layerView.lodFactor, t6 = this.layerView.view.resourceController.memoryController.memoryFactor;
    return this.fixedFeatureTarget ? 1 : (e7 > 0 ? e7 : 1) * t6;
  }
  get lodDropFactor() {
    if (this.fixedFeatureTarget)
      return 1;
    const e7 = this.layerView.view.resourceController.memoryController;
    return (Math.min(e7.memoryFactor, 0.5) - e7.minQuality) / (0.5 - e7.minQuality);
  }
  isGeometryVisible(e7) {
    return r(this._index) && this._index.isGeometryVisible(e7.index);
  }
  updateVisibility(e7) {
    r(this._index) && this._index.invalidateNodeVisibilityCache(e7);
  }
  invalidateGeometryVisibility(e7) {
    r(this._index) && this._index.invalidateGeometryVisibility(e7);
  }
  invalidateVisibilityObbs() {
    r(this._index) && this._index.invalidateVisibilityObbs();
  }
  modificationsChanged() {
    r(this._index) && this._index.imModificationsChanged(!!this.layerView.hasModifications), this._invisibleDirty = true;
  }
  _shouldLoadNode(e7) {
    return !(!this._lodHandling.shouldLoadNode(e7) || this._shouldDropNode(e7)) && (!(t(this._index) || !this._index.isGeometryVisible(e7.index)) && this._isNodeInScaleBounds(e7));
  }
  _shouldDropNode(e7) {
    if (t(this._viewportQueries))
      return false;
    const t6 = this.lodDropFactor;
    if (t6 >= 1 || !this._lodHandling.hasNoVisibleChildren(e7))
      return false;
    return Math.abs(this._viewportQueries.calcCameraDistanceToCenter(e7)) - this._viewportQueries.minDistance > (this._viewportQueries.maxDistance - this._viewportQueries.minDistance) * t6;
  }
  _startNodeLoading() {
    this._restartNodeLoading = false;
    const e7 = this._index;
    if (this._updatesDisabled || t(e7) || t(this._viewportQueries))
      return;
    this._updateViewData(), this._requiredAttributesDirty && (this._requiredAttributes = this._getRequiredAttributes(), this._requiredAttributesDirty = false);
    const t6 = { textureEncodings: this.layerView.supportedTextureEncodings, uncompressedTextureDownsamplingEnabled: this.layerView.uncompressedTextureDownsamplingEnabled, textureUsageMask: this.layerView.rendererTextureUsage, loadFeatureData: this.useMaximumNumberOfFeatures };
    this._nodeLoader = new g3(this.layer, this.dataStreamController, Q2, this._defaultGeometrySchema, this._requiredAttributes, t6), e7.requestUpdate(), this._lodHandling.startNodeLoading((e8) => this._isNodeInScaleBounds(e8), (e8, t7) => this._removeNodes(e8, t7, ee.fadeout), e7, { maxLodLevel: this._viewportQueries.maxLodLevel }), this._evaluateUpdating();
  }
  isNodeLoading() {
    return null != this._nodeLoader && null != this._index;
  }
  cancelNodeLoading() {
    this.isNodeLoading() && (this.indexStreamController.cancelAll(), this.dataStreamController.cancelAll(), this._idleQueue.cancelAll(), this._cancelAllNodes(), this._nodeLoader = null, this._evaluateUpdating());
  }
  _removeInvisibleNodes(e7) {
    const t6 = this._index;
    if (t(t6) || t(this._viewportQueries))
      return false;
    X.clear(), this.layerView.getLoadedNodeIndices(X);
    const i6 = 0 === this._viewportQueries.maxDistance, s8 = i6 ? () => false : (e8) => this._shouldDropNode(e8);
    return X.filterInPlace((e8) => {
      const i7 = t6.getNode(e8);
      return t(i7) || !t6.isGeometryVisible(e8) || s8(i7) || !this._isNodeInScaleBounds(i7);
    }), X.length > 0 && this._lodHandling.setLodGlobalDirty(), this._removeNodes(X, e7, ee.pop), !(i6 && this.lodDropFactor < 1) && (0 === X.length || (X.clear(), false));
  }
  markNodeToRemove(e7) {
    X.push(e7);
  }
  removeMarkedNodes() {
    this._removeNodes(X, w, ee.pop);
  }
  _removeNodes(e7, t6, i6) {
    const s8 = e7.length;
    if (0 !== s8 && !t6.done) {
      for (r(this._index) && this._index.requestUpdate(); e7.length > 0 && !t6.done; ) {
        const s9 = e7.pop(), r7 = this._index;
        i6 === ee.fadeout && this.layerView.nodeFadeoutEnabled && r(r7) && r7.isGeometryVisible(s9) ? this.layerView.fadeNode(s9, a7.FadeOut, true) : this.layerView.removeNode(s9), t6.madeProgress();
      }
      if (this._loadedNodeScales.size > 0)
        for (let t7 = e7.length; t7 < s8; t7++) {
          const i7 = e7.data[t7];
          this._loadedNodeScales.delete(i7);
        }
    }
  }
  _needsUpdate(e7) {
    if (!e7.resources.hasFeatureData || this._updatingNodes.has(e7.index))
      return false;
    const t6 = this.layerView.getLoadedAttributes(e7.index);
    return null != t6 && t6 !== this._requiredAttributes;
  }
  _updateLoadedNode(e7) {
    const t6 = new AbortController();
    this._updatingNodes.set(e7.index, t6);
    (J(this.layerView.getLoadedAttributes(e7.index), this._requiredAttributes) ? Promise.resolve(this.layerView.getAttributeData(e7.index)) : this._nodeLoader.loadAttributes(e7, this._requiredAttributes, t6.signal)).then((i6) => this.schedule(() => this.layerView.updateAttributes(e7.index, { loadedAttributes: this._requiredAttributes, attributeData: i6 }, t6.signal), t6.signal)).catch((i6) => {
      if (!g(i6))
        return this.layerView.updateAttributes(e7.index, { loadedAttributes: this._requiredAttributes, attributeData: {} }, t6.signal);
    }).catch(() => {
    }).then(() => {
      this._updatingNodes.delete(e7.index), this._evaluateUpdating();
    }), this._evaluateUpdating();
  }
  _loadNode(e7) {
    if (this._loadingNodes.has(e7.index))
      return void Q2.error("already loading node " + e7.index);
    const t6 = new AbortController();
    this._loadingNodes.set(e7.index, t6), this._evaluateUpdating(), this._loadAndAddNode(e7, t6.signal).then((i6) => {
      i6 && r(this._index) && this._loadingNodes.get(e7.index) === t6 && (this._loadingNodes.delete(e7.index), this._index.requestUpdate());
    }).catch((e8) => {
      if (!g(e8))
        throw e8;
    }).finally(() => {
      this._loadingNodes.get(e7.index) === t6 && this._loadingNodes.delete(e7.index), this._evaluateUpdating();
    });
  }
  _loadAndAddNode(e7, t6) {
    return e7.cacheState === s4.Uncached ? this._loadUncached(e7, t6).then(() => false) : this._loadCached(e7, t6).then((t7) => !t7 && (e7.cacheState = s4.Uncached, true)).catch((t7) => !g(t7) && (e7.cacheState = s4.Uncached, true));
  }
  _enableFromGPUCache(e7, t6) {
    if (this._disableMemCache || t(this._index))
      return false;
    if (t6 === c.Hole && !this._index.useNodeAsHole(e7.index))
      return true;
    const i6 = this._loadCachedGPUData(e7);
    return !!i6 && (this.layerView.addCachedGPUData(e7, i6, t6), this._nodeAdded(), true);
  }
  _loadCachedGPUData(e7) {
    const t6 = this.layerView.loadCachedGPUData(e7);
    return r(t6) && r(t6.attributeInfo) && J(t6.attributeInfo.loadedAttributes, this._requiredAttributes) ? t6 : (this.layerView.deleteCachedGPUData(t6), null);
  }
  _nodeAdded() {
    r(this._index) && this._index.requestUpdate(), this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating();
  }
  updateLoadStatus(e7, t6) {
    const i6 = this._index;
    r(i6) && i6.updateChildrenLoaded(e7, t6 ? 1 : -1);
  }
  _loadCached(e7, t6) {
    if (this._enableFromGPUCache(e7, c.Leaf))
      return Promise.resolve(true);
    const i6 = this.layerView;
    return !this.disableIDBCache && i6.loadCachedNodeData && i6.addCachedNodeData ? this.schedule(() => i6.loadCachedNodeData(e7, t6, (t7, i7) => this._nodeLoader.loadTextures(e7, t7, i7)), t6).then((s8) => {
      if (t(s8))
        return false;
      const r7 = this._requiredAttributes;
      return this.reschedule(() => this._nodeLoader.loadAttributes(e7, r7, t6), t6).then((a8) => this.reschedule(() => i6.addCachedNodeData(e7, s8, { loadedAttributes: r7, attributeData: a8 }, t6), t6)).then(() => (this._nodeAdded(), true));
    }) : Promise.resolve(false);
  }
  _loadUncached(e7, t6) {
    return this._downloadingCount++, this._nodeLoader.loadNodeData(e7, t6).catch((e8) => {
      throw this._downloadingCount--, e8;
    }).then((i6) => (this._downloadingCount--, this.schedule(() => this.layerView.addNode(e7, i6, t6), t6))).then(() => {
      this._nodeAdded(), e7.cacheState = s4.Cached;
    }).catch((t7) => {
      if (!g(t7))
        throw Q2.error("#loadNodeData()", this.layer, `Failed to load node '${e7.id}'`, t7), e7.failed = true, r(this._index) && this._index.requestUpdate(), t7;
    });
  }
  _updateIdleState(e7) {
    e7 !== this._isIdle && (this._isIdle = e7, this._evaluateUpdating(), e7 && this._index && r(this._index) && this._index.resetFailedNodes());
  }
  _getScale(e7) {
    if (this._loadedNodeScales.has(e7.index))
      return this._loadedNodeScales.get(e7.index);
    const t6 = this._computeScale(e7);
    return this.layerView.isNodeLoaded(e7.index) && this._loadedNodeScales.set(e7.index, t6), t6;
  }
  _computeScale(e7) {
    this._tmpPoint.x = e7.mbs[0], this._tmpPoint.y = e7.mbs[1], this._tmpPoint.z = e7.mbs[2];
    const t6 = e7.mbs[3];
    return this.layerView.view.basemapTerrain.getSphereScale(this._tmpPoint, t6);
  }
  _isNodeInScaleBounds(e7) {
    if (!this.areScaleBoundsActive)
      return true;
    const t6 = this._getScale(e7), { minScale: i6, maxScale: s8 } = r2(this.layer);
    return c2(t6, i6, s8);
  }
  updateStats(e7) {
    e7.index = r(this._index) ? this._index.size : 0, this.isGraphics3D && (e7.detail = this._featureLOD, e7.target = this.featureTarget * this.baseLOD), r(this._index) && this._index.updateStats(e7);
  }
  get test() {
    const e7 = this;
    return { index: this._index, set disableUpdates(t6) {
      e7._updatesDisabled = t6, t6 ? e7.cancelNodeLoading() : e7.requestUpdate();
    }, set disableIDBCache(t6) {
      e7.disableIDBCache = t6;
    }, set ignoreServiceObb(t6) {
      r(e7._index) && (e7._index.ignoreServiceObb = t6);
    }, shouldLoadNode: (t6) => e7._shouldLoadNode(t6) };
  }
  notifyLODUpdate() {
    this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating(), r(this._index) && this._index.requestUpdate();
  }
  geometryFilterChanged(e7) {
    const t6 = this._index;
    r(t6) && t6.layerFilterChanged(e7), this.requestUpdate();
  }
};
e([d3({ readOnly: true })], K.prototype, "isMeshPyramid", null), e([d3({ readOnly: true })], K.prototype, "isGraphics3D", null), e([d3({ readOnly: true })], K.prototype, "useMaximumNumberOfFeatures", null), e([d3({ readOnly: true })], K.prototype, "indexStreamController", null), e([d3({ readOnly: true })], K.prototype, "dataStreamController", null), e([d3({ readOnly: true })], K.prototype, "crsVertex", null), e([d3({ readOnly: true })], K.prototype, "crsIndex", null), e([d3()], K.prototype, "screenSizeFactor", void 0), e([d3()], K.prototype, "featureTarget", void 0), e([d3()], K.prototype, "fixedFeatureTarget", void 0), e([d3()], K.prototype, "layerView", void 0), e([d3()], K.prototype, "layer", null), e([d3({})], K.prototype, "updating", void 0), e([d3({})], K.prototype, "updatingProgress", void 0), e([d3({ readOnly: true })], K.prototype, "leavesReached", void 0), e([d3({ constructOnly: true })], K.prototype, "scaleVisibilityEnabled", void 0), e([d3({ readOnly: true, dependsOn: [] })], K.prototype, "rootNodeVisible", null), K = e([n3("esri.layers.graphics.controllers.I3SOnDemandController")], K);
var X = new n({ deallocator: null });
var $;
function J(e7, t6) {
  return r(e7) && e7.length === t6.length && e7.every((e8) => W(t6, e8.name) >= 0);
}
function W(e7, t6) {
  const i6 = t6.toLowerCase();
  for (let s8 = 0; s8 < e7.length; s8++)
    if (e7[s8].name.toLowerCase() === i6)
      return s8;
  return -1;
}
var Y = { factorIM: 0.2, factor3dObject: 0.05, distancePenalty: 10 };
var Z = u3();
var ee;
!function(e7) {
  e7[e7.pop = 0] = "pop", e7[e7.fadeout = 1] = "fadeout";
}(ee || (ee = {}));
var te = K;

// node_modules/@arcgis/core/views/3d/support/GraphicsMap.js
var s7 = class extends n5 {
  constructor() {
    super(...arguments), this._map = /* @__PURE__ */ new Map();
  }
  clear() {
    if (this._map.size > 0) {
      const e7 = this.toArray();
      this._map.clear(), this.emit("change", { added: [], removed: e7 });
    }
  }
  get length() {
    return this._map.size;
  }
  get(e7) {
    return this._map.get(e7);
  }
  addMany(e7) {
    if (0 === e7.length)
      return;
    const t6 = /* @__PURE__ */ new Set();
    for (let r7 = 0; r7 < e7.length; r7++) {
      const s9 = e7[r7], o6 = s9.objectId, n10 = this._map.get(o6);
      n10 ? (t6.add(o6), s9 !== n10 && (e7[r7] = n10), ++n10.refCount) : (s9.refCount = 1, this._map.set(o6, s9));
    }
    const s8 = t6.size > 0 ? e7.filter((e8) => !t6.has(e8.objectId)) : e7;
    s8.length > 0 && this.emit("change", { added: s8, removed: [] });
  }
  removeMany(e7) {
    const t6 = [];
    for (const s8 of e7) {
      const e8 = s8.objectId, r7 = this._map.get(e8);
      null != r7 && --r7.refCount <= 0 && (this._map.delete(e8), t6.push(s8));
    }
    t6.length > 0 && this.emit("change", { added: [], removed: t6 });
  }
  removeManyByObjectId(e7) {
    const t6 = [];
    for (const s8 of e7) {
      const e8 = this._map.get(s8);
      null != e8 && --e8.refCount <= 0 && (this._map.delete(s8), t6.push(e8));
    }
    t6.length > 0 && this.emit("change", { added: [], removed: t6 });
  }
  toArray() {
    return [...this._map.values()];
  }
  find(e7) {
    let s8;
    return n2(this._map, (t6) => !!e7(t6) && (s8 = t6, true)), s8;
  }
  forEach(e7) {
    this._map.forEach((t6) => e7(t6));
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SAttributeOverrides.js
var p6 = s.getLogger("esri.views.3d.layers.i3s.I3SAttributeOverrides");
var f2 = class {
  constructor(e7, t6) {
    this.layer = e7, this.warnMaximumChangedObjectsExceeded = false, this.changedObjectIds = /* @__PURE__ */ new Set(), this.pendingFetchAbortController = new AbortController(), this.interactiveEditingSessions = null, this._maximumNumberOfEditOVerrides = j, this.memCache = t6.newCache(`${e7.uid}-attribute-overrides`), this.pendingFetchChangedObjectIds = this._fetchChangedObjectIds(this.pendingFetchAbortController.signal), this.pendingFetchChangedObjectIds.then(() => this.pendingFetchAbortController = null);
  }
  destroy() {
    this.layer = null, this.memCache.destroy(), this.memCache = null, this.pendingFetchAbortController && (this.pendingFetchAbortController.abort(), this.pendingFetchAbortController = null), this.pendingFetchChangedObjectIds = null;
  }
  createInteractiveEditSession(e7) {
    this.changedObjectIds.add(e7), t(this.interactiveEditingSessions) && (this.interactiveEditingSessions = []);
    const s8 = this.interactiveEditingSessions, i6 = new y5(e7, { rollback: () => {
      F(s8, i6), 0 === s8.length && (this.interactiveEditingSessions = null);
    }, commit: (t6) => {
      for (const [s9, i7] of t6)
        this.updateValue(e7, s9, i7);
    } });
    return s8.unshift(i6), i6;
  }
  async apply(e7, t6, s8) {
    if (t(t6))
      return;
    const { loadedAttributes: i6, attributeData: r7 } = t6;
    if (t(i6) || 0 === i6.length || t(r7))
      return;
    if (await y(this.pendingFetchChangedObjectIds, s8), 0 === this.changedObjectIds.size)
      return;
    const a8 = { loadedAttributes: i6, attributeData: r7 }, n10 = this._getOverridesFromCache(e7, a8, this.changedObjectIds), { objectIds: o6, fieldNames: d5 } = n10, h5 = await this._queryOverridesFromAssociatedLayer(o6, d5, s8);
    t(h5) || this._processOverridesFromAssociatedLayer(e7, h5, d5, a8);
  }
  updateValue(e7, t6, s8) {
    this.changedObjectIds.add(e7), this._cacheValue(e7, t6, s8);
  }
  _cacheValue(e7, t6, s8) {
    this.memCache.put(this._getCacheKey(e7, t6), s8, this._memCacheValueSize(s8));
  }
  _getOverridesFromCache(e7, { loadedAttributes: t6, attributeData: s8 }, i6) {
    const r7 = /* @__PURE__ */ new Set(), a8 = new Array();
    for (const o6 of t6)
      a8[o6.index] = s8[o6.name];
    const n10 = /* @__PURE__ */ new Set();
    for (let o6 = 0; o6 < e7.length; o6++) {
      const s9 = e7[o6];
      if (i6.has(s9))
        for (const e8 of t6) {
          const t7 = this._fromCache(s9, e8.index);
          void 0 === t7 ? (r7.add(s9), n10.add(e8.name)) : a8[e8.index][o6] = t7;
        }
    }
    return { objectIds: Array.from(r7), fieldNames: Array.from(n10) };
  }
  _fromCache(e7, t6) {
    const s8 = this._fromInteractiveEditingSession(e7, t6);
    if (void 0 !== s8)
      return s8;
    const i6 = this._getCacheKey(e7, t6);
    return this.memCache.get(i6);
  }
  _fromInteractiveEditingSession(e7, t6) {
    if (!t(this.interactiveEditingSessions))
      for (const s8 of this.interactiveEditingSessions) {
        if (s8.objectId !== e7)
          continue;
        const i6 = s8.get(t6);
        if (void 0 !== i6)
          return i6;
      }
  }
  _getCacheKey(e7, t6) {
    return `${e7}-${t6}`;
  }
  async _queryOverridesFromAssociatedLayer(e7, t6, r7) {
    if (0 === e7.length || 0 === t6.length)
      return null;
    e7 = e7.sort((e8, t7) => e8 - t7), this.warnMaximumChangedObjectsExceeded && (this.warnMaximumChangedObjectsExceeded = false, this._logMaximumObjectsExceededWarning());
    const a8 = e2(this.layer.associatedLayer), n10 = a8.createQuery();
    n10.where = "1=1", n10.returnGeometry = false, n10.outFields = [a8.objectIdField, ...t6], n10.cacheHint = true, n10.objectIds = e7;
    const o6 = a6(a8), c3 = e7.length > o6 ? d(e7, o6).map((e8) => {
      const t7 = n10.clone();
      return t7.objectIds = e8, u4(t4(a8, t7, { signal: r7 }));
    }) : [u4(t4(a8, n10, { signal: r7 }))];
    return (await Promise.all(c3)).reduce((e8, t7) => e8.concat(t7.ok ? t7.value.features : []), []);
  }
  _logMaximumObjectsExceededWarning() {
    let e7 = `The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${m3(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`;
    const t6 = this.layer.portalItem;
    t6 && t6.loaded ? e7 += ` (${t6.portal.url}/home/item.html?id=${t6.id}#settings)` : e7 += ` (${this.layer.parsedUrl.path})`, p6.warn("#queryOverrides()", this.layer.title, `${e7}.`);
  }
  _processOverridesFromAssociatedLayer(e7, t6, s8, { loadedAttributes: i6, attributeData: r7 }) {
    const a8 = e2(this.layer.associatedLayer).objectIdField, n10 = s8.map((e8) => r7[e8]), o6 = new Map(i6.map((e8) => [e8.name, e8.index])), c3 = s8.map((e8) => o6.get(e8)), h5 = new Map(Array.from(e7, (e8, t7) => [e8, t7]));
    for (const d5 of t6) {
      const e8 = d5.attributes[a8];
      for (let t7 = 0; t7 < s8.length; t7++) {
        const i7 = c3[t7], r8 = h5.get(e8), a9 = d5.attributes[s8[t7]];
        n10[t7][r8] = a9, this._cacheValue(e8, i7, a9);
      }
    }
  }
  _memCacheValueSize(e7) {
    return "string" == typeof e7 ? n6(e7) : t2();
  }
  async _fetchChangedObjectIds(t6) {
    var _a, _b, _c;
    const s8 = this.layer;
    if (await s8.load({ signal: t6 }), this.changedObjectIds.clear(), t(s8.associatedLayer) || !((_b = (_a = s8.associatedLayer.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsChangeTracking))
      return;
    const i6 = this._getFetchChangedObjectIdsServerGen();
    if (t(i6))
      return null;
    const a8 = s8.associatedLayer.layerId, n10 = await a3(U2(`${s8.associatedLayer.url}/extractChanges`, { method: "post", query: { f: "json", returnIdsOnly: true, layers: `${a8}`, returnUpdates: true, returnDeletes: false, returnInserts: false, layerServerGens: JSON.stringify([{ id: a8, serverGen: i6 }]) }, timeout: C5, signal: t6 })), o6 = n10.ok && ((_c = n10.value.data) == null ? void 0 : _c.edits) ? m(n10.value.data.edits[0], "objectIds", "updates") : null;
    if (r(o6)) {
      const e7 = Math.min(this._maximumNumberOfEditOVerrides, o6.length);
      e7 < o6.length && (this.warnMaximumChangedObjectsExceeded = true);
      const t7 = o6.sort((e8, t8) => e8 - t8);
      for (let s9 = 0; s9 < e7; s9++)
        this.changedObjectIds.add(t7[s9]);
    }
  }
  _getFetchChangedObjectIdsServerGen() {
    const e7 = this.layer;
    if (r(e7.serviceUpdateTimeStamp) && r(e7.serviceUpdateTimeStamp.lastUpdate))
      return e7.serviceUpdateTimeStamp.lastUpdate;
    const t6 = e7.associatedLayer;
    return r(t6) && r(t6.serverGens) && r(t6.serverGens.minServerGen) ? t6.serverGens.minServerGen : null;
  }
  get test() {
    const e7 = Array.from(this.changedObjectIds), t6 = this.pendingFetchChangedObjectIds, s8 = this;
    return { changedObjectIds: e7, pendingFetchChangedObjectIds: t6, get maximumNumberOfEditOVerrides() {
      return s8._maximumNumberOfEditOVerrides;
    }, set maximumNumberOfEditOVerrides(e8) {
      s8._maximumNumberOfEditOVerrides = e8;
    } };
  }
};
var y5 = class {
  constructor(e7, t6) {
    this.objectId = e7, this.options = t6, this.updates = /* @__PURE__ */ new Map(), this.state = O4.ACTIVE;
  }
  get(e7) {
    return this.updates.get(e7);
  }
  set(e7, t6) {
    this.isActive && this.updates.set(e7, t6);
  }
  rollback() {
    this.isActive && (this.state = O4.ROLLED_BACK, this.options.rollback());
  }
  commit() {
    this.isActive && (this.state = O4.COMMITTED, this.options.commit(this.updates), this.updates.clear());
  }
  get isActive() {
    return this.state === O4.ACTIVE;
  }
};
var O4;
!function(e7) {
  e7[e7.ACTIVE = 0] = "ACTIVE", e7[e7.COMMITTED = 1] = "COMMITTED", e7[e7.ROLLED_BACK = 2] = "ROLLED_BACK";
}(O4 || (O4 = {}));
var C5 = 1e4;
var j = 5e4;

export {
  a7 as a,
  e6 as e,
  s6 as s,
  F3 as F,
  C4 as C,
  S2 as S,
  D2 as D,
  w4 as w,
  te,
  s7 as s2,
  f2 as f
};
//# sourceMappingURL=chunk-XVC34HIT.js.map
