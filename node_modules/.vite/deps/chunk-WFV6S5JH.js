import {
  a,
  t as t3
} from "./chunk-2RRRGIMY.js";
import {
  t as t2
} from "./chunk-JYWDI7GA.js";
import {
  f
} from "./chunk-A2XF5TZW.js";
import {
  k,
  v as v2
} from "./chunk-53KI6WDE.js";
import {
  c
} from "./chunk-ZYIEYKCD.js";
import {
  l as l2,
  o,
  q as q2,
  r as r3,
  s as s2,
  v,
  x as x2
} from "./chunk-YZNDHJDJ.js";
import {
  An,
  Bn
} from "./chunk-PZWU5EHT.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  l
} from "./chunk-T7BEWVV3.js";
import {
  O
} from "./chunk-RN2KRYDN.js";
import {
  i,
  s,
  x
} from "./chunk-NWRK6QLX.js";
import {
  A,
  e as e2,
  q,
  r as r2,
  u,
  z
} from "./chunk-PKZEO23A.js";
import {
  n as n2,
  t
} from "./chunk-AIRC226G.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/overlay/LineOverlayItem.js
var r4 = class extends y {
  constructor(t4) {
    super(t4), this.startX = 0, this.startY = 0, this.endX = 0, this.endY = 0, this.width = 1, this.color = [0, 0, 0, 0.5], this.visible = true;
  }
  get startPosition() {
    return [this.startX, this.startY];
  }
  set startPosition(t4) {
    this._set("startX", t4[0]), this._set("startY", t4[1]);
  }
  get endPosition() {
    return [this.endX, this.endY];
  }
  set endPosition(t4) {
    this._set("endX", t4[0]), this._set("endY", t4[1]);
  }
  get strokeStyle() {
    const t4 = this.color;
    return `rgba(${t4[0]}, ${t4[1]}, ${t4[2]}, ${t4[3]})`;
  }
  get lineCap() {
    return "round";
  }
  render() {
    const { height: t4, left: s3, top: e3, width: i2, x1: r5, x2: n4, y1: a2, y2: p } = this._calculateCoordinates(h), l4 = `stroke: ${this.strokeStyle}; stroke-width: ${this.width}; stroke-linecap: ${this.lineCap};`;
    return t3("div", { classes: { "esri-line-overlay-item": true }, styles: { left: s3 + "px", top: e3 + "px", width: i2 + "px", height: t4 + "px", visibility: this.visible ? "visible" : "hidden" } }, [t3("svg", { width: i2, height: t4 }, [t3("line", { x1: r5, y1: a2, x2: n4, y2: p, style: l4 })])]);
  }
  renderCanvas(t4) {
    if (!this.visible)
      return;
    t4.strokeStyle = this.strokeStyle, t4.lineWidth = this.width, t4.lineCap = this.lineCap;
    const s3 = this._calculateCoordinates(h);
    t4.beginPath(), t4.moveTo(s3.left + s3.x1, s3.top + s3.y1), t4.lineTo(s3.left + s3.x2, s3.top + s3.y2), t4.stroke();
  }
  _calculateCoordinates(t4) {
    const s3 = Math.min(this.startX, this.endX), e3 = Math.max(this.startX, this.endX), i2 = Math.min(this.startY, this.endY), o2 = Math.max(this.startY, this.endY), r5 = this.width;
    return t4.left = s3 - r5, t4.top = i2 - r5, t4.width = e3 - s3 + 2 * r5, t4.height = Math.max(20, o2 - i2 + 2 * r5), t4.x1 = this.startX - s3 + r5, t4.y1 = this.startY - i2 + r5, t4.x2 = this.endX - s3 + r5, t4.y2 = this.endY - i2 + r5, t4;
  }
};
e([d()], r4.prototype, "startX", void 0), e([d()], r4.prototype, "startY", void 0), e([d()], r4.prototype, "endX", void 0), e([d()], r4.prototype, "endY", void 0), e([d()], r4.prototype, "startPosition", null), e([d()], r4.prototype, "endPosition", null), e([d()], r4.prototype, "width", void 0), e([d()], r4.prototype, "color", void 0), e([d()], r4.prototype, "visible", void 0), e([d({ readOnly: true })], r4.prototype, "strokeStyle", null), r4 = e([n("esri.views.overlay.LineOverlayItem")], r4);
var h = { left: 0, top: 0, width: 0, height: 0, x1: 0, y1: 0, x2: 0, y2: 0 };
var n3 = r4;

// node_modules/@arcgis/core/views/3d/interactive/visualElements/LabelVisualElement.js
var v3 = class extends t2 {
  constructor(e3) {
    super(e3.view), this._handles = new u2(), this._textItem = null, this._calloutItem = null, this._showCallout = true, this._showText = true, this._geometry = null, this._text = "-", this._fontSize = 14, this._distance = 25, this._anchor = "right", this.applyProps(e3);
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(t4) {
    this._geometry = t4, this._updateLabelPosition();
  }
  get textItem() {
    return this._textItem;
  }
  get text() {
    return this._text;
  }
  set text(t4) {
    this._text = t4, this.attached && (this._textItem.text = this._text);
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(t4) {
    this._fontSize = t4, this.attached && (this._textItem.fontSize = this._fontSize);
  }
  get distance() {
    return this._distance;
  }
  set distance(t4) {
    this._distance !== t4 && (this._distance = t4, this._updateLabelPosition());
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(t4) {
    this._anchor !== t4 && (this._anchor = t4, this._updateLabelPosition());
  }
  overlaps(t4) {
    return !!this.attached && (this.textItem.visible && t4.textItem.visible && this.view.overlay.overlaps(this._textItem, t4.textItem));
  }
  _updateLabelPosition() {
    if (!this.attached)
      return;
    this._showText = false, this._showCallout = false;
    const { geometry: t4, view: i2, visible: s3 } = this;
    if (r(t4) && i2._stage)
      switch (t4.type) {
        case "point":
          if (!this._computeLabelPositionFromPoint(t4.point, R))
            break;
          if (t4.callout) {
            const e3 = i2.state.camera, s4 = t4.callout.distance;
            s2(L, L, [0, t4.callout.offset]), e3.renderToScreen(L, R), r3(j, 0, 1), l2(j, j, s4 * e3.pixelRatio), s2(j, j, L), e3.renderToScreen(j, z2), this._showCallout = this._updatePosition(R, z2);
          } else
            this._textItem.position = [R[0], R[1]], this._textItem.anchor = "center";
          this._showText = true;
          break;
        case "corner":
          if (!this._computeLabelPositionFromCorner(t4, this._distance, R, z2))
            break;
          this._showCallout = this._updatePosition(R, z2), this._showText = true;
          break;
        case "segment": {
          if (!this._computeLabelPositionFromSegment(t4, this._distance, this._anchor, R, z2))
            break;
          this._showText = true;
          const e3 = this._updatePosition(R, z2);
          this._showCallout = false !== t4.callout && e3, this._showCallout || (this._textItem.anchor = "center");
        }
      }
    this.updateVisibility(s3);
  }
  _computeLabelPositionFromPoint(t4, e3) {
    const i2 = this.view.state.camera;
    return i2.projectToRenderScreen(t4, L), !(L[2] < 0 || L[2] > 1) && (i2.renderToScreen(L, e3), true);
  }
  _computeLabelPositionFromCorner(t4, e3, i2, s3) {
    if (!t4)
      return false;
    const o2 = this.view.state.camera;
    return w(t4.left, 1, o2, P), x2(P, P), w(t4.right, 0, o2, T), s2(j, P, T), x2(j, j), v(j, j), o2.projectToRenderScreen(t4.left.endRenderSpace, L), !(L[2] < 0 || L[2] > 1) && (o2.renderToScreen(L, i2), l2(j, j, e3 * o2.pixelRatio), s2(j, j, L), o2.renderToScreen(j, s3), true);
  }
  _computeLabelPositionFromSegment(t4, e3, i2, s3, o2) {
    if (!t4)
      return false;
    const r5 = t4.segment, l4 = this.view.state.camera;
    f(r5.startRenderSpace, r5.endRenderSpace, l4, P), r3(j, -P[1], P[0]);
    let _ = false;
    switch (i2) {
      case "top":
        _ = j[1] < 0;
        break;
      case "bottom":
        _ = j[1] > 0;
        break;
      case "left":
        _ = j[0] > 0;
        break;
      case "right":
        _ = j[0] < 0;
    }
    if (_ && x2(j, j), 0 === q2(j))
      switch (i2) {
        case "top":
          j[1] = 1;
          break;
        case "bottom":
          j[1] = -1;
          break;
        case "left":
          j[0] = -1;
          break;
        case "right":
          j[0] = 1;
      }
    return r5.eval(V[t4.sampleLocation], k2), l4.projectToRenderScreen(k2, L), !(L[2] < 0 || L[2] > 1) && (l4.renderToScreen(L, s3), l2(j, j, e3 * l4.pixelRatio), s2(j, j, L), l4.renderToScreen(j, o2), true);
  }
  _updatePosition(t4, e3) {
    if (e3) {
      const i2 = e3[0] - t4[0], s3 = e3[1] - t4[1];
      return this._textItem.position = [e3[0], e3[1]], this._textItem.anchor = Math.abs(i2) > Math.abs(s3) ? i2 > 0 ? "left" : "right" : s3 > 0 ? "top" : "bottom", this._calloutItem.startPosition = [t4[0], t4[1]], this._calloutItem.endPosition = [e3[0], e3[1]], true;
    }
    return this._textItem.position = [t4[0], t4[1]], this._textItem.anchor = "center", false;
  }
  createResources() {
    this._textItem = new a({ visible: true, text: this._text, fontSize: this._fontSize }), this._calloutItem = new n3({ visible: true, width: 2 }), this._updateLabelPosition(), this.view.overlay.items.addMany([this._textItem, this._calloutItem]), this._handles.add(l(() => this.view.state.camera, () => this._updateLabelPosition()));
  }
  destroyResources() {
    this.view.overlay && !this.view.overlay.destroyed && this.view.overlay.items.removeMany([this._textItem, this._calloutItem]), this._handles.removeAll();
  }
  updateVisibility(t4) {
    this._textItem.visible = this._showText && t4, this._calloutItem.visible = this._showCallout && t4;
  }
};
function w(t4, e3, i2, s3) {
  t4.eval(e3, S, y2), u(g, S, y2), i2.projectToRenderScreen(S, C), i2.projectToRenderScreen(g, M), o(s3, U, F), v(s3, s3);
}
function I(t4) {
  switch (t4) {
    case "top":
      return "bottom";
    case "right":
      return "left";
    case "bottom":
      return "top";
    case "left":
      return "right";
  }
}
var S = n2();
var g = n2();
var y2 = n2();
var P = s();
var T = s();
var j = s();
var k2 = n2();
var L = x();
var R = i();
var z2 = i();
var C = x();
var F = C;
var M = x();
var U = M;
var V = { start: 0, center: 0.5, end: 1 };

// node_modules/@arcgis/core/views/3d/interactive/visualElements/support/Segment.js
var l3 = class {
  constructor(e3 = n2(), t4 = n2()) {
    this.startRenderSpace = e3, this.endRenderSpace = t4, this.type = "euclidean";
  }
  eval(r5, i2, n4) {
    return A(i2, this.startRenderSpace, this.endRenderSpace, r5), n4 && (e2(n4, this.endRenderSpace, this.startRenderSpace), z(n4, n4)), i2;
  }
  createRenderGeometry(e3, s3) {
    const r5 = [], i2 = [], n4 = (s4, n5) => {
      const c3 = S2;
      e2(c3, s4, e3), r5.push([c3[0], c3[1], c3[2]]), i2.push([n5[0], n5[1], n5[2]]);
    }, c2 = s3.worldUpAtPosition(this.eval(0.5, R2), c.get());
    return n4(this.startRenderSpace, c2), n4(this.endRenderSpace, c2), { points: r5, normals: i2 };
  }
  static fromPositionAndVector(e3, t4, s3 = 1) {
    return q(R2, t4, s3), u(R2, e3, R2), new l3(t(e3), t(R2));
  }
};
var m = class {
  constructor(e3, t4, s3) {
    this.startRenderSpace = e3, this.endRenderSpace = t4, this.renderSpatialReference = s3, this.type = "geodesic", this._start = n2(), this._end = n2(), this._pcpf = O(s3), this._project = An(s3, this._pcpf), this._projectIn(e3, this._start), this._projectIn(t4, this._end);
  }
  _projectIn(e3, t4) {
    this._project ? Bn(e3, this.renderSpatialReference, t4, this._pcpf) : r2(t4, e3);
  }
  eval(r5, n4, c2) {
    if (this._project)
      if (c2) {
        const e3 = S2;
        v2(this._start, this._end, r5, n4, e3), u(j2, n4, e3), Bn(n4, this._pcpf, n4, this.renderSpatialReference), Bn(j2, this._pcpf, j2, this.renderSpatialReference), e2(c2, j2, n4), z(c2, c2);
      } else
        k(this._start, this._end, r5, n4), Bn(n4, this._pcpf, n4, this.renderSpatialReference);
    else
      A(n4, this._start, this._end, r5), c2 && (e2(c2, this._end, this._start), z(c2, c2));
    return n4;
  }
  createRenderGeometry(e3, s3) {
    const r5 = [], i2 = [], n4 = (s4, n5) => {
      const c3 = j2;
      e2(c3, s4, e3), r5.push([c3[0], c3[1], c3[2]]), i2.push([n5[0], n5[1], n5[2]]);
    }, c2 = 128 + 1 & -2;
    for (let t4 = 0; t4 < c2; ++t4) {
      const e4 = t4 / (c2 - 1), r6 = R2, i3 = S2;
      this.eval(e4, r6), s3.worldUpAtPosition(r6, i3), n4(r6, i3);
    }
    return { points: r5, normals: i2 };
  }
};
var R2 = n2();
var S2 = n2();
var j2 = n2();

export {
  v3 as v,
  I,
  l3 as l,
  m
};
//# sourceMappingURL=chunk-WFV6S5JH.js.map
