import {
  L,
  O,
  T
} from "./chunk-WFUZXUS4.js";
import {
  u
} from "./chunk-NCMBCUFA.js";
import {
  ne,
  se,
  te
} from "./chunk-6SWQ7R36.js";
import {
  e
} from "./chunk-Z4FD36CT.js";
import {
  d
} from "./chunk-FU5UMT3R.js";
import {
  i
} from "./chunk-JMZLJZMP.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  M
} from "./chunk-YPZEGNLG.js";
import {
  c as c2,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  c,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/ogc/ogcFeatureUtils.js
var b = s.getLogger("esri.layers.graphics.sources.ogcfeature");
var j = "http://www.opengis.net/def/crs/";
var F = `${j}OGC/1.3/CRS84`;
async function I(i2, r2, a = {}, s3 = 5) {
  const { links: o } = i2, l = G(o, "items", "application/geo+json") || G(o, "http://www.opengis.net/def/rel/ogc/1.0/items", "application/geo+json");
  if (t(l))
    throw new s2("ogc-feature-layer:missing-items-page", "Missing items url");
  const { data: c3 } = await U(l.href, { signal: a.signal, query: { limit: s3, ...a.customParameters, token: a.apiKey }, headers: { accept: "application/geo+json" } });
  await O(c3);
  const d2 = T(c3, { geometryType: r2.geometryType }), u2 = r2.fields || d2.fields || [], f = null != r2.hasZ ? r2.hasZ : d2.hasZ, h = d2.geometryType, j2 = r2.objectIdField || d2.objectIdFieldName || "OBJECTID";
  let F2 = r2.timeInfo;
  const I2 = u2.find((e2) => e2.name === j2);
  if (!I2) {
    if (!d2.objectIdFieldType)
      throw new s2("ogc-feature-layer:missing-feature-id", "Collection geojson require a feature id as a unique identifier");
    u2.unshift({ name: j2, alias: j2, type: "esriFieldTypeOID", editable: false, nullable: false });
  } else
    I2.type = "esriFieldTypeOID", I2.editable = false, I2.nullable = false;
  if (j2 !== d2.objectIdFieldName) {
    const e2 = u2.find((e3) => e3.name === d2.objectIdFieldName);
    e2 && (e2.type = "esriFieldTypeInteger");
  }
  u2 === d2.fields && d2.unknownFields.length > 0 && b.warn({ name: "ogc-feature-layer:unknown-field-types", message: "Some fields types couldn't be inferred from the features and were dropped", details: { unknownFields: d2.unknownFields } });
  for (const e2 of u2) {
    if (null == e2.name && (e2.name = e2.alias), null == e2.alias && (e2.alias = e2.name), "esriFieldTypeOID" !== e2.type && "esriFieldTypeGlobalID" !== e2.type && (e2.editable = null == e2.editable || !!e2.editable, e2.nullable = null == e2.nullable || !!e2.nullable), !e2.name)
      throw new s2("ogc-feature-layer:invalid-field-name", "field name is missing", { field: e2 });
    if (!i.jsonValues.includes(e2.type))
      throw new s2("ogc-feature-layer:invalid-field-type", `invalid type for field "${e2.name}"`, { field: e2 });
  }
  if (F2) {
    const e2 = new d(u2);
    if (F2.startTimeField) {
      const t2 = e2.get(F2.startTimeField);
      t2 ? (F2.startTimeField = t2.name, t2.type = "esriFieldTypeDate") : F2.startTimeField = null;
    }
    if (F2.endTimeField) {
      const t2 = e2.get(F2.endTimeField);
      t2 ? (F2.endTimeField = t2.name, t2.type = "esriFieldTypeDate") : F2.endTimeField = null;
    }
    if (F2.trackIdField) {
      const t2 = e2.get(F2.trackIdField);
      t2 ? F2.trackIdField = t2.name : (F2.trackIdField = null, b.warn({ name: "ogc-feature-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: F2 } }));
    }
    F2.startTimeField || F2.endTimeField || (b.warn({ name: "ogc-feature-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing", details: { timeInfo: F2 } }), F2 = null);
  }
  return { drawingInfo: h ? u(h) : null, geometryType: h, fields: u2, hasZ: !!f, objectIdField: j2, timeInfo: F2 };
}
async function T2(i2, r2 = {}) {
  const { links: a } = i2, s3 = G(a, "data", "application/json") || G(a, "http://www.opengis.net/def/rel/ogc/1.0/data", "application/json");
  if (t(s3))
    throw new s2("ogc-feature-layer:missing-collections-page", "Missing collections url");
  const { apiKey: o, customParameters: l, signal: c3 } = r2, { data: d2 } = await U(s3.href, { signal: c3, headers: { accept: "application/json" }, query: { ...l, token: o } });
  return d2;
}
async function k2(i2, r2 = {}) {
  const { links: a } = i2, s3 = G(a, "conformance", "application/json") || G(a, "http://www.opengis.net/def/rel/ogc/1.0/conformance", "application/json");
  if (t(s3))
    throw new s2("ogc-feature-layer:missing-conformance-page", "Missing conformance url");
  const { apiKey: o, customParameters: l, signal: c3 } = r2, { data: d2 } = await U(s3.href, { signal: c3, headers: { accept: "application/json" }, query: { ...l, token: o } });
  return d2;
}
async function S(t2, i2 = {}) {
  const { apiKey: n, customParameters: r2, signal: a } = i2, { data: s3 } = await U(t2, { signal: a, headers: { accept: "application/json" }, query: { ...r2, token: n } });
  return s3;
}
async function x(t2, i2 = {}) {
  const r2 = "application/vnd.oai.openapi+json;version=3.0", a = G(t2.links, "service-desc", r2);
  if (t(a))
    return b.warn("ogc-feature-layer:missing-openapi-page", "The OGC API-Features server does not have an OpenAPI page."), null;
  const { apiKey: s3, customParameters: o, signal: l } = i2, { data: c3 } = await U(a.href, { signal: l, headers: { accept: r2 }, query: { ...o, token: s3 } });
  return c3;
}
function N(e2) {
  var _a;
  const t2 = (_a = /^http:\/\/www\.opengis.net\/def\/crs\/(?<authority>.*)\/(?<version>.*)\/(?<code>.*)$/i.exec(e2)) == null ? void 0 : _a.groups;
  if (!t2)
    return null;
  const { authority: i2, code: n } = t2;
  switch (i2.toLowerCase()) {
    case "ogc":
      switch (n.toLowerCase()) {
        case "crs27":
          return k.GCS_NAD_1927.wkid;
        case "crs83":
          return 4269;
        case "crs84":
        case "crs84h":
          return k.WGS84.wkid;
        default:
          return null;
      }
    case "esri":
    case "epsg": {
      const e3 = Number.parseInt(n, 10);
      return Number.isNaN(e3) ? null : e3;
    }
    default:
      return null;
  }
}
async function q(e2, t2, i2) {
  const n = await v(e2, t2, i2);
  return se(n);
}
async function v(i2, l, p) {
  const { capabilities: { query: { maxRecordCount: m } }, collection: g, layerDefinition: y, queryParameters: { apiKey: w, customParameters: b2 }, spatialReference: j2, supportedCrs: F2 } = i2, { links: I2 } = g, T3 = G(I2, "items", "application/geo+json") || G(I2, "http://www.opengis.net/def/rel/ogc/1.0/items", "application/geo+json");
  if (t(T3))
    throw new s2("ogc-feature-layer:missing-items-page", "Missing items url");
  const { geometry: k3, num: S2, start: x2, timeExtent: N2, where: q2 } = l;
  if (l.objectIds)
    throw new s2("ogc-feature-layer:query-by-objectids-not-supported", "Queries with objectids are not supported");
  const v2 = k.fromJSON(j2), M3 = c(l.outSpatialReference, v2), C2 = M3.isWGS84 ? null : O2(M3, F2), P = D(k3, F2), W = R(N2), Z = $(q2), K = S2 ?? (null != x2 && void 0 !== x2 ? 10 : m), { data: L2 } = await U(T3.href, { ...p, query: { ...b2, ...P, crs: C2, datetime: W, query: Z, limit: K, startindex: x2, token: w }, headers: { accept: "application/geo+json" } });
  let A = false;
  if (L2.links) {
    const e2 = L2.links.find((e3) => "next" === e3.rel);
    A = !!e2;
  }
  !A && Number.isInteger(L2.numberMatched) && Number.isInteger(L2.numberReturned) && (A = L2.numberReturned < L2.numberMatched);
  const { fields: E, globalIdField: J, hasM: U2, hasZ: _, objectIdField: z } = y, B = y.geometryType, Q = L(L2, { geometryType: B, hasZ: _, objectIdField: z });
  if (!C2 && M3.isWebMercator) {
    for (const e2 of Q)
      if (r(e2.geometry)) {
        const t2 = ne(e2.geometry, B, _, false);
        t2.spatialReference = k.WGS84, e2.geometry = te(M(t2, M3));
      }
  }
  for (const e2 of Q)
    e2.objectId = e2.attributes[z];
  const V = C2 || !C2 && M3.isWebMercator ? M3.toJSON() : c2, H = new e();
  return H.exceededTransferLimit = A, H.features = Q, H.fields = E, H.geometryType = B, H.globalIdFieldName = J, H.hasM = U2, H.hasZ = _, H.objectIdFieldName = z, H.spatialReference = V, H;
}
function M2(e2) {
  return r(e2) && "extent" === e2.type;
}
function O2(e2, t2) {
  const { isWebMercator: i2, wkid: n } = e2;
  if (!n)
    return null;
  const r2 = i2 ? t2[3857] ?? t2[102100] ?? t2[102113] ?? t2[900913] : t2[e2.wkid];
  return r2 ? `${j}${r2}` : null;
}
function C(e2) {
  if (t(e2))
    return "";
  const { xmin: t2, ymin: i2, xmax: r2, ymax: a } = e2;
  return `${t2},${i2},${r2},${a}`;
}
function R(e2) {
  if (t(e2))
    return null;
  const { start: t2, end: i2 } = e2;
  return `${r(t2) ? t2.toISOString() : ".."}/${r(i2) ? i2.toISOString() : ".."}`;
}
function $(e2) {
  return t(e2) || !e2 || "1=1" === e2 ? null : e2;
}
function D(e2, t2) {
  if (!M2(e2))
    return null;
  const { spatialReference: i2 } = e2;
  if (!i2 || i2.isWGS84)
    return { bbox: C(e2) };
  const n = O2(i2, t2);
  return r(n) ? { bbox: C(e2), "bbox-crs": n } : i2.isWebMercator ? { bbox: C(M(e2, k.WGS84)) } : null;
}
function G(e2, t2, i2) {
  return e2.find((e3) => e3.rel === t2 && e3.type === i2) || e2.find((e3) => e3.rel === t2 && !e3.type);
}

export {
  j,
  F,
  I,
  T2 as T,
  k2 as k,
  S,
  x,
  N,
  q,
  v
};
//# sourceMappingURL=chunk-JOD7ILR7.js.map
