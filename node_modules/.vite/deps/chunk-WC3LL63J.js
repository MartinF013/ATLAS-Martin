import {
  d as d2
} from "./chunk-3BCNCVBY.js";
import {
  C,
  O,
  _,
  ee,
  ke,
  t,
  w,
  z
} from "./chunk-LBBA3SFR.js";
import {
  ne
} from "./chunk-6SWQ7R36.js";
import {
  d
} from "./chunk-4PRVTUEZ.js";
import {
  j2 as j,
  p
} from "./chunk-YPZEGNLG.js";
import {
  e,
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/arcade/ArcadePortal.js
var s = class extends d2 {
  constructor(t2) {
    super(), this.immutable = false, this.setField("url", t2), this.immutable = true;
  }
};

// node_modules/@arcgis/core/arcade/Feature.js
var d3 = class {
  constructor() {
    this.arcadeDeclaredClass = "esri.arcade.Feature", this._optimizedGeomDefinition = null, this._geometry = null, this.attributes = null, this._layer = null, this._datesfixed = true, this.immutable = true, this._datefields = null, this.immutable = true;
  }
  static createFromGraphic(t2) {
    const e2 = new d3();
    return e2._geometry = r(t2.geometry) ? t2.geometry : null, void 0 === t2.attributes || null === t2.attributes ? e2.attributes = {} : e2.attributes = t2.attributes, t2._sourceLayer ? (e2._layer = t2._sourceLayer, e2._datesfixed = false) : t2._layer ? (e2._layer = t2._layer, e2._datesfixed = false) : t2.layer && "fields" in t2.layer ? (e2._layer = t2.layer, e2._datesfixed = false) : t2.sourceLayer && "fields" in t2.sourceLayer && (e2._layer = t2.sourceLayer, e2._datesfixed = false), e2;
  }
  static createFromArcadeFeature(t2) {
    const e2 = new d3();
    return e2._datesfixed = t2._datesfixed, e2.attributes = t2.attributes, e2._geometry = t2._geometry, e2._optimizedGeomDefinition = t2._optimizedGeomDefinition, t2._layer && (e2._layer = t2._layer), e2;
  }
  static createFromOptimisedFeature(t2, e2, i) {
    const s2 = new d3();
    return s2._geometry = t2.geometry ? { geometry: t2.geometry } : null, s2._optimizedGeomDefinition = i, s2.attributes = t2.attributes || {}, s2._layer = e2, s2._datesfixed = false, s2;
  }
  static createFromArcadeDictionary(e2) {
    const i = new d3();
    return i.attributes = e2.field("attributes"), null !== i.attributes && i.attributes instanceof d2 ? (i.attributes = i.attributes.attributes, null === i.attributes && (i.attributes = {})) : i.attributes = {}, i._geometry = e2.field("geometry"), null !== i._geometry && (i._geometry instanceof d2 ? i._geometry = d3.parseGeometryFromDictionary(i._geometry) : i._geometry instanceof p || (i._geometry = null)), i;
  }
  static createFromGraphicLikeObject(t2, e2, i = null) {
    const s2 = new d3();
    return null === e2 && (e2 = {}), s2.attributes = e2, s2._geometry = r(t2) ? t2 : null, s2._layer = i, s2._layer && (s2._datesfixed = false), s2;
  }
  repurposeFromGraphicLikeObject(t2, e2, i = null) {
    null === e2 && (e2 = {}), this.attributes = e2, this._geometry = t2 || null, this._layer = i, this._layer ? this._datesfixed = false : this._datesfixed = true;
  }
  castToText() {
    let t2 = "";
    false === this._datesfixed && this._fixDates();
    for (const o in this.attributes) {
      "" !== t2 && (t2 += ",");
      const n = this.attributes[o];
      null == n ? t2 += JSON.stringify(o) + ":null" : _(n) || O(n) || w(n) ? t2 += JSON.stringify(o) + ":" + JSON.stringify(n) : n instanceof p || n instanceof t || n instanceof Array ? t2 += JSON.stringify(o) + ":" + ee(n) : n instanceof Date ? t2 += JSON.stringify(o) + ":" + JSON.stringify(n) : null !== n && "object" == typeof n && void 0 !== n.castToText && (t2 += JSON.stringify(o) + ":" + n.castToText());
    }
    return '{"geometry":' + (null === this.geometry() ? "null" : ee(this.geometry())) + ',"attributes":{' + t2 + "}}";
  }
  _fixDates() {
    if (null !== this._datefields)
      return this._datefields.length > 0 && this._fixDateFields(this._datefields), void (this._datesfixed = true);
    const t2 = [];
    for (let e2 = 0; e2 < this._layer.fields.length; e2++) {
      const i = this._layer.fields[e2];
      "date" !== i.type && "esriFieldTypeDate" !== i.type || t2.push(i.name);
    }
    this._datefields = t2, t2.length > 0 && this._fixDateFields(t2), this._datesfixed = true;
  }
  _fixDateFields(t2) {
    this.attributes = { ...this.attributes };
    for (let e2 = 0; e2 < t2.length; e2++) {
      let i = this.attributes[t2[e2]];
      if (null === i)
        ;
      else if (void 0 === i) {
        for (const s2 in this.attributes)
          if (s2.toLowerCase() === t2[e2].toLowerCase()) {
            i = this.attributes[s2], null !== i && (i instanceof Date || (this.attributes[s2] = new Date(i)));
            break;
          }
      } else
        i instanceof Date || (this.attributes[t2[e2]] = new Date(i));
    }
  }
  geometry() {
    return null === this._geometry || this._geometry instanceof p || (this._optimizedGeomDefinition ? (this._geometry = e(d(ne(this._geometry, this._optimizedGeomDefinition.geometryType, this._optimizedGeomDefinition.hasZ, this._optimizedGeomDefinition.hasM))), this._geometry.spatialReference = this._optimizedGeomDefinition.spatialReference) : this._geometry = e(d(this._geometry))), this._geometry;
  }
  field(t2) {
    false === this._datesfixed && this._fixDates();
    const e2 = this.attributes[t2];
    if (void 0 !== e2)
      return e2;
    const i = t2.toLowerCase();
    for (const s2 in this.attributes)
      if (s2.toLowerCase() === i)
        return this.attributes[s2];
    if (this._hasFieldDefinition(i))
      return null;
    throw new Error("Field not Found : " + t2);
  }
  _hasFieldDefinition(t2) {
    if (null === this._layer)
      return false;
    for (let e2 = 0; e2 < this._layer.fields.length; e2++) {
      if (this._layer.fields[e2].name.toLowerCase() === t2)
        return true;
    }
    return false;
  }
  setField(t2, e2) {
    if (this.immutable)
      throw new Error("Feature is Immutable");
    if (false === C(e2))
      throw new Error("Illegal Value Assignment to Feature");
    const i = t2.toLowerCase();
    if (void 0 === this.attributes[t2]) {
      for (const t3 in this.attributes)
        if (t3.toLowerCase() === i)
          return void (this.attributes[t3] = e2);
      this.attributes[t2] = e2;
    } else
      this.attributes[t2] = e2;
  }
  hasField(t2) {
    const e2 = t2.toLowerCase();
    if (void 0 !== this.attributes[t2])
      return true;
    for (const i in this.attributes)
      if (i.toLowerCase() === e2)
        return true;
    return !!this._hasFieldDefinition(e2);
  }
  keys() {
    let t2 = [];
    const e2 = {};
    for (const i in this.attributes)
      t2.push(i), e2[i.toLowerCase()] = 1;
    if (null !== this._layer)
      for (let i = 0; i < this._layer.fields.length; i++) {
        const s2 = this._layer.fields[i];
        1 !== e2[s2.name.toLowerCase()] && t2.push(s2.name);
      }
    return t2 = t2.sort(), t2;
  }
  static parseGeometryFromDictionary(t2) {
    const e2 = d3._convertDictionaryToJson(t2, true);
    return void 0 !== e2.hasm && (e2.hasM = e2.hasm, delete e2.hasm), void 0 !== e2.hasz && (e2.hasZ = e2.hasz, delete e2.hasz), void 0 !== e2.spatialreference && (e2.spatialReference = e2.spatialreference, delete e2.spatialreference), void 0 !== e2.rings && (e2.rings = this._fixPathArrays(e2.rings, true === e2.hasZ, true === e2.hasZ)), void 0 !== e2.paths && (e2.paths = this._fixPathArrays(e2.paths, true === e2.hasZ, true === e2.hasM)), void 0 !== e2.points && (e2.points = this._fixPointArrays(e2.points, true === e2.hasZ, true === e2.hasM)), d(e2);
  }
  static _fixPathArrays(t2, i, s2) {
    const r2 = [];
    if (t2 instanceof Array)
      for (let e2 = 0; e2 < t2.length; e2++)
        r2.push(this._fixPointArrays(t2[e2], i, s2));
    else if (t2 instanceof t)
      for (let e2 = 0; e2 < t2.length(); e2++)
        r2.push(this._fixPointArrays(t2.get(e2), i, s2));
    return r2;
  }
  static _fixPointArrays(t2, i, s2) {
    const r2 = [];
    if (t2 instanceof Array)
      for (let a = 0; a < t2.length; a++) {
        const o = t2[a];
        o instanceof j ? i && s2 ? r2.push([o.x, o.y, o.z, o.m]) : i ? r2.push([o.x, o.y, o.z]) : s2 ? r2.push([o.x, o.y, o.m]) : r2.push([o.x, o.y]) : o instanceof t ? r2.push(o.toArray()) : r2.push(o);
      }
    else if (t2 instanceof t)
      for (let a = 0; a < t2.length(); a++) {
        const o = t2.get(a);
        o instanceof j ? i && s2 ? r2.push([o.x, o.y, o.z, o.m]) : i ? r2.push([o.x, o.y, o.z]) : s2 ? r2.push([o.x, o.y, o.m]) : r2.push([o.x, o.y]) : o instanceof t ? r2.push(o.toArray()) : r2.push(o);
      }
    return r2;
  }
  static _convertDictionaryToJson(e2, i = false) {
    const s2 = {};
    for (const r2 in e2.attributes) {
      let a = e2.attributes[r2];
      a instanceof d2 && (a = d3._convertDictionaryToJson(a)), i ? s2[r2.toLowerCase()] = a : s2[r2] = a;
    }
    return s2;
  }
  static parseAttributesFromDictionary(t2) {
    const e2 = {};
    for (const i in t2.attributes) {
      const s2 = t2.attributes[i];
      if (!C(s2))
        throw new Error("Illegal Argument");
      e2[i] = s2;
    }
    return e2;
  }
  static fromJson(t2) {
    let e2 = null;
    null !== t2.geometry && void 0 !== t2.geometry && (e2 = d(t2.geometry));
    const a = {};
    if (null !== t2.attributes && void 0 !== t2.attributes)
      for (const o in t2.attributes) {
        const e3 = t2.attributes[o];
        if (null === e3)
          a[o] = e3;
        else {
          if (!(w(e3) || O(e3) || _(e3) || z(e3)))
            throw new Error("Illegal Argument");
          a[o] = e3;
        }
      }
    return d3.createFromGraphicLikeObject(e2, a, null);
  }
  fullSchema() {
    return this._layer;
  }
  gdbVersion() {
    if (null === this._layer)
      return "";
    const t2 = this._layer.gdbVersion;
    return void 0 === t2 ? "" : "" === t2 && this._layer.capabilities && this._layer.capabilities.isVersioned ? "SDE.DEFAULT" : t2;
  }
  castAsJson(t2) {
    const e2 = { attributes: {}, geometry: true === (t2 == null ? void 0 : t2.keepGeometryType) ? this.geometry() : this.geometry().toJSON() };
    for (const i in this.attributes) {
      const s2 = this.attributes[i];
      void 0 !== s2 && (e2.attributes[i] = ke(s2, t2));
    }
    return e2;
  }
  async castAsJsonAsync(t2 = null, e2) {
    return this.castAsJson(e2);
  }
};

export {
  s,
  d3 as d
};
//# sourceMappingURL=chunk-WC3LL63J.js.map
