import {
  L as L2,
  M as M3,
  k as k3,
  r as r3,
  x as x2
} from "./chunk-C3M7GLTQ.js";
import {
  a as a2,
  g,
  k,
  l as l2,
  x
} from "./chunk-EQ3EWUVK.js";
import {
  o as o2
} from "./chunk-5EPJG7SL.js";
import {
  f as f3,
  p as p4
} from "./chunk-XXEJXJP4.js";
import "./chunk-MFOJFHT7.js";
import "./chunk-J73IXFNW.js";
import {
  L as L3,
  M as M2,
  O as O3,
  h,
  j as j2,
  k as k2
} from "./chunk-FFHGE66H.js";
import "./chunk-MOZ4GR2L.js";
import "./chunk-MQBVOUKB.js";
import "./chunk-RIOXX6J2.js";
import "./chunk-DLM6NKXW.js";
import "./chunk-TQLSOIYV.js";
import {
  e as e4
} from "./chunk-YFBAFAZ2.js";
import {
  e as e3
} from "./chunk-LUU3J646.js";
import "./chunk-MZ4JF5C6.js";
import {
  a
} from "./chunk-3NPGGTI6.js";
import "./chunk-YZNDHJDJ.js";
import {
  Hn,
  qn
} from "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import {
  x as x3
} from "./chunk-4XBERLPX.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  a as a3
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  l
} from "./chunk-T7BEWVV3.js";
import {
  p as p3
} from "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-CLGCKZUR.js";
import {
  O
} from "./chunk-RN2KRYDN.js";
import {
  g as g2
} from "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import {
  m as m2
} from "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import {
  m
} from "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  Ot,
  _
} from "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import {
  L,
  O as O2,
  e as e2,
  o,
  q,
  u,
  z
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import {
  f as f2,
  n as n2,
  r as r2
} from "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j,
  p as p2
} from "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  C,
  f,
  p,
  y
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var a4 = s.getLogger("esri.geometry.support.meshUtils.centerAt");
function c(e6, r4, i) {
  if (!e6.vertexAttributes || !e6.vertexAttributes.position)
    return;
  const n3 = (i == null ? void 0 : i.origin) ?? e6.origin;
  if (r(e6.transform))
    null != (i == null ? void 0 : i.geographic) && i.geographic !== e6.transform.geographic && a4.warn(`Specifying the 'geographic' parameter (${i.geographic}) different from the Mesh transform setting (${e6.transform.geographic}) is not supported`), f4(e6.transform, r4, n3);
  else {
    r3(e6.spatialReference, i) ? p5(e6, r4, n3) : g3(e6, r4, n3);
  }
}
function f4(e6, t2, r4) {
  const i = t2.x - r4.x, o3 = t2.y - r4.y, n3 = t2.hasZ && r4.hasZ ? t2.z - r4.z : 0, s4 = e6.origin;
  e6.origin = [s4[0] + i, s4[1] + o3, s4[2] + n3];
}
function p5(e6, t2, r4) {
  const i = M3(e6.vertexAttributes, r4, { geographic: true }), { position: o3, normal: a5, tangent: c4 } = x2(i, t2, { geographic: true });
  e6.vertexAttributes.position = o3, e6.vertexAttributes.normal = a5, e6.vertexAttributes.tangent = c4, e6.vertexAttributesChanged();
}
function g3(e6, t2, r4) {
  const o3 = h2, n3 = l3;
  if (Hn(t2, n3, e6.spatialReference)) {
    if (!Hn(r4, o3, e6.spatialReference)) {
      const t3 = e6.origin;
      o3[0] = t3.x, o3[1] = t3.y, o3[2] = t3.z, a4.error(`Failed to project specified origin (wkid:${r4.spatialReference.wkid}) to mesh spatial reference (wkid:${e6.spatialReference.wkid}).`);
    }
    m3(e6.vertexAttributes.position, n3, o3), e6.vertexAttributesChanged();
  } else
    a4.error(`Failed to project centerAt location (wkid:${t2.spatialReference.wkid}) to mesh spatial reference (wkid:${e6.spatialReference.wkid})`);
}
function m3(e6, t2, r4) {
  if (e6)
    for (let i = 0; i < e6.length; i += 3)
      for (let o3 = 0; o3 < 3; o3++)
        e6[i + o3] += t2[o3] - r4[o3];
}
var l3 = n2();
var h2 = n2();

// node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function f5(e6, s4, o3) {
  const { loadGLTFMesh: n3 } = await y(import("./loadGLTFMesh-OCS46BSO.js"), o3), a5 = await m4(s4, o3), i = n3(new j({ x: 0, y: 0, z: 0, spatialReference: e6.spatialReference }), a5.url, { resolveFile: u2(a5), useTransform: true, signal: r(o3) ? o3.signal : null });
  i.then(() => a5.dispose(), () => a5.dispose());
  const { vertexAttributes: l6, components: f7 } = await i;
  e6.vertexAttributes = l6, e6.components = f7;
}
function u2(e6) {
  const t2 = Ot(e6.url);
  return (s4) => {
    const r4 = _(s4, t2, t2), o3 = r4 ? r4.replace(/^ *\.\//, "") : null;
    return e6.files.get(o3) ?? s4;
  };
}
async function m4(e6, t2) {
  return e6 instanceof Blob ? y2.fromBlob(e6) : "string" == typeof e6 ? new y2(e6) : Array.isArray(e6) ? p6(e6, t2) : w(e6, t2);
}
async function p6(t2, r4) {
  const i = /* @__PURE__ */ new Map();
  let l6 = null;
  const c4 = await C(t2.map(async (e6) => ({ name: e6.name, source: await m4(e6 instanceof Blob ? e6 : e6.source, r4) }))), f7 = [];
  for (const e6 of c4)
    e6 && (p(r4) ? e6.source.dispose() : f7.push(e6));
  f(r4);
  for (const { name: e6, source: o3 } of f7)
    (t(l6) || /\.(gltf|glb)/i.test(e6)) && (l6 = o3.url), i.set(e6, o3.url), o3.files && o3.files.forEach((e7, t3) => i.set(t3, e7));
  if (t(l6))
    throw new s2("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new y2(l6, () => f7.forEach(({ source: e6 }) => e6.dispose()), i);
}
async function w(e6, t2) {
  const { default: s4 } = await y(import("./request-VWKJHTPX.js"), t2), o3 = "string" == typeof e6.multipart[0] ? await Promise.all(e6.multipart.map(async (e7) => (await s4(e7, { responseType: "array-buffer" })).data)) : e6.multipart;
  return y2.fromBlob(new Blob(o3));
}
var y2 = class {
  constructor(e6, t2 = () => {
  }, s4 = /* @__PURE__ */ new Map()) {
    this.url = e6, this.dispose = t2, this.files = s4;
  }
  static fromBlob(e6) {
    const t2 = URL.createObjectURL(e6);
    return new y2(t2, () => URL.revokeObjectURL(t2));
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/offset.js
var x4 = s.getLogger("esri.geometry.support.meshUtils.offset");
function A(t2, e6, o3) {
  if (t2.vertexAttributes && t2.vertexAttributes.position)
    if (r(t2.transform))
      null != (o3 == null ? void 0 : o3.geographic) && o3.geographic !== t2.transform.geographic && x4.warn(`Specifying the 'geographic' parameter (${o3.geographic}) different from the Mesh transform setting (${t2.transform.geographic}) is not supported`), v2(t2.transform, e6);
    else {
      r3(t2.spatialReference, o3) ? b(t2, e6) : y3(t2, e6);
    }
}
function v2(t2, r4) {
  const e6 = t2.origin;
  t2.origin = u(n2(), e6, r4);
}
function b(t2, o3) {
  const i = t2.spatialReference, n3 = t2.vertexAttributes.position, a5 = t2.vertexAttributes.normal, c4 = t2.vertexAttributes.tangent, x7 = new Float64Array(n3.length), A4 = r(a5) ? new Float32Array(a5.length) : null, v5 = r(c4) ? new Float32Array(c4.length) : null, b3 = t2.extent.center, y7 = k4;
  qn(i, [b3.x, b3.y, b3.z], w2, O(i)), a(F, w2), O2(y7, o3, F), M2(n3, i, x7), r(a5) && j2(a5, n3, x7, i, A4), r(c4) && k2(c4, n3, x7, i, v5), d2(x7, y7), O3(x7, n3, i), r(a5) && h(A4, n3, x7, i, a5), r(c4) && L3(v5, n3, x7, i, c4), t2.vertexAttributesChanged();
}
function y3(t2, r4) {
  d2(t2.vertexAttributes.position, r4), t2.vertexAttributesChanged();
}
function d2(t2, r4) {
  if (t2)
    for (let e6 = 0; e6 < t2.length; e6 += 3)
      for (let o3 = 0; o3 < 3; o3++)
        t2[e6 + o3] += r4[o3];
}
var k4 = n2();
var w2 = e4();
var F = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function c2() {
  const { faceDescriptions: t2, faceVertexOffsets: e6, uvScales: n3 } = d3, r4 = 4 * t2.length, o3 = new Float64Array(3 * r4), s4 = new Float32Array(3 * r4), a5 = new Float32Array(2 * r4), i = new Uint32Array(2 * t2.length * 3);
  let c4 = 0, l6 = 0, f7 = 0, u4 = 0;
  for (let h4 = 0; h4 < t2.length; h4++) {
    const r5 = t2[h4], p9 = c4 / 3;
    for (const t3 of e6)
      i[u4++] = p9 + t3;
    const m6 = r5.corners;
    for (let t3 = 0; t3 < 4; t3++) {
      const e7 = m6[t3];
      let i2 = 0;
      a5[f7++] = 0.25 * n3[t3][0] + r5.uvOrigin[0], a5[f7++] = r5.uvOrigin[1] - 0.25 * n3[t3][1];
      for (let t4 = 0; t4 < 3; t4++)
        0 !== r5.axis[t4] ? (o3[c4++] = 0.5 * r5.axis[t4], s4[l6++] = r5.axis[t4]) : (o3[c4++] = 0.5 * e7[i2++], s4[l6++] = 0);
    }
  }
  return { position: o3, normal: s4, uv: a5, faces: i };
}
function l4(e6, n3) {
  const r4 = e6.components[0], o3 = r4.faces, a5 = M4[n3], i = 6 * a5, c4 = new Uint32Array(6), l6 = new Uint32Array(o3.length - 6);
  let f7 = 0, u4 = 0;
  for (let t2 = 0; t2 < o3.length; t2++)
    t2 >= i && t2 < i + 6 ? c4[f7++] = o3[t2] : l6[u4++] = o3[t2];
  if (r(e6.vertexAttributes.uv)) {
    const t2 = new Float32Array(e6.vertexAttributes.uv), n4 = 4 * a5 * 2, r5 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let e7 = 0; e7 < r5.length; e7++)
      t2[n4 + e7] = r5[e7];
    e6.vertexAttributes.uv = t2;
  }
  return e6.components = [new f3({ faces: c4, material: r4.material }), new f3({ faces: l6 })], e6;
}
function f6(t2 = 0) {
  const e6 = Math.round(8 * 2 ** t2), n3 = 2 * e6, r4 = (e6 - 1) * (n3 + 1) + 2 * n3, o3 = new Float64Array(3 * r4), s4 = new Float32Array(3 * r4), a5 = new Float32Array(2 * r4), i = new Uint32Array(3 * ((e6 - 1) * n3 * 2));
  let c4 = 0, l6 = 0, f7 = 0, u4 = 0;
  for (let h4 = 0; h4 <= e6; h4++) {
    const t3 = h4 / e6 * Math.PI + 0.5 * Math.PI, r5 = Math.cos(t3), p9 = Math.sin(t3);
    F2[2] = p9;
    const m6 = 0 === h4 || h4 === e6, w5 = m6 ? n3 - 1 : n3;
    for (let v5 = 0; v5 <= w5; v5++) {
      const t4 = v5 / w5 * 2 * Math.PI;
      F2[0] = -Math.sin(t4) * r5, F2[1] = Math.cos(t4) * r5;
      for (let e7 = 0; e7 < 3; e7++)
        o3[c4] = 0.5 * F2[e7], s4[c4] = F2[e7], ++c4;
      a5[l6++] = (v5 + (m6 ? 0.5 : 0)) / n3, a5[l6++] = h4 / e6, 0 !== h4 && v5 !== n3 && (h4 !== e6 && (i[f7++] = u4, i[f7++] = u4 + 1, i[f7++] = u4 - n3), 1 !== h4 && (i[f7++] = u4, i[f7++] = u4 - n3, i[f7++] = u4 - n3 - 1)), u4++;
    }
  }
  return { position: o3, normal: s4, uv: a5, faces: i };
}
function u3(t2 = 0) {
  const e6 = 5, n3 = Math.round(16 * 2 ** t2), r4 = (e6 - 1) * (n3 + 1) + 2 * n3, o3 = new Float64Array(3 * r4), s4 = new Float32Array(3 * r4), a5 = new Float32Array(2 * r4), i = new Uint32Array(3 * (4 * n3));
  let c4 = 0, l6 = 0, f7 = 0, u4 = 0, h4 = 0;
  for (let p9 = 0; p9 <= e6; p9++) {
    const t3 = 0 === p9 || p9 === e6, r5 = p9 <= 1 || p9 >= e6 - 1, m6 = 2 === p9 || 4 === p9, w5 = t3 ? n3 - 1 : n3;
    for (let v5 = 0; v5 <= w5; v5++) {
      const g6 = v5 / w5 * 2 * Math.PI, A4 = t3 ? 0 : 0.5;
      F2[0] = A4 * Math.sin(g6), F2[1] = A4 * -Math.cos(g6), F2[2] = p9 <= 2 ? 0.5 : -0.5;
      for (let t4 = 0; t4 < 3; t4++)
        o3[c4++] = F2[t4], s4[l6++] = r5 ? 2 === t4 ? p9 <= 1 ? 1 : -1 : 0 : 2 === t4 ? 0 : F2[t4] / A4;
      a5[f7++] = (v5 + (t3 ? 0.5 : 0)) / n3, a5[f7++] = p9 <= 1 ? 1 * p9 / 3 : p9 <= 3 ? 1 * (p9 - 2) / 3 + 1 / 3 : 1 * (p9 - 4) / 3 + 2 / 3, m6 || 0 === p9 || v5 === n3 || (p9 !== e6 && (i[u4++] = h4, i[u4++] = h4 + 1, i[u4++] = h4 - n3), 1 !== p9 && (i[u4++] = h4, i[u4++] = h4 - n3, i[u4++] = h4 - n3 - 1)), h4++;
    }
  }
  return { position: o3, normal: s4, uv: a5, faces: i };
}
function h3(t2, e6) {
  const n3 = "number" == typeof e6 ? e6 : null != e6 ? e6.width : 1, r4 = "number" == typeof e6 ? e6 : null != e6 ? e6.height : 1;
  switch (t2) {
    case "up":
    case "down":
      return { width: n3, depth: r4 };
    case "north":
    case "south":
      return { width: n3, height: r4 };
    case "east":
    case "west":
      return { depth: n3, height: r4 };
  }
}
function p7(t2) {
  const e6 = g4.facingAxisOrderSwap[t2], n3 = g4.position, r4 = g4.normal, o3 = new Float64Array(n3.length), s4 = new Float32Array(r4.length);
  let a5 = 0;
  for (let i = 0; i < 4; i++) {
    const t3 = a5;
    for (let i2 = 0; i2 < 3; i2++) {
      const c4 = e6[i2], l6 = Math.abs(c4) - 1, f7 = c4 >= 0 ? 1 : -1;
      o3[a5] = n3[t3 + l6] * f7, s4[a5] = r4[t3 + l6] * f7, a5++;
    }
  }
  return { position: o3, normal: s4, uv: new Float32Array(g4.uv), faces: new Uint32Array(g4.faces), isPlane: true };
}
var m5 = 1;
var w3 = 2;
var v3 = 3;
var g4 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [v3, m5, w3], west: [-v3, -m5, w3], north: [-m5, v3, w3], south: [m5, -v3, w3], up: [m5, w3, v3], down: [m5, -w3, -v3] } };
function A2(t2, e6, n3) {
  t2.isPlane || y4(t2), x5(t2, n3 && n3.size);
  const { vertexAttributes: r4, transform: o3 } = k3(t2, e6, n3);
  return { vertexAttributes: new p4({ ...r4, uv: t2.uv }), transform: o3, components: [new f3({ faces: t2.faces, material: n3 && n3.material || null })], spatialReference: e6.spatialReference };
}
function y4(t2) {
  for (let e6 = 0; e6 < t2.position.length; e6 += 3)
    t2.position[e6 + 2] += 0.5;
}
function x5(t2, e6) {
  if (null == e6)
    return;
  const o3 = "number" == typeof e6 ? [e6, e6, e6] : [null != e6.width ? e6.width : 1, null != e6.depth ? e6.depth : 1, null != e6.height ? e6.height : 1];
  O4[0] = o3[0], O4[4] = o3[1], O4[8] = o3[2];
  for (let r4 = 0; r4 < t2.position.length; r4 += 3) {
    for (let e7 = 0; e7 < 3; e7++)
      F2[e7] = t2.position[r4 + e7];
    O2(F2, F2, O4);
    for (let e7 = 0; e7 < 3; e7++)
      t2.position[r4 + e7] = F2[e7];
  }
  if (o3[0] !== o3[1] || o3[1] !== o3[2]) {
    O4[0] = 1 / o3[0], O4[4] = 1 / o3[1], O4[8] = 1 / o3[2];
    for (let e7 = 0; e7 < t2.normal.length; e7 += 3) {
      for (let n3 = 0; n3 < 3; n3++)
        F2[n3] = t2.normal[e7 + n3];
      O2(F2, F2, O4), z(F2, F2);
      for (let n3 = 0; n3 < 3; n3++)
        t2.normal[e7 + n3] = F2[n3];
    }
  }
}
var d3 = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var M4 = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var F2 = n2();
var O4 = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var $ = s.getLogger("esri.geometry.support.meshUtils.rotate");
function z2(t2, r4, o3) {
  if (!t2.vertexAttributes || !t2.vertexAttributes.position || 0 === r4[3])
    return;
  const i = t2.spatialReference;
  if (r(t2.transform)) {
    null != (o3 == null ? void 0 : o3.geographic) && o3.geographic !== t2.transform.geographic && $.warn(`Specifying the 'geographic' parameter (${o3.geographic}) different from the Mesh transform setting (${t2.transform.geographic}) is not supported`);
    const e6 = (o3 == null ? void 0 : o3.origin) ?? t2.transform.getOriginPoint(i);
    C2(t2.transform, r4, e6);
  } else {
    const e6 = (o3 == null ? void 0 : o3.origin) ?? t2.origin;
    r3(t2.spatialReference, o3) ? I(t2, r4, e6) : U(t2, r4, e6);
  }
}
function C2(t2, e6, r4) {
  const o3 = o(E, r4.x, r4.y, r4.z), i = e2(E, o3, t2.origin);
  t2.applyLocalInverse(i, M5), t2.rotation = g(t2.rotation, e6, a2()), t2.applyLocalInverse(i, i), e2(i, i, M5), t2.translation = u(n2(), t2.translation, i);
}
function I(t2, r4, i) {
  const n3 = t2.spatialReference, s4 = O(n3), a5 = Z;
  Hn(i, a5, s4) || Hn(t2.origin, a5, s4);
  const c4 = t2.vertexAttributes.position, f7 = t2.vertexAttributes.normal, m6 = t2.vertexAttributes.tangent, g6 = new Float64Array(c4.length), l6 = r(f7) ? new Float32Array(f7.length) : null, v5 = r(m6) ? new Float32Array(m6.length) : null;
  qn(s4, a5, P, s4), a(S, P);
  const x7 = O5;
  O2(l2(O5), l2(r4), S), x7[3] = r4[3], M2(c4, n3, g6), r(f7) && j2(f7, c4, g6, n3, l6), r(m6) && k2(m6, c4, g6, n3, v5), D(g6, x7, 3, a5), O3(g6, c4, n3), r(f7) && (D(l6, x7, 3), h(l6, c4, g6, n3, f7)), r(m6) && (D(v5, x7, 4), L3(v5, c4, g6, n3, m6)), t2.vertexAttributesChanged();
}
function U(t2, e6, r4) {
  const o3 = Z;
  if (!Hn(r4, o3, t2.spatialReference)) {
    const e7 = t2.origin;
    o3[0] = e7.x, o3[1] = e7.y, o3[2] = e7.z, $.error(`Failed to project specified origin (wkid:${r4.spatialReference.wkid}) to mesh spatial reference (wkid:${t2.spatialReference.wkid}).`);
  }
  D(t2.vertexAttributes.position, e6, 3, o3), D(t2.vertexAttributes.normal, e6, 3), D(t2.vertexAttributes.tangent, e6, 4), t2.vertexAttributesChanged();
}
function D(t2, e6, o3, i = f2) {
  if (!t(t2)) {
    p3(P, x(e6), l2(e6));
    for (let e7 = 0; e7 < t2.length; e7 += o3) {
      for (let r4 = 0; r4 < 3; r4++)
        E[r4] = t2[e7 + r4] - i[r4];
      L(E, E, P);
      for (let r4 = 0; r4 < 3; r4++)
        t2[e7 + r4] = E[r4] + i[r4];
    }
  }
}
var E = n2();
var M5 = n2();
var O5 = a2();
var P = e4();
var S = e3();
var Z = n2();

// node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var v4 = s.getLogger("esri.geometry.support.meshUtils.scale");
function d4(e6, r4, o3) {
  if (!e6.vertexAttributes || !e6.vertexAttributes.position)
    return;
  const i = e6.spatialReference;
  if (r(e6.transform)) {
    null != (o3 == null ? void 0 : o3.geographic) && o3.geographic !== e6.transform.geographic && v4.warn(`Specifying the 'geographic' parameter (${o3.geographic}) different from the Mesh transform setting (${e6.transform.geographic}) is not supported`);
    const t2 = (o3 == null ? void 0 : o3.origin) ?? e6.transform.getOriginPoint(i);
    x6(e6.transform, r4, t2);
  } else {
    const t2 = r3(e6.spatialReference, o3), i2 = o3 && o3.origin || e6.origin;
    t2 ? A3(e6, r4, i2) : b2(e6, r4, i2);
  }
}
function x6(e6, t2, a5) {
  const c4 = o(w4, a5.x, a5.y, a5.z), p9 = e2(w4, c4, e6.origin);
  e6.applyLocalInverse(p9, k5);
  const f7 = q(n2(), e6.scale, t2);
  e6.scale = f7, e6.applyLocalInverse(p9, p9), e2(p9, p9, k5), e6.translation = u(n2(), e6.translation, p9);
}
function A3(e6, r4, o3) {
  const i = e6.spatialReference, n3 = O(i), s4 = R;
  Hn(o3, s4, n3) || Hn(e6.origin, s4, n3);
  const a5 = e6.vertexAttributes.position, f7 = e6.vertexAttributes.normal, v5 = e6.vertexAttributes.tangent, d5 = new Float64Array(a5.length), x7 = r(f7) ? new Float32Array(f7.length) : null, A4 = r(v5) ? new Float32Array(v5.length) : null;
  M2(a5, i, d5), r(f7) && j2(f7, a5, d5, i, x7), r(v5) && k2(v5, a5, d5, i, A4), y5(d5, r4, s4), O3(d5, a5, i), r(f7) && h(x7, a5, d5, i, f7), r(v5) && L3(A4, a5, d5, i, v5), e6.vertexAttributesChanged();
}
function b2(e6, t2, r4) {
  const o3 = R;
  if (!Hn(r4, o3, e6.spatialReference)) {
    const t3 = e6.origin;
    o3[0] = t3.x, o3[1] = t3.y, o3[2] = t3.z, v4.error(`Failed to project specified origin (wkid:${r4.spatialReference.wkid}) to mesh spatial reference (wkid:${e6.spatialReference.wkid}).`);
  }
  y5(e6.vertexAttributes.position, t2, o3), e6.vertexAttributesChanged();
}
function y5(e6, t2, r4 = f2) {
  if (e6)
    for (let o3 = 0; o3 < e6.length; o3 += 3) {
      for (let t3 = 0; t3 < 3; t3++)
        w4[t3] = e6[o3 + t3] - r4[t3];
      q(w4, w4, t2);
      for (let t3 = 0; t3 < 3; t3++)
        e6[o3 + t3] = w4[t3] + r4[t3];
    }
}
var w4 = n2();
var k5 = n2();
var R = n2();

// node_modules/@arcgis/core/geometry/Mesh.js
var I2;
var B = s.getLogger("esri.geometry.Mesh");
var k6 = I2 = class extends a3(m2.LoadableMixin(m(p2))) {
  constructor(e6) {
    super(e6), this.components = null, this.transform = null, this.external = null, this.hasZ = true, this.hasM = false, this.vertexAttributes = new p4(), this.type = "mesh";
  }
  initialize() {
    (t(this.external) || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.handles.add(l(() => {
        var _a;
        return { vertexAttributes: this.vertexAttributes, components: (_a = this.components) == null ? void 0 : _a.map((e6) => e6.clone()), transform: r(this.transform) ? this.transform.clone() : null };
      }, () => this._set("external", null), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    return !this.loaded && r(this.external) && r(this.external.extent) || this.loaded && this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0);
  }
  get boundingInfo() {
    const e6 = this.vertexAttributes.position, t2 = this.spatialReference;
    if (0 === e6.length || this.components && 0 === this.components.length)
      return { extent: new M({ xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0, spatialReference: t2 }), center: new j({ x: 0, y: 0, z: 0, spatialReference: t2 }) };
    const o3 = r(this.transform) ? this.transform.project(e6, t2) : e6;
    let r4 = 1 / 0, n3 = 1 / 0, s4 = 1 / 0, a5 = -1 / 0, l6 = -1 / 0, p9 = -1 / 0, c4 = 0, m6 = 0, h4 = 0;
    const f7 = o3.length, d5 = 1 / (f7 / 3);
    let y7 = 0;
    for (; y7 < f7; ) {
      const e7 = o3[y7++], t3 = o3[y7++], i = o3[y7++];
      r4 = Math.min(r4, e7), n3 = Math.min(n3, t3), s4 = Math.min(s4, i), a5 = Math.max(a5, e7), l6 = Math.max(l6, t3), p9 = Math.max(p9, i), c4 += d5 * e7, m6 += d5 * t3, h4 += d5 * i;
    }
    return { extent: new M({ xmin: r4, ymin: n3, zmin: s4, xmax: a5, ymax: l6, zmax: p9, spatialReference: t2 }), center: new j({ x: c4, y: m6, z: h4, spatialReference: t2 }) };
  }
  get anchor() {
    if (r(this.transform))
      return this.transform.getOriginPoint(this.spatialReference);
    const e6 = this.boundingInfo;
    return new j({ x: e6.center.x, y: e6.center.y, z: e6.extent.zmin, spatialReference: this.spatialReference });
  }
  get origin() {
    return r(this.transform) ? this.transform.getOriginPoint(this.spatialReference) : this.boundingInfo.center;
  }
  get extent() {
    return !this.loaded && r(this.external) && r(this.external.extent) ? this.external.extent.clone() : this.boundingInfo.extent;
  }
  addComponent(e6) {
    this.loaded ? (this.components || (this.components = []), this.components.push(f3.from(e6)), this.notifyChange("components")) : B.error("addComponent()", "Mesh must be loaded before applying operations");
  }
  removeComponent(e6) {
    if (this.loaded) {
      if (this.components) {
        const t2 = this.components.indexOf(e6);
        if (-1 !== t2)
          return this.components.splice(t2, 1), void this.notifyChange("components");
      }
      B.error("removeComponent()", "Provided component is not part of the list of components");
    } else
      B.error("removeComponent()", "Mesh must be loaded before applying operations");
  }
  rotate(e6, t2, o3, r4) {
    return k(D2.x, e6, W), k(D2.y, t2, Z2), k(D2.z, o3, _2), g(W, Z2, W), g(W, _2, W), z2(this, W, r4), this;
  }
  offset(e6, t2, o3, r4) {
    return this.loaded ? (H[0] = e6, H[1] = t2, H[2] = o3, A(this, H, r4), this) : (B.error("offset()", "Mesh must be loaded before applying operations"), this);
  }
  scale(e6, t2) {
    return this.loaded ? (d4(this, e6, t2), this) : (B.error("scale()", "Mesh must be loaded before applying operations"), this);
  }
  centerAt(e6, t2) {
    return this.loaded ? (c(this, e6, t2), this) : (B.error("centerAt()", "Mesh must be loaded before applying operations"), this);
  }
  load(e6) {
    return r(this.external) && this.addResolvingPromise(f5(this, this.external.source, e6)), Promise.resolve(this);
  }
  clone() {
    const e6 = this.components ? /* @__PURE__ */ new Map() : null, t2 = this.components ? /* @__PURE__ */ new Map() : null, o3 = { components: this.components ? this.components.map((o4) => o4.cloneWithDeduplication(e6, t2)) : null, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes.clone(), transform: r(this.transform) ? this.transform.clone() : null, external: r(this.external) ? { source: this.external.source, extent: r(this.external.extent) ? this.external.extent.clone() : null } : null };
    return new I2(o3);
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e6) {
    const { toBinaryGLTF: t2 } = await import("./gltfexport-LDJB6ZOC.js");
    return t2(this, e6);
  }
  static createBox(e6, t2) {
    if (!(e6 instanceof j))
      return B.error(".createBox()", "expected location to be a Point instance"), null;
    const o3 = new I2(A2(c2(), e6, t2));
    return t2 && t2.imageFace && "all" !== t2.imageFace ? l4(o3, t2.imageFace) : o3;
  }
  static createSphere(e6, t2) {
    return e6 instanceof j ? new I2(A2(f6(t2 && t2.densificationFactor || 0), e6, t2)) : (B.error(".createSphere()", "expected location to be a Point instance"), null);
  }
  static createCylinder(e6, t2) {
    return e6 instanceof j ? new I2(A2(u3(t2 && t2.densificationFactor || 0), e6, t2)) : (B.error(".createCylinder()", "expected location to be a Point instance"), null);
  }
  static createPlane(e6, t2) {
    if (!(e6 instanceof j))
      return B.error(".createPlane()", "expected location to be a Point instance"), null;
    const o3 = (t2 == null ? void 0 : t2.facing) ?? "up", r4 = h3(o3, t2 == null ? void 0 : t2.size);
    return new I2(A2(p7(o3), e6, { ...t2, size: r4 }));
  }
  static createFromPolygon(e6, t2) {
    if (!(e6 instanceof v))
      return B.error(".createFromPolygon()", "expected polygon to be a Polygon instance"), null;
    const o3 = o2(e6);
    return new I2({ vertexAttributes: new p4({ position: o3.position }), components: [new f3({ faces: o3.faces, shading: "flat", material: t2 && t2.material || null })], spatialReference: e6.spatialReference });
  }
  static async createFromGLTF(e6, o3, r4) {
    if (!(e6 instanceof j))
      throw B.error(".createfromGLTF()", "expected location to be a Point instance"), new s2("invalid-input", "Expected location to be a Point instance");
    const { loadGLTFMesh: n3 } = await y(import("./loadGLTFMesh-OCS46BSO.js"), r4);
    return new I2(await n3(e6, o3, r4));
  }
  static createWithExternalSource(e6, t2, o3) {
    const r4 = (o3 == null ? void 0 : o3.extent) ?? null, n3 = (o3 == null ? void 0 : o3.transform.clone()) ?? new L2();
    n3.origin = [e6.x, e6.y, e6.z ?? 0];
    const s4 = e6.spatialReference;
    return new I2({ external: { source: t2, extent: r4 }, transform: n3, spatialReference: s4 });
  }
  static createIncomplete(e6, o3) {
    const r4 = (o3 == null ? void 0 : o3.transform.clone()) ?? new L2();
    r4.origin = [e6.x, e6.y, e6.z ?? 0];
    const n3 = e6.spatialReference, s4 = new I2({ transform: r4, spatialReference: n3 });
    return s4.addResolvingPromise(Promise.reject(new s2("mesh-incomplete", "Mesh resources are not complete"))), s4;
  }
};
e([d({ type: [f3], json: { write: true } })], k6.prototype, "components", void 0), e([d({ type: L2, json: { write: true } })], k6.prototype, "transform", void 0), e([d({ constructOnly: true })], k6.prototype, "external", void 0), e([d({ readOnly: true })], k6.prototype, "hasExtent", null), e([d({ readOnly: true })], k6.prototype, "boundingInfo", null), e([d({ readOnly: true })], k6.prototype, "anchor", null), e([d({ readOnly: true })], k6.prototype, "origin", null), e([d({ readOnly: true, json: { read: false } })], k6.prototype, "extent", null), e([d({ readOnly: true, json: { read: false, write: true, default: true } })], k6.prototype, "hasZ", void 0), e([d({ readOnly: true, json: { read: false, write: true, default: false } })], k6.prototype, "hasM", void 0), e([d({ type: p4, nonNullable: true, json: { write: true } })], k6.prototype, "vertexAttributes", void 0), k6 = I2 = e([n("esri.geometry.Mesh")], k6);
var D2 = { x: r2(1, 0, 0), y: r2(0, 1, 0), z: r2(0, 0, 1) };
var W = a2();
var Z2 = a2();
var _2 = a2();
var H = n2();
var N = k6;

// node_modules/@arcgis/core/layers/support/infoFor3D.js
var s3;
var e5;
!function(s4) {
  s4.featureGUID = "featureGUID", s4.assetName = "assetName", s4.hash = "hash", s4.type = "type", s4.conversionStatus = "conversionStatus", s4.flags = "flags", s4.complexity = "complexity", s4.size = "size", s4.seqNo = "seqNo", s4.sourceHash = "sourceHash", s4.assetURL = "assetURL";
}(s3 || (s3 = {})), function(s4) {
  s4.SUBMITTED = "SUBMITTED", s4.INPROGRESS = "INPROGRESS", s4.FAILED = "FAILED", s4.COMPLETED = "COMPLETED";
}(e5 || (e5 = {}));

// node_modules/@arcgis/core/rest/support/meshFeatureSet.js
function c3(o3, s4, n3) {
  const a5 = n3.features;
  n3.features = [], delete n3.geometryType;
  const i = x3.fromJSON(n3);
  i.geometryType = "mesh";
  const u4 = i.spatialReference, f7 = t(o3.outFields) || !o3.outFields.length ? () => ({}) : l5(o3.outFields.includes("*") ? null : new Set(o3.outFields));
  for (const e6 of a5) {
    const o4 = p8(e6, u4, s4);
    r(o4) && i.features.push(new g2({ geometry: o4, attributes: f7(e6) }));
  }
  return i;
}
function l5(t2) {
  return ({ attributes: e6 }) => {
    if (!e6)
      return {};
    if (!t2)
      return e6;
    for (const r4 in e6)
      t2.has(r4) || delete e6[r4];
    return e6;
  };
}
function p8(t2, e6, r4) {
  const { status: n3, source: a5 } = D3(t2);
  if (n3 === y6.FAILED)
    return null;
  const i = g5(t2, e6, r4), u4 = M.fromJSON(t2.geometry);
  u4.spatialReference = e6;
  const f7 = E2(t2, r4);
  return n3 === y6.PENDING ? N.createIncomplete(i, { extent: u4, transform: f7 }) : N.createWithExternalSource(i, a5, { extent: u4, transform: f7 });
}
function g5({ attributes: t2 }, e6, { transformFieldRoles: r4 }) {
  return new j({ x: t2[r4.originX], y: t2[r4.originY], z: t2[r4.originZ], spatialReference: e6 });
}
function E2({ attributes: t2, assetMappings: e6 }, { transformFieldRoles: r4 }) {
  var _a;
  return new L2({ translation: [t2[r4.translationX], t2[r4.translationY], t2[r4.translationZ]], rotation: k([t2[r4.rotationX], t2[r4.rotationY], t2[r4.rotationZ]], t2[r4.rotationDeg]), scale: [t2[r4.scaleX], t2[r4.scaleY], t2[r4.scaleZ]], geographic: !((_a = e6[s3.flags]) == null ? void 0 : _a.includes("PROJECT_VERTICES")) });
}
function D3(t2) {
  if (!t2.assetMappings)
    return { status: y6.FAILED };
  const e6 = [], r4 = /* @__PURE__ */ new Map();
  for (const o3 of t2.assetMappings) {
    const t3 = o3[s3.seqNo], s4 = o3[s3.assetName], n3 = o3[s3.assetURL], a5 = o3[s3.conversionStatus];
    if (a5 === e5.FAILED)
      return { status: y6.FAILED };
    if (a5 !== e5.COMPLETED)
      return { status: y6.PENDING };
    if (null == t3)
      e6.push({ name: s4, source: n3 });
    else {
      const o4 = r4.get(s4);
      let a6;
      o4 ? a6 = o4.multipart : (a6 = [], e6.push({ name: s4, source: { multipart: a6 } }), r4.set(s4, { multipart: a6 })), a6[t3] = n3;
    }
  }
  return { status: y6.COMPLETED, source: e6 };
}
var y6;
!function(t2) {
  t2[t2.FAILED = 0] = "FAILED", t2[t2.PENDING = 1] = "PENDING", t2[t2.COMPLETED = 2] = "COMPLETED";
}(y6 || (y6 = {}));
export {
  c3 as meshFeatureSetFromJSON
};
//# sourceMappingURL=meshFeatureSet-ZMVSY6IE.js.map
