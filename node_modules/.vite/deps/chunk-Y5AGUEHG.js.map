{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sUniform.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{Uniform as r}from\"./Uniform.js\";import{BindType as s}from\"../shaderTechnique/BindType.js\";class e extends r{constructor(r,e,t,i){switch(e){case s.Pass:return void super(r,\"mat4\",e,((s,e,i)=>s.setUniformMatrix4fv(r,t(e,i))),i);case s.Draw:return void super(r,\"mat4\",e,((s,e,i)=>s.setUniformMatrix4fv(r,t(e,i))),i)}}}export{e as Matrix4sUniform};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{c as e}from\"../../../../../../chunks/vec3f64.js\";import{RgbaFloatEncoding as a}from\"../util/RgbaFloatEncoding.glsl.js\";import{Float4PassUniform as s}from\"../../shaderModules/Float4PassUniform.js\";import{FloatPassUniform as o}from\"../../shaderModules/FloatPassUniform.js\";import{IntegerPassUniform as t}from\"../../shaderModules/IntegerPassUniform.js\";import{NoParameters as i,glsl as r}from\"../../shaderModules/interfaces.js\";import{Matrix4sUniform as d}from\"../../shaderModules/Matrix4sUniform.js\";import{Texture2DPassUniform as l}from\"../../shaderModules/Texture2DPassUniform.js\";import{BindType as p}from\"../../shaderTechnique/BindType.js\";class n extends i{constructor(){super(...arguments),this.origin=e()}}function h(e,a){a.receiveShadows&&(e.fragment.uniforms.add(new d(\"shadowMapMatrix\",p.Pass,((e,a)=>a.shadowMap.getShadowMapMatrices(e.origin)),4)),v(e))}function c(e,a){a.receiveShadows&&(e.fragment.uniforms.add(new d(\"shadowMapMatrix\",p.Draw,((e,a)=>a.shadowMap.getShadowMapMatrices(e.origin)),4)),v(e))}function v(e){const i=e.fragment;i.include(a),i.uniforms.add([new l(\"shadowMapTex\",((e,a)=>a.shadowMap.depthTexture)),new t(\"numCascades\",((e,a)=>a.shadowMap.numCascades)),new s(\"cascadeDistances\",((e,a)=>a.shadowMap.cascadeDistances)),new o(\"depthHalfPixelSz\",((e,a)=>.5/a.shadowMap.textureSize))]),i.code.add(r`int chooseCascade(float depth, out mat4 mat) {\nvec4 distance = cascadeDistances;\nint i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\nmat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\nreturn i;\n}\nvec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\nvec4 lv = mat * vec4(_vpos, 1.0);\nlv.xy /= lv.w;\nreturn 0.5 * lv.xyz + vec3(0.5);\n}\nvec2 cascadeCoordinates(int i, vec3 lvpos) {\nreturn vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n}\nfloat readShadowMapDepth(vec2 uv, sampler2D _depthTex) {\nreturn rgba2float(texture2D(_depthTex, uv));\n}\nfloat posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {\nreturn readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\n}\nfloat filterShadow(vec2 uv, vec3 lvpos, float halfPixelSize, sampler2D _depthTex) {\nfloat texSize = 0.5 / halfPixelSize;\nvec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\nfloat s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);\nfloat s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);\nfloat s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);\nfloat s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);\nreturn mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n}\nfloat readShadowMap(const in vec3 _vpos, float _linearDepth) {\nmat4 mat;\nint i = chooseCascade(_linearDepth, mat);\nif (i >= numCascades) { return 0.0; }\nvec3 lvpos = lightSpacePosition(_vpos, mat);\nif (lvpos.z >= 1.0) { return 0.0; }\nif (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\nvec2 uv = cascadeCoordinates(i, lvpos);\nreturn filterShadow(uv, lvpos, depthHalfPixelSz, shadowMapTex);\n}`)}export{n as ReadShadowMapBindParameters,c as ReadShadowMapDraw,h as ReadShadowMapPass};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIiG,IAAMA,KAAN,cAAgB,EAAC;AAAA,EAAC,YAAY,GAAEA,IAAEC,IAAEC,IAAE;AAAC,YAAOF,IAAE;AAAA,MAAC,KAAK,EAAE;AAAK,eAAO,KAAK,MAAM,GAAE,QAAOA,IAAG,CAAC,GAAEA,IAAEE,OAAI,EAAE,oBAAoB,GAAED,GAAED,IAAEE,EAAC,CAAC,GAAGA,EAAC;AAAA,MAAE,KAAK,EAAE;AAAK,eAAO,KAAK,MAAM,GAAE,QAAOF,IAAG,CAAC,GAAEA,IAAEE,OAAI,EAAE,oBAAoB,GAAED,GAAED,IAAEE,EAAC,CAAC,GAAGA,EAAC;AAAA,IAAC;AAAA,EAAC;AAAC;;;ACAwU,IAAMC,KAAN,cAAgB,EAAC;AAAA,EAAC,cAAa;AAAC,UAAM,GAAG,SAAS,GAAE,KAAK,SAAO,EAAE;AAAA,EAAC;AAAC;AAAC,SAAS,EAAEC,IAAEC,IAAE;AAAC,EAAAA,GAAE,mBAAiBD,GAAE,SAAS,SAAS,IAAI,IAAIA,GAAE,mBAAkB,EAAE,MAAM,CAACA,IAAEC,OAAIA,GAAE,UAAU,qBAAqBD,GAAE,MAAM,GAAG,CAAC,CAAC,GAAE,EAAEA,EAAC;AAAE;AAAC,SAASE,GAAEF,IAAEC,IAAE;AAAC,EAAAA,GAAE,mBAAiBD,GAAE,SAAS,SAAS,IAAI,IAAIA,GAAE,mBAAkB,EAAE,MAAM,CAACA,IAAEC,OAAIA,GAAE,UAAU,qBAAqBD,GAAE,MAAM,GAAG,CAAC,CAAC,GAAE,EAAEA,EAAC;AAAE;AAAC,SAAS,EAAEA,IAAE;AAAC,QAAMG,KAAEH,GAAE;AAAS,EAAAG,GAAE,QAAQF,EAAC,GAAEE,GAAE,SAAS,IAAI,CAAC,IAAI,EAAE,gBAAgB,CAACH,IAAEC,OAAIA,GAAE,UAAU,YAAa,GAAE,IAAI,EAAE,eAAe,CAACD,IAAEC,OAAIA,GAAE,UAAU,WAAY,GAAE,IAAID,GAAE,oBAAoB,CAACA,IAAEC,OAAIA,GAAE,UAAU,gBAAiB,GAAE,IAAI,EAAE,oBAAoB,CAACD,IAAEC,OAAI,MAAGA,GAAE,UAAU,WAAY,CAAC,CAAC,GAAEE,GAAE,KAAK,IAAIJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsCnzC;AAAC;",
  "names": ["e", "t", "i", "n", "e", "a", "c", "i"]
}
