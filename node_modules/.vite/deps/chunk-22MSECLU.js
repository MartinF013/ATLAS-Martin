import {
  r as r3
} from "./chunk-PTJ3MGYO.js";
import {
  o as o2
} from "./chunk-G4ERZR5M.js";
import {
  w
} from "./chunk-GRW2GUB3.js";
import {
  l
} from "./chunk-ZN2MGN4S.js";
import {
  rn
} from "./chunk-PZWU5EHT.js";
import {
  j as j2
} from "./chunk-TT2HIXWQ.js";
import {
  c
} from "./chunk-NWRK6QLX.js";
import {
  o
} from "./chunk-BPZGJQOB.js";
import {
  r as r2
} from "./chunk-AIRC226G.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  D
} from "./chunk-U3PSONS6.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  e as e2,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/interactive/dragEventPipeline.js
function f(t2, n2) {
  let e4 = null, a = null;
  return (c3) => {
    if ("cancel" === c3.action)
      return void (r(a) && (a.execute({ action: "cancel" }), e4 = null, a = null));
    const s2 = { action: c3.action, screenStart: c3.start, screenEnd: c3.screenPoint };
    "start" === c3.action && t(e4) && (e4 = new G(), a = new G(), n2(t2, e4, a, c3.pointerType, s2)), r(e4) && e4.execute(s2), "end" === c3.action && r(e4) && (e4 = null, a = null);
  };
}
function p(t2, n2) {
  return t2.events.on("drag", f(t2, n2));
}
function d2(t2, n2) {
  const e4 = [t2.x, t2.y, t2.z], r6 = n2, o3 = [Math.cos(r6), Math.sin(r6)], a = Math.sqrt(o3[0] * o3[0] + o3[1] * o3[1]);
  if (0 === a)
    return null;
  o3[0] /= a, o3[1] /= a;
  const c3 = (t3) => {
    const n3 = (t3.x - e4[0]) * o3[0] + (t3.y - e4[1]) * o3[1];
    t3.x = e4[0] + n3 * o3[0], t3.y = e4[1] + n3 * o3[1];
  };
  return (t3) => (c3(t3.mapStart), c3(t3.mapEnd), t3);
}
function x(t2, n2) {
  let e4 = null;
  return (r6) => {
    if ("start" === r6.action && (e4 = h(t2, r6.mapStart.spatialReference, n2)), t(e4))
      return null;
    const a = r6.mapEnd.x - r6.mapStart.x, c3 = r6.mapEnd.y - r6.mapStart.y, s2 = r6.mapEnd.z - r6.mapStart.z;
    return e4.move(a, c3, s2), { ...r6, translationX: a, translationY: c3, translationZ: s2 };
  };
}
function g(t2, n2) {
  return t(t2) ? null : t2.spatialReference.equals(n2) ? t2.clone() : rn(t2, n2);
}
function h(t2, n2, e4) {
  const r6 = t2.geometry;
  if (t(r6))
    return null;
  if ("mesh" === r6.type)
    return E(t2, r6, n2, e4);
  const a = g(r6, n2), c3 = r6.spatialReference;
  return t(a) ? null : { move: (n3, e5, r7) => {
    const o3 = r3(a.clone(), n3, e5, r7);
    o3.spatialReference.equals(c3) ? t2.geometry = o3 : t2.geometry = rn(o3, c3);
  } };
}
function E(t2, n2, e4, o3) {
  if (r(n2.transform))
    return S(t2, n2, n2.transform, e4);
  if (!n2.spatialReference.equals(e4))
    return null;
  let a = 0, c3 = 0, s2 = 0;
  return { move: (e5, r6, i) => {
    const u = e5 - a, f2 = r6 - c3, p2 = i - s2;
    if (u || f2 || p2) {
      const y2 = new j(n2.origin.x + u, n2.origin.y + f2, n2.origin.z + p2, n2.origin.spatialReference);
      n2.centerAt(y2, { geographic: o3 === l.Global }), t2.notifyGeometryChanged(), a = e5, c3 = r6, s2 = i;
    }
  } };
}
function S(t2, n2, e4, a) {
  const c3 = g(e4.getOriginPoint(n2.spatialReference), a), l2 = n2.spatialReference;
  return t(c3) ? null : { move: (n3, o3, a2) => {
    const m2 = r3(c3.clone(), n3, o3, a2);
    if (m2.spatialReference.equals(l2))
      e4.origin = r2(m2.x, m2.y, m2.z);
    else {
      const t3 = rn(m2, l2);
      r(t3) && (e4.origin = r2(t3.x, t3.y, t3.z));
    }
    t2.notifyMeshTransformChanged(), t2.notifyGeometryChanged();
  } };
}
function j3(t2, n2 = null, e4) {
  let a = null;
  const c3 = r(n2) && !t2.spatialReference.equals(n2) ? (t3) => r(t3) ? rn(t3, n2) : t3 : (t3) => t3, s2 = { exclude: [], ...e4 };
  return (n3) => {
    if ("start" === n3.action && (a = c3(t2.toMap(n3.screenStart, s2))), t(a))
      return null;
    const e5 = c3(t2.toMap(n3.screenEnd, s2));
    return r(e5) ? { ...n3, mapStart: a, mapEnd: e5 } : null;
  };
}
function R(t2, n2) {
  const e4 = t2.map((t3) => e2(x(t3, n2))).filter((t3) => r(t3));
  return (t3) => {
    const n3 = t3.mapEnd.x - t3.mapStart.x, r6 = t3.mapEnd.y - t3.mapStart.y, o3 = t3.mapEnd.z - t3.mapStart.z;
    return e4.forEach((n4) => n4(t3)), { ...t3, translationX: n3, translationY: r6, translationZ: o3 };
  };
}
function z(t2, e4) {
  const r6 = /* @__PURE__ */ new Map();
  for (const o3 of e4)
    r6.set(o3, m(t2[o3]));
  return (n2) => (r6.forEach((n3, e5) => {
    t2[e5] = n3;
  }), n2);
}
function w2(t2) {
  return r(t2.geometry) && "mesh" === t2.geometry.type ? v(t2, t2.geometry) : z(t2, ["geometry"]);
}
function v(t2, n2) {
  const e4 = r(n2.transform) ? n2.transform.clone() : null, o3 = n2.vertexAttributes.clonePositional();
  return (r6) => (n2.transform = e4, n2.vertexAttributes = o3, t2.notifyGeometryChanged(), r6);
}
function M(t2) {
  const n2 = t2.map((t3) => e2(w2(t3))).filter((t3) => r(t3));
  return (t3) => (n2.forEach((n3) => n3(t3)), t3);
}
function D2() {
  let t2 = 0, n2 = 0, e4 = 0;
  return (r6) => {
    "start" === r6.action && (t2 = r6.mapStart.x, n2 = r6.mapStart.y, e4 = r6.mapStart.z);
    const o3 = r6.mapEnd.x - t2, a = r6.mapEnd.y - n2, c3 = r6.mapEnd.z - e4;
    return t2 = r6.mapEnd.x, n2 = r6.mapEnd.y, e4 = r6.mapEnd.z, { ...r6, mapDeltaX: o3, mapDeltaY: a, mapDeltaZ: c3, mapDeltaSpatialReference: r6.mapStart.spatialReference };
  };
}
function b() {
  let t2 = 0, n2 = 0;
  return (e4) => {
    "start" === e4.action && (t2 = e4.screenStart.x, n2 = e4.screenStart.y);
    const r6 = e4.screenEnd.x - t2, o3 = e4.screenEnd.y - n2;
    return t2 = e4.screenEnd.x, n2 = e4.screenEnd.y, { ...e4, screenDeltaX: r6, screenDeltaY: o3 };
  };
}
function C(t2, n2) {
  let r6 = null, o3 = 0, a = 0;
  return (s2) => {
    if ("start" === s2.action && (r6 = t2.toScreen(n2), r6.x < 0 || r6.x > t2.width || r6.y < 0 || r6.y > t2.height ? r6 = null : (o3 = s2.screenStart.x - r6.x, a = s2.screenStart.y - r6.y)), null == r6)
      return null;
    const i = o(s2.screenEnd.x - o3, 0, t2.width), l2 = o(s2.screenEnd.y - a, 0, t2.height), u = c(i, l2);
    return s2.screenStart = r6, s2.screenEnd = u, s2;
  };
}
var G = class {
  constructor() {
    this.execute = () => {
    };
  }
  next(t2, n2 = new G()) {
    return r(t2) && (this.execute = (e4) => {
      const o3 = t2(e4);
      r(o3) && n2.execute(o3);
    }), n2;
  }
};

// node_modules/@arcgis/core/views/interactive/ManipulatorCollection.js
var e3;
!function(t2) {
  t2[t2.WhenToolEditable = 0] = "WhenToolEditable", t2[t2.WhenToolNotEditable = 1] = "WhenToolNotEditable", t2[t2.Always = 2] = "Always";
}(e3 || (e3 = {}));
var r5 = class {
  constructor() {
    this._isToolEditable = true, this._manipulators = new j2(), this._nextManipulatorId = 0, this._resourceContexts = { manipulator3D: {} }, this._attached = false;
  }
  set isToolEditable(t2) {
    this._isToolEditable = t2;
  }
  get length() {
    return this._manipulators.length;
  }
  add(t2, a = e3.WhenToolEditable) {
    return this.addMany([t2], a)[0];
  }
  addMany(t2, a = e3.WhenToolEditable) {
    return t2.map((t3) => {
      const i = this._nextManipulatorId++, e4 = { id: i, manipulator: t3, visibilityPredicate: a, attached: false };
      return this._manipulators.add(e4), this._attached && this._updateManipulatorAttachment(e4), i;
    });
  }
  remove(t2) {
    if ("number" == typeof t2) {
      const a2 = t2;
      for (let t3 = 0; t3 < this._manipulators.length; t3++)
        if (this._manipulators.getItemAt(t3).id === a2) {
          const a3 = this._manipulators.splice(t3, 1)[0];
          return this._detachManipulator(a3), a3.id;
        }
      return null;
    }
    const a = t2;
    for (let i = 0; i < this._manipulators.length; i++)
      if (this._manipulators.getItemAt(i).manipulator === a) {
        const t3 = this._manipulators.splice(i, 1)[0];
        return this._detachManipulator(t3), t3.id;
      }
    return null;
  }
  removeAll() {
    this._manipulators.forEach((t2) => {
      this._detachManipulator(t2);
    }), this._manipulators.removeAll();
  }
  attach() {
    this._manipulators.forEach((t2) => {
      this._updateManipulatorAttachment(t2);
    }), this._attached = true;
  }
  detach() {
    this._manipulators.forEach((t2) => {
      this._detachManipulator(t2);
    }), this._attached = false;
  }
  destroy() {
    this._manipulators.forEach(({ manipulator: t2 }) => {
      t2.destroy && t2.destroy();
    }), this._manipulators.destroy(), this._resourceContexts = null;
  }
  on(t2, a) {
    return this._manipulators.on(t2, (t3) => {
      a(t3);
    });
  }
  forEach(t2) {
    for (const a of this._manipulators.items)
      t2(a);
  }
  some(t2) {
    return this._manipulators.items.some(t2);
  }
  toArray() {
    const t2 = [];
    return this.forEach((a) => t2.push(a.manipulator)), t2;
  }
  intersect(t2, a) {
    let e4 = null, r6 = Number.MAX_VALUE;
    return this._manipulators.forEach(({ id: o3, manipulator: n2, attached: s2 }) => {
      if (!s2 || !n2.interactive)
        return;
      const l2 = n2.intersectionDistance(t2, a);
      r(l2) && l2 < r6 && (r6 = l2, e4 = { id: o3, manipulator: n2 });
    }), e4;
  }
  findById(t2) {
    if (t(t2))
      return null;
    for (const a of this._manipulators.items)
      if (t2 === a.id)
        return a.manipulator;
    return null;
  }
  _updateManipulatorAttachment(t2) {
    this._isManipulatorItemVisible(t2) ? this._attachManipulator(t2) : this._detachManipulator(t2);
  }
  _attachManipulator(t2) {
    t2.attached || (t2.manipulator.attach && t2.manipulator.attach(this._resourceContexts), t2.attached = true);
  }
  _detachManipulator(t2) {
    if (!t2.attached)
      return;
    const a = t2.manipulator;
    a.grabbing = false, a.dragging = false, a.hovering = false, a.selected = false, a.detach && a.detach(this._resourceContexts), t2.attached = false;
  }
  _isManipulatorItemVisible(t2) {
    return t2.visibilityPredicate === e3.Always || (this._isToolEditable ? t2.visibilityPredicate === e3.WhenToolEditable : t2.visibilityPredicate === e3.WhenToolNotEditable);
  }
};

// node_modules/@arcgis/core/views/interactive/InteractiveToolBase.js
var h2 = s.getLogger("esri.views.interactive.InteractiveToolBase");
var c2 = class extends y {
  constructor(t2) {
    super(t2), this.manipulators = new r5(), this.preferManipulatorCursor = false, this.automaticManipulatorSelection = true, this.hasFocusedManipulators = false, this.created = false, this.removeIncompleteOnCancel = true, this._editableFlags = /* @__PURE__ */ new Map([[o2.MANAGER, true], [o2.USER, true]]), this._creationFinishedResolver = D();
  }
  get active() {
    return null != this.view && this.view.activeTool === this;
  }
  set visible(t2) {
    this._get("visible") !== t2 && (this._set("visible", t2), this._syncVisible());
  }
  get editable() {
    return this.getEditableFlag(o2.USER);
  }
  set editable(t2) {
    this.setEditableFlag(o2.USER, t2);
  }
  get updating() {
    return false;
  }
  get cursor() {
    return null;
  }
  destroy() {
    this.manipulators.destroy(), this._set("view", null);
  }
  onAdd() {
    this._syncVisible();
  }
  activate() {
    t(this.view) ? h2.error("Can't activate tool if view is not defined.") : (w(this.view) && this.view.focus(), this.onActivate());
  }
  deactivate() {
    this.onDeactivate();
  }
  handleInputEvent(t2) {
    this.onInputEvent(t2);
  }
  handleInputEventAfter(t2) {
    this.onInputEventAfter(t2);
  }
  setEditableFlag(t2, e4) {
    this._editableFlags.set(t2, e4), this.manipulators.isToolEditable = this.internallyEditable, this._updateManipulatorAttachment(), t2 === o2.USER && this.notifyChange("editable"), this.onEditableChange();
  }
  getEditableFlag(t2) {
    return this._editableFlags.get(t2);
  }
  whenCreated() {
    return this._creationFinishedResolver.promise;
  }
  onActivate() {
  }
  onDeactivate() {
  }
  onShow() {
  }
  onHide() {
  }
  onEditableChange() {
  }
  onInputEvent(t2) {
  }
  onInputEventAfter(t2) {
  }
  get internallyEditable() {
    return this.getEditableFlag(o2.USER) && this.getEditableFlag(o2.MANAGER);
  }
  finishToolCreation() {
    this.created || this._creationFinishedResolver.resolve(this), this._set("created", true);
  }
  _syncVisible() {
    if (this.constructed) {
      if (this.visible)
        this._show();
      else if (this._hide(), this.active)
        return void (this.view.activeTool = null);
    }
  }
  _show() {
    this._updateManipulatorAttachment(), this.onShow();
  }
  _hide() {
    this._updateManipulatorAttachment(), this.onHide();
  }
  _updateManipulatorAttachment() {
    this.visible ? this.manipulators.attach() : this.manipulators.detach();
  }
};
e([d({ constructOnly: true })], c2.prototype, "view", void 0), e([d({ readOnly: true })], c2.prototype, "active", null), e([d({ value: true })], c2.prototype, "visible", null), e([d({ value: true })], c2.prototype, "editable", null), e([d({ readOnly: true })], c2.prototype, "manipulators", void 0), e([d({ readOnly: true })], c2.prototype, "updating", null), e([d()], c2.prototype, "cursor", null), e([d({ readOnly: true })], c2.prototype, "preferManipulatorCursor", void 0), e([d({ readOnly: true })], c2.prototype, "automaticManipulatorSelection", void 0), e([d()], c2.prototype, "hasFocusedManipulators", void 0), e([d({ readOnly: true })], c2.prototype, "created", void 0), e([d({ readOnly: true })], c2.prototype, "removeIncompleteOnCancel", void 0), c2 = e([n("esri.views.interactive.InteractiveToolBase")], c2);

export {
  p,
  d2 as d,
  x,
  j3 as j,
  R,
  z,
  w2 as w,
  M,
  D2 as D,
  b,
  C,
  G,
  r5 as r,
  c2 as c
};
//# sourceMappingURL=chunk-22MSECLU.js.map
