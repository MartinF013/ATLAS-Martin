import {
  An,
  E,
  S,
  c,
  en,
  i,
  on,
  rn,
  s as s2,
  tn
} from "./chunk-PZWU5EHT.js";
import {
  z
} from "./chunk-RN2KRYDN.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterProjectionHelper.js
var d;
function M2(e, t2, n) {
  return !An(e, t2, n);
}
function w(t2, n, o) {
  const i2 = M2(t2, n, o);
  if (i2 && !en())
    throw new s("rasterprojectionhelper-project", "projection engine is not loaded");
  return i2;
}
!function(e) {
  e[e.None = 0] = "None", e[e.North = 1] = "North", e[e.South = 2] = "South", e[e.Both = 3] = "Both";
}(d || (d = {}));
var R = (e, t2, n, o = 0) => {
  if (1 === n[0])
    return [0, 0];
  let i2 = 1, r2 = -1, s3 = 1, a = -1;
  for (let g = 0; g < e.length; g += 2)
    isNaN(e[g]) || (i2 = i2 > e[g] ? e[g] : i2, r2 = r2 > e[g] ? r2 : e[g], s3 = s3 > e[g + 1] ? e[g + 1] : s3, a = a > e[g + 1] ? a : e[g + 1]);
  const { cols: l, rows: c2 } = t2, f = (r2 - i2) / l / n[0], u = (a - s3) / c2 / n[1], m = 2 * o;
  let x = 0, h = false, p = [0, 0];
  for (let g = 0; g < l - 3; g++) {
    for (let t3 = 0; t3 < c2 - 3; t3++) {
      const n2 = g * c2 * 2 + 2 * t3, o2 = (e[n2] + e[n2 + 4] + e[n2 + 4 * c2] + e[n2 + 4 * c2 + 4]) / 4, i3 = (e[n2 + 1] + e[n2 + 5] + e[n2 + 4 * c2 + 1] + e[n2 + 4 * c2 + 5]) / 4, r3 = Math.abs((o2 - e[n2 + 2 * c2 + 2]) / f), s4 = Math.abs((i3 - e[n2 + 2 * c2 + 3]) / u);
      if (r3 + s4 > x && (x = r3 + s4, p = [r3, s4]), m && x > m) {
        h = true;
        break;
      }
    }
    if (h)
      break;
  }
  return p;
};
var P = { 3395: 20037508342789244e-9, 3410: 17334193943686873e-9, 3857: 20037508342788905e-9, 3975: 17367530445161372e-9, 4087: 20037508342789244e-9, 4088: 20015108787169147e-9, 6933: 17367530445161372e-9, 32662: 20037508342789244e-9, 53001: 2001508679602057e-8, 53002: 1000754339801029e-8, 53003: 2001508679602057e-8, 53004: 2001508679602057e-8, 53016: 14152803599503474e-9, 53017: 17333573624304302e-9, 53034: 2001508679602057e-8, 53079: 20015114352186374e-9, 53080: 20015114352186374e-9, 54001: 20037508342789244e-9, 54002: 10018754171394624e-9, 54003: 20037508342789244e-9, 54004: 20037508342789244e-9, 54016: 14168658027268292e-9, 54017: 1736753044516137e-8, 54034: 20037508342789244e-9, 54079: 20037508342789244e-9, 54080: 20037508342789244e-9, 54100: 20037508342789244e-9, 54101: 20037508342789244e-9 };
var S2 = 32;
var b = 4;
var E2 = b;
var G = /* @__PURE__ */ new Map();
var N = /* @__PURE__ */ new Map();
async function k2() {
  if (en())
    return null;
  await tn();
}
function T(e, t2, n) {
  if (!w(e.spatialReference, t2))
    return null;
  return n ? on(t2, e.spatialReference, e) : on(e.spatialReference, t2, e);
}
function v2(e, i2, r2, s3 = null) {
  const a = e.spatialReference;
  if (a.equals(i2))
    return e;
  w(a, i2, s3);
  const l = r2.center, c2 = new M({ xmin: l.x - e.x / 2, xmax: l.x + e.x / 2, ymin: l.y - e.y / 2, ymax: l.y + e.y / 2, spatialReference: a }), f = rn(c2, i2, s3), u = X(i2);
  let m;
  if (t(f) || r(u) && f.width >= u) {
    const t2 = z(a) / z(i2);
    m = { x: e.x * t2, y: e.y * t2 };
  } else
    m = { x: f.width, y: f.height };
  return m;
}
function C(e, t2 = 0.01) {
  return z(e) ? t2 / z(e) : 0;
}
function _(e, t2, o = null, i2 = true) {
  const r2 = e.spatialReference;
  if (r2.equals(t2))
    return e;
  w(r2, t2, o);
  const s3 = rn(e, t2, o);
  if (!i2 || !s3)
    return s3;
  const a = K(r2, true), l = K(t2, true), c2 = C(r2);
  return c2 && r(a) && r(l) && (s3.x > 0 && Math.abs(e.x - a[0]) < c2 ? s3.x -= l[1] - l[0] : s3.x < 0 && Math.abs(e.x - a[1]) < c2 && (s3.x += l[1] - l[0])), s3;
}
function j2(e) {
  const { inSR: t2, outSR: o, datumTransformation: i2, preferPE: r2 } = e;
  if (t2.equals(o)) {
    const { points: t3 } = B(e, null);
    return t3;
  }
  if (t2.isWebMercator && o.isWGS84 || t2.isWGS84 && o.isWebMercator)
    return O(e);
  if (w(t2, o, i2) && r2) {
    if (t2.isGeographic)
      return W(e);
    const o2 = L(t2);
    if (r(o2))
      return W(e);
  }
  return z2(e);
}
function z2(e) {
  const { points: t2 } = B(e, null), n = t2.map((t3) => new j(t3[0], t3[1], e.inSR));
  return rn(n, e.outSR, e.datumTransformation).map((e2) => e2 ? [e2.x, e2.y] : [NaN, NaN]);
}
function W(e) {
  const { inSR: t2, outSR: o, datumTransformation: l } = e, c2 = L(t2), { points: f, mask: u } = B(e, c2);
  if (!t2.isGeographic) {
    const e2 = t2.wkid ? i.coordsys(t2.wkid) : i.fromString(t2.isGeographic ? E.PE_TYPE_GEOGCS : E.PE_TYPE_PROJCS, t2.wkt);
    s2.projToGeog(e2, f.length, f);
  }
  if (r(l) && l.steps.length && l.steps.forEach((e2) => {
    const t3 = e2.wkid ? i.geogtran(e2.wkid) : i.fromString(E.PE_TYPE_GEOGTRAN, e2.wkt);
    c.geogToGeog(t3, f.length, f, null, e2.isInverse ? E.PE_TRANSFORM_2_TO_1 : E.PE_TRANSFORM_1_TO_2);
  }), !o.isGeographic) {
    const e2 = L(o, true), t3 = r(e2) && e2.isEnvelope ? [e2.bbox[1], e2.bbox[3]] : [-90, 90];
    I(f, t3);
    const a = o.wkid ? i.coordsys(o.wkid) : i.fromString(o.isGeographic ? E.PE_TYPE_GEOGCS : E.PE_TYPE_PROJCS, o.wkt);
    s2.geogToProj(a, f.length, f);
  }
  let m = f;
  if (u && f.length !== u.length) {
    m = [];
    for (let e2 = 0, t3 = 0; e2 < u.length; e2++)
      u[e2] ? m.push(f[t3++]) : m.push([NaN, NaN]);
  }
  return m;
}
function O(e) {
  const { cols: t2, rows: n, xres: o, yres: i2, usePixelCenter: r2, inSR: s3, outSR: a } = e;
  let { xmin: l, ymax: c2 } = e;
  r2 && (l += o / 2, c2 -= i2 / 2);
  const f = [], u = [], m = Math.max(t2, n);
  for (let g = 0; g < m; g++) {
    const e2 = l + o * Math.min(t2, g), r3 = c2 - i2 * Math.min(n, g), m2 = rn(new j({ x: e2, y: r3, spatialReference: s3 }), a);
    g <= t2 && f.push(m2.x), g <= n && u.push(m2.y);
  }
  const h = [];
  for (let x = 0; x < t2; x++)
    for (let e2 = 0; e2 < n; e2++)
      h.push([f[x], u[e2]]);
  return h;
}
function L(e, t2 = false) {
  let n = e.wkid || e.wkt;
  if (!n || e.isGeographic)
    return null;
  if (n = String(n), G.has(n)) {
    const e2 = G.get(n);
    return t2 ? e2 == null ? void 0 : e2.gcs : e2 == null ? void 0 : e2.pcs;
  }
  const o = e.wkid ? i.coordsys(e.wkid) : i.fromString(e.isGeographic ? E.PE_TYPE_GEOGCS : E.PE_TYPE_PROJCS, e.wkt), s3 = A(o, C(e, 1e-4)), a = A(o, 0, true);
  return G.set(n, { pcs: s3, gcs: a }), t2 ? a : s3;
}
function A(e, t2 = 0, n = false) {
  const o = S.generate(e), i2 = n ? e.horizonGcsGenerate() : e.horizonPcsGenerate();
  if (!(i2 == null ? void 0 : i2.length))
    return null;
  let r2 = false, s3 = i2.find((e2) => 1 === e2.getInclusive() && 1 === e2.getKind());
  if (!s3) {
    if (s3 = i2.find((e2) => 1 === e2.getInclusive() && 0 === e2.getKind()), !s3)
      return null;
    r2 = true;
  }
  const a = n ? 0 : (2 === o.getNorthPoleLocation() ? 1 : 0) | (2 === o.getSouthPoleLocation() ? 2 : 0), c2 = o.isPannableRectangle(), f = s3.getCoord();
  if (r2)
    return { isEnvelope: r2, isPannable: c2, vertices: f, coef: null, bbox: [f[0][0] - t2, f[0][1] - t2, f[1][0] + t2, f[1][1] + t2], poleLocation: a };
  let u = 0;
  const m = [];
  let [x, h] = f[0], [p, g] = f[0];
  for (let l = 0, y = f.length; l < y; l++) {
    u++, u === y && (u = 0);
    const [e2, t3] = f[l], [n2, o2] = f[u];
    if (o2 === t3)
      m.push([e2, n2, t3, o2, 2]);
    else {
      const i3 = (n2 - e2) / (o2 - t3 || 1e-4), r3 = e2 - i3 * t3;
      t3 < o2 ? m.push([i3, r3, t3, o2, 0]) : m.push([i3, r3, o2, t3, 1]);
    }
    x = x < e2 ? x : e2, h = h < t3 ? h : t3, p = p > e2 ? p : e2, g = g > t3 ? g : t3;
  }
  return { isEnvelope: false, isPannable: c2, vertices: f, coef: m, bbox: [x, h, p, g], poleLocation: a };
}
function B(e, n) {
  const o = [], { cols: i2, rows: r2, xres: s3, yres: a, usePixelCenter: l } = e;
  let { xmin: c2, ymax: f } = e;
  if (l && (c2 += s3 / 2, f -= a / 2), t(n)) {
    for (let e2 = 0; e2 < i2; e2++)
      for (let t2 = 0; t2 < r2; t2++)
        o.push([c2 + s3 * e2, f - a * t2]);
    return { points: o };
  }
  const u = new Uint8Array(i2 * r2);
  if (n.isEnvelope) {
    const { bbox: [e2, t2, l2, m2] } = n;
    for (let x2 = 0, h = 0; x2 < i2; x2++) {
      const i3 = c2 + s3 * x2, p = n.isPannable || i3 >= e2 && i3 <= l2;
      for (let e3 = 0; e3 < r2; e3++, h++) {
        const n2 = f - a * e3;
        p && n2 >= t2 && n2 <= m2 && (o.push([i3, n2]), u[h] = 1);
      }
    }
    return { points: o, mask: u };
  }
  const { coef: m } = n, x = [];
  for (let t2 = 0; t2 < r2; t2++) {
    const e2 = f - a * t2, n2 = [], o2 = [];
    for (let t3 = 0; t3 < m.length; t3++) {
      const [i4, r3, s4, a2, l2] = m[t3];
      if (e2 === s4 && s4 === a2)
        n2.push(i4), n2.push(r3), o2.push(2), o2.push(2);
      else if (e2 >= s4 && e2 <= a2) {
        const t4 = i4 * e2 + r3;
        n2.push(t4), o2.push(l2);
      }
    }
    let i3 = n2;
    if (n2.length > 2) {
      let e3 = 2 === o2[0] ? 0 : o2[0], t3 = n2[0];
      i3 = [];
      for (let r3 = 1; r3 < o2.length; r3++)
        2 === o2[r3] && r3 !== o2.length - 1 || (o2[r3] !== e3 && (i3.push(0 === e3 ? Math.min(t3, n2[r3 - 1]) : Math.max(t3, n2[r3 - 1])), e3 = o2[r3], t3 = n2[r3]), r3 === o2.length - 1 && i3.push(0 === o2[r3] ? Math.min(t3, n2[r3]) : Math.max(t3, n2[r3])));
      i3.sort((e4, t4) => e4 - t4);
    } else
      n2[0] > n2[1] && (i3 = [n2[1], n2[0]]);
    x.push(i3);
  }
  for (let t2 = 0, h = 0; t2 < i2; t2++) {
    const e2 = c2 + s3 * t2;
    for (let t3 = 0; t3 < r2; t3++, h++) {
      const n2 = f - a * t3, i3 = x[t3];
      if (2 === i3.length)
        e2 >= i3[0] && e2 <= i3[1] && (o.push([e2, n2]), u[h] = 1);
      else if (i3.length > 2) {
        let t4 = false;
        for (let n3 = 0; n3 < i3.length; n3 += 2)
          if (e2 >= i3[n3] && e2 <= i3[n3 + 1]) {
            t4 = true;
            break;
          }
        t4 && (o.push([e2, n2]), u[h] = 1);
      }
    }
  }
  return { points: o, mask: u };
}
function I(e, t2) {
  const [n, o] = t2;
  for (let i2 = 0; i2 < e.length; i2++) {
    const t3 = e[i2][1];
    (t3 < n || t3 > o) && (e[i2] = [NaN, NaN]);
  }
}
function Y(e) {
  const n = X(e[0].spatialReference);
  if (e.length < 2 || t(n))
    return e[0];
  let { xmin: o, xmax: i2, ymin: r2, ymax: s3 } = e[0];
  for (let t2 = 1; t2 < e.length; t2++) {
    const o2 = e[t2];
    i2 = o2.xmax + n * t2, r2 = Math.min(r2, o2.ymin), s3 = Math.max(s3, o2.ymax);
  }
  return new M({ xmin: o, xmax: i2, ymin: r2, ymax: s3, spatialReference: e[0].spatialReference });
}
function F(e, o, i2 = null, r2 = true) {
  const s3 = e.spatialReference;
  if (s3.equals(o))
    return e;
  const a = D(e), l = X(s3, true), c2 = X(o);
  if (0 === a || t(l) || t(c2)) {
    const a2 = J(e, o, i2, r2);
    if (t(l) && r(c2) && Math.abs(a2.width - c2) < C(o) && en()) {
      const t2 = L(s3);
      if (r(t2) && t2.poleLocation === d.None && e.width < (t2.bbox[2] - t2.bbox[0]) / 2)
        return q(e, o) || a2;
    }
    return a2;
  }
  const u = e.clone().normalize();
  if (1 === u.length && e.xmax < l && e.xmax - l / 2 > C(s3)) {
    const { xmin: t2, xmax: n } = e;
    for (let o2 = 0; o2 <= a; o2++) {
      const i3 = 0 === o2 ? t2 : -l / 2, r3 = o2 === a ? n - l * o2 : l / 2;
      u[o2] = new M({ xmin: i3, xmax: r3, ymin: e.ymin, ymax: e.ymax, spatialReference: s3 });
    }
  }
  return Y(u.map((e2) => J(e2, o, i2, r2)).filter((e2) => !!e2));
}
function q(e, n) {
  const o = X(n);
  if (t(o))
    return null;
  let { xmin: i2, ymin: r2, xmax: s3, ymax: a } = e;
  const l = e.spatialReference, c2 = new v({ spatialReference: l, rings: [[[i2, r2], [s3, r2], [s3, a], [i2, a], [i2, r2]]] }), f = rn(c2, n);
  if (2 !== f.rings.length || !f.rings[0].length || !f.rings[1].length)
    return null;
  const { rings: u } = f, m = C(l), p = new M({ spatialReference: n });
  for (let t2 = 0; t2 < 2; t2++) {
    i2 = s3 = u[t2][0][0], r2 = a = u[t2][0][1];
    for (let e2 = 0; e2 < u[t2].length; e2++)
      i2 = i2 > u[t2][e2][0] ? u[t2][e2][0] : i2, s3 = s3 < u[t2][e2][0] ? u[t2][e2][0] : s3, r2 = r2 > u[t2][e2][1] ? u[t2][e2][1] : r2, a = a < u[t2][e2][1] ? u[t2][e2][1] : a;
    if (0 === t2)
      p.ymin = r2, p.ymax = a, p.xmin = i2, p.xmax = s3;
    else if (p.ymin = Math.min(p.ymin, r2), p.ymax = Math.max(p.ymax, a), Math.abs(s3 - o / 2) < m)
      p.xmin = i2, p.xmax = p.xmax + o;
    else {
      if (!(Math.abs(i2 + o / 2) < m))
        return null;
      p.xmax = s3 + o;
    }
  }
  return p;
}
function J(e, n, o = null, i2 = true, r2 = true) {
  const s3 = e.spatialReference;
  if (s3.equals(n))
    return e;
  w(s3, n, o);
  const a = rn(e, n, o);
  if (r2 && n.isWebMercator && a && (a.ymax = Math.min(20037508342787e-6, a.ymax), a.ymin = Math.max(-20037508342787e-6, a.ymin), a.ymin >= a.ymax))
    return null;
  if (!i2 || !a)
    return a;
  const l = K(s3, true), c2 = K(n, true);
  if (t(l) || t(c2))
    return a;
  const f = C(s3, 1e-3), u = C(s3, 500), m = C(n, 1e-3);
  if (Math.abs(a.xmin - c2[0]) < m && Math.abs(a.xmax - c2[1]) < m) {
    const t2 = Math.abs(e.xmin - l[0]), i3 = Math.abs(l[1] - e.xmax);
    if (t2 < f && i3 > u) {
      a.xmin = c2[0];
      const t3 = [];
      t3.push(new j(e.xmax, e.ymin, s3)), t3.push(new j(e.xmax, (e.ymin + e.ymax) / 2, s3)), t3.push(new j(e.xmax, e.ymax, s3));
      const i4 = t3.map((e2) => _(e2, n, o)).filter((e2) => !isNaN(e2 == null ? void 0 : e2.x)).map((e2) => e2.x);
      a.xmax = Math.max.apply(null, i4);
    }
    if (i3 < f && t2 > u) {
      a.xmax = c2[1];
      const t3 = [];
      t3.push(new j(e.xmin, e.ymin, s3)), t3.push(new j(e.xmin, (e.ymin + e.ymax) / 2, s3)), t3.push(new j(e.xmin, e.ymax, s3));
      const i4 = t3.map((e2) => _(e2, n, o)).filter((e2) => !isNaN(e2 == null ? void 0 : e2.x)).map((e2) => e2.x);
      a.xmin = Math.min.apply(null, i4);
    }
  } else {
    const e2 = C(n, 1e-3);
    Math.abs(a.xmin - c2[0]) < e2 && (a.xmin = c2[0]), Math.abs(a.xmax - c2[1]) < e2 && (a.xmax = c2[1]);
  }
  return a;
}
function X(e, t2 = false) {
  const n = t2 ? 20037508342787e-6 : 20037508342788905e-9;
  return e.isWebMercator ? 2 * n : e.wkid && e.isGeographic ? 360 : 2 * P[e.wkid] || null;
}
function K(e, t2 = false) {
  if (e.isGeographic)
    return [-180, 180];
  const o = X(e, t2);
  return r(o) ? [-o / 2, o / 2] : null;
}
function U(e, t2, n, o) {
  let i2 = (e - t2) / n;
  return i2 - Math.floor(i2) != 0 ? i2 = Math.floor(i2) : o && (i2 -= 1), i2;
}
function D(e, n = false) {
  const o = X(e.spatialReference);
  if (t(o))
    return 0;
  const i2 = n ? 0 : -(o / 2), r2 = C(e.spatialReference), s3 = !n && Math.abs(e.xmax - o / 2) < r2 ? o / 2 : e.xmax, a = !n && Math.abs(e.xmin + o / 2) < r2 ? -o / 2 : e.xmin;
  return U(s3, i2, o, true) - U(a, i2, o, false);
}
function H(e) {
  const o = e.storageInfo.origin.x, i2 = X(e.spatialReference, true);
  if (t(i2))
    return { originX: o, halfWorldWidth: null, pyramidsInfo: null };
  const r2 = i2 / 2, { nativePixelSize: s3, storageInfo: a, extent: l } = e, { maximumPyramidLevel: c2, blockWidth: f, pyramidScalingFactor: u } = a;
  let m = s3.x;
  const x = [], h = r(e.transform) && "gcs-shift" === e.transform.type, p = o + (h ? 0 : r2), g = h ? i2 - o : r2 - o;
  for (let t2 = 0; t2 <= c2; t2++) {
    const e2 = (l.xmax - o) / m / f, t3 = e2 - Math.floor(e2) == 0 ? e2 : Math.ceil(e2), n = g / m / f, i3 = n - Math.floor(n) == 0 ? n : Math.ceil(n), r3 = Math.floor(p / m / f), s4 = Math.round(p / m) % f, a2 = (f - Math.round(g / m) % f) % f;
    x.push({ resolutionX: m, blockWidth: f, datsetColumnCount: t3, worldColumnCountFromOrigin: i3, leftMargin: s4, rightPadding: a2, originColumnOffset: r3 }), m *= u;
  }
  return { originX: o, halfWorldWidth: r2, pyramidsInfo: x, hasGCSSShiftTransform: h };
}
function Q(e) {
  if (!e || e.isGeographic)
    return e;
  const t2 = String(e.wkid || e.wkt);
  let n;
  if (N.has(t2))
    n = N.get(t2);
  else {
    n = (e.wkid ? i.coordsys(e.wkid) : i.fromString(E.PE_TYPE_PROJCS, e.wkt)).getGeogcs().getCode(), N.set(t2, n);
  }
  return new k({ wkid: n });
}
function V(e) {
  const t2 = e.isAdaptive && null == e.spacing;
  let o = e.spacing || [S2, S2], i2 = Z(e), r2 = { cols: i2.size[0] + 1, rows: i2.size[1] + 1 };
  const s3 = i2.outofBoundPointCount > 0 && i2.outofBoundPointCount < i2.offsets.length / 2;
  let a = i2.outofBoundPointCount === i2.offsets.length / 2 || t2 && s3 ? [0, 0] : R(i2.offsets, r2, o, E2);
  const l = (a[0] + a[1]) / 2, c2 = e.projectedExtent.spatialReference, f = e.srcBufferExtent.spatialReference;
  if (t2 && (s3 || l > E2)) {
    M2(c2, f, e.datumTransformation) && (c2.isGeographic || r(L(c2))), o = [b, b], i2 = Z({ ...e, spacing: o }), r2 = { cols: i2.size[0] + 1, rows: i2.size[1] + 1 }, a = R(i2.offsets, r2, o, E2);
  }
  if (i2.error = a, o[0] > 1 && (i2.coefficients = $(i2.offsets, r2, s3)), e.includeGCSGrid && !c2.isGeographic && !c2.isWebMercator)
    if (f.isGeographic)
      i2.gcsGrid = { offsets: i2.offsets, coefficients: i2.coefficients, spacing: o };
    else {
      const t3 = L(c2);
      if (r(t3) && !t3.isEnvelope) {
        const t4 = Q(c2), n = F(e.projectedExtent, t4), { offsets: a2 } = Z({ ...e, srcBufferExtent: n, spacing: o }), l2 = $(a2, r2, s3);
        i2.gcsGrid = { offsets: a2, coefficients: l2, spacing: o };
      }
    }
  return i2;
}
function Z(e) {
  const { projectedExtent: t2, srcBufferExtent: o, pixelSize: i2, datumTransformation: r2, rasterTransform: s3 } = e, a = t2.spatialReference, l = o.spatialReference, c2 = w(a, l), { xmin: f, ymin: u, xmax: m, ymax: x } = t2, h = X(l), g = r(h) && (e.hasWrapAround || "gcs-shift" === (s3 == null ? void 0 : s3.type)), y = e.spacing || [S2, S2], d2 = y[0] * i2.x, M3 = y[1] * i2.y, R2 = 1 === y[0], P2 = Math.ceil((m - f) / d2 - 0.1 / y[0]) + (R2 ? 0 : 1), E3 = Math.ceil((x - u) / M3 - 0.1 / y[1]) + (R2 ? 0 : 1), G2 = j2({ cols: P2, rows: E3, xmin: f, ymax: x, xres: d2, yres: M3, inSR: a, outSR: l, datumTransformation: r2, preferPE: y[0] <= b, usePixelCenter: R2 }), N2 = [];
  let k3, T2 = 0;
  const v3 = R2 ? -1 : NaN, { xmin: _2, xmax: z3, ymax: W2, width: O2, height: A2 } = o, B2 = C(l, 500), I2 = r(h) && _2 > 0 && z3 > h / 2;
  let Y2 = false;
  if (c2) {
    const e2 = L(a);
    Y2 = r(e2) && e2.poleLocation > 0;
  }
  for (let n = 0; n < P2; n++) {
    const e2 = [];
    for (let t3 = 0; t3 < E3; t3++) {
      let o2 = G2[n * E3 + t3];
      if (g && o2[0] > z3 && o2[0] > h / 2 - B2 ? o2[0] -= h : g && 0 === n && o2[0] < 0 && I2 && !s3 && (o2[0] += h), !o2 || isNaN(o2[0]) || isNaN(o2[1]))
        N2.push(v3), N2.push(v3), e2.push(null), T2++;
      else {
        if (s3) {
          const e3 = s3.inverseTransform(new j({ x: o2[0], y: o2[1], spatialReference: l }));
          o2 = [e3.x, e3.y];
        }
        e2.push(o2), n > 0 && g && k3[t3] && o2[0] < k3[t3][0] && (o2[0] += h, Y2 && o2[0] > z3 && o2[0] > h && (o2[0] -= h)), N2.push((o2[0] - _2) / O2), N2.push((W2 - o2[1]) / A2);
      }
    }
    k3 = e2;
  }
  return { offsets: N2, error: null, coefficients: null, outofBoundPointCount: T2, spacing: y, size: R2 ? [P2, E3] : [P2 - 1, E3 - 1] };
}
function $(e, t2, n) {
  const { cols: o, rows: i2 } = t2, r2 = new Float32Array((o - 1) * (i2 - 1) * 2 * 6), s3 = new Float32Array([-0, -1, 1, -1, 1, -0, 1, -0, -0]), a = new Float32Array([-1, 1, 0, 0, -1, 1, 1, 0, 0]);
  for (let l = 0; l < o - 1; l++) {
    for (let t3 = 0; t3 < i2 - 1; t3++) {
      let n2 = l * i2 * 2 + 2 * t3;
      const c2 = e[n2], f = e[n2 + 1], u = e[n2 + 2], m = e[n2 + 3];
      n2 += 2 * i2;
      const x = e[n2], h = e[n2 + 1], p = e[n2 + 2], g = e[n2 + 3];
      let y = 0, d2 = 12 * (t3 * (o - 1) + l);
      for (let e2 = 0; e2 < 3; e2++)
        r2[d2++] = s3[y++] * c2 + s3[y++] * u + s3[y++] * p;
      y = 0;
      for (let e2 = 0; e2 < 3; e2++)
        r2[d2++] = s3[y++] * f + s3[y++] * m + s3[y++] * g;
      y = 0;
      for (let e2 = 0; e2 < 3; e2++)
        r2[d2++] = a[y++] * c2 + a[y++] * x + a[y++] * p;
      y = 0;
      for (let e2 = 0; e2 < 3; e2++)
        r2[d2++] = a[y++] * f + a[y++] * h + a[y++] * g;
    }
    if (n)
      for (let e2 = 0; e2 < r2.length; e2++)
        isNaN(r2[e2]) && (r2[e2] = -1);
  }
  return r2;
}
function ee(e) {
  const t2 = e.clone().normalize();
  return 1 === t2.length ? t2[0] : Y(t2);
}
function te(e, t2, i2) {
  const { storageInfo: r2, pixelSize: s3 } = t2;
  let a, l = false;
  const { pyramidResolutions: c2 } = r2;
  if (r(c2) && c2.length) {
    const n = (e.x + e.y) / 2, r3 = c2[c2.length - 1], f2 = (r3.x + r3.y) / 2, u2 = (s3.x + s3.y) / 2;
    if (n <= u2)
      a = 0;
    else if (n >= f2)
      a = c2.length, l = n / f2 > 8;
    else {
      let e2, t3 = u2;
      for (let o = 1; o <= c2.length; o++) {
        if (e2 = (c2[o - 1].x + c2[o - 1].y) / 2, n <= e2) {
          n === e2 ? a = o : "down" === i2 ? (a = o - 1, l = n / t3 > 8) : a = "up" === i2 || n - t3 > e2 - n || n / t3 > 2 ? o : o - 1;
          break;
        }
        t3 = e2;
      }
    }
    const m2 = 0 === a ? s3 : c2[a - 1];
    if (l) {
      Math.min(m2.x, m2.y) * z(t2.spatialReference) > 19567 && (l = false);
    }
    return { pyramidLevel: a, pyramidResolution: new j({ x: m2.x, y: m2.y, spatialReference: t2.spatialReference }), excessiveReading: l };
  }
  const f = Math.log(e.x / s3.x) / Math.LN2, u = Math.log(e.y / s3.y) / Math.LN2, m = t2.storageInfo.maximumPyramidLevel || 0;
  a = "down" === i2 ? Math.floor(Math.min(f, u)) : "up" === i2 ? Math.ceil(Math.max(f, u)) : Math.round((f + u) / 2), a < 0 ? a = 0 : a > m && (l = a > m + 3, a = m);
  const x = 2 ** a;
  return { pyramidLevel: a, pyramidResolution: new j({ x: x * t2.nativePixelSize.x, y: x * t2.nativePixelSize.y, spatialReference: t2.spatialReference }), excessiveReading: l };
}
function ne(e, t2, n = 512, i2 = true) {
  const { extent: r2, spatialReference: s3, pixelSize: a } = e, l = v2(new j({ x: a.x, y: a.y, spatialReference: s3 }), t2, r2);
  if (null == l)
    return { projectedPixelSize: null, scales: null, srcResolutions: null, isCustomTilingScheme: false };
  const c2 = (l.x + l.y) / 2, f = z(t2), u = c2 * f * 96 * 39.37, m = t2.isGeographic ? 256 / n * 2958287637958547e-7 : 256 / n * 591657527591555e-6;
  let x = "vector-magdir" === e.dataType || "vector-uv" === e.dataType;
  const h = F(r2, t2);
  x || i2 && (t2.isGeographic || t2.isWebMercator) && (x = h.xmin * h.xmax < 0);
  let g, y = u;
  const d2 = 1.001;
  if (x) {
    y = m;
    const e2 = t2.isGeographic ? 1341104507446289e-21 : 0.29858214164761665, n2 = e2 * (96 * f * 39.37), o = t2.isGeographic ? 4326 : 3857;
    g = v2(new j({ x: e2, y: e2, spatialReference: { wkid: o } }), s3, h), g.x *= y / n2, g.y *= y / n2;
  } else {
    g = { x: a.x, y: a.y };
    const t3 = Math.ceil(Math.log(Math.min(e.width, e.height) / 32) / Math.LN2);
    let n2 = 0;
    for (; y < m * (d2 / 2) && n2 < t3; )
      n2++, y *= 2, g.x *= 2, g.y *= 2;
    Math.max(y, m) / Math.min(y, m) <= d2 && (y = m);
  }
  const M3 = [y], w2 = [{ x: g.x, y: g.y }], R2 = 70.5310735, P2 = Math.min(R2, u) / d2;
  for (; y >= P2; )
    y /= 2, g.x /= 2, g.y /= 2, M3.push(y), w2.push({ x: g.x, y: g.y });
  return { projectedPixelSize: l, scales: M3, srcResolutions: w2, isCustomTilingScheme: !x };
}

export {
  M2 as M,
  k2 as k,
  T,
  v2 as v,
  _,
  F,
  X,
  D,
  H,
  V,
  ee,
  te,
  ne
};
//# sourceMappingURL=chunk-B5VZTE6L.js.map
