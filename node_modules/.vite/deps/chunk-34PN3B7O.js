import {
  p
} from "./chunk-T4FVDPUN.js";
import {
  fn,
  rn
} from "./chunk-PZWU5EHT.js";
import {
  a
} from "./chunk-QKRZMDWG.js";
import {
  z
} from "./chunk-RN2KRYDN.js";
import {
  R,
  c,
  u
} from "./chunk-56RHM4A6.js";
import {
  m,
  m2
} from "./chunk-CHNDTVQJ.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  E,
  w,
  y
} from "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/support/ElevationTile.js
var i = class {
  constructor(a2, i2 = null) {
    if (this.tile = a2, this.zmin = 0, this.zmax = 0, r(i2)) {
      const t2 = a2.extent;
      this.samplerData = { pixelData: i2.values, width: i2.width, height: i2.height, safeWidth: 0.99999999 * (i2.width - 1), noDataValue: i2.noDataValue, dx: (i2.width - 1) / (t2[2] - t2[0]), dy: (i2.width - 1) / (t2[3] - t2[1]), x0: t2[0], y1: t2[3] }, this.zmin = i2.minValue, this.zmax = i2.maxValue;
    }
  }
  sample(t2, i2) {
    if (t(this.samplerData))
      return;
    const { safeWidth: h, width: s2, pixelData: l, noDataValue: n, dx: o, dy: r2, y1: m3, x0: d } = this.samplerData, u2 = e(r2 * (m3 - i2), 0, h), x2 = e(o * (t2 - d), 0, h), f = Math.floor(u2), c2 = Math.floor(x2), p2 = f * s2 + c2, D = p2 + s2, w3 = l[p2], y2 = l[D], V = l[p2 + 1], z2 = l[D + 1];
    if (w3 !== n && y2 !== n && V !== n && z2 !== n) {
      const t3 = x2 - c2, a2 = w3 + (V - w3) * t3;
      return a2 + (y2 + (z2 - y2) * t3 - a2) * (u2 - f);
    }
  }
};
function e(t2, a2, i2) {
  return t2 < a2 ? a2 : t2 > i2 ? i2 : t2;
}

// node_modules/@arcgis/core/layers/support/ElevationQuery.js
var v = class {
  async queryAll(e2, i2, o) {
    if (!(e2 = o && o.ignoreInvisibleLayers ? e2.filter((e3) => e3.visible) : e2.slice()).length)
      throw new s("elevation-query:invalid-layer", "Elevation queries require at least one elevation layer to fetch tiles from");
    const s2 = x.fromGeometry(i2);
    let l = false;
    o && o.returnSampleInfo || (l = true);
    const n = { ...R2, ...o, returnSampleInfo: true }, a2 = await this.query(e2[e2.length - 1], s2, n), r2 = await this._queryAllContinue(e2, a2, n);
    return r2.geometry = r2.geometry.export(), l && delete r2.sampleInfo, r2;
  }
  async query(e2, i2, o) {
    if (!e2)
      throw new s("elevation-query:invalid-layer", "Elevation queries require an elevation layer to fetch tiles from");
    if (!i2 || !(i2 instanceof x) && "point" !== i2.type && "multipoint" !== i2.type && "polyline" !== i2.type)
      throw new s("elevation-query:invalid-geometry", "Only point, polyline and multipoint geometries can be used to query elevation");
    const s2 = { ...R2, ...o }, l = new w2(e2, i2.spatialReference, s2), n = s2.signal;
    return await e2.load({ signal: n }), await this._createGeometryDescriptor(l, i2, n), await this._selectTiles(l, n), await this._populateElevationTiles(l, n), this._sampleGeometryWithElevation(l), this._createQueryResult(l, n);
  }
  async createSampler(e2, i2, o) {
    if (!e2)
      throw new s("elevation-query:invalid-layer", "Elevation queries require an elevation layer to fetch tiles from");
    if (!i2 || "extent" !== i2.type)
      throw new s("elevation-query:invalid-extent", "Invalid or undefined extent");
    const s2 = { ...R2, ...o };
    return this._createSampler(e2, i2, s2);
  }
  async createSamplerAll(e2, i2, o) {
    if (!(e2 = o && o.ignoreInvisibleLayers ? e2.filter((e3) => e3.visible) : e2.slice()).length)
      throw new s("elevation-query:invalid-layer", "Elevation queries require at least one elevation layer to fetch tiles from");
    if (!i2 || "extent" !== i2.type)
      throw new s("elevation-query:invalid-extent", "Invalid or undefined extent");
    const s2 = { ...R2, ...o, returnSampleInfo: true }, l = await this._createSampler(e2[e2.length - 1], i2, s2);
    return this._createSamplerAllContinue(e2, i2, l, s2);
  }
  async _createSampler(e2, t2, i2, o) {
    const s2 = i2.signal;
    await e2.load({ signal: s2 });
    const l = t2.spatialReference, n = e2.tileInfo.spatialReference;
    l.equals(n) || (await fn([{ source: l, dest: n }], { signal: s2 }), t2 = rn(t2, n));
    const a2 = new _(e2, t2, i2, o);
    return await this._selectTiles(a2, s2), await this._populateElevationTiles(a2, s2), new p(a2.elevationTiles, a2.layer.tileInfo, a2.options.noDataValue);
  }
  async _createSamplerAllContinue(e2, t2, i2, o) {
    if (e2.pop(), !e2.length)
      return i2;
    const s2 = i2.samplers.map((e3) => c(e3.extent)), l = await this._createSampler(e2[e2.length - 1], t2, o, s2);
    if (0 === l.samplers.length)
      return i2;
    const n = i2.samplers.concat(l.samplers), a2 = new p(n, o.noDataValue);
    return this._createSamplerAllContinue(e2, t2, a2, o);
  }
  async _queryAllContinue(e2, t2, i2) {
    const o = e2.pop(), s2 = t2.geometry.coordinates, l = [], n = [];
    for (let c2 = 0; c2 < s2.length; c2++) {
      const i3 = t2.sampleInfo[c2];
      i3.demResolution >= 0 ? i3.source || (i3.source = o) : e2.length && (l.push(s2[c2]), n.push(c2));
    }
    if (!e2.length || 0 === l.length)
      return t2;
    const a2 = t2.geometry.clone(l), r2 = await this.query(e2[e2.length - 1], a2, i2);
    return n.forEach((e3, i3) => {
      s2[e3].z = r2.geometry.coordinates[i3].z, t2.sampleInfo[e3].demResolution = r2.sampleInfo[i3].demResolution;
    }), this._queryAllContinue(e2, t2, i2);
  }
  async _createQueryResult(e2, t2) {
    const i2 = { geometry: (await e2.geometry.project(e2.outSpatialReference, t2)).export(), noDataValue: e2.options.noDataValue };
    return e2.options.returnSampleInfo && (i2.sampleInfo = this._extractSampleInfo(e2)), e2.geometry.coordinates.forEach((e3) => {
      e3.tile = null, e3.elevationTile = null;
    }), i2;
  }
  async _createGeometryDescriptor(e2, i2, o) {
    let s2;
    const l = e2.layer.tileInfo.spatialReference;
    if (i2 instanceof x ? s2 = await i2.project(l, o) : (await fn([{ source: i2.spatialReference, dest: l }], { signal: o }), s2 = rn(i2, l)), !s2)
      throw new s("elevation-query:spatial-reference-mismatch", `Cannot query elevation in '${i2.spatialReference.wkid}' on an elevation service in '${l.wkid}'`);
    e2.geometry = x.fromGeometry(s2);
  }
  async _selectTiles(e2, i2) {
    const o = e2.options.demResolution;
    if ("geometry" === e2.type && this._preselectOutsideLayerExtent(e2), "number" == typeof o)
      this._selectTilesClosestResolution(e2);
    else if ("finest-contiguous" === o)
      await this._selectTilesFinestContiguous(e2, i2);
    else {
      if ("auto" !== o)
        throw new s("elevation-query:invalid-dem-resolution", `Invalid dem resolution value '${o}', expected a number, "finest-contiguous" or "auto"`);
      await this._selectTilesAuto(e2, i2);
    }
  }
  _preselectOutsideLayerExtent(e2) {
    if (t(e2.layer.fullExtent))
      return;
    const t2 = new i(null);
    t2.sample = () => e2.options.noDataValue, e2.outsideExtentTile = t2;
    const o = e2.layer.fullExtent;
    e2.geometry.coordinates.forEach((e3) => {
      const i2 = e3.x, s2 = e3.y;
      (i2 < o.xmin || i2 > o.xmax || s2 < o.ymin || s2 > o.ymax) && (e3.elevationTile = t2);
    });
  }
  _selectTilesClosestResolution(e2) {
    const t2 = e2.layer.tileInfo, i2 = this._findNearestDemResolutionLODIndex(t2, e2.options.demResolution);
    e2.selectTilesAtLOD(i2);
  }
  _findNearestDemResolutionLODIndex(e2, t2) {
    const i2 = t2 / z(e2.spatialReference);
    let o = e2.lods[0], s2 = 0;
    for (let l = 1; l < e2.lods.length; l++) {
      const t3 = e2.lods[l];
      Math.abs(t3.resolution - i2) < Math.abs(o.resolution - i2) && (o = t3, s2 = l);
    }
    return s2;
  }
  async _selectTilesFinestContiguous(e2, t2) {
    const i2 = E2(e2.layer.tileInfo, e2.options.minDemResolution);
    await this._selectTilesFinestContiguousAt(e2, i2, t2);
  }
  async _selectTilesFinestContiguousAt(e2, i2, o) {
    const n = e2.layer;
    if (e2.selectTilesAtLOD(i2), i2 < 0)
      return;
    const a2 = n.tilemapCache, r2 = e2.getTilesToFetch();
    try {
      if (a2)
        await y(Promise.all(r2.map((e3) => a2.fetchAvailability(e3.level, e3.row, e3.col, { signal: o }))), o);
      else if (await this._populateElevationTiles(e2, o), !e2.allElevationTilesFetched())
        throw e2.clearElevationTiles(), new s("elevation-query:has-unavailable-tiles");
    } catch (c2) {
      w(c2), await this._selectTilesFinestContiguousAt(e2, i2 - 1, o);
    }
  }
  async _populateElevationTiles(e2, t2) {
    const i2 = e2.getTilesToFetch(), l = {}, a2 = e2.options.cache, r2 = e2.options.noDataValue, c2 = i2.map(async (i3) => {
      const s2 = `${e2.layer.uid}:${i3.id}:${r2}`, n = r(a2) ? a2.get(s2) : null, c3 = r(n) ? n : await e2.layer.fetchTile(i3.level, i3.row, i3.col, { noDataValue: r2, signal: t2 });
      r(a2) && a2.put(s2, c3), l[i3.id] = new i(i3, c3);
    });
    await y(E(c2), t2), e2.populateElevationTiles(l);
  }
  async _selectTilesAuto(t2, i2) {
    this._selectTilesAutoFinest(t2), this._reduceTilesForMaximumRequests(t2);
    const o = t2.layer.tilemapCache;
    if (!o)
      return this._selectTilesAutoPrefetchUpsample(t2, i2);
    const n = t2.getTilesToFetch(), a2 = {}, r2 = n.map(async (t3) => {
      const s2 = { id: null, level: 0, row: 0, col: 0, extent: u() }, n2 = await a(o.fetchAvailabilityUpsample(t3.level, t3.row, t3.col, s2, { signal: i2 }));
      false === n2.ok ? w(n2.error) : a2[t3.id] = s2;
    });
    await y(Promise.all(r2), i2), t2.remapTiles(a2);
  }
  _reduceTilesForMaximumRequests(e2) {
    const t2 = e2.layer.tileInfo;
    let i2 = 0;
    const o = {}, s2 = (e3) => {
      e3.id in o ? o[e3.id]++ : (o[e3.id] = 1, i2++);
    }, l = (e3) => {
      const t3 = o[e3.id];
      1 === t3 ? (delete o[e3.id], i2--) : o[e3.id] = t3 - 1;
    };
    e2.forEachTileToFetch(s2, l);
    let n = true;
    for (; n && (n = false, e2.forEachTileToFetch((o2) => {
      i2 <= e2.options.maximumAutoTileRequests || (l(o2), t2.upsampleTile(o2) && (n = true), s2(o2));
    }, l), n); )
      ;
  }
  _selectTilesAutoFinest(e2) {
    const t2 = E2(e2.layer.tileInfo, e2.options.minDemResolution);
    e2.selectTilesAtLOD(t2, e2.options.maximumAutoTileRequests);
  }
  async _selectTilesAutoPrefetchUpsample(e2, t2) {
    const i2 = e2.layer.tileInfo;
    await this._populateElevationTiles(e2, t2);
    let o = false;
    e2.forEachTileToFetch((e3, t3) => {
      i2.upsampleTile(e3) ? o = true : t3();
    }), o && await this._selectTilesAutoPrefetchUpsample(e2, t2);
  }
  _sampleGeometryWithElevation(e2) {
    e2.geometry.coordinates.forEach((t2) => {
      const i2 = t2.elevationTile;
      let s2 = e2.options.noDataValue;
      if (i2) {
        const e3 = i2.sample(t2.x, t2.y);
        r(e3) ? s2 = e3 : t2.elevationTile = null;
      }
      t2.z = s2;
    });
  }
  _extractSampleInfo(e2) {
    const t2 = e2.layer.tileInfo, i2 = z(t2.spatialReference);
    return e2.geometry.coordinates.map((o) => {
      let s2 = -1;
      if (o.elevationTile && o.elevationTile !== e2.outsideExtentTile) {
        s2 = t2.lodAt(o.elevationTile.tile.level).resolution * i2;
      }
      return { demResolution: s2 };
    });
  }
};
var x = class {
  export() {
    return this._exporter(this.coordinates, this.spatialReference);
  }
  clone(e2) {
    const t2 = new x();
    return t2.geometry = this.geometry, t2.spatialReference = this.spatialReference, t2.coordinates = e2 || this.coordinates.map((e3) => this._cloneCoordinate(e3)), t2._exporter = this._exporter, t2;
  }
  async project(e2, t2) {
    if (this.spatialReference.equals(e2))
      return this.clone();
    await fn([{ source: this.spatialReference, dest: e2 }], { signal: t2 });
    const i2 = new m({ spatialReference: this.spatialReference, points: this.coordinates.map((e3) => [e3.x, e3.y]) }), o = rn(i2, e2);
    if (!o)
      return null;
    const s2 = this.coordinates.map((e3, t3) => {
      const i3 = this._cloneCoordinate(e3), s3 = o.points[t3];
      return i3.x = s3[0], i3.y = s3[1], i3;
    }), l = this.clone(s2);
    return l.spatialReference = e2, l;
  }
  _cloneCoordinate(e2) {
    return { x: e2.x, y: e2.y, z: e2.z, m: e2.m, tile: null, elevationTile: null };
  }
  static fromGeometry(e2) {
    const t2 = new x();
    if (t2.geometry = e2, t2.spatialReference = e2.spatialReference, e2 instanceof x)
      t2.coordinates = e2.coordinates.map((e3) => t2._cloneCoordinate(e3)), t2._exporter = (t3, i2) => {
        const o = e2.clone(t3);
        return o.spatialReference = i2, o;
      };
    else
      switch (e2.type) {
        case "point": {
          const i2 = e2, { hasZ: o, hasM: s2 } = i2;
          t2.coordinates = o && s2 ? [{ x: i2.x, y: i2.y, z: i2.z, m: i2.m }] : o ? [{ x: i2.x, y: i2.y, z: i2.z }] : s2 ? [{ x: i2.x, y: i2.y, m: i2.m }] : [{ x: i2.x, y: i2.y }], t2._exporter = (t3, i3) => e2.hasM ? new j(t3[0].x, t3[0].y, t3[0].z, t3[0].m, i3) : new j(t3[0].x, t3[0].y, t3[0].z, i3);
          break;
        }
        case "multipoint": {
          const i2 = e2, { hasZ: o, hasM: s2 } = i2;
          t2.coordinates = o && s2 ? i2.points.map((e3) => ({ x: e3[0], y: e3[1], z: e3[2], m: e3[3] })) : o ? i2.points.map((e3) => ({ x: e3[0], y: e3[1], z: e3[2] })) : s2 ? i2.points.map((e3) => ({ x: e3[0], y: e3[1], m: e3[2] })) : i2.points.map((e3) => ({ x: e3[0], y: e3[1] })), t2._exporter = (t3, i3) => e2.hasM ? new m({ points: t3.map((e3) => [e3.x, e3.y, e3.z, e3.m]), hasZ: true, hasM: true, spatiaReference: i3 }) : new m(t3.map((e3) => [e3.x, e3.y, e3.z]), i3);
          break;
        }
        case "polyline": {
          const i2 = e2, o = [], s2 = [], { hasZ: l, hasM: n } = e2;
          let a2 = 0;
          for (const e3 of i2.paths)
            if (s2.push([a2, a2 + e3.length]), a2 += e3.length, l && n)
              for (const t3 of e3)
                o.push({ x: t3[0], y: t3[1], z: t3[2], m: t3[3] });
            else if (l)
              for (const t3 of e3)
                o.push({ x: t3[0], y: t3[1], z: t3[2] });
            else if (n)
              for (const t3 of e3)
                o.push({ x: t3[0], y: t3[1], m: t3[2] });
            else
              for (const t3 of e3)
                o.push({ x: t3[0], y: t3[1] });
          t2.coordinates = o, t2._exporter = (t3, i3) => {
            const o2 = e2.hasM ? t3.map((e3) => [e3.x, e3.y, e3.z, e3.m]) : t3.map((e3) => [e3.x, e3.y, e3.z]), l2 = s2.map((e3) => o2.slice(e3[0], e3[1]));
            return new m2({ paths: l2, hasM: e2.hasM, hasZ: true, spatialReference: i3 });
          };
          break;
        }
      }
    return t2;
  }
};
var g = class {
  constructor(e2, t2) {
    this.layer = e2, this.options = t2;
  }
};
var w2 = class extends g {
  constructor(e2, t2, i2) {
    super(e2, i2), this.outSpatialReference = t2, this.type = "geometry";
  }
  selectTilesAtLOD(e2) {
    if (e2 < 0)
      this.geometry.coordinates.forEach((e3) => e3.tile = null);
    else {
      const t2 = this.layer.tileInfo, i2 = t2.lods[e2].level;
      this.geometry.coordinates.forEach((e3) => {
        e3.tile = t2.tileAt(i2, e3.x, e3.y);
      });
    }
  }
  allElevationTilesFetched() {
    return !this.geometry.coordinates.some((e2) => !e2.elevationTile);
  }
  clearElevationTiles() {
    for (const e2 of this.geometry.coordinates)
      e2.elevationTile !== this.outsideExtentTile && (e2.elevationTile = null);
  }
  populateElevationTiles(e2) {
    for (const t2 of this.geometry.coordinates)
      !t2.elevationTile && t2.tile && (t2.elevationTile = e2[t2.tile.id]);
  }
  remapTiles(e2) {
    for (const t2 of this.geometry.coordinates)
      t2.tile = e2[t2.tile.id];
  }
  getTilesToFetch() {
    const e2 = {}, t2 = [];
    for (const i2 of this.geometry.coordinates) {
      const o = i2.tile;
      i2.elevationTile || !i2.tile || e2[o.id] || (e2[o.id] = o, t2.push(o));
    }
    return t2;
  }
  forEachTileToFetch(e2) {
    for (const t2 of this.geometry.coordinates)
      t2.tile && !t2.elevationTile && e2(t2.tile, () => t2.tile = null);
  }
};
var _ = class extends g {
  constructor(e2, t2, i2, o) {
    super(e2, i2), this.type = "extent", this.elevationTiles = [], this.candidateTiles = [], this.fetchedCandidates = /* @__PURE__ */ new Set(), this.extent = t2.intersection(e2.fullExtent), this.maskExtents = o;
  }
  selectTilesAtLOD(e2, t2) {
    const i2 = this._maximumLodForRequests(t2), o = Math.min(i2, e2);
    o < 0 ? this.candidateTiles.length = 0 : this._selectCandidateTilesCoveringExtentAt(o);
  }
  _maximumLodForRequests(e2) {
    const t2 = this.layer.tileInfo;
    if (!e2)
      return t2.lods.length - 1;
    const o = this.extent;
    if (t(o))
      return -1;
    for (let i2 = t2.lods.length - 1; i2 >= 0; i2--) {
      const s2 = t2.lods[i2], l = s2.resolution * t2.size[0], n = s2.resolution * t2.size[1];
      if (Math.ceil(o.width / l) * Math.ceil(o.height / n) <= e2)
        return i2;
    }
    return -1;
  }
  allElevationTilesFetched() {
    return this.candidateTiles.length === this.elevationTiles.length;
  }
  clearElevationTiles() {
    this.elevationTiles.length = 0, this.fetchedCandidates.clear();
  }
  populateElevationTiles(e2) {
    for (const t2 of this.candidateTiles) {
      const i2 = e2[t2.id];
      i2 && (this.fetchedCandidates.add(t2), this.elevationTiles.push(i2));
    }
  }
  remapTiles(e2) {
    this.candidateTiles = this._uniqueNonOverlappingTiles(this.candidateTiles.map((t2) => e2[t2.id]));
  }
  getTilesToFetch() {
    return this.candidateTiles;
  }
  forEachTileToFetch(e2, t2) {
    const i2 = this.candidateTiles;
    this.candidateTiles = [], i2.forEach((i3) => {
      if (this.fetchedCandidates.has(i3))
        return void (t2 && t2(i3));
      let o = false;
      e2(i3, () => o = true), o ? t2 && t2(i3) : this.candidateTiles.push(i3);
    }), this.candidateTiles = this._uniqueNonOverlappingTiles(this.candidateTiles, t2);
  }
  _uniqueNonOverlappingTiles(e2, t2) {
    const i2 = {}, o = [];
    for (const l of e2)
      i2[l.id] ? t2 && t2(l) : (i2[l.id] = l, o.push(l));
    const s2 = o.sort((e3, t3) => e3.level - t3.level);
    return s2.filter((e3, i3) => {
      for (let o2 = 0; o2 < i3; o2++)
        if (R(s2[o2].extent, e3.extent))
          return t2 && t2(e3), false;
      return true;
    });
  }
  _selectCandidateTilesCoveringExtentAt(e2) {
    this.candidateTiles.length = 0;
    const t2 = this.extent;
    if (t(t2))
      return;
    const o = this.layer.tileInfo, s2 = o.lods[e2], l = o.tileAt(s2.level, t2.xmin, t2.ymin), n = s2.resolution * o.size[0], a2 = s2.resolution * o.size[1], r2 = Math.ceil((t2.xmax - l.extent[0]) / n), c2 = Math.ceil((t2.ymax - l.extent[1]) / a2);
    for (let i2 = 0; i2 < c2; i2++)
      for (let e3 = 0; e3 < r2; e3++) {
        const t3 = { id: null, level: l.level, row: l.row - i2, col: l.col + e3 };
        o.updateTileInfo(t3), this._tileIsMasked(t3) || this.candidateTiles.push(t3);
      }
  }
  _tileIsMasked(e2) {
    return !!this.maskExtents && this.maskExtents.some((t2) => R(t2, e2.extent));
  }
};
function E2(e2, t2) {
  let i2 = e2.lods.length - 1;
  if (t2 > 0) {
    const o = e2.lods.findIndex((e3) => e3.resolution < t2);
    0 === o ? i2 = 0 : o > 0 && (i2 = o - 1);
  }
  return i2;
}
var R2 = { maximumAutoTileRequests: 20, noDataValue: 0, returnSampleInfo: false, demResolution: "auto", minDemResolution: 0 };

export {
  v,
  x,
  E2 as E
};
//# sourceMappingURL=chunk-34PN3B7O.js.map
