import {
  d as d3,
  s
} from "./chunk-WC3LL63J.js";
import {
  e
} from "./chunk-U7LREOA7.js";
import {
  l as l2
} from "./chunk-Q3ZGS5K7.js";
import {
  d as d2
} from "./chunk-3BCNCVBY.js";
import {
  M as M3,
  P as P3,
  Z as Z2,
  d as d4,
  p as p3
} from "./chunk-RO2QI6Y3.js";
import {
  $,
  Ae,
  C,
  DateTime,
  E,
  F2 as F,
  Fe,
  G,
  H,
  I,
  J,
  L,
  M as M2,
  N,
  O,
  P,
  P2,
  Q,
  Re,
  V,
  X,
  Y,
  Z,
  _,
  ee,
  he,
  i,
  ie,
  j as j2,
  je,
  ne,
  oe,
  re,
  se,
  t,
  t2,
  ue,
  v2,
  ve,
  w,
  ye,
  z
} from "./chunk-LBBA3SFR.js";
import {
  p as p2
} from "./chunk-2KZBVPWA.js";
import {
  l
} from "./chunk-Y7FSCP47.js";
import {
  d
} from "./chunk-4PRVTUEZ.js";
import {
  m,
  m2
} from "./chunk-CHNDTVQJ.js";
import {
  f,
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j,
  p
} from "./chunk-YPZEGNLG.js";
import {
  k2
} from "./chunk-3NMRL5CR.js";
import {
  k
} from "./chunk-U3PSONS6.js";

// node_modules/@arcgis/core/arcade/treeAnalysis.js
var e2 = { all: { min: "2", max: "2" }, none: { min: "2", max: "2" }, any: { min: "2", max: "2" }, reduce: { min: "2", max: "3" }, map: { min: "2", max: "2" }, filter: { min: "2", max: "2" }, fromcodepoint: { min: "1", max: "*" }, fromcharcode: { min: "1", max: "*" }, tocodepoint: { min: "1", max: "2" }, tocharcode: { min: "1", max: "2" }, concatenate: { min: "0", max: "*" }, expects: { min: "1", max: "*" }, getfeatureset: { min: "1", max: "2" }, week: { min: "1", max: "2" }, fromjson: { min: "1", max: "1" }, length3d: { min: "1", max: "2" }, tohex: { min: "1", max: "1" }, hash: { min: "1", max: "1" }, isoweek: { min: "1", max: "1" }, isoweekday: { min: "1", max: "1" }, isomonth: { min: "1", max: "1" }, isoyear: { min: "1", max: "1" }, resize: { min: "2", max: "3" }, slice: { min: "0", max: "*" }, splice: { min: "0", max: "*" }, push: { min: "2", max: "2" }, pop: { min: "1", max: "1" }, includes: { min: "2", max: "2" }, array: { min: "1", max: "2" }, front: { min: "1", max: "1" }, back: { min: "1", max: "1" }, insert: { min: "3", max: "3" }, erase: { min: "2", max: "2" }, split: { min: "2", max: "4" }, guid: { min: "0", max: "1" }, today: { min: "0", max: "0" }, angle: { min: "2", max: "3" }, bearing: { min: "2", max: "3" }, urlencode: { min: "1", max: "1" }, now: { min: "0", max: "0" }, timestamp: { min: "0", max: "0" }, day: { min: "1", max: "1" }, month: { min: "1", max: "1" }, year: { min: "1", max: "1" }, hour: { min: "1", max: "1" }, second: { min: "1", max: "1" }, millisecond: { min: "1", max: "1" }, minute: { min: "1", max: "1" }, weekday: { min: "1", max: "1" }, toutc: { min: "1", max: "1" }, tolocal: { min: "1", max: "1" }, date: { min: "0", max: "7" }, datediff: { min: "2", max: "3" }, dateadd: { min: "2", max: "3" }, trim: { min: "1", max: "1" }, text: { min: "1", max: "2" }, left: { min: "2", max: "2" }, right: { min: "2", max: "2" }, mid: { min: "2", max: "3" }, upper: { min: "1", max: "1" }, proper: { min: "1", max: "2" }, lower: { min: "1", max: "1" }, find: { min: "2", max: "3" }, iif: { min: "3", max: "3" }, decode: { min: "2", max: "*" }, when: { min: "2", max: "*" }, defaultvalue: { min: "2", max: "2" }, isempty: { min: "1", max: "1" }, domaincode: { min: "2", max: "4" }, domainname: { min: "2", max: "4" }, polygon: { min: "1", max: "1" }, point: { min: "1", max: "1" }, polyline: { min: "1", max: "1" }, extent: { min: "1", max: "1" }, multipoint: { min: "1", max: "1" }, ringisclockwise: { min: "1", max: "1" }, geometry: { min: "1", max: "1" }, count: { min: "0", max: "*" }, number: { min: "1", max: "2" }, acos: { min: "1", max: "1" }, asin: { min: "1", max: "1" }, atan: { min: "1", max: "1" }, atan2: { min: "2", max: "2" }, ceil: { min: "1", max: "2" }, floor: { min: "1", max: "2" }, round: { min: "1", max: "2" }, cos: { min: "1", max: "1" }, exp: { min: "1", max: "1" }, log: { min: "1", max: "1" }, min: { min: "0", max: "*" }, constrain: { min: "3", max: "3" }, console: { min: "0", max: "*" }, max: { min: "0", max: "*" }, pow: { min: "2", max: "2" }, random: { min: "0", max: "0" }, sqrt: { min: "1", max: "1" }, sin: { min: "1", max: "1" }, tan: { min: "1", max: "1" }, abs: { min: "1", max: "1" }, isnan: { min: "1", max: "1" }, stdev: { min: "0", max: "*" }, average: { min: "0", max: "*" }, mean: { min: "0", max: "*" }, sum: { min: "0", max: "*" }, variance: { min: "0", max: "*" }, distinct: { min: "0", max: "*" }, first: { min: "1", max: "1" }, top: { min: "2", max: "2" }, boolean: { min: "1", max: "1" }, dictionary: { min: "0", max: "*" }, typeof: { min: "1", max: "1" }, reverse: { min: "1", max: "1" }, replace: { min: "3", max: "4" }, sort: { min: "1", max: "2" }, feature: { min: "1", max: "*" }, haskey: { min: "2", max: "2" }, indexof: { min: "2", max: "2" }, disjoint: { min: "2", max: "2" }, intersects: { min: "2", max: "2" }, touches: { min: "2", max: "2" }, crosses: { min: "2", max: "2" }, within: { min: "2", max: "2" }, contains: { min: "2", max: "2" }, overlaps: { min: "2", max: "2" }, equals: { min: "2", max: "2" }, relate: { min: "3", max: "3" }, intersection: { min: "2", max: "2" }, union: { min: "1", max: "2" }, difference: { min: "2", max: "2" }, symmetricdifference: { min: "2", max: "2" }, clip: { min: "2", max: "2" }, cut: { min: "2", max: "2" }, area: { min: "1", max: "2" }, areageodetic: { min: "1", max: "2" }, length: { min: "1", max: "2" }, lengthgeodetic: { min: "1", max: "2" }, distancegeodetic: { min: "2", max: "3" }, distance: { min: "2", max: "3" }, densify: { min: "2", max: "3" }, densifygeodetic: { min: "2", max: "3" }, generalize: { min: "2", max: "4" }, buffer: { min: "2", max: "3" }, buffergeodetic: { min: "2", max: "3" }, offset: { min: "2", max: "6" }, rotate: { min: "2", max: "3" }, issimple: { min: "1", max: "1" }, simplify: { min: "1", max: "1" }, centroid: { min: "1", max: "1" }, isselfintersecting: { min: "1", max: "1" }, multiparttosinglepart: { min: "1", max: "1" }, setgeometry: { min: "2", max: "2" }, portal: { min: "1", max: "1" }, getuser: { min: "1", max: "2" }, subtypes: { min: "1", max: "1" }, subtypecode: { min: "1", max: "1" }, subtypename: { min: "1", max: "1" }, domain: { min: "2", max: "3" }, convertdirection: { min: "3", max: "3" }, schema: { min: "1", max: "1" } };
for (const k4 in e2)
  e2[k4].fmin = e2[k4].min, e2[k4].fmax = e2[k4].max;
var t3 = ["featureset", "getuser", "featuresetbyid", "featuresetbyname", "featuresetbyassociation", "featuresetbyrelationshipname", "featuresetbyurl", "getfeatureset", "attachments", "featuresetbyportalitem"];
var n = ["disjoint", "intersects", "touches", "crosses", "within", "contains", "overlaps", "equals", "relate", "intersection", "union", "difference", "symmetricdifference", "clip", "cut", "area", "areageodetic", "length", "length3d", "lengthgeodetic", "distance", "distancegeodetic", "densify", "densifygeodetic", "generalize", "buffer", "buffergeodetic", "offset", "rotate", "issimple", "simplify", "multiparttosinglepart"];
function a(e4) {
  return "string" == typeof e4 || e4 instanceof String;
}
function r(t5, n3) {
  const a2 = e2[t5.name.toLowerCase()];
  void 0 === a2 ? e2[t5.name.toLowerCase()] = "sync" === n3 ? { min: t5.min, max: t5.max } : { fmin: t5.min, fmax: t5.max } : "sync" === n3 ? (a2.min = t5.min, a2.max = t5.max) : (a2.fmin = t5.min, a2.fmax = t5.max);
}
function i2(e4, t5) {
  return "0" !== e4.min && t5.length < Number(e4.min) || "*" !== e4.max && t5.length > Number(e4.max) ? -2 : 1;
}
function s2(e4, t5, n3) {
  if (null !== n3.localScope && void 0 !== n3.localScope[e4.toLowerCase()]) {
    const a2 = n3.localScope[e4.toLowerCase()];
    if ("FormulaFunction" === a2.type)
      return void 0 === a2.signature && (a2.signature = { min: "0", max: "*" }), i2(a2.signature, t5);
    if ("any" === a2.type)
      return void 0 === a2.signature && (a2.signature = { min: "0", max: "*" }), i2(a2.signature, t5);
  }
  if (void 0 !== n3.globalScope[e4.toLowerCase()]) {
    const a2 = n3.globalScope[e4.toLowerCase()];
    if ("FormulaFunction" === a2.type)
      return void 0 === a2.signature && (a2.signature = { min: "0", max: "*" }), i2(a2.signature, t5);
    if ("any" === a2.type)
      return void 0 === a2.signature && (a2.signature = { min: "0", max: "*" }), i2(a2.signature, t5);
  }
  return -1;
}
function o(e4, t5) {
  if (e4)
    for (const n3 of e4)
      l3(n3, t5);
}
function l3(e4, t5) {
  if (e4 && false !== t5(e4))
    switch (e4.type) {
      case "ArrayExpression":
        o(e4.elements, t5);
        break;
      case "AssignmentExpression":
      case "BinaryExpression":
      case "LogicalExpression":
        l3(e4.left, t5), l3(e4.right, t5);
        break;
      case "BlockStatement":
      case "Program":
        o(e4.body, t5);
        break;
      case "BreakStatement":
      case "ContinueStatement":
      case "EmptyStatement":
      case "Identifier":
      case "Literal":
        break;
      case "CallExpression":
        l3(e4.callee, t5), o(e4.arguments, t5);
        break;
      case "ExpressionStatement":
        l3(e4.expression, t5);
        break;
      case "ForInStatement":
        l3(e4.left, t5), l3(e4.right, t5), l3(e4.body, t5);
        break;
      case "ForStatement":
        l3(e4.init, t5), l3(e4.test, t5), l3(e4.update, t5), l3(e4.body, t5);
        break;
      case "FunctionDeclaration":
        l3(e4.id, t5), o(e4.params, t5), l3(e4.body, t5);
        break;
      case "IfStatement":
        l3(e4.test, t5), l3(e4.consequent, t5), l3(e4.alternate, t5);
        break;
      case "MemberExpression":
        l3(e4.object, t5), l3(e4.property, t5);
        break;
      case "ObjectExpression":
        o(e4.properties, t5);
        break;
      case "Property":
        l3(e4.key, t5), l3(e4.value, t5);
        break;
      case "ReturnStatement":
      case "UnaryExpression":
      case "UpdateExpression":
        l3(e4.argument, t5);
        break;
      case "VariableDeclaration":
        o(e4.declarations, t5);
        break;
      case "VariableDeclarator":
        l3(e4.id, t5), l3(e4.init, t5);
        break;
      case "TemplateLiteral":
        o(e4.expressions, t5), o(e4.quasis, t5);
    }
}
function m3(e4, t5 = true) {
  let n3 = b(e4, "SYNTAX", "UNREOGNISED");
  try {
    switch (e4.type) {
      case "VariableDeclarator":
        return "Identifier" !== e4.id.type ? b(e4, "SYNTAX", "VARIABLEMUSTHAVEIDENTIFIER") : null !== e4.init ? m3(e4.init, false) : "";
      case "VariableDeclaration":
        for (let a2 = 0; a2 < e4.declarations.length; a2++)
          if (n3 = m3(e4.declarations[a2], t5), "" !== n3)
            return n3;
        return "";
      case "ForInStatement":
        if (n3 = m3(e4.left, t5), "" !== n3)
          return n3;
        if ("VariableDeclaration" === e4.left.type) {
          if (e4.left.declarations.length > 1)
            return b(e4, "SYNTAX", "ONLY1VAR");
          if (null !== e4.left.declarations[0].init)
            return b(e4, "SYNTAX", "CANNOTDECLAREVAL");
        } else if ("Identifier" !== e4.left.type)
          return b(e4, "SYNTAX", "LEFTNOTVAR");
        return n3 = m3(e4.right, t5), "" !== n3 ? n3 : (n3 = m3(e4.body, t5), "" !== n3 ? n3 : "");
      case "ForStatement":
        return null !== e4.test && (n3 = m3(e4.test, t5), "" !== n3) || (null !== e4.init && (n3 = m3(e4.init, t5), "" !== n3) || null !== e4.update && (n3 = m3(e4.update, t5), "" !== n3) || null !== e4.body && (n3 = m3(e4.body, t5), "" !== n3)) ? n3 : "";
      case "ContinueStatement":
      case "EmptyStatement":
      case "BreakStatement":
      case "Literal":
      case "TemplateElement":
        return "";
      case "IfStatement":
        return n3 = m3(e4.test, t5), "" !== n3 || null !== e4.consequent && (n3 = m3(e4.consequent, false), "" !== n3) || null !== e4.alternate && (n3 = m3(e4.alternate, false), "" !== n3) ? n3 : "";
      case "BlockStatement": {
        const a2 = [];
        for (let t6 = 0; t6 < e4.body.length; t6++)
          "EmptyStatement" !== e4.body[t6].type && a2.push(e4.body[t6]);
        e4.body = a2;
        for (let r3 = 0; r3 < e4.body.length; r3++)
          if (n3 = m3(e4.body[r3], t5), "" !== n3)
            return n3;
        return "";
      }
      case "FunctionDeclaration":
        return false === t5 ? b(e4, "SYNTAX", "GLOBALFUNCTIONSONLY") : "Identifier" !== e4.id.type ? b(e4, "SYNTAX", "FUNCTIONMUSTHAVEIDENTIFIER") : m3(e4.body, false);
      case "ReturnStatement":
        return null !== e4.argument ? m3(e4.argument, t5) : "";
      case "UpdateExpression":
        return "Identifier" !== e4.argument.type && "MemberExpression" !== e4.argument.type ? b(e4, "SYNTAX", "ASSIGNMENTTOVARSONLY") : m3(e4.argument, t5);
      case "AssignmentExpression":
        if ("Identifier" !== e4.left.type && "MemberExpression" !== e4.left.type)
          return b(e4, "SYNTAX", "ASSIGNMENTTOVARSONLY");
        if (n3 = m3(e4.left, t5), "" !== n3)
          return n3;
        switch (e4.operator) {
          case "=":
          case "/=":
          case "*=":
          case "%=":
          case "+=":
          case "-=":
            break;
          default:
            return b(e4, "SYNTAX", "OPERATORNOTRECOGNISED");
        }
        return m3(e4.right, false);
      case "ExpressionStatement":
        return "AssignmentExpression" === e4.expression.type || e4.expression.type, m3(e4.expression, false);
      case "Identifier":
        n3 = "";
        break;
      case "MemberExpression":
        return n3 = m3(e4.object, t5), "" !== n3 ? n3 : true === e4.computed ? m3(e4.property, t5) : "";
      case "CallExpression":
        if ("Identifier" !== e4.callee.type)
          return b(e4, "SYNTAX", "ONLYNODESSUPPORTED");
        n3 = "";
        for (let a2 = 0; a2 < e4.arguments.length; a2++)
          if (n3 = m3(e4.arguments[a2], t5), "" !== n3)
            return n3;
        return "";
      case "UnaryExpression":
        n3 = m3(e4.argument, t5);
        break;
      case "BinaryExpression":
        if (n3 = m3(e4.left, t5), "" !== n3)
          return n3;
        if (n3 = m3(e4.right, t5), "" !== n3)
          return n3;
        switch (e4.operator) {
          case "|":
          case "&":
          case ">>":
          case "<<":
          case ">>>":
          case "^":
          case "==":
          case "!=":
          case "<":
          case "<=":
          case ">":
          case ">=":
          case "+":
          case "-":
          case "*":
          case "/":
          case "%":
            break;
          default:
            return b(e4, "SYNTAX", "OPERATORNOTRECOGNISED");
        }
        return "";
      case "LogicalExpression":
        if (n3 = m3(e4.left, t5), "" !== n3)
          return n3;
        if (n3 = m3(e4.right), "" !== n3)
          return n3;
        switch (e4.operator) {
          case "&&":
          case "||":
            break;
          default:
            return b(e4, "SYNTAX", "OPERATORNOTRECOGNISED");
        }
        return "";
      case "ArrayExpression":
        n3 = "";
        for (let a2 = 0; a2 < e4.elements.length; a2++)
          if (n3 = m3(e4.elements[a2], t5), "" !== n3)
            return n3;
        return n3;
      case "TemplateLiteral":
        n3 = "";
        for (let a2 = 0; a2 < e4.quasis.length; a2++)
          if (n3 = m3(e4.quasis[a2], t5), "" !== n3)
            return n3;
        for (let a2 = 0; a2 < e4.expressions.length; a2++)
          if (n3 = m3(e4.expressions[a2], t5), "" !== n3)
            return n3;
        return n3;
      case "ObjectExpression":
        n3 = "";
        for (let a2 = 0; a2 < e4.properties.length; a2++) {
          if (n3 = "", null !== e4.properties[a2].key && ("Literal" !== e4.properties[a2].key.type && "Identifier" !== e4.properties[a2].key.type && (n3 = b(e4, "SYNTAX", "OBJECTPROPERTYMUSTBESTRING")), "Literal" === e4.properties[a2].key.type)) {
            const t6 = e4.properties[a2].key, r3 = "value" in t6 ? t6.value : null;
            "string" == typeof r3 || r3 instanceof String || (n3 = b(e4, "SYNTAX", "OBJECTPROPERTYMUSTBESTRING"));
          }
          if ("" === n3 && (n3 = m3(e4.properties[a2], t5)), "" !== n3)
            return n3;
        }
        return n3;
      case "Property":
        return "Literal" !== e4.key.type && "Identifier" !== e4.key.type ? b(e4, "SYNTAX", "ONLYLITERAL") : ("Identifier" !== e4.key.type && (n3 = m3(e4.key, t5), "" !== n3) || (n3 = m3(e4.value, t5)), n3);
      default:
        return n3;
    }
    return n3;
  } catch (a2) {
    throw a2;
  }
}
function c(e4, t5) {
  let n3 = b(e4, "SYNTAX", "UNREOGNISED"), a2 = null, r3 = "";
  try {
    switch (e4.type) {
      case "VariableDeclarator": {
        const n4 = null === e4.init ? "" : c(e4.init, t5);
        return "" !== n4 ? n4 : ("Identifier" === e4.id.type && (null === t5.localScope ? t5.globalScope[e4.id.name.toLowerCase()] = { type: "any" } : t5.localScope[e4.id.name.toLowerCase()] = { type: "any" }), "");
      }
      case "FunctionDeclaration":
        return a2 = y(e4.id.name.toLowerCase(), e4), r3 = x(e4, t5), "" !== r3 ? r3 : null !== t5.localScope ? b(e4, "SYNTAX", "GLOBALFUNCTIONSONLY") : (a2.isnative = false, t5.globalScope[e4.id.name.toLowerCase()] = { type: "FormulaFunction", signature: [a2] }, "");
      case "VariableDeclaration":
        n3 = "";
        for (let a3 = 0; a3 < e4.declarations.length; a3++)
          if (n3 = c(e4.declarations[a3], t5), "" !== n3)
            return n3;
        return n3;
      case "IfStatement":
        return n3 = c(e4.test, t5), "" !== n3 ? n3 : "AssignmentExpression" === e4.test.type || "UpdateExpression" === e4.test.type ? b(e4.test, "SYNTAX", "CANNOT_USE_ASSIGNMENT_IN_CONDITION") : null !== e4.consequent && (n3 = c(e4.consequent, t5), "" !== n3) || null !== e4.alternate && (n3 = c(e4.alternate, t5), "" !== n3) ? n3 : "";
      case "EmptyStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "Literal":
      case "TemplateElement":
        return "";
      case "BlockStatement":
        for (let a3 = 0; a3 < e4.body.length; a3++)
          if (n3 = c(e4.body[a3], t5), "" !== n3)
            return n3;
        return "";
      case "ReturnStatement":
        return null !== e4.argument ? c(e4.argument, t5) : "";
      case "ForInStatement":
        if ("VariableDeclaration" === e4.left.type) {
          if (e4.left.declarations.length > 1)
            return b(e4, "SYNTAX", "ONLY1VAR");
          if (null !== e4.left.declarations[0].init)
            return b(e4, "SYNTAX", "CANNOTDECLAREVAL");
        } else if ("Identifier" !== e4.left.type)
          return b(e4, "SYNTAX", "LEFTNOTVAR");
        return n3 = c(e4.left, t5), "" !== n3 ? n3 : (n3 = c(e4.right, t5), "" !== n3 ? n3 : (n3 = c(e4.body, t5), "" !== n3 ? n3 : ""));
      case "ForStatement":
        return null !== e4.init && (n3 = c(e4.init, t5), "" !== n3) || (null !== e4.test && (n3 = c(e4.test, t5), "" !== n3) || null !== e4.body && (n3 = c(e4.body, t5), "" !== n3) || null !== e4.update && (n3 = c(e4.update, t5), "" !== n3)) ? n3 : "";
      case "UpdateExpression": {
        if ("Identifier" !== e4.argument.type && "MemberExpression" !== e4.argument.type)
          return b(e4, "SYNTAX", "ASSIGNMENTTOVARSONLY");
        let n4 = false;
        return "MemberExpression" === e4.argument.type ? c(e4.argument, t5) : (null !== t5.localScope && void 0 !== t5.localScope[e4.argument.name.toLowerCase()] && (n4 = true), void 0 !== t5.globalScope[e4.argument.name.toLowerCase()] && (n4 = true), false === n4 ? "Identifier " + e4.argument.name + " has not been declared." : "");
      }
      case "AssignmentExpression": {
        if ("Identifier" !== e4.left.type && "MemberExpression" !== e4.left.type)
          return b(e4, "SYNTAX", "ASSIGNMENTTOVARSONLY");
        let n4 = c(e4.right, t5);
        if ("" !== n4)
          return n4;
        let a3 = false;
        return "MemberExpression" === e4.left.type ? (n4 = c(e4.left, t5), "" !== n4 ? n4 : "") : (null !== t5.localScope && void 0 !== t5.localScope[e4.left.name.toLowerCase()] && (a3 = true), void 0 !== t5.globalScope[e4.left.name.toLowerCase()] && (a3 = true), false === a3 ? "Identifier " + e4.left.name + " has not been declared." : "");
      }
      case "ExpressionStatement":
        return "AssignmentExpression" === e4.expression.type || e4.expression.type, c(e4.expression, t5);
      case "Identifier": {
        const a3 = e4.name.toLowerCase();
        if (null !== t5.localScope && void 0 !== t5.localScope[a3])
          return "";
        n3 = void 0 !== t5.globalScope[a3] ? "" : b(e4, "SYNTAX", "VARIABLENOTFOUND");
        break;
      }
      case "MemberExpression":
        return n3 = c(e4.object, t5), "" !== n3 ? n3 : true === e4.computed ? c(e4.property, t5) : "";
      case "CallExpression": {
        if ("Identifier" !== e4.callee.type)
          return b(e4, "SYNTAX", "ONLYNODESSUPPORTED");
        n3 = "";
        for (let r4 = 0; r4 < e4.arguments.length; r4++)
          if (n3 = c(e4.arguments[r4], t5), "" !== n3)
            return n3;
        const a3 = s2(e4.callee.name, e4.arguments, t5);
        -1 === a3 && (n3 = b(e4, "SYNTAX", "NOTFOUND")), -2 === a3 && (n3 = b(e4, "SYNTAX", "WRONGSIGNATURE"));
        break;
      }
      case "UnaryExpression":
        n3 = c(e4.argument, t5);
        break;
      case "BinaryExpression":
        return n3 = c(e4.left, t5), "" !== n3 ? n3 : (n3 = c(e4.right, t5), "" !== n3 ? n3 : "");
      case "LogicalExpression":
        return n3 = c(e4.left, t5), "" !== n3 ? n3 : "AssignmentExpression" === e4.left.type || "UpdateExpression" === e4.left.type ? b(e4.left, "SYNTAX", "CANNOT_USE_ASSIGNMENT_IN_CONDITION") : (n3 = c(e4.right, t5), "" !== n3 ? n3 : "AssignmentExpression" === e4.right.type || "UpdateExpression" === e4.right.type ? b(e4.right, "SYNTAX", "CANNOT_USE_ASSIGNMENT_IN_CONDITION") : "");
      case "ArrayExpression":
        n3 = "";
        for (let a3 = 0; a3 < e4.elements.length; a3++)
          if (n3 = c(e4.elements[a3], t5), "" !== n3)
            return n3;
        return n3;
      case "TemplateLiteral":
        n3 = "";
        for (let a3 = 0; a3 < e4.quasis.length; a3++)
          if (n3 = c(e4.quasis[a3], t5), "" !== n3)
            return n3;
        for (let a3 = 0; a3 < e4.expressions.length; a3++)
          if (n3 = c(e4.expressions[a3], t5), "" !== n3)
            return n3;
        return n3;
      case "ObjectExpression":
        n3 = "";
        for (let a3 = 0; a3 < e4.properties.length; a3++) {
          if (n3 = "", null !== e4.properties[a3].key && ("Literal" !== e4.properties[a3].key.type && "Identifier" !== e4.properties[a3].key.type && (n3 = b(e4, "SYNTAX", "OBJECTPROPERTYMUSTBESTRING")), "Literal" === e4.properties[a3].key.type)) {
            const t6 = e4.properties[a3].key, r4 = "value" in t6 ? t6.value : null;
            "string" == typeof r4 || r4 instanceof String || (n3 = b(e4, "SYNTAX", "OBJECTPROPERTYMUSTBESTRING"));
          }
          if ("" === n3 && (n3 = c(e4.properties[a3], t5)), "" !== n3)
            return n3;
        }
        return n3;
      case "Property":
        return "Literal" !== e4.key.type && "Identifier" !== e4.key.type ? b(e4, "SYNTAX", "ONLYLITERAL") : ("Identifier" !== e4.key.type && (n3 = c(e4.key, t5), "" !== n3) || (n3 = c(e4.value, t5)), n3);
      default:
        return C2(e4), n3;
    }
    return n3;
  } catch (i5) {
    throw i5;
  }
}
function p4(e4, t5) {
  let n3 = false;
  const a2 = t5.toLowerCase();
  return l3(e4, (e5) => !n3 && ("Identifier" === e5.type && e5.name && e5.name.toLowerCase() === a2 && (n3 = true), true)), n3;
}
function u(e4, t5) {
  let n3 = false;
  const a2 = t5.toLowerCase();
  return l3(e4, (e5) => !n3 && ("CallExpression" !== e5.type || "Identifier" !== e5.callee.type || !e5.callee.name || e5.callee.name.toLowerCase() !== a2 || (n3 = true, false))), n3;
}
function f2(e4) {
  const t5 = [];
  return l3(e4, (e5) => "MemberExpression" !== e5.type || "Identifier" !== e5.object.type || (false === e5.computed && e5.object && e5.object.name && e5.property && "Identifier" === e5.property.type && e5.property.name ? t5.push(e5.object.name.toLowerCase() + "." + e5.property.name.toLowerCase()) : e5.object && e5.object.name && e5.property && "Literal" === e5.property.type && "string" == typeof e5.property.value && t5.push(e5.object.name.toLowerCase() + "." + e5.property.value.toString().toLowerCase()), false)), t5;
}
function d5(e4) {
  const t5 = [];
  return l3(e4, (e5) => {
    if ("CallExpression" === e5.type) {
      if ("Identifier" === e5.callee.type && "expects" === e5.callee.name.toLowerCase()) {
        let n3 = "";
        for (let r3 = 0; r3 < (e5.arguments || []).length; r3++)
          0 === r3 ? "Identifier" === e5.arguments[r3].type && (n3 = e5.arguments[r3].name.toLowerCase()) : n3 && "Literal" === e5.arguments[r3].type && a(e5.arguments[r3].value) && t5.push(n3 + "." + e5.arguments[r3].value.toLowerCase());
        return false;
      }
      if ("Identifier" === e5.callee.type && ["domainname", "domaincode", "domain", "haskey"].includes(e5.callee.name.toLowerCase()) && e5.arguments.length >= 2) {
        let n3 = "";
        return "Identifier" === e5.arguments[0].type && (n3 = e5.arguments[0].name.toLowerCase()), n3 && "Literal" === e5.arguments[1].type && a(e5.arguments[1].value) && t5.push(n3 + "." + e5.arguments[1].value.toLowerCase()), false;
      }
    }
    return "MemberExpression" !== e5.type || "Identifier" !== e5.object.type || (false === e5.computed && e5.object && e5.object.name && e5.property && "Identifier" === e5.property.type && e5.property.name ? t5.push(e5.object.name.toLowerCase() + "." + e5.property.name.toLowerCase()) : e5.object && e5.object.name && e5.property && "Literal" === e5.property.type && "string" == typeof e5.property.value && t5.push(e5.object.name.toLowerCase() + "." + e5.property.value.toString().toLowerCase()), false);
  }), t5;
}
function y(e4, t5) {
  const n3 = [];
  if (void 0 !== t5.params && null !== t5.params)
    for (let a2 = 0; a2 < t5.params.length; a2++)
      n3.push("any");
  return { name: e4, return: "any", params: n3 };
}
function x(e4, t5) {
  const n3 = { globalScope: t5.globalScope, localScope: {} };
  for (let a2 = 0; a2 < e4.params.length; a2++) {
    const t6 = e4.params[a2].name;
    n3.localScope[t6.toLowerCase()] = { type: "any" };
  }
  return c(e4.body, n3);
}
function N2(e4, t5, n3, a2) {
  const r3 = {};
  null == e4 && (e4 = {}), null == n3 && (n3 = {}), r3.infinity = { type: "any" }, r3.textformatting = { type: "any" }, r3.pi = { type: "any" };
  for (const i5 in t5)
    "sync" === a2 && void 0 !== t5[i5].min ? r3[i5] = { type: "FormulaFunction", signature: { min: t5[i5].min, max: t5[i5].max } } : "sync" !== a2 && void 0 !== t5[i5].fmin && (r3[i5] = { type: "FormulaFunction", signature: { min: t5[i5].fmin, max: t5[i5].fmax } });
  for (let i5 = 0; i5 < n3.length; i5++) {
    const e5 = n3[i5];
    r3[e5.name] = { type: "FormulaFunction", signature: e5 };
  }
  for (const i5 in e4)
    r3[i5] = e4[i5], r3[i5].type = "any";
  return r3;
}
function S(t5, n3, a2 = "async", r3 = e2) {
  const i5 = { globalScope: N2(n3.vars, r3, n3.customFunctions, a2), localScope: null };
  return c(t5.body[0].body, i5);
}
function E2(e4) {
  return "BlockStatement" !== e4.body[0].body.type ? "Invalid formula content." : m3(e4.body[0].body);
}
function b(e4, t5, n3) {
  let a2 = "";
  switch (t5) {
    case "SYNTAX":
    default:
      a2 = "Syntax Error: ";
      break;
    case "RUNTIME":
      a2 = "Runtime Error: ";
  }
  try {
    switch (e4.type) {
      case "IfStatement":
        switch (n3) {
          case "CANNOT_USE_ASSIGNMENT_IN_CONDITION":
            a2 += " Assignments not be made in logical tests";
            break;
          case "CANNOT_USE_NONBOOLEAN_IN_CONDITION":
            a2 += " Non Boolean used as Condition";
        }
        break;
      case "UpdateExpression":
      case "AssignmentExpression":
        switch (n3) {
          case "CANNOT_USE_ASSIGNMENT_IN_CONDITION":
            a2 += " Assignments not be made in logical tests";
            break;
          case "ASSIGNMENTTOVARSONLY":
            a2 += " Assignments can only be made to identifiers";
        }
        break;
      case "ExpressionStatement":
        a2 += " Assignments can only be made to identifiers";
        break;
      case "FunctionDeclaration":
        switch (n3) {
          case "GLOBALFUNCTIONSONLY":
            a2 += " Functions cannot be declared as variables";
            break;
          case "FUNCTIONMUSTHAVEIDENTIFIER":
            a2 += " Function Definition must have an identifier";
        }
        break;
      case "VariableDeclaration":
        a2 += " Only 1 variable can be declared at a time";
        break;
      case "VariableDeclarator":
        switch (n3) {
          case "FUNCTIONVARIABLEDECLARATOR":
            a2 += " Functions cannot be declared as variables";
            break;
          case "VARIABLEMUSTHAVEIDENTIFIER":
            a2 += " Variable Definition must have an identifier";
        }
        break;
      case "Identifier":
        a2 += " Identifier Not Found. ", a2 += e4.name;
        break;
      case "ObjectExpression":
        if ("OBJECTPROPERTYMUSTBESTRING" === n3)
          a2 += " Property name must be a string";
        break;
      case "ForStatement":
        if ("CANNOT_USE_NONBOOLEAN_IN_CONDITION" === n3)
          a2 += " Non Boolean used as Condition";
        break;
      case "ForInStatement":
        switch (n3) {
          case "ONLY1VAR":
            a2 += " Can only declare 1 var for use with IN";
            break;
          case "CANNOTDECLAREVAL":
            a2 += " Can only declare value for use with IN";
            break;
          case "LEFTNOVAR":
            a2 += "Must provide a variable to iterate with.";
            break;
          case "VARIABLENOTDECLARED":
            a2 += "Variable must be declared before it is used..";
            break;
          case "CANNOTITERATETHISTYPE":
            a2 += "This type cannot be used in an IN loop";
        }
        break;
      case "MemberExpression":
        switch (n3) {
          case "PROPERTYNOTFOUND":
            a2 += "Cannot find member property. ", a2 += false === e4.computed && "Identifier" === e4.property.type ? e4.property.name : "";
            break;
          case "OUTOFBOUNDS":
            a2 += "Out of Bounds. ", a2 += false === e4.computed && "Identifier" === e4.property.type ? e4.property.name : "";
            break;
          case "NOTFOUND":
            a2 += "Cannot call member method on null. ", a2 += false === e4.computed && "Identifier" === e4.property.type ? e4.property.name : "";
            break;
          case "INVALIDTYPE":
            a2 += "Cannot call member property on object of this type. ", a2 += false === e4.computed && "Identifier" === e4.property.type ? e4.property.name : "";
        }
        break;
      case "Property":
        if ("ONLYLITERAL" === n3)
          a2 += "Property names must be literals or identifiers";
        break;
      case "Literal":
        break;
      case "CallExpression":
        switch (n3) {
          case "WRONGSIGNATURE":
            a2 += "Function signature does not match: ", a2 += "Identifier" === e4.callee.type ? e4.callee.name : "";
            break;
          case "ONLYNODESUPPORTED":
            a2 += "Functions must be declared.", a2 += "Identifier" === e4.callee.type ? e4.callee.name : "";
            break;
          case "NOTAFUNCTION":
            a2 += "Not a Function: ", a2 += "Identifier" === e4.callee.type ? e4.callee.name : "";
            break;
          case "NOTFOUND":
            a2 += "Function Not Found: " + ("Identifier" === e4.callee.type ? e4.callee.name : "");
        }
        break;
      case "UnaryExpression":
        switch (n3) {
          case "NOTSUPPORTEDUNARYOPERATOR":
            a2 += "Operator " + e4.operator + " not allowed in this context. Only ! can be used with boolean, and - with a number";
            break;
          case "NOTSUPPORTEDTYPE":
            a2 += "Unary operator " + e4.operator + " cannot be used with this argument.";
        }
      case "BinaryExpression":
        if ("OPERATORNOTRECOGNISED" === n3)
          a2 += "Binary Operator not recognised " + e4.operator;
        break;
      case "LogicalExpression":
        switch (n3) {
          case "ONLYBOOLEAN":
            a2 += "Operator " + e4.operator + " cannot be used. Only || or && are allowed values";
            break;
          case "ONLYORORAND":
            a2 += "Logical Expression " + e4.operator + " being applied to parameters that are not boolean.";
        }
        break;
      case "ArrayExpression":
        if ("FUNCTIONCONTEXTILLEGAL" === n3)
          a2 += " Cannot Put Function inside Array.";
        break;
      default:
        a2 += "Expression contains unrecognised code structures.";
    }
  } catch (r3) {
    throw r3;
  }
  return a2;
}
function g(e4, t5, n3) {
  return { line: e4.loc.start.line, character: e4.loc.start.column, reason: b(e4, t5, n3) };
}
function T(e4, t5, n3, a2) {
  const r3 = { globalScope: t5.globalScope, localScope: {} };
  for (let i5 = 0; i5 < e4.params.length; i5++) {
    const t6 = e4.params[i5].name;
    r3.localScope[t6.toLowerCase()] = { type: "any" };
  }
  O2(e4.body, r3, n3, a2, false);
}
function O2(e4, t5, n3, a2, r3 = true) {
  if (null === e4)
    throw new Error("Unnexpexted Expression Syntax");
  let i5 = null;
  try {
    switch (e4.type) {
      case "VariableDeclarator":
        return "Identifier" !== e4.id.type ? a2.push(g(e4, "SYNTAX", "VARIABLEMUSTHAVEIDENTIFIER")) : (null !== t5.localScope ? t5.localScope[e4.id.name.toLowerCase()] : t5.globalScope[e4.id.name.toLowerCase()], null === t5.localScope ? t5.globalScope[e4.id.name.toLowerCase()] = { type: "any" } : t5.localScope[e4.id.name.toLowerCase()] = { type: "any" }), void (null !== e4.init && O2(e4.init, t5, n3, a2, r3));
      case "FunctionDeclaration":
        return false === r3 && a2.push(g(e4, "SYNTAX", "GLOBALFUNCTIONSONLY")), "Identifier" !== e4.id.type && a2.push(g(e4, "SYNTAX", "FUNCTIONMUSTHAVEIDENTIFIER")), i5 = y("", e4), T(e4, t5, n3, a2), null !== t5.localScope && a2.push(g(e4, "SYNTAX", "GLOBALFUNCTIONSONLY")), i5.isnative = false, void ("Identifier" === e4.id.type && (t5.globalScope[e4.id.name.toLowerCase()] = { type: "FormulaFunction", signature: [i5] }));
      case "VariableDeclaration":
        for (let i6 = 0; i6 < e4.declarations.length; i6++)
          O2(e4.declarations[i6], t5, n3, a2, r3);
        return;
      case "IfStatement":
        return null !== e4.test && (O2(e4.test, t5, n3, a2, r3), "AssignmentExpression" !== e4.test.type && "UpdateExpression" !== e4.test.type || a2.push(g(e4.test, "SYNTAX", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"))), null !== e4.consequent && O2(e4.consequent, t5, n3, a2, r3), void (null !== e4.alternate && O2(e4.alternate, t5, n3, a2, r3));
      case "EmptyStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "Literal":
      case "TemplateElement":
        return;
      case "BlockStatement":
        if (null !== e4.body)
          for (let i6 = 0; i6 < e4.body.length; i6++)
            O2(e4.body[i6], t5, n3, a2, r3);
        return;
      case "ReturnStatement":
        return void (null !== e4.argument && O2(e4.argument, t5, n3, a2, r3));
      case "ForInStatement":
        return "VariableDeclaration" === e4.left.type ? (e4.left.declarations.length > 1 && a2.push(g(e4, "SYNTAX", "ONLY1VAR")), null !== e4.left.declarations[0].init && a2.push(g(e4, "SYNTAX", "CANNOTDECLAREVAL"))) : "Identifier" !== e4.left.type && a2.push(g(e4, "SYNTAX", "LEFTNOTVAR")), O2(e4.left, t5, n3, a2, r3), O2(e4.right, t5, n3, a2, r3), void O2(e4.body, t5, n3, a2, r3);
      case "ForStatement":
        return null !== e4.init && O2(e4.init, t5, n3, a2, r3), null !== e4.test && O2(e4.test, t5, n3, a2, r3), null !== e4.body && O2(e4.body, t5, n3, a2, r3), void (null !== e4.update && O2(e4.update, t5, n3, a2, r3));
      case "UpdateExpression":
        if ("Identifier" !== e4.argument.type && "MemberExpression" !== e4.argument.type)
          a2.push(g(e4, "SYNTAX", "ASSIGNMENTTOVARSONLY"));
        else {
          if ("Identifier" === e4.argument.type) {
            let r4 = false;
            false === n3 && (null !== t5.localScope && void 0 !== t5.localScope[e4.argument.name.toLowerCase()] && (r4 = true), void 0 !== t5.globalScope[e4.argument.name.toLowerCase()] && (r4 = true), false === r4 && a2.push({ line: null === e4 ? 0 : e4.loc.start.line, character: null === e4 ? 0 : e4.loc.start.column, reason: "Identifier " + e4.argument.name + " has not been declared." }));
          }
          "MemberExpression" === e4.argument.type && O2(e4.argument, t5, n3, a2, r3);
        }
        return;
      case "AssignmentExpression": {
        switch ("Identifier" !== e4.left.type && "MemberExpression" !== e4.left.type && a2.push(g(e4, "SYNTAX", "ASSIGNMENTTOVARSONLY")), e4.operator) {
          case "=":
          case "/=":
          case "*=":
          case "%=":
          case "+=":
          case "-=":
            break;
          default:
            a2.push(g(e4, "SYNTAX", "OPERATORNOTRECOGNISED"));
        }
        O2(e4.right, t5, n3, a2, r3);
        let i6 = false;
        return "Identifier" === e4.left.type && (null !== t5.localScope && void 0 !== t5.localScope[e4.left.name.toLowerCase()] && (i6 = true), void 0 !== t5.globalScope[e4.left.name.toLowerCase()] && (i6 = true), false === n3 && false === i6 && a2.push({ line: null === e4 ? 0 : e4.loc.start.line, character: null === e4 ? 0 : e4.loc.start.column, reason: "Identifier " + e4.left.name + " has not been declared." })), void ("MemberExpression" === e4.left.type && O2(e4.left, t5, n3, a2, r3));
      }
      case "ExpressionStatement":
        return "AssignmentExpression" === e4.expression.type || e4.expression.type, void O2(e4.expression, t5, n3, a2, r3);
      case "Identifier": {
        const r4 = e4.name.toLowerCase();
        if (null !== t5.localScope && void 0 !== t5.localScope[r4])
          return;
        if (void 0 !== t5.globalScope[r4])
          return;
        false === n3 && a2.push(g(e4, "SYNTAX", "VARIABLENOTFOUND"));
        break;
      }
      case "MemberExpression":
        return O2(e4.object, t5, n3, a2, r3), void (true === e4.computed && O2(e4.property, t5, n3, a2, r3));
      case "CallExpression":
        "Identifier" !== e4.callee.type && a2.push(g(e4, "SYNTAX", "ONLYNODESSUPPORTED"));
        for (let i6 = 0; i6 < e4.arguments.length; i6++)
          O2(e4.arguments[i6], t5, n3, a2, r3);
        if ("Identifier" === e4.callee.type) {
          const r4 = s2(e4.callee.name, e4.arguments, t5);
          false === n3 && -1 === r4 && a2.push(g(e4, "SYNTAX", "NOTFOUND")), -2 === r4 && a2.push(g(e4, "SYNTAX", "WRONGSIGNATURE"));
        }
        return;
      case "UnaryExpression":
        return void O2(e4.argument, t5, n3, a2, r3);
      case "BinaryExpression":
        switch (O2(e4.left, t5, n3, a2, r3), O2(e4.right, t5, n3, a2, r3), e4.operator) {
          case "==":
          case "!=":
          case "<":
          case "<=":
          case ">":
          case ">=":
          case "+":
          case "-":
          case "*":
          case "/":
          case "%":
          case "&":
          case "|":
          case "^":
          case "<<":
          case ">>":
          case ">>>":
            break;
          default:
            a2.push(g(e4, "SYNTAX", "OPERATORNOTRECOGNISED"));
        }
        return;
      case "LogicalExpression":
        switch (e4.operator) {
          case "&&":
          case "||":
            break;
          default:
            a2.push(g(e4, "SYNTAX", "OPERATORNOTRECOGNISED"));
        }
        return O2(e4.left, t5, n3, a2, r3), "AssignmentExpression" !== e4.left.type && "UpdateExpression" !== e4.left.type || a2.push(g(e4, "SYNTAX", "CANNOT_USE_ASSIGNMENT_IN_CONDITION")), O2(e4.right, t5, n3, a2, r3), void ("AssignmentExpression" !== e4.right.type && "UpdateExpression" !== e4.right.type || a2.push(g(e4, "SYNTAX", "CANNOT_USE_ASSIGNMENT_IN_CONDITION")));
      case "ArrayExpression":
        for (let i6 = 0; i6 < e4.elements.length; i6++)
          O2(e4.elements[i6], t5, n3, a2, r3);
        return;
      case "TemplateLiteral":
        for (let i6 = 0; i6 < e4.quasis.length; i6++)
          O2(e4.quasis[i6], t5, n3, a2, r3);
        for (let i6 = 0; i6 < e4.expressions.length; i6++)
          O2(e4.expressions[i6], t5, n3, a2, r3);
        return;
      case "ObjectExpression":
        for (let i6 = 0; i6 < e4.properties.length; i6++)
          O2(e4.properties[i6], t5, n3, a2, r3);
        return;
      case "Property":
        return "Literal" !== e4.key.type && "Identifier" !== e4.key.type && a2.push(g(e4, "SYNTAX", "ONLYLITERAL")), "Literal" === e4.key.type && O2(e4.key, t5, n3, a2, r3), void O2(e4.value, t5, n3, a2, r3);
      default:
        a2.push(g(e4, "SYNTAX", "UNRECOGNISED"));
    }
    return;
  } catch (o4) {
    a2.push({ line: null === e4 ? 0 : e4.loc.start.line, character: null === e4 ? 0 : e4.loc.start.column, reason: "Unnexpected Syntax" });
  }
}
function A(t5, n3, a2, r3 = "async", i5 = e2) {
  const s4 = [];
  if ("BlockStatement" !== t5.body[0].body.type)
    return [{ line: 0, character: 0, reason: "Invalid Body" }];
  null == n3 && (n3 = { vars: {}, customFunctions: [] });
  const o4 = { globalScope: N2(n3.vars, i5, n3.customFunctions, r3), localScope: null };
  try {
    O2(t5.body[0].body, o4, a2, s4);
  } catch (l6) {
  }
  return s4;
}
function I2(e4) {
  const t5 = [];
  return l3(e4, (e5) => ("CallExpression" === e5.type && "Identifier" === e5.callee.type && t5.push(e5.callee.name.toLowerCase()), true)), t5;
}
function h(e4, a2 = []) {
  let r3 = null;
  if (void 0 === e4.usesFeatureSet) {
    null === r3 && (r3 = I2(e4)), e4.usesFeatureSet = false;
    for (let n3 = 0; n3 < r3.length; n3++)
      t3.includes(r3[n3]) && (e4.usesFeatureSet = true, e4.isAsync = true);
    if (false === e4.usesFeatureSet && a2 && a2.length > 0) {
      for (const t5 of a2)
        if (p4(e4, t5)) {
          e4.usesFeatureSet = true, e4.isAsync = true;
          break;
        }
    }
  }
  if (void 0 === e4.usesGeometry) {
    e4.usesGeometry = false, null === r3 && (r3 = I2(e4));
    for (let t5 = 0; t5 < r3.length; t5++)
      n.includes(r3[t5]) && (e4.usesGeometry = true);
  }
}
function C2(e4) {
}

// node_modules/@arcgis/core/chunks/array.js
function w2(w5) {
  function m7(r3, t5) {
    if (t5 instanceof t2)
      return w5.arcadeCustomFunctionHandler(t5);
    if (t5 instanceof N)
      return (...n3) => t5.fn(r3, { preparsed: true, arguments: n3 });
    if (t5 instanceof M2)
      return (...n3) => {
        if (n3.length !== t5.paramCount)
          throw new Error("Invalid parameters");
        return t5.fn(...n3);
      };
    throw new Error("Invalid Parameter");
  }
  function g4(n3) {
    if (n3 instanceof t)
      return n3.toArray();
    if (L(n3))
      return n3;
    throw new Error("Invalid Parameter");
  }
  w5.functions.array = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, a2) {
      G(a2, 1, 2);
      const u3 = ne(a2[0]);
      if (isNaN(u3) || false === Z(u3))
        throw new Error("Invalid Parameter");
      const c3 = I(a2[1], null), s4 = new Array(u3);
      return s4.fill(c3), s4;
    });
  }, w5.functions.front = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, o4) {
      if (G(o4, 1, 1), E(o4[0])) {
        if (o4[0].length() <= 0)
          throw new Error("Array is empty");
        return o4[0].get(0);
      }
      if (L(o4[0])) {
        if (o4[0].length <= 0)
          throw new Error("Array is empty");
        return o4[0][0];
      }
      throw new Error("Invalid Parameter");
    });
  }, w5.functions.back = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, o4) {
      if (G(o4, 1, 1), E(o4[0])) {
        if (o4[0].length() <= 0)
          throw new Error("Array is empty");
        return o4[0].get(o4[0].length() - 1);
      }
      if (L(o4[0])) {
        if (o4[0].length <= 0)
          throw new Error("Array is empty");
        return o4[0][o4[0].length - 1];
      }
      throw new Error("Invalid Parameter");
    });
  }, w5.functions.push = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, o4) {
      if (G(o4, 1, 2), L(o4[0]))
        return o4[0][o4[0].length] = o4[1], o4[0].length;
      throw new Error("Invalid Parameter");
    });
  }, w5.functions.pop = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, o4) {
      if (G(o4, 1, 1), L(o4[0])) {
        if (o4[0].length <= 0)
          throw new Error("Array is empty");
        const n5 = o4[0][o4[0].length - 1];
        return o4[0].length = o4[0].length - 1, n5;
      }
      throw new Error("Invalid Parameter");
    });
  }, w5.functions.erase = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, i5) {
      if (G(i5, 2, 2), L(i5[0])) {
        let n5 = ne(i5[1]);
        if (isNaN(n5) || false === Z(n5))
          throw new Error("Invalid Parameter");
        const r5 = i5[0];
        if (r5.length <= 0)
          throw new Error("Array is empty");
        if (n5 < 0 && (n5 = r5.length + n5), n5 < 0)
          throw new Error("Element not found");
        if (n5 >= r5.length)
          throw new Error("Index is greater than array");
        return r5.splice(n5, 1), j2;
      }
      throw new Error("Invalid Parameter");
    });
  }, w5.functions.insert = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, i5) {
      if (G(i5, 3, 3), L(i5[0])) {
        const n5 = ne(i5[1]);
        if (isNaN(n5) || false === Z(n5))
          throw new Error("Invalid Parameter");
        const r5 = i5[2], t5 = i5[0];
        if (n5 > t5.length)
          throw new Error("Index is greater than array");
        if (n5 < 0 && n5 < -1 * t5.length)
          throw new Error("Index is greater than array");
        return n5 === t5.length ? (t5[n5] = r5, j2) : (t5.splice(n5, 0, r5), j2);
      }
      throw new Error("Invalid Parameter");
    });
  }, w5.functions.resize = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, a2) {
      if (G(a2, 2, 3), L(a2[0])) {
        const n5 = ne(a2[1]);
        if (isNaN(n5) || false === Z(n5))
          throw new Error("Invalid Parameter");
        if (n5 < 0)
          throw new Error("Size cannot be negative");
        const r5 = I(a2[2], null), t5 = a2[0];
        if (t5.length >= n5)
          return t5.length = n5, j2;
        const u3 = t5.length;
        t5.length = n5;
        for (let o4 = u3; o4 < t5.length; o4++)
          t5[o4] = r5;
        return j2;
      }
      throw new Error("Invalid Parameter");
    });
  }, w5.functions.includes = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, o4) {
      if (G(o4, 2, 2), L(o4[0])) {
        const n5 = o4[1];
        return o4[0].findIndex((r5) => Q(r5, n5)) > -1;
      }
      if (E(o4[0])) {
        const n5 = o4[1];
        return o4[0].toArray().findIndex((r5) => Q(r5, n5)) > -1;
      }
      throw new Error("Invalid Parameter");
    });
  }, w5.functions.slice = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, c3) {
      if (G(c3, 1, 3), L(c3[0])) {
        const n5 = ne(I(c3[1], 0)), r5 = ne(I(c3[2], c3[0].length));
        if (isNaN(n5) || false === Z(n5))
          throw new Error("Invalid Parameter");
        if (isNaN(r5) || false === Z(r5))
          throw new Error("Invalid Parameter");
        return c3[0].slice(n5, r5);
      }
      if (E(c3[0])) {
        const n5 = c3[0], r5 = ne(I(c3[1], 0)), t5 = ne(I(c3[2], n5.length()));
        if (isNaN(r5) || false === Z(r5))
          throw new Error("Invalid Parameter");
        if (isNaN(t5) || false === Z(t5))
          throw new Error("Invalid Parameter");
        return n5.toArray().slice(r5, t5);
      }
      throw new Error("Invalid Parameter");
    });
  }, w5.functions.splice = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(n4, r4, t5) {
      const o4 = [];
      for (let e4 = 0; e4 < t5.length; e4++)
        L(t5[e4]) ? o4.push(...t5[e4]) : E(t5[e4]) ? o4.push(...t5[e4].toArray()) : o4.push(t5[e4]);
      return o4;
    });
  }, "sync" === w5.mode && (w5.functions.any = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]);
      for (const n4 of a2) {
        const r5 = i5(n4);
        if (_(r5) && true === r5)
          return true;
      }
      return false;
    });
  }, w5.functions.all = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]);
      for (const n4 of a2) {
        if (true !== i5(n4))
          return false;
      }
      return true;
    });
  }, w5.functions.none = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]);
      for (const n4 of a2) {
        if (true === i5(n4))
          return false;
      }
      return true;
    });
  }, w5.functions.reduce = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(r4, o4, e4) {
      G(e4, 2, 3);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]);
      return 2 === e4.length ? 0 === a2.length ? null : a2.reduce((n4, r5) => {
        const t5 = i5(n4, r5);
        return n4 = void 0 !== t5 && t5 !== j2 ? t5 : null;
      }) : a2.reduce((n4, r5) => {
        const t5 = i5(n4, r5);
        return n4 = void 0 !== t5 && t5 !== j2 ? t5 : null;
      }, e4[2]);
    });
  }, w5.functions.map = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]), u3 = [];
      for (const n4 of a2) {
        const r5 = i5(n4);
        void 0 !== r5 && r5 !== j2 ? u3.push(r5) : u3.push(null);
      }
      return u3;
    });
  }, w5.functions.filter = function(n3, r3) {
    return w5.standardFunction(n3, r3, function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]), u3 = [];
      for (const n4 of a2) {
        true === i5(n4) && u3.push(n4);
      }
      return u3;
    });
  }), "async" === w5.mode && (w5.functions.any = function(n3, r3) {
    return w5.standardFunctionAsync(n3, r3, async function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]);
      for (const n4 of a2) {
        const r5 = await i5(n4);
        let t5 = null;
        if (t5 = k(t5) ? await r5 : r5, _(t5) && true === t5)
          return true;
      }
      return false;
    });
  }, w5.functions.all = function(n3, r3) {
    return w5.standardFunctionAsync(n3, r3, async function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]);
      for (const n4 of a2) {
        const r5 = await i5(n4);
        let t5 = null;
        if (t5 = k(t5) ? await r5 : r5, true !== t5)
          return false;
      }
      return true;
    });
  }, w5.functions.none = function(n3, r3) {
    return w5.standardFunctionAsync(n3, r3, async function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]);
      for (const n4 of a2) {
        const r5 = await i5(n4);
        let t5 = null;
        if (t5 = k(t5) ? await r5 : r5, true === t5)
          return false;
      }
      return true;
    });
  }, w5.functions.filter = function(n3, r3) {
    return w5.standardFunctionAsync(n3, r3, async function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]), u3 = [];
      for (const n4 of a2) {
        const r5 = await i5(n4);
        let t5 = null;
        t5 = k(t5) ? await r5 : r5, true === t5 && u3.push(n4);
      }
      return u3;
    });
  }, w5.functions.reduce = function(n3, r3) {
    return w5.standardFunctionAsync(n3, r3, function(r4, o4, e4) {
      G(e4, 2, 3);
      const a2 = m7(n3, e4[1]), u3 = g4(e4[0]);
      let s4 = null;
      if (e4.length > 2) {
        const n4 = I(e4[2], null);
        s4 = u3.reduce(async (n5, r5) => {
          let t5 = await n5;
          return void 0 !== t5 && t5 !== j2 || (t5 = null), a2(t5, r5);
        }, Promise.resolve(n4));
      } else {
        if (0 === u3.length)
          return null;
        s4 = u3.reduce(async (n4, r5, t5) => {
          if (t5 <= 1)
            return a2(n4, r5);
          let o5 = await n4;
          return void 0 !== o5 && o5 !== j2 || (o5 = null), a2(o5, r5);
        });
      }
      return s4.then((n4) => void 0 !== n4 && n4 !== j2 ? n4 : null);
    });
  }, w5.functions.map = function(n3, r3) {
    return w5.standardFunctionAsync(n3, r3, async function(r4, o4, e4) {
      G(e4, 2, 2);
      const i5 = m7(n3, e4[1]), a2 = g4(e4[0]), u3 = [];
      for (const n4 of a2) {
        const r5 = await i5(n4);
        let t5 = null;
        t5 = k(t5) ? await r5 : r5, void 0 !== t5 && t5 !== j2 ? u3.push(t5) : u3.push(null);
      }
      return u3;
    });
  });
}
var m4 = Object.freeze(Object.defineProperty({ __proto__: null, registerFunctions: w2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/arcade/functions/date.js
function f3(e4) {
  const n3 = new Date(e4.getTime()), t5 = n3.getFullYear(), r3 = /* @__PURE__ */ new Date(0);
  r3.setFullYear(t5 + 1, 0, 4), r3.setHours(0, 0, 0, 0);
  const u3 = g2(r3), s4 = /* @__PURE__ */ new Date(0);
  s4.setFullYear(t5, 0, 4), s4.setHours(0, 0, 0, 0);
  const o4 = g2(s4);
  return n3.getTime() >= u3.getTime() ? t5 + 1 : n3.getTime() >= o4.getTime() ? t5 : t5 - 1;
}
function g2(e4) {
  const n3 = 1, t5 = new Date(e4.getTime()), r3 = t5.getDay(), u3 = (r3 < n3 ? 7 : 0) + r3 - n3;
  return t5.setDate(t5.getDate() - u3), t5.setHours(0, 0, 0, 0), t5;
}
function d6(e4) {
  const n3 = f3(e4), t5 = /* @__PURE__ */ new Date(0);
  t5.setFullYear(n3, 0, 4), t5.setHours(0, 0, 0, 0);
  return g2(t5);
}
function m5(e4, n3, t5) {
  return e4 + (h2(t5) ? D : N3)[n3];
}
function h2(e4) {
  return e4 % 4 == 0 && (e4 % 100 != 0 || e4 % 400 == 0);
}
var N3 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var D = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function w3(e4) {
  return null === e4 ? e4 : isNaN(e4.getTime()) ? null : e4;
}
function y2(h4, N6) {
  h4.today = function(n3, t5) {
    return N6(n3, t5, function(n4, t6, r3) {
      G(r3, 0, 0);
      const u3 = /* @__PURE__ */ new Date();
      return u3.setHours(0, 0, 0, 0), u3;
    });
  }, h4.now = function(n3, t5) {
    return N6(n3, t5, function(n4, t6, r3) {
      G(r3, 0, 0);
      return /* @__PURE__ */ new Date();
    });
  }, h4.timestamp = function(n3, t5) {
    return N6(n3, t5, function(n4, t6, r3) {
      G(r3, 0, 0);
      let u3 = /* @__PURE__ */ new Date();
      return u3 = new Date(u3.getUTCFullYear(), u3.getUTCMonth(), u3.getUTCDate(), u3.getUTCHours(), u3.getUTCMinutes(), u3.getUTCSeconds(), u3.getUTCMilliseconds()), u3;
    });
  }, h4.toutc = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? null : new Date(s4.getUTCFullYear(), s4.getUTCMonth(), s4.getUTCDate(), s4.getUTCHours(), s4.getUTCMinutes(), s4.getUTCSeconds(), s4.getUTCMilliseconds());
    });
  }, h4.tolocal = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? null : DateTime.utc(s4.getFullYear(), s4.getMonth() + 1, s4.getDate(), s4.getHours(), s4.getMinutes(), s4.getSeconds(), s4.getMilliseconds()).toJSDate();
    });
  }, h4.day = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : s4.getDate();
    });
  }, h4.month = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : s4.getMonth();
    });
  }, h4.year = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : s4.getFullYear();
    });
  }, h4.hour = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : s4.getHours();
    });
  }, h4.second = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : s4.getSeconds();
    });
  }, h4.millisecond = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : s4.getMilliseconds();
    });
  }, h4.minute = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : s4.getMinutes();
    });
  }, h4.week = function(u3, s4) {
    return N6(u3, s4, function(u4, s5, o4) {
      G(o4, 1, 2);
      const a2 = re(o4[0]);
      if (null === a2)
        return NaN;
      const c3 = ne(I(o4[1], 0));
      if (c3 < 0 || c3 > 6)
        throw new Error("Invalid Parameter");
      const i5 = a2.getDate(), l6 = a2.getMonth(), f5 = a2.getFullYear(), g4 = a2.getDay(), d7 = m5(i5, l6, f5) - 1, h5 = Math.floor(d7 / 7);
      return g4 - c3 + (g4 - c3 < 0 ? 7 : 0) < d7 - 7 * h5 ? h5 + 1 : h5;
    });
  }, h4.weekday = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : s4.getDay();
    });
  }, h4.isoweekday = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      if (null === s4)
        return NaN;
      let o4 = s4.getDay();
      return 0 === o4 && (o4 = 7), o4;
    });
  }, h4.isomonth = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : s4.getMonth() + 1;
    });
  }, h4.isoweek = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      if (null === s4)
        return NaN;
      const o4 = g2(s4).getTime() - d6(s4).getTime();
      return Math.round(o4 / 6048e5) + 1;
    });
  }, h4.isoyear = function(t5, r3) {
    return N6(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const s4 = re(u3[0]);
      return null === s4 ? NaN : f3(s4);
    });
  }, h4.date = function(r3, a2) {
    return N6(r3, a2, function(r4, a3, c3) {
      if (G(c3, 0, 7), 3 === c3.length)
        return w3(new Date(ne(c3[0]), ne(c3[1]), ne(c3[2]), 0, 0, 0, 0));
      if (4 === c3.length)
        return w3(new Date(ne(c3[0]), ne(c3[1]), ne(c3[2]), ne(c3[3]), 0, 0, 0));
      if (5 === c3.length)
        return w3(new Date(ne(c3[0]), ne(c3[1]), ne(c3[2]), ne(c3[3]), ne(c3[4]), 0, 0));
      if (6 === c3.length)
        return w3(new Date(ne(c3[0]), ne(c3[1]), ne(c3[2]), ne(c3[3]), ne(c3[4]), ne(c3[5]), 0));
      if (7 === c3.length)
        return w3(new Date(ne(c3[0]), ne(c3[1]), ne(c3[2]), ne(c3[3]), ne(c3[4]), ne(c3[5]), ne(c3[6])));
      if (2 === c3.length) {
        let e4, n3 = X(c3[1]);
        return "" === n3 ? null : (n3 = $(n3), e4 = "X" === n3 ? DateTime.fromSeconds(ne(c3[0])) : "x" === n3 ? DateTime.fromMillis(ne(c3[0])) : DateTime.fromFormat(X(c3[0]), n3, { locale: l(), numberingSystem: "latn" }), e4.isValid ? e4.toJSDate() : null);
      }
      if (1 === c3.length) {
        if (w(c3[0])) {
          if ("" === c3[0].replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""))
            return null;
          if (true === /^[0-9][0-9][0-9][0-9]$/.test(c3[0]))
            return re(c3[0] + "-01-01");
        }
        const e4 = ne(c3[0]);
        if (false === isNaN(e4))
          return w3(new Date(e4));
        return re(c3[0]);
      }
      return 0 === c3.length ? /* @__PURE__ */ new Date() : void 0;
    });
  }, h4.datediff = function(n3, t5) {
    return N6(n3, t5, function(n4, t6, r3) {
      G(r3, 2, 3);
      const s4 = ie(r3[0]), o4 = ie(r3[1]);
      if (null === s4 || null === o4)
        return NaN;
      switch (X(r3[2]).toLowerCase()) {
        case "days":
        case "day":
        case "d":
          return s4.diff(o4, "days").days;
        case "months":
        case "month":
          return s4.diff(o4, "months").months;
        case "minutes":
        case "minute":
        case "m":
          return "M" === r3[2] ? s4.diff(o4, "months").months : s4.diff(o4, "minutes").minutes;
        case "seconds":
        case "second":
        case "s":
          return s4.diff(o4, "seconds").seconds;
        case "milliseconds":
        case "millisecond":
        case "ms":
        default:
          return s4.diff(o4).milliseconds;
        case "hours":
        case "hour":
        case "h":
          return s4.diff(o4, "hours").hours;
        case "years":
        case "year":
        case "y":
          return s4.diff(o4, "years").years;
      }
    });
  }, h4.dateadd = function(n3, r3) {
    return N6(n3, r3, function(n4, r4, s4) {
      G(s4, 2, 3);
      const o4 = ie(s4[0]);
      if (null === o4)
        return null;
      let i5 = ne(s4[1]);
      if (isNaN(i5))
        return o4.toJSDate();
      let l6 = "milliseconds";
      switch (X(s4[2]).toLowerCase()) {
        case "days":
        case "day":
        case "d":
          l6 = "days", i5 = V(i5);
          break;
        case "months":
        case "month":
          l6 = "months", i5 = V(i5);
          break;
        case "minutes":
        case "minute":
        case "m":
          l6 = "M" === s4[2] ? "months" : "minutes";
          break;
        case "seconds":
        case "second":
        case "s":
          l6 = "seconds";
          break;
        case "milliseconds":
        case "millisecond":
        case "ms":
          l6 = "milliseconds";
          break;
        case "hours":
        case "hour":
        case "h":
          l6 = "hours";
          break;
        case "years":
        case "year":
        case "y":
          l6 = "years";
      }
      return o4.plus({ [l6]: i5 }).toJSDate();
    });
  };
}

// node_modules/@arcgis/core/arcade/functions/geometry.js
function D2(e4) {
  return e4 && "esri.arcade.Feature" === e4.arcadeDeclaredClass;
}
function P4(P6, M5) {
  P6.ringisclockwise = function(e4, r3) {
    return M5(e4, r3, function(e5, r4, o4) {
      G(o4, 1, 1);
      let l6 = [], s4 = false, f5 = false;
      if (null === o4[0])
        return false;
      if (L(o4[0])) {
        for (const e6 of o4[0]) {
          if (!(e6 instanceof j))
            throw new Error("Invalid Argument");
          l6.push(e6.hasZ ? e6.hasM ? [e6.x, e6.y, e6.z, e6.m] : [e6.x, e6.y, e6.z] : [e6.x, e6.y]);
        }
        l6.length > 0 && (s4 = o4[0][0].hasZ, f5 = o4[0][0].hasM);
      } else if (o4[0] instanceof i)
        l6 = o4[0]._elements, l6.length > 0 && (s4 = o4[0]._hasZ, f5 = o4[0]._hasM);
      else {
        if (!E(o4[0]))
          throw new Error("Invalid Argument");
        for (const e6 of o4[0].toArray()) {
          if (!(e6 instanceof j))
            throw new Error("Invalid Argument");
          l6.push(e6.hasZ ? e6.hasM ? [e6.x, e6.y, e6.z, e6.m] : [e6.x, e6.y, e6.z] : [e6.x, e6.y]);
        }
        l6.length > 0 && (s4 = o4[0].get(0).hasZ, f5 = o4[0].get(0).hasM);
      }
      return !(l6.length < 3) && f(l6, f5, s4);
    });
  }, P6.polygon = function(n3, i5) {
    return M5(n3, i5, function(i6, a2, s4) {
      G(s4, 1, 1);
      let f5 = null;
      if (s4[0] instanceof d2) {
        if (f5 = se(d3.parseGeometryFromDictionary(s4[0]), n3.spatialReference), f5 instanceof v == false)
          throw new Error("Illegal Parameter");
      } else
        f5 = s4[0] instanceof v ? d(s4[0].toJSON()) : se(new v(JSON.parse(s4[0])), n3.spatialReference);
      if (null !== f5 && false === f5.spatialReference.equals(n3.spatialReference))
        throw new Error("Cannot create Geometry in this SpatialReference. Engine is using a different spatial reference.");
      return ue(f5);
    });
  }, P6.polyline = function(n3, i5) {
    return M5(n3, i5, function(i6, a2, s4) {
      G(s4, 1, 1);
      let f5 = null;
      if (s4[0] instanceof d2) {
        if (f5 = se(d3.parseGeometryFromDictionary(s4[0]), n3.spatialReference), f5 instanceof m2 == false)
          throw new Error("Illegal Parameter");
      } else
        f5 = s4[0] instanceof m2 ? d(s4[0].toJSON()) : se(new m2(JSON.parse(s4[0])), n3.spatialReference);
      if (null !== f5 && false === f5.spatialReference.equals(n3.spatialReference))
        throw new Error("Cannot create Geometry in this SpatialReference. Engine is using a different spatial reference.");
      return ue(f5);
    });
  }, P6.point = function(n3, i5) {
    return M5(n3, i5, function(i6, a2, s4) {
      G(s4, 1, 1);
      let f5 = null;
      if (s4[0] instanceof d2) {
        if (f5 = se(d3.parseGeometryFromDictionary(s4[0]), n3.spatialReference), f5 instanceof j == false)
          throw new Error("Illegal Parameter");
      } else
        f5 = s4[0] instanceof j ? d(s4[0].toJSON()) : se(new j(JSON.parse(s4[0])), n3.spatialReference);
      if (null !== f5 && false === f5.spatialReference.equals(n3.spatialReference))
        throw new Error("Cannot create Geometry in this SpatialReference. Engine is using a different spatial reference.");
      return ue(f5);
    });
  }, P6.multipoint = function(n3, i5) {
    return M5(n3, i5, function(i6, a2, s4) {
      G(s4, 1, 1);
      let f5 = null;
      if (s4[0] instanceof d2) {
        if (f5 = se(d3.parseGeometryFromDictionary(s4[0]), n3.spatialReference), f5 instanceof m == false)
          throw new Error("Illegal Parameter");
      } else
        f5 = s4[0] instanceof m ? d(s4[0].toJSON()) : se(new m(JSON.parse(s4[0])), n3.spatialReference);
      if (null !== f5 && false === f5.spatialReference.equals(n3.spatialReference))
        throw new Error("Cannot create Geometry in this SpatialReference. Engine is using a different spatial reference.");
      return ue(f5);
    });
  }, P6.extent = function(n3, i5) {
    return M5(n3, i5, function(i6, a2, f5) {
      f5 = ye(f5), G(f5, 1, 1);
      let c3 = null;
      if (f5[0] instanceof d2)
        c3 = se(d3.parseGeometryFromDictionary(f5[0]), n3.spatialReference);
      else if (f5[0] instanceof j) {
        const e4 = { xmin: f5[0].x, ymin: f5[0].y, xmax: f5[0].x, ymax: f5[0].y, spatialReference: f5[0].spatialReference.toJSON() }, r3 = f5[0];
        r3.hasZ ? (e4.zmin = r3.z, e4.zmax = r3.z) : r3.hasM && (e4.mmin = r3.m, e4.mmax = r3.m), c3 = d(e4);
      } else
        c3 = f5[0] instanceof v || f5[0] instanceof m2 || f5[0] instanceof m ? d(f5[0].extent.toJSON()) : f5[0] instanceof M ? d(f5[0].toJSON()) : se(new M(JSON.parse(f5[0])), n3.spatialReference);
      if (null !== c3 && false === c3.spatialReference.equals(n3.spatialReference))
        throw new Error("Cannot create Geometry in this SpatialReference. Engine is using a different spatial reference.");
      return ue(c3);
    });
  }, P6.geometry = function(n3, i5) {
    return M5(n3, i5, function(i6, a2, s4) {
      G(s4, 1, 1);
      let f5 = null;
      if (null === s4[0])
        return null;
      if (f5 = D2(s4[0]) ? se(s4[0].geometry(), n3.spatialReference) : s4[0] instanceof d2 ? se(d3.parseGeometryFromDictionary(s4[0]), n3.spatialReference) : se(d(JSON.parse(s4[0])), n3.spatialReference), null !== f5 && false === f5.spatialReference.equals(n3.spatialReference))
        throw new Error("Cannot create Geometry in this SpatialReference. Engine is using a different spatial reference.");
      return ue(f5);
    });
  }, P6.setgeometry = function(e4, r3) {
    return M5(e4, r3, function(e5, r4, n3) {
      if (G(n3, 2, 2), !D2(n3[0]))
        throw new Error("Illegal Argument");
      if (true === n3[0].immutable)
        throw new Error("Feature is Immutable");
      if (!(n3[1] instanceof p || null === n3[1]))
        throw new Error("Illegal Argument");
      return n3[0]._geometry = n3[1], j2;
    });
  }, P6.feature = function(n3, t5) {
    return M5(n3, t5, function(t6, i5, a2) {
      if (0 === a2.length)
        throw new Error("Missing Parameters");
      let l6 = null;
      if (1 === a2.length)
        if (w(a2[0]))
          l6 = d3.fromJson(JSON.parse(a2[0]));
        else if (D2(a2[0]))
          l6 = d3.createFromArcadeFeature(a2[0]);
        else if (a2[0] instanceof p)
          l6 = d3.createFromGraphicLikeObject(a2[0], null, null);
        else {
          if (!(a2[0] instanceof d2))
            throw new Error("Illegal Argument");
          {
            let n4 = a2[0].hasField("geometry") ? a2[0].field("geometry") : null, t7 = a2[0].hasField("attributes") ? a2[0].field("attributes") : null;
            null !== n4 && n4 instanceof d2 && (n4 = d3.parseGeometryFromDictionary(n4)), null !== t7 && (t7 = d3.parseAttributesFromDictionary(t7)), l6 = d3.createFromGraphicLikeObject(n4, t7, null);
          }
        }
      else if (2 === a2.length) {
        let n4 = null, t7 = null;
        if (null !== a2[0])
          if (a2[0] instanceof p)
            n4 = a2[0];
          else {
            if (!(n4 instanceof d2))
              throw new Error("Illegal Argument");
            n4 = d3.parseGeometryFromDictionary(a2[0]);
          }
        if (null !== a2[1]) {
          if (!(a2[1] instanceof d2))
            throw new Error("Illegal Argument");
          t7 = d3.parseAttributesFromDictionary(a2[1]);
        }
        l6 = d3.createFromGraphicLikeObject(n4, t7, null);
      } else {
        let n4 = null;
        const t7 = {};
        if (null !== a2[0])
          if (a2[0] instanceof p)
            n4 = a2[0];
          else {
            if (!(n4 instanceof d2))
              throw new Error("Illegal Argument");
            n4 = d3.parseGeometryFromDictionary(a2[0]);
          }
        for (let e4 = 1; e4 < a2.length; e4 += 2) {
          const r3 = X(a2[e4]), n5 = a2[e4 + 1];
          if (!(null == n5 || w(n5) || isNaN(n5) || z(n5) || O(n5) || _(n5)))
            throw new Error("Illegal Argument");
          if (v2(n5) || false === C(n5))
            throw new Error("Illegal Argument");
          t7[r3] = n5 === j2 ? null : n5;
        }
        l6 = d3.createFromGraphicLikeObject(n4, t7, null);
      }
      return l6._geometry = se(l6.geometry(), n3.spatialReference), l6.immutable = false, l6;
    });
  }, P6.dictionary = function(r3, n3) {
    return M5(r3, n3, function(r4, n4, t5) {
      if (0 === t5.length) {
        const r5 = new d2();
        return r5.immutable = false, r5;
      }
      if (1 === t5.length && w(t5[0]))
        try {
          const r5 = JSON.parse(t5[0]), n5 = d2.convertObjectToArcadeDictionary(r5, false);
          return n5.immutable = false, n5;
        } catch (s4) {
          throw new Error("Missing Parameters or Illegal Json");
        }
      if (t5.length % 2 != 0)
        throw new Error("Missing Parameters");
      const o4 = {};
      for (let e4 = 0; e4 < t5.length; e4 += 2) {
        const r5 = X(t5[e4]), n5 = t5[e4 + 1];
        if (!(null == n5 || w(n5) || isNaN(n5) || z(n5) || O(n5) || _(n5) || L(n5) || E(n5)))
          throw new Error("Illegal Argument");
        if (v2(n5))
          throw new Error("Illegal Argument");
        o4[r5] = n5 === j2 ? null : n5;
      }
      const l6 = new d2(o4);
      return l6.immutable = false, l6;
    });
  }, P6.haskey = function(r3, n3) {
    return M5(r3, n3, function(r4, n4, i5) {
      G(i5, 2, 2);
      const a2 = X(i5[1]);
      if (D2(i5[0]))
        return i5[0].hasField(a2);
      if (i5[0] instanceof d2)
        return i5[0].hasField(a2);
      throw new Error("Illegal Argument");
    });
  }, P6.indexof = function(e4, r3) {
    return M5(e4, r3, function(e5, r4, n3) {
      G(n3, 2, 2);
      const o4 = n3[1];
      if (L(n3[0])) {
        for (let e6 = 0; e6 < n3[0].length; e6++)
          if (Q(o4, n3[0][e6]))
            return e6;
        return -1;
      }
      if (E(n3[0])) {
        const e6 = n3[0].length();
        for (let r5 = 0; r5 < e6; r5++)
          if (Q(o4, n3[0].get(r5)))
            return r5;
        return -1;
      }
      throw new Error("Illegal Argument");
    });
  }, P6.angle = function(e4, r3) {
    return M5(e4, r3, function(e5, r4, n3) {
      if (n3 = ye(n3), G(n3, 2, 3), !(n3[0] instanceof j))
        throw new Error("Illegal Argument");
      if (!(n3[1] instanceof j))
        throw new Error("Illegal Argument");
      if (n3.length > 2 && !(n3[2] instanceof j))
        throw new Error("Illegal Argument");
      return 2 === n3.length ? p3(n3[0], n3[1]) : P3(n3[0], n3[1], n3[2]);
    });
  }, P6.bearing = function(e4, r3) {
    return M5(e4, r3, function(e5, r4, n3) {
      if (n3 = ye(n3), G(n3, 2, 3), !(n3[0] instanceof j))
        throw new Error("Illegal Argument");
      if (!(n3[1] instanceof j))
        throw new Error("Illegal Argument");
      if (n3.length > 2 && !(n3[2] instanceof j))
        throw new Error("Illegal Argument");
      return 2 === n3.length ? M3(n3[0], n3[1]) : d4(n3[0], n3[1], n3[2]);
    });
  }, P6.isselfintersecting = function(e4, r3) {
    return M5(e4, r3, function(r4, n3, o4) {
      o4 = ye(o4), G(o4, 1, 1);
      let l6 = o4[0];
      if (l6 instanceof v)
        return l6.isSelfIntersecting;
      if (l6 instanceof m2)
        return l6 = l6.paths, Z2(l6);
      if (l6 instanceof m) {
        const e5 = l6.points;
        for (let r5 = 0; r5 < e5.length; r5++)
          for (let n4 = 0; n4 < e5.length; n4++)
            if (n4 !== r5) {
              let t5 = true;
              for (let i5 = 0; i5 < e5[r5].length; i5++)
                if (e5[r5][i5] !== e5[n4][i5]) {
                  t5 = false;
                  break;
                }
              if (true === t5)
                return true;
            }
      }
      return !(!L(l6) && !E(l6)) && (l6 = he(l6, e4.spatialReference), null !== l6 && (l6 = l6.paths), Z2(l6));
    });
  };
}

// node_modules/@arcgis/core/arcade/functions/maths.js
function l4(n3, t5, r3) {
  return void 0 === r3 || 0 == +r3 ? Math[n3](t5) : (t5 = +t5, r3 = +r3, isNaN(t5) || "number" != typeof r3 || r3 % 1 != 0 ? NaN : (t5 = t5.toString().split("e"), +((t5 = (t5 = Math[n3](+(t5[0] + "e" + (t5[1] ? +t5[1] - r3 : -r3)))).toString().split("e"))[0] + "e" + (t5[1] ? +t5[1] + r3 : r3))));
}
function N4(N6, h4) {
  function m7(n3, t5, r3) {
    const u3 = ne(n3);
    return isNaN(u3) ? u3 : isNaN(t5) || isNaN(r3) || t5 > r3 ? NaN : u3 < t5 ? t5 : u3 > r3 ? r3 : u3;
  }
  N6.number = function(f5, a2) {
    return h4(f5, a2, function(f6, a3, c3) {
      G(c3, 1, 2);
      const l6 = c3[0];
      if (O(l6))
        return l6;
      if (null === l6)
        return 0;
      if (z(l6))
        return Number(l6);
      if (_(l6))
        return Number(l6);
      if (L(l6))
        return NaN;
      if ("" === l6)
        return Number(l6);
      if (void 0 === l6)
        return Number(l6);
      if (w(l6)) {
        if (void 0 !== c3[1]) {
          let n3 = F(c3[1], "‰", "");
          return n3 = F(n3, "¤", ""), p2(l6, { pattern: n3 });
        }
        return Number(l6.trim());
      }
      return Number(l6);
    });
  }, N6.abs = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.abs(ne(u3[0]));
    });
  }, N6.acos = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.acos(ne(u3[0]));
    });
  }, N6.asin = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.asin(ne(u3[0]));
    });
  }, N6.atan = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.atan(ne(u3[0]));
    });
  }, N6.atan2 = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 2, 2), Math.atan2(ne(u3[0]), ne(u3[1]));
    });
  }, N6.ceil = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      if (G(u3, 1, 2), 2 === u3.length) {
        let n3 = ne(u3[1]);
        return isNaN(n3) && (n3 = 0), l4("ceil", ne(u3[0]), -1 * n3);
      }
      return Math.ceil(ne(u3[0]));
    });
  }, N6.round = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      if (G(u3, 1, 2), 2 === u3.length) {
        let n3 = ne(u3[1]);
        return isNaN(n3) && (n3 = 0), l4("round", ne(u3[0]), -1 * n3);
      }
      return Math.round(ne(u3[0]));
    });
  }, N6.floor = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      if (G(u3, 1, 2), 2 === u3.length) {
        let n3 = ne(u3[1]);
        return isNaN(n3) && (n3 = 0), l4("floor", ne(u3[0]), -1 * n3);
      }
      return Math.floor(ne(u3[0]));
    });
  }, N6.cos = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.cos(ne(u3[0]));
    });
  }, N6.isnan = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), "number" == typeof u3[0] && isNaN(u3[0]);
    });
  }, N6.exp = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.exp(ne(u3[0]));
    });
  }, N6.log = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.log(ne(u3[0]));
    });
  }, N6.pow = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 2, 2), ne(u3[0]) ** ne(u3[1]);
    });
  }, N6.random = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 0, 0), Math.random();
    });
  }, N6.sin = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.sin(ne(u3[0]));
    });
  }, N6.sqrt = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.sqrt(ne(u3[0]));
    });
  }, N6.tan = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), Math.tan(ne(u3[0]));
    });
  }, N6.defaultvalue = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 2, 2), null === u3[0] || "" === u3[0] || void 0 === u3[0] ? u3[1] : u3[0];
    });
  }, N6.isempty = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      return G(u3, 1, 1), null === u3[0] || ("" === u3[0] || void 0 === u3[0]);
    });
  }, N6.boolean = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      G(u3, 1, 1);
      const e4 = u3[0];
      return oe(e4);
    });
  }, N6.constrain = function(t5, r3) {
    return h4(t5, r3, function(t6, r4, u3) {
      G(u3, 3, 3);
      const i5 = ne(u3[1]), o4 = ne(u3[2]);
      if (L(u3[0])) {
        const n3 = [];
        for (const t7 of u3[0])
          n3.push(m7(t7, i5, o4));
        return n3;
      }
      if (E(u3[0])) {
        const n3 = [];
        for (let t7 = 0; t7 < u3[0].length(); t7++)
          n3.push(m7(u3[0].get(t7), i5, o4));
        return n3;
      }
      return m7(u3[0], i5, o4);
    });
  };
}

// node_modules/@arcgis/core/arcade/functions/stats.js
function i3(n3, r3, i5, o4) {
  if (1 === o4.length) {
    if (L(o4[0]))
      return l2(n3, o4[0], -1);
    if (E(o4[0]))
      return l2(n3, o4[0].toArray(), -1);
  }
  return l2(n3, o4, -1);
}
function o2(e4, o4) {
  e4.stdev = function(n3, t5) {
    return o4(n3, t5, function(n4, t6, r3) {
      return i3("stdev", n4, t6, r3);
    });
  }, e4.variance = function(n3, t5) {
    return o4(n3, t5, function(n4, t6, r3) {
      return i3("variance", n4, t6, r3);
    });
  }, e4.average = function(n3, t5) {
    return o4(n3, t5, function(n4, t6, r3) {
      return i3("mean", n4, t6, r3);
    });
  }, e4.mean = function(n3, t5) {
    return o4(n3, t5, function(n4, t6, r3) {
      return i3("mean", n4, t6, r3);
    });
  }, e4.sum = function(n3, t5) {
    return o4(n3, t5, function(n4, t6, r3) {
      return i3("sum", n4, t6, r3);
    });
  }, e4.min = function(n3, t5) {
    return o4(n3, t5, function(n4, t6, r3) {
      return i3("min", n4, t6, r3);
    });
  }, e4.max = function(n3, t5) {
    return o4(n3, t5, function(n4, t6, r3) {
      return i3("max", n4, t6, r3);
    });
  }, e4.distinct = function(n3, t5) {
    return o4(n3, t5, function(n4, t6, r3) {
      return i3("distinct", n4, t6, r3);
    });
  }, e4.count = function(e5, i5) {
    return o4(e5, i5, function(e6, i6, o5) {
      if (G(o5, 1, 1), L(o5[0]) || w(o5[0]))
        return o5[0].length;
      if (E(o5[0]))
        return o5[0].length();
      throw new Error("Invalid Parameters for Count");
    });
  };
}

// node_modules/@arcgis/core/arcade/functions/convertdirection.js
var c2 = (e4) => (t5, r3, n3) => (n3 = n3 || 14, +e4(t5, r3).toFixed(n3));
var o3 = (e4, t5) => e4 + t5;
var u2 = (e4, t5) => e4 * t5;
var m6 = (e4, t5) => e4 / t5;
var l5 = (e4, t5, r3) => c2(o3)(e4, t5, r3);
var g3 = (e4, t5, r3) => c2(u2)(e4, t5, r3);
var _2 = (e4, t5, r3) => c2(m6)(e4, t5, r3);
var f4 = 360;
var w4 = 400;
var A2 = 2 * Math.PI;
var D3 = 3600;
var E3 = 3240;
var p5 = 60;
var T2 = 60;
var S2 = 180 * D3 / Math.PI;
var R = f4 * p5 * T2;
var M4 = 90 * D3;
var U = 180 * D3;
var v3 = 270 * D3;
var F2 = String.fromCharCode(7501);
var I3 = "°";
function N5(e4) {
  if (false === w(e4))
    throw new Error("Invalid Parameter");
  return e4;
}
function x2(e4, t5) {
  const r3 = 10 ** t5;
  return Math.round(e4 * r3) / r3;
}
function z2(e4, t5) {
  return e4 % t5;
}
function O3(e4) {
  const t5 = parseFloat(e4.toString().replace(Math.trunc(e4).toString(), "0")) * Math.sign(e4);
  if (e4 < 0) {
    return { fraction: t5, integer: Math.ceil(e4) };
  }
  return { fraction: t5, integer: Math.floor(e4) };
}
var G2;
var b2;
var H2;
var C3;
function y3(e4, t5) {
  switch (e4) {
    case G2.north:
      return "SHORT" === t5 ? "N" : "North";
    case G2.east:
      return "SHORT" === t5 ? "E" : "East";
    case G2.south:
      return "SHORT" === t5 ? "S" : "South";
    case G2.west:
      return "SHORT" === t5 ? "W" : "West";
  }
}
function q(e4, t5, r3) {
  for (; e4.length < r3; )
    e4 = t5 + e4;
  return e4;
}
function P5(e4, t5) {
  return e4 - Math.floor(e4 / t5) * t5;
}
function k3(e4) {
  switch (e4) {
    case b2.truncated_degrees:
    case b2.decimal_degrees:
      return f4;
    case b2.radians:
      return A2;
    case b2.gradians:
      return w4;
    case b2.seconds:
      return R;
    case b2.fractional_degree_minutes:
      return p5;
    case b2.fractional_minute_seconds:
      return T2;
    default:
      throw new Error("Unnexpected evaluations");
  }
}
function L2(e4) {
  switch (e4.toUpperCase().trim()) {
    case "NORTH":
    case "NORTHAZIMUTH":
    case "NORTH AZIMUTH":
      return H2.north_azimuth;
    case "POLAR":
      return H2.polar;
    case "QUADRANT":
      return H2.quadrant;
    case "SOUTH":
    case "SOUTHAZIMUTH":
    case "SOUTH AZIMUTH":
      return H2.south_azimuth;
  }
  throw new Error("Unsupported direction type");
}
function Q2(e4) {
  switch (e4.toUpperCase().trim()) {
    case "D":
    case "DD":
    case "DECIMALDEGREE":
    case "DECIMAL DEGREE":
    case "DEGREE":
    case "DECIMALDEGREES":
    case "DECIMAL DEGREES":
    case "DEGREES":
      return b2.decimal_degrees;
    case "DMS":
    case "DEGREESMINUTESSECONDS":
    case "DEGREES MINUTES SECONDS":
      return b2.degrees_minutes_seconds;
    case "R":
    case "RAD":
    case "RADS":
    case "RADIAN":
    case "RADIANS":
      return b2.radians;
    case "G":
    case "GON":
    case "GONS":
    case "GRAD":
    case "GRADS":
    case "GRADIAN":
    case "GRADIANS":
      return b2.gradians;
  }
  throw new Error("Unsupported units");
}
!function(e4) {
  e4[e4.north = 0] = "north", e4[e4.east = 1] = "east", e4[e4.south = 2] = "south", e4[e4.west = 3] = "west";
}(G2 || (G2 = {})), function(e4) {
  e4[e4.decimal_degrees = 1] = "decimal_degrees", e4[e4.seconds = 2] = "seconds", e4[e4.degrees_minutes_seconds = 3] = "degrees_minutes_seconds", e4[e4.radians = 4] = "radians", e4[e4.gradians = 5] = "gradians", e4[e4.truncated_degrees = 6] = "truncated_degrees", e4[e4.fractional_degree_minutes = 7] = "fractional_degree_minutes", e4[e4.fractional_minute_seconds = 8] = "fractional_minute_seconds";
}(b2 || (b2 = {})), function(e4) {
  e4[e4.north_azimuth = 1] = "north_azimuth", e4[e4.polar = 2] = "polar", e4[e4.quadrant = 3] = "quadrant", e4[e4.south_azimuth = 4] = "south_azimuth";
}(H2 || (H2 = {})), function(e4) {
  e4[e4.meridian = 0] = "meridian", e4[e4.direction = 1] = "direction";
}(C3 || (C3 = {}));
var W = class {
  constructor(e4, t5, r3) {
    this.m_degrees = e4, this.m_minutes = t5, this.m_seconds = r3;
  }
  getField(e4) {
    switch (e4) {
      case b2.decimal_degrees:
      case b2.truncated_degrees:
        return this.m_degrees;
      case b2.fractional_degree_minutes:
        return this.m_minutes;
      case b2.seconds:
      case b2.fractional_minute_seconds:
        return this.m_seconds;
      default:
        throw new Error("Unnexpected evaluation");
    }
  }
  static secondsToDMS(e4) {
    const t5 = O3(e4).fraction;
    let r3 = O3(e4).integer;
    const n3 = Math.floor(r3 / D3);
    r3 -= n3 * D3;
    const s4 = Math.floor(r3 / T2);
    return r3 -= s4 * T2, new W(n3, s4, r3 + t5);
  }
  static numberToDms(e4) {
    const t5 = O3(e4).fraction, r3 = O3(e4).integer, n3 = g3(O3(100 * t5).fraction, 100), s4 = O3(100 * t5).integer;
    return new W(r3, s4, n3);
  }
  format(e4, t5) {
    let r3 = x2(this.m_seconds, t5), n3 = this.m_minutes, s4 = this.m_degrees;
    if (e4 === b2.seconds || e4 === b2.fractional_minute_seconds)
      T2 <= r3 && (r3 -= T2, ++n3), p5 <= n3 && (n3 = 0, ++s4), f4 <= s4 && (s4 = 0);
    else if (e4 === b2.fractional_degree_minutes)
      r3 = 0, n3 = 30 <= this.m_seconds ? this.m_minutes + 1 : this.m_minutes, s4 = this.m_degrees, p5 <= n3 && (n3 = 0, ++s4), f4 <= s4 && (s4 = 0);
    else if (e4 === b2.decimal_degrees || e4 === b2.truncated_degrees) {
      const e5 = _2(this.m_seconds, D3), t6 = _2(this.m_minutes, p5);
      s4 = Math.round(this.m_degrees + t6 + e5), n3 = 0, r3 = 0;
    }
    return new W(s4, n3, r3);
  }
  static dmsToSeconds(e4, t5, r3) {
    return e4 * D3 + t5 * T2 + r3;
  }
};
var Z3 = class {
  constructor(e4, t5, r3) {
    this.meridian = e4, this.angle = t5, this.direction = r3;
  }
  fetchAzimuth(e4) {
    return e4 === C3.meridian ? this.meridian : this.direction;
  }
};
var B = class {
  constructor(e4) {
    this.m_angle = e4;
  }
  static createFromAngleAndDirection(e4, t5) {
    return new B(new V2(B._convertDirectionFormat(e4.extractAngularUnits(b2.seconds), t5, H2.north_azimuth)));
  }
  getAngle(e4) {
    const t5 = this.m_angle.extractAngularUnits(b2.seconds);
    switch (e4) {
      case H2.north_azimuth:
      case H2.south_azimuth:
      case H2.polar:
        return new V2(B._convertDirectionFormat(t5, H2.north_azimuth, e4));
      case H2.quadrant: {
        const e5 = B.secondsNorthAzimuthToQuadrant(t5);
        return new V2(e5.angle);
      }
    }
  }
  getMeridian(e4) {
    const t5 = this.m_angle.extractAngularUnits(b2.seconds);
    switch (e4) {
      case H2.north_azimuth:
        return G2.north;
      case H2.south_azimuth:
        return G2.south;
      case H2.polar:
        return G2.east;
      case H2.quadrant:
        return B.secondsNorthAzimuthToQuadrant(t5).meridian;
    }
  }
  getDirection(e4) {
    const t5 = this.m_angle.extractAngularUnits(b2.seconds);
    switch (e4) {
      case H2.north_azimuth:
        return G2.east;
      case H2.south_azimuth:
        return G2.west;
      case H2.polar:
        return G2.north;
      case H2.quadrant:
        return B.secondsNorthAzimuthToQuadrant(t5).direction;
    }
  }
  static secondsNorthAzimuthToQuadrant(e4) {
    const t5 = e4 <= M4 || e4 >= v3 ? G2.north : G2.south, r3 = t5 === G2.north ? Math.min(R - e4, e4) : Math.abs(e4 - U), n3 = e4 > U ? G2.west : G2.east;
    return new Z3(t5, r3, n3);
  }
  static createFromAngleMeridianAndDirection(e4, t5, r3) {
    return new B(new V2(B.secondsQuadrantToNorthAzimuth(e4.extractAngularUnits(b2.seconds), t5, r3)));
  }
  static secondsQuadrantToNorthAzimuth(e4, t5, r3) {
    return t5 === G2.north ? r3 === G2.east ? e4 : R - e4 : r3 === G2.east ? U - e4 : U + e4;
  }
  static _convertDirectionFormat(e4, t5, r3) {
    let n3 = 0;
    switch (t5) {
      case H2.north_azimuth:
        n3 = e4;
        break;
      case H2.polar:
        n3 = M4 - e4;
        break;
      case H2.quadrant:
        throw new Error("Unnexpected evaluation");
      case H2.south_azimuth:
        n3 = e4 + U;
    }
    let s4 = 0;
    switch (r3) {
      case H2.north_azimuth:
        s4 = n3;
        break;
      case H2.polar:
        s4 = M4 - n3;
        break;
      case H2.quadrant:
        throw new Error("Unnexpected evaluation");
      case H2.south_azimuth:
        s4 = n3 - U;
    }
    return s4 = z2(s4, R), s4 < 0 ? R + s4 : s4;
  }
};
function j3(e4, t5, r3) {
  let n3 = null;
  switch (t5) {
    case b2.decimal_degrees:
      n3 = g3(e4, D3);
      break;
    case b2.seconds:
      n3 = e4;
      break;
    case b2.gradians:
      n3 = g3(e4, E3);
      break;
    case b2.radians:
      n3 = g3(e4, S2);
      break;
    default:
      throw new Error("Unnexpected evaluation");
  }
  switch (r3) {
    case b2.decimal_degrees:
      return _2(n3, D3);
    case b2.seconds:
      return n3;
    case b2.gradians:
      return _2(n3, E3);
    case b2.radians:
      return n3 / S2;
    default:
      throw new Error("Unnexpected evaluation");
  }
}
var V2 = class {
  constructor(e4) {
    this.m_seconds = e4;
  }
  static createFromAngleAndUnits(e4, t5) {
    return new V2(j3(e4, t5, b2.seconds));
  }
  extractAngularUnits(e4) {
    return j3(this.m_seconds, b2.seconds, X2(e4));
  }
  static createFromDegreesMinutesSeconds(e4, t5, r3) {
    return new V2(l5(l5(g3(e4, D3), g3(t5, T2)), r3));
  }
};
function X2(e4) {
  switch (e4) {
    case b2.decimal_degrees:
    case b2.truncated_degrees:
    case b2.degrees_minutes_seconds:
      return b2.decimal_degrees;
    case b2.gradians:
      return b2.gradians;
    case b2.fractional_degree_minutes:
      return b2.fractional_degree_minutes;
    case b2.radians:
      return b2.radians;
    case b2.seconds:
    case b2.fractional_minute_seconds:
      return b2.seconds;
  }
}
var J2 = class {
  constructor(e4, t5, r3, n3) {
    this.m_view = e4, this.m_angle = t5, this.m_merdian = r3, this.m_direction = n3, this.m_dms = null, this.m_formatted_dms = null;
  }
  static createFromStringAndBearing(e4, t5, r3) {
    return new J2(e4, t5.getAngle(r3), t5.getMeridian(r3), t5.getDirection(r3));
  }
  fetchAngle() {
    return this.m_angle;
  }
  fetchMeridian() {
    return this.m_merdian;
  }
  fetchDirection() {
    return this.m_direction;
  }
  fetchView() {
    return this.m_view;
  }
  fetchDms() {
    return null === this.m_dms && this._calculateDms(), this.m_dms;
  }
  fetchFormattedDms() {
    return null === this.m_formatted_dms && this._calculateDms(), this.m_formatted_dms;
  }
  _calculateDms() {
    let e4 = null, t5 = b2.truncated_degrees, r3 = 0;
    for (let n3 = 0; n3 < this.m_view.length; n3++) {
      const s4 = this.m_view[n3];
      switch (s4) {
        case "m":
          e4 = oe2(this.m_view, n3, s4), t5 = t5 === b2.truncated_degrees ? b2.fractional_degree_minutes : t5, n3 = e4.newpos;
          continue;
        case "s":
          e4 = oe2(this.m_view, n3, s4), t5 = b2.fractional_minute_seconds, r3 = r3 < e4.rounding ? e4.rounding : r3, n3 = e4.newpos;
          continue;
        default:
          continue;
      }
    }
    this.m_dms = W.secondsToDMS(this.m_angle.extractAngularUnits(b2.seconds)), this.m_formatted_dms = W.secondsToDMS(this.m_angle.extractAngularUnits(b2.seconds)).format(t5, r3);
  }
};
function K(e4, t5, r3, n3, s4) {
  let a2 = null;
  switch (t5) {
    case b2.decimal_degrees:
    case b2.radians:
    case b2.gradians:
      return a2 = P5(x2(e4.extractAngularUnits(t5), n3), k3(t5)), q(a2.toFixed(n3), "0", r3 + n3 + (n3 > 0 ? 1 : 0));
    case b2.truncated_degrees:
    case b2.fractional_degree_minutes:
      return a2 = P5(s4.fetchFormattedDms().getField(t5), k3(t5)), q(a2.toFixed(n3), "0", r3 + n3 + (n3 > 0 ? 1 : 0));
    case b2.fractional_minute_seconds:
      return a2 = P5(x2(s4.fetchDms().getField(t5), n3), k3(t5)), q(a2.toFixed(n3), "0", r3 + n3 + (n3 > 0 ? 1 : 0));
    default:
      throw new Error("Unnexepected evaluation");
  }
}
function Y2(e4, t5, r3) {
  if (r3 === H2.quadrant)
    throw new Error("Conversion error");
  if (t5 === b2.degrees_minutes_seconds) {
    const t6 = W.numberToDms(e4);
    return B.createFromAngleAndDirection(V2.createFromDegreesMinutesSeconds(t6.m_degrees, t6.m_minutes, t6.m_seconds), r3);
  }
  return B.createFromAngleAndDirection(V2.createFromAngleAndUnits(e4, X2(t5)), r3);
}
function $2(e4) {
  switch (ne(e4)) {
    case 1:
      return { first: G2.north, second: G2.east };
    case 2:
      return { first: G2.south, second: G2.east };
    case 3:
      return { first: G2.south, second: G2.west };
    case 4:
      return { first: G2.north, second: G2.west };
  }
  return null;
}
function ee2(e4) {
  switch (e4.toUpperCase().trim()) {
    case "N":
    case "NORTH":
      return G2.north;
    case "E":
    case "EAST":
      return G2.east;
    case "S":
    case "SOUTH":
      return G2.south;
    case "W":
    case "WEST":
      return G2.west;
  }
  return null;
}
function te(e4) {
  const t5 = parseFloat(e4);
  if (O(t5)) {
    if (isNaN(t5))
      throw new Error("Invalid conversion");
    return t5;
  }
  throw new Error("Invalid conversion");
}
function re2(e4, r3, n3) {
  const s4 = n3 === H2.quadrant;
  let a2 = null, i5 = null, c3 = 0, o4 = 0, d7 = 0;
  if (s4) {
    if (e4.length < 2)
      throw new Error("Conversion Error");
    d7 = 1;
    const r4 = $2(X(e4[e4.length - 1]));
    if (r4 ? (a2 = r4.first, i5 = r4.second) : (c3 = 1, a2 = ee2(X(e4[0])), i5 = ee2(X(e4[e4.length - 1]))), null === a2 || null === i5)
      throw new Error("Invalid Conversion");
  }
  switch (r3) {
    case b2.decimal_degrees:
    case b2.radians:
    case b2.gradians:
      if (0 === e4.length)
        throw new Error("Invalid Conversion");
      return s4 ? B.createFromAngleMeridianAndDirection(V2.createFromAngleAndUnits(te(e4[c3]), X2(r3)), a2, i5) : B.createFromAngleAndDirection(V2.createFromAngleAndUnits(te(e4[c3]), X2(r3)), n3);
    case b2.degrees_minutes_seconds:
      if (o4 = e4.length - d7 - c3, 3 === o4) {
        const t5 = V2.createFromDegreesMinutesSeconds(te(e4[c3]), te(e4[c3 + 1]), te(e4[c3 + 2]));
        return s4 ? B.createFromAngleMeridianAndDirection(t5, a2, i5) : B.createFromAngleAndDirection(t5, n3);
      }
      if (1 === o4) {
        const t5 = te(e4[c3]), r4 = W.numberToDms(t5), o5 = V2.createFromDegreesMinutesSeconds(r4.m_degrees, r4.m_minutes, r4.m_seconds);
        return s4 ? B.createFromAngleMeridianAndDirection(o5, a2, i5) : B.createFromAngleAndDirection(o5, n3);
      }
  }
  throw new Error("Conversion Error");
}
function ne2(e4) {
  const t5 = [" ", "-", "/", "'", '"', "\\", "^", I3, F2, "	", "\r", "\n", "*"];
  let r3 = "";
  for (let n3 = 0; n3 < e4.length; n3++) {
    const s4 = e4.charAt(n3);
    t5.includes(s4) ? r3 += "RRSPLITRRSPLITRR" : r3 += s4;
  }
  return r3.split("RRSPLITRRSPLITRR").filter((e5) => "" !== e5);
}
function se2(e4, t5, c3) {
  if (O(e4))
    return Y2(ne(e4), t5, c3);
  if (w(e4))
    return re2(ne2(e4), t5, c3);
  if (L(e4))
    return re2(e4, t5, c3);
  if (E(e4))
    return re2(e4.toArray(), t5, c3);
  throw new Error("Conversion Error");
}
function ae(e4, t5, r3) {
  const n3 = X2(r3);
  if (n3 && r3 !== b2.degrees_minutes_seconds) {
    return e4.getAngle(t5).extractAngularUnits(n3);
  }
  throw new Error("Conversion Error");
}
function ie2(e4, t5, r3) {
  const n3 = e4.getAngle(t5);
  if (t5 === H2.quadrant && r3 === b2.degrees_minutes_seconds) {
    const r4 = W.secondsToDMS(n3.extractAngularUnits(b2.seconds));
    return [y3(e4.getMeridian(t5), "SHORT"), r4.m_degrees, r4.m_minutes, r4.m_seconds, y3(e4.getDirection(t5), "SHORT")];
  }
  if (r3 === b2.degrees_minutes_seconds) {
    const e5 = W.secondsToDMS(n3.extractAngularUnits(b2.seconds));
    return [e5.m_degrees, e5.m_minutes, e5.m_seconds];
  }
  return t5 === H2.quadrant ? [y3(e4.getMeridian(t5), "SHORT"), n3.extractAngularUnits(r3), y3(e4.getDirection(t5), "SHORT")] : [n3.extractAngularUnits(r3)];
}
function ce(e4, t5) {
  let r3 = "";
  switch (e4) {
    case b2.decimal_degrees:
      r3 = t5 === H2.quadrant ? "DD.DD" + I3 : "DDD.DD" + I3;
      break;
    case b2.degrees_minutes_seconds:
      r3 = t5 === H2.quadrant ? "dd" + I3 + ` mm' ss"` : "ddd" + I3 + ` mm' ss.ss"`;
      break;
    case b2.radians:
      r3 = "R.RR";
      break;
    case b2.gradians:
      r3 = "GGG.GG" + F2;
      break;
    default:
      throw new Error("Conversion error");
  }
  return t5 === H2.quadrant && (r3 = "p " + r3 + " b"), r3;
}
function oe2(e4, t5, r3) {
  const n3 = { padding: 0, rounding: 0, newpos: t5 };
  let s4 = false;
  for (; t5 < e4.length; ) {
    const a2 = e4[t5];
    if (a2 === r3)
      s4 ? n3.rounding++ : n3.padding++, t5++;
    else {
      if ("." !== a2)
        break;
      s4 = true, t5++;
    }
  }
  return n3.newpos = t5 - 1, n3;
}
function de(e4, t5, r3) {
  const n3 = { escaped: "", newpos: t5 };
  for (t5++; t5 < e4.length; ) {
    const r4 = e4[t5];
    if (t5++, "]" === r4)
      break;
    n3.escaped += r4;
  }
  return n3.newpos = t5 - 1, n3;
}
function ue2(e4, t5, r3) {
  let n3 = "", s4 = null, a2 = null;
  const i5 = J2.createFromStringAndBearing(t5, e4, r3), c3 = { D: b2.decimal_degrees, d: b2.truncated_degrees, m: b2.fractional_degree_minutes, s: b2.fractional_minute_seconds, R: b2.radians, G: b2.gradians };
  for (let o4 = 0; o4 < t5.length; o4++) {
    const d7 = t5[o4];
    switch (d7) {
      case "[":
        s4 = de(t5, o4), n3 += s4.escaped, o4 = s4.newpos;
        continue;
      case "D":
      case "d":
      case "m":
      case "s":
      case "R":
      case "G":
        s4 = oe2(t5, o4, d7), a2 = e4.getAngle(r3), n3 += K(a2, c3[d7], s4.padding, s4.rounding, i5), o4 = s4.newpos;
        continue;
      case "P":
      case "p":
        n3 += y3(i5.fetchMeridian(), "p" === d7 ? "SHORT" : "LONG");
        continue;
      case "B":
      case "b":
        n3 += y3(i5.fetchDirection(), "b" === d7 ? "SHORT" : "LONG");
        continue;
      default:
        n3 += d7;
    }
  }
  return n3;
}
function me(r3, n3, s4) {
  if (!(n3 instanceof d2))
    throw new Error("Invalid Parameter");
  if (false === n3.hasField("directionType"))
    throw new Error("Invalid Parameter - Missing directionType");
  if (false === n3.hasField("angleType"))
    throw new Error("Invalid Parameter - Missing directionType");
  const a2 = L2(N5(n3.field("directiontype"))), i5 = se2(r3, Q2(N5(n3.field("angletype"))), a2);
  if (!(s4 instanceof d2))
    throw new Error("Invalid Parameter");
  if (false === s4.hasField("directionType"))
    throw new Error("Invalid Parameter - Missing directionType");
  if (false === s4.hasField("outputType"))
    throw new Error("Invalid Parameter - Missing directionType");
  const c3 = L2(N5(s4.field("directiontype"))), o4 = s4.hasField("angleType") ? Q2(N5(s4.field("angletype"))) : null, d7 = N5(s4.field("outputType")).toUpperCase().trim();
  if (!c3 || !d7)
    throw new Error("Conversion error");
  if (!(o4 || "TEXT" === d7 && s4.hasField("format")))
    throw new Error("Invalid unit");
  switch (d7) {
    case "VALUE":
      return c3 === H2.quadrant || o4 === b2.degrees_minutes_seconds ? ie2(i5, c3, o4) : ae(i5, c3, o4);
    case "TEXT": {
      let e4 = "";
      return s4.hasField("format") && (e4 = X(s4.field("format"))), null !== e4 && "" !== e4 || (e4 = ce(o4, c3)), ue2(i5, e4, c3);
    }
    default:
      throw new Error("Invalid Parameter");
  }
}

// node_modules/@arcgis/core/arcade/functions/hash.js
var t4 = 2654435761;
var s3 = 2246822519;
var n2 = 3266489917;
var e3 = 668265263;
var r2 = 374761393;
function h3(t5) {
  const s4 = [];
  for (let n3 = 0, e4 = t5.length; n3 < e4; n3++) {
    let e5 = t5.charCodeAt(n3);
    e5 < 128 ? s4.push(e5) : e5 < 2048 ? s4.push(192 | e5 >> 6, 128 | 63 & e5) : e5 < 55296 || e5 >= 57344 ? s4.push(224 | e5 >> 12, 128 | e5 >> 6 & 63, 128 | 63 & e5) : (n3++, e5 = 65536 + ((1023 & e5) << 10 | 1023 & t5.charCodeAt(n3)), s4.push(240 | e5 >> 18, 128 | e5 >> 12 & 63, 128 | e5 >> 6 & 63, 128 | 63 & e5));
  }
  return new Uint8Array(s4);
}
var i4 = class {
  constructor(t5) {
    this.seed = t5, this.totallen = 0, this.bufs = [], this.init();
  }
  init() {
    return this.bufs = [], this.totallen = 0, this;
  }
  updateFloatArray(t5) {
    const s4 = [];
    for (const n3 of t5)
      isNaN(n3) ? s4.push("NaN") : n3 === 1 / 0 ? s4.push("Infinity") : n3 === -1 / 0 ? s4.push("-Infinity") : 0 === n3 ? s4.push("0") : s4.push(n3.toString(16));
    this.update(h3(s4.join("")));
  }
  updateIntArray(t5) {
    const s4 = Int32Array.from(t5);
    this.update(new Uint8Array(s4.buffer));
  }
  updateUint8Array(t5) {
    this.update(Uint8Array.from(t5));
  }
  updateWithString(t5) {
    return this.update(h3(t5));
  }
  update(t5) {
    return this.bufs.push(t5), this.totallen += t5.length, this;
  }
  digest() {
    const t5 = new Uint8Array(this.totallen);
    let s4 = 0;
    for (const n3 of this.bufs)
      t5.set(n3, s4), s4 += n3.length;
    return this.init(), this._xxHash32(t5, this.seed);
  }
  _xxHash32(h4, i5 = 0) {
    const o4 = h4;
    let u3 = i5 + r2 & 4294967295, a2 = 0;
    if (o4.length >= 16) {
      const n3 = [i5 + t4 + s3 & 4294967295, i5 + s3 & 4294967295, i5 + 0 & 4294967295, i5 - t4 & 4294967295], e4 = h4, r3 = e4.length - 16;
      let o5 = 0;
      for (a2 = 0; (4294967280 & a2) <= r3; a2 += 4) {
        const r4 = a2, h5 = e4[r4 + 0] + (e4[r4 + 1] << 8), i6 = e4[r4 + 2] + (e4[r4 + 3] << 8), u4 = h5 * s3 + (i6 * s3 << 16);
        let l7 = n3[o5] + u4 & 4294967295;
        l7 = l7 << 13 | l7 >>> 19;
        const f5 = 65535 & l7, p6 = l7 >>> 16;
        n3[o5] = f5 * t4 + (p6 * t4 << 16) & 4294967295, o5 = o5 + 1 & 3;
      }
      u3 = (n3[0] << 1 | n3[0] >>> 31) + (n3[1] << 7 | n3[1] >>> 25) + (n3[2] << 12 | n3[2] >>> 20) + (n3[3] << 18 | n3[3] >>> 14) & 4294967295;
    }
    u3 = u3 + h4.length & 4294967295;
    const l6 = h4.length - 4;
    for (; a2 <= l6; a2 += 4) {
      const t5 = a2, s4 = o4[t5 + 0] + (o4[t5 + 1] << 8), r3 = o4[t5 + 2] + (o4[t5 + 3] << 8);
      u3 = u3 + (s4 * n2 + (r3 * n2 << 16)) & 4294967295, u3 = u3 << 17 | u3 >>> 15, u3 = (65535 & u3) * e3 + ((u3 >>> 16) * e3 << 16) & 4294967295;
    }
    for (; a2 < o4.length; ++a2) {
      u3 += o4[a2] * r2, u3 = u3 << 11 | u3 >>> 21, u3 = (65535 & u3) * t4 + ((u3 >>> 16) * t4 << 16) & 4294967295;
    }
    return u3 ^= u3 >>> 15, u3 = ((65535 & u3) * s3 & 4294967295) + ((u3 >>> 16) * s3 << 16), u3 ^= u3 >>> 13, u3 = ((65535 & u3) * n2 & 4294967295) + ((u3 >>> 16) * n2 << 16), u3 ^= u3 >>> 16, u3 < 0 ? u3 + 4294967296 : u3;
  }
};

// node_modules/@arcgis/core/arcade/functions/string.js
function H3(t5, r3) {
  if (t5.x === r3.x && t5.y === r3.y) {
    if (t5.hasZ) {
      if (t5.z !== r3.z)
        return false;
    } else if (r3.hasZ)
      return false;
    if (t5.hasM) {
      if (t5.m !== r3.m)
        return false;
    } else if (r3.hasM)
      return false;
    return true;
  }
  return false;
}
function S3(e4, o4, a2) {
  if (null !== e4)
    if (L(e4)) {
      if (o4.updateUint8Array([61]), a2.map.has(e4)) {
        const t5 = a2.map.get(e4);
        o4.updateIntArray([61237541 ^ t5]);
      } else {
        a2.map.set(e4, a2.currentLength++);
        for (const t5 of e4)
          S3(t5, o4, a2);
        a2.map.delete(e4), a2.currentLength--;
      }
      o4.updateUint8Array([199]);
    } else if (E(e4)) {
      if (o4.updateUint8Array([61]), a2.map.has(e4)) {
        const t5 = a2.map.get(e4);
        o4.updateIntArray([61237541 ^ t5]);
      } else {
        a2.map.set(e4, a2.currentLength++);
        for (const t5 of e4.toArray())
          S3(t5, o4, a2);
        a2.map.delete(e4), a2.currentLength--;
      }
      o4.updateUint8Array([199]);
    } else {
      if (z(e4))
        return o4.updateIntArray([e4.getTime()]), void o4.updateUint8Array([241]);
      if (w(e4))
        return o4.updateIntArray([e4.length]), o4.updateWithString(e4), void o4.updateUint8Array([41]);
      if (_(e4))
        o4.updateUint8Array([true === e4 ? 1 : 0, 113]);
      else {
        if (O(e4))
          return o4.updateFloatArray([e4]), void o4.updateUint8Array([173]);
        if (e4 instanceof e)
          throw new Error("Type not supported in Hash");
        if (e4 instanceof s)
          throw new Error("Type not supported in Hash");
        if (!(e4 instanceof d2)) {
          if (Y(e4))
            throw new Error("Type not supported in Hash");
          if (e4 instanceof j)
            return o4.updateIntArray([3833836621]), o4.updateIntArray([0]), o4.updateFloatArray([e4.x]), o4.updateIntArray([1]), o4.updateFloatArray([e4.y]), e4.hasZ && (o4.updateIntArray([2]), o4.updateFloatArray([e4.z])), e4.hasM && (o4.updateIntArray([3]), o4.updateFloatArray([e4.m])), o4.updateIntArray([3765347959]), void S3(e4.spatialReference.wkid, o4, a2);
          if (e4 instanceof v) {
            o4.updateIntArray([1266616829]);
            for (let t5 = 0; t5 < e4.rings.length; t5++) {
              const r3 = e4.rings[t5], n3 = [];
              let i5 = null, u3 = null;
              for (let o5 = 0; o5 < r3.length; o5++) {
                const a3 = e4.getPoint(t5, o5);
                if (0 === o5)
                  i5 = a3;
                else if (H3(u3, a3))
                  continue;
                u3 = a3, o5 === r3.length - 1 && H3(i5, a3) || n3.push(a3);
              }
              o4.updateIntArray([1397116793, n3.length]);
              for (let t6 = 0; t6 < n3.length; t6++) {
                const r4 = n3[t6];
                o4.updateIntArray([3962308117, t6]), S3(r4, o4, a2), o4.updateIntArray([2716288009]);
              }
              o4.updateIntArray([2278822459]);
            }
            return o4.updateIntArray([3878477243]), void S3(e4.spatialReference.wkid, o4, a2);
          }
          if (e4 instanceof m2) {
            o4.updateIntArray([4106883559]);
            for (let t5 = 0; t5 < e4.paths.length; t5++) {
              const r3 = e4.paths[t5];
              o4.updateIntArray([1397116793, r3.length]);
              for (let n3 = 0; n3 < r3.length; n3++)
                o4.updateIntArray([3962308117, n3]), S3(e4.getPoint(t5, n3), o4, a2), o4.updateIntArray([2716288009]);
              o4.updateIntArray([2278822459]);
            }
            return o4.updateIntArray([2568784753]), void S3(e4.spatialReference.wkid, o4, a2);
          }
          if (e4 instanceof m) {
            o4.updateIntArray([588535921, e4.points.length]);
            for (let t5 = 0; t5 < e4.points.length; t5++) {
              const r3 = e4.getPoint(t5);
              o4.updateIntArray([t5]), S3(r3, o4, a2);
            }
            return o4.updateIntArray([1700171621]), void S3(e4.spatialReference.wkid, o4, a2);
          }
          if (e4 instanceof M)
            return o4.updateIntArray([3483648373]), o4.updateIntArray([0]), o4.updateFloatArray([e4.xmax]), o4.updateIntArray([1]), o4.updateFloatArray([e4.xmin]), o4.updateIntArray([2]), o4.updateFloatArray([e4.ymax]), o4.updateIntArray([3]), o4.updateFloatArray([e4.ymin]), e4.hasZ && (o4.updateIntArray([4]), o4.updateFloatArray([e4.zmax]), o4.updateIntArray([5]), o4.updateFloatArray([e4.zmin])), e4.hasM && (o4.updateIntArray([6]), o4.updateFloatArray([e4.mmax]), o4.updateIntArray([7]), o4.updateFloatArray([e4.mmin])), o4.updateIntArray([3622027469]), void S3(e4.spatialReference.wkid, o4, a2);
          if (e4 instanceof k2)
            return o4.updateIntArray([14]), void 0 !== e4.wkid && null !== e4.wkid && o4.updateIntArray([e4.wkid]), void (e4.wkt && o4.updateWithString(e4.wkt));
          if (v2(e4))
            throw new Error("Type not supported in Hash");
          if (J(e4))
            throw new Error("Type not supported in Hash");
          if (P2(e4))
            throw new Error("Type not supported in Hash");
          if (e4 === j2)
            throw new Error("Type not supported in Hash");
          throw new Error("Type not supported in Hash");
        }
        if (o4.updateUint8Array([223]), a2.map.has(e4)) {
          const t5 = a2.map.get(e4);
          o4.updateIntArray([61237541 ^ t5]);
        } else {
          a2.map.set(e4, a2.currentLength++);
          for (const t5 of e4.keys()) {
            o4.updateIntArray([t5.length]), o4.updateWithString(t5), o4.updateUint8Array([251]);
            S3(e4.field(t5), o4, a2), o4.updateUint8Array([239]);
          }
          a2.map.delete(e4), a2.currentLength--;
        }
        o4.updateUint8Array([73]);
      }
    }
  else
    o4.updateUint8Array([0, 139]);
}
function O4(r3, v4) {
  r3.portal = function(r4, n3) {
    return v4(r4, n3, function(r5, n4, a2) {
      return G(a2, 1, 1), new s(X(a2[0]));
    });
  }, r3.trim = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      return G(n3, 1, 1), X(n3[0]).trim();
    });
  }, r3.tohex = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 1, 1);
      const o4 = ne(n3[0]);
      return isNaN(o4) ? o4 : o4.toString(16);
    });
  }, r3.upper = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      return G(n3, 1, 1), X(n3[0]).toUpperCase();
    });
  }, r3.proper = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 1, 2);
      let a2 = 1;
      2 === n3.length && "firstword" === X(n3[1]).toLowerCase() && (a2 = 2);
      const i5 = /\s/, u3 = X(n3[0]);
      let s4 = "", f5 = true;
      for (let e4 = 0; e4 < u3.length; e4++) {
        let t7 = u3[e4];
        if (i5.test(t7))
          1 === a2 && (f5 = true);
        else {
          t7.toUpperCase() !== t7.toLowerCase() && (f5 ? (t7 = t7.toUpperCase(), f5 = false) : t7 = t7.toLowerCase());
        }
        s4 += t7;
      }
      return s4;
    });
  }, r3.lower = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      return G(n3, 1, 1), X(n3[0]).toLowerCase();
    });
  }, r3.guid = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (G(n3, 0, 1), n3.length > 0)
        switch (X(n3[0]).toLowerCase()) {
          case "digits":
            return H().replace("-", "").replace("-", "").replace("-", "").replace("-", "");
          case "digits-hyphen":
            return H();
          case "digits-hyphen-braces":
            return "{" + H() + "}";
          case "digits-hyphen-parentheses":
            return "(" + H() + ")";
        }
      return "{" + H() + "}";
    });
  }, r3.console = function(t5, r4) {
    return v4(t5, r4, function(r5, n3, e4) {
      return 0 === e4.length || (1 === e4.length ? t5.console(X(e4[0])) : t5.console(X(e4))), j2;
    });
  }, r3.mid = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 2, 3);
      let i5 = ne(n3[1]);
      if (isNaN(i5))
        return "";
      if (i5 < 0 && (i5 = 0), 2 === n3.length)
        return X(n3[0]).substr(i5);
      let u3 = ne(n3[2]);
      return isNaN(u3) ? "" : (u3 < 0 && (u3 = 0), X(n3[0]).substr(i5, u3));
    });
  }, r3.find = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 2, 3);
      let i5 = 0;
      if (n3.length > 2) {
        if (i5 = ne(I(n3[2], 0)), isNaN(i5))
          return -1;
        i5 < 0 && (i5 = 0);
      }
      return X(n3[1]).indexOf(X(n3[0]), i5);
    });
  }, r3.left = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 2, 2);
      let i5 = ne(n3[1]);
      return isNaN(i5) ? "" : (i5 < 0 && (i5 = 0), X(n3[0]).substr(0, i5));
    });
  }, r3.right = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 2, 2);
      let i5 = ne(n3[1]);
      return isNaN(i5) ? "" : (i5 < 0 && (i5 = 0), X(n3[0]).substr(-1 * i5, i5));
    });
  }, r3.split = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      let i5;
      G(n3, 2, 4);
      let u3 = ne(I(n3[2], -1));
      const c3 = oe(I(n3[3], false));
      if (-1 === u3 || null === u3 || true === c3 ? i5 = X(n3[0]).split(X(n3[1])) : (isNaN(u3) && (u3 = -1), u3 < -1 && (u3 = -1), i5 = X(n3[0]).split(X(n3[1]), u3)), false === c3)
        return i5;
      const l6 = [];
      for (let e4 = 0; e4 < i5.length && !(-1 !== u3 && l6.length >= u3); e4++)
        "" !== i5[e4] && void 0 !== i5[e4] && l6.push(i5[e4]);
      return l6;
    });
  }, r3.text = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      return G(n3, 1, 2), ee(n3[0], n3[1]);
    });
  }, r3.concatenate = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      const e4 = [];
      if (n3.length < 1)
        return "";
      if (L(n3[0])) {
        const t7 = I(n3[2], "");
        for (let r6 = 0; r6 < n3[0].length; r6++)
          e4[r6] = ee(n3[0][r6], t7);
        return n3.length > 1 ? e4.join(n3[1]) : e4.join("");
      }
      if (E(n3[0])) {
        const t7 = I(n3[2], "");
        for (let r6 = 0; r6 < n3[0].length(); r6++)
          e4[r6] = ee(n3[0].get(r6), t7);
        return n3.length > 1 ? e4.join(n3[1]) : e4.join("");
      }
      for (let o4 = 0; o4 < n3.length; o4++)
        e4[o4] = ee(n3[o4]);
      return e4.join("");
    });
  }, r3.reverse = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (G(n3, 1, 1), L(n3[0])) {
        const t7 = n3[0].slice(0);
        return t7.reverse(), t7;
      }
      if (E(n3[0])) {
        const t7 = n3[0].toArray().slice(0);
        return t7.reverse(), t7;
      }
      throw new Error("Invalid Parameter");
    });
  }, r3.replace = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 3, 4);
      const a2 = X(n3[0]), i5 = X(n3[1]), u3 = X(n3[2]);
      return 4 !== n3.length || oe(n3[3]) ? F(a2, i5, u3) : a2.replace(i5, u3);
    });
  }, r3.schema = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, e4) {
      if (Y(e4[0])) {
        const t7 = ve(e4[0]);
        return t7 ? d2.convertObjectToArcadeDictionary(t7) : null;
      }
      throw new Error("Invalid Parameter");
    });
  }, r3.subtypes = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, o4) {
      if (G(o4, 1, 1), Y(o4[0])) {
        const t7 = Ae(o4[0]);
        return t7 ? d2.convertObjectToArcadeDictionary(t7) : null;
      }
      throw new Error("Invalid Parameter");
    });
  }, r3.subtypecode = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (G(n3, 1, 1), Y(n3[0])) {
        const t7 = Ae(n3[0]);
        if (!t7)
          return null;
        if (t7.subtypeField && n3[0].hasField(t7.subtypeField)) {
          const r6 = n3[0].field(t7.subtypeField);
          for (const n4 of t7.subtypes)
            if (n4.code === r6)
              return n4.code;
          return null;
        }
        return null;
      }
      throw new Error("Invalid Parameter");
    });
  }, r3.subtypename = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (G(n3, 1, 1), Y(n3[0])) {
        const t7 = Ae(n3[0]);
        if (!t7)
          return "";
        if (t7.subtypeField && n3[0].hasField(t7.subtypeField)) {
          const r6 = n3[0].field(t7.subtypeField);
          for (const n4 of t7.subtypes)
            if (n4.code === r6)
              return n4.name;
          return "";
        }
        return "";
      }
      throw new Error("Invalid Parameter");
    });
  }, r3.gdbversion = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (G(n3, 1, 1), Y(n3[0]))
        return n3[0].gdbVersion();
      throw new Error("Invalid Parameter");
    });
  }, r3.domain = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, i5) {
      if (G(i5, 2, 3), Y(i5[0])) {
        const t7 = je(i5[0], X(i5[1]), void 0 === i5[2] ? void 0 : ne(i5[2]));
        return t7 && t7.domain ? "coded-value" === t7.domain.type || "codedValue" === t7.domain.type ? d2.convertObjectToArcadeDictionary({ type: "codedValue", name: t7.domain.name, dataType: P[t7.field.type], codedValues: t7.domain.codedValues.map((t8) => ({ name: t8.name, code: t8.code })) }) : d2.convertObjectToArcadeDictionary({ type: "range", name: t7.domain.name, dataType: P[t7.field.type], min: t7.domain.min, max: t7.domain.max }) : null;
      }
      throw new Error("Invalid Parameter");
    });
  }, r3.domainname = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (G(n3, 2, 4), Y(n3[0]))
        return Re(n3[0], X(n3[1]), n3[2], void 0 === n3[3] ? void 0 : ne(n3[3]));
      throw new Error("Invalid Parameter");
    });
  }, r3.domaincode = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (G(n3, 2, 4), Y(n3[0]))
        return Fe(n3[0], X(n3[1]), n3[2], void 0 === n3[3] ? void 0 : ne(n3[3]));
      throw new Error("Invalid Parameter");
    });
  }, r3.urlencode = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, a2) {
      if (G(a2, 1, 1), null === a2[0])
        return "";
      if (a2[0] instanceof d2) {
        let t7 = "";
        for (const r6 of a2[0].keys()) {
          const n3 = a2[0].field(r6);
          "" !== t7 && (t7 += "&"), t7 += null === n3 ? encodeURIComponent(r6) + "=" : encodeURIComponent(r6) + "=" + encodeURIComponent(n3);
        }
        return t7;
      }
      return encodeURIComponent(X(a2[0]));
    });
  }, r3.hash = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 1, 1);
      const o4 = new i4(0);
      return S3(n3[0], o4, { map: /* @__PURE__ */ new Map(), currentLength: 0 }), o4.digest();
    });
  }, r3.convertdirection = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      return G(n3, 3, 3), me(n3[0], n3[1], n3[2]);
    });
  }, r3.fromjson = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, a2) {
      if (G(a2, 1, 1), false === w(a2[0]))
        throw new Error("Invalid Parameter");
      return d2.convertJsonToArcade(JSON.parse(X(a2[0])));
    });
  }, r3.expects = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (n3.length < 1)
        throw new Error("Function called with wrong number of Parameters");
      return j2;
    });
  }, r3.tocharcode = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 1, 2);
      const i5 = ne(I(n3[1], 0)), u3 = X(n3[0]);
      if (0 === u3.length && 1 === n3.length)
        return null;
      if (u3.length <= i5 || i5 < 0)
        throw new Error("Illegal argument");
      return u3.charCodeAt(i5);
    });
  }, r3.tocodepoint = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      G(n3, 1, 2);
      const i5 = ne(I(n3[1], 0)), u3 = X(n3[0]);
      if (0 === u3.length && 1 === n3.length)
        return null;
      if (u3.length <= i5 || i5 < 0)
        throw new Error("Illegal argument");
      return u3.codePointAt(i5);
    });
  }, r3.fromcharcode = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (n3.length < 1)
        throw new Error("Function called with wrong number of Parameters");
      const e4 = n3.map((t7) => Math.trunc(ne(t7))).filter((t7) => t7 >= 0 && t7 <= 65535);
      return 0 === e4.length ? null : String.fromCharCode.apply(null, e4);
    });
  }, r3.fromcodepoint = function(t5, r4) {
    return v4(t5, r4, function(t6, r5, n3) {
      if (n3.length < 1)
        throw new Error("Function called with wrong number of Parameters");
      let e4;
      try {
        e4 = n3.map((t7) => Math.trunc(ne(t7))).filter((t7) => t7 <= 1114111 && t7 >>> 0 === t7);
      } catch (o4) {
        return null;
      }
      return 0 === e4.length ? null : String.fromCodePoint.apply(null, e4);
    });
  };
}

export {
  r,
  p4 as p,
  u,
  f2 as f,
  d5 as d,
  S,
  E2 as E,
  b,
  A,
  I2 as I,
  h,
  m4 as m,
  y2 as y,
  P4 as P,
  N4 as N,
  o2 as o,
  O4 as O
};
//# sourceMappingURL=chunk-LKISLLXN.js.map
