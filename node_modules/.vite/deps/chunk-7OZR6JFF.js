import {
  g,
  l,
  u as u2
} from "./chunk-EYJ2F5XB.js";
import {
  c,
  i,
  u,
  x
} from "./chunk-MQBVOUKB.js";
import {
  e as e2,
  r as r2
} from "./chunk-EEJIELE6.js";
import {
  c as c2
} from "./chunk-MDCKEJ7B.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  e
} from "./chunk-NAIF4GWX.js";
import {
  G
} from "./chunk-ASC3X65B.js";
import {
  A,
  p
} from "./chunk-PKZEO23A.js";
import {
  n as n2,
  r,
  t as t2
} from "./chunk-AIRC226G.js";
import {
  n4 as n
} from "./chunk-2QOWZFCU.js";
import {
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BoundingInfo.js
var a = class {
  constructor(i3, s, a2, c4) {
    this.primitiveIndices = i3, this._numIndexPerPrimitive = s, this.indices = a2, this.position = c4, this.center = n2(), e(i3.length >= 1), e(a2.length % this._numIndexPerPrimitive == 0), e(a2.length >= i3.length * this._numIndexPerPrimitive), e(3 === c4.size || 4 === c4.size);
    const { data: o, size: d3 } = c4, M = i3.length;
    let l4 = d3 * a2[this._numIndexPerPrimitive * i3[0]];
    b.clear(), b.push(l4), this.bbMin = r(o[l4], o[l4 + 1], o[l4 + 2]), this.bbMax = t2(this.bbMin);
    for (let t3 = 0; t3 < M; ++t3) {
      const s2 = this._numIndexPerPrimitive * i3[t3];
      for (let i4 = 0; i4 < this._numIndexPerPrimitive; ++i4) {
        l4 = d3 * a2[s2 + i4], b.push(l4);
        let t4 = o[l4];
        this.bbMin[0] = Math.min(t4, this.bbMin[0]), this.bbMax[0] = Math.max(t4, this.bbMax[0]), t4 = o[l4 + 1], this.bbMin[1] = Math.min(t4, this.bbMin[1]), this.bbMax[1] = Math.max(t4, this.bbMax[1]), t4 = o[l4 + 2], this.bbMin[2] = Math.min(t4, this.bbMin[2]), this.bbMax[2] = Math.max(t4, this.bbMax[2]);
      }
    }
    A(this.center, this.bbMin, this.bbMax, 0.5), this.radius = 0.5 * Math.max(Math.max(this.bbMax[0] - this.bbMin[0], this.bbMax[1] - this.bbMin[1]), this.bbMax[2] - this.bbMin[2]);
    let m = this.radius * this.radius;
    for (let t3 = 0; t3 < b.length; ++t3) {
      l4 = b.getItemAt(t3);
      const i4 = o[l4] - this.center[0], s2 = o[l4 + 1] - this.center[1], e3 = o[l4 + 2] - this.center[2], n3 = i4 * i4 + s2 * s2 + e3 * e3;
      if (n3 <= m)
        continue;
      const r3 = Math.sqrt(n3), h2 = 0.5 * (r3 - this.radius);
      this.radius = this.radius + h2, m = this.radius * this.radius;
      const a3 = h2 / r3;
      this.center[0] += i4 * a3, this.center[1] += s2 * a3, this.center[2] += e3 * a3;
    }
    b.clear();
  }
  getCenter() {
    return this.center;
  }
  getBSRadius() {
    return this.radius;
  }
  getBBMin() {
    return this.bbMin;
  }
  getBBMax() {
    return this.bbMax;
  }
  getChildren() {
    if (this._children)
      return this._children;
    if (p(this.bbMin, this.bbMax) > 1) {
      const i3 = A(n2(), this.bbMin, this.bbMax, 0.5), s = this.primitiveIndices.length, n3 = new Uint8Array(s), r3 = new Array(8);
      for (let t3 = 0; t3 < 8; ++t3)
        r3[t3] = 0;
      const { data: h2, size: b2 } = this.position;
      for (let t3 = 0; t3 < s; ++t3) {
        let s2 = 0;
        const e3 = this._numIndexPerPrimitive * this.primitiveIndices[t3];
        let a2 = b2 * this.indices[e3], c5 = h2[a2], o2 = h2[a2 + 1], d3 = h2[a2 + 2];
        for (let i4 = 1; i4 < this._numIndexPerPrimitive; ++i4) {
          a2 = b2 * this.indices[e3 + i4];
          const t4 = h2[a2], s3 = h2[a2 + 1], n4 = h2[a2 + 2];
          t4 < c5 && (c5 = t4), s3 < o2 && (o2 = s3), n4 < d3 && (d3 = n4);
        }
        c5 < i3[0] && (s2 |= 1), o2 < i3[1] && (s2 |= 2), d3 < i3[2] && (s2 |= 4), n3[t3] = s2, ++r3[s2];
      }
      let c4 = 0;
      for (let t3 = 0; t3 < 8; ++t3)
        r3[t3] > 0 && ++c4;
      if (c4 < 2)
        return;
      const o = new Array(8);
      for (let t3 = 0; t3 < 8; ++t3)
        o[t3] = r3[t3] > 0 ? new Uint32Array(r3[t3]) : void 0;
      for (let t3 = 0; t3 < 8; ++t3)
        r3[t3] = 0;
      for (let t3 = 0; t3 < s; ++t3) {
        const i4 = n3[t3];
        o[i4][r3[i4]++] = this.primitiveIndices[t3];
      }
      this._children = new Array(8);
      for (let t3 = 0; t3 < 8; ++t3)
        void 0 !== o[t3] && (this._children[t3] = new a(o[t3], this._numIndexPerPrimitive, this.indices, this.position));
    }
    return this._children;
  }
  static prune() {
    b.prune();
  }
};
var b = new n({ deallocator: null });

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Geometry.js
var g2 = class extends r2 {
  constructor(t3, i3 = [], n3 = c2.Triangle, o = -1) {
    super(), this._primitiveType = n3, this.edgeIndicesLength = o, this.type = e2.Geometry, this._vertexAttributes = /* @__PURE__ */ new Map(), this._indices = /* @__PURE__ */ new Map(), this._boundingInfo = null;
    for (const [e3, s] of t3)
      s && this._vertexAttributes.set(e3, { ...s });
    if (null == i3 || 0 === i3.length) {
      const t4 = d(this._vertexAttributes), e3 = l(t4);
      this.edgeIndicesLength = this.edgeIndicesLength < 0 ? t4 : this.edgeIndicesLength;
      for (const i4 of this._vertexAttributes.keys())
        this._indices.set(i4, e3);
    } else
      for (const [e3, s] of i3)
        s && (this._indices.set(e3, l2(s)), e3 === O.POSITION && (this.edgeIndicesLength = this.edgeIndicesLength < 0 ? this._indices.get(e3).length : this.edgeIndicesLength));
  }
  cloneShallow() {
    const t3 = new g2([], void 0, this._primitiveType, void 0), { _vertexAttributes: e3, _indices: i3 } = t3;
    return this._vertexAttributes.forEach((t4, i4) => {
      e3.set(i4, t4);
    }), this._indices.forEach((t4, e4) => {
      i3.set(e4, t4);
    }), t3.screenToWorldRatio = this.screenToWorldRatio, t3._boundingInfo = this._boundingInfo, t3;
  }
  get vertexAttributes() {
    return this._vertexAttributes;
  }
  getMutableAttribute(t3) {
    const e3 = this._vertexAttributes.get(t3);
    return e3 && !e3.exclusive && (e3.data = Array.from(e3.data), e3.exclusive = true), e3;
  }
  get indices() {
    return this._indices;
  }
  get indexCount() {
    const t3 = this._indices.values().next().value;
    return t3 ? t3.length : 0;
  }
  get primitiveType() {
    return this._primitiveType;
  }
  get faceCount() {
    return this.indexCount / 3;
  }
  get boundingInfo() {
    return t(this._boundingInfo) && (this._boundingInfo = this._calculateBoundingInfo()), this._boundingInfo;
  }
  computeAttachmentOrigin(t3) {
    return this.primitiveType === c2.Triangle ? this._computeAttachmentOriginTriangles(t3) : this._computeAttachmentOriginPoints(t3);
  }
  _computeAttachmentOriginTriangles(t3) {
    const e3 = this.indices.get(O.POSITION), i3 = this.vertexAttributes.get(O.POSITION);
    return u2(i3, e3, t3);
  }
  _computeAttachmentOriginPoints(t3) {
    const e3 = this.indices.get(O.POSITION), i3 = this.vertexAttributes.get(O.POSITION);
    return g(i3, e3, t3);
  }
  invalidateBoundingInfo() {
    this._boundingInfo = null;
  }
  _calculateBoundingInfo() {
    const t3 = this.indices.get(O.POSITION);
    if (0 === t3.length)
      return null;
    const n3 = this.primitiveType === c2.Triangle ? 3 : 1;
    e(t3.length % n3 == 0, "Indexing error: " + t3.length + " not divisible by " + n3);
    const s = l(t3.length / n3), o = this.vertexAttributes.get(O.POSITION);
    return new a(s, n3, t3, o);
  }
};
function d(t3) {
  const e3 = t3.values().next().value;
  return null == e3 ? 0 : e3.data.length / e3.size;
}
function l2(t3) {
  if (t3.BYTES_PER_ELEMENT === Uint16Array.BYTES_PER_ELEMENT)
    return t3;
  for (const e3 of t3)
    if (e3 >= 65536)
      return t3;
  return new Uint16Array(t3);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/bufferWriterUtils.js
function i2(t3, e3, f, o, r3 = 1) {
  const s = f.typedBuffer, n3 = f.typedBufferStride, i3 = t3.length;
  if (o *= n3, 1 === r3)
    for (let c4 = 0; c4 < i3; ++c4)
      s[o] = e3[t3[c4]], o += n3;
  else
    for (let c4 = 0; c4 < i3; ++c4) {
      const f2 = e3[t3[c4]];
      for (let t4 = 0; t4 < r3; t4++)
        s[o] = f2, o += n3;
    }
}
function c3(t3, e3, f, o) {
  const r3 = f.typedBuffer, s = f.typedBufferStride, n3 = t3.length;
  o *= s;
  for (let i3 = 0; i3 < n3; ++i3) {
    const f2 = 2 * t3[i3];
    r3[o] = e3[f2], r3[o + 1] = e3[f2 + 1], o += s;
  }
}
function l3(t3, e3, f, o, r3) {
  const s = f.typedBuffer, n3 = f.typedBufferStride, i3 = t3.length;
  if (o *= n3, null == r3 || 1 === r3)
    for (let c4 = 0; c4 < i3; ++c4) {
      const f2 = 3 * t3[c4];
      s[o] = e3[f2], s[o + 1] = e3[f2 + 1], s[o + 2] = e3[f2 + 2], o += n3;
    }
  else
    for (let c4 = 0; c4 < i3; ++c4) {
      const f2 = 3 * t3[c4];
      for (let t4 = 0; t4 < r3; ++t4)
        s[o] = e3[f2], s[o + 1] = e3[f2 + 1], s[o + 2] = e3[f2 + 2], o += n3;
    }
}
function d2(t3, e3, f, o, r3 = 1) {
  const s = f.typedBuffer, n3 = f.typedBufferStride, i3 = t3.length;
  if (o *= n3, 1 === r3)
    for (let c4 = 0; c4 < i3; ++c4) {
      const f2 = 4 * t3[c4];
      s[o] = e3[f2], s[o + 1] = e3[f2 + 1], s[o + 2] = e3[f2 + 2], s[o + 3] = e3[f2 + 3], o += n3;
    }
  else
    for (let c4 = 0; c4 < i3; ++c4) {
      const f2 = 4 * t3[c4];
      for (let t4 = 0; t4 < r3; ++t4)
        s[o] = e3[f2], s[o + 1] = e3[f2 + 1], s[o + 2] = e3[f2 + 2], s[o + 3] = e3[f2 + 3], o += n3;
    }
}
function p2(t3, e3, f, o, r3, s = 1) {
  if (!f)
    return void l3(t3, e3, o, r3, s);
  const n3 = o.typedBuffer, i3 = o.typedBufferStride, c4 = t3.length, d3 = f[0], u3 = f[1], a2 = f[2], p3 = f[4], B2 = f[5], y2 = f[6], g4 = f[8], h2 = f[9], S = f[10], b2 = f[12], m = f[13], z = f[14];
  if (r3 *= i3, 1 === s)
    for (let l4 = 0; l4 < c4; ++l4) {
      const f2 = 3 * t3[l4], o2 = e3[f2], s2 = e3[f2 + 1], c5 = e3[f2 + 2];
      n3[r3] = d3 * o2 + p3 * s2 + g4 * c5 + b2, n3[r3 + 1] = u3 * o2 + B2 * s2 + h2 * c5 + m, n3[r3 + 2] = a2 * o2 + y2 * s2 + S * c5 + z, r3 += i3;
    }
  else
    for (let l4 = 0; l4 < c4; ++l4) {
      const f2 = 3 * t3[l4], o2 = e3[f2], c5 = e3[f2 + 1], O2 = e3[f2 + 2], k = d3 * o2 + p3 * c5 + g4 * O2 + b2, F = u3 * o2 + B2 * c5 + h2 * O2 + m, M = a2 * o2 + y2 * c5 + S * O2 + z;
      for (let t4 = 0; t4 < s; ++t4)
        n3[r3] = k, n3[r3 + 1] = F, n3[r3 + 2] = M, r3 += i3;
    }
}
function B(e3, f, o, r3, s, n3 = 1) {
  if (!o)
    return void l3(e3, f, r3, s, n3);
  const i3 = o, c4 = r3.typedBuffer, d3 = r3.typedBufferStride, u3 = e3.length, a2 = i3[0], p3 = i3[1], B2 = i3[2], y2 = i3[4], g4 = i3[5], h2 = i3[6], S = i3[8], b2 = i3[9], m = i3[10], z = !G(i3), O2 = 1e-6, k = 1 - O2;
  if (s *= d3, 1 === n3)
    for (let t3 = 0; t3 < u3; ++t3) {
      const o2 = 3 * e3[t3], r4 = f[o2], n4 = f[o2 + 1], i4 = f[o2 + 2];
      let l4 = a2 * r4 + y2 * n4 + S * i4, u4 = p3 * r4 + g4 * n4 + b2 * i4, F = B2 * r4 + h2 * n4 + m * i4;
      if (z) {
        const t4 = l4 * l4 + u4 * u4 + F * F;
        if (t4 < k && t4 > O2) {
          const e4 = 1 / Math.sqrt(t4);
          l4 *= e4, u4 *= e4, F *= e4;
        }
      }
      c4[s + 0] = l4, c4[s + 1] = u4, c4[s + 2] = F, s += d3;
    }
  else
    for (let t3 = 0; t3 < u3; ++t3) {
      const o2 = 3 * e3[t3], r4 = f[o2], i4 = f[o2 + 1], l4 = f[o2 + 2];
      let u4 = a2 * r4 + y2 * i4 + S * l4, F = p3 * r4 + g4 * i4 + b2 * l4, M = B2 * r4 + h2 * i4 + m * l4;
      if (z) {
        const t4 = u4 * u4 + F * F + M * M;
        if (t4 < k && t4 > O2) {
          const e4 = 1 / Math.sqrt(t4);
          u4 *= e4, F *= e4, M *= e4;
        }
      }
      for (let t4 = 0; t4 < n3; ++t4)
        c4[s + 0] = u4, c4[s + 1] = F, c4[s + 2] = M, s += d3;
    }
}
function y(e3, f, o, r3, s, n3 = 1) {
  if (!o)
    return void d2(e3, f, r3, s, n3);
  const i3 = o, c4 = r3.typedBuffer, l4 = r3.typedBufferStride, u3 = e3.length, a2 = i3[0], p3 = i3[1], B2 = i3[2], y2 = i3[4], g4 = i3[5], h2 = i3[6], S = i3[8], b2 = i3[9], m = i3[10], z = !G(i3), O2 = 1e-6, k = 1 - O2;
  if (s *= l4, 1 === n3)
    for (let t3 = 0; t3 < u3; ++t3) {
      const o2 = 4 * e3[t3], r4 = f[o2], n4 = f[o2 + 1], i4 = f[o2 + 2], d3 = f[o2 + 3];
      let u4 = a2 * r4 + y2 * n4 + S * i4, F = p3 * r4 + g4 * n4 + b2 * i4, M = B2 * r4 + h2 * n4 + m * i4;
      if (z) {
        const t4 = u4 * u4 + F * F + M * M;
        if (t4 < k && t4 > O2) {
          const e4 = 1 / Math.sqrt(t4);
          u4 *= e4, F *= e4, M *= e4;
        }
      }
      c4[s + 0] = u4, c4[s + 1] = F, c4[s + 2] = M, c4[s + 3] = d3, s += l4;
    }
  else
    for (let t3 = 0; t3 < u3; ++t3) {
      const o2 = 4 * e3[t3], r4 = f[o2], i4 = f[o2 + 1], d3 = f[o2 + 2], u4 = f[o2 + 3];
      let F = a2 * r4 + y2 * i4 + S * d3, M = p3 * r4 + g4 * i4 + b2 * d3, N = B2 * r4 + h2 * i4 + m * d3;
      if (z) {
        const t4 = F * F + M * M + N * N;
        if (t4 < k && t4 > O2) {
          const e4 = 1 / Math.sqrt(t4);
          F *= e4, M *= e4, N *= e4;
        }
      }
      for (let t4 = 0; t4 < n3; ++t4)
        c4[s + 0] = F, c4[s + 1] = M, c4[s + 2] = N, c4[s + 3] = u4, s += l4;
    }
}
function g3(t3, e3, f, o, r3, s = 1) {
  const n3 = o.typedBuffer, i3 = o.typedBufferStride, c4 = t3.length;
  if (r3 *= i3, 1 === s) {
    if (4 === f)
      for (let l4 = 0; l4 < c4; ++l4) {
        const f2 = 4 * t3[l4];
        n3[r3] = e3[f2], n3[r3 + 1] = e3[f2 + 1], n3[r3 + 2] = e3[f2 + 2], n3[r3 + 3] = e3[f2 + 3], r3 += i3;
      }
    else if (3 === f)
      for (let l4 = 0; l4 < c4; ++l4) {
        const f2 = 3 * t3[l4];
        n3[r3] = e3[f2], n3[r3 + 1] = e3[f2 + 1], n3[r3 + 2] = e3[f2 + 2], n3[r3 + 3] = 255, r3 += i3;
      }
  } else if (4 === f)
    for (let l4 = 0; l4 < c4; ++l4) {
      const f2 = 4 * t3[l4];
      for (let t4 = 0; t4 < s; ++t4)
        n3[r3] = e3[f2], n3[r3 + 1] = e3[f2 + 1], n3[r3 + 2] = e3[f2 + 2], n3[r3 + 3] = e3[f2 + 3], r3 += i3;
    }
  else if (3 === f)
    for (let l4 = 0; l4 < c4; ++l4) {
      const f2 = 3 * t3[l4];
      for (let t4 = 0; t4 < s; ++t4)
        n3[r3] = e3[f2], n3[r3 + 1] = e3[f2 + 1], n3[r3 + 2] = e3[f2 + 2], n3[r3 + 3] = 255, r3 += i3;
    }
}
function h(t3, i3, l4, d3, u3, a2) {
  for (const h2 of i3.fieldNames) {
    const i4 = t3.vertexAttributes.get(h2), S = t3.indices.get(h2);
    if (i4 && S)
      switch (h2) {
        case O.POSITION: {
          e(3 === i4.size);
          const t4 = u3.getField(h2, i);
          t4 && p2(S, i4.data, l4, t4, a2);
          break;
        }
        case O.NORMAL: {
          e(3 === i4.size);
          const t4 = u3.getField(h2, i);
          t4 && B(S, i4.data, d3, t4, a2);
          break;
        }
        case O.UV0: {
          e(2 === i4.size);
          const t4 = u3.getField(h2, u);
          t4 && c3(S, i4.data, t4, a2);
          break;
        }
        case O.COLOR: {
          e(3 === i4.size || 4 === i4.size);
          const t4 = u3.getField(h2, x);
          t4 && g3(S, i4.data, i4.size, t4, a2);
          break;
        }
        case O.SYMBOLCOLOR: {
          e(3 === i4.size || 4 === i4.size);
          const t4 = u3.getField(h2, x);
          t4 && g3(S, i4.data, i4.size, t4, a2);
          break;
        }
        case O.TANGENT: {
          e(4 === i4.size);
          const t4 = u3.getField(h2, c);
          t4 && y(S, i4.data, d3, t4, a2);
          break;
        }
      }
  }
}

export {
  a,
  g2 as g,
  i2 as i,
  d2 as d,
  p2 as p,
  B,
  g3 as g2,
  h
};
//# sourceMappingURL=chunk-7OZR6JFF.js.map
