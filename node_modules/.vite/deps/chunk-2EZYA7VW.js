import {
  e,
  i,
  l as l2,
  n as n2
} from "./chunk-OEQ3EDRD.js";
import {
  n
} from "./chunk-P6G64ARX.js";
import {
  m
} from "./chunk-GD6ALUPQ.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import {
  l
} from "./chunk-FVPTCNCX.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/renderers/visualVariables/support/visualVariableUtils.js
var f = s.getLogger("esri.renderers.visualVariables.support.visualVariableUtils");
var p = new g();
var d = Math.PI;
var v = /^\s*(return\s+)?\$view\.scale\s*(;)?\s*$/i;
function b(a, r2, i2) {
  const s2 = "visualVariables" in a && a.visualVariables ? a.visualVariables.find((e2) => "color" === e2.type) : a;
  if (!s2)
    return;
  if ("esri.renderers.visualVariables.ColorVariable" !== s2.declaredClass)
    return void f.warn("The visualVariable should be an instance of esri.renderers.visualVariables.ColorVariable");
  const o = "number" == typeof r2, l3 = o ? null : r2, c = l3 && l3.attributes;
  let u = o ? r2 : null;
  const p2 = s2.field, { ipData: d2, hasExpression: v2 } = s2.cache;
  let b2 = s2.cache.compiledFunc;
  if (!p2 && !v2) {
    const e2 = s2.stops;
    return e2 && e2[0] && e2[0].color;
  }
  if ("number" != typeof u)
    if (v2) {
      if (t(i2) || t(i2.arcade))
        return void f.error("Use of arcade expressions requires an arcade context");
      const e2 = { viewingMode: i2.viewingMode, scale: i2.scale, spatialReference: i2.spatialReference }, a2 = i2.arcade.arcadeUtils, r3 = a2.getViewInfo(e2), t2 = a2.createExecContext(l3, r3);
      if (!b2) {
        const e3 = a2.createSyntaxTree(s2.valueExpression);
        b2 = a2.createFunction(e3), s2.cache.compiledFunc = b2;
      }
      u = a2.executeFunction(b2, t2);
    } else
      c && (u = c[p2]);
  const h2 = s2.normalizationField, m3 = c ? parseFloat(c[h2]) : void 0;
  if (null != u && (!h2 || o || !isNaN(m3) && 0 !== m3)) {
    isNaN(m3) || o || (u /= m3);
    const a2 = R(u, d2);
    if (a2) {
      const r3 = a2[0], n3 = a2[1], o2 = r3 === n3 ? s2.stops[r3].color : l.blendColors(s2.stops[r3].color, s2.stops[n3].color, a2[2], r(i2) ? i2.color : void 0);
      return new l(o2);
    }
  }
}
function h(e2, a, r2) {
  const i2 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => "opacity" === e3.type) : e2;
  if (!i2)
    return;
  if ("esri.renderers.visualVariables.OpacityVariable" !== i2.declaredClass)
    return void f.warn("The visualVariable should be an instance of esri.renderers.visualVariables.OpacityVariable");
  const t2 = "number" == typeof a, s2 = t2 ? null : a, o = s2 && s2.attributes;
  let l3 = t2 ? a : null;
  const c = i2.field, { ipData: u, hasExpression: p2 } = i2.cache;
  let d2 = i2.cache.compiledFunc;
  if (!c && !p2) {
    const e3 = i2.stops;
    return e3 && e3[0] && e3[0].opacity;
  }
  if ("number" != typeof l3)
    if (p2) {
      if (t(r2) || t(r2.arcade))
        return void f.error("Use of arcade expressions requires an arcade context");
      const e3 = { viewingMode: r2.viewingMode, scale: r2.scale, spatialReference: r2.spatialReference }, a2 = r2.arcade.arcadeUtils, t3 = a2.getViewInfo(e3), o2 = a2.createExecContext(s2, t3);
      if (!d2) {
        const e4 = a2.createSyntaxTree(i2.valueExpression);
        d2 = a2.createFunction(e4), i2.cache.compiledFunc = d2;
      }
      l3 = a2.executeFunction(d2, o2);
    } else
      o && (l3 = o[c]);
  const v2 = i2.normalizationField, b2 = o ? parseFloat(o[v2]) : void 0;
  if (null != l3 && (!v2 || t2 || !isNaN(b2) && 0 !== b2)) {
    isNaN(b2) || t2 || (l3 /= b2);
    const e3 = R(l3, u);
    if (e3) {
      const a2 = e3[0], r3 = e3[1];
      if (a2 === r3)
        return i2.stops[a2].opacity;
      {
        const n3 = i2.stops[a2].opacity;
        return n3 + (i2.stops[r3].opacity - n3) * e3[2];
      }
    }
  }
}
function m2(e2, a, r2) {
  const i2 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => "rotation" === e3.type) : e2;
  if (!i2)
    return;
  if ("esri.renderers.visualVariables.RotationVariable" !== i2.declaredClass)
    return void f.warn("The visualVariable should be an instance of esri.renderers.visualVariables.RotationVariable");
  const t2 = i2.axis || "heading", s2 = "heading" === t2 && "arithmetic" === i2.rotationType ? 90 : 0, o = "heading" === t2 && "arithmetic" === i2.rotationType ? -1 : 1, l3 = "number" == typeof a ? null : a, c = l3 && l3.attributes, u = i2.field, { hasExpression: p2 } = i2.cache;
  let d2 = i2.cache.compiledFunc, v2 = 0;
  if (!u && !p2)
    return v2;
  if (p2) {
    if (t(r2) || t(r2.arcade))
      return void f.error("Use of arcade expressions requires an arcade context");
    const e3 = { viewingMode: r2.viewingMode, scale: r2.scale, spatialReference: r2.spatialReference }, a2 = r2.arcade.arcadeUtils, t3 = a2.getViewInfo(e3), s3 = a2.createExecContext(l3, t3);
    if (!d2) {
      const e4 = a2.createSyntaxTree(i2.valueExpression);
      d2 = a2.createFunction(e4), i2.cache.compiledFunc = d2;
    }
    v2 = a2.executeFunction(d2, s3);
  } else
    c && (v2 = c[u] || 0);
  return v2 = "number" != typeof v2 || isNaN(v2) ? null : s2 + o * v2, v2;
}
function V(e2, a, r2) {
  const i2 = "number" == typeof a, s2 = i2 ? null : a, o = s2 && s2.attributes;
  let c = i2 ? a : null;
  const { isScaleDriven: p2 } = e2.cache;
  let d2 = e2.cache.compiledFunc;
  if (p2) {
    const a2 = r(r2) ? r2.scale : void 0, i3 = r(r2) ? r2.view : void 0;
    c = null == a2 || "3d" === i3 ? x(e2) : a2;
  } else if (!i2)
    switch (e2.inputValueType) {
      case n2.Expression: {
        if (t(r2) || t(r2.arcade))
          return void f.error("Use of arcade expressions requires an arcade context");
        const a2 = { viewingMode: r2.viewingMode, scale: r2.scale, spatialReference: r2.spatialReference }, i3 = r2.arcade.arcadeUtils, t2 = i3.getViewInfo(a2), o2 = i3.createExecContext(s2, t2);
        if (!d2) {
          const a3 = i3.createSyntaxTree(e2.valueExpression);
          d2 = i3.createFunction(a3), e2.cache.compiledFunc = d2;
        }
        c = i3.executeFunction(d2, o2);
        break;
      }
      case n2.Field:
        o && (c = o[e2.field]);
        break;
      case n2.Unknown:
        c = null;
    }
  if (!l2(c))
    return null;
  if (i2 || !e2.normalizationField)
    return c;
  const v2 = o ? parseFloat(o[e2.normalizationField]) : null;
  return l2(v2) && 0 !== v2 ? c / v2 : null;
}
function x(e2) {
  let a = null, r2 = null;
  const i2 = e2.stops;
  return i2 ? (a = i2[0].value, r2 = i2[i2.length - 1].value) : (a = e2.minDataValue || 0, r2 = e2.maxDataValue || 0), (a + r2) / 2;
}
function y(e2, a, r2) {
  const i2 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => "size" === e3.type) : e2;
  if (!i2)
    return;
  if ("esri.renderers.visualVariables.SizeVariable" !== i2.declaredClass)
    return void f.warn("The visualVariable should be an instance of esri.renderers.visualVariables.SizeVariable");
  const n3 = M(V(i2, a, r2), i2, a, r2, i2.cache.ipData);
  return null == n3 || isNaN(n3) ? 0 : n3;
}
function w(e2, a, r2) {
  return null == e2 ? null : e(e2) ? y(e2, a, r2) : l2(e2) ? e2 : null;
}
function g2(e2, a, r2) {
  return l2(r2) && e2 > r2 ? r2 : l2(a) && e2 < a ? a : e2;
}
function z(e2, a, r2, i2) {
  return e2 + (w(a.minSize, r2, i2) || a.minDataValue);
}
function F(e2, a, r2) {
  const i2 = e2.stops;
  let n3 = i2 && i2.length && i2[0].size;
  return null == n3 && (n3 = e2.minSize), w(n3, a, r2);
}
function S(e2, a, r2, i2) {
  const n3 = (e2 - a.minDataValue) / (a.maxDataValue - a.minDataValue), s2 = w(a.minSize, r2, i2), o = w(a.maxSize, r2, i2), l3 = r(i2) ? i2.shape : void 0;
  if (e2 <= a.minDataValue)
    return s2;
  if (e2 >= a.maxDataValue)
    return o;
  if ("area" === a.scaleBy && l3) {
    const e3 = "circle" === l3, a2 = e3 ? d * (s2 / 2) ** 2 : s2 * s2, r3 = a2 + n3 * ((e3 ? d * (o / 2) ** 2 : o * o) - a2);
    return e3 ? 2 * Math.sqrt(r3 / d) : Math.sqrt(r3);
  }
  return s2 + n3 * (o - s2);
}
function E(e2, a, r2, i2) {
  const n3 = r(i2) ? i2.shape : void 0, s2 = e2 / a.minDataValue, o = w(a.minSize, r2, i2), l3 = w(a.maxSize, r2, i2);
  let c = null;
  return c = "circle" === n3 ? 2 * Math.sqrt(s2 * (o / 2) ** 2) : "square" === n3 || "diamond" === n3 || "image" === n3 ? Math.sqrt(s2 * o ** 2) : s2 * o, g2(c, o, l3);
}
function U(e2, a, r2, i2, n3) {
  const [t2, s2, o] = R(e2, n3);
  if (t2 === s2)
    return w(a.stops[t2].size, r2, i2);
  {
    const e3 = w(a.stops[t2].size, r2, i2);
    return e3 + (w(a.stops[s2].size, r2, i2) - e3) * o;
  }
}
function C(e2, a, r2, i2) {
  const n3 = (r(i2) && i2.resolution ? i2.resolution : 1) * m[a.valueUnit], o = w(a.minSize, r2, i2), l3 = w(a.maxSize, r2, i2), { valueRepresentation: c } = a;
  let u = null;
  return u = "area" === c ? 2 * Math.sqrt(e2 / d) / n3 : "radius" === c || "distance" === c ? 2 * e2 / n3 : e2 / n3, g2(u, o, l3);
}
function D(e2) {
  return e2;
}
function M(e2, a, r2, i2, n3) {
  switch (a.transformationType) {
    case i.Additive:
      return z(e2, a, r2, i2);
    case i.Constant:
      return F(a, r2, i2);
    case i.ClampedLinear:
      return S(e2, a, r2, i2);
    case i.Proportional:
      return E(e2, a, r2, i2);
    case i.Stops:
      return U(e2, a, r2, i2, n3);
    case i.RealWorldSize:
      return C(e2, a, r2, i2);
    case i.Identity:
      return D(e2);
    case i.Unknown:
      return null;
  }
}
function k(e2, a, r2) {
  const { isScaleDriven: i2 } = e2.cache;
  if (!(i2 && "3d" === r2 || a))
    return null;
  const n3 = { scale: a, view: r2 };
  let t2 = w(e2.minSize, p, n3), s2 = w(e2.maxSize, p, n3);
  if (null != t2 || null != s2) {
    if (t2 > s2) {
      const e3 = s2;
      s2 = t2, t2 = e3;
    }
    return { minSize: t2, maxSize: s2 };
  }
}
function N(e2, a, r2) {
  if (!e2.visualVariables)
    return;
  const i2 = [], n3 = [], t2 = [], s2 = [], o = [];
  for (const l3 of e2.visualVariables)
    switch (l3.type) {
      case "color":
        n3.push(l3);
        break;
      case "opacity":
        t2.push(l3);
        break;
      case "rotation":
        o.push(l3);
        break;
      case "size":
        s2.push(l3);
    }
  return n3.forEach((e3) => {
    const n4 = b(e3, a, r2);
    i2.push({ variable: e3, value: n4 });
  }), t2.forEach((e3) => {
    const n4 = h(e3, a, r2);
    i2.push({ variable: e3, value: n4 });
  }), o.forEach((e3) => {
    const n4 = m2(e3, a, r2);
    i2.push({ variable: e3, value: n4 });
  }), s2.forEach((e3) => {
    const n4 = y(e3, a, r2);
    i2.push({ variable: e3, value: n4 });
  }), i2.filter((e3) => null != e3.value);
}
function R(e2, a) {
  if (!a)
    return;
  let r2 = 0, i2 = a.length - 1;
  return a.some((a2, n3) => e2 < a2 ? (i2 = n3, true) : (r2 = n3, false)), [r2, i2, (e2 - a[r2]) / (a[i2] - a[r2])];
}
function T(e2, a, i2) {
  const n3 = ["proportional", "proportional", "proportional"];
  for (const t2 of e2) {
    const e3 = t2.useSymbolValue ? "symbol-value" : y(t2, a, i2);
    switch (t2.axis) {
      case "width":
        n3[0] = e3;
        break;
      case "depth":
        n3[1] = e3;
        break;
      case "height":
        n3[2] = e3;
        break;
      case "width-and-depth":
        n3[0] = e3, n3[1] = e3;
        break;
      case "all":
      case void 0:
      case null:
        n3[0] = e3, n3[1] = e3, n3[2] = e3;
        break;
      default:
        n(t2.axis);
    }
  }
  return n3;
}

export {
  v,
  b,
  h,
  m2 as m,
  y,
  w,
  M,
  k,
  N,
  T
};
//# sourceMappingURL=chunk-2EZYA7VW.js.map
