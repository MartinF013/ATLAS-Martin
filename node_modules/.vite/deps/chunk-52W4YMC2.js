import {
  g
} from "./chunk-7OZR6JFF.js";
import {
  l
} from "./chunk-EYJ2F5XB.js";
import {
  c
} from "./chunk-MDCKEJ7B.js";
import {
  n as n2,
  r as r2,
  t
} from "./chunk-MLAOYRDT.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  e as e2
} from "./chunk-NAIF4GWX.js";
import {
  _ as _2,
  p2 as p,
  q2
} from "./chunk-53KI6WDE.js";
import {
  j
} from "./chunk-W2HLA6I3.js";
import {
  L,
  P,
  _,
  e,
  o,
  q,
  r,
  u,
  z
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BufferVectorMath.js
var n3;
!function(n4) {
  function t2(n5, t3) {
    const c3 = n5[t3], o3 = n5[t3 + 1], r4 = n5[t3 + 2];
    return Math.sqrt(c3 * c3 + o3 * o3 + r4 * r4);
  }
  function c2(n5, t3) {
    const c3 = n5[t3], o3 = n5[t3 + 1], r4 = n5[t3 + 2], u3 = 1 / Math.sqrt(c3 * c3 + o3 * o3 + r4 * r4);
    n5[t3] *= u3, n5[t3 + 1] *= u3, n5[t3 + 2] *= u3;
  }
  function o2(n5, t3, c3) {
    n5[t3] *= c3, n5[t3 + 1] *= c3, n5[t3 + 2] *= c3;
  }
  function r3(n5, t3, c3, o3, r4, u3 = t3) {
    (r4 = r4 || n5)[u3] = n5[t3] + c3[o3], r4[u3 + 1] = n5[t3 + 1] + c3[o3 + 1], r4[u3 + 2] = n5[t3 + 2] + c3[o3 + 2];
  }
  function u2(n5, t3, c3, o3, r4, u3 = t3) {
    (r4 = r4 || n5)[u3] = n5[t3] - c3[o3], r4[u3 + 1] = n5[t3 + 1] - c3[o3 + 1], r4[u3 + 2] = n5[t3 + 2] - c3[o3 + 2];
  }
  n4.length = t2, n4.normalize = c2, n4.scale = o2, n4.add = r3, n4.subtract = u2;
}(n3 || (n3 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GeometryUtil.js
var P2 = n3;
var U;
var S;
var p2;
var x;
!function(t2) {
  const e3 = 0.5, n4 = [[-e3, -e3, e3], [e3, -e3, e3], [e3, e3, e3], [-e3, e3, e3], [-e3, -e3, -e3], [e3, -e3, -e3], [e3, e3, -e3], [-e3, e3, -e3]], r3 = [0, 0, 1, -1, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, -1], a = [0, 0, 1, 0, 1, 1, 0, 1], o2 = new Uint16Array([0, 1, 2, 2, 3, 0, 4, 0, 3, 3, 7, 4, 1, 5, 6, 6, 2, 1, 1, 0, 4, 4, 5, 1, 3, 2, 6, 6, 7, 3, 5, 4, 7, 7, 6, 5]), s = new Uint16Array(36);
  for (let c2 = 0; c2 < 6; c2++)
    for (let t3 = 0; t3 < 6; t3++)
      s[6 * c2 + t3] = c2;
  const l2 = new Uint16Array(36);
  for (let c2 = 0; c2 < 6; c2++)
    l2[6 * c2 + 0] = 0, l2[6 * c2 + 1] = 1, l2[6 * c2 + 2] = 2, l2[6 * c2 + 3] = 2, l2[6 * c2 + 4] = 3, l2[6 * c2 + 5] = 0;
  function i(t3) {
    Array.isArray(t3) || (t3 = [t3, t3, t3]);
    const e4 = new Array(24);
    for (let r4 = 0; r4 < 8; r4++)
      e4[3 * r4] = n4[r4][0] * t3[0], e4[3 * r4 + 1] = n4[r4][1] * t3[1], e4[3 * r4 + 2] = n4[r4][2] * t3[2];
    return new g([[O.POSITION, { size: 3, data: e4, exclusive: true }], [O.NORMAL, { size: 3, data: r3 }], [O.UV0, { size: 2, data: a }]], [[O.POSITION, o2], [O.NORMAL, s], [O.UV0, l2]]);
  }
  t2.createGeometry = i;
}(U || (U = {})), function(t2) {
  const e3 = 0.5, n4 = [[-e3, 0, -e3], [e3, 0, -e3], [e3, 0, e3], [-e3, 0, e3], [0, -e3, 0], [0, e3, 0]], r3 = [0, 1, -1, 1, 1, 0, 0, 1, 1, -1, 1, 0, 0, -1, -1, 1, -1, 0, 0, -1, 1, -1, -1, 0], a = new Uint16Array([5, 1, 0, 5, 2, 1, 5, 3, 2, 5, 0, 3, 4, 0, 1, 4, 1, 2, 4, 2, 3, 4, 3, 0]), o2 = new Uint16Array([0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7]);
  function s(t3) {
    Array.isArray(t3) || (t3 = [t3, t3, t3]);
    const e4 = new Array(18);
    for (let r4 = 0; r4 < 6; r4++)
      e4[3 * r4] = n4[r4][0] * t3[0], e4[3 * r4 + 1] = n4[r4][1] * t3[1], e4[3 * r4 + 2] = n4[r4][2] * t3[2];
    return new g([[O.POSITION, { size: 3, data: e4, exclusive: true }], [O.NORMAL, { size: 3, data: r3 }]], [[O.POSITION, a], [O.NORMAL, o2]]);
  }
  t2.createGeometry = s;
}(S || (S = {})), function(r3) {
  const a = 0.5, o2 = 0, s = r2(-a, o2, -a), l2 = r2(a, o2, -a), i = r2(0, o2, a), h = r2(0, o2 + a, 0), f = n2(), O2 = n2(), A = n2(), y = n2(), I = n2();
  e(f, s, h), e(O2, s, l2), _(A, f, O2), z(A, A), e(f, l2, h), e(O2, l2, i), _(y, f, O2), z(y, y), e(f, i, h), e(O2, i, s), _(I, f, O2), z(I, I);
  const g2 = [s, l2, i, h], M = [0, -1, 0, A[0], A[1], A[2], y[0], y[1], y[2], I[0], I[1], I[2]], d = [0, 1, 2, 3, 1, 0, 3, 2, 1, 3, 0, 2], w = [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];
  function P3(t2) {
    Array.isArray(t2) || (t2 = [t2, t2, t2]);
    const e3 = new Array(12);
    for (let n4 = 0; n4 < 4; n4++)
      e3[3 * n4] = g2[n4][0] * t2[0], e3[3 * n4 + 1] = g2[n4][1] * t2[1], e3[3 * n4 + 2] = g2[n4][2] * t2[2];
    return new g([[O.POSITION, { size: 3, data: e3, exclusive: true }], [O.NORMAL, { size: 3, data: M }]], [[O.POSITION, new Uint16Array(d)], [O.NORMAL, new Uint16Array(w)]]);
  }
  r3.createGeometry = P3;
}(p2 || (p2 = {})), function(M) {
  function x2(t2, e3, n4, r3 = { uv: true }) {
    const a = -Math.PI, o2 = 2 * Math.PI, s = -Math.PI / 2, l2 = Math.PI, i = Math.max(3, Math.floor(e3)), c2 = Math.max(2, Math.floor(n4)), u2 = (i + 1) * (c2 + 1), h = new Float32Array(3 * u2), f = new Float32Array(3 * u2), O2 = new Float32Array(2 * u2), A = [];
    let y = 0;
    for (let m = 0; m <= c2; m++) {
      const e4 = [], n5 = m / c2, r4 = s + n5 * l2, u3 = Math.cos(r4);
      for (let s2 = 0; s2 <= i; s2++) {
        const l3 = s2 / i, c3 = a + l3 * o2, A2 = Math.cos(c3) * u3, I2 = Math.sin(r4), g3 = -Math.sin(c3) * u3;
        h[3 * y] = A2 * t2, h[3 * y + 1] = I2 * t2, h[3 * y + 2] = g3 * t2, f[3 * y] = A2, f[3 * y + 1] = I2, f[3 * y + 2] = g3, O2[2 * y] = l3, O2[2 * y + 1] = n5, e4.push(y), ++y;
      }
      A.push(e4);
    }
    const I = new Uint32Array(2 * i * (c2 - 1) * 3);
    y = 0;
    for (let m = 0; m < c2; m++)
      for (let t3 = 0; t3 < i; t3++) {
        const e4 = A[m][t3], n5 = A[m][t3 + 1], r4 = A[m + 1][t3 + 1], a2 = A[m + 1][t3];
        0 === m ? (I[y++] = e4, I[y++] = r4, I[y++] = a2) : m === c2 - 1 ? (I[y++] = e4, I[y++] = n5, I[y++] = r4) : (I[y++] = e4, I[y++] = n5, I[y++] = r4, I[y++] = r4, I[y++] = a2, I[y++] = e4);
      }
    const g2 = [[O.POSITION, I], [O.NORMAL, I]], M2 = [[O.POSITION, { size: 3, data: h, exclusive: true }], [O.NORMAL, { size: 3, data: f, exclusive: true }]];
    return r3.uv && (M2.push([O.UV0, { size: 2, data: O2, exclusive: true }]), g2.push([O.UV0, I])), r3.offset && (g2[0][0] = O.OFFSET, M2[0][0] = O.OFFSET, g2.push([O.POSITION, new Uint32Array(I.length)]), M2.push([O.POSITION, { size: 3, data: Float64Array.from(r3.offset), exclusive: true }])), new g(M2, g2);
  }
  function T2(t2, e3, n4) {
    const r3 = t2;
    let a, o2;
    if (n4)
      a = [0, -1, 0, 1, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, -1, 0, 1, 0], o2 = new Uint32Array([0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 1, 1, 5, 2, 2, 5, 3, 3, 5, 4, 4, 5, 1]);
    else {
      const t3 = r3 * (1 + Math.sqrt(5)) / 2;
      a = [-r3, t3, 0, r3, t3, 0, -r3, -t3, 0, r3, -t3, 0, 0, -r3, t3, 0, r3, t3, 0, -r3, -t3, 0, r3, -t3, t3, 0, -r3, t3, 0, r3, -t3, 0, -r3, -t3, 0, r3], o2 = new Uint32Array([0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]);
    }
    for (let h = 0; h < a.length; h += 3)
      P2.scale(a, h, t2 / P2.length(a, h));
    let s = {};
    function l2(e4, n5) {
      e4 > n5 && ([e4, n5] = [n5, e4]);
      const r4 = e4.toString() + "." + n5.toString();
      if (s[r4])
        return s[r4];
      let o3 = a.length;
      return a.length += 3, P2.add(a, 3 * e4, a, 3 * n5, a, o3), P2.scale(a, o3, t2 / P2.length(a, o3)), o3 /= 3, s[r4] = o3, o3;
    }
    for (let h = 0; h < e3; h++) {
      const t3 = o2.length, e4 = new Uint32Array(4 * t3);
      for (let n5 = 0; n5 < t3; n5 += 3) {
        const t4 = o2[n5], r4 = o2[n5 + 1], a2 = o2[n5 + 2], s2 = l2(t4, r4), i2 = l2(r4, a2), c3 = l2(a2, t4), u3 = 4 * n5;
        e4[u3] = t4, e4[u3 + 1] = s2, e4[u3 + 2] = c3, e4[u3 + 3] = r4, e4[u3 + 4] = i2, e4[u3 + 5] = s2, e4[u3 + 6] = a2, e4[u3 + 7] = c3, e4[u3 + 8] = i2, e4[u3 + 9] = s2, e4[u3 + 10] = i2, e4[u3 + 11] = c3;
      }
      o2 = e4, s = {};
    }
    const i = new Float32Array(a);
    for (let h = 0; h < i.length; h += 3)
      P2.normalize(i, h);
    const c2 = [[O.POSITION, o2], [O.NORMAL, o2]], u2 = [[O.POSITION, { size: 3, data: new Float32Array(a), exclusive: true }], [O.NORMAL, { size: 3, data: i, exclusive: true }]];
    return new g(u2, c2);
  }
  function L2(t2, e3, n4, r3, a, o2, s) {
    const l2 = e3 ? [e3[0], e3[1], e3[2]] : [0, 0, 0], i = t2 ? [t2[0], t2[1], t2[2]] : [0, 0, 1];
    o2 = o2 || [0, 0];
    const c2 = n4 ? [255 * n4[0], 255 * n4[1], 255 * n4[2], n4.length > 3 ? 255 * n4[3] : 255] : [255, 255, 255, 255], u2 = null != r3 && 2 === r3.length ? r3 : [1, 1], h = [[O.POSITION, { size: 3, data: l2, exclusive: true }], [O.NORMAL, { size: 3, data: i, exclusive: true }], [O.UV0, { size: o2.length, data: o2 }], [O.COLOR, { size: 4, data: c2, exclusive: true }], [O.SIZE, { size: 2, data: u2 }]];
    if (null != a) {
      const t3 = new Float32Array([a[0], a[1], a[2], a[3]]);
      h.push([O.AUXPOS1, { size: 4, data: t3 }]);
    }
    if (null != s) {
      const t3 = new Float32Array([s[0], s[1], s[2], s[3]]);
      h.push([O.AUXPOS2, { size: 4, data: t3 }]);
    }
    return new g(h, null, c.Point);
  }
  function R(t2, e3, n4, r3, a, o2, s, l2) {
    if (null != t2) {
      const { data: e4 } = l2.getMutableAttribute(O.NORMAL);
      e4[0] = t2[0], e4[1] = t2[1], e4[2] = t2[2];
    }
    if (null != e3) {
      const { data: t3 } = l2.getMutableAttribute(O.POSITION);
      t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2];
    }
    if (null != n4) {
      const { data: t3 } = l2.getMutableAttribute(O.COLOR);
      t3[0] = n4[0], t3[1] = n4[1], t3[2] = n4[2], t3[3] = n4[3];
    }
    if (null != r3) {
      const { data: t3 } = l2.getMutableAttribute(O.SIZE);
      t3[0] = r3[0], t3[1] = r3[1];
    }
    if (null != a) {
      const { data: t3 } = l2.getMutableAttribute(O.AUXPOS1);
      t3[0] = a[0], t3[1] = a[1], t3[2] = a[2], t3[3] = a[3];
    }
    if (null != o2) {
      const { data: t3 } = l2.getMutableAttribute(O.UV0);
      t3[0] = o2[0], t3[1] = o2[1];
    }
    if (null != s) {
      const { data: t3 } = l2.getMutableAttribute(O.AUXPOS2);
      t3[0] = s[0], t3[1] = s[1], t3[2] = s[2], t3[3] = s[3];
    }
  }
  function b(t2, e3) {
    const n4 = new Float32Array(3 * t2.length), r3 = new Float32Array(e3 ? 3 * t2.length : 3), a = new Uint32Array(t2.length), o2 = new Uint32Array(t2.length);
    for (let c2 = 0; c2 < t2.length; c2++)
      n4[3 * c2] = t2[c2][0], n4[3 * c2 + 1] = t2[c2][1], n4[3 * c2 + 2] = t2[c2][2], e3 && (r3[3 * c2] = e3[c2][0], r3[3 * c2 + 1] = e3[c2][1], r3[3 * c2 + 2] = e3[c2][2]), a[c2] = c2, o2[c2] = 0;
    e3 || (r3[0] = 0, r3[1] = 1, r3[2] = 0);
    const s = [0, 0], l2 = [[O.POSITION, a], [O.NORMAL, e3 ? a : o2], [O.UV0, o2]], i = [[O.POSITION, { size: 3, data: n4, exclusive: true }], [O.NORMAL, { size: 3, data: r3, exclusive: true }], [O.UV0, { size: 2, data: s, exclusive: true }]];
    return new g(i, l2, c.Point);
  }
  function G() {
    const t2 = [0, 0, 0, 0, 0, 100, 100, 0, 0], e3 = new Uint16Array([0, 1, 2]), n4 = [0, 1, 0], r3 = new Uint16Array([0, 0, 0]), a = [0, 0], o2 = new Uint16Array([0, 0, 0]), s = [[O.POSITION, e3], [O.NORMAL, r3], [O.UV0, o2]], l2 = [[O.POSITION, { size: 3, data: t2, exclusive: true }], [O.NORMAL, { size: 3, data: n4, exclusive: true }], [O.UV0, { size: 2, data: a, exclusive: true }]];
    return new g(l2, s);
  }
  M.createBoxGeometry = U.createGeometry, M.createDiamondGeometry = S.createGeometry, M.createTetrahedronGeometry = p2.createGeometry, M.createSphereGeometry = x2, M.createPolySphereGeometry = T2, M.createPointGeometry = L2, M.updatePointGeometry = R, M.createPointArrayGeometry = b, M.createTriangleGeometry = G;
  const F = [[-1, -1, 0], [1, -1, 0], [1, 1, 0], [-1, 1, 0]];
  function V(t2 = F) {
    const e3 = new Array(12);
    for (let c2 = 0; c2 < 4; c2++)
      for (let n5 = 0; n5 < 3; n5++)
        e3[3 * c2 + n5] = t2[c2][n5];
    const n4 = new Uint32Array([0, 1, 2, 2, 3, 0]), r3 = [0, 0, 1], a = new Uint32Array([0, 0, 0, 0, 0, 0]), o2 = [0, 0, 1, 0, 1, 1, 0, 1], s = [255, 255, 255, 255], l2 = [[O.POSITION, n4], [O.NORMAL, a], [O.UV0, n4], [O.COLOR, a]], i = [[O.POSITION, { size: 3, data: e3, exclusive: true }], [O.NORMAL, { size: 3, data: r3, exclusive: true }], [O.UV0, { size: 2, data: o2, exclusive: true }], [O.COLOR, { size: 4, data: s, exclusive: true }]];
    return new g(i, l2);
  }
  function j2(t2, e3, n4, r3, a = true, o2 = true) {
    let s = 0;
    const l2 = e3, i = t2;
    let u2 = r2(0, s, 0), h = r2(0, s + i, 0), f = r2(0, -1, 0), O2 = r2(0, 1, 0);
    r3 && (s = i, h = r2(0, 0, 0), u2 = r2(0, s, 0), f = r2(0, 1, 0), O2 = r2(0, -1, 0));
    const A = [h, u2], y = [f, O2], I = n4 + 2, g2 = Math.sqrt(i * i + l2 * l2);
    if (r3)
      for (let m = n4 - 1; m >= 0; m--) {
        const t3 = m * (2 * Math.PI / n4), e4 = r2(Math.cos(t3) * l2, s, Math.sin(t3) * l2);
        A.push(e4);
        const r4 = r2(i * Math.cos(t3) / g2, -l2 / g2, i * Math.sin(t3) / g2);
        y.push(r4);
      }
    else
      for (let m = 0; m < n4; m++) {
        const t3 = m * (2 * Math.PI / n4), e4 = r2(Math.cos(t3) * l2, s, Math.sin(t3) * l2);
        A.push(e4);
        const r4 = r2(i * Math.cos(t3) / g2, l2 / g2, i * Math.sin(t3) / g2);
        y.push(r4);
      }
    const M2 = new Uint32Array(2 * (n4 + 2) * 3), d = new Uint32Array(2 * (n4 + 2) * 3);
    let w = 0, P3 = 0;
    if (a) {
      for (let t3 = 3; t3 < A.length; t3++)
        M2[w++] = 1, M2[w++] = t3 - 1, M2[w++] = t3, d[P3++] = 0, d[P3++] = 0, d[P3++] = 0;
      M2[w++] = A.length - 1, M2[w++] = 2, M2[w++] = 1, d[P3++] = 0, d[P3++] = 0, d[P3++] = 0;
    }
    if (o2) {
      for (let t3 = 3; t3 < A.length; t3++)
        M2[w++] = t3, M2[w++] = t3 - 1, M2[w++] = 0, d[P3++] = t3, d[P3++] = t3 - 1, d[P3++] = 1;
      M2[w++] = 0, M2[w++] = 2, M2[w++] = A.length - 1, d[P3++] = 1, d[P3++] = 2, d[P3++] = y.length - 1;
    }
    const U2 = new Float32Array(3 * I);
    for (let c2 = 0; c2 < I; c2++)
      U2[3 * c2] = A[c2][0], U2[3 * c2 + 1] = A[c2][1], U2[3 * c2 + 2] = A[c2][2];
    const S2 = new Float32Array(3 * I);
    for (let c2 = 0; c2 < I; c2++)
      S2[3 * c2] = y[c2][0], S2[3 * c2 + 1] = y[c2][1], S2[3 * c2 + 2] = y[c2][2];
    const p3 = [[O.POSITION, M2], [O.NORMAL, d]], x3 = [[O.POSITION, { size: 3, data: U2, exclusive: true }], [O.NORMAL, { size: 3, data: S2, exclusive: true }]];
    return new g(x3, p3);
  }
  function C(t2, l2, i, f, O2, A) {
    const y = f ? t(f) : r2(1, 0, 0), I = O2 ? t(O2) : r2(0, 0, 0);
    A = null == A || A;
    const g2 = n2();
    z(g2, y);
    const M2 = n2();
    q(M2, g2, Math.abs(t2));
    const d = n2();
    q(d, M2, -0.5), u(d, d, I);
    const w = r2(0, 1, 0);
    Math.abs(1 - P(g2, w)) < 0.2 && o(w, 0, 0, 1);
    const P3 = n2();
    _(P3, g2, w), z(P3, P3), _(w, P3, g2);
    const U2 = 2 * i + (A ? 2 : 0), S2 = i + (A ? 2 : 0), p3 = new Float32Array(3 * U2), x3 = new Float32Array(3 * S2), z3 = new Float32Array(2 * U2), v2 = new Uint32Array(3 * i * (A ? 4 : 2)), T3 = new Uint32Array(3 * i * (A ? 4 : 2));
    A && (p3[3 * (U2 - 2) + 0] = d[0], p3[3 * (U2 - 2) + 1] = d[1], p3[3 * (U2 - 2) + 2] = d[2], z3[2 * (U2 - 2)] = 0, z3[2 * (U2 - 2) + 1] = 0, p3[3 * (U2 - 1) + 0] = p3[3 * (U2 - 2) + 0] + M2[0], p3[3 * (U2 - 1) + 1] = p3[3 * (U2 - 2) + 1] + M2[1], p3[3 * (U2 - 1) + 2] = p3[3 * (U2 - 2) + 2] + M2[2], z3[2 * (U2 - 1)] = 1, z3[2 * (U2 - 1) + 1] = 1, x3[3 * (S2 - 2) + 0] = -g2[0], x3[3 * (S2 - 2) + 1] = -g2[1], x3[3 * (S2 - 2) + 2] = -g2[2], x3[3 * (S2 - 1) + 0] = g2[0], x3[3 * (S2 - 1) + 1] = g2[1], x3[3 * (S2 - 1) + 2] = g2[2]);
    const L3 = (t3, e3, n4) => {
      v2[t3] = e3, T3[t3] = n4;
    };
    let R2 = 0;
    const b2 = n2(), G2 = n2();
    for (let e3 = 0; e3 < i; e3++) {
      const t3 = e3 * (2 * Math.PI / i);
      q(b2, w, Math.sin(t3)), q(G2, P3, Math.cos(t3)), u(b2, b2, G2), x3[3 * e3 + 0] = b2[0], x3[3 * e3 + 1] = b2[1], x3[3 * e3 + 2] = b2[2], q(b2, b2, l2), u(b2, b2, d), p3[3 * e3 + 0] = b2[0], p3[3 * e3 + 1] = b2[1], p3[3 * e3 + 2] = b2[2], z3[2 * e3 + 0] = e3 / i, z3[2 * e3 + 1] = 0, p3[3 * (e3 + i) + 0] = p3[3 * e3 + 0] + M2[0], p3[3 * (e3 + i) + 1] = p3[3 * e3 + 1] + M2[1], p3[3 * (e3 + i) + 2] = p3[3 * e3 + 2] + M2[2], z3[2 * (e3 + i) + 0] = e3 / i, z3[2 * e3 + 1] = 1;
      const n4 = (e3 + 1) % i;
      L3(R2++, e3, e3), L3(R2++, e3 + i, e3), L3(R2++, n4, n4), L3(R2++, n4, n4), L3(R2++, e3 + i, e3), L3(R2++, n4 + i, n4);
    }
    if (A) {
      for (let t3 = 0; t3 < i; t3++) {
        const e3 = (t3 + 1) % i;
        L3(R2++, U2 - 2, S2 - 2), L3(R2++, t3, S2 - 2), L3(R2++, e3, S2 - 2);
      }
      for (let t3 = 0; t3 < i; t3++) {
        const e3 = (t3 + 1) % i;
        L3(R2++, t3 + i, S2 - 1), L3(R2++, U2 - 1, S2 - 1), L3(R2++, e3 + i, S2 - 1);
      }
    }
    const F2 = [[O.POSITION, v2], [O.NORMAL, T3], [O.UV0, v2]], V2 = [[O.POSITION, { size: 3, data: p3, exclusive: true }], [O.NORMAL, { size: 3, data: x3, exclusive: true }], [O.UV0, { size: 2, data: z3, exclusive: true }]];
    return new g(V2, F2);
  }
  function E(t2, e3, n4, r3, a) {
    n4 = n4 || 10, r3 = null == r3 || r3, e2(t2.length > 1);
    const o2 = [[0, 0, 0]], s = [], l2 = [];
    for (let i = 0; i < n4; i++) {
      s.push([0, -i - 1, -(i + 1) % n4 - 1]);
      const t3 = i / n4 * 2 * Math.PI;
      l2.push([Math.cos(t3) * e3, Math.sin(t3) * e3]);
    }
    return M.createPathExtrusionGeometry(l2, t2, o2, s, r3, a);
  }
  function k(o2, i, h, g2, M2, d = r2(0, 0, 0)) {
    const w = o2.length, P3 = new Float32Array(i.length * w * 3 + (6 * h.length || 0)), U2 = new Float32Array(i.length * w * 3 + (h ? 6 : 0)), S2 = (i.length - 1) * w * 6 + 3 * g2.length * 2, p3 = new Uint32Array(S2), x3 = new Uint32Array(S2);
    let v2 = 0, T3 = 0, L3 = 0, R2 = 0;
    const b2 = n2(), G2 = n2(), F2 = n2(), V2 = n2(), j3 = n2(), C2 = n2(), E2 = n2(), k2 = n(), B2 = n2(), D2 = n2(), X2 = n2(), q4 = n2(), Z2 = n2(), J = p();
    o(B2, 0, 1, 0), e(G2, i[1], i[0]), z(G2, G2), M2 ? (u(k2, i[0], d), z(F2, k2)) : o(F2, 0, 0, 1), H(G2, F2, B2, B2, j3, F2, z2), r(V2, F2), r(q4, j3);
    for (let t2 = 0; t2 < h.length; t2++)
      q(C2, j3, h[t2][0]), q(k2, F2, h[t2][2]), u(C2, C2, k2), u(C2, C2, i[0]), P3[v2++] = C2[0], P3[v2++] = C2[1], P3[v2++] = C2[2];
    U2[T3++] = -G2[0], U2[T3++] = -G2[1], U2[T3++] = -G2[2];
    for (let t2 = 0; t2 < g2.length; t2++)
      p3[L3++] = g2[t2][0] > 0 ? g2[t2][0] : -g2[t2][0] - 1 + h.length, p3[L3++] = g2[t2][1] > 0 ? g2[t2][1] : -g2[t2][1] - 1 + h.length, p3[L3++] = g2[t2][2] > 0 ? g2[t2][2] : -g2[t2][2] - 1 + h.length, x3[R2++] = 0, x3[R2++] = 0, x3[R2++] = 0;
    let K = h.length;
    const Q = h.length - 1;
    for (let s = 0; s < i.length; s++) {
      let c2 = false;
      if (s > 0) {
        r(b2, G2), s < i.length - 1 ? (e(G2, i[s + 1], i[s]), z(G2, G2)) : c2 = true, u(D2, b2, G2), z(D2, D2), u(X2, i[s - 1], V2), _2(i[s], D2, J);
        q2(J, j(X2, b2), k2) ? (e(k2, k2, i[s]), z(F2, k2), _(j3, D2, F2), z(j3, j3)) : H(D2, V2, q4, B2, j3, F2, z2), r(V2, F2), r(q4, j3);
      }
      M2 && (u(k2, i[s], d), z(Z2, k2));
      for (let t2 = 0; t2 < w; t2++)
        if (q(C2, j3, o2[t2][0]), q(k2, F2, o2[t2][1]), u(C2, C2, k2), z(E2, C2), U2[T3++] = E2[0], U2[T3++] = E2[1], U2[T3++] = E2[2], u(C2, C2, i[s]), P3[v2++] = C2[0], P3[v2++] = C2[1], P3[v2++] = C2[2], !c2) {
          const e3 = (t2 + 1) % w;
          p3[L3++] = K + t2, p3[L3++] = K + w + t2, p3[L3++] = K + e3, p3[L3++] = K + e3, p3[L3++] = K + w + t2, p3[L3++] = K + w + e3;
          for (let t3 = 0; t3 < 6; t3++)
            x3[R2++] = p3[L3 - 6 + t3] - Q;
        }
      K += w;
    }
    const W = i[i.length - 1];
    for (let t2 = 0; t2 < h.length; t2++)
      q(C2, j3, h[t2][0]), q(k2, F2, h[t2][1]), u(C2, C2, k2), u(C2, C2, W), P3[v2++] = C2[0], P3[v2++] = C2[1], P3[v2++] = C2[2];
    const Y = T3 / 3;
    U2[T3++] = G2[0], U2[T3++] = G2[1], U2[T3++] = G2[2];
    const $ = K - w;
    for (let t2 = 0; t2 < g2.length; t2++)
      p3[L3++] = g2[t2][0] >= 0 ? K + g2[t2][0] : -g2[t2][0] - 1 + $, p3[L3++] = g2[t2][2] >= 0 ? K + g2[t2][2] : -g2[t2][2] - 1 + $, p3[L3++] = g2[t2][1] >= 0 ? K + g2[t2][1] : -g2[t2][1] - 1 + $, x3[R2++] = Y, x3[R2++] = Y, x3[R2++] = Y;
    const _3 = [[O.POSITION, p3], [O.NORMAL, x3]], tt = [[O.POSITION, { size: 3, data: P3, exclusive: true }], [O.NORMAL, { size: 3, data: U2, exclusive: true }]];
    return new g(tt, _3);
  }
  function B(t2, e3, n4) {
    e2(t2.length > 1, "createPolylineGeometry(): polyline needs at least 2 points"), e2(3 === t2[0].length, "createPolylineGeometry(): malformed vertex"), e2(null == e3 || e3.length === t2.length, "createPolylineGeometry: need same number of points and normals"), e2(null == e3 || 3 === e3[0].length, "createPolylineGeometry(): malformed normal");
    const r3 = new Float64Array(3 * t2.length), a = new Uint32Array(2 * (t2.length - 1));
    let o2 = 0, s = 0;
    for (let c2 = 0; c2 < t2.length; c2++) {
      for (let e4 = 0; e4 < 3; e4++)
        r3[o2++] = t2[c2][e4];
      c2 > 0 && (a[s++] = c2 - 1, a[s++] = c2);
    }
    const l2 = [], i = [];
    if (l2.push([O.POSITION, a]), i.push([O.POSITION, { size: 3, data: r3, exclusive: true }]), e3) {
      const n5 = new Float32Array(3 * e3.length);
      let r4 = 0;
      for (let a2 = 0; a2 < t2.length; a2++)
        for (let t3 = 0; t3 < 3; t3++)
          n5[r4++] = e3[a2][t3];
      l2.push([O.NORMAL, a]), i.push([O.NORMAL, { size: 3, data: n5, exclusive: true }]);
    }
    return n4 && (i.push([O.COLOR, { size: 4, data: n4 }]), l2.push([O.COLOR, l(n4.length / 4)])), new g(i, l2, c.Line);
  }
  function D(t2, e3, n4, r3, a = 0) {
    const o2 = new Array(18), s = [[-e3, a, r3 / 2], [n4, a, r3 / 2], [0, t2 + a, r3 / 2], [-e3, a, -r3 / 2], [n4, a, -r3 / 2], [0, t2 + a, -r3 / 2]], l2 = new Uint16Array([0, 1, 2, 3, 0, 2, 2, 5, 3, 1, 4, 5, 5, 2, 1, 1, 0, 3, 3, 4, 1, 4, 3, 5]);
    for (let i = 0; i < 6; i++)
      o2[3 * i] = s[i][0], o2[3 * i + 1] = s[i][1], o2[3 * i + 2] = s[i][2];
    return new g([[O.POSITION, { size: 3, data: o2, exclusive: true }]], [[O.POSITION, l2]]);
  }
  function X(t2, e3) {
    const n4 = t2.getMutableAttribute(O.POSITION).data;
    for (let r3 = 0; r3 < n4.length; r3 += 3) {
      const t3 = n4[r3], a = n4[r3 + 1], o2 = n4[r3 + 2];
      o(v, t3, a, o2), L(v, v, e3), n4[r3] = v[0], n4[r3 + 1] = v[1], n4[r3 + 2] = v[2];
    }
  }
  function q3(t2, e3 = t2) {
    const n4 = t2.vertexAttributes, r3 = n4.get(O.POSITION).data, a = n4.get(O.NORMAL).data;
    if (a) {
      const t3 = e3.getMutableAttribute(O.NORMAL).data;
      for (let e4 = 0; e4 < a.length; e4 += 3) {
        const n5 = a[e4 + 1];
        t3[e4 + 1] = -a[e4 + 2], t3[e4 + 2] = n5;
      }
    }
    if (r3) {
      const t3 = e3.getMutableAttribute(O.POSITION).data;
      for (let e4 = 0; e4 < r3.length; e4 += 3) {
        const n5 = r3[e4 + 1];
        t3[e4 + 1] = -r3[e4 + 2], t3[e4 + 2] = n5;
      }
    }
    return e3;
  }
  function Z(t2, r3, a, s, l2) {
    return !(Math.abs(P(r3, t2)) > l2) && (_(a, t2, r3), z(a, a), _(s, a, t2), z(s, s), true);
  }
  function H(t2, e3, n4, r3, a, o2, s) {
    return Z(t2, e3, a, o2, s) || Z(t2, n4, a, o2, s) || Z(t2, r3, a, o2, s);
  }
  M.createSquareGeometry = V, M.createConeGeometry = j2, M.createCylinderGeometry = C, M.createTubeGeometry = E, M.createPathExtrusionGeometry = k, M.createPolylineGeometry = B, M.createExtrudedTriangle = D, M.transformInPlace = X, M.cgToGIS = q3, M.makeOrthoBasisDirUp = Z, M.makeOrthoBasisDirUpFallback = H;
}(x || (x = {}));
var z2 = 0.99619469809;
var v = n2();
var T = x;

export {
  T
};
//# sourceMappingURL=chunk-52W4YMC2.js.map
