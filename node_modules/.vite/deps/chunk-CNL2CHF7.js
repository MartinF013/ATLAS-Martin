import {
  r as r2
} from "./chunk-HRAEK6P4.js";
import {
  s
} from "./chunk-K6UIDSFF.js";
import {
  e
} from "./chunk-AALA53RH.js";
import {
  c
} from "./chunk-YAQGRU5B.js";
import {
  o
} from "./chunk-A3QLZKCF.js";
import {
  a
} from "./chunk-OYAHQ564.js";
import {
  n as n2
} from "./chunk-NAB3NF54.js";
import {
  l,
  n
} from "./chunk-U7B2WKBH.js";
import {
  r
} from "./chunk-ZOKX6UGH.js";
import {
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/ensureColor4.js
function t2(c3) {
  return t(c3) ? l : 4 === c3.length ? c3 : r(e2, c3[0], c3[1], c3[2], 1);
}
var e2 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js
function p(e3, t3) {
  e3.constants.add("stippleAlphaColorDiscard", "float", 1e-3), e3.constants.add("stippleAlphaHighlightDiscard", "float", 0.5), t3.stippleEnabled ? n3(e3, t3) : d(e3);
}
function n3(p2, n4) {
  const d2 = !(n4.draped && n4.stipplePreferContinuous), { vertex: f, fragment: m } = p2;
  m.include(a), f.uniforms.add(new r2("stipplePatternPixelSize")), n4.draped || (c(f, n4), f.uniforms.add(new o("worldToScreenPerDistanceRatio", (e3, t3) => 1 / t3.camera.perScreenPixelRatio)), f.code.add(n2`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)), p2.varyings.add("vStippleDistance", "float"), n4.stippleRequiresClamp && p2.varyings.add("vStippleDistanceLimits", "vec2"), n4.stippleRequiresStretchMeasure && p2.varyings.add("vStipplePatternStretch", "float"), f.code.add(n2`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${c2};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `), f.code.add(n2`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`), f.code.add(n2`
    if (segmentLengthPseudoScreen >= ${d2 ? "patternLength" : "1e4"}) {
  `), f.uniforms.add(new o("pixelRatio", (e3, t3) => t3.camera.pixelRatio)), f.code.add(n2`
        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        ${n4.stippleRequiresStretchMeasure ? n2`
              float stretch = repetitions / flooredRepetitions;

              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.
              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.
              vStipplePatternStretch = max(0.75, stretch);` : ""}

        return vec2(0.0, segmentLengthScreenRounded);
      }
      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
    }
  `), m.uniforms.add(new s("stipplePatternTexture")), m.uniforms.add(new r2("stipplePatternSDFNormalizer")), m.uniforms.add(new r2("stipplePatternTextureSize")), m.uniforms.add(new r2("stipplePatternPixelSizeInv")), m.code.add(n2`float padTexture(float u) {
return (u * stipplePatternTextureSize + 1.0)/(stipplePatternTextureSize + 2.0);
}`), m.code.add(n2`
    float getStippleSDF(out bool isClamped) {
      ${n4.stippleRequiresClamp ? n2`
          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;` : n2`
          float stippleDistanceClamped = vStippleDistance;
          isClamped = false;`}

      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;
      ${n4.stippleScaleWithLineWidth ? n2`u *= vLineSizeInv;` : ""}
      u = padTexture(fract(u));

      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));
      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;

      ${n4.stippleRequiresStretchMeasure ? n2`return (sdf - 0.5) * vStipplePatternStretch + 0.5;` : n2`return sdf;`}
    }

    float getStippleSDF() {
      bool ignored;
      return getStippleSDF(ignored);
    }

    float getStippleAlpha() {
      bool isClamped;
      float stippleSDF = getStippleSDF(isClamped);

      float antiAliasedResult = ${n4.stippleScaleWithLineWidth ? n2`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);` : n2`clamp(stippleSDF + 0.5, 0.0, 1.0);`}

      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
    }
  `), n4.stippleOffColorEnabled ? (m.uniforms.add(new e("stippleOffColor", (e3) => t2(e3.stippleOffColor))), m.code.add(n2`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)) : m.code.add(n2`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`);
}
function d(e3) {
  e3.fragment.code.add(n2`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`);
}
var c2 = n2.float(0.4);

export {
  p
};
//# sourceMappingURL=chunk-CNL2CHF7.js.map
