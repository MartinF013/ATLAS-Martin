import {
  s
} from "./chunk-VQLKKADV.js";
import {
  D,
  G,
  L,
  M,
  P,
  U,
  t,
  u
} from "./chunk-FPMD6IB4.js";
import {
  o
} from "./chunk-MV2XZ5BA.js";
import {
  i
} from "./chunk-BPZGJQOB.js";
import {
  e,
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/webgl/capabilities/isWebGL2Context.js
function n(n2) {
  return window.WebGL2RenderingContext && n2 instanceof window.WebGL2RenderingContext;
}

// node_modules/@arcgis/core/views/webgl/Texture.js
var c = 4;
var u2 = class {
  constructor(t2, e2, i2 = null) {
    if (this._context = t2, this.type = "texture", this._glName = null, this._descriptor = void 0, this._samplingModeDirty = false, this._wrapModeDirty = false, this._wasImmutablyAllocated = false, t2.instanceCounter.increment(t.Texture, this), this._descriptor = { target: M.TEXTURE_2D, samplingMode: L.LINEAR, wrapMode: D.REPEAT, flipped: false, hasMipmap: false, isOpaque: false, unpackAlignment: 4, preMultiplyAlpha: false, isImmutable: false, ...e2 }, t2.type !== o.WEBGL2 && (this._descriptor.isImmutable && (this._descriptor.isImmutable = false), A(this._descriptor.target)))
      throw new Error("3D and array textures are not supported in WebGL1");
    this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(i2) : this.setData(i2);
  }
  get glName() {
    return this._glName;
  }
  get descriptor() {
    return this._descriptor;
  }
  get isDirty() {
    return this._samplingModeDirty || this._wrapModeDirty;
  }
  dispose() {
    this._context.gl && this._glName && (this._context.unbindTexture(this), this._context.gl.deleteTexture(this._glName), this._glName = null, this._context.instanceCounter.decrement(t.Texture, this));
  }
  release() {
    this.dispose();
  }
  resize(t2, e2) {
    const i2 = this._descriptor;
    if (i2.width !== t2 || i2.height !== e2) {
      if (this._wasImmutablyAllocated)
        throw new Error("Immutable textures can't be resized!");
      i2.width = t2, i2.height = e2, this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(null) : this.setData(null);
    }
  }
  _setDataCubeMap(t2 = null) {
    for (let e2 = M.TEXTURE_CUBE_MAP_POSITIVE_X; e2 <= M.TEXTURE_CUBE_MAP_NEGATIVE_Z; e2++)
      this._setData(t2, e2);
  }
  setData(t2) {
    this._setData(t2);
  }
  _setData(t2, i2) {
    if (!this._context || !this._context.gl)
      return;
    const a = this._context.gl;
    this._glName || (this._glName = a.createTexture()), void 0 === t2 && (t2 = null);
    const s2 = this._descriptor;
    i2 ?? (i2 = s2.target);
    const o2 = A(i2);
    null === t2 && (s2.width = s2.width || c, s2.height = s2.height || c, o2 && (s2.depth = s2.depth ?? 1));
    const n2 = this._context.bindTexture(this, u2.TEXTURE_UNIT_FOR_UPDATES);
    this._context.setActiveTexture(u2.TEXTURE_UNIT_FOR_UPDATES), u2._validateTexture(this._context, s2), this._configurePixelStorage();
    const p = s2.pixelFormat;
    let h = s2.internalFormat ? s2.internalFormat : this._deriveInternalFormat(p, s2.dataType);
    if (M2(t2)) {
      let e2 = t2.width, n3 = t2.height;
      const p2 = 1;
      t2 instanceof HTMLVideoElement && (e2 = t2.videoWidth, n3 = t2.videoHeight), s2.width && s2.height, o2 && s2.depth, s2.isImmutable && !this._wasImmutablyAllocated && this._texStorage(i2, h, s2.hasMipmap, e2, n3, p2), this._texImage(i2, 0, h, e2, n3, p2, t2), s(a), s2.hasMipmap && this.generateMipmap(), void 0 === s2.width && (s2.width = e2), void 0 === s2.height && (s2.height = n3), o2 && void 0 === s2.depth && (s2.depth = p2);
    } else {
      const { width: n3, height: p2, depth: _ } = s2;
      if (null != n3 && null != p2 || console.error("Width and height must be specified!"), o2 && null == _ && console.error("Depth must be specified!"), s2.isImmutable && !this._wasImmutablyAllocated && this._texStorage(i2, h, s2.hasMipmap, n3, p2, _), a.DEPTH24_STENCIL8 && h === a.DEPTH_STENCIL && (h = a.DEPTH24_STENCIL8), g(t2)) {
        const e2 = t2.levels, r2 = I(i2, n3, p2, _), o3 = Math.min(r2 - 1, e2.length - 1);
        n(a) ? a.texParameteri(s2.target, a.TEXTURE_MAX_LEVEL, o3) : s2.hasMipmap = s2.hasMipmap && r2 === e2.length;
        const l = h;
        if (!T(l))
          throw new Error("Attempting to use compressed data with an umcompressed format!");
        this._forEachMipmapLevel((t3, r3, a2, s3) => {
          const o4 = e2[Math.min(t3, e2.length - 1)];
          this._compressedTexImage(i2, t3, l, r3, a2, s3, o4);
        }, o3);
      } else
        r(t2) ? (this._texImage(i2, 0, h, n3, p2, _, t2), s(a), s2.hasMipmap && this.generateMipmap()) : this._forEachMipmapLevel((t3, e2, s3, o3) => {
          this._texImage(i2, t3, h, e2, s3, o3, null), s(a);
        });
    }
    u2._applySamplingMode(a, this._descriptor), u2._applyWrapMode(a, this._descriptor), u2._applyAnisotropicFilteringParameters(this._context, this._descriptor), s(a), this._context.bindTexture(n2, u2.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData(t2, e2, i2, r2, a, s2) {
    s2 || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const o2 = this._context.gl, n2 = this._descriptor, { pixelFormat: p, internalFormat: h, dataType: _, isImmutable: l, target: m } = n2;
    if (l && !this._wasImmutablyAllocated)
      throw new Error("Cannot update immutable texture before allocation!");
    const d = this._context.bindTexture(this, u2.TEXTURE_UNIT_FOR_UPDATES);
    (e2 < 0 || i2 < 0 || r2 > n2.width || a > n2.height || e2 + r2 > n2.width || i2 + a > n2.height) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage(), M2(s2) ? o2.texSubImage2D(m, t2, e2, i2, p, _, s2) : g(s2) ? o2.compressedTexSubImage2D(m, t2, e2, i2, r2, a, h, s2.levels[t2]) : o2.texSubImage2D(m, t2, e2, i2, r2, a, p, _, s2), this._context.bindTexture(d, u2.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData3D(t2, e2, i2, r2, a, s2, o2, n2) {
    n2 || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const p = this._context.gl;
    if (!n(p))
      throw new Error("3D textures are not supported in WebGL1");
    const h = this._descriptor, { pixelFormat: _, dataType: l, isImmutable: m, target: c2, internalFormat: E2 } = h;
    if (m && !this._wasImmutablyAllocated)
      throw new Error("Cannot update immutable texture before allocation!");
    A(c2) || console.warn("Attempting to set 3D texture data on a non-3D texture");
    const T2 = this._context.bindTexture(this, u2.TEXTURE_UNIT_FOR_UPDATES);
    if (this._context.setActiveTexture(u2.TEXTURE_UNIT_FOR_UPDATES), (e2 < 0 || i2 < 0 || r2 < 0 || a > h.width || s2 > h.height || o2 > h.depth || e2 + a > h.width || i2 + s2 > h.height || r2 + o2 > h.depth) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage(), g(n2))
      n2 = n2.levels[t2], p.compressedTexSubImage3D(c2, t2, e2, i2, r2, a, s2, o2, E2, n2);
    else {
      const h2 = n2;
      p.texSubImage3D(c2, t2, e2, i2, r2, a, s2, o2, _, l, h2);
    }
    this._context.bindTexture(T2, u2.TEXTURE_UNIT_FOR_UPDATES);
  }
  generateMipmap() {
    const t2 = this._descriptor;
    if (!t2.hasMipmap) {
      if (this._wasImmutablyAllocated)
        throw new Error("Cannot add mipmaps to immutable texture after allocation");
      t2.hasMipmap = true, this._samplingModeDirty = true, u2._validateTexture(this._context, t2);
    }
    t2.samplingMode === L.LINEAR ? (this._samplingModeDirty = true, t2.samplingMode = L.LINEAR_MIPMAP_NEAREST) : t2.samplingMode === L.NEAREST && (this._samplingModeDirty = true, t2.samplingMode = L.NEAREST_MIPMAP_NEAREST);
    const e2 = this._context.bindTexture(this, u2.TEXTURE_UNIT_FOR_UPDATES);
    this._context.setActiveTexture(u2.TEXTURE_UNIT_FOR_UPDATES);
    this._context.gl.generateMipmap(t2.target), this._context.bindTexture(e2, u2.TEXTURE_UNIT_FOR_UPDATES);
  }
  setSamplingMode(t2) {
    t2 !== this._descriptor.samplingMode && (this._descriptor.samplingMode = t2, this._samplingModeDirty = true);
  }
  setWrapMode(t2) {
    t2 !== this._descriptor.wrapMode && (this._descriptor.wrapMode = t2, u2._validateTexture(this._context, this._descriptor), this._wrapModeDirty = true);
  }
  applyChanges() {
    const t2 = this._context.gl, e2 = this._descriptor;
    this._samplingModeDirty && (u2._applySamplingMode(t2, e2), this._samplingModeDirty = false), this._wrapModeDirty && (u2._applyWrapMode(t2, e2), this._wrapModeDirty = false);
  }
  _deriveInternalFormat(t2, e2) {
    if (this._context.type === o.WEBGL1)
      return t2;
    switch (e2) {
      case G.FLOAT:
        switch (t2) {
          case P.RGBA:
            return U.RGBA32F;
          case P.RGB:
            return U.RGB32F;
          default:
            throw new Error("Unable to derive format");
        }
      case G.UNSIGNED_BYTE:
        switch (t2) {
          case P.RGBA:
            return U.RGBA8;
          case P.RGB:
            return U.RGB8;
        }
      default:
        return t2;
    }
  }
  _configurePixelStorage() {
    const t2 = this._context.gl, { unpackAlignment: e2, flipped: i2, preMultiplyAlpha: r2 } = this._descriptor;
    t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, i2 ? 1 : 0), t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r2 ? 1 : 0);
  }
  _texStorage(t2, e2, i2, r2, a, s2) {
    const o2 = this._context.gl;
    if (!n(o2))
      throw new Error("Immutable textures are not supported in WebGL1");
    if (!E(e2))
      throw new Error("Immutable textures must have a sized internal format");
    if (!this._descriptor.isImmutable)
      return;
    const n2 = i2 ? I(t2, r2, a, s2) : 1;
    A(t2) ? o2.texStorage3D(t2, n2, e2, r2, a, s2) : o2.texStorage2D(t2, n2, e2, r2, a), this._wasImmutablyAllocated = true;
  }
  _texImage(t2, r2, s2, o2, n2, p, h) {
    const _ = this._context.gl;
    let l = null;
    const m = this._context.type === o.WEBGL2, d = A(t2), { isImmutable: c2, pixelFormat: u3, dataType: E2 } = this._descriptor;
    if (m && (l = _), m || !M2(h))
      if (c2) {
        if (r(h)) {
          const e2 = h;
          d ? l.texSubImage3D(t2, r2, 0, 0, 0, o2, n2, p, u3, E2, e2) : _.texSubImage2D(t2, r2, 0, 0, o2, n2, u3, E2, e2);
        }
      } else {
        const e2 = e(h);
        d ? l.texImage3D(t2, r2, s2, o2, n2, p, 0, u3, E2, e2) : _.texImage2D(t2, r2, s2, o2, n2, 0, u3, E2, e2);
      }
    else
      _.texImage2D(t2, 0, s2, u3, E2, h);
  }
  _compressedTexImage(t2, i2, r2, s2, o2, n2, p) {
    const h = this._context.gl;
    let _ = null;
    const l = A(t2), m = this._descriptor.isImmutable;
    if (l) {
      if (this._context.type !== o.WEBGL2)
        throw new Error("3D textures are not supported in WebGL1");
      _ = h;
    }
    m ? r(p) && (l ? _.compressedTexSubImage3D(t2, i2, 0, 0, 0, s2, o2, n2, r2, p) : h.compressedTexSubImage2D(t2, i2, 0, 0, s2, o2, r2, p)) : l ? _.compressedTexImage3D(t2, i2, r2, s2, o2, n2, 0, p) : h.compressedTexImage2D(t2, i2, r2, s2, o2, 0, p);
  }
  _forEachMipmapLevel(t2, e2 = 1 / 0) {
    let { width: i2, height: r2, depth: a, hasMipmap: s2, target: n2 } = this._descriptor;
    const p = n2 === M.TEXTURE_3D;
    for (let o2 = 0; t2(o2, i2, r2, a), s2 && (1 !== i2 || 1 !== r2 || p && 1 !== a) && !(o2 >= e2); ++o2)
      i2 = Math.max(1, i2 >> 1), r2 = Math.max(1, r2 >> 1), p && (a = Math.max(1, a >> 1));
  }
  static _validateTexture(e2, i2) {
    (i2.width < 0 || i2.height < 0 || i2.depth < 0) && console.error("Negative dimension parameters are not allowed!");
    const r2 = n(e2.gl), a = i(i2.width) && i(i2.height);
    r2 || !i2.isImmutable && !A(i2.target) || console.error("Immutable and 3D-like textures are not supported in WebGL1!"), r2 || a || ("number" == typeof i2.wrapMode ? i2.wrapMode !== D.CLAMP_TO_EDGE && console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!") : i2.wrapMode.s === D.CLAMP_TO_EDGE && i2.wrapMode.t === D.CLAMP_TO_EDGE || console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"), i2.hasMipmap && console.error("Mipmapping requires power-of-two textures!"));
  }
  static _applySamplingMode(t2, e2) {
    let i2 = e2.samplingMode, r2 = e2.samplingMode;
    i2 === L.LINEAR_MIPMAP_NEAREST || i2 === L.LINEAR_MIPMAP_LINEAR ? (i2 = L.LINEAR, e2.hasMipmap || (r2 = L.LINEAR)) : i2 !== L.NEAREST_MIPMAP_NEAREST && i2 !== L.NEAREST_MIPMAP_LINEAR || (i2 = L.NEAREST, e2.hasMipmap || (r2 = L.NEAREST)), t2.texParameteri(e2.target, t2.TEXTURE_MAG_FILTER, i2), t2.texParameteri(e2.target, t2.TEXTURE_MIN_FILTER, r2);
  }
  static _applyWrapMode(t2, e2) {
    "number" == typeof e2.wrapMode ? (t2.texParameteri(e2.target, t2.TEXTURE_WRAP_S, e2.wrapMode), t2.texParameteri(e2.target, t2.TEXTURE_WRAP_T, e2.wrapMode)) : (t2.texParameteri(e2.target, t2.TEXTURE_WRAP_S, e2.wrapMode.s), t2.texParameteri(e2.target, t2.TEXTURE_WRAP_T, e2.wrapMode.t));
  }
  static _applyAnisotropicFilteringParameters(t2, e2) {
    const i2 = t2.capabilities.textureFilterAnisotropic;
    if (!i2)
      return;
    t2.gl.texParameterf(e2.target, i2.TEXTURE_MAX_ANISOTROPY, e2.maxAnisotropy ?? 1);
  }
};
function E(t2) {
  return t2 in U;
}
function T(t2) {
  return t2 in u;
}
function g(t2) {
  return r(t2) && "type" in t2 && "compressed" === t2.type;
}
function x(t2) {
  return r(t2) && "byteLength" in t2;
}
function M2(t2) {
  return r(t2) && !g(t2) && !x(t2);
}
function A(t2) {
  return t2 === M.TEXTURE_3D || t2 === M.TEXTURE_2D_ARRAY;
}
function I(t2, e2, i2, r2 = 1) {
  let a = Math.max(e2, i2);
  return t2 === M.TEXTURE_3D && (a = Math.max(a, r2)), Math.round(Math.log(a) / Math.LN2) + 1;
}
u2.TEXTURE_UNIT_FOR_UPDATES = 0;

export {
  n,
  u2 as u
};
//# sourceMappingURL=chunk-EJ7RFMRW.js.map
