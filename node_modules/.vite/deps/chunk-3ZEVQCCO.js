import {
  m as m2
} from "./chunk-5KER37ZC.js";
import {
  Y,
  se
} from "./chunk-IEPHENP2.js";
import {
  s,
  s2
} from "./chunk-436X6OVY.js";
import {
  m
} from "./chunk-JYR7GBAU.js";
import {
  e,
  n,
  r
} from "./chunk-IG4CY4XM.js";
import {
  p
} from "./chunk-C5ULLWJ7.js";
import {
  u
} from "./chunk-NWRK6QLX.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  c as c2,
  v,
  y
} from "./chunk-4PRVTUEZ.js";
import {
  l
} from "./chunk-FVPTCNCX.js";
import {
  f
} from "./chunk-U3PSONS6.js";
import {
  c
} from "./chunk-G5JBUC5N.js";

// node_modules/@arcgis/core/symbols/cim/CIMSymbolRasterizer.js
var M;
!function(e2) {
  e2.Legend = "legend", e2.Preview = "preview";
}(M || (M = {}));
var C = (e2, t, r2) => {
  if (e2 && e2.targetSize) {
    let i;
    if (r2) {
      const t2 = Math.max(r2.frame.xmax - r2.frame.xmin, r2.frame.ymax - r2.frame.ymin);
      i = e2.targetSize / u(t2);
    } else
      i = e2.targetSize / t.referenceSize;
    return i;
  }
  return e2 && e2.scaleFactor ? e2.scaleFactor : 1;
};
var I = { fill: { legend: { frame: { xmax: 15, xmin: 0, ymax: 15, ymin: 0 }, geometry: { rings: [[[0, 15], [15, 7.5], [15, 0], [0, 0], [0, 15]]] }, canvasPaths: { rings: [[[0, 15], [0, 0], [15, 7.5], [15, 15], [0, 15]]] } }, preview: { frame: { xmax: 100, xmin: 0, ymax: 100, ymin: 0 }, geometry: { rings: [[[0, 100], [100, 100], [100, 0], [0, 0], [0, 100]]] }, canvasPaths: { rings: [[[0, 100], [0, 0], [100, 0], [100, 100], [0, 100]]] } } }, stroke: { legend: { frame: { xmax: 24, xmin: 0, ymax: 2, ymin: -2 }, geometry: { paths: [[[0, 0], [12, 0], [24, 0]]] }, canvasPaths: { paths: [[[0, 2], [12, 2], [24, 2]]] } }, preview: { frame: { xmax: 100, xmin: 0, ymax: 2, ymin: -2 }, geometry: { paths: [[[0, 0], [50, 0], [100, 0]]] }, canvasPaths: { paths: [[[0, 2], [50, 2], [100, 2]]] } } } };
var z = class {
  constructor(e2, t) {
    this._spatialReference = e2, this._avoidSDF = t, this._resourceCache = /* @__PURE__ */ new Map(), this._pictureMarkerCache = /* @__PURE__ */ new Map(), this._textRasterizer = new s2(), this._cimResourceManager = new s(), this._rasterizer = new m2(this._cimResourceManager);
  }
  async rasterizeCIMSymbolAsync(e2, t, r2, a, i, o, n2, c3) {
    a = a || (t ? null != t.centroid ? "esriGeometryPolygon" : v(t.geometry) : null) || x(e2);
    const l2 = await this.analyzeCIMSymbol(e2, t ? P(t.attributes) : null, r2, a, c3);
    return this.rasterizeCIMSymbol(l2, t, a, i, o, n2);
  }
  async analyzeCIMSymbol(e2, t, a, i, s3) {
    const o = [], n2 = t ? { geometryType: i, spatialReference: this._spatialReference, fields: t } : null;
    let l2;
    await Y(e2.data, n2, this._cimResourceManager, o, this._avoidSDF), f(s3);
    for (const r2 of o)
      "CIMPictureMarker" !== r2.cim.type && "CIMPictureFill" !== r2.cim.type && "CIMPictureStroke" !== r2.cim.type || (l2 || (l2 = []), l2.push(this._fetchPictureMarkerResource(r2, s3))), a && "text" === r2.type && "string" == typeof r2.text && r2.text.includes("[") && (r2.text = n(a, r2.text, r2.cim.textCase));
    return l2 && await Promise.all(l2), o;
  }
  async _fetchPictureMarkerResource(e2, r2) {
    const a = e2.materialHash;
    if (!this._pictureMarkerCache.get(a)) {
      const i = (await U(e2.cim.url, { responseType: "image", signal: r2 && r2.signal })).data;
      this._pictureMarkerCache.set(a, i);
    }
  }
  rasterizeCIMSymbol(e2, t, r2, a, i, s3) {
    const o = [];
    for (const n2 of e2) {
      a && "function" == typeof a.scaleFactor && (a.scaleFactor = a.scaleFactor(t, i, s3));
      const e3 = this._getRasterizedResource(n2, t, r2, a, i, s3);
      if (!e3)
        continue;
      let c3 = 0, l2 = e3.anchorX || 0, m3 = e3.anchorY || 0, h = false, f2 = 0, g = 0;
      if ("esriGeometryPoint" === r2) {
        const e4 = C(a, n2, null);
        if (f2 = e(n2.offsetX, t, i, s3) * e4 || 0, g = e(n2.offsetY, t, i, s3) * e4 || 0, "marker" === n2.type)
          c3 = e(n2.rotation, t, i, s3) || 0, h = !!n2.rotateClockwise && n2.rotateClockwise;
        else if ("text" === n2.type) {
          if (c3 = e(n2.angle, t, i, s3) || 0, void 0 !== n2.horizontalAlignment)
            switch (n2.horizontalAlignment) {
              case "left":
                l2 = -0.5;
                break;
              case "right":
                l2 = 0.5;
                break;
              default:
                l2 = 0;
            }
          if (void 0 !== n2.verticalAlignment)
            switch (n2.verticalAlignment) {
              case "top":
                m3 = 0.5;
                break;
              case "bottom":
                m3 = -0.5;
                break;
              case "baseline":
                m3 = -0.25;
                break;
              default:
                m3 = 0;
            }
        }
      }
      null != e3 && o.push({ angle: c3, rotateClockWise: h, anchorX: l2, anchorY: m3, offsetX: f2, offsetY: g, rasterizedResource: e3 });
    }
    return this.getSymbolImage(o);
  }
  getSymbolImage(e2) {
    const t = document.createElement("canvas"), r2 = t.getContext("2d");
    let i = 0, s3 = 0, o = 0, n2 = 0;
    const c3 = [];
    for (let f2 = 0; f2 < e2.length; f2++) {
      const t2 = e2[f2], l3 = t2.rasterizedResource;
      if (!l3)
        continue;
      const m4 = l3.size, h2 = t2.offsetX, g = t2.offsetY, u2 = t2.anchorX, y2 = t2.anchorY, p2 = t2.rotateClockWise || false;
      let d = t2.angle, M2 = u(h2) - m4[0] * (0.5 + u2), C2 = u(g) - m4[1] * (0.5 + y2), I2 = M2 + m4[0], z2 = C2 + m4[1];
      if (d) {
        p2 && (d = -d);
        const e3 = Math.sin(d * Math.PI / 180), t3 = Math.cos(d * Math.PI / 180), r3 = M2 * t3 - C2 * e3, a = M2 * e3 + C2 * t3, i2 = M2 * t3 - z2 * e3, s4 = M2 * e3 + z2 * t3, o2 = I2 * t3 - z2 * e3, n3 = I2 * e3 + z2 * t3, c4 = I2 * t3 - C2 * e3, l4 = I2 * e3 + C2 * t3;
        M2 = Math.min(r3, i2, o2, c4), C2 = Math.min(a, s4, n3, l4), I2 = Math.max(r3, i2, o2, c4), z2 = Math.max(a, s4, n3, l4);
      }
      i = M2 < i ? M2 : i, s3 = C2 < s3 ? C2 : s3, o = I2 > o ? I2 : o, n2 = z2 > n2 ? z2 : n2;
      const P2 = r2.createImageData(l3.size[0], l3.size[1]);
      P2.data.set(new Uint8ClampedArray(l3.image.buffer));
      const x2 = { offsetX: h2, offsetY: g, rotateClockwise: p2, angle: d, rasterizedImage: P2, anchorX: u2, anchorY: y2 };
      c3.push(x2);
    }
    t.width = o - i, t.height = n2 - s3;
    const l2 = -i, m3 = n2;
    for (let f2 = 0; f2 < c3.length; f2++) {
      const e3 = c3[f2], t2 = this._imageDataToCanvas(e3.rasterizedImage), i2 = e3.rasterizedImage.width, s4 = e3.rasterizedImage.height, o2 = l2 - i2 * (0.5 + e3.anchorX), n3 = m3 - s4 * (0.5 - e3.anchorY);
      if (e3.angle) {
        const i3 = (360 - e3.angle) * Math.PI / 180;
        r2.save(), r2.translate(u(e3.offsetX), -u(e3.offsetY)), r2.translate(l2, m3), r2.rotate(i3), r2.translate(-l2, -m3), r2.drawImage(t2, o2, n3), r2.restore();
      } else
        r2.drawImage(t2, o2 + u(e3.offsetX), n3 - u(e3.offsetY));
    }
    const h = new p({ x: l2 / t.width - 0.5, y: m3 / t.height - 0.5 });
    return { imageData: 0 !== t.width && 0 !== t.height ? r2.getImageData(0, 0, t.width, t.height) : r2.createImageData(1, 1), anchorPosition: h };
  }
  _imageDataToCanvas(e2) {
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const t = this._imageDataCanvas, r2 = t.getContext("2d");
    return t.width = e2.width, t.height = e2.height, r2.putImageData(e2, 0, 0), t;
  }
  _imageTo32Array(t, r2, a, i) {
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const s3 = this._imageDataCanvas, o = s3.getContext("2d");
    if (s3.width = r2, s3.height = a, o.drawImage(t, 0, 0, r2, a), i) {
      o.save();
      const s4 = new l(i);
      o.fillStyle = s4.toHex(), o.globalCompositeOperation = "multiply", o.fillRect(0, 0, r2, a), o.globalCompositeOperation = "destination-atop", o.drawImage(t, 0, 0, r2, a), o.restore();
    }
    return new Uint32Array(o.getImageData(0, 0, r2, a).data.buffer);
  }
  _getRasterizedResource(e2, t, r2, a, s3, o) {
    let n2, c3, l2, m3, h = null, f2 = null;
    if ("esriGeometryPolyline" === r2 || "esriGeometryPolygon" === r2) {
      const m4 = a && a.style ? a.style : M.Legend, g2 = "esriGeometryPolyline" === r2 ? I.stroke[m4] : I.fill[m4];
      if ("line" === e2.type) {
        if ("CIMSolidStroke" !== e2.cim.type) {
          if ("CIMPictureStroke" === e2.cim.type) {
            const r3 = e(e2.width, t, s3, o), a2 = e(e2.color, t, s3, o), { image: i, width: n3, height: c4 } = this._getPictureResource(e2, r3, a2);
            return this._rasterizePictureResource(e2, i, n3, c4, g2, r3);
          }
          return null;
        }
        ({ analyzedCIM: n2, hash: l2 } = w(e2, t, s3, o)), c3 = this._embedCIMLayerInVectorMarker(n2, g2);
      } else if ("marker" === e2.type) {
        if ("CIMPictureMarker" === e2.cim.type) {
          const r3 = e(e2.size, t, s3, o), a2 = e(e2.color, t, s3, o), { image: i, width: n3, height: c4 } = this._getPictureResource(e2, r3, a2);
          return this._rasterizePictureResource(e2, i, n3, c4, g2, r3);
        }
        if ("CIMVectorMarker" !== e2.cim.type)
          return null;
        e2.cim.offsetX = e(e2.offsetX, t, s3, o), e2.cim.offsetY = e(e2.offsetY, t, s3, o), e2.cim.rotation = e(e2.rotation, t, s3, o), e2.cim.markerPlacement = e2.markerPlacement, { analyzedCIM: n2 } = w(e2, t, s3, o), l2 = c(JSON.stringify(n2)).toString(), c3 = this._embedCIMLayerInVectorMarker(n2, g2), h = e(e2.size, t, s3, o), f2 = e2.path;
      } else {
        if ("text" === e2.type)
          return null;
        if ("fill" === e2.type) {
          if ("CIMHatchFill" === e2.cim.type || "CIMVectorMarker" === e2.cim.type || "CIMPictureMarker" === e2.cim.type || "CIMPictureFill" === e2.cim.type) {
            const r3 = e2.cim.size || e2.cim.height;
            let a2, i, c4;
            if ("CIMPictureMarker" === e2.cim.type || "CIMPictureFill" === e2.cim.type)
              ({ image: a2, width: i, height: c4 } = this._getPictureResource(e2, r3, e(e2.color, t, s3, o)));
            else {
              ({ analyzedCIM: n2, hash: l2 } = w(e2, t, s3, o));
              const m5 = this._rasterizer.rasterizeJSONResource({ cim: n2, type: e2.type, url: e2.url, mosaicHash: l2, size: r3, path: f2 }, 1, this._avoidSDF);
              a2 = m5.image, i = m5.size[0], c4 = m5.size[1];
            }
            return this._rasterizePictureResource(e2, a2, i, c4, g2, null);
          }
          if ("CIMSolidFill" !== e2.cim.type)
            return null;
          ({ analyzedCIM: n2, hash: l2 } = w(e2, t, s3, o)), c3 = this._embedCIMLayerInVectorMarker(n2, g2);
        }
      }
    } else {
      if ("text" === e2.type)
        return m3 = this._rasterizeTextResource(e2, t, a, s3, o), m3;
      ({ analyzedCIM: n2, hash: l2 } = w(e2, t, s3, o));
      const r3 = C(a, e2, null);
      if ("CIMPictureMarker" === e2.cim.type) {
        const a2 = e(e2.size, t, s3, o) * r3, { image: i, width: n3, height: c4 } = this._getPictureResource(e2, a2, e(e2.color, t, s3, o));
        return m3 = { image: i, size: [n3, c4], sdf: false, simplePattern: false, anchorX: e2.anchorPoint ? e2.anchorPoint.x : 0, anchorY: e2.anchorPoint ? e2.anchorPoint.y : 0 }, m3;
      }
      m(n2, r3, { preserveOutlineWidth: false }), c3 = n2;
    }
    l2 += r2, a && (l2 += JSON.stringify(a));
    const g = this._resourceCache;
    return g.has(l2) ? g.get(l2) : (m3 = this._rasterizer.rasterizeJSONResource({ cim: c3, type: e2.type, url: e2.url, mosaicHash: l2, size: h, path: f2 }, window.devicePixelRatio || 1, this._avoidSDF), g.set(l2, m3), m3);
  }
  _rasterizeTextResource(e2, t, r2, a, i) {
    const s3 = C(r2, e2, null), o = e(e2.text, t, a, i);
    if (!o || 0 === o.length)
      return null;
    const n2 = e(e2.fontName, t, a, i), c3 = e(e2.style, t, a, i), l2 = e(e2.weight, t, a, i), m3 = e(e2.decoration, t, a, i), h = e(e2.size, t, a, i) * s3, f2 = e(e2.horizontalAlignment, t, a, i), g = e(e2.verticalAlignment, t, a, i), p2 = r(e(e2.color, t, a, i)), d = r(e(e2.outlineColor, t, a, i)), M2 = { color: p2, size: h, horizontalAlignment: f2, verticalAlignment: g, font: { family: n2, style: c3, weight: l2, decoration: m3 }, halo: { size: e(e2.outlineSize, t, a, i) || 0, color: d, style: c3 }, pixelRatio: 1, premultiplyColors: !this._avoidSDF };
    return this._textRasterizer.rasterizeText(o, M2);
  }
  _rasterizePictureResource(e2, t, r2, i, s3, c3) {
    const l2 = document.createElement("canvas"), m3 = l2.getContext("2d");
    l2.height = u(Math.max(s3.frame.ymax - s3.frame.ymin, c3)), l2.width = u(s3.frame.xmax - s3.frame.xmin);
    const h = m3.createImageData(r2, i);
    h.data.set(new Uint8ClampedArray(t.buffer));
    const f2 = this._imageDataToCanvas(h), g = m3.createPattern(f2, "repeat"), u2 = Math.cos((-e2.cim.rotation || 0) * Math.PI / 180), y2 = Math.sin((-e2.cim.rotation || 0) * Math.PI / 180);
    g.setTransform({ m11: u2, m12: y2, m21: -y2, m22: u2, m41: u(e2.cim.offsetX) || 0, m42: u(e2.cim.offsetY) || 0 });
    const p2 = s3.canvasPaths;
    let d, M2, C2;
    c2(p2) ? (d = p2.rings, m3.fillStyle = g, M2 = m3.fill, C2 = ["evenodd"]) : y(p2) && (d = p2.paths, m3.strokeStyle = g, m3.lineWidth = c3, M2 = m3.stroke, d[0][0][1] = l2.height / 2, d[0][1][1] = l2.height / 2), m3.beginPath();
    for (const o of d) {
      const e3 = o ? o.length : 0;
      if (e3 > 1) {
        let t2 = o[0];
        m3.moveTo(u(t2[0]), u(t2[1]));
        for (let r3 = 1; r3 < e3; ++r3)
          t2 = o[r3], m3.lineTo(u(t2[0]), u(t2[1]));
        m3.closePath();
      }
    }
    M2.apply(m3, C2);
    const I2 = m3.getImageData(0, 0, l2.width, l2.height), z2 = new Uint8Array(I2.data);
    return { size: [l2.width, l2.height], image: new Uint32Array(z2.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0 };
  }
  _getPictureResource(e2, t, r2) {
    const i = this._pictureMarkerCache.get(e2.materialHash);
    if (!i)
      return null;
    const s3 = i.height / i.width, o = t ? s3 > 1 ? u(t) : u(t) / s3 : i.width, n2 = t ? s3 > 1 ? u(t) * s3 : u(t) : i.height;
    return { image: this._imageTo32Array(i, o, n2, r2), width: o, height: n2 };
  }
  _embedCIMLayerInVectorMarker(e2, t) {
    const r2 = c2(t.geometry) ? "CIMPolygonSymbol" : "CIMLineSymbol", a = t.frame;
    return { type: "CIMVectorMarker", frame: a, size: a.ymax - a.ymin, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: t.geometry, symbol: { type: r2, symbolLayers: [e2] } }] };
  }
};
function P(e2) {
  return (e2 ? Object.keys(e2) : []).map((t) => ({ name: t, alias: t, type: "string" == typeof e2[t] ? "esriFieldTypeString" : "esriFieldTypeDouble" }));
}
function x(e2) {
  if (!(e2 && e2.data && e2.data.symbol))
    return null;
  switch (e2.data.symbol.type) {
    case "CIMPointSymbol":
    case "CIMTextSymbol":
      return "esriGeometryPoint";
    case "CIMLineSymbol":
      return "esriGeometryPolyline";
    case "CIMPolygonSymbol":
      return "esriGeometryPolygon";
    default:
      return null;
  }
}
function w(e2, t, r2, a) {
  let i, s3;
  if ("function" == typeof e2.materialHash) {
    i = (0, e2.materialHash)(t, r2, a), s3 = se(e2.cim, e2.materialOverrides);
  } else
    i = e2.materialHash, s3 = e2.cim;
  return { analyzedCIM: s3, hash: i };
}

export {
  M,
  z
};
//# sourceMappingURL=chunk-3ZEVQCCO.js.map
