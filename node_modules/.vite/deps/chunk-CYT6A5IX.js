import {
  r as r3
} from "./chunk-TGUQXVQU.js";
import {
  o as o6
} from "./chunk-3236UEJN.js";
import {
  e
} from "./chunk-E3V32BOJ.js";
import {
  a as a2,
  m
} from "./chunk-MQLLOFWM.js";
import {
  c2
} from "./chunk-XNOIZLCR.js";
import {
  t
} from "./chunk-I22L7HNU.js";
import {
  o as o2
} from "./chunk-44UD36FH.js";
import {
  c as c3
} from "./chunk-Y5AGUEHG.js";
import {
  e as e5
} from "./chunk-YSWURJZW.js";
import {
  e as e6,
  o as o4,
  v
} from "./chunk-5JKCNCL2.js";
import {
  o as o3
} from "./chunk-2YDCEMEJ.js";
import {
  a
} from "./chunk-767LZ6IM.js";
import {
  n as n2
} from "./chunk-DNPZNIDB.js";
import {
  e as e7
} from "./chunk-WW7VYUQW.js";
import {
  r as r2
} from "./chunk-FCDEMPPS.js";
import {
  o
} from "./chunk-TEJEYVH4.js";
import {
  u
} from "./chunk-IJHFAZOW.js";
import {
  c,
  d
} from "./chunk-YAQGRU5B.js";
import {
  e as e4
} from "./chunk-46N7XS5M.js";
import {
  e as e2
} from "./chunk-4MKQUQD4.js";
import {
  o as o5
} from "./chunk-A3QLZKCF.js";
import {
  e as e3
} from "./chunk-LGILR4HN.js";
import {
  i2 as i
} from "./chunk-I5UNY2WQ.js";
import {
  n
} from "./chunk-NAB3NF54.js";
import {
  O as O2
} from "./chunk-MDCKEJ7B.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  r
} from "./chunk-RTHP2LNT.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js
var f = 8;
function n3(e8, c4) {
  e8.attributes.add(O.FEATUREVALUE, "vec4");
  const n4 = e8.vertex;
  n4.code.add(n`bool isCapVertex() {
return featureValue.w == 1.0;
}`), n4.uniforms.add(new e3("size", (e9) => e9.size)), c4.vvSize ? (n4.uniforms.add(new e2("vvSizeMinSize", (e9) => e9.vvSizeMinSize)), n4.uniforms.add(new e2("vvSizeMaxSize", (e9) => e9.vvSizeMaxSize)), n4.uniforms.add(new e2("vvSizeOffset", (e9) => e9.vvSizeOffset)), n4.uniforms.add(new e2("vvSizeFactor", (e9) => e9.vvSizeFactor)), n4.code.add(n`vec2 getSize() {
return size * clamp(vvSizeOffset + featureValue.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;
}`)) : n4.code.add(n`vec2 getSize(){
return size;
}`), c4.vvOpacity ? (n4.constants.add("vvOpacityNumber", "int", f), n4.uniforms.add([new o3("vvOpacityValues", (e9) => e9.vvOpacityValues, f), new o3("vvOpacityOpacities", (e9) => e9.vvOpacityOpacities, f)]), n4.code.add(n`vec4 applyOpacity(vec4 color) {
float value = featureValue.z;
if (value <= vvOpacityValues[0]) {
return vec4( color.xyz, vvOpacityOpacities[0]);
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));
}
}
return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);
}`)) : n4.code.add(n`vec4 applyOpacity(vec4 color){
return color;
}`), c4.vvColor ? (n4.constants.add("vvColorNumber", "int", o4), n4.uniforms.add([new o3("vvColorValues", (e9) => e9.vvColorValues, o4), new e6("vvColorColors", (e9) => e9.vvColorColors, o4)]), n4.code.add(n`vec4 getColor() {
float value = featureValue.y;
if (value <= vvColorValues[0]) {
return applyOpacity(vvColorColors[0]);
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));
}
}
return applyOpacity(vvColorColors[vvColorNumber - 1]);
}`)) : n4.code.add(n`vec4 getColor(){
return applyOpacity(vec4(1, 1, 1, 1));
}`), e8.include(o2), e8.attributes.add(O.PROFILERIGHT, "vec4"), e8.attributes.add(O.PROFILEUP, "vec4"), e8.attributes.add(O.PROFILEVERTEXANDNORMAL, "vec4"), n4.code.add(n`vec3 calculateVPos() {
vec2 size = getSize();
vec3 origin = position;
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileVertex = profileVertexAndNormal.xy * size;
vec2 profileNormal = profileVertexAndNormal.zw;
float positionOffsetAlongProfilePlaneNormal = 0.0;
float normalOffsetAlongProfilePlaneNormal = 0.0;`), n4.code.add(n`if(!isCapVertex()) {
vec2 rotationRight = vec2(profileRight.w, profileUp.w);
float maxDistance = length(rotationRight);`), n4.code.add(n`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);
float rx = dot(profileVertex, rotationRight);
if (abs(rx) > maxDistance) {
vec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);
float ry = dot(profileVertex, rotationUp);
profileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;
}
}else{
positionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];
normalOffsetAlongProfilePlaneNormal = profileUp.w;
}
vec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;
return origin + offset;
}`), n4.code.add(n`vec3 localNormal() {
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileNormal = profileVertexAndNormal.zw;
vec3 normal = right * profileNormal.x + up * profileNormal.y;
if(isCapVertex()) {
normal += forward * profileUp.w;
}
return normal;
}`);
}
var p = class extends v {
  constructor() {
    super(...arguments), this.size = r(1, 1);
  }
};

// node_modules/@arcgis/core/chunks/Path.glsl.js
function S(S2) {
  const M2 = new i(), C = d(M2, S2), { vertex: _, fragment: O3 } = M2;
  return M2.varyings.add("vpos", "vec3"), M2.include(n3, S2), S2.output !== o.Color && S2.output !== o.Alpha || (M2.include(r2), M2.include(c3, S2), M2.include(t, S2), M2.varyings.add("vnormal", "vec3"), M2.varyings.add("vcolor", "vec4"), S2.hasMultipassTerrain && M2.varyings.add("depth", "float"), _.code.add(n`
      void main() {
        vpos = calculateVPos();
        vnormal = normalize(localNormal());

        ${S2.hasMultipassTerrain ? "depth = (view * vec4(vpos, 1.0)).z;" : ""}
        gl_Position = transformPosition(proj, view, vpos);

        ${S2.output === o.Color ? "forwardLinearDepth();" : ""}

        vcolor = getColor();
      }
    `)), M2.include(n2, S2), S2.output === o.Alpha && (M2.include(u, S2), O3.uniforms.add(new o5("opacity", (e8) => e8.opacity)), O3.code.add(n`
      void main() {
        discardBySlice(vpos);
        ${S2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        float combinedOpacity = vcolor.a * opacity;
        gl_FragColor = vec4(combinedOpacity);
      }
    `)), S2.output === o.Color && (M2.include(u, S2), M2.include(m, S2), M2.include(a2, S2), M2.include(c3, S2), M2.include(e, S2), c(O3, S2), O3.uniforms.add([C, new e2("ambient", (e8) => e8.ambient), new e2("diffuse", (e8) => e8.diffuse), new e2("specular", (e8) => e8.specular), new o5("opacity", (e8) => e8.opacity), new o5("lightingGlobalFactor", (e8, o7) => o7.lighting.globalFactor), new e2("lightingMainIntensity", (e8, o7) => o7.lighting.mainLight.intensity)]), O3.constants.add("ambientBoostFactor", "float", c2), O3.include(e7), O3.code.add(n`
      void main() {
        discardBySlice(vpos);
        ${S2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}

        shadingParams.viewDirection = normalize(vpos - cameraPosition);
        shadingParams.normalView = vnormal;
        vec3 normal = shadingNormal(shadingParams);
        float ssao = evaluateAmbientOcclusionInverse();

        float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
        ${S2.receiveShadows ? "float shadow = readShadowMap(vpos, linearDepth);" : S2.spherical ? "float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);" : "float shadow = 0.0;"}
        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
        float combinedOpacity = vcolor.a * opacity;
        albedo += 0.25 * specular; // don't completely ignore specular for now

        vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);
        gl_FragColor = vec4(shadedColor, combinedOpacity);
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
        ${S2.transparencyPassType === O2.Color ? "gl_FragColor = premultiplyAlpha(gl_FragColor);" : ""}
      }
    `)), S2.output !== o.Depth && S2.output !== o.Shadow || (M2.include(r2, { hasModelTransformation: false, linearDepth: true }), _.uniforms.add(new e3("nearFar", (e8, o7) => o7.camera.nearFar)), M2.varyings.add("depth", "float"), _.code.add(n`void main() {
vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
}`), M2.include(u, S2), M2.include(e5, S2), O3.code.add(n`void main() {
discardBySlice(vpos);
outputDepth(depth);
}`)), S2.output === o.Normal && (M2.include(r2), M2.include(r3, S2), _.uniforms.add(new e4("viewNormal", (e8, o7) => o7.camera.viewInverseTransposeMatrix)), M2.varyings.add("vnormal", "vec3"), _.code.add(n`void main(void) {
vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);
}`), M2.include(u, S2), O3.uniforms.add(new o6("waterColor")), O3.code.add(n`void main() {
discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
}`)), S2.output === o.Highlight && (M2.include(r2), M2.include(r3, S2), M2.varyings.add("vnormal", "vec3"), _.code.add(n`void main(void) {
vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);
}`), M2.include(u, S2), M2.include(a), O3.code.add(n`void main() {
discardBySlice(vpos);
outputHighlight();
}`)), M2;
}
var M = Object.freeze(Object.defineProperty({ __proto__: null, build: S }, Symbol.toStringTag, { value: "Module" }));

export {
  p,
  S,
  M
};
//# sourceMappingURL=chunk-CYT6A5IX.js.map
