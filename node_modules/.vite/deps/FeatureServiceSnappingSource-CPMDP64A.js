import {
  o as o3
} from "./chunk-AJRWXVO4.js";
import "./chunk-UJ2QT226.js";
import {
  b
} from "./chunk-6A3YBNGJ.js";
import "./chunk-73VW7LOZ.js";
import "./chunk-PJI2LYU5.js";
import "./chunk-3HMF3PNP.js";
import "./chunk-N5C77AAH.js";
import {
  s
} from "./chunk-FLBHQA56.js";
import {
  n as n4
} from "./chunk-KETNREBT.js";
import {
  G,
  Q,
  es
} from "./chunk-7GTYHKA3.js";
import "./chunk-53KI6WDE.js";
import "./chunk-W2HLA6I3.js";
import "./chunk-Q6AASANP.js";
import "./chunk-ZYIEYKCD.js";
import "./chunk-TQLSOIYV.js";
import "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-YZNDHJDJ.js";
import {
  c
} from "./chunk-V7M26XZ7.js";
import {
  p
} from "./chunk-2LGANX7J.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import {
  S,
  p as p2
} from "./chunk-HR2OX32D.js";
import "./chunk-7ZPDA3EC.js";
import {
  n as n3
} from "./chunk-U7B2WKBH.js";
import {
  a,
  d as d2
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  h,
  l
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  f,
  o as o2
} from "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import {
  i
} from "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import {
  o
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n2 as n,
  n8 as n2,
  t2,
  y3 as y2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  y
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/tileUtils.js
function t3(n6, o4) {
  return Q(o4.extent, e2), es(e2, o(a2, n6.x, n6.y, 0));
}
var e2 = G();
var a2 = n3();

// node_modules/@arcgis/core/views/2d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles2D.js
var p3 = class extends y2 {
  constructor(e3) {
    super(e3), this.pointOfInterest = null;
  }
  get tiles() {
    const e3 = this.tilesCoveringView, t4 = r(this.pointOfInterest) ? this.pointOfInterest : this.view.center;
    return e3.sort((e4, r2) => t3(t4, e4) - t3(t4, r2)), e3;
  }
  _scaleEnabled() {
    return c(this.view.scale, this.layer.minScale || 0, this.layer.maxScale || 0);
  }
  get tilesCoveringView() {
    if (!this.view.ready || !this.view.featuresTilingScheme || !this.view.state || t(this.tileInfo))
      return [];
    if (!this._scaleEnabled)
      return [];
    const { spans: e3, lodInfo: t4 } = this.view.featuresTilingScheme.getTileCoverage(this.view.state, 0), { level: r2 } = t4, o4 = [];
    for (const { row: i2, colFrom: s2, colTo: l3 } of e3)
      for (let e4 = s2; e4 <= l3; e4++) {
        const s3 = { id: null, level: r2, row: i2, col: t4.normalizeCol(e4) };
        this.tileInfo.updateTileInfo(s3), o4.push(s3);
      }
    return o4;
  }
  get tileInfo() {
    var _a;
    return ((_a = this.view.featuresTilingScheme) == null ? void 0 : _a.tileInfo) ?? null;
  }
  get tileSize() {
    return r(this.tileInfo) ? this.tileInfo.size[0] : 256;
  }
  initialize() {
    this.own(l(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.state) == null ? void 0 : _b.viewpoint;
    }, () => this.notifyChange("tilesCoveringView"), U));
  }
};
e([d({ readOnly: true })], p3.prototype, "tiles", null), e([d({ readOnly: true })], p3.prototype, "_scaleEnabled", null), e([d({ readOnly: true })], p3.prototype, "tilesCoveringView", null), e([d({ readOnly: true })], p3.prototype, "tileInfo", null), e([d({ readOnly: true })], p3.prototype, "tileSize", null), e([d({ constructOnly: true })], p3.prototype, "view", void 0), e([d({ constructOnly: true })], p3.prototype, "layer", void 0), e([d()], p3.prototype, "pointOfInterest", void 0), p3 = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles2D")], p3);

// node_modules/@arcgis/core/views/3d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles3D.js
var p4 = class extends d2 {
  constructor(e3) {
    super(e3), this.pointOfInterest = null;
  }
  get tiles() {
    const e3 = this.tilesCoveringView, t4 = this.effectivePointOfInterest;
    if (r(t4)) {
      const r2 = e3.map((e4) => t3(t4, e4));
      for (let i2 = 1; i2 < r2.length; i2++)
        if (r2[i2 - 1] > r2[i2])
          return e3.sort((e4, r3) => t3(t4, e4) - t3(t4, r3)), e3.slice();
    }
    return e3;
  }
  get tilesCoveringView() {
    var _a, _b;
    return this._filterTiles((_b = (_a = this.view.featureTiles) == null ? void 0 : _a.tiles) == null ? void 0 : _b.toArray()).map(u2);
  }
  get tileInfo() {
    var _a;
    return ((_a = this.view.featureTiles) == null ? void 0 : _a.tilingScheme.toTileInfo()) ?? null;
  }
  get tileSize() {
    var _a;
    return ((_a = this.view.featureTiles) == null ? void 0 : _a.tileSize) ?? 256;
  }
  get effectivePointOfInterest() {
    var _a;
    const e3 = this.pointOfInterest;
    return r(e3) ? e3 : (_a = this.view.pointsOfInterest) == null ? void 0 : _a.focus.location;
  }
  initialize() {
    this.handles.add(l(() => this.view.featureTiles, (e3) => {
      this.handles.remove(m), e3 && this.handles.add(e3.addClient(), m);
    }, h));
  }
  _filterTiles(e3) {
    if (t(e3))
      return [];
    return e3.filter((e4) => Math.abs(e4.measures.screenRect[3] - e4.measures.screenRect[1]) > f2 && e4.measures.visibility === s.VISIBLE_ON_SURFACE);
  }
};
function u2({ lij: [e3, t4, r2], extent: i2 }) {
  return { id: `${e3}/${t4}/${r2}`, level: e3, row: t4, col: r2, extent: i2 };
}
e([d({ readOnly: true })], p4.prototype, "tiles", null), e([d({ readOnly: true })], p4.prototype, "tilesCoveringView", null), e([d({ readOnly: true })], p4.prototype, "tileInfo", null), e([d({ readOnly: true })], p4.prototype, "tileSize", null), e([d({ constructOnly: true })], p4.prototype, "view", void 0), e([d()], p4.prototype, "pointOfInterest", void 0), e([d()], p4.prototype, "effectivePointOfInterest", null), p4 = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles3D")], p4);
var f2 = 50;
var m = "feature-tiles";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/WorkerTileTreeDebugger.js
var d3 = class extends b {
  constructor(e3) {
    super(e3), this.handles = new u();
  }
  initialize() {
    const e3 = setInterval(() => this._fetchDebugInfo(), 2e3);
    this.handles.add(n(() => clearInterval(e3)));
  }
  destroy() {
    this.handles.destroy();
  }
  getTiles() {
    if (!this.debugInfo)
      return [];
    const e3 = /* @__PURE__ */ new Map(), t4 = /* @__PURE__ */ new Map();
    this.debugInfo.storedTiles.forEach((t5) => {
      e3.set(t5.data.id, t5.featureCount);
    }), this.debugInfo.pendingTiles.forEach((r3) => {
      e3.set(r3.data.id, r3.featureCount), t4.set(r3.data.id, r3.state);
    });
    const r2 = (r3) => {
      const o5 = t4.get(r3), s2 = e3.get(r3) ?? "?";
      return o5 ? `${o5}:${s2}
${r3}` : `store:${s2}
${r3}`;
    }, o4 = /* @__PURE__ */ new Map();
    return this.debugInfo.storedTiles.forEach((e4) => {
      o4.set(e4.data.id, e4.data);
    }), this.debugInfo.pendingTiles.forEach((e4) => {
      o4.set(e4.data.id, e4.data);
    }), Array.from(o4.values()).map((e4) => ({ lij: [e4.level, e4.row, e4.col], geometry: v.fromExtent(f(e4.extent, this.view.spatialReference)), label: r2(e4.id) }));
  }
  _fetchDebugInfo() {
    this.handle.getDebugInfo(null).then((e3) => {
      this.debugInfo = e3, this.update();
    });
  }
};
e([d({ constructOnly: true })], d3.prototype, "handle", void 0), d3 = e([n2("esri.views.interactive.snapping.featureSources.WorkerTileTreeDebugger")], d3);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorkerHandle.js
var l2 = class extends d2 {
  constructor(e3) {
    super(e3), this.availability = 0, this.workerHandleUpdating = true, this.editId = 0;
  }
  get updating() {
    return this.updatingHandles.updating || this.workerHandleUpdating;
  }
  destroy() {
    this.workerHandle.destroy();
  }
  initialize() {
    this.workerHandle = new p5(this.schedule), this.handles.add([this.workerHandle.on("notify-updating", ({ updating: e3 }) => this.workerHandleUpdating = e3), this.workerHandle.on("notify-availability", ({ availability: e3 }) => this._set("availability", e3))]);
  }
  async setup(e3, t4) {
    const r2 = this._serviceInfoFromLayer(e3.layer);
    if (t(r2))
      return;
    const o4 = { configuration: this._convertConfiguration(e3.configuration), serviceInfo: r2, spatialReference: e3.spatialReference.toJSON() };
    await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("setup", o4, t4)), this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  async configure(e3, t4) {
    const i2 = this._convertConfiguration(e3);
    await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("configure", i2, t4)), this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  async refresh(e3) {
    await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("refresh", {}, e3)), this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating", {}, e3));
  }
  async fetchCandidates(e3, t4) {
    const i2 = { distance: e3.distance, point: e3.coordinateHelper.vectorToPoint(e3.point).toJSON(), types: e3.types, filter: r(e3.filter) ? e3.filter.createQuery().toJSON() : null };
    return this.workerHandle.invoke(i2, t4);
  }
  async updateTiles(e3, t4) {
    const i2 = { tiles: e3.tiles, tileInfo: r(e3.tileInfo) ? e3.tileInfo.toJSON() : null, tileSize: e3.tileSize };
    await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("updateTiles", i2, t4)), this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  async applyEdits(e3, t4) {
    var _a, _b, _c;
    const i2 = this.editId++, r2 = { id: i2 };
    await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("beginApplyEdits", r2, t4));
    const a3 = await this.updatingHandles.addPromise(y(e3.result, t4)), s2 = { id: i2, edits: { addedFeatures: ((_a = a3.addedFeatures) == null ? void 0 : _a.map(({ objectId: e4 }) => e4)) ?? [], deletedFeatures: ((_b = a3.deletedFeatures) == null ? void 0 : _b.map(({ objectId: e4, globalId: t5 }) => ({ objectId: e4, globalId: t5 }))) ?? [], updatedFeatures: ((_c = a3.updatedFeatures) == null ? void 0 : _c.map(({ objectId: e4 }) => e4)) ?? [] } };
    await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("endApplyEdits", s2, t4)), this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating", {}, t4));
  }
  getDebugInfo(e3) {
    return this.workerHandle.invokeMethod("getDebugInfo", {}, e3);
  }
  _convertConfiguration(e3) {
    return { filter: r(e3.filter) ? e3.filter.toJSON() : null, customParameters: e3.customParameters };
  }
  _serviceInfoFromLayer(e3) {
    var _a;
    return "multipatch" === e3.geometryType || "mesh" === e3.geometryType ? null : { url: e3.parsedUrl.path, fields: e3.fields.map((e4) => e4.toJSON()), geometryType: i.toJSON(e3.geometryType), capabilities: e3.capabilities, objectIdField: e3.objectIdField, globalIdField: e3.globalIdField, spatialReference: e3.spatialReference.toJSON(), timeInfo: (_a = e3.timeInfo) == null ? void 0 : _a.toJSON() };
  }
};
e([d({ constructOnly: true })], l2.prototype, "schedule", void 0), e([d({ readOnly: true })], l2.prototype, "updating", null), e([d({ readOnly: true })], l2.prototype, "availability", void 0), e([d()], l2.prototype, "workerHandleUpdating", void 0), l2 = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")], l2);
var p5 = class extends n4 {
  constructor(e3) {
    super("FeatureServiceSnappingSourceWorker", "fetchCandidates", {}, e3, { strategy: "dedicated" });
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTilesSimple.js
var n5 = class extends y2 {
  constructor(e3) {
    super(e3), this.pointOfInterest = null;
  }
  get tiles() {
    return [{ id: "0/0/0", level: 0, row: 0, col: 0, extent: o2(-1e8, -1e8, 1e8, 1e8) }];
  }
  get tileInfo() {
    return new S({ origin: new j({ x: -1e8, y: 1e8, spatialReference: this.layer.spatialReference }), size: [512, 512], lods: [new p2({ level: 0, scale: 1, resolution: 390625 })], spatialReference: this.layer.spatialReference });
  }
  get tileSize() {
    return this.tileInfo.size[0];
  }
};
e([d({ readOnly: true })], n5.prototype, "tiles", null), e([d({ readOnly: true })], n5.prototype, "tileInfo", null), e([d({ readOnly: true })], n5.prototype, "tileSize", null), e([d({ constructOnly: true })], n5.prototype, "layer", void 0), e([d()], n5.prototype, "pointOfInterest", void 0), n5 = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTilesSimple")], n5);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/FeatureServiceSnappingSource.js
var g = class extends a(y2) {
  constructor(e3) {
    super(e3);
  }
  get updateTilesParameters() {
    return { tiles: this.tilesOfInterest.tiles, tileInfo: this.tilesOfInterest.tileInfo, tileSize: this.tilesOfInterest.tileSize };
  }
  get updating() {
    return this.workerHandle.updating || this.updatingHandles.updating;
  }
  get configuration() {
    return { filter: this.layer.createQuery(), customParameters: this.layer.customParameters };
  }
  get availability() {
    return this.workerHandle.availability;
  }
  get layer() {
    return this.layerSource.layer;
  }
  initialize() {
    const e3 = this.view;
    if (r(e3))
      switch (e3.type) {
        case "2d":
          this.tilesOfInterest = new p3({ view: e3, layer: this.layer }), this.workerHandle = new l2();
          break;
        case "3d": {
          const r2 = e3.resourceController;
          this.tilesOfInterest = new p4({ view: e3 }), this.workerHandle = new l2({ schedule: (e4) => r2.schedule(e4) });
          break;
        }
      }
    else
      this.tilesOfInterest = new n5({ layer: this.layer }), this.workerHandle = new l2();
    this.handles.add([t2(this.workerHandle)]), this.workerHandle.setup({ layer: this.layer, spatialReference: this.spatialReference, configuration: this.configuration }, null), this.updatingHandles.add(() => this.updateTilesParameters, () => this.workerHandle.updateTiles(this.updateTilesParameters, null), h), this.handles.add([l(() => this.configuration, (e4) => this.workerHandle.configure(e4, null), U)]), r(e3) && this.handles.add(l(() => p.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES, (r2) => {
      r2 && !this.debug ? (this.debug = new d3({ view: e3, handle: this.workerHandle }), this.handles.add(t2(this.debug), "debug")) : !r2 && this.debug && this.handles.remove("debug");
    }, h)), this.handles.add(this.layerSource.layer.on("apply-edits", (e4) => {
      this.workerHandle.applyEdits(e4, null);
    }));
  }
  refresh() {
    this.workerHandle.refresh(null);
  }
  async fetchCandidates(e3, r2) {
    return this.tilesOfInterest.pointOfInterest = e3.coordinateHelper.vectorToPoint(e3.point), (await this.workerHandle.fetchCandidates({ ...e3, filter: null }, r2)).candidates.map((r3) => o3(r3, e3.coordinateHelper, e3.elevationInfo));
  }
  getDebugInfo(e3) {
    return this.workerHandle.getDebugInfo(e3);
  }
};
e([d({ constructOnly: true })], g.prototype, "spatialReference", void 0), e([d({ constructOnly: true })], g.prototype, "layerSource", void 0), e([d({ constructOnly: true })], g.prototype, "view", void 0), e([d()], g.prototype, "tilesOfInterest", void 0), e([d({ readOnly: true })], g.prototype, "updateTilesParameters", null), e([d({ readOnly: true })], g.prototype, "updating", null), e([d({ readOnly: true })], g.prototype, "configuration", null), e([d({ readOnly: true })], g.prototype, "availability", null), g = e([n2("esri.views.interactive.snapping.featureSources.FeatureServiceSnappingSource")], g);
export {
  g as FeatureServiceSnappingSource
};
//# sourceMappingURL=FeatureServiceSnappingSource-CPMDP64A.js.map
