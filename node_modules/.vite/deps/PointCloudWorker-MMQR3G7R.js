import {
  a,
  c,
  f,
  m
} from "./chunk-O5HWALWY.js";
import "./chunk-Q2LKCV6V.js";
import {
  e
} from "./chunk-7CXXTQLM.js";
import {
  n,
  r as r2
} from "./chunk-MLAOYRDT.js";
import "./chunk-VMF4NMEB.js";
import {
  S as S2
} from "./chunk-DLM6NKXW.js";
import "./chunk-TQLSOIYV.js";
import "./chunk-LUU3J646.js";
import {
  Un
} from "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import {
  S
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  o2 as o,
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/3d/layers/PointCloudWorker.js
var c2 = class {
  transform(e2) {
    const a2 = this._transform(e2), o2 = [a2.points.buffer, a2.rgb.buffer];
    r(a2.pointIdFilterMap) && o2.push(a2.pointIdFilterMap.buffer);
    for (const t of a2.attributes)
      "buffer" in t.values && o(t.values.buffer) && t.values.buffer !== a2.rgb.buffer && o2.push(t.values.buffer);
    return Promise.resolve({ result: a2, transferList: o2 });
  }
  _transform(r3) {
    const e2 = c(r3.schema, r3.geometryBuffer);
    let a2 = e2.length / 3, o2 = null;
    const f2 = [], s = a(r3.primaryAttributeData, e2, a2);
    r(r3.primaryAttributeData) && s && f2.push({ attributeInfo: r3.primaryAttributeData.attributeInfo, values: s });
    const i = a(r3.modulationAttributeData, e2, a2);
    r(r3.modulationAttributeData) && i && f2.push({ attributeInfo: r3.modulationAttributeData.attributeInfo, values: i });
    let c3 = f(r3.rendererInfo, s, i, a2);
    if (r3.filterInfo && r3.filterInfo.length > 0 && r(r3.filterAttributesData)) {
      const t = r3.filterAttributesData.map((t2) => {
        const r4 = a(t2, e2, a2), o3 = { attributeInfo: t2.attributeInfo, values: r4 };
        return f2.push(o3), o3;
      });
      o2 = new Uint32Array(a2), a2 = m(e2, c3, o2, r3.filterInfo, t);
    }
    for (const t of r3.userAttributesData) {
      const r4 = a(t, e2, a2);
      f2.push({ attributeInfo: t.attributeInfo, values: r4 });
    }
    3 * a2 < c3.length && (c3 = new Uint8Array(c3.buffer.slice(0, 3 * a2))), this._applyElevationOffsetInPlace(e2, a2, r3.elevationOffset);
    const p2 = this._transformCoordinates(e2, a2, r3.obb, k.fromJSON(r3.inSR), k.fromJSON(r3.outSR));
    return { obb: r3.obb, points: p2, rgb: c3, attributes: f2, pointIdFilterMap: o2 };
  }
  _transformCoordinates(t, r3, a2, n2, u) {
    if (!Un(t, n2, 0, t, u, 0, r3))
      throw Error("Can't reproject");
    const l = r2(a2.center[0], a2.center[1], a2.center[2]), b = n(), m2 = n();
    S2(p, a2.quaternion);
    const c3 = new Float32Array(3 * r3);
    for (let e2 = 0; e2 < r3; e2++)
      b[0] = t[3 * e2] - l[0], b[1] = t[3 * e2 + 1] - l[1], b[2] = t[3 * e2 + 2] - l[2], S(m2, b, p), a2.halfSize[0] = Math.max(a2.halfSize[0], Math.abs(m2[0])), a2.halfSize[1] = Math.max(a2.halfSize[1], Math.abs(m2[1])), a2.halfSize[2] = Math.max(a2.halfSize[2], Math.abs(m2[2])), c3[3 * e2] = b[0], c3[3 * e2 + 1] = b[1], c3[3 * e2 + 2] = b[2];
    return c3;
  }
  _applyElevationOffsetInPlace(t, r3, e2) {
    if (0 !== e2)
      for (let a2 = 0; a2 < r3; a2++)
        t[3 * a2 + 2] += e2;
  }
};
var p = e();
function h() {
  return new c2();
}
export {
  h as default
};
//# sourceMappingURL=PointCloudWorker-MMQR3G7R.js.map
