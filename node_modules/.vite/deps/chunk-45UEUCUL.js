import {
  p
} from "./chunk-TMSBC6BS.js";
import {
  b
} from "./chunk-SIH2IMSA.js";
import {
  n as n2
} from "./chunk-6DWU2ZQF.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  k
} from "./chunk-U3PSONS6.js";
import {
  s
} from "./chunk-CVWDM4C7.js";

// node_modules/@arcgis/core/support/collectionUtils.js
function t(t2) {
  return new p({ getCollections: () => [t2.tables, t2.layers], getChildrenFunction: (e2) => {
    const t3 = [];
    return "tables" in e2 && t3.push(e2.tables), "layers" in e2 && t3.push(e2.layers), t3;
  }, itemFilterFunction: (e2) => {
    const t3 = e2.parent;
    return t3 && "tables" in t3 && t3.tables.includes(e2);
  } });
}

// node_modules/@arcgis/core/support/LayersMixin.js
function n3(e2, r, t2) {
  let s2, o;
  if (e2)
    for (let a2 = 0, i = e2.length; a2 < i; a2++) {
      if (s2 = e2.getItemAt(a2), s2[r] === t2)
        return s2;
      if ("group" === (s2 == null ? void 0 : s2.type) && (o = n3(s2.layers, r, t2), o))
        return o;
    }
}
var d2 = s.getLogger("esri.support.LayersMixin");
var y = (s2) => {
  let y2 = class extends s2 {
    constructor(...e2) {
      super(...e2), this.layers = new j();
      const t2 = (e3) => {
        e3.parent && "remove" in e3.parent && e3.parent.remove(e3);
      }, s3 = (e3) => {
        e3.parent = this, this.layerAdded(e3), "elevation" !== e3.type && "base-elevation" !== e3.type || d2.error(`Layer 'title:${e3.title}, id:${e3.id}' of type '${e3.type}' is not supported as an operational layer and will therefore be ignored.`);
      }, o = (e3) => {
        e3.parent = null, this.layerRemoved(e3);
      };
      this.layers.on("before-add", (e3) => t2(e3.item)), this.layers.on("after-add", (e3) => s3(e3.item)), this.layers.on("after-remove", (e3) => o(e3.item));
    }
    destroy() {
      const e2 = this.layers.removeAll();
      for (const r of e2)
        this.layerRemoved(r), r.destroy();
      this.layers.destroy();
    }
    set layers(e2) {
      this._set("layers", n2(e2, this._get("layers")));
    }
    add(e2, r) {
      const t2 = this.layers;
      if (r = t2.getNextIndex(r), e2 instanceof b) {
        const s3 = e2;
        s3.parent === this ? this.reorder(s3, r) : t2.add(s3, r);
      } else
        k(e2) ? e2.then((e3) => {
          this.destroyed || this.add(e3, r);
        }) : d2.error("#add()", "The item being added is not a Layer or a Promise that resolves to a Layer.");
    }
    addMany(e2, r) {
      const t2 = this.layers;
      r = t2.getNextIndex(r), e2.slice().forEach((e3) => {
        e3.parent !== this ? (t2.add(e3, r), r += 1) : this.reorder(e3, r);
      });
    }
    findLayerById(e2) {
      return n3(this.layers, "id", e2);
    }
    findLayerByUid(e2) {
      return n3(this.layers, "uid", e2);
    }
    remove(e2) {
      return this.layers.remove(e2);
    }
    removeMany(e2) {
      return this.layers.removeMany(e2);
    }
    removeAll() {
      return this.layers.removeAll();
    }
    reorder(e2, r) {
      return this.layers.reorder(e2, r);
    }
    layerAdded(e2) {
    }
    layerRemoved(e2) {
    }
  };
  return e([d()], y2.prototype, "layers", null), y2 = e([n("esri.support.LayersMixin")], y2), y2;
};

// node_modules/@arcgis/core/support/TablesMixin.js
var a = "esri.support.TablesMixin";
var l = s.getLogger(a);
function n4(t2, e2, r) {
  if (t2)
    for (let s2 = 0, o = t2.length; s2 < o; s2++) {
      const o2 = t2.getItemAt(s2);
      if (o2[e2] === r)
        return o2;
      if ("group" === (o2 == null ? void 0 : o2.type)) {
        const t3 = n4(o2.tables, e2, r);
        if (t3)
          return t3;
      }
    }
}
var p2 = (s2) => {
  let p3 = class extends s2 {
    constructor(...t2) {
      super(...t2), this.tables = new j(), this.tables.on("after-add", (t3) => {
        const e2 = t3.item;
        e2.parent && e2.parent !== this && "tables" in e2.parent && e2.parent.tables.remove(e2), e2.parent = this, "feature" !== e2.type && l.error(`Layer 'title:${e2.title}, id:${e2.id}' of type '${e2.type}' is not supported as a table and will therefore be ignored.`);
      }), this.tables.on("after-remove", (t3) => {
        t3.item.parent = null;
      });
    }
    destroy() {
      const t2 = this.tables.removeAll();
      for (const e2 of t2)
        e2.destroy();
      this.tables.destroy();
    }
    set tables(t2) {
      this._set("tables", n2(t2, this._get("tables")));
    }
    findTableById(t2) {
      return n4(this.tables, "id", t2);
    }
    findTableByUid(t2) {
      return n4(this.tables, "uid", t2);
    }
  };
  return e([d()], p3.prototype, "tables", null), p3 = e([n(a)], p3), p3;
};

export {
  t,
  y,
  p2 as p
};
//# sourceMappingURL=chunk-45UEUCUL.js.map
