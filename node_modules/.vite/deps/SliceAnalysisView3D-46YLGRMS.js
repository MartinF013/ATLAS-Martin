import {
  $e,
  At,
  C as C2,
  Je,
  Ke,
  Lt,
  Mt,
  Pt,
  Qe,
  Rt,
  S,
  Tt,
  U as U2,
  Vt,
  We,
  Ye,
  a as a4,
  b as b2,
  dt,
  gt,
  h,
  i as i2,
  it,
  j as j2,
  k,
  l as l4,
  m as m2,
  mt,
  o as o2,
  p as p5,
  pt,
  qe,
  rt,
  tt,
  ut,
  x as x2
} from "./chunk-V4UDBBB4.js";
import "./chunk-3MW65G3U.js";
import {
  C
} from "./chunk-RED2ALFM.js";
import {
  a as a2
} from "./chunk-FDKIF5RK.js";
import {
  c as c3,
  m
} from "./chunk-GAAASXOF.js";
import {
  a as a3
} from "./chunk-R5LRVAQP.js";
import {
  O
} from "./chunk-EEPTXXKK.js";
import {
  n as n4
} from "./chunk-KQRXZVEP.js";
import "./chunk-OGZ4KF5L.js";
import "./chunk-JYMQQ22E.js";
import "./chunk-JYWDI7GA.js";
import "./chunk-MQZSD3AZ.js";
import "./chunk-PT7GCS5M.js";
import "./chunk-ZO4P57E5.js";
import "./chunk-7Y6VVOP3.js";
import {
  E
} from "./chunk-2FLJ43TR.js";
import "./chunk-EY24INV2.js";
import "./chunk-3DTDACBY.js";
import "./chunk-ZG7SHSSS.js";
import "./chunk-QFYBIFWB.js";
import {
  p as p4
} from "./chunk-22MSECLU.js";
import "./chunk-PTJ3MGYO.js";
import "./chunk-DSCM4HDL.js";
import "./chunk-ZGXOGFCR.js";
import {
  s as s3
} from "./chunk-WGMCNMOI.js";
import "./chunk-76A4CWFG.js";
import {
  r as r3
} from "./chunk-KYD2B4O6.js";
import "./chunk-PUU4QXN5.js";
import "./chunk-EHWEX2VK.js";
import "./chunk-HPO2NV7P.js";
import "./chunk-22O7HU3A.js";
import "./chunk-Y75V5CF3.js";
import "./chunk-PQM6RARY.js";
import "./chunk-2Y5KPYOJ.js";
import "./chunk-BBUIX72C.js";
import "./chunk-5ZS6RUSM.js";
import "./chunk-R3PFJUIG.js";
import "./chunk-7LH2XNVI.js";
import "./chunk-PXOPYXIX.js";
import "./chunk-WSQIVEW5.js";
import "./chunk-ZTFWVZTL.js";
import "./chunk-ELZC3DZT.js";
import "./chunk-TGUQXVQU.js";
import "./chunk-4LQ6NAOX.js";
import "./chunk-K37I5IIG.js";
import "./chunk-GKYJJGE3.js";
import "./chunk-AWIG2DGF.js";
import "./chunk-3236UEJN.js";
import "./chunk-KSOWE6GO.js";
import "./chunk-ZLORWBMB.js";
import "./chunk-OZAI2STL.js";
import "./chunk-CNL2CHF7.js";
import "./chunk-HRAEK6P4.js";
import "./chunk-K6UIDSFF.js";
import "./chunk-52W4YMC2.js";
import "./chunk-AIONJO5O.js";
import "./chunk-YLSPLHY5.js";
import "./chunk-4GGQTXXY.js";
import "./chunk-QMP4VG7M.js";
import "./chunk-5RP42VZJ.js";
import "./chunk-KD6KBT2L.js";
import "./chunk-XEWFCJLT.js";
import "./chunk-ZEDAE7EU.js";
import "./chunk-YXFNNKMT.js";
import "./chunk-7OZR6JFF.js";
import "./chunk-NXOQBIK7.js";
import "./chunk-ERNXFM5T.js";
import "./chunk-6ITXWFMK.js";
import "./chunk-SV4VP57N.js";
import "./chunk-5LWMNFCG.js";
import "./chunk-PWYPPSAW.js";
import "./chunk-5EXPMKQP.js";
import "./chunk-B7F3T673.js";
import "./chunk-QXYW5CVF.js";
import "./chunk-Z7AZMEL6.js";
import "./chunk-FUKESVWQ.js";
import "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-XEIRRA3E.js";
import "./chunk-B3IXFXV6.js";
import "./chunk-XNOIZLCR.js";
import "./chunk-I22L7HNU.js";
import "./chunk-44UD36FH.js";
import "./chunk-ODYLXHP4.js";
import "./chunk-Y5AGUEHG.js";
import "./chunk-DVE4HUBR.js";
import "./chunk-RC6OMMF6.js";
import "./chunk-AWPZQDE5.js";
import "./chunk-OYNEZ5VG.js";
import "./chunk-R67CDTDF.js";
import "./chunk-UCWSHVC4.js";
import "./chunk-DHZ2TSD5.js";
import "./chunk-FAF3GP2W.js";
import "./chunk-YSWURJZW.js";
import "./chunk-5JKCNCL2.js";
import "./chunk-2YDCEMEJ.js";
import "./chunk-O7YSDCZE.js";
import "./chunk-767LZ6IM.js";
import "./chunk-TTKSAULB.js";
import "./chunk-WJDUBZ7S.js";
import "./chunk-DNPZNIDB.js";
import "./chunk-WW7VYUQW.js";
import "./chunk-FCDEMPPS.js";
import "./chunk-TEJEYVH4.js";
import "./chunk-HEZ2ATGC.js";
import "./chunk-AALA53RH.js";
import "./chunk-BOVIIQLB.js";
import "./chunk-IJHFAZOW.js";
import "./chunk-DMGVDNFD.js";
import "./chunk-YAQGRU5B.js";
import "./chunk-M3GMIUQS.js";
import "./chunk-BMA2CXVS.js";
import "./chunk-46N7XS5M.js";
import "./chunk-4MKQUQD4.js";
import "./chunk-A3QLZKCF.js";
import "./chunk-OYAHQ564.js";
import "./chunk-LGILR4HN.js";
import "./chunk-I5UNY2WQ.js";
import "./chunk-EYJ2F5XB.js";
import "./chunk-5EPJG7SL.js";
import "./chunk-TR3U55RZ.js";
import "./chunk-3DCTMZI6.js";
import "./chunk-33INAWJA.js";
import "./chunk-5WOO2FX6.js";
import "./chunk-FPMD6IB4.js";
import "./chunk-J73IXFNW.js";
import "./chunk-MQBVOUKB.js";
import "./chunk-EOJGYH5X.js";
import {
  N
} from "./chunk-4CRT3CQZ.js";
import "./chunk-EJ4V43KX.js";
import "./chunk-PLLZPG4O.js";
import {
  t as t5,
  x
} from "./chunk-WQLER7IU.js";
import {
  D,
  G,
  X,
  ms
} from "./chunk-7GTYHKA3.js";
import "./chunk-MOXYEJRV.js";
import "./chunk-EEJIELE6.js";
import "./chunk-Y55TYMBP.js";
import "./chunk-NAB3NF54.js";
import "./chunk-MHB3L22D.js";
import "./chunk-MDCKEJ7B.js";
import "./chunk-MLAOYRDT.js";
import "./chunk-VMF4NMEB.js";
import "./chunk-NAIF4GWX.js";
import "./chunk-72PB636Q.js";
import "./chunk-RIOXX6J2.js";
import "./chunk-SOZCO2CU.js";
import {
  W,
  Z,
  p2 as p3,
  q2 as q3
} from "./chunk-53KI6WDE.js";
import {
  d as d3
} from "./chunk-W2HLA6I3.js";
import "./chunk-Q6AASANP.js";
import {
  c as c2,
  f,
  t as t4
} from "./chunk-ZYIEYKCD.js";
import "./chunk-DLM6NKXW.js";
import "./chunk-TQLSOIYV.js";
import "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-3NPGGTI6.js";
import "./chunk-G4ERZR5M.js";
import "./chunk-GRW2GUB3.js";
import {
  n as n3
} from "./chunk-RBVTRJPJ.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-ZZCCRN4U.js";
import "./chunk-TWQ374WD.js";
import "./chunk-GT2OBOXC.js";
import "./chunk-Z3S5X75I.js";
import "./chunk-YK4ZKK2Q.js";
import "./chunk-NMRWU44S.js";
import "./chunk-LBBA3SFR.js";
import "./chunk-2KZBVPWA.js";
import "./chunk-CXIMLSDF.js";
import "./chunk-ZDSMRGKC.js";
import "./chunk-I6H66HCE.js";
import "./chunk-4P4OV7G6.js";
import "./chunk-ZUDEVIXR.js";
import "./chunk-RRFFPL7N.js";
import "./chunk-JYR7GBAU.js";
import "./chunk-IG4CY4XM.js";
import "./chunk-HB4HVKJV.js";
import "./chunk-CC32E45Q.js";
import "./chunk-V7M26XZ7.js";
import "./chunk-ZN2MGN4S.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-XZTXACPW.js";
import "./chunk-EHYYP2L2.js";
import "./chunk-ZUEYZA7M.js";
import "./chunk-74GUBHRJ.js";
import "./chunk-E447OCKN.js";
import "./chunk-LPU5TMA4.js";
import "./chunk-25QHXOZB.js";
import "./chunk-AA7FGPNP.js";
import "./chunk-UHJVTABQ.js";
import "./chunk-W66LN57L.js";
import "./chunk-PNUWGOXY.js";
import "./chunk-FUQI3AAI.js";
import "./chunk-22YODLVL.js";
import "./chunk-TB42IUV7.js";
import "./chunk-ZWMYDR2G.js";
import "./chunk-ZZY5IDKU.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-6FKG7JUE.js";
import "./chunk-PZWU5EHT.js";
import "./chunk-CQSGZXR7.js";
import "./chunk-7LOJJ46D.js";
import "./chunk-VNR743PA.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-SWCA522B.js";
import "./chunk-YPIBZ3CH.js";
import "./chunk-XLCZFN6R.js";
import "./chunk-OMNBM2E4.js";
import "./chunk-WKHS6QIX.js";
import "./chunk-6O7ZZEV7.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-OBCAVCXI.js";
import "./chunk-RFOZTYJH.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-L2YBXQTH.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-4XBERLPX.js";
import "./chunk-HR2OX32D.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-SZPDY7KN.js";
import "./chunk-Y6YGVGFR.js";
import "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import "./chunk-MZX3HN4G.js";
import "./chunk-T47JAOQZ.js";
import "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-RIWDMEW4.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import {
  l as l3
} from "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-OG6CQEZJ.js";
import "./chunk-X5Z3DJQ4.js";
import "./chunk-BUWXVMJU.js";
import "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import "./chunk-D3XXPCBB.js";
import "./chunk-OWBMOIIV.js";
import {
  b
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  j,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import {
  p as p2,
  q as q2,
  u as u3
} from "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import {
  c,
  d as d2,
  i
} from "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import {
  L,
  P,
  o,
  q,
  r as r2,
  s as s2,
  u,
  z
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import {
  n as n2,
  t as t3
} from "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  A,
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  t as t2
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  a2 as a,
  e as e2,
  l,
  p,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/3d/analysis/Slice/SliceController.js
var V = s.getLogger("esri.views.3d.analysis.Slice.SliceController");
var g = class extends y {
  constructor(e3) {
    super(e3), this._handles = new u2(), this._internalChange = false, this._currentSlicePlane = null, this.state = "ready";
  }
  get ready() {
    return "ready" === this.state;
  }
  initialize() {
    this._handles.add(this.analysis.excludedLayers.on("before-add", (e3) => {
      const i3 = e3.item;
      null != i3 && (i3 instanceof b || i3 instanceof E) ? i3 instanceof b && N(i3) ? (V.error("excludedLayers", `Layer '${i3.title}, id:${i3.id}' of type '${i3.type}' can not be individually excluded from slicing. Use 'excludeGroundSurface' instead.`), e3.preventDefault()) : this.analysis.excludedLayers.includes(i3) && e3.preventDefault() : (V.error("excludedLayers", "Invalid layer type, layer must derive from Layer or BuildingComponentSublayer"), e3.preventDefault());
    })), C3(this.view, this), this._handles.add([l2(() => this.analysisViewData.plane, () => {
      this._internalChange || this._updateSlicePlaneFromBoundedPlane(), this._updateLayerViews();
    }, { sync: true }), l2(() => this.analysis.excludeGroundSurface, () => this._updateLayerViews(), { sync: true }), this.analysis.excludedLayers.on("change", () => this._updateLayerViews()), l2(() => [this.analysisViewData.active, this.analysisViewData.visible], () => {
      this._updateActiveController(), this._updateViewSlicePlane();
    }, { sync: true }), l2(() => this._allLayerAndSubLayerViews, () => this._updateLayerViews())]), this._handles.add([l2(() => this.analysis.shape, () => {
      this._internalChange || (this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane());
    }, { sync: true })], "analysis"), this._set("state", "ready"), this._updateActiveController(), this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane();
  }
  destroy() {
    "destroyed" !== this.state && (this.analysisViewData.active && (this.analysisViewData.active = false, this.view.slicePlane = null), j3(this.view, this), this._handles.destroy(), this.set("view", null), this._set("state", "destroyed"));
  }
  async whenReady() {
    return await j(() => this.ready), this;
  }
  get _allLayerAndSubLayerViews() {
    const e3 = this.view.allLayerViews.items;
    return e3.concat(e3.filter(Vt).flatMap(({ sublayerViews: e4 }) => e4.items));
  }
  _updateBoundedPlaneFromSlicePlane() {
    const e3 = this.analysis.shape, i3 = this._currentSlicePlane;
    if (t(i3) && t(e3) || r(i3) && r(e3) && e3.equals(i3))
      return;
    let t6 = null, a5 = null;
    if (r(e3) && r(e3.position)) {
      const i4 = e3.position.spatialReference, s4 = Rt(e3, this.view);
      t(s4) && a2(this.analysis, i4, V), t6 = At(s4, this.view, { tiltEnabled: this.analysis.tiltEnabled }, G()), r(t6) && (a5 = { heading: e3.heading, tilt: e3.tilt, position: e3.position, width: e3.width, height: e3.height });
    }
    this._currentSlicePlane = a5, this._internalChange = true, this.analysisViewData.plane = t6, this._internalChange = false;
  }
  _updateSlicePlaneFromBoundedPlane() {
    const e3 = this.analysisViewData.plane, t6 = Tt(e3, this.view, this.view.spatialReference, new h());
    let a5 = null;
    r(t6) && (a5 = { heading: t6.heading, tilt: t6.tilt, position: t6.position, width: t6.width, height: t6.height }), this._currentSlicePlane = a5, this._internalChange = true, this.analysis.shape = t6, this._internalChange = false, this._updateViewSlicePlane();
  }
  _updateActiveController() {
    if (b3)
      return;
    const e3 = L2(this.view);
    if (this.analysisViewData.active)
      r(e3.activeController) && e3.activeController !== this ? (b3 = true, e3.activeController.analysisViewData.active = false, b3 = false) : r(e3.activeController) && e3.activeController, this._updateLayerViews(), e3.activeController = this;
    else {
      if (r(e3.activeController) && e3.activeController !== this)
        return;
      r(e3.activeController) && e3.activeController === this && (e3.activeController = null, this._updateLayerViews());
    }
  }
  _updateViewSlicePlane() {
    "ready" === this.state && P2(this.view);
  }
  _updateLayerViews() {
    const e3 = r(this.analysisViewData.plane) && this.analysisViewData.visible && this.analysisViewData.active, i3 = [], t6 = (e4) => {
      "layers" in e4 ? e4.layers.forEach(t6) : i3.push(e4);
    };
    this.analysis.excludedLayers.forEach(t6), this.view.allLayerViews.forEach((t7) => {
      t7.destroyed || ("slicePlaneEnabled" in t7 && (t7.slicePlaneEnabled = e3 && !i3.includes(t7.layer)), "sublayerViews" in t7 && t7.sublayerViews.forEach((t8) => {
        t8.slicePlaneEnabled = e3 && !i3.includes(t8.sublayer);
      }));
    }), null != this.view.basemapTerrain && (this.view.basemapTerrain.slicePlaneEnabled = e3 && !this.analysis.excludeGroundSurface);
  }
};
e([d({ readOnly: true })], g.prototype, "state", void 0), e([d()], g.prototype, "view", void 0), e([d()], g.prototype, "analysis", void 0), e([d()], g.prototype, "analysisViewData", void 0), e([d()], g.prototype, "ready", null), e([d()], g.prototype, "_allLayerAndSubLayerViews", null), g = e([n("esri.views.3d.analysis.Slice.SliceController")], g);
var S2 = /* @__PURE__ */ new Map();
var b3 = false;
function P2(e3) {
  const i3 = L2(e3).activeController;
  r(i3) && r(i3.analysisViewData.plane) && i3.analysisViewData.visible ? e3.slicePlane = i3.analysisViewData.plane : e3.slicePlane = null;
}
function C3(e3, i3) {
  S2.has(e3) || S2.set(e3, { all: [], activeController: null }), S2.get(e3).all.push(i3);
}
function L2(e3) {
  return S2.get(e3);
}
function j3(e3, i3) {
  if (!S2.has(e3))
    throw new Error("view expected in global slice register");
  const t6 = S2.get(e3), a5 = t6.all.lastIndexOf(i3);
  if (-1 === a5)
    throw new Error("controller expected in global slice register");
  t6.all.splice(a5, 1), 0 === t6.all.length && S2.delete(e3);
}

// node_modules/@arcgis/core/views/3d/analysis/Slice/SliceTool.js
var kt;
var Et = kt = class extends a3 {
  constructor(t6) {
    super(t6), this.clock = t2, this._previewPlaneOpacity = 1, this.removeIncompleteOnCancel = false, this.layersMode = "none", this.shiftManipulator = null, this.rotateHeadingManipulator = null, this.rotateTiltManipulator = null, this.resizeManipulators = null, this._handles = new u2(), this._viewHandles = new u2(), this._frameTask = null, this._pointerMoveTimerMs = p5, this._prevPointerMoveTimeout = null, this._previewPlaneGridVisualElement = null, this._previewPlaneOutlineVisualElement = null, this._startPlane = G(), this._previewPlane = null, this._activeKeyModifiers = {}, this._lastCursorPosition = c(), this._resizeHandles = [{ direction: [1, 0] }, { direction: [1, 1] }, { direction: [0, 1] }, { direction: [-1, 1] }, { direction: [-1, 0] }, { direction: [-1, -1] }, { direction: [0, -1] }, { direction: [1, -1] }], this._intersector = x(t6.view.state.viewingMode), this._intersector.options.store = t5.MIN;
  }
  initialize() {
    if (null == this.analysis)
      throw new Error("SliceTool requires valid analysis, but null was provided.");
    this.rotateHeadingImage = o2(this.view.toolViewManager.textures), this.rotateTiltImage = i2(this.view.toolViewManager.textures);
    const t6 = (t7) => {
      this._updateManipulatorsInteractive(t7), t7.grabbing || (r(this.analysisViewData.plane) && X(this.analysisViewData.plane, this._startPlane), this.inputState = null);
    };
    this.shiftManipulator = ut(this.view), this.manipulators.add(this.shiftManipulator), this.shiftManipulator.events.on("grab-changed", (e4) => {
      this._onShiftGrab(e4), t6(this.shiftManipulator);
    }), this._handles.add(this._createShiftDragPipeline(this.shiftManipulator)), this.rotateHeadingManipulator = dt(this.view, this.rotateHeadingImage.texture), this.manipulators.add(this.rotateHeadingManipulator), this.rotateHeadingManipulator.events.on("grab-changed", (e4) => {
      this._onRotateHeadingGrab(e4), t6(this.rotateHeadingManipulator);
    }), this._handles.add(this._createRotateHeadingDragPipeline(this.rotateHeadingManipulator)), this.rotateTiltManipulator = dt(this.view, this.rotateTiltImage.texture), this.manipulators.add(this.rotateTiltManipulator), this.rotateTiltManipulator.events.on("grab-changed", (e4) => {
      this._onRotateTiltGrab(e4), t6(this.rotateTiltManipulator);
    }), this._handles.add(this._createRotateTiltDragPipeline(this.rotateTiltManipulator)), this.resizeManipulators = this._resizeHandles.map((e4, i3) => {
      const a5 = gt(this.view, e4);
      return a5.events.on("grab-changed", (e5) => {
        this._onResizeGrab(e5, i3), t6(a5);
      }), this._handles.add(this._createResizeDragPipeline(a5)), a5;
    }), this.manipulators.addMany(this.resizeManipulators), this._previewPlaneGridVisualElement = pt(this.view), this._previewPlaneOutlineVisualElement = mt(this.view), this._previewPlaneOutlineVisualElement.width = b2, this._handles.add(l2(() => this.analysisViewData.plane, () => this._updateManipulators(), U));
    const e3 = l2(() => this.state, (t7) => {
      "sliced" === t7 && this.finishToolCreation();
    }, w);
    this._handles.add([e3, l2(() => this.view.state.camera, () => this._onCameraChange())]);
  }
  destroy() {
    this.rotateHeadingImage = p(this.rotateHeadingImage), this.rotateTiltImage = p(this.rotateTiltImage), this._handles = l(this._handles), this._viewHandles = l(this._viewHandles), this._removeFrameTask(), this._clearPointerMoveTimeout(), this._previewPlaneOutlineVisualElement = l(this._previewPlaneOutlineVisualElement), this._previewPlaneGridVisualElement = l(this._previewPlaneGridVisualElement);
  }
  get state() {
    const t6 = !!this.analysisViewData.plane, e3 = !!this.inputState;
    return t6 ? t6 && e3 ? "slicing" : t6 && !e3 ? "sliced" : "ready" : "ready";
  }
  get cursor() {
    return this._isPlacingSlicePlane || "exclude" === this.layersMode ? "crosshair" : r(this._creatingPointerId) ? "grabbing" : null;
  }
  set analysis(t6) {
    if (null == t6)
      throw new Error("SliceTool requires valid analysis, but null was provided.");
    this._handles.remove("analysis"), this._set("analysis", t6);
  }
  get inputState() {
    return this._get("inputState");
  }
  set inputState(t6) {
    this._set("inputState", t6), this.analysisViewData.showGrid = r(t6) && "resize" === t6.type, this._updateMaterials();
  }
  get _isPlacingSlicePlane() {
    return !this.inputState && !this.analysisViewData.plane && this.active;
  }
  get _creatingPointerId() {
    return r(this.inputState) && "shift" === this.inputState.type ? this.inputState.creatingPointerId : null;
  }
  enterExcludeLayerMode() {
    t(this.analysisViewData.plane) || (this._set("layersMode", "exclude"), this.active || (this.view.activeTool = this));
  }
  exitExcludeLayerMode() {
    t(this.analysisViewData.plane) || (this._set("layersMode", "none"), this.active && (this.view.activeTool = null));
  }
  onDeactivate() {
    this._set("layersMode", "none"), this._updatePreviewPlane(null);
  }
  onShow() {
    this._updateVisibility(true);
  }
  onHide() {
    this._updateVisibility(false);
  }
  _updateVisibility(t6) {
    this.shiftManipulator && (this._updateManipulators(), t6 || this._clearPointerMoveTimeout());
  }
  onInputEvent(t6) {
    switch (t6.type) {
      case "pointer-drag":
        if (!Ht(t6))
          return;
        this._isPlacingSlicePlane ? this._onClickPlacePlane(t6) && t6.stopPropagation() : this._onPointerDrag(t6) && t6.stopPropagation();
        break;
      case "pointer-move":
        this._onPointerMove(t6);
        break;
      case "pointer-up":
        this._onPointerUp(t6) && t6.stopPropagation();
        break;
      case "immediate-click":
        if (!Ht(t6))
          return;
        this._onClickPlacePlane(t6) && t6.stopPropagation();
        break;
      case "click":
        if (!Ht(t6))
          return;
        this._onClickExcludeLayer(t6) && t6.stopPropagation();
        break;
      case "drag":
        this.inputState && t6.stopPropagation();
        break;
      case "key-down":
        this._onKeyDown(t6) && t6.stopPropagation();
        break;
      case "key-up":
        this._onKeyUp(t6) && t6.stopPropagation();
    }
  }
  onEditableChange() {
    this.analysisViewData.editable = this.editable;
  }
  _onPointerDrag(t6) {
    const e3 = this.inputState;
    if (t6.pointerId === this._creatingPointerId && r(e3) && "shift" === e3.type) {
      const i3 = n3(t6);
      return this.shiftManipulator.events.emit("drag", { action: e3.hasBeenDragged ? "update" : "start", pointerType: t6.pointerType, start: i3, screenPoint: i3 }), e3.hasBeenDragged = true, true;
    }
    return false;
  }
  _onPointerMove(t6) {
    this._lastCursorPosition.x = t6.x, this._lastCursorPosition.y = t6.y, this._resetPointerMoveTimeout(), "touch" !== t6.pointerType && this._updatePreviewPlane(n3(t6), this._activeKeyModifiers);
  }
  _onCameraChange() {
    this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), this._updateManipulators();
  }
  _onPointerUp(t6) {
    if (t6.pointerId === this._creatingPointerId && r(this.analysisViewData.plane)) {
      const e3 = n3(t6);
      return this.shiftManipulator.events.emit("drag", { action: "end", start: e3, screenPoint: e3 }), X(this.analysisViewData.plane, this._startPlane), this.inputState = null, true;
    }
    return false;
  }
  _onClickPlacePlane(t6) {
    if ("exclude" === this.layersMode)
      return false;
    if (this._isPlacingSlicePlane) {
      const i3 = n3(t6), a5 = G();
      if (this._pickPlane(i3, false, this._activeKeyModifiers, a5)) {
        if (X(a5, this._startPlane), this.analysis.shape = Tt(a5, this.view, this.view.spatialReference, new h()), "pointer-drag" === t6.type) {
          const e3 = this._calculatePickRay(i3);
          this.inputState = St(e3, t6.pointerId, a5.origin, a5);
        }
        return true;
      }
    }
    return false;
  }
  _onClickExcludeLayer(t6) {
    return !("exclude" !== this.layersMode || !this.created) && (this.view.hitTest(n3(t6)).then((t7) => {
      if (t7.results.length) {
        const e3 = t7.results[0], i3 = "graphic" === (e3 == null ? void 0 : e3.type) && e3.graphic;
        if (i3) {
          const t8 = i3.sourceLayer || i3.layer;
          t8 && this.analysis.excludedLayers.push(t8);
        }
      } else
        t7.ground.layer ? this.analysis.excludedLayers.push(t7.ground.layer) : this.analysis.excludeGroundSurface = true;
    }), this._set("layersMode", "none"), this.active && (this.view.activeTool = null), true);
  }
  _onKeyDown(t6) {
    return (t6.key === a4 || t6.key === m2) && (this._activeKeyModifiers[t6.key] = true, r(this._previewPlane) && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onKeyUp(t6) {
    return !(t6.key !== a4 && t6.key !== m2 || !this._activeKeyModifiers[t6.key]) && (delete this._activeKeyModifiers[t6.key], r(this._previewPlane) && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onShiftGrab(t6) {
    if ("start" !== t6.action || t(this.analysisViewData.plane))
      return;
    const e3 = this._calculatePickRay(t6.screenPoint);
    X(this.analysisViewData.plane, this._startPlane), this.inputState = St(e3, null, this.shiftManipulator.renderLocation, this.analysisViewData.plane);
  }
  _createShiftDragPipeline(t6) {
    return p4(t6, (t7, e3, i3) => {
      const a5 = this.inputState;
      if (t(a5) || "shift" !== a5.type)
        return;
      const s4 = r(this.analysisViewData.plane) ? X(this.analysisViewData.plane, G()) : null;
      e3.next(C(this.view, a5.shiftPlane)).next(this._shiftDragAdjustSensitivity(a5)).next(this._shiftDragUpdatePlane(a5)), i3.next(() => {
        r(s4) && this._updateBoundedPlane(s4);
      });
    });
  }
  _shiftDragAdjustSensitivity(t6) {
    return (e3) => {
      if (t(this.analysisViewData.plane))
        return null;
      const i3 = 1e-3, a5 = Math.min((1 - Math.abs(P(ms(this.analysisViewData.plane), e3.ray.direction) / s2(e3.ray.direction))) / i3, 1), s4 = -W(this._startPlane.plane, e3.renderEnd), n5 = -W(this._startPlane.plane, t6.startPoint);
      return t6.depth = t6.depth * (1 - a5) + s4 * a5 - n5, e3;
    };
  }
  _shiftDragUpdatePlane(t6) {
    return () => {
      if (t(this.analysisViewData.plane))
        return;
      const e3 = r2(c2.get(), this._startPlane.origin), i3 = r2(c2.get(), ms(this._startPlane));
      q(i3, i3, -t6.depth), u(i3, i3, e3);
      const a5 = D(i3, this.analysisViewData.plane.basis1, this.analysisViewData.plane.basis2, G());
      this._updateBoundedPlane(a5);
    };
  }
  _onRotateHeadingGrab(t6) {
    if ("start" !== t6.action || t(this.analysisViewData.plane))
      return;
    const e3 = Ke(this.analysisViewData.plane, this.view.renderCoordsHelper, Lt.HEADING, p3()), i3 = this._calculatePickRay(t6.screenPoint), a5 = n2();
    q3(e3, i3, a5) && (X(this.analysisViewData.plane, this._startPlane), this.inputState = { type: "rotate", rotatePlane: e3, startPoint: a5 });
  }
  _createRotateHeadingDragPipeline(t6) {
    return p4(t6, (t7, e3, i3) => {
      const a5 = this.inputState;
      if (t(a5) || "rotate" !== a5.type)
        return;
      const s4 = r(this.analysisViewData.plane) ? X(this.analysisViewData.plane, G()) : null;
      e3.next(C(this.view, a5.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a5)).next(this._rotateDragUpdatePlaneFromRotate()), i3.next(() => {
        r(s4) && this._updateBoundedPlane(s4);
      });
    });
  }
  _onRotateTiltGrab(t6) {
    if ("start" !== t6.action || t(this.analysisViewData.plane))
      return;
    const e3 = Ke(this.analysisViewData.plane, this.view.renderCoordsHelper, Lt.TILT, p3()), i3 = this._calculatePickRay(t6.screenPoint), a5 = n2();
    q3(e3, i3, a5) && (X(this.analysisViewData.plane, this._startPlane), this.inputState = { type: "rotate", rotatePlane: e3, startPoint: a5 });
  }
  _createRotateTiltDragPipeline(t6) {
    return p4(t6, (t7, e3, i3) => {
      const a5 = this.inputState;
      if (t(a5) || "rotate" !== a5.type)
        return;
      const s4 = r(this.analysisViewData.plane) ? X(this.analysisViewData.plane, G()) : null;
      e3.next(C(this.view, a5.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a5)).next(this._rotateDragUpdatePlaneFromRotate()), i3.next(() => {
        r(s4) && this._updateBoundedPlane(s4);
      });
    });
  }
  _rotateDragRenderPlaneToRotate(t6) {
    return (e3) => {
      if (t(this.analysisViewData.plane))
        return null;
      const i3 = Z(t6.rotatePlane), a5 = O(t6.startPoint, e3.renderEnd, this.analysisViewData.plane.origin, i3);
      return { ...e3, rotateAxis: i3, rotateAngle: a5 };
    };
  }
  _rotateDragUpdatePlaneFromRotate() {
    return (t6) => {
      if (t(this.analysisViewData.plane))
        return;
      const e3 = p2(f.get(), t6.rotateAngle, t6.rotateAxis), i3 = L(c2.get(), this._startPlane.basis1, e3), a5 = L(c2.get(), this._startPlane.basis2, e3), s4 = D(this.analysisViewData.plane.origin, i3, a5, G());
      this._updateBoundedPlane(s4);
    };
  }
  _onResizeGrab(t6, e3) {
    if ("start" !== t6.action || t(this.analysisViewData.plane))
      return;
    const i3 = this._calculatePickRay(t6.screenPoint), a5 = c2.get();
    q3(this.analysisViewData.plane.plane, i3, a5) && (X(this.analysisViewData.plane, this._startPlane), this.inputState = { type: "resize", activeHandleIdx: e3, startPoint: t3(a5) });
  }
  _createResizeDragPipeline(t6) {
    return p4(t6, (t7, e3, i3) => {
      const a5 = this.inputState;
      if (t(a5) || "resize" !== a5.type || t(this.analysisViewData.plane))
        return;
      const s4 = X(this.analysisViewData.plane, G());
      e3.next(C(this.view, this.analysisViewData.plane.plane)).next(this._resizeDragUpdatePlane(a5)), i3.next(() => {
        this._updateBoundedPlane(s4);
      });
    });
  }
  _resizeDragUpdatePlane(t6) {
    return (e3) => {
      if (t(this.analysisViewData.plane))
        return;
      const i3 = this._resizeHandles[t6.activeHandleIdx], a5 = We(i3, t6.startPoint, e3.renderEnd, this.view.state.camera, this._startPlane, X(this.analysisViewData.plane));
      this._updateBoundedPlane(a5);
    };
  }
  _updateBoundedPlane(t6) {
    const e3 = this.analysisViewData;
    if (!r(e3))
      throw new Error("valid internal object expected");
    e3.plane = t6;
  }
  _updatePreviewPlane(t6, e3 = {}) {
    let i3 = this._previewPlane;
    if (this._previewPlane = null, t(t6))
      return this._removeFrameTask(), void this._updateManipulators();
    if (!this.analysisViewData.plane && this.active) {
      const a5 = r(i3) ? i3 : G();
      if (i3 = r(i3) ? X(i3, xt) : null, this._pickPlane(t6, true, e3, a5)) {
        const t7 = k;
        let e4 = false;
        r(i3) && (e4 = P(i3.plane, a5.plane) < t7 || P(z(c2.get(), i3.basis1), z(c2.get(), a5.basis1)) < t7), e4 && (this._previewPlaneOpacity = 0), this._previewPlane = a5;
      }
    }
    r(this._previewPlane) && t(this._frameTask) && 0 === this._previewPlaneOpacity ? this._frameTask = A({ update: ({ deltaTime: t7 }) => {
      this._previewPlaneOpacity = Math.min(this._previewPlaneOpacity + t7 / (1e3 * l4), 1), this._updateManipulators(), 1 === this._previewPlaneOpacity && this._removeFrameTask();
    } }) : t(this._previewPlane) && r(this._frameTask) ? this._removeFrameTask() : r(this._previewPlane) && this._updateManipulators();
  }
  _removeFrameTask() {
    this._frameTask = a(this._frameTask);
  }
  _calculatePickRay(t6) {
    const e3 = d3(), i3 = d2(t6, It);
    return s3(this.view.state.camera, i3, e3), z(e3.direction, e3.direction), e3;
  }
  _pickMinResult(t6) {
    const e3 = d2(t6, t4.get());
    return this.view.sceneIntersectionHelper.intersectToolIntersectorScreen(e3, this._intersector), this._intersector.results.min;
  }
  _pickPlane(t6, e3, i3, a5) {
    const s4 = this._pickMinResult(t6), n5 = c2.get();
    if (!s4.getIntersectionPoint(n5))
      return false;
    const r4 = s4.getTransformedNormal(c2.get()), l5 = this.view.state.camera;
    P(r4, l5.viewForward) > 0 && q(r4, r4, -1);
    const o3 = qe(n5, l5), h2 = (e3 ? 1 : -1) * o3 * j2, p6 = q(c2.get(), r4, h2);
    u(p6, p6, n5);
    const u5 = this.analysis.tiltEnabled ? Pt.TILTED : Pt.HORIZONTAL_OR_VERTICAL, c5 = i3[a4] ? Pt.VERTICAL : i3[m2] ? Pt.HORIZONTAL : u5;
    return Ye(p6, r4, o3, o3, l5, c5, this.view.renderCoordsHelper, a5), true;
  }
  _clearPointerMoveTimeout() {
    this._prevPointerMoveTimeout = a(this._prevPointerMoveTimeout);
  }
  _resetPointerMoveTimeout() {
    this._clearPointerMoveTimeout(), this.shiftManipulator.state |= Mt, this.rotateHeadingManipulator.state |= Mt, this.rotateTiltManipulator.state |= Mt, this._prevPointerMoveTimeout = this.clock.setTimeout(() => {
      this.shiftManipulator.state &= ~Mt, this.rotateHeadingManipulator.state &= ~Mt, this.rotateTiltManipulator.state &= ~Mt;
    }, this._pointerMoveTimerMs);
  }
  _updateManipulators() {
    if (kt.disableEngineLayers)
      return;
    let t6 = null, e3 = false;
    if (r(this.analysisViewData.plane))
      t6 = this.analysisViewData.plane, e3 = false;
    else {
      if (!r(this._previewPlane))
        return this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t7) => t7.available = false), this._previewPlaneOutlineVisualElement.visible = false, void (this._previewPlaneGridVisualElement.visible = false);
      t6 = this._previewPlane, e3 = true;
    }
    const i3 = Je(t6, f.get());
    e3 ? (this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t7) => t7.available = false), this._previewPlaneOutlineVisualElement.visible = true, this._previewPlaneGridVisualElement.visible = true) : (this.shiftManipulator.available = true, this.rotateHeadingManipulator.available = true, this.rotateTiltManipulator.available = this.analysis.tiltEnabled, this.resizeManipulators.forEach((t7) => t7.available = true), Qe(this.shiftManipulator, i3, t6, this.view.state.camera), rt(this.rotateHeadingManipulator, i3, t6, this.view.renderCoordsHelper), it(this.rotateTiltManipulator, i3, t6), this.resizeManipulators.forEach((e4, a6) => tt(e4, this._resizeHandles[a6], i3, t6)), this._previewPlaneOutlineVisualElement.visible = false, this._previewPlaneGridVisualElement.visible = false);
    const a5 = o(c2.get(), s2(t6.basis1), s2(t6.basis2), 1), s4 = q2(f.get(), a5), n5 = u3(s4, i3, s4);
    this._previewPlaneOutlineVisualElement.transform = n5, this._previewPlaneGridVisualElement.transform = n5, this._updateMaterials();
  }
  _updateMaterials() {
    const t6 = [C2[0], C2[1], C2[2], C2[3] * this._previewPlaneOpacity];
    this._previewPlaneOutlineVisualElement.color = t6;
    const e3 = [S[0], S[1], S[2], S[3] * this._previewPlaneOpacity], i3 = [0, 0, 0, 0];
    this._previewPlaneGridVisualElement.backgroundColor = e3, this._previewPlaneGridVisualElement.gridColor = i3;
  }
  _updateManipulatorsInteractive(t6) {
    if (!t6.grabbing)
      return this.shiftManipulator.interactive = true, this.rotateHeadingManipulator.interactive = true, this.rotateTiltManipulator.interactive = true, void this.resizeManipulators.forEach((t7) => {
        t7.interactive = true;
      });
    this.shiftManipulator.interactive = this.shiftManipulator === t6, this.rotateHeadingManipulator.interactive = this.rotateHeadingManipulator === t6, this.rotateTiltManipulator.interactive = this.rotateTiltManipulator === t6, this.resizeManipulators.forEach((e3) => {
      e3.interactive = e3 === t6;
    });
  }
  testData() {
    return { plane: this.analysisViewData.plane, setPointerMoveTimerMs: (t6) => {
      this._pointerMoveTimerMs = t6;
    } };
  }
};
function St(t6, e3, i3, a5) {
  const s4 = $e(i3, ms(a5), t6.direction, p3()), n5 = n2();
  return q3(s4, t6, n5) ? { type: "shift", creatingPointerId: e3, hasBeenDragged: false, shiftPlane: s4, depth: 0, startPoint: n5 } : null;
}
function Ht(t6) {
  return "mouse" !== t6.pointerType || 0 === t6.button;
}
Et.disableEngineLayers = false, e([d()], Et.prototype, "clock", void 0), e([d({ constructOnly: true })], Et.prototype, "view", void 0), e([d()], Et.prototype, "analysisViewData", void 0), e([d({ readOnly: true })], Et.prototype, "state", null), e([d({ readOnly: true })], Et.prototype, "cursor", null), e([d()], Et.prototype, "analysis", null), e([d()], Et.prototype, "removeIncompleteOnCancel", void 0), e([d({ readOnly: true })], Et.prototype, "layersMode", void 0), e([d({ value: null })], Et.prototype, "inputState", null), e([d()], Et.prototype, "_isPlacingSlicePlane", null), e([d()], Et.prototype, "_creatingPointerId", null), Et = kt = e([n("esri.views.3d.analysis.Slice.SliceTool")], Et);
var xt = G();
var It = i();
var Rt2 = Et;

// node_modules/@arcgis/core/views/3d/analysis/Slice/SliceVisualization.js
var G2 = class extends y {
  constructor(e3) {
    super(e3), this._handles = new u2(), this._gridVisualElement = null, this._outlineVisualElement = null, this.state = "pending", this.showGrid = false, this.preview = true;
  }
  get ready() {
    return "ready" === this.state;
  }
  initialize() {
    this._initialize();
  }
  async _initialize() {
    if ("destroyed" === this.state || "ready" === this.state)
      return;
    await j(() => this.view.ready);
    const e3 = this.analysisViewData;
    if (t(e3))
      throw new Error("expected internal object to be valid");
    this._gridVisualElement = pt(this.view), this._outlineVisualElement = mt(this.view), this._handles.add([l2(() => ({ visible: r(e3.plane) && this.analysisViewData.visible, active: this.analysisViewData.active, preview: this.preview, showGrid: this.showGrid }), (e4) => this._updateMaterials(e4), w), l2(() => e3.plane, (e4) => this._updatePlane(e4), w)], "internal"), this._set("state", "ready");
  }
  destroy() {
    "destroyed" !== this.state && "pending" !== this.state && (this._handles.destroy(), this._gridVisualElement = l(this._gridVisualElement), this._outlineVisualElement = l(this._outlineVisualElement), this.set("view", null), this._set("state", "destroyed"));
  }
  async whenReady() {
    await j(() => this.view.ready);
  }
  _updatePlane(e3) {
    if (t(e3))
      return;
    const t6 = o(c2.get(), s2(e3.basis1), s2(e3.basis2), 1), i3 = q2(f.get(), t6), r4 = Je(e3, f.get()), o3 = u3(i3, r4, i3);
    this._outlineVisualElement.transform = o3, this._gridVisualElement.transform = o3;
  }
  _updateMaterials({ visible: e3, active: t6, preview: i3, showGrid: s4 }) {
    this._outlineVisualElement.color = C2, this._outlineVisualElement.width = i3 ? b2 : x2, this._outlineVisualElement.stipplePattern = t6 ? null : r3(5), this._gridVisualElement.backgroundColor = S, this._gridVisualElement.gridColor = s4 ? U2 : l3, this._gridVisualElement.visible = e3, this._outlineVisualElement.visible = e3;
  }
};
e([d({ readOnly: true })], G2.prototype, "state", void 0), e([d()], G2.prototype, "view", void 0), e([d()], G2.prototype, "analysis", void 0), e([d()], G2.prototype, "analysisViewData", void 0), e([d()], G2.prototype, "ready", null), e([d()], G2.prototype, "showGrid", void 0), e([d()], G2.prototype, "preview", void 0), G2 = e([n("esri.views.3d.analysis.Slice.SliceVisualization")], G2);

// node_modules/@arcgis/core/views/3d/analysis/SliceAnalysisView3D.js
var c4 = class extends n4(y) {
  constructor(i3) {
    super(i3), this.type = "slice-view-3d", this.analysis = null, this.tool = null, this.analysisVisualization = null, this.analysisController = null, this.plane = null, this.active = true, this.showGrid = false;
  }
  initialize() {
    this.analysisVisualization = new G2({ view: this.view, analysis: this.analysis, analysisViewData: this }), this.analysisController = new g({ view: this.view, analysis: this.analysis, analysisViewData: this }), this.own(c3(this, Rt2));
  }
  destroy() {
    m(this), this.analysisVisualization = l(this.analysisVisualization), this.analysisController = l(this.analysisController);
  }
  get editable() {
    return !this.analysisVisualization.preview;
  }
  set editable(i3) {
    this.analysisVisualization.preview = !i3;
  }
  async when() {
    return await this.analysisVisualization.whenReady(), await this.analysisController.whenReady(), this;
  }
  get testData() {
    return { visualization: this.analysisVisualization, controller: this.analysisController, tool: e2(this.tool) };
  }
};
e([d({ readOnly: true })], c4.prototype, "type", void 0), e([d({ constructOnly: true, nonNullable: true })], c4.prototype, "analysis", void 0), e([d()], c4.prototype, "tool", void 0), e([d()], c4.prototype, "plane", void 0), e([d()], c4.prototype, "active", void 0), e([d({ aliasOf: "analysisVisualization.showGrid" })], c4.prototype, "showGrid", void 0), e([d()], c4.prototype, "editable", null), c4 = e([n("esri.views.3d.analysis.SliceAnalysisView3D")], c4);
var u4 = c4;
export {
  u4 as default
};
//# sourceMappingURL=SliceAnalysisView3D-46YLGRMS.js.map
