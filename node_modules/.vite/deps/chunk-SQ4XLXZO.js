import {
  r as r3
} from "./chunk-6YT7XVZA.js";
import {
  m as m2
} from "./chunk-444THZYK.js";
import {
  e
} from "./chunk-E3V32BOJ.js";
import {
  e as e4,
  f,
  i as i2,
  m
} from "./chunk-PZHH54V6.js";
import {
  i as i3,
  s as s2
} from "./chunk-PZFKIJU3.js";
import {
  i,
  n as n2,
  o as o3
} from "./chunk-B3IXFXV6.js";
import {
  a as a2,
  m as m3
} from "./chunk-MQLLOFWM.js";
import {
  c2 as c3
} from "./chunk-XNOIZLCR.js";
import {
  t as t2
} from "./chunk-I22L7HNU.js";
import {
  n as n3,
  o as o4
} from "./chunk-44UD36FH.js";
import {
  c as c4,
  h
} from "./chunk-Y5AGUEHG.js";
import {
  d as d2,
  l
} from "./chunk-DVE4HUBR.js";
import {
  d
} from "./chunk-OYNEZ5VG.js";
import {
  s
} from "./chunk-ZV3LDRB3.js";
import {
  e as e5
} from "./chunk-O7YSDCZE.js";
import {
  n as n4
} from "./chunk-DNPZNIDB.js";
import {
  r as r2
} from "./chunk-FCDEMPPS.js";
import {
  o as o2
} from "./chunk-TEJEYVH4.js";
import {
  t
} from "./chunk-HEZ2ATGC.js";
import {
  a
} from "./chunk-ECNFP4CF.js";
import {
  e as e6
} from "./chunk-AALA53RH.js";
import {
  u
} from "./chunk-IJHFAZOW.js";
import {
  c
} from "./chunk-DMGVDNFD.js";
import {
  c as c2,
  d as d3
} from "./chunk-YAQGRU5B.js";
import {
  e as e3
} from "./chunk-46N7XS5M.js";
import {
  e as e2
} from "./chunk-4MKQUQD4.js";
import {
  o as o5
} from "./chunk-A3QLZKCF.js";
import {
  i2 as i4
} from "./chunk-I5UNY2WQ.js";
import {
  n
} from "./chunk-NAB3NF54.js";
import {
  O as O2
} from "./chunk-MDCKEJ7B.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  o
} from "./chunk-YFBAFAZ2.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/chunks/DefaultMaterial.glsl.js
function k(k2) {
  const W2 = new i4(), H = W2.vertex.code, q = W2.fragment.code;
  W2.include(r3, { name: "Default Material Shader", output: k2.output });
  const J = d3(W2, k2);
  return W2.include(o4), W2.varyings.add("vpos", "vec3"), W2.include(s, k2), W2.include(m, k2), W2.include(a, k2), k2.output !== o2.Color && k2.output !== o2.Alpha || (c2(W2.vertex, k2), W2.include(o3, k2), W2.include(r2, { linearDepth: false, hasModelTransformation: k2.hasModelTransformation }), k2.normalType === i.Attribute && k2.offsetBackfaces && W2.include(e4), W2.include(m2, k2), W2.include(n2, k2), k2.instancedColor && W2.attributes.add(O.INSTANCECOLOR, "vec4"), W2.varyings.add("localvpos", "vec3"), W2.include(d, k2), W2.include(t2, k2), W2.include(i2, k2), W2.include(e5, k2), W2.vertex.uniforms.add(new e6("externalColor", (e7) => e7.externalColor)), W2.varyings.add("vcolorExt", "vec4"), k2.hasMultipassTerrain && W2.varyings.add("depth", "float"), k2.hasModelTransformation && W2.vertex.uniforms.add(new e3("model", (o6) => r(o6.modelTransformation) ? o6.modelTransformation : o)), H.add(n`
      void main(void) {
        forwardNormalizedVertexColor();
        vcolorExt = externalColor;
        ${k2.instancedColor ? "vcolorExt *= instanceColor;" : ""}
        vcolorExt *= vvColor();
        vcolorExt *= getSymbolColor();
        forwardColorMixMode();

        if (vcolorExt.a < ${n.float(t)}) {
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        } else {
          vpos = calculateVPos();
          localvpos = vpos - view[3].xyz;
          vpos = subtractOrigin(vpos);
          ${k2.normalType === i.Attribute ? n`vNormalWorld = dpNormal(vvLocalNormal(normalModel()));` : ""}
          vpos = addVerticalOffset(vpos, localOrigin);
          ${k2.hasVertexTangents ? "vTangent = dpTransformVertexTangent(tangent);" : ""}
          gl_Position = transformPosition(proj, view, ${k2.hasModelTransformation ? "model," : ""} vpos);
          ${k2.normalType === i.Attribute && k2.offsetBackfaces ? "gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, cameraPosition);" : ""}
        }

        ${k2.hasMultipassTerrain ? "depth = (view * vec4(vpos, 1.0)).z;" : ""}
        forwardLinearDepth();
        forwardTextureCoordinates();
      }
    `)), k2.output === o2.Alpha && (W2.include(u, k2), W2.include(s2, k2), W2.include(n4, k2), W2.fragment.uniforms.add([new o5("opacity", (e7) => e7.opacity), new o5("layerOpacity", (e7) => e7.layerOpacity)]), k2.hasColorTexture && W2.fragment.uniforms.add(new c("tex", (e7) => e7.texture)), W2.fragment.include(i3), q.add(n`
      void main() {
        discardBySlice(vpos);
        ${k2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        ${k2.hasColorTexture ? n`
                vec4 texColor = texture2D(tex, vuv0);
                ${k2.textureAlphaPremultiplied ? "texColor.rgb /= texColor.a;" : ""}
                discardOrAdjustAlpha(texColor);` : n`vec4 texColor = vec4(1.0);`}
        ${k2.hasVertexColors ? n`float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));` : n`float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));`}
        gl_FragColor = vec4(opacity_);
      }
    `)), k2.output === o2.Color && (W2.include(u, k2), W2.include(m3, k2), W2.include(a2, k2), W2.include(s2, k2), W2.include(k2.instancedDoublePrecision ? h : c4, k2), W2.include(n4, k2), c2(W2.fragment, k2), W2.fragment.uniforms.add([J, new e2("ambient", (e7) => e7.ambient), new e2("diffuse", (e7) => e7.diffuse), new o5("opacity", (e7) => e7.opacity), new o5("layerOpacity", (e7) => e7.layerOpacity), new o5("lightingGlobalFactor", (e7, r4) => r4.lighting.globalFactor), new e2("lightingMainIntensity", (e7, r4) => r4.lighting.mainLight.intensity)]), W2.fragment.constants.add("ambientBoostFactor", "float", c3), k2.hasColorTexture && W2.fragment.uniforms.add(new c("tex", (e7) => e7.texture)), W2.include(d2, k2), W2.include(n3, k2), W2.fragment.include(i3), W2.include(e, k2), q.add(n`
      void main() {
        discardBySlice(vpos);
        ${k2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        ${k2.hasColorTexture ? n`
                vec4 texColor = texture2D(tex, vuv0);
                ${k2.textureAlphaPremultiplied ? "texColor.rgb /= texColor.a;" : ""}
                discardOrAdjustAlpha(texColor);` : n`vec4 texColor = vec4(1.0);`}
        shadingParams.viewDirection = normalize(vpos - cameraPosition);
        ${k2.normalType === i.ScreenDerivative ? n`
                vec3 normal = screenDerivativeNormal(localvpos);` : n`
                shadingParams.normalView = vNormalWorld;
                vec3 normal = shadingNormal(shadingParams);`}
        ${k2.pbrMode === l.Normal ? "applyPBRFactors();" : ""}
        float ssao = evaluateAmbientOcclusionInverse();
        ssao *= getBakedOcclusion();

        float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
        ${k2.receiveShadows ? "float shadow = readShadowMap(vpos, linearDepth);" : k2.spherical ? "float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);" : "float shadow = 0.0;"}
        vec3 matColor = max(ambient, diffuse);
        ${k2.hasVertexColors ? n`
                vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
                float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));` : n`
                vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
                float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));`}
        ${k2.hasNormalTexture ? n`
                mat3 tangentSpace = ${k2.hasVertexTangents ? "computeTangentSpace(normal);" : "computeTangentSpace(normal, vpos, vuv0);"}
                vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);` : n`vec3 shadingNormal = normal;`}
        vec3 normalGround = ${k2.spherical ? n`normalize(vpos + localOrigin);` : n`vec3(0.0, 0.0, 1.0);`}

        ${k2.snowCover ? n`
                float snow = smoothstep(0.5, 0.55, dot(normal, normalGround));
                albedo = mix(albedo, vec3(1), snow);
                shadingNormal = mix(shadingNormal, normal, snow);
                ssao = mix(ssao, 1.0, snow);` : ""}

        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

        ${k2.pbrMode === l.Normal || k2.pbrMode === l.Schematic ? n`
                float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];
                ${k2.snowCover ? n`
                        mrr = mix(mrr, vec3(0.0, 1.0, 0.04), snow);
                        emission = mix(emission, vec3(0.0), snow);` : ""}

                vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);` : n`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);
        ${k2.transparencyPassType === O2.Color ? n`gl_FragColor = premultiplyAlpha(gl_FragColor);` : ""}
      }
    `)), W2.include(f, k2), W2;
}
var W = Object.freeze(Object.defineProperty({ __proto__: null, build: k }, Symbol.toStringTag, { value: "Module" }));

export {
  k,
  W
};
//# sourceMappingURL=chunk-SQ4XLXZO.js.map
