import {
  F,
  l as l5
} from "./chunk-IHCVEO7N.js";
import {
  d as d5
} from "./chunk-FXA5BH2C.js";
import {
  s as s7
} from "./chunk-U7UHMH7X.js";
import {
  l as l4
} from "./chunk-CBFCCRGT.js";
import {
  u as u4
} from "./chunk-4QVQG5LC.js";
import {
  p as p3
} from "./chunk-SNHXPRNZ.js";
import {
  c as c7
} from "./chunk-HPO2NV7P.js";
import {
  _e,
  y as y2
} from "./chunk-Y75V5CF3.js";
import {
  T as T3
} from "./chunk-MHEQOIKQ.js";
import {
  E as E6,
  e as e7,
  t2 as t9
} from "./chunk-AIONJO5O.js";
import {
  a as a6
} from "./chunk-TRGP26VY.js";
import {
  g as g3,
  i,
  p as p2
} from "./chunk-7OZR6JFF.js";
import {
  e as e5,
  o as o5,
  t as t6
} from "./chunk-NXOQBIK7.js";
import {
  A as A2,
  E as E5
} from "./chunk-ERNXFM5T.js";
import {
  i as i2
} from "./chunk-6ITXWFMK.js";
import {
  e as e6,
  t as t7
} from "./chunk-SV4VP57N.js";
import {
  u as u6
} from "./chunk-PWYPPSAW.js";
import {
  c as c6
} from "./chunk-5EXPMKQP.js";
import {
  W,
  c as c5,
  s as s6
} from "./chunk-B7F3T673.js";
import {
  D as D2
} from "./chunk-Z7AZMEL6.js";
import {
  n as n6
} from "./chunk-T3KDRLPE.js";
import {
  u as u5
} from "./chunk-EJ7RFMRW.js";
import {
  t as t5
} from "./chunk-WJDUBZ7S.js";
import {
  T
} from "./chunk-3DCTMZI6.js";
import {
  D,
  E as E3,
  G,
  L as L2,
  M,
  P,
  R,
  T as T2,
  U as U3,
  V as V2,
  Y,
  _
} from "./chunk-FPMD6IB4.js";
import {
  i as i3
} from "./chunk-TUZ3FLXS.js";
import {
  M as M2
} from "./chunk-EJ4V43KX.js";
import {
  d2 as d4,
  o2 as o4
} from "./chunk-EEJIELE6.js";
import {
  E as E4
} from "./chunk-Y55TYMBP.js";
import {
  t as t4
} from "./chunk-NAB3NF54.js";
import {
  c as c4,
  o as o3
} from "./chunk-MDCKEJ7B.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  A,
  O as O2,
  S as S2,
  o as o2,
  w as w2
} from "./chunk-SOZCO2CU.js";
import {
  t as t8
} from "./chunk-KDNPPW3Z.js";
import {
  b,
  r as r3
} from "./chunk-YZNDHJDJ.js";
import {
  l as l3
} from "./chunk-ZN2MGN4S.js";
import {
  L,
  Q
} from "./chunk-JZY7CGEI.js";
import {
  n as n5
} from "./chunk-RTHP2LNT.js";
import {
  V
} from "./chunk-6SWQ7R36.js";
import {
  s as s4,
  t as t2
} from "./chunk-OZT6RDST.js";
import {
  Hn
} from "./chunk-PZWU5EHT.js";
import {
  e as e4,
  r as r4,
  t as t3
} from "./chunk-7ZPDA3EC.js";
import {
  g as g2
} from "./chunk-6GPADSSO.js";
import {
  b as b2,
  m as m4
} from "./chunk-GSFXXEAM.js";
import {
  a as a4
} from "./chunk-QZTJM4HG.js";
import {
  s as s5
} from "./chunk-4TDLPK3D.js";
import {
  a as a5
} from "./chunk-QKRZMDWG.js";
import {
  d as d3
} from "./chunk-JJRJ6TV3.js";
import {
  c as c3
} from "./chunk-K2FQEYBG.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  a as a2,
  h,
  j as j2,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import {
  g as g4
} from "./chunk-BLINZ65M.js";
import {
  S2 as S3,
  f as f3,
  h as h3,
  j2 as j3
} from "./chunk-TADZYUVR.js";
import {
  E as E2,
  I,
  J,
  U as U2,
  a as a3,
  c as c2,
  e as e3,
  f as f2,
  h as h2,
  u as u3
} from "./chunk-56RHM4A6.js";
import {
  m as m3
} from "./chunk-FTLBKDGL.js";
import {
  B
} from "./chunk-5Z5455ZY.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  u as u2
} from "./chunk-NWRK6QLX.js";
import {
  r as r2
} from "./chunk-PKZEO23A.js";
import {
  n as n4
} from "./chunk-AIRC226G.js";
import {
  v2
} from "./chunk-VLCG72SW.js";
import {
  d as d2,
  n2 as n,
  n8 as n3,
  v,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  E,
  f,
  g
} from "./chunk-U3PSONS6.js";
import {
  s2 as s3
} from "./chunk-HFTNOKM2.js";
import {
  n as n2
} from "./chunk-23NWA6WL.js";
import {
  s as s2
} from "./chunk-CVWDM4C7.js";
import {
  m as m2
} from "./chunk-G5JBUC5N.js";
import {
  S,
  a2 as a,
  c,
  d,
  e as e2,
  l,
  m,
  o,
  p,
  r,
  s,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/support/featureReference.js
var s8 = class {
  constructor(e8, s9) {
    this.highestResolutionVersion = null, this.versions = [], this.ref(e8, s9);
  }
  get isReferenced() {
    return 0 !== this.versions.length;
  }
  get isSingle() {
    return 1 === this.versions.length && 1 === this.versions[0].refCount;
  }
  ref(s9, t11) {
    const r5 = this.feature;
    i4.oldVersion = r5, this.feature && Object.defineProperty(s9, "uid", { value: this.feature.uid, configurable: true });
    for (const o7 of this.versions)
      if (o7.resolution === t11) {
        o7.refCount++;
        const t12 = this.highestResolutionVersion === o7 && !o2(s9, o7.feature);
        return (t12 || this.highestResolutionVersion !== o7) && (o7.feature = s9), i4.newVersion = t12 ? s9 : r5, i4;
      }
    const n7 = { feature: s9, resolution: t11, refCount: 1 };
    return this.versions.push(n7), !this.highestResolutionVersion || t11 < this.highestResolutionVersion.resolution ? (i4.newVersion = s9, this.highestResolutionVersion = n7) : i4.newVersion = r5, i4;
  }
  unref(e8) {
    for (let s9 = 0; s9 < this.versions.length; s9++) {
      const t11 = this.versions[s9];
      if (t11.resolution === e8)
        return t11.refCount--, i4.oldVersion = this.feature, 0 === t11.refCount && (this.versions[s9] = this.versions[this.versions.length - 1], this.versions.length--, this.highestResolutionVersion === t11 && (this._recalculateHighestResolutionVersion(), i4.oldVersion = t11.feature)), i4.newVersion = this.feature, i4;
    }
    return null;
  }
  get feature() {
    return this.highestResolutionVersion ? this.highestResolutionVersion.feature : null;
  }
  _recalculateHighestResolutionVersion() {
    if (0 === this.versions.length)
      return void (this.highestResolutionVersion = null);
    let e8 = this.versions[0];
    for (let s9 = 1; s9 < this.versions.length; s9++) {
      const t11 = this.versions[s9];
      t11.resolution < e8.resolution && (e8 = t11);
    }
    this.highestResolutionVersion = e8;
  }
};
var t10 = class {
  constructor(e8) {
    this._feature = e8, this.refCount = 1;
  }
  get isReferenced() {
    return 0 !== this.refCount;
  }
  get isSingle() {
    return 1 === this.refCount;
  }
  ref(s9) {
    return ++this.refCount, i4.oldVersion = this._feature, this.feature && Object.defineProperty(s9, "uid", { value: this.feature.uid, configurable: true }), o2(this._feature, s9) || (this._feature = s9), i4.newVersion = this._feature, i4;
  }
  unref() {
    return i4.oldVersion = this._feature, this.refCount > 0 && (this.refCount--, !this.isReferenced) ? (i4.newVersion = null, i4) : (i4.newVersion = this._feature, i4);
  }
  get feature() {
    return this._feature;
  }
};
var i4 = { oldVersion: null, newVersion: null };

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTile.js
var l6 = 16438;
var F2 = /* @__PURE__ */ new Set();
var E7 = class {
  constructor(t11) {
    this.descriptor = t11, this.fetchStatus = o6.FETCH_NEEDED, this._features = null, this._numVertices = 0, this._featureLimit = 0, this.featuresMissing = true, this._shuffled = false, this._numFeatures = c8, this._emptyFeatureRatio = 0, this._estimatedSize = -1, this._estimatedUnusedSize = 0, this._estimatedUnusedSizeDirty = false, this._availableFields = F2, this._displayingFeatures = null, this.alive = true, this.filtered = false;
  }
  get displayingFeatures() {
    return this._displayingFeatures;
  }
  set displayingFeatures(t11) {
    this._displayingFeatures = t11, this.extentIncludingBorrowedFeatures = null;
  }
  get perTileMaximumNumberOfFeaturesExceeded() {
    return !this.filtered && (this.featuresMissing || this.features && this.featureLimit !== this.features.length);
  }
  get features() {
    return this._features;
  }
  get featureLimit() {
    return this._featureLimit;
  }
  set featureLimit(t11) {
    this._featureLimit !== t11 && (this._featureLimit = t11, this._estimatedUnusedSizeDirty = true);
  }
  get availableFields() {
    return this._availableFields;
  }
  setFeatures(t11, s9, i5) {
    this._availableFields = c(i5, F2), this._features = t11, this._shuffled = false, this._estimatedSize = -1, this._estimatedUnusedSizeDirty = true, t11 && t11.length > 0 ? (this._emptyFeatureRatio = s9 / (t11.length + s9), this._numVertices = t11.reduce((t12, e8) => t12 + w2(e8.geometry), 0)) : (this._emptyFeatureRatio = 0, this._numVertices = 0);
  }
  get emptyFeatureRatio() {
    return this._emptyFeatureRatio;
  }
  get numFeatures() {
    return this.hasPreciseFeatureCount ? this._numFeatures : this._features ? this._features.length : 0;
  }
  set numFeatures(t11) {
    this._numFeatures = t11;
  }
  get hasPreciseFeatureCount() {
    return this._numFeatures > c8;
  }
  get needsFeatureCount() {
    return this._numFeatures === c8;
  }
  get numVertices() {
    return this._numVertices;
  }
  get id() {
    return this.descriptor.id;
  }
  get estimatedSize() {
    return this.updateMemoryEstimates(), this._estimatedSize;
  }
  get estimatedUnusedSize() {
    return this._estimatedUnusedSize;
  }
  updateMemoryEstimates() {
    if (this._estimatedSize < 0) {
      if (this._estimatedSize = 0, this._estimatedUnusedSize = 0, this._features)
        for (let t11 = 0; t11 < this._features.length; ++t11) {
          const e8 = A(this._features[t11]);
          this._estimatedSize += e8, t11 >= this.featureLimit && (this._estimatedUnusedSize += e8);
        }
      return true;
    }
    if (this._estimatedUnusedSizeDirty) {
      if (this._estimatedUnusedSize = 0, this._estimatedUnusedSizeDirty = false, this._features)
        for (let t11 = this.featureLimit; t11 < this._features.length; ++t11)
          this._estimatedUnusedSize += A(this._features[t11]);
      return true;
    }
    return false;
  }
  get isFetching() {
    return this.fetchStatus === o6.FETCHING || this.fetchStatus === o6.REFETCHING;
  }
  get isRefetching() {
    return this.fetchStatus === o6.REFETCHING;
  }
  get needsFetching() {
    return this.fetchStatus === o6.FETCH_NEEDED || this.fetchStatus === o6.REFETCH_NEEDED;
  }
  get needsRefetching() {
    return this.fetchStatus === o6.REFETCH_NEEDED;
  }
  get isFetched() {
    return this.fetchStatus === o6.DONE || this.fetchStatus === o6.FULL;
  }
  resetFetching() {
    this.fetchStatus = this.fetchStatus === o6.REFETCHING ? o6.REFETCH_NEEDED : o6.FETCH_NEEDED;
  }
  get needsDisplayUpdate() {
    return !!this._features && !S4(this._features, this.displayingFeatures, this.featureLimit);
  }
  intersects(t11) {
    return !t11 || !this.descriptor.extent || (c2(t11, D3), E2(this.descriptor.extent, D3));
  }
  intersectionIncludingBorrowed(t11, e8) {
    const i5 = r(this.extentIncludingBorrowedFeatures) ? this.extentIncludingBorrowedFeatures : this.descriptor.extent;
    return t11 || i5 ? (t11 ? (c2(t11, e8), U2(e8, i5, e8)) : a3(e8, i5), e8) : (a3(e8, J), e8);
  }
  _shuffle(e8) {
    this._features.sort((t11, s9) => O2(t11, e8) - O2(s9, e8)), S(this._features, l6), this._shuffled = true, this._estimatedUnusedSizeDirty = true;
  }
  reduceFeatures(t11, e8, s9) {
    if (t11 <= 0)
      return false;
    if (!this._features)
      return this.featureLimit = 0, false;
    let i5 = false;
    this.featureLimit = Math.ceil(this.numFeatures * t11), this.featureLimit > this._features.length && (this.featureLimit = this._features.length, this.fetchStatus === o6.DONE && this._features.length > 0 && (this.fetchStatus = o6.REFETCH_NEEDED, i5 = true)), !this._shuffled && t11 < 1 && this._shuffle(s9);
    const r5 = Math.max(this.featureLimit, Math.ceil(e8 * this.numFeatures));
    return this._features.length > r5 && (this._features.length = r5, this.featuresMissing = true, this.fetchStatus === o6.FULL && (this.fetchStatus = o6.DONE)), i5;
  }
  get cache() {
    return { availableFields: this._availableFields, features: this.features, numFeatures: this._numFeatures, emptyFeatureRatio: this._emptyFeatureRatio, fetchStatus: this.fetchStatus, featuresMissing: this.featuresMissing };
  }
  set cache(t11) {
    this.requestController = null, this._availableFields = t11.availableFields, this._features = t11.features, this._numFeatures = t11.numFeatures, this._emptyFeatureRatio = t11.emptyFeatureRatio, this.fetchStatus = t11.fetchStatus, this.featuresMissing = t11.featuresMissing, this._estimatedSize = -1, this._estimatedUnusedSizeDirty = true;
  }
};
var c8 = -1;
var g5 = -2;
var o6;
function S4(t11, e8, s9) {
  if (t(e8) || t(t11) || s9 !== e8.length || s9 > t11.length)
    return false;
  for (let i5 = 0; i5 < s9; ++i5)
    if (t11[i5] !== e8[i5])
      return false;
  return true;
}
!function(t11) {
  t11[t11.FETCH_NEEDED = 0] = "FETCH_NEEDED", t11[t11.REFETCH_NEEDED = 1] = "REFETCH_NEEDED", t11[t11.FETCHING = 2] = "FETCHING", t11[t11.REFETCHING = 3] = "REFETCHING", t11[t11.DONE = 4] = "DONE", t11[t11.FULL = 5] = "FULL";
}(o6 || (o6 = {}));
var D3 = u3();

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3D.js
var U4 = s2.getLogger("esri.views.3d.layers.support.FeatureTileFetcher3D");
var I2 = class extends y {
  constructor(e8) {
    super(e8), this._useTileCount = false, this.updating = false, this.updatingTotal = 0, this.updatingRemaining = 0, this.expectedFeatureDiff = 0, this.maximumNumberOfFeaturesExceeded = false, this.maximumNumberOfFeaturesExceededThrottle = 1e3, this._fullRatio = 1, this._farRatio = 1, this.changes = { updates: { adds: new Array(), removes: new Array() }, adds: new Array(), removes: new Array() }, this.handles = new u(), this._frameTask = Q, this._dirty = false, this.featureTiles = /* @__PURE__ */ new Map(), this.displayingFeatureReferences = /* @__PURE__ */ new Map(), this.numDisplayingFeatureReferences = 0, this.suspended = true, this.pendingEdits = null;
  }
  set maximumNumberOfFeatures(e8) {
    e8 = e8 || 1 / 0;
    const t11 = this._get("maximumNumberOfFeatures");
    e8 === t11 || e8 < 1 || (this._set("maximumNumberOfFeatures", e8), this._maximumFeaturesUpdated(t11, e8));
  }
  set memoryFactor(e8) {
    this.memoryFactor !== e8 && (this._set("memoryFactor", e8), this._setDirty());
  }
  set lodFactor(e8) {
    this.lodFactor !== e8 && (this._set("lodFactor", e8), this.supportsResolution && this.refetch());
  }
  get useTileCount() {
    return this._useTileCount && r(this.context.query.queryFeatureCount);
  }
  set useTileCount(e8) {
    this._useTileCount = e8, this.notifyChange("useTileCount");
  }
  get memoryForUnusedFeatures() {
    let e8 = 0;
    return this.featureTiles.forEach((t11) => e8 += t11.estimatedUnusedSize), e8;
  }
  get totalVertices() {
    let e8 = 0;
    return this.featureTiles.forEach((t11) => e8 += t11.numVertices), e8;
  }
  get totalFeatures() {
    let e8 = 0;
    return this.featureTiles.forEach((t11) => e8 += t11.numFeatures), e8;
  }
  set filterExtent(e8) {
    if (e8 && this.context.tilingScheme && !e8.spatialReference.equals(this.context.tilingScheme.spatialReference))
      return void U4.error("#filterExtent=", "extent needs to be in the same spatial reference as the tiling scheme");
    const t11 = this._get("filterExtent");
    if (t11 === e8 || t11 && e8 && t11.equals(e8))
      return;
    const s9 = e8 ? e8.clone() : null;
    this._set("filterExtent", s9), this._reclip(s9, t11);
  }
  initialize() {
    this.handles.add(a2(() => this.tileDescriptors, "change", () => this._setDirty(), { onListenerAdd: () => this._setDirty() })), this.objectIdField = this.context.objectIdField, this.FeatureReferenceClass = this.context.capabilities.supportsMultipleResolutions ? s8 : t10;
    const e8 = this.context.scheduler;
    r(e8) && (this._frameTask = e8.registerTask(L.FEATURE_TILE_FETCHER, this)), this._setDirty();
  }
  destroy() {
    this._frameTask.remove(), this.handles = l(this.handles), this.featureTiles.forEach((e8) => {
      this._cancelFetchTile(e8), this._removeTile(e8);
    }), this.featureTiles.clear(), this.displayingFeatureReferences.clear(), this.pendingEdits && (this.pendingEdits.controller.abort(), this.pendingEdits = null);
  }
  get paused() {
    return this.suspended || !!this.pendingEdits;
  }
  restart() {
    this.featureTiles.forEach((e8) => {
      this._cancelFetchTile(e8), this._clearTile(e8), this._resetFetchTile(e8);
    }), r(this.context.memoryCache) && this.context.memoryCache.clear(), this._setDirty();
  }
  refetch() {
    this.featureTiles.forEach((e8) => {
      this._cancelFetchTile(e8), this._resetFetchTile(e8);
    }), r(this.context.memoryCache) && this.context.memoryCache.clear(), this._setDirty();
  }
  suspend() {
    this.suspended || (this.suspended = true, this._pause(), this._setDirty());
  }
  resume() {
    this.suspended && (this.suspended = false, this._unpause());
  }
  _pause() {
    this.paused && (this.featureTiles.forEach((e8) => this._cancelFetchTile(e8)), this._updated());
  }
  _unpause() {
    this.paused || (this._setDirty(), this._updated());
  }
  get availableFields() {
    let e8 = null;
    return this.featureTiles.forEach((t11) => {
      t(t11.displayingFeatures) || 0 === t11.displayingFeatures.length || (t(e8) ? e8 = new Set(t11.availableFields) : e8.forEach((s9) => {
        t11.availableFields.has(s9) || e2(e8).delete(s9);
      }));
    }), r(e8) ? e8 : /* @__PURE__ */ new Set();
  }
  applyEdits(e8) {
    this.pendingEdits || (this.pendingEdits = { edits: Promise.resolve(), count: 0, controller: new AbortController() }, this._pause());
    const t11 = this.pendingEdits;
    t11.count++;
    const s9 = t11.edits.then(() => e8.result.catch((e9) => {
      if (g(e9))
        throw e9;
      return null;
    }).then((e9) => e9 ? (this._applyEditsDeleteFeatures(e9.deletedFeatures), this._applyEditsAddUpdateFeatures(e9.addedFeatures, e9.updatedFeatures, t11.controller.signal).then(() => e9)) : e9).then((e9) => (0 == --t11.count && (this.pendingEdits === t11 && (this.pendingEdits = null), r(this.context.memoryCache) && this.context.memoryCache.clear(), this._unpause(), this._updated()), e9)));
    return t11.edits = s9, this._updated(), s9;
  }
  _applyEditsDeleteFeatures(e8) {
    if (0 === e8.length)
      return;
    const t11 = this.context.globalIdField, s9 = t11 && this.availableFields.has(t11), i5 = /* @__PURE__ */ new Set(), r5 = this.objectIdField;
    e8.forEach(({ objectId: e9, globalId: a7 }) => {
      if ((!e9 || e9 < 0) && t11) {
        s9 || U4.errorOncePerTick(`Editing the specified service requires the layer's globalIdField, ${t11} to be included the layer's outFields for updates to be reflected in the view`);
        const e10 = this.features.find((e11) => e11.attributes && e11.attributes[t11] === a7);
        e10 && i5.add(O2(e10, r5));
      } else
        i5.add(e9);
    }), this.featureTiles.forEach((e9) => {
      if (!e9.features)
        return;
      const t12 = e9.features.filter((e10) => !i5.has(O2(e10, this.objectIdField)));
      t12.length !== e9.features.length && (e9.setFeatures(t12, 0, e9.availableFields), this._invalidateCounts());
    });
  }
  async _applyEditsAddUpdateFeatures(e8, t11, s9) {
    const i5 = [], r5 = /* @__PURE__ */ new Set();
    if (e8.forEach((e9) => i5.push(e9.objectId)), t11.forEach((e9) => {
      i5.push(e9.objectId), r5.add(e9.objectId);
    }), 0 === i5.length)
      return;
    const a7 = [];
    this.featureTiles.forEach((e9) => {
      const t12 = this._applyEditsAddUpdateTile(e9, i5, r5, s9);
      t12 && a7.push(t12);
    }), await E(a7);
  }
  async _applyEditsAddUpdateTile(e8, t11, s9, i5) {
    if (!e8.features)
      return;
    const r5 = this._createQuery(e8);
    r5.resultType = void 0, r5.cacheHint = false, r5.objectIds = t11;
    const a7 = await this._queryFeatures(r5, i5);
    let n7 = null;
    if (s9.size > 0) {
      const t12 = e8.features.filter((e9) => !s9.has(O2(e9, this.objectIdField)));
      t12.length !== e8.features.length && (n7 = t12);
    }
    if (a7.features.length > 0) {
      n7 || (n7 = e8.features.slice());
      for (const e9 of a7.features)
        n7.push(e9);
    }
    n7 && (e8.hasPreciseFeatureCount && (e8.numFeatures = Math.max(e8.numFeatures, n7.length)), e8.setFeatures(n7, 0, k(e8.availableFields, a7.fields)), this._invalidateCounts());
  }
  _queryFeatures(e8, t11) {
    return this.context.query.queryFeaturesDehydrated(e8, { signal: t11, timeout: G2 });
  }
  _setDirty() {
    this._dirty = true, this._updated();
  }
  get running() {
    return this.updating;
  }
  runTask(e8) {
    if (this._frameTask.processQueue(e8), !this._dirty || !this.constructed)
      return;
    this._dirty = false;
    const t11 = this._getListOfTiles();
    if (this._markTilesNotAlive(t11), !e8.run(() => this._addTiles(t11, e8)) || !e8.run(() => this._filterExtentTiles(t11, e8)) || !e8.run(() => this._removeTiles(t11, e8)) || e8.done)
      return void this._setDirty();
    const s9 = this._sortTiles(t11);
    e8.run(() => this._displayTiles(s9, e8)) && e8.run(() => this._fetchTiles(s9, e8)) && e8.run(() => this._updateMemoryEstimates(s9, e8)) || this._setDirty(), this._updated(), this.updating || this._updateMaximumNumberOfFeaturesExceeded();
  }
  _markTilesNotAlive(e8) {
    for (const t11 of e8)
      t11.alive = false;
  }
  _addTiles(e8, t11) {
    return !this.suspended && (this.tileDescriptors.forEach((s9) => {
      const i5 = this.featureTiles.get(s9.id);
      i5 ? i5.alive = true : t11.done || (e8.push(this._addTile(s9)), t11.madeProgress());
    }), t11.hasProgressed);
  }
  _filterExtentTiles(e8, t11) {
    for (const s9 of e8) {
      if (t11.done)
        break;
      s9.alive && (s9.filtered = !s9.intersects(this.filterExtent), s9.filtered && (this._clearTile(s9), t11.madeProgress()));
    }
    return t11.hasProgressed;
  }
  _removeTiles(e8, t11) {
    for (let s9 = e8.length - 1; s9 >= 0 && !t11.done; s9--) {
      const i5 = e8[s9];
      i5.alive || (this._removeTile(i5), s9 !== e8.length - 1 && (e8[s9] = e8[e8.length - 1]), e8.pop(), t11.madeProgress());
    }
    return t11.hasProgressed;
  }
  _sortTiles(e8) {
    return e8.sort((e9, t11) => e9.descriptor.loadPriority - t11.descriptor.loadPriority), e8;
  }
  _displayTiles(e8, t11) {
    const s9 = this._updateRatio(e8), i5 = (e9) => {
      const t12 = this._fullRatio < 1 ? s9(e9) * this._farRatio : 1;
      return e9.reduceFeatures(t12, this.memoryFactor, this.objectIdField) && this._setDirty(), this._showTile(e9);
    };
    for (const r5 of e8)
      if (!t11.run(() => i5(r5))) {
        this._setDirty();
        break;
      }
    return t11.hasProgressed;
  }
  _fetchTiles(e8, t11) {
    if (this.paused)
      return false;
    let s9 = false;
    for (const i5 of e8) {
      if (!i5.needsFetching)
        continue;
      const e9 = r(this.context.memoryCache) ? this.context.memoryCache.pop(i5.id) : null;
      if (r(e9))
        i5.cache = e9, this._setDirty(), this._scheduleUpdated(), t11.madeProgress();
      else {
        if (this._needsNumFeatures(i5)) {
          const e10 = new AbortController(), r5 = this._fetchTileCount(i5, e10.signal);
          this._handleRequest(i5, r5, e10, () => i5.numFeatures = g5), s9 = true, t11.madeProgress();
        }
        if (t11.done)
          return true;
      }
    }
    if (s9)
      return t11.hasProgressed;
    for (const i5 of e8)
      if (i5.needsFetching) {
        const e9 = new AbortController(), s10 = this._fetchTile(i5, e9.signal);
        if (this._handleRequest(i5, s10, e9, (e10) => {
          i5.setFeatures([], 0, null), this._invalidateCounts(), i5.featuresMissing = false, this.context.logFetchError(U4, e10);
        }), t11.madeProgress(), t11.done)
          return true;
      }
    return t11.hasProgressed;
  }
  _updateMemoryEstimates(e8, t11) {
    return e8.some((e9) => !t11.run(() => e9.updateMemoryEstimates()) && (this._setDirty(), true)), t11.hasProgressed;
  }
  _reclip(e8, t11) {
    if (!this.constructed)
      return;
    const s9 = new Array();
    this.featureTiles.forEach((i5) => {
      t(i5.displayingFeatures) || 0 === i5.displayingFeatures.length || (i5.intersectionIncludingBorrowed(t11, z), i5.intersectionIncludingBorrowed(e8, B2), I(z, B2) || s9.push(i5));
    }), this._refreshDisplayingFeatures(s9), this._updated();
  }
  _refreshDisplayingFeatures(e8) {
    const t11 = /* @__PURE__ */ new Set(), s9 = this.changes.updates;
    for (const i5 of e8)
      if (!t(i5.displayingFeatures))
        for (const e9 of i5.displayingFeatures) {
          const i6 = O2(e9, this.objectIdField);
          if (t11.has(i6))
            continue;
          t11.add(i6);
          const { feature: r5 } = this.displayingFeatureReferences.get(i6);
          s9.removes.push(r5), s9.adds.push(r5);
        }
    this._applyChanges();
  }
  _updated() {
    let e8 = 0;
    this.paused || this.featureTiles.forEach((t12) => t12.isFetching ? ++e8 : 0);
    const t11 = this._dirty || e8 > 0 || !!this.pendingEdits;
    if (this._set("updating", t11), t11) {
      let t12 = 0, s9 = 0, i5 = 0, r5 = 0, n7 = 0;
      const o7 = this.displayingFeatureReferences.size / this.numDisplayingFeatureReferences;
      this.featureTiles.forEach((e9) => {
        if (++s9, e9.isFetching && e9.hasPreciseFeatureCount) {
          const t13 = this._maximumFeaturesForTile(e9) * (1 - e9.emptyFeatureRatio), s10 = r(e9.displayingFeatures) ? e9.displayingFeatures.length * o7 : 0;
          n7 += t13 - s10;
        }
        e9.needsFetching ? ++r5 : e9.numFeatures > 0 && (++i5, t12 += e9.numFeatures);
      }), r5 += e8;
      let u7 = 0, l8 = 0;
      t12 ? (l8 = t12, u7 = Math.min(r5 * t12 / i5, t12)) : (l8 = s9, u7 = r5), n7 = Math.min(this.maximumNumberOfFeatures - this.features.length, n7), this._set("updatingTotal", l8), this._set("updatingRemaining", u7), this._set("expectedFeatureDiff", n7);
    } else
      this._set("updatingTotal", 0), this._set("updatingRemaining", 0), this._set("expectedFeatureDiff", 0);
    this.debugger && this.debugger.update();
  }
  _updateMaximumNumberOfFeaturesExceeded() {
    const e8 = n2(this.featureTiles, (e9) => e9.perTileMaximumNumberOfFeaturesExceeded);
    this._set("maximumNumberOfFeaturesExceeded", e8);
  }
  _updateRatio(e8) {
    const t11 = A3(e8), s9 = (e9) => 1 / (1 << Math.max(0, t11 - e9.descriptor.lij[0]));
    let i5 = 0, r5 = 0;
    for (const a7 of e8) {
      const e9 = a7.numFeatures;
      i5 += e9, r5 += e9 * s9(a7);
    }
    return this._fullRatio = Math.min(1, this.maximumNumberOfFeatures / i5), this._farRatio = this.maximumNumberOfFeatures / r5, this._scheduleUpdated(), s9;
  }
  _maximumFeaturesUpdated(e8, t11) {
    e8 !== t11 && (t11 > e8 && this.featureTiles.forEach((e9) => {
      if (!e9.featuresMissing)
        return;
      const t12 = this._maximumFeaturesForTile(e9);
      e9.features && (e9.features.length >= t12 || e9.fetchStatus === o6.FULL) || (this._cancelFetchTile(e9), this._resetFetchTile(e9));
    }), this._setDirty());
  }
  _addTile(e8) {
    const t11 = new E7(e8);
    return this.featureTiles.set(t11.id, t11), this._resetFetchTile(t11), this._referenceDisplayingFeaturesFromRelatedTiles(t11), t11;
  }
  _referenceDisplayingFeaturesFromRelatedTiles(e8) {
    const t11 = e8.descriptor.resolution;
    this.featureTiles.forEach((s9) => {
      if (!(t(s9.displayingFeatures) || e8 === s9 || e8.descriptor.lij && s9.descriptor.lij && !p3(e8.descriptor.lij, s9.descriptor.lij))) {
        t(e8.displayingFeatures) && (e8.displayingFeatures = []), e8.descriptor.extent && s9.descriptor.extent && (t(e8.extentIncludingBorrowedFeatures) && (e8.extentIncludingBorrowedFeatures = e3(e8.descriptor.extent)), h2(e8.extentIncludingBorrowedFeatures, s9.descriptor.extent, e8.extentIncludingBorrowedFeatures));
        for (const i5 of s9.displayingFeatures) {
          e8.displayingFeatures.push(i5);
          const s10 = this.displayingFeatureReferences.get(O2(i5, this.objectIdField));
          s10.ref(s10.feature, t11), this.numDisplayingFeatureReferences++;
        }
      }
    }), e8.featureLimit = r(e8.displayingFeatures) ? e8.displayingFeatures.length : 0;
  }
  _removeTile(e8) {
    this._clearTile(e8), this.featureTiles.delete(e8.id);
  }
  _resetFetchTile(e8) {
    e8.filtered = !e8.intersects(this.filterExtent), e8.filtered ? e8.needsFetching && (e8.fetchStatus = o6.DONE) : e8.fetchStatus = o6.FETCH_NEEDED;
  }
  _cancelFetchTile(e8) {
    const t11 = e8.requestController;
    r(t11) && (e8.requestController = null, e8.resetFetching(), t11.abort());
  }
  async _fetchTileCount(e8, t11) {
    return e8.numFeatures = await this._fetchCount(e8, t11), this._updateRatio(this._getListOfTiles()), e8.fetchStatus === o6.REFETCHING ? o6.REFETCH_NEEDED : o6.FETCH_NEEDED;
  }
  async _fetchTile(e8, t11) {
    const s9 = this._maximumFeaturesForTile(e8);
    if (s9 <= 0)
      return Q2(e8);
    const i5 = this._getMaxRecordCount(e8), r5 = Math.ceil(s9 / i5);
    if (q(e8) || !this.context.capabilities.supportsMaxRecordCountFactor || e8.numFeatures <= s9 && r5 > b2.MAX_MAX_RECORD_COUNT_FACTOR)
      return this._fetchPagedTile(e8, t11);
    const a7 = this._createQuery(e8);
    if (a7.maxRecordCountFactor = Math.ceil(s9 / i5), e8.isRefetching && e8.features && e8.features.length > 0) {
      const t12 = Math.ceil(e8.features.length / (1 - e8.emptyFeatureRatio) / i5);
      a7.maxRecordCountFactor = Math.max(t12 + 1, a7.maxRecordCountFactor);
    }
    const { features: n7, exceededTransferLimit: o7, fields: u7 } = await this._queryFeatures(a7, t11), l8 = o7 ? a7.maxRecordCountFactor >= b2.MAX_MAX_RECORD_COUNT_FACTOR ? o6.FULL : o6.DONE : o6.FULL;
    return await this._frameTask.schedule(() => {
      e8.featuresMissing = n7.length < e8.numFeatures || o7;
      const t12 = this._removeEmptyFeatures(n7);
      e8.setFeatures(n7, t12, H(u7));
    }, t11), f(t11), this._invalidateCounts(), l8;
  }
  async _fetchCount(e8, t11) {
    return this.context.query.queryFeatureCount(this._createFeatureCountQuery(e8), { signal: t11 });
  }
  async _fetchPagedTile(e8, t11) {
    let s9, i5 = 0, r5 = 0, a7 = 0, n7 = this._maximumFeaturesForTile(e8) - a7;
    const o7 = this._getMaxRecordCount(e8);
    let l8 = null;
    for (; ; ) {
      const h5 = this._createQuery(e8), d8 = this._setPagingParameters(h5, i5, n7, o7), { features: p6, exceededTransferLimit: f5, fields: m5 } = await this._queryFeatures(h5, t11);
      if (await this._frameTask.schedule(() => {
        d8 && (i5 += e2(h5.num)), a7 += p6.length, r5 += this._removeEmptyFeatures(p6), e8.featuresMissing = i5 < e8.numFeatures || f5, s9 = s9 ? s9.concat(p6) : p6, l8 = k(l8, m5), e8.setFeatures(s9, r5, l8);
      }, t11), f(t11), this._invalidateCounts(), this._setDirty(), n7 = this._maximumFeaturesForTile(e8) - a7, !d8 || !f5 || n7 <= 0)
        return f5 ? o6.DONE : o6.FULL;
    }
  }
  _createFeatureCountQuery(e8) {
    const t11 = this._createQuery(e8);
    return this.context.capabilities.supportsCacheHint && (t11.resultType = void 0, t11.cacheHint = true), t11;
  }
  _createQuery(e8) {
    const t11 = this.context.createQuery(), s9 = e8.descriptor.extent;
    if (s9) {
      const e9 = this.context.tilingScheme.spatialReference;
      t11.geometry = f2(s9, e9);
    }
    return this._setResolutionParams(t11, e8), this._useTileQuery(e8) ? t11.resultType = "tile" : this.context.capabilities.supportsCacheHint && (t11.cacheHint = true), t11;
  }
  _setPagingParameters(e8, t11, s9, i5) {
    return !!this.context.capabilities.supportsPagination && (e8.start = t11, s9 > 0 && this.context.capabilities.supportsMaxRecordCountFactor ? (e8.maxRecordCountFactor = Math.ceil(s9 / i5), e8.num = Math.min(e8.maxRecordCountFactor * i5, s9)) : e8.num = Math.min(i5), true);
  }
  _getEffectiveTileResolution(e8) {
    if (null == e8.descriptor.resolution)
      return null;
    const t11 = this.context.viewingMode === l3.Global ? this.context.tilingScheme.resolutionAtLevel(3) : 1 / 0;
    return Math.min(e8.descriptor.resolution, t11) / this.lodFactor;
  }
  get supportsResolution() {
    return this.context.capabilities.supportsMultipleResolutions && "point" !== this.context.geometryType;
  }
  _setResolutionParams(e8, t11) {
    if (!this.supportsResolution)
      return;
    const s9 = this._getEffectiveTileResolution(t11);
    null != s9 && (this.context.capabilities.supportsQuantization ? e8.quantizationParameters = new a4({ mode: "view", originPosition: "upper-left", tolerance: s9, extent: this.context.fullExtent }) : "polyline" === this.context.geometryType && (e8.maxAllowableOffset = s9));
  }
  _removeEmptyFeatures(e8) {
    const t11 = e8.length;
    for (let s9 = 0; s9 < e8.length; ) {
      const t12 = e8[s9];
      S2(t12.geometry) ? ++s9 : (e8[s9] = e8[e8.length - 1], --e8.length);
    }
    return t11 - e8.length;
  }
  _needsNumFeatures(e8) {
    return this.useTileCount && e8.needsFeatureCount && !q(e8);
  }
  _getMaxRecordCount(e8) {
    const { tileMaxRecordCount: t11, maxRecordCount: s9 } = this.context;
    return this._useTileQuery(e8) && r(t11) && t11 > 0 && this.context.capabilities.supportsResultType ? t11 : r(s9) && s9 > 0 ? s9 : V3;
  }
  _useTileQuery(e8) {
    return (!q(e8) || !this.context.capabilities.supportsCacheHint) && this.context.capabilities.supportsResultType;
  }
  _handleRequest(e8, t11, s9, i5) {
    e8.fetchStatus = e8.needsRefetching ? o6.REFETCHING : o6.FETCHING, e8.requestController = s9;
    let r5 = false;
    t11.then((t12) => {
      e8.requestController = null, e8.fetchStatus = t12;
    }).catch((t12) => {
      e8.requestController === s9 && (e8.requestController = null, e8.fetchStatus = o6.DONE), g(t12) ? r5 = true : i5(t12);
    }).then(() => {
      r5 || this._setDirty(), this._scheduleUpdated();
    });
  }
  _scheduleUpdated() {
    this.handles && !this.handles.has("scheduleUpdated") && this.handles.add(v(() => {
      this.handles.remove("scheduleUpdated"), this._updated();
    }), "scheduleUpdated");
  }
  _showTile(e8) {
    if (r(e8.displayingFeatures) && !e8.needsDisplayUpdate)
      return false;
    const t11 = e8.features;
    if (0 === e8.featureLimit || !t11) {
      const t12 = r(e8.displayingFeatures) && e8.displayingFeatures.length > 0;
      return this._hideTileFeatures(e8), e8.displayingFeatures = [], t12;
    }
    const s9 = e8.descriptor.resolution, i5 = this.changes.updates, r5 = this.changes.adds, n7 = Math.min(e8.featureLimit, t11.length);
    e8.featureLimit = n7;
    for (let a7 = 0; a7 < n7; ++a7) {
      const e9 = t11[a7], n8 = O2(e9, this.objectIdField), o7 = this.displayingFeatureReferences.get(n8);
      if (o7) {
        const t12 = o7.ref(e9, s9);
        t12.oldVersion !== t12.newVersion && (i5.removes.push(t12.oldVersion), i5.adds.push(t12.newVersion));
      } else
        this.displayingFeatureReferences.set(n8, new this.FeatureReferenceClass(e9, s9)), r5.push(e9);
      this.numDisplayingFeatureReferences++;
    }
    return this._hideTileFeatures(e8), this._applyChanges(), e8.displayingFeatures = t11.slice(0, n7), true;
  }
  _hideTile(e8) {
    this._cancelFetchTile(e8), this._hideTileFeatures(e8);
  }
  _hideTileFeatures(e8) {
    if (t(e8.displayingFeatures))
      return;
    const t11 = this.changes.updates, s9 = this.changes.removes;
    for (const i5 of e8.displayingFeatures) {
      const r5 = O2(i5, this.objectIdField), a7 = this.displayingFeatureReferences.get(r5);
      if (!a7)
        continue;
      const n7 = a7.unref(e8.descriptor.resolution);
      this.numDisplayingFeatureReferences--, n7 ? n7.oldVersion !== n7.newVersion && (null == n7.newVersion ? (this.displayingFeatureReferences.delete(r5), s9.push(n7.oldVersion)) : (t11.adds.push(n7.newVersion), t11.removes.push(n7.oldVersion))) : console.error("Hiding unreferenced feature");
    }
    this._applyChanges(), e8.displayingFeatures = null;
  }
  _applyChanges() {
    const e8 = this.changes.updates;
    e8.removes.length > 0 && (this.features.removeMany(e8.removes), e8.removes.length = 0), e8.adds.length > 0 && (this.features.addMany(e8.adds), e8.adds.length = 0);
    const t11 = this.changes.adds, s9 = this.changes.removes, i5 = Math.min(t11.length, s9.length);
    let r5 = 0;
    for (; r5 < i5; ) {
      const e9 = Math.min(r5 + X, i5);
      this.features.addMany(t11.slice(r5, e9)), this.features.removeMany(s9.slice(r5, e9)), r5 = e9;
    }
    t11.length > i5 && this.features.addMany(0 === r5 ? t11 : t11.slice(r5)), s9.length > i5 && this.features.removeMany(0 === r5 ? s9 : s9.slice(r5)), t11.length = 0, s9.length = 0;
  }
  _clearTile(e8) {
    if (this._hideTile(e8), e8.features && r(this.context.memoryCache)) {
      const t11 = 16 + e8.estimatedSize;
      this.context.memoryCache.put(e8.id, e8.cache, t11);
    }
    e8.setFeatures(null, 0, null), this._invalidateCounts();
  }
  _invalidateCounts() {
    this.notifyChange("totalVertices"), this.notifyChange("totalFeatures"), this.notifyChange("memoryForUnusedFeatures");
  }
  _getListOfTiles() {
    return Array.from(this.featureTiles.values());
  }
  get storedFeatures() {
    return this._getListOfTiles().reduce((e8, t11) => e8 + (t11.features ? t11.features.length : 0), 0);
  }
  _maximumFeaturesForTile(e8) {
    const t11 = e8.hasPreciseFeatureCount ? e8.numFeatures : 1 / 0, s9 = e8.hasPreciseFeatureCount ? t11 : this.maximumNumberOfFeatures, i5 = this._fullRatio < 1 ? this._farRatio : 1;
    return Math.min(Math.ceil(s9 * i5 / (1 - e8.emptyFeatureRatio)), t11);
  }
  get test() {
    return { process: (e8) => this.runTask(e8), getFeatureTileById: (e8) => this.featureTiles.get(e8), forEachFeatureTile: (e8) => this.featureTiles.forEach(e8) };
  }
};
function q(e8) {
  return "dummy-tile-full-extent" === e8.id;
}
function A3(e8) {
  let t11 = 0;
  for (const s9 of e8)
    s9.features && s9.features.length > 0 && s9.alive && (t11 = Math.max(t11, s9.descriptor.lij[0]));
  return t11;
}
function S5(e8) {
  const t11 = e8.capabilities.query;
  return { supportsMultipleResolutions: L3(e8), supportsPagination: !(!t11 || !t11.supportsPagination), supportsResultType: !(!t11 || !t11.supportsResultType), supportsCacheHint: !(!t11 || !t11.supportsCacheHint), supportsQuantization: !(!t11 || !t11.supportsQuantization), supportsQuantizationEditMode: !(!t11 || !t11.supportsQuantizationEditMode), supportsMaxRecordCountFactor: !(!t11 || !t11.supportsMaxRecordCountFactor), supportsFormatPBF: !(!t11 || !t11.supportsFormatPBF) };
}
function L3(e8) {
  switch (e8.geometryType) {
    case "polyline":
      return true;
    case "polygon":
      return e8.capabilities && e8.capabilities.query && e8.capabilities.query.supportsQuantization;
    default:
      return false;
  }
}
function Q2(e8) {
  return e8.setFeatures([], 0, null), e8.featuresMissing = false, o6.DONE;
}
function H(e8) {
  return t(e8) ? /* @__PURE__ */ new Set() : new Set(e8.map((e9) => e9.name));
}
function k(e8, t11) {
  if (t(e8) || t(t11))
    return H(t11);
  const s9 = /* @__PURE__ */ new Set();
  for (const { name: i5 } of t11)
    e8.has(i5) && s9.add(i5);
  return s9;
}
e([d2({ constructOnly: true })], I2.prototype, "features", void 0), e([d2()], I2.prototype, "tileDescriptors", void 0), e([d2({ value: 1 / 0 })], I2.prototype, "maximumNumberOfFeatures", null), e([d2({ value: 1 })], I2.prototype, "memoryFactor", null), e([d2({ value: 1 })], I2.prototype, "lodFactor", null), e([d2()], I2.prototype, "useTileCount", null), e([d2({ readOnly: true })], I2.prototype, "updating", void 0), e([d2({ readOnly: true })], I2.prototype, "updatingTotal", void 0), e([d2({ readOnly: true })], I2.prototype, "updatingRemaining", void 0), e([d2({ readOnly: true })], I2.prototype, "expectedFeatureDiff", void 0), e([d2({ readOnly: true })], I2.prototype, "memoryForUnusedFeatures", null), e([d2({ readOnly: true })], I2.prototype, "maximumNumberOfFeaturesExceeded", void 0), e([d2({ constructOnly: true })], I2.prototype, "maximumNumberOfFeaturesExceededThrottle", void 0), e([d2({ readOnly: true })], I2.prototype, "totalVertices", null), e([d2({ readOnly: true })], I2.prototype, "totalFeatures", null), e([d2()], I2.prototype, "filterExtent", null), e([d2({ constructOnly: true })], I2.prototype, "context", void 0), I2 = e([n3("esri.views.3d.layers.support.FeatureTileFetcher3D")], I2);
var V3 = 2e3;
var z = u3();
var B2 = u3();
var G2 = 6e5;
var X = 200;

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3DDebugger.js
var h4 = [[0, 179, 255], [117, 62, 128], [0, 104, 255], [215, 189, 166], [32, 0, 193], [98, 162, 206], [102, 112, 129], [52, 125, 0], [142, 118, 246], [138, 83, 0], [92, 122, 255], [122, 55, 83], [0, 142, 255], [81, 40, 179], [0, 200, 244], [13, 24, 127], [0, 170, 147], [19, 58, 241], [22, 44, 35]];
var l7 = class {
  constructor(e8, t11, s9) {
    this.loadingGraphics = /* @__PURE__ */ new Map(), this.loadedGraphics = /* @__PURE__ */ new Map(), this.pendingGraphics = /* @__PURE__ */ new Map(), this._enabled = true, this.tileFetcher = e8, this.view = s9, this.tilingScheme = new M2(t11), this.loadedSymbols = h4.map((e9) => new S3(new f3({ material: { color: [e9[0], e9[1], e9[2], 0.6] }, outline: { color: "black", size: 1 } }))), this.loadingSymbols = [new S3(new f3({ material: { color: [200, 200, 200, 0.4] }, outline: { color: [30, 30, 30], size: 1 } }))], this.pendingSymbols = [new S3(new f3({ material: { color: [100, 100, 100, 0.4] }, outline: { color: [30, 30, 30], size: 1 } }))], this.dataExtentSymbol = new S3(new f3({ material: { color: [0, 0, 0, 0] }, outline: { color: "green", size: 4 } }));
  }
  destroy() {
    this.enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e8) {
    this._enabled = e8, this.update();
  }
  update() {
    this._enabled ? (this._synchronizeMaps(this.loadingGraphics, { filter: (e8) => e8.isFetching, symbols: this.loadingSymbols }), this._synchronizeMaps(this.loadedGraphics, { filter: (e8) => !e8.isFetching, symbols: this.loadedSymbols }), this._synchronizeMaps(this.pendingGraphics, { filter: (e8) => !e8.isFetching, symbols: this.pendingSymbols }), this.showDataExtent(this.tileFetcher.filterExtent)) : (this.loadingGraphics.forEach((e8) => {
      this.view.graphics.removeMany(e8);
    }), this.loadingGraphics.clear(), this.loadedGraphics.forEach((e8) => {
      this.view.graphics.removeMany(e8);
    }), this.loadedGraphics.clear(), this.pendingGraphics.forEach((e8) => {
      this.view.graphics.removeMany(e8);
    }), this.pendingGraphics.clear(), this.dataExtentGraphic && (this.view.graphics.remove(this.dataExtentGraphic), this.dataExtentGraphic = null));
  }
  showDataExtent(i5) {
    if (this.dataExtentGraphic && (this.view.graphics.remove(this.dataExtentGraphic), this.dataExtentGraphic = null), !i5)
      return;
    const s9 = v2.fromExtent(i5);
    this.dataExtentGraphic = new g4({ geometry: s9, symbol: this.dataExtentSymbol }), this.view.graphics.add(this.dataExtentGraphic);
  }
  _synchronizeMaps(t11, i5) {
    const a7 = [];
    t11.forEach((e8, t12) => {
      const s9 = this.tileFetcher.test.getFeatureTileById(t12);
      s9 && i5.filter(s9) || (this.view.graphics.removeMany(e8), a7.push(t12));
    }), a7.forEach((e8) => t11.delete(e8)), this.tileFetcher.test.forEachFeatureTile((a8) => {
      if (i5.filter(a8) && !t11.has(a8.id)) {
        const [r5, h5, l8] = a8.descriptor.lij;
        this.tilingScheme.ensureMaxLod(r5);
        const n7 = this.tilingScheme.getExtentGeometry(r5, h5, l8), c9 = [new g4({ geometry: n7, symbol: i5.symbols[r5 % i5.symbols.length] }), new g4({ geometry: n7.center, symbol: new h3({ verticalOffset: { screenLength: 40 / 0.75 }, callout: { type: "line", color: "white", border: { color: "black" } }, symbolLayers: [new j3({ text: `${r5}/${h5}/${l8}`, halo: { color: "white", size: 1 / 0.75 }, material: { color: "black" }, size: 16 })] }) })];
        t11.set(a8.id, c9), this.view.graphics.addMany(c9);
      }
    });
  }
};

// node_modules/@arcgis/core/layers/graphics/controllers/FeatureTileController3D.js
var O3 = s2.getLogger("esri.layers.graphics.controllers.FeatureTileController3D");
var I3 = class extends m3(y) {
  constructor(e8) {
    super(e8), this.type = "feature-tile-3d", this.watchUpdatingTracking = new c3(), this.serviceDataExtent = null, this.serviceDataCount = P2.NO_SERVICE_DATA_COUNT, this.vertexLimitExceeded = false, this.displayFeatureLimit = null, this.suspended = false, this.tileFetcher = null, this.handles = new u(), this.fetchDataInfoPromise = null, this.fetchDataInfoAbortController = null, this.lifeCycleAbortController = new AbortController();
  }
  set extent(e8) {
    if (e8 && !e8.spatialReference.equals(this.layerView.view.spatialReference))
      return void O3.error("#extent=", "extent needs to be in the same spatial reference as the view");
    const t11 = this._get("extent");
    if (t11 === e8)
      return;
    if (t11 && e8 && t11.equals(e8))
      return;
    const i5 = e8 ? e8.clone() : null;
    this._set("extent", i5);
  }
  get updating() {
    return !!(r(this.tileFetcher) && this.tileFetcher.updating || null != this.fetchDataInfoPromise || "tiles" === this.mode && this.layerView.view.featureTiles && this.layerView.view.featureTiles.updating || this.watchUpdatingTracking && this.watchUpdatingTracking.updating);
  }
  get updatingTotal() {
    return this.updating && r(this.tileFetcher) ? this.tileFetcher.updatingTotal : 0;
  }
  get updatingRemaining() {
    return this.updating && r(this.tileFetcher) ? this.tileFetcher.updatingRemaining : 0;
  }
  get expectedFeatureDiff() {
    return this.updating && r(this.tileFetcher) ? this.tileFetcher.expectedFeatureDiff : 0;
  }
  get memoryForUnusedFeatures() {
    return r(this.tileFetcher) ? this.tileFetcher.memoryForUnusedFeatures : 0;
  }
  get maximumNumberOfFeaturesExceeded() {
    return !(!r(this.tileFetcher) || !this.tileFetcher.maximumNumberOfFeaturesExceeded);
  }
  get maximumNumberOfFeatures() {
    return r(this.displayFeatureLimit) ? this.displayFeatureLimit.maximumNumberOfFeatures : 0;
  }
  set maximumNumberOfFeatures(e8) {
    e8 !== this.maximumNumberOfFeatures && (null == e8 ? this._clearOverride("maximumNumberOfFeatures") : this._override("maximumNumberOfFeatures", e8));
  }
  get hasMaximumNumberOfFeaturesOverride() {
    return this._isOverridden("maximumNumberOfFeatures");
  }
  get mode() {
    var _a, _b;
    const e8 = this.layerView.layer;
    if ("feature" === e8.type && r(e8.infoFor3D))
      return "snapshot";
    if (false === ((_b = (_a = this.layerView.view.qualitySettings) == null ? void 0 : _a.graphics3D) == null ? void 0 : _b.snapshotAvailable) || this.serviceDataCount === P2.NO_SERVICE_DATA_COUNT || this.vertexLimitExceeded)
      return "tiles";
    const t11 = this.layerView.view, i5 = t11 && t11.featureTiles, r5 = i5 && i5.tilingScheme;
    if (e8 && e8.minScale && this.serviceDataExtent && r5) {
      const t12 = this._approximateExtentSizeAtScale(e8.minScale, r5);
      if ((this.serviceDataExtent.width / t12 + this.serviceDataExtent.height / t12) / 2 > P2.MAX_SNAPSHOT_MIN_SCALE_FACTOR)
        return "tiles";
    }
    return !this.maximumNumberOfFeatures || this.serviceDataCount <= this.maximumNumberOfFeatures ? "snapshot" : "tiles";
  }
  get maxTotalSnapshotVertices() {
    const e8 = this._get("maxTotalSnapshotVertices") || 0, t11 = "snapshot" === this.mode && r(this.tileFetcher) && this.tileFetcher.totalVertices || 0;
    return Math.max(e8, t11);
  }
  _approximateExtentSizeAtScale(e8, t11) {
    const i5 = this.layerView.view, r5 = Math.ceil((i5.width / t11.pixelSize + i5.height / t11.pixelSize) / 2), s9 = t11.levels[0];
    return r5 * ((s9.tileSize[0] / (s9.scale / e8) + s9.tileSize[1] / (s9.scale / e8)) / 2);
  }
  get tileDescriptors() {
    return "snapshot" === this.mode ? new j([{ id: "dummy-tile-full-extent", lij: [0, 0, 0] }]) : this.layerView.view.featureTiles ? this.layerView.view.featureTiles.tiles : new j();
  }
  get test() {
    return { fetchDataInfoPromise: this.fetchDataInfoPromise, tileFetcher: this.tileFetcher };
  }
  initialize() {
    this.watchUpdatingTracking.add(() => this.vertexLimitInfo, () => this.watchUpdatingTracking.addPromise(this._updateVertexLimitExceeded(null, this.lifeCycleAbortController.signal))), this.watchUpdatingTracking.add(() => this.mode, () => this._modeChanged(), h), this.addResolvingPromise(Promise.resolve().then(() => this._verifyCapabilities()).then(() => this.watchUpdatingTracking.addPromise(this._fetchServiceDataInfo())).then(() => this._initializeTileFetcher()));
  }
  _verifyCapabilities() {
    const e8 = this.layerView.layer;
    if (!e8.get("capabilities.operations.supportsQuery") && "ogc-feature" !== e8.type)
      throw new s3("graphicscontroller:query-capability-required", "Service requires query capabilities to be used as a feature layer", { layer: e8 });
  }
  destroy() {
    this._cancelFetchServiceDataInfo(), this.tileFetcher = l(this.tileFetcher), this.handles = l(this.handles), this.tilesHandle = a(this.tilesHandle), this.lifeCycleAbortController && (this.lifeCycleAbortController.abort(), this.lifeCycleAbortController = null), this.watchUpdatingTracking.destroy(), this._set("watchUpdatingTracking", null);
  }
  suspend() {
    this.suspended || (this.suspended = true, r(this.tileFetcher) && this.tileFetcher.suspend());
  }
  resume() {
    this.suspended && (this.suspended = false, r(this.tileFetcher) && this.tileFetcher.resume());
  }
  restart() {
    const e8 = () => {
      r(this.tileFetcher) && this.tileFetcher.restart();
    };
    this.watchUpdatingTracking.addPromise(this._fetchServiceDataInfo().then(e8, e8));
  }
  refetch() {
    const e8 = () => {
      r(this.tileFetcher) && this.tileFetcher.refetch();
    };
    this.watchUpdatingTracking.addPromise(this._fetchServiceDataInfo().then(e8, e8));
  }
  _initializeTileFetcher() {
    const e8 = this.layerView.view;
    if (!e8)
      return;
    const t11 = j2(() => {
      var _a;
      return (_a = e8.featureTiles) == null ? void 0 : _a.tilingScheme;
    }, this.lifeCycleAbortController.signal);
    this.watchUpdatingTracking.addPromise(t11), t11.then(() => {
      const { layerView: t12, tileDescriptors: i5 } = this, r5 = t12.layer, s9 = new I2({ context: this.context, filterExtent: this.extent, tileDescriptors: i5, features: this.graphics });
      this.tileFetcher = s9, this.suspended ? this.tileFetcher.suspend() : this.tileFetcher.resume();
      const a7 = this.layerView.view.resourceController;
      a7 && this.handles.add(l2(() => a7.memoryController.memoryFactor, (e9) => s9.memoryFactor = e9, w));
      const o7 = "polygon" === this.context.geometryType ? "polygonLodFactor" : "polyline" === this.context.geometryType ? "polylineLodFactor" : null;
      o7 && this.handles.add(l2(() => {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.layerView.view) == null ? void 0 : _a.qualitySettings) == null ? void 0 : _b.graphics3D) == null ? void 0 : _c[o7];
      }, (e9) => s9.lodFactor = e9 || 1, h));
      const n7 = (e9) => {
        s9.maximumNumberOfFeatures = e9, s9.useTileCount = this.serviceDataCount > e9;
      }, l8 = (e9) => s9.useTileCount = e9 > this.maximumNumberOfFeatures;
      "ogc-feature" !== r5.type && this.watchUpdatingTracking.add(() => r5.createQueryVersion, () => this._dataFilterChanged()), this.watchUpdatingTracking.add(() => t12.availableFields, (e9, t13) => this._availableFieldsChanged(t13, e9)), this.watchUpdatingTracking.add(() => t12.requiredFields, (e9, t13) => this._requiredFieldsChanged(t13, e9)), this.handles.add([r5.on("apply-edits", (e9) => this._applyEdits(e9)), l2(() => this.extent, (e9) => s9.filterExtent = e9, U), l2(() => this.tileDescriptors, (e9) => s9.tileDescriptors = e9, U), l2(() => this.maximumNumberOfFeatures, n7, w), l2(() => this.serviceDataCount, l8, w), l2(() => t9.FEATURE_TILE_FETCH_SHOW_TILES, (t13) => {
        t13 && s9 && !s9.debugger ? (s9.debugger = new l7(s9, e8.featureTiles.tilingScheme.toTileInfo(), e8), s9.debugger.update()) : !t13 && this.tileFetcher && s9.debugger && (s9.debugger.destroy(), s9.debugger = null);
      }, w)]), this.supportsExceedsLimitQuery || this.watchUpdatingTracking.add(() => this.maxTotalSnapshotVertices, () => this.watchUpdatingTracking.addPromise(this._updateVertexLimitExceeded(null, this.lifeCycleAbortController.signal)));
    }).catch(() => {
    });
  }
  _modeChanged() {
    switch (this.mode) {
      case "tiles":
        this.tilesHandle || (this.tilesHandle = this.layerView.view.featureTiles.addClient());
        break;
      default:
        O3.warn("Unhandled feature layer mode " + this.mode);
      case "snapshot":
        r(this.tilesHandle) && (this.tilesHandle.remove(), this.tilesHandle = null);
    }
  }
  _dataFilterChanged() {
    this._set("maxTotalSnapshotVertices", 0), this.notifyChange("maxTotalSnapshotVertices"), this.refetch();
  }
  _applyEdits(e8) {
    t(this.tileFetcher) || this.tileFetcher.applyEdits(e8).then((e9) => {
      e9 && (e9.deletedFeatures.length || e9.updatedFeatures.length || e9.addedFeatures.length) && this.watchUpdatingTracking.addPromise(this._updateServiceDataExtent(this.lifeCycleAbortController.signal));
    }).catch((e9) => {
      if (!g(e9))
        throw e9;
    });
  }
  _availableFieldsChanged(e8, t11) {
    r(this.tileFetcher) && L4(this.tileFetcher.availableFields, t11) && this.refetch();
  }
  _requiredFieldsChanged(e8, t11) {
    r(this.tileFetcher) && L4(this.tileFetcher.availableFields, t11) && this.restart();
  }
  _createVertexLimitExceededQuery(e8) {
    const t11 = this.layerView.layer, i5 = t11.createQuery();
    return i5.outStatistics = [new m4({ statisticType: "exceedslimit", maxVertexCount: e8, outStatisticFieldName: "exceedslimit", maxPointCount: 1e8, maxRecordCount: 1e8 })], t11.capabilities.query.supportsCacheHint && (i5.cacheHint = true), i5;
  }
  _createDataInfoQuery() {
    const e8 = this.layerView.layer, t11 = e8.createQuery();
    return t11.outSpatialReference = this.layerView.view.spatialReference, e8.capabilities.query.supportsCacheHint && (t11.cacheHint = true), t11;
  }
  _fullExtentIsAccurate() {
    const e8 = this.layerView.layer;
    if (e8.definitionExpression)
      return false;
    switch (e8.type) {
      case "feature":
        return g2(e8.url);
      case "csv":
      case "geojson":
      case "ogc-feature":
      case "wfs":
        return true;
      default:
        return;
    }
  }
  async _updateServiceDataExtent(e8) {
    try {
      await this._tryUpdateServiceDataExtent(e8);
    } catch (t11) {
      g(t11) || this._set("serviceDataExtent", m2(this.layerView.fullExtentInLocalViewSpatialReference));
    }
  }
  async _tryUpdateServiceDataExtent(e8) {
    const t11 = this.layerView, i5 = t11.layer, r5 = i5.capabilities.query.supportsExtent, s9 = m2(t11.fullExtentInLocalViewSpatialReference), a7 = i5.fullExtent, n7 = this._fullExtentIsAccurate(), c9 = this.serviceDataCount;
    if (r5 && c9 <= P2.MAX_FEATURE_COUNT_FOR_EXTENT && (!s9 || !n7) && "queryExtent" in i5) {
      const t12 = this._createDataInfoQuery(), r6 = await i5.queryExtent(t12, { timeout: P2.QUERY_EXTENT_TIMEOUT, signal: e8 });
      this._set("serviceDataExtent", r6.extent);
    } else if (s9)
      this._set("serviceDataExtent", s9);
    else if (r(a7)) {
      const r6 = "portalItem" in i5 ? i5.portalItem : null, s10 = await a6(a7, t11.view.spatialReference, r6, e8);
      this._set("serviceDataExtent", s10);
    } else
      this._set("serviceDataExtent", null);
  }
  async _updateServiceDataCount(e8) {
    const t11 = this.layerView.layer;
    if (!("queryFeatureCount" in t11))
      return void this._set("serviceDataCount", P2.NO_SERVICE_DATA_COUNT);
    const r5 = await a5(t11.queryFeatureCount(this._createDataInfoQuery(), { timeout: P2.QUERY_STATISTICS_TIMEOUT, signal: e8 }));
    if (true === r5.ok)
      this._set("serviceDataCount", r5.value);
    else {
      if (g(r5.error))
        throw r5.error;
      this._set("serviceDataCount", P2.NO_SERVICE_DATA_COUNT);
    }
  }
  get vertexLimitInfo() {
    if (t(this.displayFeatureLimit) || t(this.displayFeatureLimit.averageSymbolComplexity))
      return null;
    const { averageSymbolComplexity: e8, maximumTotalNumberOfPrimitives: t11 } = this.displayFeatureLimit, { primitivesPerCoordinate: i5, primitivesPerFeature: r5 } = e8, s9 = this._get("vertexLimitInfo");
    return t(s9) || s9.maximumTotalNumberOfPrimitives !== t11 || s9.primitivesPerCoordinate !== i5 || s9.primitivesPerFeature !== r5 ? { primitivesPerCoordinate: i5, primitivesPerFeature: r5, maximumTotalNumberOfPrimitives: t11 } : s9;
  }
  get supportsExceedsLimitQuery() {
    const e8 = this.layerView.layer;
    return e8.capabilities && e8.capabilities.operations && e8.capabilities.operations.supportsExceedsLimitStatistics;
  }
  get minimumNumberOfVerticesForGeometry() {
    switch (this.layerView.layer.geometryType) {
      case "point":
      case "multipoint":
        return 1;
      case "polygon":
        return 4;
      case "polyline":
        return 2;
      case "multipatch":
      case "mesh":
        return 3;
      default:
        return 0;
    }
  }
  async _updateVertexLimitExceeded(e8, t11) {
    const r5 = this.vertexLimitInfo;
    if (t(r5))
      return void this._set("vertexLimitExceeded", false);
    const s9 = r5.primitivesPerFeature <= 0, a7 = this.minimumNumberOfVerticesForGeometry > 1;
    if (!s9 && !a7)
      return void this._set("vertexLimitExceeded", false);
    const { primitivesPerFeature: o7, primitivesPerCoordinate: n7, maximumTotalNumberOfPrimitives: c9 } = r5;
    let h5;
    0 !== o7 && r(e8) && await e8;
    const d8 = this.serviceDataCount, p6 = d8 !== P2.NO_SERVICE_DATA_COUNT;
    if (h5 = p6 ? Math.ceil((c9 - d8 * o7) / (n7 || 1)) : Math.ceil(c9 / (n7 || 1)), a7 && (h5 = Math.min(h5, N)), p6 && this.minimumNumberOfVerticesForGeometry * d8 > h5)
      return void this._set("vertexLimitExceeded", true);
    if (!this.supportsExceedsLimitQuery)
      return void this._set("vertexLimitExceeded", this.maxTotalSnapshotVertices > h5);
    const f5 = await a5(this.layerView.layer.queryFeatures(this._createVertexLimitExceededQuery(h5), { timeout: P2.QUERY_STATISTICS_TIMEOUT, signal: t11 }));
    if (false === f5.ok) {
      if (g(f5.error))
        throw f5.error;
      return void this._set("vertexLimitExceeded", false);
    }
    const y3 = f5.value.features[0];
    y3 && y3.attributes ? this._set("vertexLimitExceeded", !!y3.attributes.exceedslimit) : this._set("vertexLimitExceeded", false);
  }
  async _fetchServiceDataInfo() {
    this._cancelFetchServiceDataInfo();
    let e8 = new AbortController();
    const t11 = e8.signal, i5 = this._updateServiceDataCount(t11), r5 = E([i5, this._updateVertexLimitExceeded(i5, t11)]), s9 = r5.then(() => this._updateServiceDataExtent(t11)).catch((e9) => {
      g(e9) || O3.error("#fetchServiceDataInfo()", e9);
    }).then(() => {
      s9 === this.fetchDataInfoPromise && (this.fetchDataInfoPromise = null, this.fetchDataInfoAbortController = null), e8 = null;
    });
    return e8 && (this.fetchDataInfoPromise = s9), this.fetchDataInfoAbortController = e8, r5.then(() => {
    }, () => {
    });
  }
  _cancelFetchServiceDataInfo() {
    const e8 = this.fetchDataInfoAbortController;
    e8 && (this.fetchDataInfoAbortController = null, this.fetchDataInfoPromise = null, e8.abort());
  }
  get debug() {
    return { storedFeatures: r(this.tileFetcher) ? this.tileFetcher.storedFeatures : 0, totalFeatures: r(this.tileFetcher) ? this.tileFetcher.totalFeatures : 0, totalVertices: r(this.tileFetcher) ? this.tileFetcher.totalVertices : 0 };
  }
};
e([d2({ readOnly: true })], I3.prototype, "type", void 0), e([d2({ constructOnly: true })], I3.prototype, "graphics", void 0), e([d2({ constructOnly: true })], I3.prototype, "layerView", void 0), e([d2({ constructOnly: true })], I3.prototype, "context", void 0), e([d2()], I3.prototype, "extent", null), e([d2()], I3.prototype, "updating", null), e([d2({ readOnly: true })], I3.prototype, "watchUpdatingTracking", void 0), e([d2()], I3.prototype, "updatingTotal", null), e([d2()], I3.prototype, "updatingRemaining", null), e([d2()], I3.prototype, "expectedFeatureDiff", null), e([d2()], I3.prototype, "memoryForUnusedFeatures", null), e([d2()], I3.prototype, "maximumNumberOfFeaturesExceeded", null), e([d2({ readOnly: true })], I3.prototype, "serviceDataExtent", void 0), e([d2({ readOnly: true })], I3.prototype, "serviceDataCount", void 0), e([d2({ readOnly: true })], I3.prototype, "vertexLimitExceeded", void 0), e([d2()], I3.prototype, "displayFeatureLimit", void 0), e([d2({ type: Number })], I3.prototype, "maximumNumberOfFeatures", null), e([d2({ readOnly: true })], I3.prototype, "mode", null), e([d2({ readOnly: true })], I3.prototype, "maxTotalSnapshotVertices", null), e([d2({ readOnly: true, dependsOn: ["mode"] })], I3.prototype, "tileDescriptors", null), e([d2()], I3.prototype, "tileFetcher", void 0), e([d2()], I3.prototype, "fetchDataInfoPromise", void 0), e([d2({ readOnly: true })], I3.prototype, "vertexLimitInfo", null), I3 = e([n3("esri.layers.graphics.controllers.FeatureTileController3D")], I3);
var V4 = 1e4;
var U5 = 12e3;
var A4 = 1e4;
var N = 5e6;
function L4(e8, t11) {
  if (!t11)
    return false;
  for (const i5 of t11)
    if (!e8.has(i5))
      return true;
  return false;
}
var P2;
!function(e8) {
  function t11() {
    e8.MAX_FEATURE_COUNT_FOR_EXTENT = V4, e8.QUERY_STATISTICS_TIMEOUT = U5, e8.QUERY_EXTENT_TIMEOUT = A4;
  }
  e8.NO_SERVICE_DATA_COUNT = 1 / 0, e8.MAX_SNAPSHOT_MIN_SCALE_FACTOR = 5, e8.reset = t11;
}(P2 || (P2 = {})), P2.reset();

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HeatmapTechnique.js
var d6 = class extends t4 {
  constructor() {
    super(...arguments), this.colorRamp = null, this.densityMap = null, this.searchRadius = 1, this.fieldTotal = 0, this.minDensity = 0, this.maxDensity = 100;
  }
};
var p4 = class extends e5 {
  constructor(e8, r5) {
    super(e8, r5, () => this.destroy());
  }
  initializeProgram(e8) {
    const r5 = p4.shader.get().build();
    return new o5(e8.rctx, r5, E4);
  }
  initializePipeline() {
    return W({ blending: c6, colorWrite: c5, depthTest: null, depthWrite: null });
  }
  get primitiveType() {
    return E3.TRIANGLE_STRIP;
  }
};
p4.shader = new t6(d5, () => import("./Heatmap.glsl-ZCXAGC76.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DrapedHeatmapRenderer.js
var b3 = class extends y2 {
  constructor(t11) {
    super(t11), this.pixelRatio = 1, this._colorRampData = new Uint8ClampedArray(4), this.type = "draped-heatmap", this._heatmapParameters = new d6();
  }
  initialize() {
    const t11 = { colorTarget: Y.TEXTURE, depthStencilTarget: V2.NONE, width: 0, height: 0 }, { capabilities: e8 } = this.rctx, { R32F: r5 } = e8.colorBufferFloat, { textureFloatLinear: a7 } = e8.textureFloat, s9 = null != r5, o7 = { target: M.TEXTURE_2D, pixelFormat: s9 ? P.RED : P.RGBA, internalFormat: s9 ? U3.R32F : P.RGBA, dataType: G.FLOAT, samplingMode: a7 ? L2.LINEAR : L2.NEAREST, wrapMode: D.CLAMP_TO_EDGE, width: 0, height: 0 };
    this._densityMap = new D2(this.rctx, t11, o7), this._quad = u6(this.rctx);
    const p6 = this._colorRampData, c9 = { target: M.TEXTURE_2D, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L2.LINEAR, wrapMode: D.CLAMP_TO_EDGE, width: p6.length / 4, height: 1 };
    this._colorRamp = new u5(this.rctx, c9, p6), this._technique = new p4({ rctx: this.rctx, viewingMode: l3.Local }, new t7()), this._heatmapParameters.densityMap = this._densityMap.colorTexture, this.own(l2(() => [this.colorRampData, this.minDensity, this.maxDensity, this.fieldTotal, this.pixelRatio, this.searchRadius], () => this.rendererContext.notifyContentChanged()));
  }
  destroy() {
    this._technique = p(this._technique), this._densityMap = s(this._densityMap), this._quad = s(this._quad), this._colorRamp = s(this._colorRamp);
  }
  get searchRadius() {
    return this._heatmapParameters.searchRadius;
  }
  set searchRadius(t11) {
    t11 !== this._heatmapParameters.searchRadius && (this._heatmapParameters.searchRadius = t11, this.notifyChange("searchRadius"));
  }
  get minDensity() {
    return this._heatmapParameters.minDensity;
  }
  set minDensity(t11) {
    t11 !== this._heatmapParameters.minDensity && (this._heatmapParameters.minDensity = t11, this.notifyChange("minDensity"));
  }
  get maxDensity() {
    return this._heatmapParameters.maxDensity;
  }
  set maxDensity(t11) {
    t11 !== this._heatmapParameters.maxDensity && (this._heatmapParameters.maxDensity = t11, this.notifyChange("maxDensity"));
  }
  get fieldTotal() {
    return this._heatmapParameters.fieldTotal;
  }
  set fieldTotal(t11) {
    this._heatmapParameters.fieldTotal = t11, this.notifyChange("fieldTotal");
  }
  get colorRampData() {
    return this._colorRampData;
  }
  set colorRampData(t11) {
    const { colorRamp: e8 } = this._heatmapParameters;
    if (r(e8) && t11 !== this._colorRampData) {
      const r5 = e8.descriptor.width, a7 = t11.length / 4;
      a7 !== r5 && e8.resize(a7, 1), e8.setData(t11);
    }
    this._colorRampData = t11;
  }
  get _colorRamp() {
    return this._heatmapParameters.colorRamp;
  }
  set _colorRamp(t11) {
    this._heatmapParameters.colorRamp = t11;
  }
  get hasHighlights() {
    return false;
  }
  get hasWater() {
    return false;
  }
  get rendersOccluded() {
    return false;
  }
  render(t11, e8) {
    const r5 = this._sortedMaterialRenderers, a7 = r5.length;
    if (a7 < 1)
      return;
    const i5 = this.rctx.getBoundFramebufferObject(), s9 = this.rctx.getViewport(), { pixelRatio: o7 } = this, h5 = Math.ceil(s9.width * o7), n7 = Math.ceil(s9.height * o7);
    this._densityMap.resize(h5, n7), this.rctx.bindFramebuffer(this._densityMap), this.rctx.setViewport(0, 0, h5, n7), this.rctx.clear(_.COLOR_BUFFER_BIT);
    let m5 = false;
    for (let p6 = 0; p6 < a7; p6++) {
      const a8 = r5.getItemAt(p6);
      a8.material.shouldRender(t11) && (m5 = m5 || a8.materialRenderer.render(t11.pass, e8));
    }
    this.rctx.bindFramebuffer(i5), this.rctx.setViewport(s9.x, s9.y, s9.width, s9.height), m5 && (this.rctx.bindVAO(this._quad), this.rctx.useProgram(this._technique.program), this._technique.bindPipelineState(this.rctx), this._technique.bindPass(this._heatmapParameters, t11.bindParameters), this.rctx.drawArrays(this._technique.primitiveType, 0, n6(this._quad, "geometry")));
  }
};
e([d2()], b3.prototype, "searchRadius", null), e([d2()], b3.prototype, "minDensity", null), e([d2()], b3.prototype, "maxDensity", null), e([d2()], b3.prototype, "fieldTotal", null), e([d2()], b3.prototype, "pixelRatio", void 0), e([d2()], b3.prototype, "colorRampData", null), e([d2()], b3.prototype, "_colorRampData", void 0), b3 = e([n3("esri.views.3d.webgl-engine.lib.DrapedHeatmapRenderer")], b3);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HeatmapDensityTechnique.js
var p5;
!function(e8) {
  e8[e8.Screen = 0] = "Screen", e8[e8.World = 1] = "World";
}(p5 || (p5 = {}));
var f4 = class extends o4 {
  constructor() {
    super(...arguments), this.searchRadius = 128, this.resolutionForScale = 0;
  }
};
var b4 = class extends e5 {
  initializeProgram(e8) {
    const r5 = b4.shader.get().build(this.configuration);
    return new o5(e8.rctx, r5, E4);
  }
  initializePipeline() {
    return W({ blending: s6(R.ONE, R.ONE, T2.ADD), colorWrite: c5, depthTest: null, depthWrite: null });
  }
  destroy() {
    super.destroy();
  }
};
b4.shader = new t6(s7, () => import("./HeatmapDensity.glsl-3SCQ2IVP.js"));
var j4 = class extends i2 {
  constructor() {
    super(...arguments), this.isAttributeDriven = false;
  }
};
e([e6()], j4.prototype, "isAttributeDriven", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/HeatmapDensityMaterial.js
var d7 = 2;
var A5 = class extends f4 {
  constructor() {
    super(...arguments), this.isAttributeDriven = false;
  }
};
var b5 = class extends d4 {
  constructor(e8) {
    super(e8, new A5()), this._techniqueConfig = new j4();
  }
  requiresSlot(e8, t11) {
    return e8 === E5.DRAPED_MATERIAL && t11 === A2.MATERIAL;
  }
  getConfiguration() {
    return this._techniqueConfig.isAttributeDriven = this.parameters.isAttributeDriven, this._techniqueConfig;
  }
  createGLMaterial(e8) {
    return new I4(e8);
  }
  intersect(s9, n7, o7, a7, u7, c9, l8, m5, p6) {
    if (t(p6) || !t8(c9))
      return;
    const h5 = s9.vertexAttributes.get(O.POSITION), { parameters: T4 } = this, { searchRadius: A7 } = T4, { screenToWorldRatio: b6 } = s9, I5 = A7 * b6 + d7 * b6, g7 = I5 * I5, v4 = h5.data.length / h5.size;
    for (let e8 = 0; e8 < v4; e8++) {
      const s10 = e8 * h5.size, i5 = r3(E8, h5.data[s10], h5.data[s10 + 1]);
      b(i5, c9) < g7 && l8(p6.dist, p6.normal, -1, false);
    }
  }
  createBufferWriter() {
    return new g6(this.parameters.isAttributeDriven ? R2 : v3);
  }
};
var I4 = class extends t5 {
  beginSlot(e8) {
    return this.ensureTechnique(b4, e8);
  }
};
var g6 = class {
  constructor(e8) {
    this.vertexBufferLayout = e8;
  }
  allocate(e8) {
    return this.vertexBufferLayout.createBuffer(e8);
  }
  elementCount(e8) {
    return e8.indices.get(O.POSITION).length * j5;
  }
  write(e8, t11, r5, s9) {
    p2(t11.indices.get(O.POSITION), t11.vertexAttributes.get(O.POSITION).data, e8.transformation, r5.position, s9, j5);
    const i5 = t11.indices.get(O.POSITION).length, n7 = r5.uv0;
    let o7 = s9;
    for (let u7 = 0; u7 < i5; ++u7)
      n7.setValues(o7++, -1, -1), n7.setValues(o7++, 1, -1), n7.setValues(o7++, 1, 1), n7.setValues(o7++, 1, 1), n7.setValues(o7++, -1, 1), n7.setValues(o7++, -1, -1);
    const a7 = "featureAttribute" in r5 ? r5.featureAttribute : null;
    a7 && i(t11.indices.get(O.FEATUREATTRIBUTE), t11.vertexAttributes.get(O.FEATUREATTRIBUTE).data, a7, s9, j5);
  }
};
var v3 = T().vec3f(O.POSITION).vec2f(O.UV0);
var R2 = v3.clone().f32(O.FEATUREATTRIBUTE);
var j5 = 6;
var E8 = n5();

// node_modules/@arcgis/core/views/3d/layers/support/HeatmapFeatureProcessor.js
var D4 = s2.getLogger("esri.views.3d.layers.support.HeatmapFeatureProcessor");
var A6 = 112;
var B3 = class extends d3 {
  constructor(e8) {
    super(e8), this.type = "heatmap", this.filterVisibility = { filterChanged() {
    }, dirty: false }, this.preferredUpdatePolicy = o3.ASYNC, this.dataExtent = null, this.drapeSourceType = e7.Features, this._renderGeometries = /* @__PURE__ */ new Map(), this._material = new b5({}), this._materialWithField = new b5({ isAttributeDriven: true }), this._fieldTotal = 0, this._drapeSourceRenderer = null;
  }
  initialize() {
    this._featureStore = new u4({ geometryType: "esriGeometryPoint", hasZ: this.hasZ, hasM: this.hasM });
    const { colorBufferFloat: e8, textureFloat: r5 } = this._renderView.capabilities, { floatBufferBlendWorking: t11 } = this._renderView.renderingContext.driverTest;
    if (!(r5 == null ? void 0 : r5.textureFloat))
      throw new s3("heatmap:missing-texture-float", "HeatmapRenderer requires WebGL2 or the WebGL1 extension OES_texture_float.");
    if (!(e8 == null ? void 0 : e8.textureFloat))
      throw new s3("heatmap:missing-color-buffer-float", "HeatmapRenderer requires the WebGL2 extension EXT_color_buffer_float or the WebGL1 extension WEBGL_color_buffer_float.");
    if (!(e8 == null ? void 0 : e8.floatBlend))
      throw new s3("heatmap:missing-float-blend", "HeatmapRenderer requires the WebGL extension EXT_float_blend.");
    if (!t11)
      throw new s3("heatmap:missing-float-blend", "HeatmapRenderer requires the WebGL extension EXT_float_blend. This device claims support for it, but does not actually support it.");
    this._drapeSourceRenderer = this.view.basemapTerrain.overlayManager.registerDrapeSource(this, b3, this._rendererParameters), this.updatingHandles.addOnCollectionChange(() => this._loadedPointGraphics, (e9) => this._onLoadedFeaturesChange(e9), h), this.updatingHandles.addWhen(() => this._materialParameters, (e9) => this._forEachMaterial((r6) => r6.setParameters(e9)), h), this.updatingHandles.add(() => this._rendererParameters, (e9) => this._drapeSourceRenderer.set(e9)), this.updatingHandles.add(() => this._heatmapRendererField, () => {
      this._recreate();
    }, U), this.updatingHandles.add(() => ({ fieldName: this._heatmapRendererFieldName, numeric: this._heatmapRendererFieldIsNumeric }), ({ fieldName: e9, numeric: r6 }) => {
      if (r(e9) && r6) {
        let r7 = 0;
        this._featureStore.forEach((t12) => r7 += t12.attributes[e9] ?? 0), this._fieldTotal = r7;
      } else
        this._fieldTotal = this._featureStore.numFeatures;
    }, h), this.handles.add([l2(() => ({ fieldName: this._heatmapRendererFieldName, field: this._heatmapRendererField }), ({ fieldName: e9, field: r6 }) => {
      e9 && !r6 && D4.warn(`Heatmap renderer field '${e9}' for layer '${this.layer.title ?? this.layer.id}' not found`);
    }), l2(() => ({ field: this._heatmapRendererField, numeric: this._heatmapRendererFieldIsNumeric }), ({ field: e9, numeric: r6 }) => {
      r(e9) && !r6 && D4.warn(`Heatmap renderer field '${e9.name}' for layer '${this.layer.title ?? this.layer.id}' does not contain numeric values and cannot be used to drive the heatmap density`);
    }), n(() => this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))]);
  }
  destroy() {
    this._renderGeometries.clear(), this._material = s(this._material), this._materialWithField = s(this._materialWithField), this._featureStore.clear(), this._featureStore = null;
  }
  get layer() {
    return this.owner.layer;
  }
  get featureStore() {
    return this._featureStore;
  }
  get updating() {
    return this.updatingHandles.updating;
  }
  get updatingRemaining() {
    return 0;
  }
  get suspendInfo() {
    return {};
  }
  get legendEnabled() {
    return true;
  }
  get displayFeatureLimit() {
    var _a, _b, _c, _d, _e2, _f;
    const e8 = ((_d = (_c = (_b = (_a = this.owner) == null ? void 0 : _a.view) == null ? void 0 : _b.resourceController) == null ? void 0 : _c.memoryController) == null ? void 0 : _d.memoryFactor) ?? 1, r5 = (_f = (_e2 = this.owner) == null ? void 0 : _e2.view) == null ? void 0 : _f.qualitySettings, t11 = r5 ? Math.ceil(r5.heatmap.maxTotalNumberOfFeatures * e8) : 0;
    return { minimumTotalNumberOfFeatures: 0, maximumTotalNumberOfFeatures: t11, maximumTotalNumberOfPrimitives: t11 * 2, maximumNumberOfFeatures: t11 };
  }
  get hasZ() {
    return "hasZ" in this.layer && this.layer.hasZ;
  }
  get hasM() {
    return "hasM" in this.layer && this.layer.hasM;
  }
  get view() {
    return this.owner.view;
  }
  get fullOpacity() {
    return this.owner.fullOpacity;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  get scaleVisibilitySuspended() {
    return false;
  }
  get usedMemory() {
    var _a, _b, _c, _d;
    const e8 = this.usedMemoryPerFeature * this._featureStore.numFeatures, { R32F: r5 } = (_b = (_a = this._renderView) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.colorBufferFloat, t11 = null != r5 ? 1 : 4, i5 = 4, a7 = Math.ceil(((_d = (_c = this._overlayRenderer) == null ? void 0 : _c.overlays[0]) == null ? void 0 : _d.resolution) * this._densityMapPixelRatio) ?? 0;
    return a7 * a7 * t11 * i5 + e8 + (r(this._heatmapRenderer) ? u2(Math.min(this._heatmapRenderer.radius, A6)) : 0) * t11 * i5;
  }
  get usedMemoryPerFeature() {
    if (0 === this._featureStore.numFeatures)
      return 0;
    let e8 = 0;
    this._featureStore.forEach((t11) => e8 += r4(t11.attributes)), e8 /= this._featureStore.numFeatures;
    const a7 = t3(), o7 = 6;
    return o7 * e4([0, 0, 0], a7) + o7 * e4([0, 0], a7) + (this._heatmapRendererFieldIsNumeric ? o7 * a7 : 0) + e8;
  }
  get unprocessedMemoryEstimate() {
    return 0;
  }
  get performanceInfo() {
    return { core: { visible: this._featureStore.numFeatures, missing: 0, pending: 0 }, elevationUpdating: false, visibilityFrustum: true, visibilityScale: true };
  }
  get _overlayRenderer() {
    return this.view.basemapTerrain.overlayManager.renderer;
  }
  get _overlaySpatialReference() {
    return e2(this._overlayRenderer.spatialReference);
  }
  get _rendererParameters() {
    return { ...this._radiusParameter, ...this._densityParameters, ...this._colorRampParameter, ...this._pixelRatioParameter };
  }
  get _materialParameters() {
    return { ...this._radiusParameter, ...this._resolutionForScaleParameter };
  }
  get _densityParameters() {
    const e8 = this._heatmapRenderer;
    if (t(e8))
      return null;
    const { minDensity: r5, maxDensity: t11 } = e8;
    return { minDensity: r5, maxDensity: t11, fieldTotal: this._fieldTotal };
  }
  get _radiusParameter() {
    return o(this._heatmapRenderer, ({ radius: e8 }) => ({ searchRadius: u2(this._clampSearchRadius(e8)) }));
  }
  get _resolutionForScaleParameter() {
    return o(this._heatmapRenderer, ({ referenceScale: e8 }) => ({ resolutionForScale: 0 === e8 ? 0 : i3(e8, this.view.spatialReference) }));
  }
  get _colorRampParameter() {
    return o(this._heatmapRenderer, (e8) => ({ colorRampData: s5(e8.colorStops) }));
  }
  get _pixelRatioParameter() {
    return { pixelRatio: this._densityMapPixelRatio };
  }
  get _densityMapPixelRatio() {
    var _a, _b, _c, _d, _e2, _f;
    const e8 = ((_d = (_c = (_b = (_a = this.owner) == null ? void 0 : _a.view) == null ? void 0 : _b.resourceController) == null ? void 0 : _c.memoryController) == null ? void 0 : _d.memoryFactor) ?? 1;
    return (((_f = (_e2 = this.owner) == null ? void 0 : _e2.view) == null ? void 0 : _f.qualitySettings.heatmap.pixelRatio) ?? 1) * Math.sqrt(e8);
  }
  get _renderView() {
    return this.view._stage.renderView;
  }
  get _featuresArePoints() {
    return "point" === this.layer.geometryType;
  }
  get _loadedPointGraphics() {
    return this.owner.loadedGraphics;
  }
  get _heatmapRenderer() {
    const e8 = this.layer.renderer;
    return "heatmap" === (e8 == null ? void 0 : e8.type) ? e8 : null;
  }
  get _heatmapRendererFieldName() {
    return o(this._heatmapRenderer, (e8) => e8.field);
  }
  get _heatmapRendererField() {
    return o(this._heatmapRendererFieldName, (e8) => this.layer.fieldsIndex.get(e8));
  }
  get _heatmapRendererFieldIsNumeric() {
    const e8 = this._heatmapRendererField;
    return !t(e8) && B(e8);
  }
  async whenGraphicBounds() {
    return null;
  }
  computeAttachmentOrigin() {
    return null;
  }
  highlight() {
    return q2;
  }
  maskOccludee() {
    return q2;
  }
  setObjectIdVisibility() {
  }
  async setup() {
  }
  _onLoadedFeaturesChange(e8) {
    if (!this._featuresArePoints)
      return;
    const { objectIdField: r5 } = this.layer;
    this._featureStore.removeManyById(e8.removed.map((e9) => O2(e9, r5))), this._featureStore.addMany(e8.added.map((e9) => new s4(V(new t2(), e9.geometry), e9.attributes, o(e9.centroid, (e10) => V(new t2(), e10)), O2(e9, r5))));
    const t11 = e8.added, i5 = e8.removed;
    this._fieldTotal += this._computeFieldTotalChange(t11, i5);
    const a7 = d(i5, ({ uid: e9 }) => {
      const r6 = this._renderGeometries.get(e9);
      return this._renderGeometries.delete(e9), r6;
    }), o7 = t11.map((e9) => {
      const r6 = this._pointGraphicToRenderGeometry(e9);
      return this._renderGeometries.set(e9.uid, r6), r6;
    });
    a7.length > 0 && this._drapeSourceRenderer.removeGeometries(a7, E6.Geometry.REMOVE), o7.length > 0 && this._drapeSourceRenderer.addGeometries(o7, E6.Geometry.ADD), (o7.length > 0 || a7.length > 0) && this._renderView.requestRender();
  }
  _recreate() {
    if (!this._loadedPointGraphics)
      return;
    const e8 = this._loadedPointGraphics.toArray();
    this._onLoadedFeaturesChange({ added: e8, removed: e8 });
  }
  _pointGraphicToRenderGeometry(e8) {
    const r5 = this._heatmapRendererFieldName, t11 = r(r5) ? this._materialWithField : this._material, i5 = n4();
    Hn(e8.geometry, i5, this._overlaySpatialReference), i5[2] = _e;
    const a7 = [[O.POSITION, { data: i5, size: i5.length }]], o7 = this._heatmapRendererFieldIsNumeric;
    r(r5) && a7.push([O.FEATUREATTRIBUTE, { data: [o7 ? e8.attributes[r5] ?? 0 : 0], size: 1 }]);
    const s9 = new T3(new g3(a7, null, c4.Point), t11, { layerUid: this.layer.uid, graphicUid: e8.uid });
    return r2(s9.boundingSphere, i5), s9;
  }
  _forEachMaterial(e8) {
    e8(this._material), e8(this._materialWithField);
  }
  _computeFieldTotalChange(e8, r5) {
    if (t(this._heatmapRendererFieldName) || !this._heatmapRendererFieldIsNumeric)
      return e8.length - r5.length;
    const t11 = this._heatmapRendererFieldName, i5 = (e9, r6) => e9 + (r6.attributes[t11] ?? 0);
    return e8.reduce(i5, 0) - r5.reduce(i5, 0);
  }
  _clampSearchRadius(e8) {
    return e8 > A6 && D4.warnOnce(`SceneView supports a maximum radius of ${A6} pt for HeatmapRenderer.`), Math.min(e8, A6);
  }
};
e([d2()], B3.prototype, "type", void 0), e([d2({ constructOnly: true })], B3.prototype, "owner", void 0), e([d2()], B3.prototype, "layer", null), e([d2()], B3.prototype, "featureStore", null), e([d2()], B3.prototype, "updating", null), e([d2()], B3.prototype, "updatingRemaining", null), e([d2()], B3.prototype, "suspendInfo", null), e([d2()], B3.prototype, "legendEnabled", null), e([d2()], B3.prototype, "filterVisibility", void 0), e([d2()], B3.prototype, "displayFeatureLimit", null), e([d2()], B3.prototype, "preferredUpdatePolicy", void 0), e([d2()], B3.prototype, "hasZ", null), e([d2()], B3.prototype, "hasM", null), e([d2()], B3.prototype, "dataExtent", void 0), e([d2()], B3.prototype, "view", null), e([d2()], B3.prototype, "fullOpacity", null), e([d2()], B3.prototype, "updatePolicy", null), e([d2()], B3.prototype, "drapeSourceType", void 0), e([d2()], B3.prototype, "_featureStore", void 0), e([d2()], B3.prototype, "_overlayRenderer", null), e([d2()], B3.prototype, "_overlaySpatialReference", null), e([d2()], B3.prototype, "_rendererParameters", null), e([d2()], B3.prototype, "_materialParameters", null), e([d2()], B3.prototype, "_densityParameters", null), e([d2()], B3.prototype, "_radiusParameter", null), e([d2()], B3.prototype, "_resolutionForScaleParameter", null), e([d2()], B3.prototype, "_colorRampParameter", null), e([d2()], B3.prototype, "_pixelRatioParameter", null), e([d2()], B3.prototype, "_densityMapPixelRatio", null), e([d2()], B3.prototype, "_renderGeometries", void 0), e([d2()], B3.prototype, "_material", void 0), e([d2()], B3.prototype, "_materialWithField", void 0), e([d2()], B3.prototype, "_renderView", null), e([d2()], B3.prototype, "_featuresArePoints", null), e([d2()], B3.prototype, "_loadedPointGraphics", null), e([d2()], B3.prototype, "_heatmapRenderer", null), e([d2()], B3.prototype, "_heatmapRendererFieldName", null), e([d2()], B3.prototype, "_heatmapRendererField", null), e([d2()], B3.prototype, "_heatmapRendererFieldIsNumeric", null), e([d2()], B3.prototype, "_fieldTotal", void 0), e([d2()], B3.prototype, "_drapeSourceRenderer", void 0), B3 = e([n3("esri.views.3d.layers.support.HeatmapFeatureProcessor")], B3);
var q2 = n();

// node_modules/@arcgis/core/views/3d/layers/FeatureLikeLayerView3D.js
var E9 = (E10) => {
  let b6 = class extends E10 {
    constructor() {
      super(...arguments), this.controller = null, this.updatePolicy = o3.SYNC, this.suspendResumeExtentMode = "computed", this.slicePlaneEnabled = false, this.fullExtentInLocalViewSpatialReference = null, this.suspendResumeExtent = null, this._controllerCreated = false, this.clippingExtent = null, this.supportsHeightUnitConversion = true, this.pendingController = null, this.queryEngine = null;
    }
    initialize() {
      const e8 = this.layer;
      "isTable" in e8 && e8.isTable ? this.addResolvingPromise(Promise.reject(new s3("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: e8 }))) : (this.addResolvingPromise(this._validateGeometryType()), this.updatingHandles.add(() => this.layer.renderer, (e9) => this._recreateProcessor(e9), h), this.addResolvingPromise((async () => {
        const e9 = await l4(this);
        this.fullExtentInLocalViewSpatialReference = e9, await this._initializeController();
      })()), this.updatingHandles.add(() => this.updatePolicy, (e9) => this.processor.preferredUpdatePolicy = e9), this.queryEngine = new l5({ layerView: this, priority: L.FEATURE_QUERY_ENGINE }), this.notifyChange("updating"));
    }
    destroy() {
      this._destroyPendingController(), this.controller = l(this.controller), this._set("processor", l(this.processor)), this.queryEngine = l(this.queryEngine), this.loadedGraphics = null;
    }
    _destroyPendingController() {
      this.pendingController = l(this.pendingController);
    }
    get legendEnabled() {
      var _a;
      return this.canResume() && ((_a = this.processor) == null ? void 0 : _a.legendEnabled);
    }
    get graphics3DProcessor() {
      var _a;
      return "graphics-3d" === ((_a = this.processor) == null ? void 0 : _a.type) ? this.processor : null;
    }
    get heatmapProcessor() {
      var _a;
      return "heatmap" === ((_a = this.processor) == null ? void 0 : _a.type) ? this.processor : null;
    }
    getHit(e8) {
      var _a;
      let t11 = null;
      return (_a = this.loadedGraphics) == null ? void 0 : _a.forEach((r5) => {
        r5.uid === e8 && (t11 = c7(r5, this.layer));
      }), t11 ? { type: "graphic", graphic: t11, layer: t11.layer } : null;
    }
    whenGraphicBounds(e8, t11) {
      var _a;
      return (_a = this.processor) == null ? void 0 : _a.whenGraphicBounds(e8, t11);
    }
    computeAttachmentOrigin(e8, t11) {
      var _a;
      return (_a = this.processor) == null ? void 0 : _a.computeAttachmentOrigin(e8, t11);
    }
    queryFeatures(e8, t11) {
      return this.queryEngine.executeQuery(this._ensureQuery(e8), m(t11, "signal"));
    }
    queryObjectIds(e8, t11) {
      return this.queryEngine.executeQueryForIds(this._ensureQuery(e8), m(t11, "signal"));
    }
    queryFeatureCount(e8, t11) {
      return this.queryEngine.executeQueryForCount(this._ensureQuery(e8), m(t11, "signal"));
    }
    queryExtent(e8, t11) {
      return this.queryEngine.executeQueryForExtent(this._ensureQuery(e8), m(t11, "signal"));
    }
    _ensureQuery(e8) {
      return t(e8) ? this.createQuery() : b2.from(e8);
    }
    highlight(e8) {
      return this.processor.highlight(e8, this.layer.objectIdField);
    }
    maskOccludee(e8) {
      return this.processor.maskOccludee(e8);
    }
    canResume() {
      var _a;
      return super.canResume() && !((_a = this.processor) == null ? void 0 : _a.scaleVisibilitySuspended);
    }
    getSuspendInfo() {
      const e8 = super.getSuspendInfo();
      return this.processor ? { ...e8, ...this.processor.suspendInfo } : e8;
    }
    isUpdating() {
      var _a, _b, _c;
      return !(!this.processor || this.processor.destroyed) && !(this._controllerCreated && !((_a = this.controller) == null ? void 0 : _a.updating) && ((_c = (_b = this.view) == null ? void 0 : _b.basemapTerrain) == null ? void 0 : _c.ready) && !this.processor.updating);
    }
    async _initializeController() {
      const e8 = this.createController();
      this.pendingController = e8, await e8.when(), this._setControllerWhenInitialized(e8);
    }
    async _setControllerWhenInitialized(e8) {
      try {
        await this.when();
      } catch (t11) {
      }
      this._controllerCreated = true, this.notifyChange("updating"), this.isResolved() && !this.destroyed ? (await j2(() => {
        var _a, _b;
        return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.ready;
      }), this.beforeSetController(e8), this.pendingController = null, this.controller = e8, this.loadedGraphics = e8.graphics, this.notifyChange("updating")) : this._destroyPendingController();
    }
    _updateClippingExtent(e8) {
      if (this.clippingExtent = e8, !this.controller)
        return false;
      switch (this.controller.type) {
        case "stream":
          return false;
        case "feature-tile-3d":
          return this.controller.extent = e8, true;
      }
    }
    async _validateGeometryType() {
      switch (this.layer.geometryType) {
        case "multipatch":
        case "multipoint":
          throw new s3("featurelayerview3d:unsupported-geometry-type", "Unsupported geometry type ${geometryType}", { geometryType: this.layer.geometryType });
      }
    }
    _recreateProcessor(e8) {
      var _a, _b;
      const t11 = "heatmap" === (e8 == null ? void 0 : e8.type), r5 = "heatmap" === ((_a = this.processor) == null ? void 0 : _a.type), s9 = this.processor;
      if (s9 && t11 === r5)
        return;
      const i5 = t11 ? new B3({ owner: this }) : new F({ owner: this, frustumVisibilityEnabled: true, scaleVisibilityEnabled: true, filterVisibilityEnabled: true, timeExtentEnabled: true, elevationAlignmentEnabled: true, elevationFeatureExpressionEnabled: true, preferredUpdatePolicy: this.updatePolicy, updateClippingExtent: (e9) => this._updateClippingExtent(e9) });
      this._set("processor", i5), s9 == null ? void 0 : s9.destroy(), (_b = this.queryEngine) == null ? void 0 : _b.clear(), this.addResolvingPromise(i5.setup());
    }
    _getResourceInfo() {
      const e8 = this.controller instanceof I3 ? this.controller : null;
      return { displayedNumberOfFeatures: this.loadedGraphics.length, maximumNumberOfFeatures: (e8 == null ? void 0 : e8.maximumNumberOfFeatures) ?? -1, totalNumberOfFeatures: (e8 == null ? void 0 : e8.serviceDataCount) ?? -1, nodes: 0, ...this.processor.performanceInfo };
    }
    get performanceInfo() {
      return this._getResourceInfo();
    }
  };
  return e([d2()], b6.prototype, "loadedGraphics", void 0), e([d2()], b6.prototype, "suspended", void 0), e([d2({ readOnly: true })], b6.prototype, "legendEnabled", null), e([d2()], b6.prototype, "updating", void 0), e([d2()], b6.prototype, "controller", void 0), e([d2()], b6.prototype, "processor", void 0), e([d2({ readOnly: true })], b6.prototype, "updatePolicy", void 0), e([d2({ readOnly: true })], b6.prototype, "suspendResumeExtentMode", void 0), e([d2({ type: Boolean })], b6.prototype, "slicePlaneEnabled", void 0), e([d2({ readOnly: true })], b6.prototype, "suspendInfo", void 0), e([d2()], b6.prototype, "graphics3DProcessor", null), e([d2()], b6.prototype, "heatmapProcessor", null), b6 = e([n3("esri.views.3d.layers.FeatureLikeLayerView3D")], b6), b6;
};

export {
  S5 as S,
  I3 as I,
  E9 as E
};
//# sourceMappingURL=chunk-3KS2GHSC.js.map
