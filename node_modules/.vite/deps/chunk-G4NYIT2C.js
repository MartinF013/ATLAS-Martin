import {
  n as n2
} from "./chunk-ZG7SHSSS.js";
import {
  w
} from "./chunk-CNBLQ5VM.js";
import {
  i
} from "./chunk-WRJQ7542.js";
import {
  t
} from "./chunk-PNUWGOXY.js";
import {
  v as v2
} from "./chunk-JJ7VMWJT.js";
import {
  L,
  b,
  h,
  m,
  y
} from "./chunk-6GPADSSO.js";
import {
  f as f2,
  v
} from "./chunk-JT3LXQ47.js";
import {
  b as b2
} from "./chunk-P3QN5DXX.js";
import {
  a
} from "./chunk-QKRZMDWG.js";
import {
  B
} from "./chunk-Q3R7XFM5.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  j
} from "./chunk-5N3FSR63.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  r as r2
} from "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  E,
  f,
  x
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/webdoc/support/saveUtils.js
async function a2(r3, a3, u) {
  if (!a3 || !a3.resources)
    return;
  const h2 = a3.portalItem === r3.portalItem ? new Set(r3.paths) : /* @__PURE__ */ new Set();
  r3.paths.length = 0, r3.portalItem = a3.portalItem;
  const i2 = new Set(a3.resources.toKeep.map((r4) => r4.resource.path)), f3 = /* @__PURE__ */ new Set(), m2 = [];
  i2.forEach((e2) => {
    h2.delete(e2), r3.paths.push(e2);
  });
  for (const e2 of a3.resources.toUpdate)
    if (h2.delete(e2.resource.path), i2.has(e2.resource.path) || f3.has(e2.resource.path)) {
      const { resource: o2, content: t2, finish: a4, error: p2 } = e2, h3 = w(o2, t());
      r3.paths.push(h3.path), m2.push(n3({ resource: h3, content: t2, finish: a4, error: p2 }, u));
    } else
      r3.paths.push(e2.resource.path), m2.push(p(e2, u)), f3.add(e2.resource.path);
  for (const e2 of a3.resources.toAdd)
    m2.push(n3(e2, u)), r3.paths.push(e2.resource.path);
  if (h2.forEach((r4) => {
    const e2 = a3.portalItem.resourceFromPath(r4);
    m2.push(e2.portalItem.removeResource(e2).catch(() => {
    }));
  }), 0 === m2.length)
    return;
  const l = await E(m2);
  f(u);
  const d2 = l.filter((r4) => "error" in r4).map((r4) => r4.error);
  if (d2.length > 0)
    throw new s2("save:resources", "Failed to save one or more resources", { errors: d2 });
}
async function n3(e2, o2) {
  const t2 = await a(e2.resource.portalItem.addResource(e2.resource, e2.content, o2));
  if (true !== t2.ok)
    throw e2.error && e2.error(t2.error), t2.error;
  e2.finish && e2.finish(e2.resource);
}
async function p(e2, o2) {
  const t2 = await a(e2.resource.update(e2.content, o2));
  if (true !== t2.ok)
    throw e2.error(t2.error), t2.error;
  e2.finish(e2.resource);
}

// node_modules/@arcgis/core/layers/mixins/SceneService.js
var R = s.getLogger("esri.layers.mixins.SceneService");
var A = (i2) => {
  let A2 = class extends i2 {
    constructor() {
      super(...arguments), this.spatialReference = null, this.fullExtent = null, this.heightModelInfo = null, this.minScale = 0, this.maxScale = 0, this.version = { major: Number.NaN, minor: Number.NaN, versionString: "" }, this.copyright = null, this.sublayerTitleMode = "item-title", this.title = null, this.layerId = null, this.indexInfo = null, this._debouncedSaveOperations = x(async (e2, t2, r3) => {
        switch (e2) {
          case K.SAVE:
            return this._save(t2);
          case K.SAVE_AS:
            return this._saveAs(r3, t2);
        }
      });
    }
    readSpatialReference(e2, t2) {
      return this._readSpatialReference(t2);
    }
    _readSpatialReference(e2) {
      if (null != e2.spatialReference)
        return k.fromJSON(e2.spatialReference);
      {
        const t2 = e2.store, r3 = t2.indexCRS || t2.geographicCRS, i3 = r3 && parseInt(r3.substring(r3.lastIndexOf("/") + 1, r3.length), 10);
        return null != i3 ? new k(i3) : null;
      }
    }
    readFullExtent(e2, t2, r3) {
      if (null != e2 && "object" == typeof e2) {
        const i4 = null == e2.spatialReference ? { ...e2, spatialReference: this._readSpatialReference(t2) } : e2;
        return M.fromJSON(i4, r3);
      }
      const i3 = t2.store, o2 = this._readSpatialReference(t2);
      return null == o2 || null == i3 || null == i3.extent || !Array.isArray(i3.extent) || i3.extent.some((e3) => e3 < N) ? null : new M({ xmin: i3.extent[0], ymin: i3.extent[1], xmax: i3.extent[2], ymax: i3.extent[3], spatialReference: o2 });
    }
    parseVersionString(e2) {
      const t2 = { major: Number.NaN, minor: Number.NaN, versionString: e2 }, r3 = e2.split(".");
      return r3.length >= 2 && (t2.major = parseInt(r3[0], 10), t2.minor = parseInt(r3[1], 10)), t2;
    }
    readVersion(e2, t2) {
      const r3 = t2.store, i3 = null != r3.version ? r3.version.toString() : "";
      return this.parseVersionString(i3);
    }
    readTitlePortalItem(e2) {
      return "item-title" !== this.sublayerTitleMode ? void 0 : e2;
    }
    readTitleService(e2, t2) {
      const r3 = this.portalItem && this.portalItem.title;
      if ("item-title" === this.sublayerTitleMode)
        return y(this.url, t2.name);
      let i3 = t2.name;
      if (!i3 && this.url) {
        const e3 = m(this.url);
        r(e3) && (i3 = e3.title);
      }
      return "item-title-and-service-name" === this.sublayerTitleMode && r3 && (i3 = r3 + " - " + i3), h(i3);
    }
    set url(e2) {
      const t2 = L({ layer: this, url: e2, nonStandardUrlAllowed: false, logger: R });
      this._set("url", t2.url), null != t2.layerId && this._set("layerId", t2.layerId);
    }
    writeUrl(e2, t2, r3, i3) {
      b(this, e2, "layers", t2, i3);
    }
    get parsedUrl() {
      const e2 = this._get("url");
      if (!e2)
        return null;
      const t2 = j(e2);
      return null != this.layerId && (t2.path = `${t2.path}/layers/${this.layerId}`), t2;
    }
    async _fetchIndexAndUpdateExtent(e2, t2) {
      this.indexInfo = n2(this.parsedUrl.path, this.rootNode, e2, this.apiKey, R, t2), null == this.fullExtent || this.fullExtent.hasZ || this._updateExtent(await this.indexInfo);
    }
    _updateExtent(e2) {
      var _a, _b, _c;
      if ("page" === (e2 == null ? void 0 : e2.type)) {
        const t2 = e2.rootIndex % e2.pageSize, i3 = (_b = (_a = e2.rootPage) == null ? void 0 : _a.nodes) == null ? void 0 : _b[t2];
        if (null == i3 || null == i3.obb || null == i3.obb.center || null == i3.obb.halfSize)
          throw new s2("sceneservice:invalid-node-page", "Invalid node page.");
        if (i3.obb.center[0] < N || null == this.fullExtent || this.fullExtent.hasZ)
          return;
        const o2 = i3.obb.halfSize, s3 = i3.obb.center[2], a3 = Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1] + o2[2] * o2[2]);
        this.fullExtent.zmin = s3 - a3, this.fullExtent.zmax = s3 + a3;
      } else if ("node" === (e2 == null ? void 0 : e2.type)) {
        const t2 = (_c = e2.rootNode) == null ? void 0 : _c.mbs;
        if (!Array.isArray(t2) || 4 !== t2.length || t2[0] < N)
          return;
        const r3 = t2[2], i3 = t2[3];
        this.fullExtent.zmin = r3 - i3, this.fullExtent.zmax = r3 + i3;
      }
    }
    async _fetchService(e2) {
      if (null == this.url)
        throw new s2("sceneservice:url-not-set", "Scene service can not be loaded without valid portal item or url");
      if (null == this.layerId && /SceneServer\/*$/i.test(this.url)) {
        const t2 = await this._fetchFirstLayerId(e2);
        null != t2 && (this.layerId = t2);
      }
      return this._fetchServiceLayer(e2);
    }
    async _fetchFirstLayerId(e2) {
      const r3 = await U(this.url, { query: { f: "json", token: this.apiKey }, responseType: "json", signal: e2 });
      if (r3.data && Array.isArray(r3.data.layers) && r3.data.layers.length > 0)
        return r3.data.layers[0].id;
    }
    async _fetchServiceLayer(e2) {
      const r3 = await U(this.parsedUrl.path, { query: { f: "json", token: this.apiKey }, responseType: "json", signal: e2 });
      r3.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
      let i3 = false;
      if (r3.data.layerType && "Voxel" === r3.data.layerType && (i3 = true), i3)
        return this._fetchVoxelServiceLayer();
      const o2 = r3.data;
      this.read(o2, { origin: "service", url: this.parsedUrl }), this.validateLayer(o2);
    }
    async _fetchVoxelServiceLayer(e2) {
      const r3 = (await U(this.parsedUrl.path + "/layer", { query: { f: "json", token: this.apiKey }, responseType: "json", signal: e2 })).data;
      this.read(r3, { origin: "service", url: this.parsedUrl }), this.validateLayer(r3);
    }
    async _ensureLoadBeforeSave() {
      await this.load(), "beforeSave" in this && "function" == typeof this.beforeSave && await this.beforeSave();
    }
    validateLayer(e2) {
    }
    _updateTypeKeywords(e2, t2, r3) {
      e2.typeKeywords || (e2.typeKeywords = []);
      const i3 = t2.getTypeKeywords();
      for (const o2 of i3)
        e2.typeKeywords.push(o2);
      e2.typeKeywords && (e2.typeKeywords = e2.typeKeywords.filter((e3, t3, r4) => r4.indexOf(e3) === t3), r3 === U2.newItem && (e2.typeKeywords = e2.typeKeywords.filter((e3) => "Hosted Service" !== e3)));
    }
    async _saveAs(e2, t2) {
      const i3 = { ...O, ...t2 };
      let o2 = b2.from(e2);
      o2 || (R.error("_saveAs(): requires a portal item parameter"), await Promise.reject(new s2("sceneservice:portal-item-required", "_saveAs() requires a portal item to save to"))), o2.id && (o2 = o2.clone(), o2.id = null);
      const s3 = o2.portal || B.getDefault();
      await this._ensureLoadBeforeSave(), o2.type = T, o2.portal = s3;
      const a3 = { origin: "portal-item", url: null, messages: [], portal: s3, portalItem: o2, writtenProperties: [], blockedRelativeUrls: [], resources: { toAdd: [], toUpdate: [], toKeep: [], pendingOperations: [] } }, n4 = { layers: [this.write({}, a3)] };
      return await Promise.all(a3.resources.pendingOperations), await this._validateAgainstJSONSchema(n4, a3, i3), o2.url = this.url, o2.title || (o2.title = this.title), this._updateTypeKeywords(o2, i3, U2.newItem), await s3._signIn(), await s3.user.addItem({ item: o2, folder: i3 && i3.folder, data: n4 }), await a2(this.resourceReferences, a3, null), this.portalItem = o2, i(a3), a3.portalItem = o2, o2;
    }
    async _save(e2) {
      const t2 = { ...O, ...e2 };
      this.portalItem || (R.error("_save(): requires the .portalItem property to be set"), await Promise.reject(new s2("sceneservice:portal-item-not-set", "Portal item to save to has not been set on this SceneService"))), this.portalItem.type !== T && (R.error("_save(): Non-matching portal item type. Got " + this.portalItem.type + ", expected " + T), await Promise.reject(new s2("sceneservice:portal-item-wrong-type", `Portal item needs to have type "${T}"`))), await this._ensureLoadBeforeSave();
      const i3 = { origin: "portal-item", url: this.portalItem.itemUrl && j(this.portalItem.itemUrl), messages: [], portal: this.portalItem.portal || B.getDefault(), portalItem: this.portalItem, writtenProperties: [], blockedRelativeUrls: [], resources: { toAdd: [], toUpdate: [], toKeep: [], pendingOperations: [] } }, o2 = { layers: [this.write({}, i3)] };
      return await Promise.all(i3.resources.pendingOperations), await this._validateAgainstJSONSchema(o2, i3, t2), this.portalItem.url = this.url, this.portalItem.title || (this.portalItem.title = this.title), this._updateTypeKeywords(this.portalItem, t2, U2.existingItem), await this.portalItem.update({ data: o2 }), await a2(this.resourceReferences, i3, null), i(i3), this.portalItem;
    }
    async _validateAgainstJSONSchema(e2, t2, i3) {
      let o2 = t2.messages.filter((e3) => "error" === e3.type).map((e3) => new s2(e3.name, e3.message, e3.details));
      if (i3 && i3.validationOptions.ignoreUnsupported && (o2 = o2.filter((e3) => "layer:unsupported" !== e3.name && "symbol:unsupported" !== e3.name && "symbol-layer:unsupported" !== e3.name && "property:unsupported" !== e3.name && "url:unsupported" !== e3.name && "scenemodification:unsupported" !== e3.name)), i3.validationOptions.enabled || E2) {
        const t3 = (await import("./schemaValidator-ZXJ2MP67.js")).validate(e2, i3.portalItemLayerType);
        if (t3.length > 0) {
          const e3 = `Layer item did not validate:
${t3.join("\n")}`;
          if (R.error(`_validateAgainstJSONSchema(): ${e3}`), "throw" === i3.validationOptions.failPolicy) {
            const e4 = t3.map((e5) => new s2("sceneservice:schema-validation", e5)).concat(o2);
            throw new s2("sceneservice-validate:error", "Failed to save layer item due to schema validation, see `details.errors`.", { combined: e4 });
          }
        }
      }
      if (o2.length > 0)
        throw new s2("sceneservice:save", "Failed to save SceneService due to unsupported or invalid content. See 'details.errors' for more detailed information", { errors: o2 });
    }
  };
  return e([d(v)], A2.prototype, "id", void 0), e([d({ type: k })], A2.prototype, "spatialReference", void 0), e([o("spatialReference", ["spatialReference", "store.indexCRS", "store.geographicCRS"])], A2.prototype, "readSpatialReference", null), e([d({ type: M })], A2.prototype, "fullExtent", void 0), e([o("fullExtent", ["fullExtent", "store.extent", "spatialReference", "store.indexCRS", "store.geographicCRS"])], A2.prototype, "readFullExtent", null), e([d({ readOnly: true, type: v2 })], A2.prototype, "heightModelInfo", void 0), e([d({ type: Number, json: { name: "layerDefinition.minScale", write: true, origins: { service: { read: { source: "minScale" }, write: false } } } })], A2.prototype, "minScale", void 0), e([d({ type: Number, json: { name: "layerDefinition.maxScale", write: true, origins: { service: { read: { source: "maxScale" }, write: false } } } })], A2.prototype, "maxScale", void 0), e([d({ readOnly: true })], A2.prototype, "version", void 0), e([o("version", ["store.version"])], A2.prototype, "readVersion", null), e([d({ type: String, json: { read: { source: "copyrightText" } } })], A2.prototype, "copyright", void 0), e([d({ type: String, json: { read: false } })], A2.prototype, "sublayerTitleMode", void 0), e([d({ type: String })], A2.prototype, "title", void 0), e([o("portal-item", "title")], A2.prototype, "readTitlePortalItem", null), e([o("service", "title", ["name"])], A2.prototype, "readTitleService", null), e([d({ type: Number, json: { origins: { service: { read: { source: "id" } }, "portal-item": { write: { target: "id", isRequired: true, ignoreOrigin: true }, read: false } } } })], A2.prototype, "layerId", void 0), e([d(f2)], A2.prototype, "url", null), e([r2("url")], A2.prototype, "writeUrl", null), e([d()], A2.prototype, "parsedUrl", null), e([d({ readOnly: true })], A2.prototype, "store", void 0), e([d({ type: String, readOnly: true, json: { read: { source: "store.rootNode" } } })], A2.prototype, "rootNode", void 0), A2 = e([n("esri.layers.mixins.SceneService")], A2), A2;
};
var N = -1e38;
var E2 = false;
var U2;
!function(e2) {
  e2[e2.existingItem = 0] = "existingItem", e2[e2.newItem = 1] = "newItem";
}(U2 || (U2 = {}));
var T = "Scene Service";
var O = { getTypeKeywords: () => [], portalItemLayerType: "unknown", validationOptions: { enabled: true, ignoreUnsupported: false, failPolicy: "throw" } };
var K;
!function(e2) {
  e2[e2.SAVE = 0] = "SAVE", e2[e2.SAVE_AS = 1] = "SAVE_AS";
}(K || (K = {}));

export {
  A,
  K
};
//# sourceMappingURL=chunk-G4NYIT2C.js.map
