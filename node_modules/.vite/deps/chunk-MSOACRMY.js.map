{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/environment/PrecipitationTechniqueConfiguration.js", "../../@arcgis/core/chunks/Precipitation.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{_ as e}from\"../../../chunks/tslib.es6.js\";import{parameter as n,ShaderTechniqueConfiguration as o}from\"../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration.js\";var t;!function(e){e[e.Rain=0]=\"Rain\",e[e.Snow=1]=\"Snow\",e[e.COUNT=2]=\"COUNT\"}(t||(t={}));class i extends o{constructor(){super(...arguments),this.type=t.Rain}}e([n({count:t.COUNT})],i.prototype,\"type\",void 0);export{i as PrecipitationTechniqueConfiguration,t as PrecipitationType};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{PrecipitationType as e}from\"../views/3d/environment/PrecipitationTechniqueConfiguration.js\";import{Float3Uniform as t}from\"../views/3d/webgl-engine/core/shaderModules/Float3Uniform.js\";import{FloatUniform as o}from\"../views/3d/webgl-engine/core/shaderModules/FloatUniform.js\";import{glsl as i}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as r}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{Matrix4Uniform as a}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4Uniform.js\";import{ShaderBuilder as n}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{VertexAttribute as s}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function d(d){const c=new n;return c.attributes.add(s.POSITION,\"vec3\"),c.attributes.add(s.INSTANCEFEATUREATTRIBUTE,\"float\"),c.vertex.uniforms.add(new t(\"cameraPosition\")),c.vertex.uniforms.add(new t(\"offset\")),c.vertex.uniforms.add(new o(\"width\")),c.vertex.uniforms.add(new r(\"proj\",((e,t)=>t.camera.projectionMatrix))),c.vertex.uniforms.add(new a(\"view\")),c.vertex.uniforms.add(new o(\"time\")),c.varyings.add(\"vUv\",\"vec2\"),c.vertex.code.add(i`\n    vec3 hash31(float p){\n      vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return fract((p3.xxy + p3.yzz) * p3.zyx);\n    }\n\n    float hash11(float p){\n      p = fract(p * 0.1031);\n      p *= p + 33.33;\n      p *= p + p;\n      return fract(p);\n    }\n\n    //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n    vec3 rotateVectorByQuaternion(vec3 v, vec4 q){\n      return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n    }\n\n    void main(void) {\n\n      vUv = position.xz;\n\n      vec3 rand = hash31(instanceFeatureAttribute);\n\n      // Set random position for all particles\n      // The hash function space is not high resolution so offset particles by an additional random value\n      // This creates grids of 1000 particles which are shifted by random hundreths of the tile width\n      // overlaying multiple identical but offset grids\n      vec3 randomPosition = 2.0 * (rand + (0.01 + 0.01 * rand) * floor(0.001 * instanceFeatureAttribute)) - 1.0;\n\n      // Random orientation of rain drops\n      float angle = 3.1415 * hash11(instanceFeatureAttribute);\n\n      vec3 up = vec3(0, 0, 1);\n\n      // Gravity and wind direction\n      vec3 direction = normalize(cameraPosition);\n\n      vec3 tangent = normalize(cross(direction, up));\n\n      // Gravity\n      vec3 animatedPos = randomPosition + direction * -time;\n\n      // Rain particles fall straight down and are randomly oriented\n      // Snow particles have random sinusoid trajectories and are rotated to face the camera\n      ${d.type===e.Rain?i`\n            // Random rotation for particle\n            vec3 rotationAxis = up;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n            vec3 transformedPos = rotateVectorByQuaternion(vec3(0.2, 0.2, 4.0) * (position - vec3(0.5, 0.0, 0.5)), quat);\n\n            // Rotate particle to planetary position\n            rotationAxis = tangent;\n            angle = 0.5 * -acos(dot(direction, up));\n            quat = vec4(rotationAxis * sin(angle), cos(angle));\n            transformedPos = rotateVectorByQuaternion(transformedPos, quat);\n\n            vec4 pos = mat4(mat3(view)) * vec4(transformedPos + (mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * pos;\n      `:i`\n            vec3 rotationAxis = direction;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n\n            tangent = rotateVectorByQuaternion(tangent, quat);\n            // Random sinusoid from friction\n            animatedPos += tangent * 0.25 * sin(dot(animatedPos, direction));\n            vec4 pos = mat4(mat3(view)) * vec4((mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * (0.5 * vec4(position.xzy, 0.0) + pos);\n      `}\n    }\n  `),c.fragment.uniforms.add(new o(\"opacity\")),c.fragment.uniforms.add(new t(\"particleColor\")),c.fragment.code.add(i`\n    void main() {\n\n      // Cut off corners of the triangle\n      if(vUv.x < 0.0 || vUv.y < 0.0){\n        discard;\n      }\n\n      float d = length(vUv - vec2(0.5));\n\n      ${d.type===e.Rain?i`d = 0.35 * smoothstep(0.5, 0.0, d);`:i`d = smoothstep(0.5, 0.1, d);`}\n      gl_FragColor = opacity * vec4(particleColor * d, d);\n    }\n  `),c}const c=Object.freeze(Object.defineProperty({__proto__:null,build:d},Symbol.toStringTag,{value:\"Module\"}));export{c as P,d as b};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIoL,IAAIA;AAAE,CAAC,SAASC,IAAE;AAAC,EAAAA,GAAEA,GAAE,OAAK,CAAC,IAAE,QAAOA,GAAEA,GAAE,OAAK,CAAC,IAAE,QAAOA,GAAEA,GAAE,QAAM,CAAC,IAAE;AAAO,EAAED,OAAIA,KAAE,CAAC,EAAE;AAAE,IAAME,KAAN,cAAgB,EAAC;AAAA,EAAC,cAAa;AAAC,UAAM,GAAG,SAAS,GAAE,KAAK,OAAKF,GAAE;AAAA,EAAI;AAAC;AAAC,EAAE,CAACC,GAAE,EAAC,OAAMD,GAAE,MAAK,CAAC,CAAC,GAAEE,GAAE,WAAU,QAAO,MAAM;;;ACA6V,SAAS,EAAEC,IAAE;AAAC,QAAMC,KAAE,IAAI;AAAE,SAAOA,GAAE,WAAW,IAAI,EAAE,UAAS,MAAM,GAAEA,GAAE,WAAW,IAAI,EAAE,0BAAyB,OAAO,GAAEA,GAAE,OAAO,SAAS,IAAI,IAAIC,GAAE,gBAAgB,CAAC,GAAED,GAAE,OAAO,SAAS,IAAI,IAAIC,GAAE,QAAQ,CAAC,GAAED,GAAE,OAAO,SAAS,IAAI,IAAI,EAAE,OAAO,CAAC,GAAEA,GAAE,OAAO,SAAS,IAAI,IAAIE,GAAE,QAAQ,CAACA,IAAEC,OAAIA,GAAE,OAAO,gBAAiB,CAAC,GAAEH,GAAE,OAAO,SAAS,IAAI,IAAI,EAAE,MAAM,CAAC,GAAEA,GAAE,OAAO,SAAS,IAAI,IAAI,EAAE,MAAM,CAAC,GAAEA,GAAE,SAAS,IAAI,OAAM,MAAM,GAAEA,GAAE,OAAO,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QA8ClpCD,GAAE,SAAOI,GAAE,OAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAchB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAWL,GAAEH,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,SAAS,CAAC,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAIC,GAAE,eAAe,CAAC,GAAED,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAU3GD,GAAE,SAAOI,GAAE,OAAK,yCAAuC;AAAA;AAAA;AAAA,GAG5D,GAAEH;AAAC;AAAC,IAAM,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["t", "e", "i", "d", "c", "o", "e", "t"]
}
