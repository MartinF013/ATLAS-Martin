import {
  _
} from "./chunk-HU4BCST4.js";
import {
  o,
  u as u3
} from "./chunk-MDCKEJ7B.js";
import {
  L,
  w
} from "./chunk-JZY7CGEI.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  h,
  l
} from "./chunk-T7BEWVV3.js";
import {
  p
} from "./chunk-RN2KRYDN.js";
import {
  R,
  a,
  b,
  h as h2,
  u as u2,
  y as y2
} from "./chunk-56RHM4A6.js";
import {
  n as n4
} from "./chunk-OIPX3EDD.js";
import {
  d,
  n2 as n,
  n4 as n2,
  n8 as n3,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/ExtentSet.js
var _2 = 0.05;
var a2 = class {
  constructor() {
    this._extents = new n2({ allocator: (t2) => t2 || u2() }), this._tmpExtent = u2(), this._dirty = false;
  }
  get empty() {
    return 0 === this._extents.length;
  }
  get size() {
    return this._extents.length;
  }
  clear() {
    this._extents.clear();
  }
  add(t2) {
    this._contains(t2) || (this._removeContained(t2), a(this._extents.pushNew(), t2), this._dirty = true);
  }
  pop() {
    return this._dirty && this._mergeTight(), this._extents.pop();
  }
  merge(t2) {
    return this._mergeTight(t2), t2.hasProgressed;
  }
  _mergeTight(t2 = w) {
    const e3 = this._extents, o2 = /* @__PURE__ */ new Set();
    let i = 0;
    for (; i !== e3.length; ) {
      e3.sort((t3, e4) => t3[0] - e4[0]), i = e3.length, o2.clear();
      for (let i2 = 0; i2 < e3.length; ++i2) {
        if (t2.done)
          return;
        const h3 = e3.getItemAt(i2);
        for (let t3 = i2 + 1; t3 < e3.length; ++t3) {
          const r3 = e3.getItemAt(t3);
          if (r3[0] >= h3[2])
            break;
          o2.add(r3);
        }
        o2.forEach((i3) => {
          if (h3 === i3)
            return;
          if (i3[2] <= h3[0])
            return void o2.delete(i3);
          const a3 = y2(h3), c = y2(i3), g = this._tmpExtent;
          h2(h3, i3, g);
          const m = a3 + c;
          (y2(g) - m) / m < _2 && (a(h3, g), o2.delete(i3), e3.remove(i3), t2.madeProgress());
        }), o2.add(h3);
      }
    }
    this._dirty = false;
  }
  _contains(t2) {
    return this._extents.some((e3) => R(e3, t2));
  }
  _removeContained(t2) {
    this._extents.filterInPlace((e3) => !R(t2, e3));
  }
  get test() {
    const t2 = this;
    return { containsPoint: (e3) => t2._extents.some((t3) => b(t3, e3)) };
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DElevationAlignment.js
var d2 = class extends y {
  constructor() {
    super(...arguments), this.dirtyExtents = new a2(), this.globalDirty = false, this.averageExtentUpdateSize = 0, this.dirtyGraphicsSet = /* @__PURE__ */ new Set(), this.handles = new u(), this.updateElevation = false, this.graphicsCoreOwner = null, this.graphicsCore = null, this.events = new n4();
  }
  setup(e3, t2, i, s2) {
    this.graphicsCoreOwner = e3, this.queryGraphicUIDsInExtent = t2, this.graphicsCore = i, this.elevationProvider = s2;
    const r3 = this.graphicsCoreOwner.view.resourceController.scheduler;
    this.handles.add([s2.on("elevation-change", (e4) => this._elevationChanged(e4)), l(() => this.graphicsCoreOwner.suspended, () => this._suspendedChange()), r3.registerTask(L.ELEVATION_ALIGNMENT, this)]);
  }
  destroy() {
    this.dirtyGraphicsSet.clear(), this.handles.destroy(), this.handles = null, this.graphicsCoreOwner = null, this.graphicsCore = null, this.queryGraphicUIDsInExtent = null;
  }
  clear() {
    this.dirtyGraphicsSet.clear(), this.notifyChange("updating");
  }
  _suspendedChange() {
    true === this.graphicsCoreOwner.suspended ? this.updateElevation = false : false === this.graphicsCoreOwner.suspended && this.updateElevation && (this.globalDirty = true, this.notifyChange("updating"));
  }
  elevationInfoChange() {
    this.globalDirty = true, this.notifyChange("updating");
  }
  get updating() {
    return this.running;
  }
  get running() {
    return this.dirtyGraphicsSet.size > 0 || this.dirtyExtents && !this.dirtyExtents.empty || this.globalDirty;
  }
  get updatingRemaining() {
    return this.dirtyGraphicsSet.size + this.dirtyExtents.size * this.averageExtentUpdateSize;
  }
  runTask(e3) {
    for (this.globalDirty && (this._markAllGraphicsElevationDirty(), this.globalDirty = false, e3.madeProgress()), e3.run(() => this.dirtyExtents.merge(e3)); this.running && !e3.done; )
      this._updateDirtyGraphics(e3), this._updateDirtyExtents(e3);
    this.graphicsCoreOwner.view.deconflictor.setDirty(), this.notifyChange("updating");
  }
  _updateDirtyGraphics(e3) {
    const t2 = this.graphicsCoreOwner.view.renderCoordsHelper, i = this.graphicsCore.effectiveUpdatePolicy === o.ASYNC;
    for (const s2 of this.dirtyGraphicsSet.keys()) {
      const a3 = this.graphicsCore.getGraphics3DGraphicById(s2);
      if (this.dirtyGraphicsSet.delete(s2), r(a3) && (a3.alignWithElevation(this.elevationProvider, t2, i), e3.madeProgress()), e3.done)
        return;
    }
  }
  _updateDirtyExtents(e3) {
    for (; !this.dirtyExtents.empty && !e3.done; ) {
      const t2 = this.dirtyExtents.pop(), i = this.elevationProvider.spatialReference;
      this.events.emit("invalidate-elevation", { extent: t2, spatialReference: i });
      const s2 = this.dirtyGraphicsSet.size;
      this.queryGraphicUIDsInExtent(t2, i, (e4) => {
        const t3 = this.graphicsCore.getGraphics3DGraphicById(e4);
        r(t3) && t3.needsElevationUpdates() && this.dirtyGraphicsSet.add(e4);
      }), this.averageExtentUpdateSize = 0.1 * (this.dirtyGraphicsSet.size - s2) + 0.9 * this.averageExtentUpdateSize, e3.madeProgress();
    }
  }
  _markAllGraphicsElevationDirty() {
    this.dirtyExtents.clear(), this.dirtyGraphicsSet.clear(), this.graphicsCore.graphics3DGraphics.forEach((e3, t2) => this.dirtyGraphicsSet.add(t2));
  }
  _elevationChanged(e3) {
    if ("scene" === e3.context && (!this.graphicsCore.layer.elevationInfo || "relative-to-scene" !== this.graphicsCore.layer.elevationInfo.mode))
      return;
    const { extent: t2, spatialReference: i } = e3;
    if (this.graphicsCoreOwner.suspended) {
      if (!this.updateElevation) {
        const e4 = this.graphicsCore.computedExtent;
        e4 && t2[2] > e4.xmin && t2[0] < e4.xmax && t2[3] > e4.ymin && t2[1] < e4.ymax && (this.updateElevation = true);
      }
      this.events.emit("invalidate-elevation", { extent: t2, spatialReference: i });
    } else
      t2[0] === -1 / 0 ? this.globalDirty = true : this.dirtyExtents.add(t2), this.notifyChange("updating");
  }
};
e([d({ readOnly: true })], d2.prototype, "updating", null), e([d({ readOnly: true })], d2.prototype, "updatingRemaining", null), d2 = e([n3("esri.views.3d.layers.graphics.Graphics3DElevationAlignment")], d2);
var l2 = d2;

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFrustumVisibility.js
var l3 = 1.2;
var u4 = class extends y {
  constructor() {
    super(...arguments), this.suspended = false, this.extent = null, this.extentIntersectionDirty = true, this._isVisibleBelowSurface = false, this.handles = new u(), this.graphicsCoreOwner = null, this.updating = true;
  }
  setup(e3) {
    this.graphicsCoreOwner = e3, this.extentIntersection = new _({ renderCoordsHelper: e3.view.renderCoordsHelper });
    const t2 = e3.view, s2 = t2.basemapTerrain, o2 = t2.resourceController.scheduler;
    this.handles.add([t2.on("resize", () => this._viewChange()), l(() => t2.state.camera, () => this._viewChange(), U), o2.registerTask(L.FRUSTUM_VISIBILITY, this), s2.on("elevation-bounds-change", () => this._elevationBoundsChange())]), "local" === t2.viewingMode ? this.isVisibleBelowSurface = true : this.handles.add([l(() => {
      var _a, _b, _c;
      return [s2.baseOpacity, s2.wireframe, (_c = (_b = (_a = t2.map) == null ? void 0 : _a.ground) == null ? void 0 : _b.navigationConstraint) == null ? void 0 : _c.type];
    }, () => this._updateIsVisibleBelowSurface(), h)]);
  }
  destroy() {
    this.graphicsCoreOwner = null, this.extent = null, this.extentIntersection = null, this.handles && (this.handles.destroy(), this.handles = null);
  }
  _setDirty() {
    this.updating || this._set("updating", true);
  }
  setExtent(e3) {
    this.extent = e3, this.extentIntersectionDirty = true, this._setDirty();
  }
  _viewChange() {
    this._setDirty();
  }
  _elevationBoundsChange() {
    this._setDirty(), this.extentIntersectionDirty = true;
  }
  set isVisibleBelowSurface(e3) {
    this._isVisibleBelowSurface = e3, this._setDirty(), this.extentIntersectionDirty = true;
  }
  _updateIsVisibleBelowSurface() {
    const e3 = this.graphicsCoreOwner.view, t2 = e3.basemapTerrain, s2 = "local" === e3.viewingMode, i = e3.map.ground && e3.map.ground.navigationConstraint && "none" === e3.map.ground.navigationConstraint.type;
    this.isVisibleBelowSurface = s2 || !t2.opaque || i;
  }
  _updateExtentIntersection() {
    if (!this.extentIntersectionDirty)
      return;
    this.extentIntersectionDirty = false;
    const e3 = this.graphicsCoreOwner.view;
    let t2;
    if (this._isVisibleBelowSurface)
      t2 = -0.3 * p(e3.spatialReference).radius;
    else {
      const { min: s2, max: i } = e3.basemapTerrain.elevationBounds;
      t2 = s2 - Math.max(1, (i - s2) * (l3 - 1));
    }
    this.extentIntersection.update(this.extent, e3.spatialReference, t2);
  }
  get running() {
    return this.updating;
  }
  runTask() {
    if (this._set("updating", false), !this.extent)
      return void this._set("suspended", false);
    this._updateExtentIntersection();
    const e3 = this.graphicsCoreOwner.view.frustum, t2 = p(this.graphicsCoreOwner.view.spatialReference).radius;
    this._set("suspended", !this.extentIntersection.isVisibleInFrustum(e3, t2));
  }
};
e([d({ readOnly: true })], u4.prototype, "suspended", void 0), e([d({ readOnly: true })], u4.prototype, "updating", void 0), u4 = e([n3("esri.views.3d.layers.graphics.Graphics3DFrustumVisibility")], u4);
var d3 = u4;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Object3DStateSet.js
var t;
!function(e3) {
  e3[e3.Object = 0] = "Object", e3[e3.RenderGeometry = 1] = "RenderGeometry", e3[e3.External = 2] = "External", e3[e3.COUNT = 3] = "COUNT";
}(t || (t = {}));
var r2 = class {
  constructor() {
    this.items = [];
  }
  addObject(e3, r3) {
    this.items.push({ type: t.Object, objectStateId: r3, object: e3 });
  }
  addRenderGeometry(e3, r3, o2) {
    this.items.push({ type: t.RenderGeometry, objectStateId: r3, renderGeometry: e3, owner: o2 });
  }
  addExternal(e3, r3) {
    this.items.push({ type: t.External, objectStateId: r3, remove: e3 });
  }
  remove(e3) {
    for (let t2 = this.items.length - 1; t2 >= 0; --t2) {
      const r3 = this.items[t2];
      r3.objectStateId === e3 && (this._removeObjectStateItem(r3), this.items.splice(t2, 1));
    }
  }
  removeObject(e3) {
    for (let r3 = this.items.length - 1; r3 >= 0; --r3) {
      const o2 = this.items[r3];
      o2.type === t.Object && o2.object === e3 && (this._removeObjectStateItem(o2), this.items.splice(r3, 1));
    }
  }
  removeRenderGeometry(e3) {
    for (let r3 = this.items.length - 1; r3 >= 0; --r3) {
      const o2 = this.items[r3];
      o2.type === t.RenderGeometry && o2.renderGeometry === e3 && (this._removeObjectStateItem(o2), this.items.splice(r3, 1));
    }
  }
  removeAll() {
    this.items.forEach((e3) => {
      this._removeObjectStateItem(e3);
    }), this.items = [];
  }
  _removeObjectStateItem(r3) {
    switch (r3.type) {
      case t.Object:
        r3.objectStateId.channel === u3.Highlight ? r3.object.removeHighlight(r3.objectStateId) : r3.objectStateId.channel === u3.MaskOccludee && r3.object.removeOcclude(r3.objectStateId);
        break;
      case t.RenderGeometry:
        r3.owner.removeRenderGeometryObjectState(r3.renderGeometry, r3.objectStateId);
        break;
      case t.External:
        r3.remove(r3.objectStateId);
    }
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectStateSet.js
var e2 = class {
  constructor(e3, i) {
    this.stateType = e3, this.objectIdField = i, this.objectStateSet = new r2(), this.ids = /* @__PURE__ */ new Set(), this.paused = false;
  }
  hasGraphic(t2) {
    if (this.objectIdField) {
      const e3 = t2.graphic.attributes[this.objectIdField];
      return this.ids.has(e3);
    }
    return this.ids.has(t2.graphic.uid);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectStates.js
var s = class {
  constructor(t2) {
    this._graphicsCore = t2, this._stateSets = new Array();
  }
  destroy() {
    this._stateSets && this._stateSets.forEach((t2) => t2.objectStateSet.removeAll()), this._stateSets = null;
  }
  acquireSet(s2, a3) {
    const i = new e2(s2, a3);
    this._stateSets.push(i);
    const h3 = n(() => this.releaseSet(i));
    return { set: i, handle: h3 };
  }
  releaseSet(t2) {
    t2.objectStateSet.removeAll();
    const e3 = this._stateSets ? this._stateSets.indexOf(t2) : -1;
    -1 !== e3 && this._stateSets.splice(e3, 1);
  }
  _addObjectStateSet(t2, e3) {
    t2.addObjectStateSet(e3.stateType, e3.objectStateSet);
  }
  _removeObjectStateSet(t2, e3) {
    t2.removeObjectState(e3.objectStateSet);
  }
  setUid(t2, e3) {
    t2.ids.add(e3);
    const s2 = this._graphicsCore.graphics3DGraphics.get(e3);
    s2 && this._addObjectStateSet(s2, t2);
  }
  setUids(t2, e3) {
    e3.forEach((e4) => this.setUid(t2, e4));
  }
  setObjectIds(t2, e3) {
    e3.forEach((e4) => t2.ids.add(e4)), this._initializeSet(t2);
  }
  addGraphic(t2) {
    this._stateSets.forEach((e3) => {
      !e3.paused && e3.hasGraphic(t2) && this._addObjectStateSet(t2, e3);
    });
  }
  removeGraphic(t2) {
    this._stateSets.forEach((e3) => {
      e3.hasGraphic(t2) && this._removeObjectStateSet(t2, e3);
    });
  }
  allGraphicsDeleted() {
    this._stateSets && this._stateSets.forEach((t2) => t2.objectStateSet.removeAll());
  }
  _initializeSet(t2) {
    const e3 = this._graphicsCore.graphics3DGraphics;
    t2.objectIdField ? e3.forEach((e4) => {
      e4 && t2.hasGraphic(e4) && this._addObjectStateSet(e4, t2);
    }) : t2.ids.forEach((s2) => {
      const a3 = e3.get(s2);
      a3 && this._addObjectStateSet(a3, t2);
    });
  }
  get test() {
    return { states: this._stateSets };
  }
};

export {
  l2 as l,
  d3 as d,
  s
};
//# sourceMappingURL=chunk-L6YDAPZR.js.map
