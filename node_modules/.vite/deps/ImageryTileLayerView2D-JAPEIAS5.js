import {
  m as m2
} from "./chunk-DMGE4KYG.js";
import {
  d as d3,
  y
} from "./chunk-ICFEIR72.js";
import "./chunk-7S6G3GM7.js";
import {
  r as r4
} from "./chunk-XQ337NY7.js";
import {
  i as i3
} from "./chunk-UMSO3HI4.js";
import {
  f
} from "./chunk-VKEKAYXP.js";
import {
  u as u4
} from "./chunk-6UGZAJSY.js";
import {
  o
} from "./chunk-JX3YCNPL.js";
import "./chunk-JERZLQLG.js";
import {
  W,
  m,
  p as p2
} from "./chunk-JWKDNFWF.js";
import "./chunk-ATJYWC6C.js";
import "./chunk-KXE4LGFJ.js";
import "./chunk-SASFTPK5.js";
import "./chunk-UJS24K6P.js";
import "./chunk-UKBGUXUQ.js";
import "./chunk-AKNCAMEF.js";
import "./chunk-UGLXR5OV.js";
import "./chunk-RGZ7VIMW.js";
import {
  I
} from "./chunk-6FQZDXGD.js";
import "./chunk-PNNMRFHO.js";
import {
  g as g2,
  i as i2,
  s as s3,
  u as u3
} from "./chunk-3KSVJZR6.js";
import {
  X,
  ne
} from "./chunk-B5VZTE6L.js";
import {
  F
} from "./chunk-I2XAFJCJ.js";
import {
  l as l2,
  u as u2
} from "./chunk-YRAX326I.js";
import "./chunk-HH3D3A65.js";
import "./chunk-OA3NMCNZ.js";
import "./chunk-YDPQRKY4.js";
import "./chunk-AGO2OES3.js";
import {
  r as r2
} from "./chunk-ARI6FRU4.js";
import {
  p
} from "./chunk-BBO6WYBO.js";
import {
  h as h2
} from "./chunk-TH2ECCFL.js";
import "./chunk-TCBD6DES.js";
import "./chunk-G2GJVIQC.js";
import {
  r as r3
} from "./chunk-567AWHAB.js";
import "./chunk-TZD2AXJG.js";
import "./chunk-FZCDFXBT.js";
import "./chunk-KD6KBT2L.js";
import "./chunk-RVR2DEVB.js";
import "./chunk-AS3OSZXK.js";
import "./chunk-IYLBVJ6T.js";
import "./chunk-Z7AZMEL6.js";
import "./chunk-FUKESVWQ.js";
import "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-33INAWJA.js";
import "./chunk-FPMD6IB4.js";
import "./chunk-RIOXX6J2.js";
import {
  mt
} from "./chunk-4ZEOAETN.js";
import {
  e as e3
} from "./chunk-MEW2XKT2.js";
import "./chunk-RB3LJE4I.js";
import {
  l as l3
} from "./chunk-6EODZIDR.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-PQO66WZ2.js";
import {
  i,
  s as s2
} from "./chunk-3NPGGTI6.js";
import "./chunk-QNKOXOOY.js";
import "./chunk-AMGAY4O5.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-ZUDEVIXR.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-FUQI3AAI.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-PZWU5EHT.js";
import "./chunk-YL26MZEL.js";
import "./chunk-YG6VFATO.js";
import {
  S
} from "./chunk-HR2OX32D.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-JT3LXQ47.js";
import "./chunk-TBT57L4K.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import {
  d as d2
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  h,
  l,
  w
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import {
  g as g3
} from "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  u
} from "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  E,
  g,
  x
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  e as e2,
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterTile.js
var i4 = class extends r3 {
  constructor(t, e4, i5, r6, a, n5 = null) {
    super(t, e4, i5, r6, a), this.bitmap = new p2(n5, null, null), this.bitmap.coordScale = [r6, a], this.bitmap.once("isReady", () => this.ready());
  }
  destroy() {
    super.destroy(), this.bitmap.destroy(), this.bitmap = null, this.stage = null;
  }
  set stencilRef(t) {
    this.bitmap.stencilRef = t;
  }
  get stencilRef() {
    return this.bitmap.stencilRef;
  }
  setTransform(t, s4) {
    super.setTransform(t, s4), this.bitmap.transforms.dvs = this.transforms.dvs;
  }
  _createTransforms() {
    return { dvs: e3(), tileMat3: e3() };
  }
  onAttach() {
    this.bitmap.stage = this.stage;
  }
  onDetach() {
    this.bitmap.stage = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterTileContainer.js
var n2 = class extends o {
  constructor() {
    super(...arguments), this.isCustomTilingScheme = false;
  }
  createTile(e4) {
    const s4 = this._getTileBounds(e4), [r6, t] = this._tileInfoView.tileInfo.size;
    return new i4(e4, s4[0], s4[3], r6, t);
  }
  prepareRenderPasses(e4) {
    const s4 = e4.registerRenderPass({ name: "imagery (tile)", brushes: [W.raster], target: () => this.children.map((e5) => e5.bitmap), drawPhase: I.MAP });
    return [...super.prepareRenderPasses(e4), s4];
  }
  doRender(e4) {
    this.visible && e4.drawPhase === I.MAP && super.doRender(e4);
  }
  _getTileBounds(r6) {
    const i5 = this._tileInfoView.getTileBounds(u(), r6);
    if (this.isCustomTilingScheme && r6.world) {
      const { tileInfo: e4 } = this._tileInfoView, t = mt(e4.spatialReference);
      if (t) {
        const { resolution: s4 } = e4.lodAt(r6.level), o3 = t / s4 % e4.size[0], n5 = o3 ? (e4.size[0] - o3) * s4 : 0;
        i5[0] -= n5 * r6.world, i5[2] -= n5 * r6.world;
      }
    }
    return i5;
  }
};

// node_modules/@arcgis/core/views/2d/layers/imagery/BaseImageryTileSubView2D.js
var R = [0, 0];
var T = s.getLogger("esri.views.2d.layers.ImageryTileLayerView2D");
var V = class extends d2 {
  constructor() {
    super(...arguments), this._emptyTilePixelBlock = null, this._tileStrategy = null, this._tileInfoView = null, this._fetchQueue = null, this._blockCacheRegistryUrl = null, this._blockCacheRegistryId = null, this._srcResolutions = null, this.previousLOD = null, this._needBlockCacheUpdate = false, this._globalSymbolizerParams = null, this._symbolizerParams = null, this._abortController = null, this._isCustomTilingScheme = false, this._globalUpdateRequested = false, this.attached = false, this.container = null, this.layer = null, this.timeExtent = null, this.redrawOrRefetch = x((e4, t) => !this.previousLOD || this.layerView.suspended ? Promise.resolve() : e4 ? this.updatingHandles.addPromise(this.doRefresh()) : this.updatingHandles.addPromise(this._redrawImage(t)));
  }
  get useWebGLForProcessing() {
    return this._get("useWebGLForProcessing") ?? true;
  }
  set useWebGLForProcessing(e4) {
    this._set("useWebGLForProcessing", e4);
  }
  get useProgressiveUpdate() {
    return null == this._get("useProgressiveUpdate") || this._get("useProgressiveUpdate");
  }
  set useProgressiveUpdate(e4) {
    if (this._tileStrategy && this.useProgressiveUpdate !== e4) {
      this._tileStrategy.destroy(), this.container.removeAllChildren();
      const t = this._getCacheSize(e4);
      this._tileStrategy = new r2({ cachePolicy: "purge", acquireTile: (e5) => this.acquireTile(e5), releaseTile: (e5) => this.releaseTile(e5), cacheSize: t, tileInfoView: this._tileInfoView }), this._set("useProgressiveUpdate", e4), this.layerView.requestUpdate();
    }
  }
  update(e4) {
    var _a;
    this._fetchQueue.pause(), this._fetchQueue.state = e4.state, this._tileStrategy.update(e4), this._fetchQueue.resume();
    const { extent: t, resolution: i5, scale: s4 } = e4.state, r6 = this._tileInfoView.getClosestInfoForScale(s4);
    if (this.layer.raster) {
      if (!this.useProgressiveUpdate || this._needBlockCacheUpdate) {
        const e5 = this._srcResolutions[r6.level], s5 = t.toJSON ? t : M.fromJSON(t);
        g2(this._blockCacheRegistryUrl, this._blockCacheRegistryId, s5, i5, e5, this.layer.raster.ioConfig.sampling);
      }
      this._needBlockCacheUpdate = false, ((_a = this.previousLOD) == null ? void 0 : _a.level) !== r6.level && (this.previousLOD = r6, null == this._symbolizerParams || this.layerView.hasTilingEffects || this._updateSymbolizerParams(), this._tileStrategy.updateCacheSize(0));
    }
  }
  moveEnd() {
    !this.layerView.hasTilingEffects && this.useProgressiveUpdate || (this._abortController && this._abortController.abort(), this._abortController = new AbortController(), 0 === this._fetchQueue.length && this._redrawImage(this._abortController.signal).then(() => {
      this._globalUpdateRequested = false, this.layerView.requestUpdate();
    }));
    const e4 = this._getCacheSize(this.useProgressiveUpdate);
    this._tileStrategy.updateCacheSize(e4), this.layerView.requestUpdate();
  }
  get updating() {
    var _a;
    return ((_a = this._fetchQueue) == null ? void 0 : _a.updating) || this._globalUpdateRequested || !(!this.updatingHandles || !this.updatingHandles.updating);
  }
  attach() {
    l3("2d").supportsTextureFloat || (this.useWebGLForProcessing = false), this._initializeTileInfo(), this._tileInfoView = new h2(this.layerView.tileInfo, this.layerView.fullExtent);
    const e4 = this._computeFetchConcurrency();
    this._fetchQueue = new p({ tileInfoView: this._tileInfoView, concurrency: e4, process: (e5, t2) => this._fetchTile1(e5, t2) });
    const t = this._getCacheSize(this.useProgressiveUpdate);
    this._tileStrategy = new r2({ cachePolicy: "purge", acquireTile: (e5) => this.acquireTile(e5), releaseTile: (e5) => this.releaseTile(e5), cacheSize: t, tileInfoView: this._tileInfoView }), this._updateBlockCacheRegistry();
  }
  detach() {
    this._tileStrategy.destroy(), this._fetchQueue.clear(), this.container.removeAllChildren(), this._fetchQueue = this._tileStrategy = this._tileInfoView = null, u3(this._blockCacheRegistryUrl, this._blockCacheRegistryId), this._blockCacheRegistryUrl = this._blockCacheRegistryId = null;
  }
  acquireTile(e4) {
    const t = this.container.createTile(e4);
    return this._enqueueTileFetch(t), this.layerView.requestUpdate(), this._needBlockCacheUpdate = true, this._globalUpdateRequested = this.layerView.hasTilingEffects || !this.useProgressiveUpdate, t;
  }
  releaseTile(e4) {
    this._fetchQueue.abort(e4.key.id), this.container.removeChild(e4), e4.once("detach", () => {
      e4.destroy(), this.layerView.requestUpdate();
    }), this.layerView.requestUpdate();
  }
  createEmptyTilePixelBlock(e4 = null) {
    const t = null == e4 || e4.join(",") === this._tileInfoView.tileInfo.size.join(",");
    if (t && r(this._emptyTilePixelBlock))
      return this._emptyTilePixelBlock;
    e4 = e4 || this._tileInfoView.tileInfo.size;
    const [i5, r6] = e4, l5 = new u2({ width: i5, height: r6, pixels: [new Uint8Array(i5 * r6)], mask: new Uint8Array(i5 * r6), pixelType: "u8" });
    return t && (this._emptyTilePixelBlock = l5), l5;
  }
  _fetchTile1(e4, t) {
    const i5 = r(t) && t.signal, l5 = this.canUseWebGLForProcessing(), { layerView: a } = this, o3 = !a.tileInfo.isWrappable && r(X(a.view.spatialReference)), h3 = { allowPartialFill: true, datumTransformation: a.datumTransformation, interpolation: l5 ? "nearest" : this.layer.interpolation, registryId: this._blockCacheRegistryId, requestRawData: l5, signal: e2(i5), srcResolution: this._srcResolutions[e4.level], timeExtent: a.timeExtent, tileInfo: a.tileInfo, disableWrapAround: o3 };
    return this.fetchTile(e4, h3);
  }
  _getCacheSize(e4) {
    return e4 ? 40 : 0;
  }
  _initializeTileInfo() {
    const e4 = this.layerView.view.spatialReference, t = new j({ x: this.layerView.fullExtent.xmin, y: this.layerView.fullExtent.ymax, spatialReference: e4 }), { scales: i5, srcResolutions: s4, isCustomTilingScheme: r6 } = ne(this.layer.rasterInfo, e4), l5 = S.create({ spatialReference: e4, size: 512, scales: i5 });
    (0 === l5.origin.x || l5.origin.x > t.x) && (l5.origin = t), this._isCustomTilingScheme = r6, this.layerView.set("tileInfo", l5), this._srcResolutions = s4 ?? [];
  }
  _computeFetchConcurrency() {
    const { blockBoundary: e4 } = this.layer.rasterInfo.storageInfo, t = e4[e4.length - 1];
    return (t.maxCol - t.minCol + 1) * (t.maxRow - t.minRow + 1) > 64 ? 2 : 10;
  }
  async _enqueueTileFetch(e4, t) {
    this.updatingHandles.addPromise(this._enqueueTileFetch1(e4, t));
  }
  async _enqueueTileFetch1(e4, t) {
    if (!this._fetchQueue.has(e4.key.id)) {
      try {
        const t2 = await this._fetchQueue.push(e4.key), { bandIds: s4 } = this.layer;
        let r6 = !this.useProgressiveUpdate || this.layerView.hasTilingEffects && !this._globalSymbolizerParams;
        if (this._globalUpdateRequested && !this.layerView.moving && 0 === this._fetchQueue.length) {
          r6 = false;
          try {
            await this._redrawImage(this._abortController && this._abortController.signal);
          } catch (i5) {
            g(i5) && T.error(i5);
          }
          this._globalUpdateRequested = false;
        }
        !this.canUseWebGLForProcessing() && "rasterVF" !== this.type || this.layerView.hasTilingEffects || null != this._symbolizerParams || this._updateSymbolizerParams();
        const l5 = this._tileInfoView.getTileCoords(R, e4.key), o3 = this._tileInfoView.getTileResolution(e4.key);
        await this.updateTileSource(e4, { source: t2, symbolizerParams: this._symbolizerParams, globalSymbolizerParams: this._globalSymbolizerParams, suspended: r6, bandIds: s4, coords: l5, resolution: o3 }), e4.once("attach", () => this.layerView.requestUpdate()), this.container.addChild(e4);
      } catch (i5) {
        g(i5) || T.error(i5);
      }
      this.layerView.requestUpdate();
    }
  }
  async _redrawImage(e4) {
    if (0 === this.container.children.length)
      return;
    await this.layer.updateRenderer(), this.layerView.hasTilingEffects ? await this._updateGlobalSymbolizerParams(e4) : (this._updateSymbolizerParams(), this._globalSymbolizerParams = null);
    const t = this.container.children.map(async (e5) => this.updateTileSymbolizerParameters(e5, { local: this._symbolizerParams, global: this._globalSymbolizerParams }));
    await E(t), this.container.requestRender();
  }
  async _updateGlobalSymbolizerParams(e4) {
    const t = { srcResolution: this._srcResolutions[this.previousLOD.level], registryId: this._blockCacheRegistryId, signal: e4 }, i5 = await this.layer.fetchPixels(this.layerView.view.extent, this.layerView.view.width, this.layerView.view.height, t);
    if (!i5 || !i5.pixelBlock)
      return;
    const s4 = this.layer.symbolizer.generateWebGLParameters({ pixelBlock: l2(i5.pixelBlock, this.layer.bandIds), isGCS: this.layerView.view.spatialReference.isGeographic, resolution: { x: this.previousLOD.resolution, y: this.previousLOD.resolution }, bandIds: this.layer.bandIds });
    !this.canUseWebGLForProcessing() && s4 && "stretch" === s4.type && this.layer.renderer && "raster-stretch" === this.layer.renderer.type && (s4.factor = s4.factor.map((e5) => 255 * e5), s4.outMin = Math.round(255 * s4.outMin), s4.outMax = Math.round(255 * s4.outMax)), this._globalSymbolizerParams = s4;
  }
  _updateSymbolizerParams() {
    this._symbolizerParams = this.layer.symbolizer.generateWebGLParameters({ pixelBlock: null, isGCS: this.layerView.view.spatialReference.isGeographic, resolution: { x: this.previousLOD.resolution, y: this.previousLOD.resolution }, bandIds: this.layer.bandIds });
  }
  _updateBlockCacheRegistry(e4 = false) {
    const { url: t, rasterInfo: i5, raster: s4 } = this.layer, { multidimensionalDefinition: r6 } = this.layer.normalizeRasterFetchOptions({ multidimensionalDefinition: this.layer.multidimensionalDefinition, timeExtent: this.layerView.timeExtent }), l5 = (i5 == null ? void 0 : i5.multidimensionalInfo) ? s4.getSliceIndex(r6) : null, a = i2(t, l5);
    if (a !== this._blockCacheRegistryUrl) {
      if (null != this._blockCacheRegistryUrl && u3(this._blockCacheRegistryUrl, this._blockCacheRegistryId), this._blockCacheRegistryId = s3(a, this.layer.raster.rasterInfo), e4) {
        const e5 = this._tileInfoView.getClosestInfoForScale(this.layerView.view.scale), t2 = this._srcResolutions[e5.level];
        g2(a, this._blockCacheRegistryId, this.layerView.view.extent, this.layerView.view.resolution, t2, this.layer.raster.ioConfig.sampling);
      }
      this._blockCacheRegistryUrl = a;
    }
  }
  async doRefresh() {
    await this.layer.updateRenderer(), this.layerView.hasTilingEffects || this._updateSymbolizerParams(), this._updateBlockCacheRegistry(true), this._fetchQueue.reset();
    const e4 = [];
    this._globalUpdateRequested = this.layerView.hasTilingEffects || !this.useProgressiveUpdate, this._tileStrategy.tiles.forEach((t) => e4.push(this._enqueueTileFetch(t))), await E(e4);
  }
};
e([d()], V.prototype, "_fetchQueue", void 0), e([d()], V.prototype, "_globalUpdateRequested", void 0), e([d()], V.prototype, "attached", void 0), e([d()], V.prototype, "container", void 0), e([d()], V.prototype, "layer", void 0), e([d()], V.prototype, "layerView", void 0), e([d()], V.prototype, "type", void 0), e([d()], V.prototype, "useWebGLForProcessing", null), e([d()], V.prototype, "useProgressiveUpdate", null), e([d()], V.prototype, "timeExtent", void 0), e([d()], V.prototype, "updating", null), V = e([n("esri.views.2d.layers.imagery.BaseImageryTileSubView2D")], V);

// node_modules/@arcgis/core/views/2d/layers/imagery/ImageryTileView2D.js
var l4 = class extends V {
  constructor() {
    super(...arguments), this.container = null, this.layer = null, this.type = "raster";
  }
  attach() {
    super.attach(), this.container = new n2(this._tileInfoView), this.container.isCustomTilingScheme = this._isCustomTilingScheme;
  }
  detach() {
    super.detach(), this.container.removeAllChildren(), this.container = null;
  }
  canUseWebGLForProcessing() {
    return this.useWebGLForProcessing && this.layer.symbolizer.canRenderInWebGL && !("majority" === this.layer.interpolation && r4(this.layer));
  }
  fetchTile(e4, r6) {
    return this.layer.fetchTile(e4.level, e4.row, e4.col, r6);
  }
  async updateTileSource(e4, t) {
    const { bandIds: s4 } = this.layer, i5 = this._getLayerInterpolation(), o3 = this.canUseWebGLForProcessing(), { source: a, globalSymbolizerParams: l5, suspended: n5, coords: c2, resolution: p3 } = t, u5 = this.layerView.hasTilingEffects ? l5 : t.symbolizerParams, { bitmap: m4 } = e4;
    if ([m4.x, m4.y] = c2, m4.resolution = p3, a && r(a) && r(a.pixelBlock)) {
      const e5 = { extent: a.extent, pixelBlock: a.pixelBlock };
      if (m4.rawPixelData = e5, o3)
        m4.source = a.pixelBlock, m4.isRendereredSource = false;
      else {
        const r6 = await this.layer.applyRenderer(e5, "stretch" === (l5 == null ? void 0 : l5.type) ? l5 : null);
        m4.source = r6, m4.isRendereredSource = true;
      }
      m4.symbolizerParameters = o3 ? u5 : null, o3 ? m4.transformGrid || (m4.transformGrid = a.transformGrid) : m4.transformGrid = null;
    } else {
      const e5 = this.createEmptyTilePixelBlock();
      m4.source = e5, m4.symbolizerParameters = o3 ? u5 : null, m4.transformGrid = null;
    }
    m4.bandIds = o3 ? s4 : null, m4.width = this._tileInfoView.tileInfo.size[0], m4.height = this._tileInfoView.tileInfo.size[1], m4.interpolation = i5, m4.suspended = n5, m4.invalidateTexture();
  }
  async updateTileSymbolizerParameters(e4, t) {
    const { local: s4, global: i5 } = t, { bandIds: o3 } = this.layer, a = this._getLayerInterpolation(), l5 = this.canUseWebGLForProcessing(), { bitmap: n5 } = e4, { rawPixelData: c2 } = n5;
    !l5 && r(c2) ? (n5.source = await this.layer.applyRenderer(c2, "stretch" === (i5 == null ? void 0 : i5.type) ? i5 : null), n5.isRendereredSource = true) : (n5.isRendereredSource && r(c2) && (n5.source = c2.pixelBlock), n5.isRendereredSource = false), n5.symbolizerParameters = l5 ? this.layerView.hasTilingEffects ? i5 : s4 : null, n5.bandIds = l5 ? o3 : null, n5.interpolation = a, n5.suspended = false;
  }
  _getLayerInterpolation() {
    const e4 = this.layer.renderer.type;
    if ("raster-colormap" === e4 || "unique-value" === e4 || "class-breaks" === e4)
      return "nearest";
    const { interpolation: r6 } = this.layer, { renderer: t } = this.layer;
    return "raster-stretch" === t.type && null != t.colorRamp ? "bilinear" === r6 || "cubic" === r6 ? "bilinear" : "nearest" : r6;
  }
};
e([d()], l4.prototype, "container", void 0), e([d()], l4.prototype, "layer", void 0), e([d()], l4.prototype, "type", void 0), l4 = e([n("esri.views.2d.layers.imagery.ImageryTileView2D")], l4);
var n3 = l4;

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFTile.js
var r5 = class extends r3 {
  constructor(t, s4, e4, i5, r6, o3 = null) {
    super(t, s4, e4, i5, r6), this.tileData = new y(o3), this.tileData.coordScale = [i5, r6], this.tileData.once("isReady", () => this.ready());
  }
  destroy() {
    super.destroy(), this.tileData.destroy(), this.tileData = null, this.stage = null;
  }
  set stencilRef(t) {
    this.tileData.stencilRef = t;
  }
  get stencilRef() {
    return this.tileData.stencilRef;
  }
  _createTransforms() {
    return { dvs: e3(), tileMat3: e3() };
  }
  setTransform(e4, a) {
    super.setTransform(e4, a);
    const i5 = a / (e4.resolution * e4.pixelRatio), r6 = this.transforms.tileMat3, [o3, l5] = this.tileData.offset, h3 = [this.x + o3 * a, this.y - l5 * a], [n5, f2] = e4.toScreenNoRotation([0, 0], h3), { symbolTileSize: m4 } = this.tileData.symbolizerParameters, c2 = Math.round((this.width - this.tileData.offset[0]) / m4) * m4, D = Math.round((this.height - this.tileData.offset[1]) / m4) * m4, d4 = c2 / this.rangeX * i5, u5 = D / this.rangeY * i5;
    s2(r6, d4, 0, 0, 0, u5, 0, n5, f2, 1), i(this.transforms.dvs, e4.displayViewMat3, r6), this.tileData.transforms.dvs = this.transforms.dvs;
  }
  onAttach() {
    this.tileData.stage = this.stage;
  }
  onDetach() {
    this.tileData.stage = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFTileContainer.js
var o2 = class extends o {
  constructor() {
    super(...arguments), this.isCustomTilingScheme = false, this.symbolTypes = ["triangle"];
  }
  createTile(s4) {
    const t = this._tileInfoView.getTileBounds(u(), s4), [i5, o3] = this._tileInfoView.tileInfo.size;
    return new r5(s4, t[0], t[3], i5, o3);
  }
  prepareRenderPasses(e4) {
    const r6 = e4.registerRenderPass({ name: "imagery (vf tile)", brushes: [m], target: () => this.children.map((e5) => e5.tileData), drawPhase: I.MAP });
    return [...super.prepareRenderPasses(e4), r6];
  }
  doRender(e4) {
    this.visible && e4.drawPhase === I.MAP && this.symbolTypes.forEach((s4) => {
      e4.renderPass = s4, super.doRender(e4);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/imagery/VectorFieldTileView2D.js
var c = class extends V {
  constructor() {
    super(...arguments), this._handle = null, this.container = null, this.layer = null, this.type = "rasterVF";
  }
  canUseWebGLForProcessing() {
    return false;
  }
  async fetchTile(e4, t) {
    t = { ...t, interpolation: "nearest", requestProjectedLocalDirections: true };
    const i5 = await this.layer.fetchTile(e4.level, e4.row, e4.col, t);
    return "vector-magdir" === this.layer.rasterInfo.dataType && (i5 == null ? void 0 : i5.pixelBlock) && (i5.pixelBlock = await this.layer.convertVectorFieldData(i5.pixelBlock, t)), i5;
  }
  updateTileSource(e4, i5) {
    const r6 = i5.symbolizerParams, { tileData: o3 } = e4;
    o3.key = e4.key, o3.width = this._tileInfoView.tileInfo.size[0], o3.height = this._tileInfoView.tileInfo.size[1];
    const { symbolTileSize: s4 } = r6, { source: l5 } = i5;
    if (o3.offset = this._getTileSymbolOffset(o3.key, s4), r(l5) && r(l5.pixelBlock)) {
      const e5 = { extent: l5.extent, pixelBlock: l5.pixelBlock };
      o3.rawPixelData = e5, o3.symbolizerParameters = r6, o3.source = this._sampleVectorFieldData(l5.pixelBlock, r6, o3.offset);
    } else {
      const e5 = [Math.round((this._tileInfoView.tileInfo[0] - o3.offset[0]) / s4), Math.round((this._tileInfoView.tileInfo[1] - o3.offset[1]) / s4)], t = this.createEmptyTilePixelBlock(e5);
      o3.source = t, o3.symbolizerParameters = r6;
    }
    return o3.invalidateVAO(), Promise.resolve(null);
  }
  updateTileSymbolizerParameters(e4, i5) {
    var _a;
    const r6 = i5.local, { symbolTileSize: o3 } = r6, { tileData: s4 } = e4;
    s4.offset = this._getTileSymbolOffset(s4.key, o3);
    const l5 = s4.symbolizerParameters.symbolTileSize;
    return s4.symbolizerParameters = r6, r((_a = s4.rawPixelData) == null ? void 0 : _a.pixelBlock) && l5 !== o3 && (s4.source = this._sampleVectorFieldData(s4.rawPixelData.pixelBlock, s4.symbolizerParameters, s4.offset)), Promise.resolve(null);
  }
  attach() {
    super.attach(), this.container = new o2(this._tileInfoView), this.container.isCustomTilingScheme = this._isCustomTilingScheme, this._updateSymbolType(this.layer.renderer), this._handle = l(() => this.layer.renderer, (e4) => this._updateSymbolType(e4));
  }
  detach() {
    super.detach(), this.container.removeAllChildren(), this._handle.remove(), this._handle = null;
  }
  _getTileSymbolOffset(e4, t) {
    const i5 = e4.col * this._tileInfoView.tileInfo.size[0] % t, r6 = e4.row * this._tileInfoView.tileInfo.size[1] % t;
    return [i5 > t / 2 ? t - i5 : -i5, r6 > t / 2 ? t - r6 : -r6];
  }
  _sampleVectorFieldData(e4, t, i5) {
    const { symbolTileSize: r6 } = t;
    return F(e4, "vector-uv", r6, i5);
  }
  _updateSymbolType(e4) {
    "vector-field" === e4.type && (this.container.symbolTypes = "wind-barb" === e4.style ? ["scalar", "triangle"] : "simple-scalar" === e4.style ? ["scalar"] : ["triangle"]);
  }
};
e([d()], c.prototype, "container", void 0), e([d()], c.prototype, "layer", void 0), e([d()], c.prototype, "type", void 0), c = e([n("esri.views.2d.layers.imagery.VectorFieldTileView2D")], c);
var n4 = c;

// node_modules/@arcgis/core/views/2d/layers/ImageryTileLayerView2D.js
var m3 = s.getLogger("esri.views.2d.layers.ImageryTileLayerView2D");
var y2 = class extends m2(i3(f(u4))) {
  constructor() {
    super(...arguments), this._useWebGLForProcessing = true, this._useProgressiveUpdate = true, this.subview = null;
  }
  get useWebGLForProcessing() {
    return this._useWebGLForProcessing;
  }
  set useWebGLForProcessing(e4) {
    this._useWebGLForProcessing = e4, this.subview && "useWebGLForProcessing" in this.subview && (this.subview.useWebGLForProcessing = e4);
  }
  get useProgressiveUpdate() {
    return this._useWebGLForProcessing;
  }
  set useProgressiveUpdate(e4) {
    this._useProgressiveUpdate = e4, this.subview && "useProgressiveUpdate" in this.subview && (this.subview.useProgressiveUpdate = e4);
  }
  update(e4) {
    this.subview.update(e4), this.notifyChange("updating");
  }
  isUpdating() {
    return !this.subview || this.subview.updating;
  }
  attach() {
    this.layer.increaseRasterJobHandlerUsage(), this._updateSubview(), this.handles.add([l(() => {
      const { layer: e4 } = this;
      return { bandIds: e4.bandIds, renderer: e4.renderer, interpolation: e4.interpolation, multidimensionalDefinition: e4.multidimensionalDefinition };
    }, (e4, s4) => {
      var _a, _b;
      const i5 = e4.interpolation !== s4.interpolation && ("majority" === e4.interpolation || "majority" === s4.interpolation) && r4(this.layer), r6 = e4.renderer !== s4.renderer && ((_a = s4.renderer) == null ? void 0 : _a.type) !== ((_b = e4.renderer) == null ? void 0 : _b.type);
      r6 && this._updateSubview();
      const o3 = e4.multidimensionalDefinition !== s4.multidimensionalDefinition || i5 || r6;
      this.subview.redrawOrRefetch(o3).catch((e5) => {
        g(e5) || m3.error(e5);
      }), this.notifyChange("updating");
    }), l(() => this.layer.blendMode ?? "normal", (e4) => {
      this.subview.container.blendMode = e4;
    }, w), l(() => this.layer.effect ?? null, (e4) => {
      this.subview.container.effect = e4;
    }, w), l(() => this.timeExtent, () => {
      this.subview.timeExtent = this.timeExtent, this.subview.redrawOrRefetch(true).catch((e4) => {
        g(e4) || m3.error(e4);
      });
    }, h)], "attach");
  }
  detach() {
    var _a;
    this.handles.remove("attach"), this.layer.decreaseRasterJobHandlerUsage(), this._detachSubview(this.subview), (_a = this.subview) == null ? void 0 : _a.destroy(), this.subview = null;
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.subview.moveEnd();
  }
  async hitTest(e4, i5) {
    return [{ type: "graphic", layer: this.layer, mapPoint: e4, graphic: new g3({ attributes: {}, geometry: e4.clone() }) }];
  }
  doRefresh() {
    return this.subview.doRefresh();
  }
  _updateSubview() {
    var _a;
    const e4 = "vector-field" === this.layer.renderer.type ? "rasterVF" : "flow" === this.layer.renderer.type ? "flow" : "raster";
    if (this.subview) {
      if (this.subview.type === e4)
        return void this._attachSubview(this.subview);
      this._detachSubview(this.subview), (_a = this.subview) == null ? void 0 : _a.destroy(), this.subview = null;
    }
    const { layer: s4 } = this;
    let i5;
    i5 = "rasterVF" === e4 ? new n4({ layer: s4, layerView: this }) : "flow" === e4 ? new d3({ layer: s4, layerView: this }) : new n3({ layer: s4, layerView: this }), "useWebGLForProcessing" in i5 && (i5.useWebGLForProcessing = this._useWebGLForProcessing), "useProgressiveUpdate" in i5 && (i5.useProgressiveUpdate = this._useProgressiveUpdate), "previousLOD" in i5 && (i5.previousLOD = this.subview && "previousLOD" in this.subview && this.subview.previousLOD), this._attachSubview(i5), this.subview = i5, this.requestUpdate();
  }
  _attachSubview(e4) {
    e4 && !e4.attached && (e4.attach(), e4.attached = true, this.container.addChildAt(e4.container, 0), e4.container.blendMode = this.layer.blendMode, e4.container.effect = this.layer.effect);
  }
  _detachSubview(e4) {
    (e4 == null ? void 0 : e4.attached) && (this.container.removeChild(e4.container), e4.detach(), e4.attached = false);
  }
};
e([d()], y2.prototype, "subview", void 0), e([d()], y2.prototype, "useWebGLForProcessing", null), e([d()], y2.prototype, "useProgressiveUpdate", null), y2 = e([n("esri.views.2d.layers.ImageryTileLayerView2D")], y2);
var g4 = y2;
export {
  g4 as default
};
//# sourceMappingURL=ImageryTileLayerView2D-JAPEIAS5.js.map
