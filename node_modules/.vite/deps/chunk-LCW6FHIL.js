import {
  i,
  r,
  s as s2
} from "./chunk-JNXH4TTS.js";
import {
  u
} from "./chunk-56RHM4A6.js";
import {
  c as c2,
  f,
  l,
  s,
  y
} from "./chunk-4PRVTUEZ.js";
import {
  c,
  h
} from "./chunk-VLCG72SW.js";
import {
  R,
  k
} from "./chunk-3NMRL5CR.js";
import {
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/geometry/support/normalizeUtilsSync.js
function p(t2) {
  return _(t2, true);
}
function f2(t2) {
  return _(t2, false);
}
function _(i2, n) {
  if (t(i2))
    return null;
  const p2 = i2.spatialReference, f3 = R(p2), _2 = "toJSON" in i2 ? i2.toJSON() : i2;
  if (!f3)
    return _2;
  const I2 = k(p2) ? 102100 : 4326, g2 = r[I2].maxX, v2 = r[I2].minX;
  if (l(_2))
    return y2(_2, g2, v2);
  if (f(_2))
    return _2.points = _2.points.map((t2) => y2(t2, g2, v2)), _2;
  if (s(_2))
    return d(_2, f3);
  if (c2(_2) || y(_2)) {
    const t2 = c(S, _2), i3 = { xmin: t2[0], ymin: t2[1], xmax: t2[2], ymax: t2[3] }, e = i(i3.xmin, v2) * (2 * g2), h2 = 0 === e ? _2 : s2(_2, e);
    return i3.xmin += e, i3.xmax += e, i3.xmax > g2 ? P(h2, g2, n) : i3.xmin < v2 ? P(h2, v2, n) : h2;
  }
  return _2;
}
function d(t2, i2) {
  if (!i2)
    return t2;
  const s3 = I(t2, i2).map((t3) => t3.extent);
  return s3.length < 2 ? s3[0] || t2 : s3.length > 2 ? (t2.xmin = i2.valid[0], t2.xmax = i2.valid[1], t2) : { rings: s3.map((t3) => [[t3.xmin, t3.ymin], [t3.xmin, t3.ymax], [t3.xmax, t3.ymax], [t3.xmax, t3.ymin], [t3.xmin, t3.ymin]]) };
}
function y2(t2, i2, s3) {
  if (Array.isArray(t2)) {
    const n = t2[0];
    if (n > i2) {
      const s4 = i(n, i2);
      t2[0] = n + s4 * (-2 * i2);
    } else if (n < s3) {
      const i3 = i(n, s3);
      t2[0] = n + i3 * (-2 * s3);
    }
  } else {
    const n = t2.x;
    if (n > i2) {
      const s4 = i(n, i2);
      t2.x += s4 * (-2 * i2);
    } else if (n < s3) {
      const i3 = i(n, s3);
      t2.x += i3 * (-2 * s3);
    }
  }
  return t2;
}
function I(t2, i2) {
  const s3 = [], { ymin: n, ymax: e, xmin: h2, xmax: o } = t2, r2 = t2.xmax - t2.xmin, [u2, m] = i2.valid, { x, frameId: l2 } = g(t2.xmin, i2), { x: c3, frameId: a } = g(t2.xmax, i2), p2 = x === c3 && r2 > 0;
  if (r2 > 2 * m) {
    const t3 = { xmin: h2 < o ? x : c3, ymin: n, xmax: m, ymax: e }, i3 = { xmin: u2, ymin: n, xmax: h2 < o ? c3 : x, ymax: e }, r3 = { xmin: 0, ymin: n, xmax: m, ymax: e }, p3 = { xmin: u2, ymin: n, xmax: 0, ymax: e }, f3 = [], _2 = [];
    v(t3, r3) && f3.push(l2), v(t3, p3) && _2.push(l2), v(i3, r3) && f3.push(a), v(i3, p3) && _2.push(a);
    for (let s4 = l2 + 1; s4 < a; s4++)
      f3.push(s4), _2.push(s4);
    s3.push(new C(t3, [l2]), new C(i3, [a]), new C(r3, f3), new C(p3, _2));
  } else
    x > c3 || p2 ? s3.push(new C({ xmin: x, ymin: n, xmax: m, ymax: e }, [l2]), new C({ xmin: u2, ymin: n, xmax: c3, ymax: e }, [a])) : s3.push(new C({ xmin: x, ymin: n, xmax: c3, ymax: e }, [l2]));
  return s3;
}
function g(t2, i2) {
  const [s3, n] = i2.valid, e = 2 * n;
  let h2, o = 0;
  return t2 > n ? (h2 = Math.ceil(Math.abs(t2 - n) / e), t2 -= h2 * e, o = h2) : t2 < s3 && (h2 = Math.ceil(Math.abs(t2 - s3) / e), t2 += h2 * e, o = -h2), { x: t2, frameId: o };
}
function v(t2, i2) {
  const { xmin: s3, ymin: n, xmax: e, ymax: h2 } = i2;
  return O(t2, s3, n) && O(t2, s3, h2) && O(t2, e, h2) && O(t2, e, n);
}
function O(t2, i2, s3) {
  return i2 >= t2.xmin && i2 <= t2.xmax && s3 >= t2.ymin && s3 <= t2.ymax;
}
function P(t2, i2, s3 = true) {
  const e = !y(t2);
  if (e && h(t2), s3) {
    return new T().cut(t2, i2);
  }
  const h2 = e ? t2.rings : t2.paths, o = e ? 4 : 2, r2 = h2.length, m = -2 * i2;
  for (let n = 0; n < r2; n++) {
    const t3 = h2[n];
    if (t3 && t3.length >= o) {
      const i3 = [];
      for (const s4 of t3)
        i3.push([s4[0] + m, s4[1]]);
      h2.push(i3);
    }
  }
  return e ? t2.rings = h2 : t2.paths = h2, t2;
}
var C = class {
  constructor(t2, i2) {
    this.extent = t2, this.frameIds = i2;
  }
};
var S = u();
var T = class {
  constructor() {
    this.linesIn = [], this.linesOut = [];
  }
  cut(t2, i2) {
    let s3;
    if (this.xCut = i2, t2.rings)
      this.closed = true, s3 = t2.rings, this.minPts = 4;
    else {
      if (!t2.paths)
        return null;
      this.closed = false, s3 = t2.paths, this.minPts = 2;
    }
    for (const e of s3) {
      if (!e || e.length < this.minPts)
        continue;
      let t3 = true;
      for (const i3 of e)
        t3 ? (this.moveTo(i3), t3 = false) : this.lineTo(i3);
      this.closed && this.close();
    }
    this._pushLineIn(), this._pushLineOut(), s3 = [];
    for (const e of this.linesIn)
      e && e.length >= this.minPts && s3.push(e);
    const n = -2 * this.xCut;
    for (const e of this.linesOut)
      if (e && e.length >= this.minPts) {
        for (const t3 of e)
          t3[0] += n;
        s3.push(e);
      }
    return this.closed ? t2.rings = s3 : t2.paths = s3, t2;
  }
  moveTo(t2) {
    this._pushLineIn(), this._pushLineOut(), this._prevSide = this._side(t2[0]), this._moveTo(t2[0], t2[1], this._prevSide), this._prevPt = t2, this._firstPt = t2;
  }
  lineTo(t2) {
    const i2 = this._side(t2[0]);
    if (i2 * this._prevSide == -1) {
      const s3 = this._intersect(this._prevPt, t2);
      this._lineTo(this.xCut, s3, 0), this._prevSide = 0, this._lineTo(t2[0], t2[1], i2);
    } else
      this._lineTo(t2[0], t2[1], i2);
    this._prevSide = i2, this._prevPt = t2;
  }
  close() {
    const t2 = this._firstPt, i2 = this._prevPt;
    t2[0] === i2[0] && t2[1] === i2[1] || this.lineTo(t2), this._checkClosingPt(this.lineIn), this._checkClosingPt(this.lineOut);
  }
  _moveTo(t2, i2, s3) {
    this.closed ? (this.lineIn.push([s3 <= 0 ? t2 : this.xCut, i2]), this.lineOut.push([s3 >= 0 ? t2 : this.xCut, i2])) : (s3 <= 0 && this.lineIn.push([t2, i2]), s3 >= 0 && this.lineOut.push([t2, i2]));
  }
  _lineTo(t2, i2, s3) {
    this.closed ? (this._addPolyVertex(this.lineIn, s3 <= 0 ? t2 : this.xCut, i2), this._addPolyVertex(this.lineOut, s3 >= 0 ? t2 : this.xCut, i2)) : s3 < 0 ? (0 === this._prevSide && this._pushLineOut(), this.lineIn.push([t2, i2])) : s3 > 0 ? (0 === this._prevSide && this._pushLineIn(), this.lineOut.push([t2, i2])) : this._prevSide < 0 ? (this.lineIn.push([t2, i2]), this.lineOut.push([t2, i2])) : this._prevSide > 0 && (this.lineOut.push([t2, i2]), this.lineIn.push([t2, i2]));
  }
  _addPolyVertex(t2, i2, s3) {
    const n = t2.length;
    n > 1 && t2[n - 1][0] === i2 && t2[n - 2][0] === i2 ? t2[n - 1][1] = s3 : t2.push([i2, s3]);
  }
  _checkClosingPt(t2) {
    const i2 = t2.length;
    i2 > 3 && t2[0][0] === this.xCut && t2[i2 - 2][0] === this.xCut && t2[1][0] === this.xCut && (t2[0][1] = t2[i2 - 2][1], t2.pop());
  }
  _side(t2) {
    return t2 < this.xCut ? -1 : t2 > this.xCut ? 1 : 0;
  }
  _intersect(t2, i2) {
    const s3 = (this.xCut - t2[0]) / (i2[0] - t2[0]);
    return t2[1] + s3 * (i2[1] - t2[1]);
  }
  _pushLineIn() {
    this.lineIn && this.lineIn.length >= this.minPts && this.linesIn.push(this.lineIn), this.lineIn = [];
  }
  _pushLineOut() {
    this.lineOut && this.lineOut.length >= this.minPts && this.linesOut.push(this.lineOut), this.lineOut = [];
  }
};

export {
  p,
  f2 as f
};
//# sourceMappingURL=chunk-LCW6FHIL.js.map
