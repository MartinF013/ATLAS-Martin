import {
  d,
  e as e5,
  g,
  i2,
  l
} from "./chunk-WRIKJ4W5.js";
import {
  o as o3
} from "./chunk-7WSRILGC.js";
import {
  t
} from "./chunk-GZ6H7JK2.js";
import {
  e as e3
} from "./chunk-R67CDTDF.js";
import {
  s
} from "./chunk-UCWSHVC4.js";
import {
  o
} from "./chunk-2YDCEMEJ.js";
import {
  e as e4
} from "./chunk-WW7VYUQW.js";
import {
  c
} from "./chunk-DMGVDNFD.js";
import {
  e
} from "./chunk-4MKQUQD4.js";
import {
  o as o2
} from "./chunk-A3QLZKCF.js";
import {
  e as e2
} from "./chunk-LGILR4HN.js";
import {
  i2 as i
} from "./chunk-I5UNY2WQ.js";
import {
  n
} from "./chunk-NAB3NF54.js";
import {
  f
} from "./chunk-AIRC226G.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/engine/imagery/enums.js
var t2;
var e6;
!function(t4) {
  t4[t4.Stretch = 0] = "Stretch", t4[t4.Lut = 1] = "Lut", t4[t4.Hillshade = 2] = "Hillshade", t4[t4.COUNT = 3] = "COUNT";
}(t2 || (t2 = {})), function(t4) {
  t4[t4.Noop = 0] = "Noop", t4[t4.PerBand = 1] = "PerBand", t4[t4.COUNT = 2] = "COUNT";
}(e6 || (e6 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl.js
function l2(l3) {
  l3.fragment.uniforms.add([new c("u_colormap", (o4) => o4.u_colormap), new o2("u_colormapOffset", (o4) => o4.colormap.u_colormapOffset), new o2("u_colormapMaxIndex", (o4) => o4.colormap.u_colormapMaxIndex), new o2("u_opacity", (o4) => o4.common.u_opacity)]), l3.fragment.code.add(n`vec4 colormap(vec4 currentPixel, bool isFloat) {
float clrIndex = isFloat ? currentPixel.r - u_colormapOffset : currentPixel.r * 255.0 - u_colormapOffset;
vec4 result;
if (currentPixel.a == 0.0 || clrIndex > u_colormapMaxIndex) {
result = vec4(0.0, 0.0, 0.0, 0.0);
} else {
vec2 clrPosition = vec2((clrIndex + 0.5) / (u_colormapMaxIndex + 1.0), 0.0);
result = texture2D(u_colormap, clrPosition);
}
return result;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/raster/Projection.glsl.js
function t3(t4) {
  t4.fragment.uniforms.add(new c("u_transformGrid", (r2) => r2.u_transformGrid)), t4.fragment.uniforms.add(new e2("u_transformSpacing", (r2) => r2.common.u_transformSpacing)), t4.fragment.uniforms.add(new e2("u_transformGridSize", (r2) => r2.common.u_transformGridSize)), t4.fragment.uniforms.add(new e2("u_targetImageSize", (r2) => r2.common.u_targetImageSize)), t4.fragment.code.add(n`vec2 projectPixelLocation(vec2 coords) {
vec2 index_image = floor(coords * u_targetImageSize);
vec2 oneTransformPixel = vec2(0.25 / u_transformGridSize.s, 1.0 / u_transformGridSize.t);
vec2 index_transform = floor(index_image / u_transformSpacing) / u_transformGridSize;
vec2 pos = fract((index_image + vec2(0.5, 0.5)) / u_transformSpacing);
vec2 srcLocation;
vec2 transform_location = index_transform + oneTransformPixel * 0.5;
if (pos.s <= pos.t) {
vec4 ll_abc = texture2D(u_transformGrid, vec2(transform_location.s, transform_location.t));
vec4 ll_def = texture2D(u_transformGrid, vec2(transform_location.s + oneTransformPixel.s, transform_location.t));
srcLocation.s = dot(ll_abc.rgb, vec3(pos, 1.0));
srcLocation.t = dot(ll_def.rgb, vec3(pos, 1.0));
} else {
vec4 ur_abc = texture2D(u_transformGrid, vec2(transform_location.s + 2.0 * oneTransformPixel.s, transform_location.t));
vec4 ur_def = texture2D(u_transformGrid, vec2(transform_location.s + 3.0 * oneTransformPixel.s, transform_location.t));
srcLocation.s = dot(ur_abc.rgb, vec3(pos, 1.0));
srcLocation.t = dot(ur_def.rgb, vec3(pos, 1.0));
}
return srcLocation;;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl.js
var i3 = class extends i2 {
  constructor(o4, r2, e7) {
    super(), this.common = o4, this.u_image = r2, this.u_transformGrid = e7;
  }
};
function n2(r2) {
  r2.include(t3), r2.fragment.uniforms.add([new c("u_image", (o4) => o4.u_image), new s("u_flipY", (o4) => o4.common.u_flipY), new s("u_applyTransform", (o4) => o4.common.u_applyTransform)]), r2.fragment.code.add(n`vec2 getPixelLocation(vec2 coords) {
vec2 targetLocation = u_flipY ? vec2(coords.s, 1.0 - coords.t) : coords;
if (!u_applyTransform) {
return targetLocation;
}
return projectPixelLocation(targetLocation);
}
bool isOutside(vec2 coords){
if (coords.t>1.00001 ||coords.t<-0.00001 || coords.s>1.00001 ||coords.s<-0.00001) {
return true;
} else {
return false;
}
}
vec4 getPixel(vec2 pixelLocation) {
return texture2D(u_image, pixelLocation);
}`);
}

// node_modules/@arcgis/core/chunks/RasterColorizer.glsl.js
var w = class extends i3 {
  constructor(e7, o4, r2, l3, i4, t4) {
    super(e7, l3, i4), this.colormap = o4, this.symbolizer = r2, this.u_colormap = t4, this.backgroundColor = f, this.fboTexture = null, this.baseOpacity = 1;
  }
};
var O = class extends w {
};
var z = class extends w {
};
function L(a) {
  const r2 = new i();
  r2.include(d), r2.include(n2), r2.include(l2), a.tileBlendInput === o3.GridComposite && (r2.extensions.add("GL_OES_standard_derivatives"), r2.fragment.include(t));
  const t4 = a.tileBlendInput === o3.ColorComposite;
  t4 && r2.fragment.uniforms.add(new e("backgroundColor", (e7) => e7.backgroundColor)), a.baseOpacityMode !== g.One && r2.fragment.uniforms.add(new o2("baseOpacity", (e7) => e7.baseOpacity));
  const f2 = a.baseOpacityMode === g.OnBaseLayer, g2 = a.baseOpacityMode === g.OnBackground || a.baseOpacityMode === g.OnBaseLayer, p = a.blendMode !== e5.Normal;
  r2.fragment.include(l, a);
  const y = a.tileBlendInput !== o3.LayerOnly;
  return (p && !y || f2) && (r2.fragment.uniforms.add(new c("fboColor", (e7) => e7.fboTexture)), r2.fragment.uniforms.add(new o2("tileSize", (a2) => r(a2.fboTexture) ? a2.fboTexture.descriptor.width : 1))), r2.fragment.code.add(n`
    vec4 applyBackgroundBlend(vec4 layerColor) {
      ${y || f2 ? n`
          vec4 bgColor = ${f2 ? n`texture2D(fboColor, gl_FragCoord.xy / tileSize)` : t4 ? n`vec4(backgroundColor, 1.0)` : n`gridColor(vuv)`};
          ${g2 ? n`bgColor *= baseOpacity;` : ""}` : ""}
      ${p ? n`
            vec3 pmColorLayer = layerColor.rgb * layerColor.a;
            vec4 fboTex = ${y ? n`bgColor;` : n`texture2D(fboColor, gl_FragCoord.xy / tileSize) ${f2 ? " * baseOpacity" : ""};`}
            vec3 Cb = fboTex.a == 0.0 ? fboTex.rgb : vec3(fboTex.rgb * fboTex.a);
            return applyBlendMode(pmColorLayer.rgb, layerColor.a * u_opacity, Cb, fboTex.a);` : y || f2 ? n`
            float composeAlpha = layerColor.a * u_opacity;
            vec4 pmColorLayer = vec4(layerColor.rgb, 1.0);
            return mix(bgColor, pmColorLayer, composeAlpha);` : n`
            return layerColor * layerColor.a * u_opacity;`}
    }
  `), a.colorizerType === t2.Stretch ? B(r2, a) : a.colorizerType === t2.Lut ? P(r2) : a.colorizerType === t2.Hillshade && V(r2, a), r2;
}
function P(e7) {
  e7.fragment.code.add(n`void main() {
vec2 pixelLocation = getPixelLocation(uv);
if (isOutside(pixelLocation)) {
gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));
return;
}
vec4 currentPixel = getPixel(pixelLocation);
gl_FragColor = applyBackgroundBlend(colormap(currentPixel, true));
}`);
}
function B(e7, a) {
  e7.fragment.uniforms.add([new e3("u_bandCount", (e8) => e8.symbolizer.u_bandCount), new o("u_minCutOff", (e8) => e8.symbolizer.u_minCutOff, 3), new o("u_maxCutOff", (e8) => e8.symbolizer.u_maxCutOff, 3), new o("u_factor", (e8) => e8.symbolizer.u_factor, 3), new o2("u_minOutput", (e8) => e8.symbolizer.u_minOutput), new o2("u_maxOutput", (e8) => e8.symbolizer.u_maxOutput), new s("u_useGamma", (e8) => e8.symbolizer.u_useGamma), new o("u_gamma", (e8) => e8.symbolizer.u_gamma, 3), new o("u_gammaCorrection", (e8) => e8.symbolizer.u_gammaCorrection, 3), new o2("u_opacity", (e8) => e8.common.u_opacity)]), e7.fragment.code.add(n`float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {
if (val >= maxCutOff) {
return maxOutput;
} else if (val <= minCutOff) {
return minOutput;
}
float stretchedVal;
if (useGamma) {
float tempf = 1.0;
float outRange = maxOutput - minOutput;
float relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);
if (gamma > 1.0) {
tempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);
}
stretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;
} else {
stretchedVal = minOutput + (val - minCutOff) * factor;
}
return stretchedVal;
}`);
  const o4 = a.applyColormap ? n`gl_FragColor = applyBackgroundBlend(colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma));` : n`gl_FragColor = applyBackgroundBlend(vec4(grayVal, grayVal, grayVal, currentPixel.a));`;
  e7.fragment.code.add(n`
      void main() {
        vec2 pixelLocation = getPixelLocation(uv);
        if (isOutside(pixelLocation)) {
          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));
          return;
        }

        vec4 currentPixel = getPixel(pixelLocation);
        ${a.stretchType === e6.Noop ? n`
        gl_FragColor = applyBackgroundBlend(currentPixel);` : n`
        if (currentPixel.a == 0.0) {
          gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));
          return;
        }
        if (u_bandCount == 1) {
          float grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);
          ${o4}
        } else {
          float redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);
          float greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);
          float blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);
          gl_FragColor = applyBackgroundBlend(vec4(redVal, greenVal, blueVal, currentPixel.a));
        }`}
      }`);
}
function V(e7, a) {
  const o4 = e7.fragment;
  o4.uniforms.add([new c("u_image", (e8) => e8.u_image), new e3("u_hillshadeType", (e8) => e8.symbolizer.u_hillshadeType), new o("u_sinZcosAs", (e8) => e8.symbolizer.u_sinZcosAs, 6), new o("u_sinZsinAs", (e8) => e8.symbolizer.u_sinZsinAs, 6), new o("u_cosZs", (e8) => e8.symbolizer.u_cosZs, 6), new o("u_weights", (e8) => e8.symbolizer.u_weights, 6), new e2("u_factor", (e8) => e8.symbolizer.u_factor), new o2("u_minValue", (e8) => e8.symbolizer.u_minValue), new o2("u_maxValue", (e8) => e8.symbolizer.u_maxValue), new e2("u_srcImageSize", (e8) => e8.common.u_srcImageSize)]), o4.include(e4), o4.code.add(n`vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {
val = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);
vec3 hsv = rgb2hsv(colormap(vec4(val, val, val, 1.0), false).rgb);
hsv.z = hillshade;
return vec4(hsv2rgb(hsv) * alpha, alpha);
}`), o4.code.add(n`float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){
if (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {
return 0.0;
}  else {
return e;
}
}`);
  const r2 = a.applyColormap ? n`gl_FragColor = applyBackgroundBlend(overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha));` : n`hillshade *= alpha;
gl_FragColor = applyBackgroundBlend(vec4(hillshade, hillshade, hillshade, alpha));`;
  o4.code.add(n`
    void main() {
      vec2 pixelLocation = getPixelLocation(uv);
      if (isOutside(pixelLocation)) {
        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));
        return;
      }

      vec4 currentPixel = getPixel(pixelLocation);
      if (currentPixel.a == 0.0) {
        gl_FragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));
        return;
      }

      //mirror edge pixels
      vec2 axy = vec2(-1.0, -1.0);
      vec2 bxy = vec2(0.0, -1.0);
      vec2 cxy = vec2(1.0, -1.0);
      vec2 dxy = vec2(-1.0, 0.0);
      vec2 fxy = vec2(1.0, 0.0);
      vec2 gxy = vec2(-1.0, 1.0);
      vec2 hxy = vec2(0.0, 1.0);
      vec2 ixy = vec2(1.0, 1.0);
      vec2 onePixel = 1.0 / u_srcImageSize;
      if (pixelLocation.s < onePixel.s) {
        axy[0] = 1.0;
        dxy[0] = 1.0;
        gxy[0] = 1.0;
      }
      if (pixelLocation.t < onePixel.t) {
        axy[1] = 1.0;
        bxy[1] = 1.0;
        cxy[1] = 1.0;
      }
      if (pixelLocation.s > 1.0 - onePixel.s) {
        cxy[0] = -1.0;
        fxy[0] = -1.0;
        ixy[0] = -1.0;
      }
      if (pixelLocation.t > 1.0 - onePixel.t) {
        gxy[1] = -1.0;
        hxy[1] = -1.0;
        ixy[1] = -1.0;
      }

      // calculate hillshade
      vec4 va = texture2D(u_image, pixelLocation + onePixel * axy);
      vec4 vb = texture2D(u_image, pixelLocation + onePixel * bxy);
      vec4 vc = texture2D(u_image, pixelLocation + onePixel * cxy);
      vec4 vd = texture2D(u_image, pixelLocation + onePixel * dxy);
      vec4 ve = texture2D(u_image, pixelLocation);
      vec4 vf = texture2D(u_image, pixelLocation + onePixel * fxy);
      vec4 vg = texture2D(u_image, pixelLocation + onePixel * gxy);
      vec4 vh = texture2D(u_image, pixelLocation + onePixel * hxy);
      vec4 vi = texture2D(u_image, pixelLocation + onePixel * ixy);

      // calculate the rate of z change along the x, y, and diagonal direction
      float dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;
      float dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;
      float dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);
      float hillshade = 0.0;

      // traditional single light source
      if (u_hillshadeType == 0){
        float cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;
        float z = (u_cosZs[0] + cosDelta) / dzd;
        if (z < 0.0)  z = 0.0;
        hillshade = z;
      } else {
        // multi-directional with 6 light sources
        for (int k = 0; k < 6; k++) {
        float cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;
        float z = (u_cosZs[k] + cosDelta) / dzd;
        if (z < 0.0) z = 0.0;
        hillshade = hillshade + z * u_weights[k];
        if (k == 5) break;
        }
      }

      // set color
      float alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);
      alpha *= u_opacity;
      ${r2}
    }
  `);
}
var k = Object.freeze(Object.defineProperty({ __proto__: null, ColorizerUniforms: w, ColorizerStretchUniforms: O, ColorizerHillshadeUniforms: z, build: L }, Symbol.toStringTag, { value: "Module" }));

export {
  t2 as t,
  e6 as e,
  w,
  O,
  z,
  L,
  k
};
//# sourceMappingURL=chunk-FK4VVO2E.js.map
