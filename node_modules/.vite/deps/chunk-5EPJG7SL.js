import {
  n
} from "./chunk-J73IXFNW.js";
import {
  x
} from "./chunk-RIOXX6J2.js";
import {
  f
} from "./chunk-VLCG72SW.js";

// node_modules/@arcgis/core/geometry/support/triangulationUtils.js
function o(t) {
  const o2 = l(t.rings, t.hasZ, c.CCW_IS_HOLE), s2 = [];
  let i2 = 0, h = 0;
  for (const e of o2.polygons) {
    const t2 = e.count, r2 = e.index, l2 = new Float64Array(o2.position.buffer, 3 * r2 * o2.position.BYTES_PER_ELEMENT, 3 * t2), c2 = e.holeIndices.map((n2) => n2 - r2), f3 = new Uint32Array(x(l2, c2, 3));
    s2.push({ position: l2, faces: f3 }), i2 += l2.length, h += f3.length;
  }
  const f2 = r(s2, i2, h), a = n(f2.position.buffer, 6, { originalIndices: f2.faces });
  return f2.position = new Float64Array(a.buffer), f2.faces = a.indices, f2;
}
function r(n2, t, e) {
  if (1 === n2.length)
    return n2[0];
  const o2 = new Float64Array(t), r2 = new Uint32Array(e);
  let l2 = 0, s2 = 0, i2 = 0;
  for (const c2 of n2) {
    for (let n3 = 0; n3 < c2.position.length; n3++)
      o2[l2++] = c2.position[n3];
    for (let n3 = 0; n3 < c2.faces.length; n3++)
      r2[s2++] = c2.faces[n3] + i2;
    i2 = l2 / 3;
  }
  return { position: o2, faces: r2 };
}
function l(n2, t, e) {
  const o2 = n2.length, r2 = new Array(o2), l2 = new Array(o2), h = new Array(o2);
  let f2 = 0, a = 0, g = 0, u = 0;
  for (let s2 = 0; s2 < o2; ++s2)
    u += n2[s2].length;
  const p = new Float64Array(3 * u);
  let d = 0;
  for (let y = o2 - 1; y >= 0; y--) {
    const u2 = n2[y], w = e === c.CCW_IS_HOLE && i(u2);
    if (w && 1 !== o2)
      r2[f2++] = u2;
    else {
      let n3 = u2.length;
      for (let t2 = 0; t2 < f2; ++t2)
        n3 += r2[t2].length;
      const e2 = { index: d, pathLengths: new Array(f2 + 1), count: n3, holeIndices: new Array(f2) };
      e2.pathLengths[0] = u2.length, u2.length > 0 && (h[g++] = { index: d, count: u2.length }), d = w ? s(u2, u2.length - 1, -1, p, d, u2.length, t) : s(u2, 0, 1, p, d, u2.length, t);
      for (let o3 = 0; o3 < f2; ++o3) {
        const n4 = r2[o3];
        e2.holeIndices[o3] = d, e2.pathLengths[o3 + 1] = n4.length, n4.length > 0 && (h[g++] = { index: d, count: n4.length }), d = s(n4, 0, 1, p, d, n4.length, t);
      }
      f2 = 0, e2.count > 0 && (l2[a++] = e2);
    }
  }
  for (let i2 = 0; i2 < f2; ++i2) {
    const n3 = r2[i2];
    n3.length > 0 && (h[g++] = { index: d, count: n3.length }), d = s(n3, 0, 1, p, d, n3.length, t);
  }
  return a < o2 && (l2.length = a), g < o2 && (h.length = g), { position: p, polygons: l2, outlines: h };
}
function s(n2, t, e, o2, r2, l2, s2) {
  r2 *= 3;
  for (let i2 = 0; i2 < l2; ++i2) {
    const l3 = n2[t];
    o2[r2++] = l3[0], o2[r2++] = l3[1], o2[r2++] = s2 ? l3[2] : 0, t += e;
  }
  return r2 / 3;
}
function i(n2) {
  return !f(n2, false, false);
}
var c;
!function(n2) {
  n2[n2.NONE = 0] = "NONE", n2[n2.CCW_IS_HOLE = 1] = "CCW_IS_HOLE";
}(c || (c = {}));

export {
  o,
  l,
  c
};
//# sourceMappingURL=chunk-5EPJG7SL.js.map
