import {
  t as t4
} from "./chunk-DQPH5EKZ.js";
import {
  f as f6
} from "./chunk-LCW6FHIL.js";
import {
  K as K2,
  S as S2,
  c as c5,
  d as d3,
  g as g3,
  h as h2,
  p,
  u as u4,
  y as y3
} from "./chunk-WKUIJCRG.js";
import {
  c as c4,
  i as i3,
  o as o2
} from "./chunk-2HUXPKKU.js";
import {
  o
} from "./chunk-HHJIVHSH.js";
import {
  E as E3,
  e as e4,
  l as l5,
  l2 as l6,
  x
} from "./chunk-6UTST6NO.js";
import {
  n as n3
} from "./chunk-BYHUWBKS.js";
import {
  Q,
  j2 as j,
  n as n2,
  q as q2
} from "./chunk-436X6OVY.js";
import {
  U as U3
} from "./chunk-UKBGUXUQ.js";
import {
  R as R3,
  d as d2,
  r as r4
} from "./chunk-SNC4BDIX.js";
import {
  G,
  K,
  W,
  X as X2,
  ae,
  ge,
  he,
  ie as ie2,
  se
} from "./chunk-UGLXR5OV.js";
import {
  S
} from "./chunk-6FQZDXGD.js";
import {
  A
} from "./chunk-ZUKXZSOF.js";
import {
  U as U2
} from "./chunk-HH3D3A65.js";
import {
  f as f3,
  g as g2
} from "./chunk-XZHFGTRH.js";
import {
  i as i2
} from "./chunk-ZIAGZEFK.js";
import {
  a as a3
} from "./chunk-RVR2DEVB.js";
import {
  f as f5
} from "./chunk-FUKESVWQ.js";
import {
  c as c3
} from "./chunk-T3KDRLPE.js";
import {
  C,
  E as E2,
  F,
  I,
  R as R2
} from "./chunk-FPMD6IB4.js";
import {
  r as r3
} from "./chunk-MLAOYRDT.js";
import {
  O,
  U
} from "./chunk-Z7BSDVJ3.js";
import {
  e as e5
} from "./chunk-MEW2XKT2.js";
import {
  t as t3
} from "./chunk-RB3LJE4I.js";
import {
  l as l4
} from "./chunk-6EODZIDR.js";
import {
  M,
  f as f4,
  h,
  i,
  r as r2
} from "./chunk-3NPGGTI6.js";
import {
  $,
  L,
  X,
  fe,
  ie
} from "./chunk-6SWQ7R36.js";
import {
  t as t2
} from "./chunk-OZT6RDST.js";
import {
  z
} from "./chunk-4I3W4KD5.js";
import {
  N,
  O as O2,
  j as j2
} from "./chunk-6O2ARNGD.js";
import {
  a as a2
} from "./chunk-JJRJ6TV3.js";
import {
  l as l2
} from "./chunk-T7BEWVV3.js";
import {
  E,
  e as e3,
  l as l3,
  q,
  s as s2,
  u as u3
} from "./chunk-56RHM4A6.js";
import {
  u as u2
} from "./chunk-NWRK6QLX.js";
import {
  c as c2,
  f as f2,
  l,
  s,
  v,
  y as y2
} from "./chunk-4PRVTUEZ.js";
import {
  c,
  e as e2,
  u
} from "./chunk-VLCG72SW.js";
import {
  R,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  f,
  g,
  w
} from "./chunk-U3PSONS6.js";
import {
  a,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/DirtyMap.js
var t5 = -1;
var e6 = class {
  constructor() {
    this._dirties = [{ vertexFrom: t5, vertexCount: t5, indexFrom: t5, indexCount: t5, allDirty: false }, { vertexFrom: t5, vertexCount: t5, indexFrom: t5, indexCount: t5, allDirty: false }, { vertexFrom: t5, vertexCount: t5, indexFrom: t5, indexCount: t5, allDirty: false }, { vertexFrom: t5, vertexCount: t5, indexFrom: t5, indexCount: t5, allDirty: false }, { vertexFrom: t5, vertexCount: t5, indexFrom: t5, indexCount: t5, allDirty: false }];
  }
  hasDirty() {
    return this._dirties.some((e12) => e12.indexCount !== t5 || e12.allDirty);
  }
  markAllClean() {
    for (const e12 of this._dirties)
      e12.indexFrom = t5, e12.indexCount = t5, e12.vertexFrom = t5, e12.vertexCount = t5, e12.allDirty = false;
  }
  markAllDirty() {
    for (const t11 of this._dirties)
      t11.allDirty = true;
  }
  forEach(e12) {
    for (let r8 = 0; r8 < this._dirties.length; ++r8) {
      const { indexCount: i5, indexFrom: o7, vertexCount: n7, vertexFrom: x4, allDirty: l8 } = this._dirties[r8], s6 = {};
      let d7, m = false;
      (l8 || x4 !== t5 && n7 > 0) && (s6.geometry = { count: n7, from: x4, allDirty: l8 }, m = true), (l8 || o7 !== t5 && i5 > 0) && (d7 = { count: i5, from: o7, allDirty: l8 }, m = true), m && e12({ indices: d7, vertices: s6 }, r8);
    }
  }
  markDirtyIndices(e12, r8, i5) {
    const o7 = this._dirties[e12], n7 = r8, x4 = i5;
    if (!o7.allDirty)
      if (o7.indexCount !== t5) {
        const t11 = Math.min(o7.indexFrom, n7), e13 = Math.max(o7.indexFrom + o7.indexCount, n7 + x4) - t11;
        o7.indexFrom = t11, o7.indexCount = e13;
      } else
        o7.indexFrom = n7, o7.indexCount = x4;
  }
  markDirtyVertices(e12, r8, i5, o7) {
    const n7 = this._dirties[e12], x4 = i5, l8 = o7;
    if (!n7.allDirty)
      if (n7.vertexCount !== t5) {
        const t11 = Math.min(n7.vertexFrom, x4), e13 = Math.max(n7.vertexFrom + n7.vertexCount, x4 + l8) - t11;
        n7.vertexFrom = t11, n7.vertexCount = e13;
      } else
        n7.vertexFrom = x4, n7.vertexCount = l8;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FreeList.js
var e7 = class {
  constructor(e12) {
    this._largestRange = null, this._parent = e12, this._updateLargestRange();
  }
  get largestRange() {
    return this._largestRange;
  }
  rangeCreated(e12) {
    (!this._largestRange || e12.count > this._largestRange.count) && (this._largestRange = e12);
  }
  rangeResized(e12, t11) {
    e12 === this._largestRange ? e12.count < t11 && this._updateLargestRange() : (!this._largestRange || e12.count > this._largestRange.count) && (this._largestRange = e12);
  }
  findBestRange(e12) {
    let t11 = this._parent._freeHead, n7 = null;
    for (; null !== t11; )
      t11.count >= e12 && (!n7 || t11.count - e12 < n7.count - e12) && (n7 = t11), t11 = t11.next;
    return n7;
  }
  findAdjacentRanges(e12, t11) {
    let n7 = true, r8 = false, s6 = null, o7 = this._parent._freeHead;
    for (; n7 && !r8; ) {
      const a5 = null !== s6 ? s6.from + s6.count : 0, l8 = null !== o7 ? o7.from : this._parent._size;
      e12 >= a5 && e12 + t11 <= l8 ? (n7 = false, r8 = true) : null !== o7 ? (s6 = o7, o7 = o7.next) : n7 = false;
    }
    return [s6, o7];
  }
  _updateLargestRange() {
    let e12 = null, t11 = this._parent._freeHead;
    for (; null !== t11; )
      (!e12 || t11.count > e12.count) && (e12 = t11), t11 = t11.next;
    this._largestRange = e12;
  }
};
var t6 = class {
  constructor(t11, n7) {
    this._allocated = 0, this._size = t11, this._freeHead = t11 > 0 ? { from: 0, count: t11, prev: null, next: null } : null, this._bookKeeper = n7 || new e7(this), this._freeHead && this._bookKeeper.rangeCreated(this._freeHead);
  }
  allocate(e12) {
    const n7 = this._bookKeeper.findBestRange(e12);
    if (null === n7)
      return -1;
    const r8 = n7.from, s6 = n7.count;
    if (n7.from += e12, n7.count -= e12, this._bookKeeper.rangeResized(n7, r8, s6), this._allocated += e12, 0 === n7.count) {
      const e13 = null !== n7.prev ? this._freeHead : n7.next;
      t6._removeRange(n7), this._freeHead = e13;
    }
    return r8;
  }
  free(e12, n7) {
    const [r8, s6] = this._bookKeeper.findAdjacentRanges(e12, n7), o7 = { from: e12, count: n7, prev: r8, next: s6 };
    if (null !== r8 && (r8.next = o7), null !== s6 && (s6.prev = o7), this._bookKeeper.rangeCreated(o7), this._allocated -= n7, null !== s6 && o7.from + o7.count === s6.from) {
      const e13 = o7.from, n8 = o7.count;
      t6._fuse(o7, s6), t6._removeRange(s6), this._bookKeeper.rangeResized(o7, e13, n8), this._bookKeeper.rangeResized(s6, void 0, 0);
    }
    if (null !== r8 && r8.from + r8.count === o7.from) {
      const e13 = r8.from, n8 = r8.count;
      t6._fuse(r8, o7), t6._removeRange(o7), this._bookKeeper.rangeResized(r8, e13, n8), this._bookKeeper.rangeResized(o7, void 0, 0);
    }
    this._freeHead = null !== o7.prev ? this._freeHead : o7;
  }
  get fragmentation() {
    const e12 = this._size - this._allocated;
    if (0 === e12)
      return 0;
    return 1 - this._bookKeeper.largestRange.count / e12;
  }
  static _removeRange(e12) {
    null !== e12.prev ? null !== e12.next ? (e12.prev.next = e12.next, e12.next.prev = e12.prev) : e12.prev.next = null : null !== e12.next && (e12.next.prev = null);
  }
  static _fuse(e12, t11) {
    e12.count += t11.count, e12.next = t11.next, t11.from += t11.count, t11.count = 0, null !== t11.next && (t11.next.prev = e12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayRecordStore.js
var s3 = ["FILL", "LINE", "MARKER", "TEXT", "LABEL"];
function o3(e12) {
  const t11 = e12.getStrides(), r8 = {};
  for (let i5 = 0; i5 < t11.length; i5++)
    r8[s3[i5]] = t11[i5];
  return r8;
}
var n4 = 0.5;
var d4 = class {
  constructor(r8, i5, s6, o7) {
    this._strides = r8, this._displayList = i5, this._freeListsAndStorage = {}, this._dirtyMap = null, this._dirtyMap = s6;
    for (const n7 in r8) {
      this._freeListsAndStorage[n7] = { vtxFreeList: o7 ? new t6(o7) : null, idxFreeList: o7 ? new t6(o7) : null, vertexBuffers: {}, indexBuffer: o7 ? new Uint32Array(o7) : null };
      for (const e12 in r8[n7])
        this._freeListsAndStorage[n7].vertexBuffers[e12] = { data: o7 ? K(o7, r8[n7][e12]) : null, stride: r8[n7][e12] };
    }
  }
  static fromTileData(t11, i5) {
    const n7 = o3(t11), a5 = [0, 0, 0, 0, 0], x4 = [0, 0, 0, 0, 0], u5 = t11.tileDisplayData.displayObjects;
    for (const e12 of u5)
      for (const t12 of e12.displayRecords)
        a5[t12.geometryType] = Math.max(a5[t12.geometryType], t12.vertexFrom + t12.vertexCount), x4[t12.geometryType] = Math.max(x4[t12.geometryType], t12.indexFrom + t12.indexCount);
    const f11 = new d4(n7, t11.tileDisplayData.displayList, i5, null);
    for (let o7 = 0; o7 < t11.tileBufferData.geometries.length; ++o7) {
      const i6 = a5[o7], n8 = x4[o7], d7 = t11.tileBufferData.geometries[o7], u6 = s3[o7], l8 = f11._storageFor(u6), c6 = t11.tileBufferData.geometries[o7].indexBuffer;
      let m;
      l8.indexBuffer = c6, l8.idxFreeList = new t6(c6.length), l8.idxFreeList.allocate(n8);
      for (const e12 in d7.vertexBuffer) {
        const i7 = t11.tileBufferData.geometries[o7].vertexBuffer[e12];
        l8.vertexBuffers[e12].data = i7.data, l8.vertexBuffers[e12].stride = i7.stride;
        const s6 = X2(i7.stride), n9 = i7.data.length * s6 / i7.stride;
        m || (m = n9);
      }
      l8.vtxFreeList = new t6(m), l8.vtxFreeList.allocate(i6);
    }
    return f11;
  }
  delete(e12) {
    const t11 = s3[e12.geometryType];
    this._freeVertices(t11, e12.vertexFrom, e12.vertexCount), this._freeIndices(t11, e12.indexFrom, e12.indexCount), this._displayList.removeFromList(e12), e12.vertexFrom = void 0, e12.indexFrom = void 0;
  }
  setMeshData(e12, t11, r8, o7, n7) {
    const d7 = s3[e12.geometryType];
    let a5, x4;
    e12.meshData = null, void 0 === e12.vertexFrom ? (x4 = t11.vertexCount, a5 = this._allocateVertices(d7, x4)) : t11.vertexCount > e12.vertexCount ? (this._freeVertices(d7, e12.vertexFrom, e12.vertexCount), x4 = t11.vertexCount, a5 = this._allocateVertices(d7, x4)) : t11.vertexCount === e12.vertexCount ? (a5 = e12.vertexFrom, x4 = e12.vertexCount) : (this._freeVertices(d7, e12.vertexFrom + t11.vertexCount, e12.vertexCount - t11.vertexCount), a5 = e12.vertexFrom, x4 = t11.vertexCount);
    let u5, f11, l8, c6 = true;
    if (void 0 === e12.indexFrom ? (u5 = n7, l8 = t11.indexCount, f11 = this._allocateIndices(d7, l8)) : t11.indexCount > e12.indexCount ? (u5 = this._displayList.removeFromList(e12), this._freeIndices(d7, e12.indexFrom, e12.indexCount), l8 = t11.indexCount, f11 = this._allocateIndices(d7, l8)) : t11.indexCount === e12.indexCount ? (c6 = false, f11 = e12.indexFrom, l8 = e12.indexCount) : (u5 = this._displayList.removeFromList(e12), this._freeIndices(d7, e12.indexFrom + t11.indexCount, e12.indexCount - t11.indexCount), f11 = e12.indexFrom, l8 = t11.indexCount), -1 !== a5 && -1 !== f11) {
      const s6 = this._storageFor(d7);
      if (ae(a5, f11, s6.vertexBuffers, s6.indexBuffer, t11, r8, o7), e12.vertexFrom = a5, e12.indexFrom = f11, e12.vertexCount = t11.vertexCount, e12.indexCount = t11.indexCount, this._dirtyMap) {
        this._dirtyMap.markDirtyIndices(e12.geometryType, e12.indexFrom, e12.indexCount);
        for (const t12 in r8)
          this._dirtyMap.markDirtyVertices(e12.geometryType, t12, e12.vertexFrom, e12.vertexCount);
      }
      return c6 && this._displayList.addToList(e12, u5), true;
    }
    return -1 !== a5 && this._freeVertices(d7, a5, x4), -1 !== f11 && this._freeIndices(d7, f11, l8), e12.setMeshDataFromBuffers(t11, r8, o7), e12.vertexFrom = void 0, e12.vertexCount = 0, e12.indexFrom = void 0, e12.indexCount = 0, false;
  }
  tryAddMeshData(e12, t11) {
    const r8 = t11.vertexBuffer, o7 = t11.indexBuffer, n7 = s3[e12.geometryType], d7 = this._allocateVertices(n7, e12.vertexCount);
    if (-1 === d7)
      return this._freeVertices(n7, d7, e12.vertexCount), false;
    const a5 = this._allocateIndices(n7, e12.indexCount);
    if (-1 === a5)
      return this._freeVertices(n7, d7, e12.vertexCount), this._freeIndices(n7, a5, e12.indexCount), false;
    const x4 = this._storageFor(n7);
    if (ae(d7, a5, x4.vertexBuffers, x4.indexBuffer, e12, r8, o7), e12.vertexFrom = d7, e12.indexFrom = a5, this._dirtyMap) {
      this._dirtyMap.markDirtyIndices(e12.geometryType, e12.indexFrom, e12.indexCount);
      for (const t12 in r8)
        this._dirtyMap.markDirtyVertices(e12.geometryType, t12, d7, e12.vertexCount);
    }
    return this._displayList.addToList(e12), true;
  }
  _allocateVertices(e12, t11) {
    const r8 = this._storageFor(e12), i5 = r8.vtxFreeList.allocate(t11);
    if (-1 === i5)
      return -1;
    return r8.vtxFreeList.fragmentation > n4 ? -1 : i5;
  }
  _freeVertices(e12, t11, r8) {
    this._storageFor(e12).vtxFreeList.free(t11, r8);
  }
  _freeIndices(e12, t11, r8) {
    this._storageFor(e12).idxFreeList.free(t11, r8);
  }
  _allocateIndices(e12, t11) {
    const r8 = this._storageFor(e12), i5 = r8.idxFreeList.allocate(t11);
    if (-1 === i5)
      return -1;
    return r8.idxFreeList.fragmentation > n4 ? -1 : i5;
  }
  _storageFor(e12) {
    return this._freeListsAndStorage[e12];
  }
  _stridesFor(e12, t11) {
    return this._strides[e12][t11];
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLBuffers.js
var f7 = class {
  constructor(a5) {
    this.geometryMap = ie2(() => ({ indexBuffer: c3.createIndex(a5, F.STATIC_DRAW), vao: null }), (e12, s6) => ({ vertexBuffer: c3.createVertex(a5, se[s6]) }));
  }
  dispose() {
    for (let e12 = 0; e12 < 5; e12++) {
      const t11 = this.geometryMap[e12];
      if (t11) {
        t11.data.vao && t11.data.vao.dispose(false), t11.data.indexBuffer && t11.data.indexBuffer.dispose();
        for (const e13 in t11.buffers)
          t11.buffers[e13] && t11.buffers[e13].data.vertexBuffer.dispose();
      }
    }
  }
  get(e12) {
    const t11 = this.geometryMap[e12];
    return { getVAO(e13, r8, s6) {
      if (!t11.data.vao) {
        const f11 = {};
        for (const e14 in t11.buffers)
          f11[e14] = t11.buffers[e14].data.vertexBuffer;
        t11.data.vao = new f5(e13, s6, r8, f11, t11.data.indexBuffer);
      }
      return t11.data.vao;
    } };
  }
  has(e12) {
    return null != this.geometryMap[e12];
  }
  upload(e12, t11) {
    t11.forEach((t12, r8) => {
      this._upload(t12, r8, e12);
    });
  }
  _upload(e12, t11, r8) {
    if (e12.indices && (e12.indices.allDirty ? this._uploadIndices(r8, t11) : null != e12.indices.from && null != e12.indices.count && this._uploadIndices(r8, t11, e12.indices.from, e12.indices.count)), e12.vertices) {
      const s6 = e12.vertices;
      for (const e13 in s6) {
        const a5 = s6[e13];
        a5.allDirty ? this._uploadVertices(r8, t11, e13) : null != a5.from && null != a5.count && this._uploadVertices(r8, t11, e13, a5.from, a5.count);
      }
    }
  }
  _uploadVertices(e12, t11, r8, s6, a5) {
    const f11 = this.geometryMap[t11];
    if (!f11)
      return;
    const o7 = e12.geometries[t11].vertexBuffer[r8];
    if (!o7)
      return;
    const i5 = o7.stride, n7 = o7.data.buffer;
    f11.buffers[r8] && n7.byteLength > 0 && (null != s6 && null != a5 ? f11.buffers[r8].data.vertexBuffer.setSubData(n7, s6 * i5, s6 * i5, (s6 + a5) * i5) : f11.buffers[r8].data.vertexBuffer.setData(n7));
  }
  _uploadIndices(e12, t11, r8, s6) {
    const a5 = this.geometryMap[t11];
    if (!a5)
      return;
    const f11 = 4, o7 = e12.geometries[t11].indexBuffer.buffer;
    a5.data.indexBuffer && o7.byteLength > 0 && (null != r8 && null != s6 ? a5.data.indexBuffer.setSubData(o7, r8 * f11, r8 * f11, (r8 + s6) * f11) : a5.data.indexBuffer.setData(o7));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicTile.js
var a4 = class extends c4 {
  constructor() {
    super(...arguments), this._data = null, this._displayList = null, this._lastCommitTime = 0, this._hasData = false, this._invalidated = false, this._wglBuffers = null, this._dirtyMap = new e6();
  }
  destroy() {
    super.destroy(), this.clear();
  }
  get hasData() {
    return !!this._hasData;
  }
  get displayObjects() {
    return this._displayObjects ?? [];
  }
  getGeometry(t11) {
    return this._wglBuffers && this._wglBuffers.has(t11) ? this._wglBuffers.get(t11) : null;
  }
  getDisplayList() {
    return this._displayList;
  }
  patch(e12) {
    if (true === e12.clear)
      return this.clear(), void (this._hasData = false);
    const i5 = e12.addOrUpdate, a5 = e12.remove;
    !this._data && i5 && i5.tileDisplayData.displayObjects.length ? (i5.tileDisplayData.computeDisplayList(), this._dirtyMap = new e6(), this._dispRecStore = d4.fromTileData(i5, this._dirtyMap), this._data = i5, this._dirtyMap.markAllDirty(), this._hasData = true, e12.end && this.ready()) : this._data && (i5 && i5.tileDisplayData.displayObjects.length || a5.length) ? this._doPatchData(e12) : e12.end && this.ready(), e12.end && !this._data && this.clear(), this.requestRender(), this.emit("change");
  }
  commit(t11) {
    t11.time && t11.time === this._lastCommitTime || (this._lastCommitTime = t11.time, this.visible && this._data && (this._wglBuffers || (this._wglBuffers = new f7(t11.context)), (this._dirtyMap.hasDirty() || this._invalidated) && (this._invalidated = false, this._wglBuffers.upload(this._data.tileBufferData, this._dirtyMap), this._displayList = this._data.tileDisplayData.displayList.clone(), this._displayObjects = this._data.tileDisplayData.displayObjects.slice(), this._dirtyMap.markAllClean())));
  }
  clear() {
    this._data = null, this._displayList = null, this._dispRecStore = null, this._wglBuffers && (this._wglBuffers.dispose(), this._wglBuffers = null);
  }
  _doPatchData(t11) {
    this._invalidated = true, this._patchData(t11) || (this._dirtyMap.markAllDirty(), this._data.reshuffle(), this._dispRecStore = d4.fromTileData(this._data, this._dirtyMap)), this.requestRender();
  }
  _patchData(t11) {
    let s6 = true;
    const e12 = t11.addOrUpdate && t11.addOrUpdate.tileDisplayData && t11.addOrUpdate.tileDisplayData.displayObjects || [], i5 = (t11.remove || []).slice();
    for (const a5 of e12)
      null != a5.insertAfter && i5.push(a5.id);
    for (const a5 of i5) {
      const t12 = this._data.tileDisplayData.displayObjectRegistry.get(a5);
      if (t12) {
        this._data.tileDisplayData.displayList.removeFromList(t12.displayRecords);
        for (const e13 of t12.displayRecords)
          this._dispRecStore.delete(e13);
        this._data.tileDisplayData.displayObjectRegistry.delete(a5);
        const s7 = this._data.tileDisplayData.displayObjects.indexOf(t12);
        this._data.tileDisplayData.displayObjects.splice(s7, 1);
      }
    }
    for (const a5 of e12) {
      let e13, i6 = this._data.tileDisplayData.displayObjectRegistry.get(a5.id);
      if (i6) {
        const t12 = i6.displayRecords;
        i6.set(a5), i6.displayRecords = t12;
        const s7 = i6.displayRecords.length;
        for (let e14 = 0; e14 < s7; ++e14) {
          const t13 = i6.displayRecords[e14], s8 = a5.displayRecords[e14];
          (e14 >= a5.displayRecords.length || t13.geometryType !== s8.geometryType || t13.symbolLevel !== s8.symbolLevel || t13.zOrder !== s8.zOrder || t13.materialKey !== s8.materialKey) && (this._dispRecStore.delete(i6.displayRecords[e14]), e14 < a5.displayRecords.length && (i6.displayRecords[e14] = void 0));
        }
        i6.displayRecords.length = a5.displayRecords.length;
      } else {
        let t12;
        i6 = a5.copy(), i6.displayRecords = [], this._data.tileDisplayData.displayObjectRegistry.set(a5.id, i6);
        const s7 = this._data.tileDisplayData.displayObjects;
        if (null != i6.insertAfter)
          if (e13 = {}, i6.insertAfter >= 0) {
            const e14 = this._data.tileDisplayData.displayObjectRegistry.get(i6.insertAfter);
            e14 ? (t12 = s7.indexOf(e14) + 1, t12 < s7.length ? s7.splice(t12, 0, i6) : (s7.push(i6), t12 = s7.length)) : (s7.push(i6), t12 = s7.length);
          } else
            s7.unshift(i6), t12 = 0;
        else
          s7.push(i6), t12 = s7.length;
        if (e13) {
          const i7 = a5.displayRecords.length > 0 ? 1 : 0;
          let l9 = 0;
          for (let a6 = t12 - 1; a6 >= 0 && l9 < i7; --a6)
            for (let t13 = s7[a6].displayRecords.length - 1; t13 >= 0 && l9 < i7; --t13) {
              const i8 = s7[a6].displayRecords[t13], d7 = this._data.tileDisplayData.displayList.getDPInfoType();
              e13[d7] || (e13[d7] = i8, ++l9);
            }
        }
      }
      const l8 = a5.displayRecords.length;
      for (let d7 = 0; d7 < l8; ++d7) {
        const l9 = a5.displayRecords[d7];
        let r8 = i6.displayRecords[d7];
        r8 ? (r8.meshData = l9.meshData, r8.materialKey = l9.materialKey) : (r8 = l9.copy(), r8.vertexFrom = void 0, r8.indexFrom = void 0, i6.displayRecords[d7] = r8);
        const p3 = l9.geometryType, h4 = this._data.tileDisplayData.displayList.getDPInfoType(), o7 = t11.addOrUpdate.tileBufferData.geometries[p3], y7 = o7.vertexBuffer, c6 = o7.indexBuffer;
        let n7;
        e13 && (n7 = e13[h4] ? this._data.tileDisplayData.displayList.splitAfter(e13[h4]) : -1), s6 = this._dispRecStore.setMeshData(r8, l9, y7, c6, n7) && s6, e13 && null != r8.indexFrom && null != r8.indexFrom && (e13[h4] = r8);
      }
    }
    return s6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MemoryRequirements.js
var e8 = class {
  constructor() {
    this._byGeometryType = null;
  }
  get satisfied() {
    return !this._byGeometryType;
  }
  reset() {
    this._byGeometryType = null;
  }
  verticesFor(e12) {
    return this._byGeometryType ? this._byGeometryType[e12].vertices : 0;
  }
  indicesFor(e12) {
    return this._byGeometryType ? this._byGeometryType[e12].indices : 0;
  }
  needMore(e12, t11, i5) {
    if (!t11 && !i5)
      return;
    this._byGeometryType || (this._byGeometryType = [{ vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }]);
    const s6 = this._byGeometryType[e12];
    s6.vertices += t11, s6.indices += i5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileBufferData.js
var r5 = 5;
var f8 = class {
  constructor() {
    this.geometries = [{ indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }];
  }
  clone() {
    const e12 = new f8();
    for (let r8 = 0; r8 < this.geometries.length; r8++) {
      const f11 = this.geometries[r8], t11 = e12.geometries[r8];
      t11.indexBuffer = f11.indexBuffer.slice(), t11.vertexBuffer = {};
      for (const e13 in f11.vertexBuffer) {
        const { data: r9, stride: i5 } = f11.vertexBuffer[e13];
        t11.vertexBuffer[e13] = { data: r9.slice(), stride: i5 };
      }
    }
    return e12;
  }
  static deserialize(t11) {
    const i5 = new f8();
    for (let f11 = 0; f11 < r5; ++f11) {
      i5.geometries[f11].indexBuffer = new Uint32Array(t11.geometries[f11].indexBuffer), i5.geometries[f11].vertexBuffer = {};
      for (const r8 in t11.geometries[f11].vertexBuffer)
        i5.geometries[f11].vertexBuffer[r8] = { data: W(t11.geometries[f11].vertexBuffer[r8].data, t11.geometries[f11].vertexBuffer[r8].stride), stride: t11.geometries[f11].vertexBuffer[r8].stride };
    }
    return i5;
  }
  serialize() {
    const e12 = { geometries: [{ indexBuffer: this.geometries[0].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[1].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[2].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[3].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[4].indexBuffer.buffer, vertexBuffer: {} }] };
    for (let f11 = 0; f11 < r5; ++f11)
      for (const r8 in this.geometries[f11].vertexBuffer)
        e12.geometries[f11].vertexBuffer[r8] = { data: this.geometries[f11].vertexBuffer[r8].data.buffer, stride: this.geometries[f11].vertexBuffer[r8].stride };
    return e12;
  }
  getBuffers() {
    const e12 = [];
    for (let f11 = 0; f11 < r5; ++f11) {
      e12.push(this.geometries[f11].indexBuffer.buffer);
      for (const r8 in this.geometries[f11].vertexBuffer)
        e12.push(this.geometries[f11].vertexBuffer[r8].data.buffer);
    }
    return e12;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicDisplayList.js
function t7(e12, t11, n7, ...o7) {
  t11 < e12.length ? e12.splice(t11, n7, ...o7) : e12.push(...o7);
}
var n5 = class {
  constructor() {
    this.symbolLevels = [];
  }
  replay(t11, n7, o7) {
    for (const i5 of this.symbolLevels)
      for (const r8 of i5.zLevels) {
        const i6 = r8.geometryDPInfo.unified;
        if (i6)
          for (const r9 of i6) {
            const { geometryType: i7, materialKey: l8, indexFrom: s6, indexCount: m } = r9, y7 = U3.load(l8).symbologyType, d7 = t11.painter.getBrush(i7, y7), u5 = { geometryType: i7, materialKey: l8, indexFrom: s6, indexCount: m, target: n7.getGeometry(i7) };
            d7.prepareState(t11, n7), d7.drawGeometry(t11, n7, u5, o7);
          }
      }
  }
  get empty() {
    return !this.symbolLevels || 0 === this.symbolLevels.length;
  }
  clear() {
    this.symbolLevels.length = 0;
  }
  addToList(e12, t11) {
    if (Array.isArray(e12))
      for (const n7 of e12)
        this._addToList(n7, t11);
    else
      this._addToList(e12, t11);
  }
  removeFromList(e12) {
    Array.isArray(e12) || (e12 = [e12]);
    let t11 = null;
    for (const n7 of e12)
      t11 = this._removeFromList(n7);
    return t11;
  }
  clone() {
    const e12 = new n5();
    for (const t11 of this.symbolLevels)
      e12.symbolLevels.push(t11.clone());
    return e12;
  }
  splitAfter(e12) {
    const t11 = this._getDisplayList(e12.symbolLevel, e12.zOrder), n7 = t11.length, i5 = e12.indexFrom + e12.indexCount;
    for (let r8 = 0; r8 < n7; ++r8) {
      const n8 = t11[r8];
      if (n8.geometryType === e12.geometryType && i5 > n8.indexFrom && i5 <= n8.indexFrom + n8.indexCount) {
        if (i5 < n8.indexFrom + n8.indexCount) {
          const e13 = new o4();
          e13.geometryType = n8.geometryType, e13.materialKey = n8.materialKey, e13.indexFrom = i5, e13.indexCount = n8.indexFrom + n8.indexCount - i5, t11.splice(r8 + 1, 0, e13), n8.indexCount = i5 - n8.indexFrom;
        }
        return r8;
      }
    }
  }
  _addToList(e12, n7) {
    const i5 = e12.symbolLevel, r8 = e12.zOrder, l8 = this._getDisplayList(i5, r8), s6 = null != n7 ? n7 : l8.length - 1, m = s6 >= 0 && s6 < l8.length ? l8[s6] : null;
    if (null !== m && m.materialKey === e12.materialKey && m.indexFrom + m.indexCount === e12.indexFrom && m.geometryType === e12.geometryType)
      m.indexCount += e12.indexCount;
    else {
      const n8 = new o4();
      n8.indexFrom = e12.indexFrom, n8.indexCount = e12.indexCount, n8.materialKey = e12.materialKey, n8.geometryType = e12.geometryType, t7(l8, s6 + 1, 0, n8);
    }
  }
  _removeFromList(e12) {
    const n7 = e12.symbolLevel, i5 = e12.zOrder, r8 = this._getDisplayList(n7, i5), l8 = r8.length;
    let s6;
    for (let t11 = 0; t11 < l8; ++t11) {
      const n8 = r8[t11];
      if (e12.indexFrom + e12.indexCount > n8.indexFrom && e12.indexFrom < n8.indexFrom + n8.indexCount && n8.geometryType === e12.geometryType) {
        s6 = t11;
        break;
      }
    }
    if (void 0 !== s6) {
      const n8 = r8[s6];
      if (e12.indexFrom === n8.indexFrom)
        return n8.indexCount -= e12.indexCount, n8.indexFrom += e12.indexCount, 0 === n8.indexCount && t7(r8, s6, 1), s6 - 1;
      if (e12.indexFrom + e12.indexCount === n8.indexFrom + n8.indexCount)
        return n8.indexCount -= e12.indexCount, 0 === n8.indexCount ? (t7(r8, s6, 1), s6 - 1) : s6;
      {
        const i6 = n8.indexFrom, l9 = e12.indexFrom - n8.indexFrom, m = e12.indexCount, y7 = n8.indexFrom + n8.indexCount - (e12.indexFrom + e12.indexCount);
        n8.indexCount = l9;
        const d7 = new o4();
        return d7.geometryType = n8.geometryType, d7.materialKey = n8.materialKey, d7.indexFrom = i6 + l9 + m, d7.indexCount = y7, t7(r8, s6 + 1, 0, d7), s6;
      }
    }
    return null;
  }
  _getDisplayList(e12, t11) {
    let n7;
    const o7 = this.symbolLevels.length;
    for (let i5 = 0; i5 < o7; i5++)
      if (this.symbolLevels[i5].symbolLevel === e12) {
        n7 = this.symbolLevels[i5];
        break;
      }
    let s6;
    n7 || (n7 = new l7(), n7.symbolLevel = e12, this.symbolLevels.push(n7));
    const m = n7.zLevels.length;
    for (let i5 = 0; i5 < m; i5++)
      if (n7.zLevels[i5].zLevel === t11) {
        s6 = n7.zLevels[i5];
        break;
      }
    return s6 || (s6 = new r6(), s6.geometryDPInfo = new i4(), s6.zLevel = t11, n7.zLevels.push(s6)), s6.geometryDPInfo.unified || (s6.geometryDPInfo.unified = []), s6.geometryDPInfo.unified;
  }
  getDPInfoType() {
    return "unified";
  }
};
var o4 = class {
  constructor() {
    this.materialKey = null, this.indexFrom = 0, this.indexCount = 0;
  }
  clone() {
    const e12 = new o4();
    return e12.geometryType = this.geometryType, e12.materialKey = this.materialKey, e12.indexFrom = this.indexFrom, e12.indexCount = this.indexCount, e12;
  }
};
var i4 = class {
  constructor() {
    this.fill = null, this.line = null, this.marker = null, this.text = null, this.label = null, this.unified = null;
  }
  clone() {
    const e12 = new i4();
    return e12.fill = this.fill && this.fill.map((e13) => e13.clone()), e12.line = this.line && this.line.map((e13) => e13.clone()), e12.marker = this.marker && this.marker.map((e13) => e13.clone()), e12.text = this.text && this.text.map((e13) => e13.clone()), e12.label = this.label && this.label.map((e13) => e13.clone()), e12.unified = this.unified && this.unified.map((e13) => e13.clone()), e12;
  }
};
var r6 = class {
  constructor() {
    this.geometryDPInfo = new i4();
  }
  clone() {
    const e12 = new r6();
    return e12.zLevel = this.zLevel, e12.geometryDPInfo = this.geometryDPInfo.clone(), e12;
  }
};
var l7 = class {
  constructor() {
    this.zLevels = [];
  }
  clone() {
    const e12 = new l7();
    e12.symbolLevel = this.symbolLevel;
    for (const t11 of this.zLevels)
      e12.zLevels.push(t11.clone());
    return e12;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MeshData.js
var t8 = class {
  constructor() {
    this.vertexData = /* @__PURE__ */ new Map(), this.vertexCount = 0, this.indexData = [];
  }
  clear() {
    this.vertexData.clear(), this.vertexCount = 0, this.indexData = [];
  }
  update(t11, e12, a5) {
    for (const s6 in t11)
      this.vertexData.set(s6, t11[s6]);
    for (const s6 in this.vertexData)
      null === t11[s6] && this.vertexData.delete(s6);
    this.vertexCount = e12, this.indexData = a5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayRecord.js
var s4 = class {
  constructor(t11, e12, s6, r8 = 0, i5 = 0) {
    this.id = t11, this.geometryType = e12, this.materialKey = s6, this.minZoom = r8, this.maxZoom = i5, this.meshData = null, this.symbolLevel = 0, this.zOrder = 0, this.vertexFrom = 0, this.vertexCount = 0, this.indexFrom = 0, this.indexCount = 0;
  }
  get sortKey() {
    return void 0 === this._sortKey && this._computeSortKey(), this._sortKey;
  }
  clone() {
    return this.copy();
  }
  copy() {
    const t11 = new s4(this.id, this.geometryType, this.materialKey);
    return t11.vertexFrom = this.vertexFrom, t11.vertexCount = this.vertexCount, t11.indexFrom = this.indexFrom, t11.indexCount = this.indexCount, t11.zOrder = this.zOrder, t11.symbolLevel = this.symbolLevel, t11.meshData = this.meshData, t11.minZoom = this.minZoom, t11.maxZoom = this.maxZoom, t11;
  }
  setMeshDataFromBuffers(s6, r8, i5) {
    const o7 = new t8();
    for (const t11 in r8) {
      const i6 = r8[t11].stride, a5 = r8[t11].data, h4 = [], n7 = X2(i6);
      for (let t12 = 0; t12 < i6 * s6.vertexCount / n7; ++t12)
        h4[t12] = a5[t12 + i6 * s6.vertexFrom / n7];
      o7.vertexData.set(t11, h4);
    }
    o7.indexData.length = 0;
    for (let t11 = 0; t11 < s6.indexCount; ++t11)
      o7.indexData[t11] = i5[t11 + s6.indexFrom] - s6.vertexFrom;
    o7.vertexCount = s6.vertexCount, this.meshData = o7;
  }
  readMeshDataFromBuffers(s6, r8) {
    this.meshData ? this.meshData.clear() : this.meshData = new t8();
    for (const t11 in s6) {
      const r9 = s6[t11].stride, i5 = s6[t11].data, o7 = [], a5 = X2(r9);
      for (let t12 = 0; t12 < r9 * this.vertexCount / a5; ++t12)
        o7[t12] = i5[t12 + r9 * this.vertexFrom / a5];
      this.meshData.vertexData.set(t11, o7);
    }
    this.meshData.indexData.length = 0;
    for (let t11 = 0; t11 < this.indexCount; ++t11)
      this.meshData.indexData[t11] = r8[t11 + this.indexFrom] - this.vertexFrom;
    this.meshData.vertexCount = this.vertexCount;
  }
  writeMeshDataToBuffers(t11, s6, r8, i5) {
    for (const o7 in s6) {
      const r9 = s6[o7].stride, i6 = this.meshData.vertexData.get(o7), a5 = s6[o7].data, h4 = X2(r9);
      for (let e12 = 0; e12 < r9 * this.meshData.vertexCount / h4; ++e12)
        a5[e12 + r9 * t11 / h4] = i6[e12];
    }
    for (let e12 = 0; e12 < this.meshData.indexData.length; ++e12)
      i5[e12 + r8] = this.meshData.indexData[e12] + t11;
    this.vertexFrom = t11, this.vertexCount = this.meshData.vertexCount, this.indexFrom = r8, this.indexCount = this.meshData.indexData.length;
  }
  static writeAllMeshDataToBuffers(t11, e12, s6) {
    let r8 = 0, i5 = 0;
    for (const o7 of t11)
      o7.writeMeshDataToBuffers(r8, e12, i5, s6), r8 += o7.vertexCount, i5 += o7.indexCount;
  }
  _computeSortKey() {
    this._sortKey = (31 & this.symbolLevel) << 12 | (127 & this.zOrder) << 4 | 7 & this.geometryType;
  }
  serialize(t11) {
    return t11.push(this.geometryType), t11.push(this.materialKey), t11.push(this.vertexFrom), t11.push(this.vertexCount), t11.push(this.indexFrom), t11.push(this.indexCount), t11.push(this.minZoom), t11.push(this.maxZoom), t11;
  }
  static deserialize(t11, e12) {
    const r8 = t11.readInt32(), i5 = t11.readInt32(), o7 = new s4(e12.id, r8, i5);
    return o7.vertexFrom = t11.readInt32(), o7.vertexCount = t11.readInt32(), o7.indexFrom = t11.readInt32(), o7.indexCount = t11.readInt32(), o7.minZoom = t11.readInt32(), o7.maxZoom = t11.readInt32(), o7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js
function e9(e12, n7) {
  if (null !== n7) {
    e12.push(n7.length);
    for (const r8 of n7)
      r8.serialize(e12);
    return e12;
  }
  e12.push(0);
}
function n6(e12, n7, r8) {
  const t11 = e12.readInt32(), o7 = new Array(t11);
  for (let i5 = 0; i5 < o7.length; i5++)
    o7[i5] = n7.deserialize(e12, r8);
  return o7;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayObject.js
var e10 = class {
  constructor(s6) {
    this.insertAfter = null, this.id = s6, this.displayRecords = [];
  }
  copy() {
    const s6 = new e10(this.id);
    return s6.set(this), s6;
  }
  clone() {
    const s6 = new e10(this.id);
    return s6.displayRecords = this.displayRecords.map((s7) => s7.clone()), s6.insertAfter = this.insertAfter, s6;
  }
  set(s6) {
    this.id = s6.id, this.displayRecords = s6.displayRecords, this.insertAfter = s6.insertAfter;
  }
  serialize(s6) {
    return s6.push(this.id), e9(s6, this.displayRecords), s6;
  }
  static deserialize(i5) {
    const r8 = i5.readInt32(), d7 = new e10(r8), o7 = { id: r8 };
    return d7.displayRecords = n6(i5, s4, o7), d7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileDisplayData.js
var e11 = class {
  get displayObjectRegistry() {
    if (!this._displayObjectRegistry) {
      this._displayObjectRegistry = /* @__PURE__ */ new Map();
      for (const s6 of this.displayObjects)
        this._displayObjectRegistry.set(s6.id, s6);
    }
    return this._displayObjectRegistry;
  }
  get displayList() {
    return this._displayList;
  }
  computeDisplayList() {
    this._displayList = new n5();
    for (const s6 of this.displayObjects)
      for (const t11 of s6.displayRecords)
        this._displayList.addToList(t11);
  }
  clone() {
    const s6 = new e11();
    return this.displayObjects && (s6.displayObjects = this.displayObjects.map((s7) => s7.clone())), s6;
  }
  serialize(s6) {
    return e9(s6, this.displayObjects), s6;
  }
  _deserializeObjects(s6) {
    const i5 = s6.readInt32(), e12 = new Array(i5), a5 = /* @__PURE__ */ new Map();
    for (let l8 = 0; l8 < e12.length; ++l8) {
      const i6 = e10.deserialize(s6);
      e12[l8] = i6, a5.set(i6.id, i6);
    }
    this.displayObjects = e12, this._displayList = null, this._displayObjectRegistry = a5;
  }
  static deserialize(s6) {
    const t11 = new e11();
    return t11._deserializeObjects(s6), t11;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexBuffer.js
var t9 = class {
  constructor(e12, t11) {
    this.data = e12, this.stride = t11;
  }
  static decode(r8) {
    const s6 = W(r8.data, r8.stride), n7 = r8.stride;
    return new t9(s6, n7);
  }
  static fromVertexVector(r8) {
    const s6 = W(r8.data.buffer(), r8.stride), n7 = r8.stride;
    return new t9(s6, n7);
  }
};
var r7 = class {
  constructor(e12, t11, r8) {
    this.geometryType = e12, this.indexBuffer = new Uint32Array(t11), this.namedBuffers = r8;
  }
  static decode(e12) {
    const s6 = e12.geometryType, n7 = e12.indexBuffer, o7 = {};
    for (const r8 in e12.namedBuffers)
      o7[r8] = t9.decode(e12.namedBuffers[r8]);
    return new r7(s6, n7, o7);
  }
  static fromVertexData(s6, n7) {
    const o7 = s6.indices, c6 = W(s6.vertices, s6.stride), i5 = s6.stride, d7 = { geometry: new t9(c6, i5) };
    return new r7(n7, o7, d7);
  }
  static fromVertexVectors(e12) {
    const s6 = e12.geometryType, n7 = e12.indexVector.buffer(), o7 = {};
    for (const r8 in e12.namedVectors)
      o7[r8] = t9.fromVertexVector(e12.namedVectors[r8]);
    return new r7(s6, n7, o7);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexVector.js
var s5 = class {
  constructor(t11, e12) {
    this.data = t11, this.stride = e12;
  }
  get vertexCount() {
    const t11 = this.stride / 4, e12 = this.data.length / t11;
    return e12 !== (0 | e12) && console.debug("Corrupted stride"), e12;
  }
  transfer(t11, e12) {
    const r8 = this.data.buffer();
    t11.vertexCount = this.vertexCount, t11.data = r8, t11.stride = this.stride, e12.push(r8);
  }
};
var o5 = class {
  constructor(e12, o7, n7) {
    this.geometryType = e12, this.indexVector = new e4(Uint32Array, 6 * o7), this.namedVectors = {};
    const i5 = G(e12, n7);
    for (const t11 in i5) {
      const e13 = i5[t11];
      let n8;
      switch (e13 % 4) {
        case 0:
        case 2:
          n8 = new e4(Uint32Array, e13 * o7);
          break;
        case 1:
        case 3:
          n8 = new e4(Uint8Array, e13 * o7);
      }
      this.namedVectors[t11] = new s5(n8, e13);
    }
  }
  get(t11) {
    return this.namedVectors[t11].data;
  }
  getVector(t11) {
    return this.namedVectors[t11];
  }
  transfer(t11, e12) {
    const r8 = this.indexVector.buffer(), s6 = {};
    e12.push(r8);
    for (const o7 in this.namedVectors) {
      const t12 = this.namedVectors[o7];
      s6[o7] = {}, t12.transfer(s6[o7], e12);
    }
    t11.geometryType = this.geometryType, t11.indexBuffer = r8, t11.namedBuffers = s6, this.destroy();
  }
  intoBuffers() {
    const t11 = r7.fromVertexVectors(this);
    return this.destroy(), t11;
  }
  destroy() {
    this.indexVector = null, this.namedVectors = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileData.js
var D = new e8();
var d5 = new e8();
var p2 = 1.5;
var h3 = 5;
function x2(e12, t11) {
  const r8 = {};
  for (const s6 in e12) {
    const i5 = { data: K(t11, e12[s6]), stride: e12[s6] };
    r8[s6] = i5;
  }
  return r8;
}
function y4(e12) {
  return [e12.fill || {}, e12.line || {}, e12.icon || {}, e12.text || {}, e12.label || {}];
}
function B(e12) {
  const t11 = [[], [], [], [], []], r8 = e12;
  for (const s6 of r8)
    for (const e13 of s6.displayRecords)
      t11[e13.geometryType].push(e13);
  return t11;
}
var g4 = class {
  constructor() {
    this.tileDisplayData = null, this.tileBufferData = null;
  }
  reshuffle() {
    D.reset();
    const e12 = B(this.tileDisplayData.displayObjects);
    for (const s6 of e12)
      for (const e13 of s6)
        e13 && D.needMore(e13.geometryType, e13.meshData ? e13.meshData.vertexCount : e13.vertexCount, e13.meshData ? e13.meshData.indexData.length : e13.indexCount);
    const t11 = e12.length, r8 = new f8();
    for (let s6 = 0; s6 < t11; ++s6) {
      r8.geometries[s6].indexBuffer = new Uint32Array(Math.round(p2 * D.indicesFor(s6)));
      const e13 = [];
      for (const r9 in this.tileBufferData.geometries[s6].vertexBuffer)
        e13.push(this.tileBufferData.geometries[s6].vertexBuffer[r9].stride);
      const t12 = g4._computeVertexAlignment(e13), i5 = Math.round(p2 * D.verticesFor(s6)), a5 = g4._align(i5, t12);
      for (const f11 in this.tileBufferData.geometries[s6].vertexBuffer) {
        const e14 = this.tileBufferData.geometries[s6].vertexBuffer[f11].stride;
        r8.geometries[s6].vertexBuffer[f11] = { stride: e14, data: K(a5, e14) };
      }
    }
    d5.reset(), this.tileDisplayData.displayList.clear();
    for (let s6 = 0; s6 < t11; ++s6) {
      const t12 = e12[s6];
      for (const e13 of t12) {
        if (e13.meshData)
          e13.writeMeshDataToBuffers(d5.verticesFor(s6), r8.geometries[s6].vertexBuffer, d5.indicesFor(s6), r8.geometries[s6].indexBuffer), e13.meshData = null;
        else {
          const t13 = this.tileBufferData.geometries[s6].vertexBuffer, i5 = this.tileBufferData.geometries[s6].indexBuffer, o7 = r8.geometries[s6].vertexBuffer, f11 = r8.geometries[s6].indexBuffer, n7 = d5.verticesFor(s6), l8 = d5.indicesFor(s6);
          ae(n7, l8, o7, f11, e13, t13, i5), e13.vertexFrom = n7, e13.indexFrom = l8;
        }
        d5.needMore(s6, e13.vertexCount, e13.indexCount);
      }
    }
    for (const s6 of this.tileDisplayData.displayObjects)
      this.tileDisplayData.displayList.addToList(s6.displayRecords);
    this.tileBufferData = r8;
  }
  getStrides() {
    const e12 = [];
    for (let t11 = 0; t11 < this.tileBufferData.geometries.length; ++t11) {
      const r8 = this.tileBufferData.geometries[t11];
      e12[t11] = {};
      for (const s6 in r8.vertexBuffer)
        e12[t11][s6] = r8.vertexBuffer[s6].stride;
    }
    return e12;
  }
  clone() {
    const e12 = new g4();
    return e12.tileBufferData = this.tileBufferData.clone(), e12.tileDisplayData = this.tileDisplayData.clone(), e12;
  }
  _guessSize() {
    const { displayObjects: e12 } = this.tileDisplayData, t11 = Math.min(e12.length, 4), r8 = 12, s6 = 40;
    let i5 = 0;
    for (let o7 = 0; o7 < t11; o7++)
      i5 = Math.max(i5, e12[o7].displayRecords.length);
    return 2 * (e12.length * r8 + e12.length * i5 * s6);
  }
  serialize() {
    const e12 = this.tileBufferData.serialize(), t11 = this.tileBufferData.getBuffers(), r8 = this.tileDisplayData.serialize(new e4(Int32Array, this._guessSize())).buffer();
    return t11.push(r8), { result: { displayData: r8, bufferData: e12 }, transferList: t11 };
  }
  static fromVertexData(r8, s6) {
    const i5 = {}, o7 = /* @__PURE__ */ new Map();
    for (const e12 of s6)
      o7.set(e12.id, e12);
    return he((s7) => {
      const a5 = r8.data[s7];
      if (r(a5)) {
        const e12 = i3.from(a5.records).getCursor();
        for (; e12.next(); ) {
          const t11 = e12.id, r9 = e12.materialKey, i6 = e12.indexFrom, a6 = e12.indexCount, f11 = e12.vertexFrom, l8 = e12.vertexCount, u5 = o7.get(t11), c6 = new s4(t11, s7, r9);
          c6.indexFrom = i6, c6.indexCount = a6, c6.vertexFrom = f11, c6.vertexCount = l8, u5.displayRecords.push(c6);
        }
        i5[s7] = r7.fromVertexData(a5, s7);
      } else
        i5[s7] = new o5(s7, 0, S.DEFAULT).intoBuffers();
    }), g4.fromMeshData({ displayObjects: s6, vertexBuffersMap: i5 });
  }
  static fromMeshData(e12) {
    const t11 = new g4(), r8 = new e11(), o7 = new f8();
    r8.displayObjects = e12.displayObjects;
    for (const s6 in e12.vertexBuffersMap) {
      const t12 = e12.vertexBuffersMap[s6];
      o7.geometries[s6].indexBuffer = t12.indexBuffer, o7.geometries[s6].vertexBuffer = t12.namedBuffers;
    }
    return t11.tileDisplayData = r8, t11.tileBufferData = o7, t11;
  }
  static bind(e12, t11) {
    const r8 = new g4();
    return r8.tileDisplayData = e12, r8.tileBufferData = t11, r8;
  }
  static create(e12, t11) {
    const r8 = new g4();
    r8.tileDisplayData = new e11(), r8.tileDisplayData.displayObjects = e12;
    const o7 = [0, 0, 0, 0, 0], a5 = [0, 0, 0, 0, 0], f11 = [[], [], [], [], []];
    for (const s6 of e12)
      for (const e13 of s6.displayRecords)
        f11[e13.geometryType].push(e13), o7[e13.geometryType] += e13.meshData.vertexCount, a5[e13.geometryType] += e13.meshData.indexData.length;
    const l8 = new f8(), u5 = y4(t11);
    for (let s6 = 0; s6 < h3; s6++) {
      const e13 = new Uint32Array(a5[s6]), t12 = x2(u5[s6], o7[s6]);
      s4.writeAllMeshDataToBuffers(f11[s6], t12, e13), l8.geometries[s6] = { indexBuffer: e13, vertexBuffer: t12 };
    }
    return r8.tileBufferData = l8, r8;
  }
  static _align(e12, t11) {
    const r8 = e12 % t11;
    return 0 === r8 ? e12 : e12 + (t11 - r8);
  }
  static _computeVertexAlignment(e12) {
    let t11 = false, r8 = false;
    for (const s6 of e12)
      s6 % 4 == 2 ? t11 = true : s6 % 4 != 0 && (r8 = true);
    return r8 ? 4 : t11 ? 2 : 1;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/GraphicsReader.js
var o6 = class extends d2 {
  constructor(r8, t11) {
    super(r8, t11, null);
  }
  static from(s6, n7) {
    const i5 = A.createInstance(), c6 = [], u5 = s6.filter((r8) => !!r8.geometry);
    for (const e12 of u5) {
      const s7 = v(e12.geometry);
      X(c6, [e12], s7, false, false, n7);
    }
    return new o6(i5, c6);
  }
  get geometryType() {
    const r8 = this._current;
    return r8 ? r8.geometryType : null;
  }
  get insertAfter() {
    return this._current.insertAfter;
  }
  readGraphic() {
    return this._current;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const r8 = new o6(this.instance, this._features);
    return this.copyInto(r8), r8;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStoreItem.js
var y5 = new t2();
var f9 = new t2();
var d6 = "esriGeometryPolyline";
function b(t11) {
  t11.coords.length = 0, t11.lengths.length = 0;
}
var z2 = class {
  constructor() {
    this.bounds = u3(), this.graphic = null;
  }
  static acquire(t11 = null, e12, s6, r8, i5) {
    let o7;
    return 0 === z2._pool.length ? o7 = new z2() : (o7 = z2._pool.pop(), this._set.delete(o7)), o7.acquire(t11, e12, s6, r8, i5), o7;
  }
  static release(t11) {
    t11 && !this._set.has(t11) && (t11.release(), this._pool.push(t11), this._set.add(t11));
  }
  static getCentroidQuantized(e12, s6) {
    if (c2(e12.geometry)) {
      const i5 = e12.symbol;
      if (t(i5))
        return null;
      if ((i5 == null ? void 0 : i5.layers.length) > 0 && i5.layers.some((t11) => "text" === t11.type || "marker" === t11.type)) {
        const t11 = e2(e12.geometry);
        return null !== t11 ? O(s6, {}, { x: t11[0], y: t11[1] }, false, false) : null;
      }
    }
    return null;
  }
  acquire(t11 = null, e12, s6, r8, i5) {
    t11 && this.set(t11, e12, s6, r8, i5);
  }
  release() {
    this.graphic = null, this.symbolResource = null, this.geometry = null;
  }
  get symbol() {
    return this.symbolResource.symbol;
  }
  set(t11, e12, s6, r8, i5) {
    this.graphic = t11, this.geometry = s6, this.symbolResource = e12, this.bounds = r8, i5 && (this.size = i5);
  }
  getGeometryQuantized(t11, e12, r8, l8) {
    const g7 = this.geometry;
    if (c2(g7)) {
      const e13 = g7.rings;
      if (1 === e13.length && 2 === e13[0].length)
        return U(t11, { paths: [[e13[0][0], e13[0][1]]] });
    } else {
      if (y2(g7))
        return b(y5), b(f9), $(y5, g7), fe(f9, y5, g7.hasZ, g7.hasM, d6, t11.scale[0]), ie(y5, f9, g7.hasZ, g7.hasM, d6, t11), L(y5, g7.hasZ, g7.hasM);
      if (f2(g7)) {
        const i5 = 0.5 * l8 * Math.max(Math.abs(this.size[0]) + this.size[2] - this.size[0], Math.abs(this.size[1]) + this.size[3] - this.size[1]), o7 = R(r8);
        let n7 = g7.points;
        if (o7) {
          const [t12, r9] = o7.valid, l9 = r9 - t12;
          n7 = n7.filter((o8) => {
            if (o8[0] + i5 > r9 || o8[0] - i5 < t12) {
              const t13 = [...o8];
              return o8[0] + i5 > r9 ? t13[0] -= l9 : t13[0] += l9, q(e12, o8, i5) || q(e12, t13, i5);
            }
            return q(e12, o8, i5);
          });
        }
        return 0 === n7.length ? { points: n7 } : U(t11, { points: n7 });
      }
    }
    return U(t11, this.geometry);
  }
};
z2._pool = [], z2._set = /* @__PURE__ */ new Set();

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStore.js
var g5 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
var f10 = u3();
var _ = 1e-5;
function b2(e12, t11, r8, i5, s6) {
  return g5.minX = t11, g5.minY = r8, g5.maxX = i5, g5.maxY = s6, e12.search(g5);
}
function y6(e12) {
  return { minX: e12.bounds[0], minY: e12.bounds[1], maxX: e12.bounds[2], maxY: e12.bounds[3] };
}
var I2 = class {
  constructor(e12, t11, r8, s6, o7, n7, h4) {
    this._graphics = s6, this._onAdd = o7, this._onRemove = n7, this._hashToCIM = h4, this._index = i2(9, y6), this._itemByGraphic = /* @__PURE__ */ new Map(), this._inflatedSizeHelper = new Q(), this._tileInfoView = e12, this._uidFieldName = r8;
    const a5 = e12.getClosestInfoForScale(t11);
    a5 && (this._resolution = this._tileInfoView.getTileResolution(a5.level));
  }
  setResourceManager(e12) {
    this._cimResourceManager = e12, this._hittestDrawHelper = new j(e12);
  }
  hitTest(e12, t11, r8, i5, n7) {
    e12 = z(e12, this._tileInfoView.spatialReference);
    const h4 = 0.5 * i5 * window.devicePixelRatio * r8;
    f10[0] = e12 - h4, f10[1] = t11 - h4, f10[2] = e12 + h4, f10[3] = t11 + h4;
    const u5 = 0.5 * i5 * (r8 + g3), l8 = b2(this._index, e12 - u5, t11 - u5, e12 + u5, t11 + u5);
    if (!l8 || 0 === l8.length)
      return [];
    const c6 = [], d7 = u3(), p3 = u3();
    for (const s6 of l8) {
      const { geometry: e13, symbolResource: t12 } = s6;
      this._getSymbolBounds(d7, t12, e13, p3, n7), p3[3] = p3[2] = p3[1] = p3[0] = 0, E(d7, f10) && s6.graphic.visible && c6.push(s6);
    }
    if (0 === c6.length)
      return [];
    const g7 = this._hittestDrawHelper, _2 = [];
    for (const s6 of c6) {
      const { geometry: e13, symbolResource: t12 } = s6, { hash: r9, textInfo: o7 } = t12, h5 = this._hashToCIM.get(r9);
      h5 && (g7.hitTest(f10, h5.symbol, e13, o7, n7, i5) && _2.push(s6));
    }
    return _2.sort(z3), _2.map((e13) => e13.graphic);
  }
  getGraphicsData(e12, t11, r8) {
    const i5 = this._searchForItems(t11);
    if (0 === i5.length || 0 === r8.length)
      return [];
    i5.sort((e13, t12) => e13.zorder - t12.zorder), i5[0].insertAfter = -1;
    for (let l8 = 1; l8 < i5.length; l8++)
      i5[l8].insertAfter = i5[l8 - 1].graphic.uid;
    i5.sort((e13, t12) => e13.graphic.uid - t12.graphic.uid), r8.sort((e13, t12) => e13.uid - t12.uid);
    let s6, o7 = 0, n7 = 0;
    const h4 = t11.resolution, a5 = [], u5 = { originPosition: "upperLeft", scale: [h4, h4], translate: [t11.bounds[0], t11.bounds[3]] };
    for (const l8 of r8) {
      for (n7 = -2; o7 < i5.length; )
        if (s6 = i5[o7], o7++, l8.uid === s6.graphic.uid) {
          n7 = s6.insertAfter;
          break;
        }
      if (!s6.geometry || -2 === n7)
        continue;
      const r9 = s6.getGeometryQuantized(u5, t11.bounds, this._tileInfoView.spatialReference, h4), c6 = { ...s6.graphic.attributes };
      c6[this._uidFieldName] = l8.uid, null == s6.groupId && (s6.groupId = e12.createTemplateGroup(s6.symbol, null)), a5.push({ centroid: z2.getCentroidQuantized(s6, u5), geometry: r9, attributes: c6, symbol: s6.symbol, groupId: s6.groupId, insertAfter: n7, zorder: s6.zorder });
    }
    return a5.sort((e13, t12) => e13.zorder - t12.zorder), a5;
  }
  queryTileData(e12, t11) {
    if (0 === this._graphics.length)
      return [];
    const { bounds: r8, resolution: i5 } = t11, s6 = this._searchForItems(t11), o7 = [];
    return 0 === s6.length || this._createTileGraphics(o7, e12, s6, { originPosition: "upperLeft", scale: [i5, i5], translate: [r8[0], r8[3]] }, t11), o7;
  }
  has(e12) {
    return this._itemByGraphic.has(e12);
  }
  getBounds(e12) {
    const t11 = this._itemByGraphic.get(e12);
    return t11 ? t11.bounds : null;
  }
  getAllBounds() {
    return Array.from(this._itemByGraphic.values()).filter((e12) => e12.graphic.visible).map((e12) => e12.bounds);
  }
  addOrModify(r8, i5, s6) {
    if (!r8 || t(i5))
      return;
    this.has(r8) && this.remove(r8), this._onAdd(r8);
    const o7 = [0, 0, 0, 0], n7 = this._getSymbolBounds(null, i5, s6, o7, 0), h4 = z2.acquire(r8, i5, s6, r(n7) ? n7 : null, o7);
    return this._itemByGraphic.set(r8, h4), s6 && this._index.insert(h4), h4.bounds;
  }
  remove(e12) {
    if (!this._itemByGraphic.has(e12))
      return;
    this._onRemove(e12);
    const t11 = this._itemByGraphic.get(e12);
    t11.bounds && this._index.remove(t11), this._itemByGraphic.delete(e12);
  }
  updateZ() {
    const e12 = this._graphics.items;
    let t11, r8;
    for (let i5 = 0; i5 < e12.length; i5++)
      r8 = e12[i5], t11 = this._itemByGraphic.get(r8), t11 && (t11.zorder = i5);
  }
  update(e12, r8, i5) {
    const s6 = this._itemByGraphic.get(e12);
    s6.groupId = null;
    const o7 = e3(s6.bounds);
    this._index.remove(s6);
    const h4 = this._getSymbolBounds(s6.bounds, r8, i5, s6.size, 0);
    return r(h4) && s6.set(e12, r8, i5, h4, s6.size), i5 && this._index.insert(s6), { oldBounds: o7, newBounds: s6.bounds };
  }
  updateLevel(e12) {
    if (this._resolution === e12)
      return;
    this._resolution = e12, this._index.clear();
    const r8 = this._itemByGraphic, i5 = [];
    for (const [s6, o7] of r8) {
      const e13 = this._getSymbolBounds(o7.bounds, o7.symbolResource, o7.geometry, o7.size, 0);
      o7.geometry && r(e13) && (o7.bounds = e13, i5.push(o7));
    }
    this._index.load(i5);
  }
  clear() {
    this._itemByGraphic.clear(), this._index.clear();
  }
  _createTileGraphics(e12, t11, r8, i5, s6) {
    const o7 = this._uidFieldName, n7 = this._tileInfoView.spatialReference, { bounds: h4, resolution: a5 } = s6;
    let u5, l8, c6, m;
    r8.sort((e13, t12) => e13.zorder - t12.zorder);
    for (let p3 = 0; p3 < r8.length; p3++) {
      c6 = r8[p3], u5 = c6.graphic, l8 = c6.getGeometryQuantized(i5, h4, n7, a5), m = 0 === p3 ? -1 : r8[p3 - 1].graphic.uid;
      const s7 = { ...c6.graphic.attributes };
      s7[o7] = u5.uid, null == c6.groupId && (c6.groupId = t11.createTemplateGroup(c6.symbol, null)), e12.push({ centroid: z2.getCentroidQuantized(c6, i5), geometry: l8, attributes: s7, symbol: c6.symbol, groupId: c6.groupId, insertAfter: m, zorder: c6.zorder });
    }
  }
  _searchForItems(e12) {
    const t11 = this._tileInfoView.spatialReference, r8 = e12.bounds;
    if (t11.isWrappable) {
      const [i5, o7] = R(t11).valid, n7 = Math.abs(r8[2] - o7) < _, h4 = Math.abs(r8[0] - i5) < _;
      if ((!n7 || !h4) && (n7 || h4)) {
        const t12 = e12.resolution;
        let h5;
        h5 = u3(n7 ? [i5, r8[1], i5 + t12 * g3, r8[3]] : [o7 - t12 * g3, r8[1], o7, r8[3]]);
        const a5 = b2(this._index, r8[0], r8[1], r8[2], r8[3]), u5 = b2(this._index, h5[0], h5[1], h5[2], h5[3]);
        return [.../* @__PURE__ */ new Set([...a5, ...u5])];
      }
    }
    return b2(this._index, r8[0], r8[1], r8[2], r8[3]);
  }
  _getSymbolBounds(e12, t11, i5, o7, n7) {
    if (!t11 || !t11.symbol || !i5)
      return null;
    if (e12 || (e12 = u3()), c(e12, i5), !o7 || 0 === o7[0] && 0 === o7[1] && 0 === o7[2] && 0 === o7[3]) {
      const { hash: e13, textInfo: i6 } = t11, s6 = this._hashToCIM.get(e13);
      if (!s6)
        return null;
      o7 || (o7 = [0, 0, 0, 0]);
      const h4 = this._inflatedSizeHelper.getSymbolInflateSize(o7, s6.symbol, this._cimResourceManager, n7, i6);
      o7[0] = u2(h4[0]), o7[1] = u2(h4[1]), o7[2] = u2(h4[2]), o7[3] = u2(h4[3]);
    }
    const a5 = this._resolution, u5 = Q.safeSize(o7);
    return e12[0] -= u5 * a5, e12[1] -= u5 * a5, e12[2] += u5 * a5, e12[3] += u5 * a5, e12;
  }
};
var z3 = (e12, t11) => {
  const r8 = y3(e12.graphic), i5 = y3(t11.graphic);
  return r8 === i5 ? t11.zorder - e12.zorder : r8 - i5;
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicsView2D.js
var ie3 = a("esri-2d-graphic-debug");
function re(e12, t11, s6) {
  if (s6.has(e12))
    return s6.get(e12);
  const i5 = { tile: t11, addedOrModified: [], removed: [] };
  return s6.set(e12, i5), i5;
}
var oe = class extends t4(a2(y)) {
  constructor(e12) {
    super(e12), this._storage = new r4(), this._displayIds = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._tiles = /* @__PURE__ */ new Map(), this._graphicStoreUpdate = false, this._graphicsSet = /* @__PURE__ */ new Set(), this._matcher = Promise.resolve(null), this._tileUpdateSet = /* @__PURE__ */ new Set(), this._tilesToUpdate = /* @__PURE__ */ new Map(), this._graphicIdToAbortController = /* @__PURE__ */ new Map(), this._attached = false, this._updatingGraphicsTimer = null, this._hashToExpandedSymbol = /* @__PURE__ */ new Map(), this._hashToExpandedSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIMSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIM = /* @__PURE__ */ new Map(), this._processing = false, this._needsProcessing = false, this._pendingUpdate = { added: /* @__PURE__ */ new Set(), updated: /* @__PURE__ */ new Set(), removed: /* @__PURE__ */ new Set() }, this.lastUpdateId = -1, this.updateRequested = false, this.graphicUpdateHandler = this.graphicUpdateHandler.bind(this);
  }
  destroy() {
    this._updatingGraphicsTimer && (clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = null, this.notifyChange("updating")), this._controller.abort(), this.container.destroy(), this._set("graphics", null), this._graphicStore.clear(), this._attributeStore = null, this._hashToExpandedSymbol.clear(), this.view = null, this.renderer = null, this._hashToCIM.clear(), this._hashToCIMSymbolPromise.clear(), this._hashToExpandedSymbolPromise.clear();
  }
  _createMatcher(e12, t11, s6) {
    if (e12) {
      const i5 = K2({ indexCount: 0, fields: {} }, "feature", e12);
      this._matcher = l6(i5, t11, null, s6);
    }
  }
  _createDisplayId(e12) {
    return this._displayIds.has(e12) || this._displayIds.set(e12, this._storage.createDisplayId()), this._displayIds.get(e12);
  }
  initialize() {
    this._attributeStore = new R3({ type: "local", initialize: (e13) => Promise.resolve(this.container.attributeView.initialize(e13)), update: (e13) => this.container.attributeView.requestUpdate(e13), render: () => this.container.requestRender() }, l4("2d"), () => this.notifyChange("updating")), this.container.hasHighlight = () => this._attributeStore.hasHighlight;
    const e12 = (e13) => {
      this._createDisplayId(e13.uid), this._setFilterState(e13.uid, e13.visible);
    }, t11 = (e13) => {
      const t12 = this._displayIds.get(e13.uid);
      this._displayIds.delete(e13.uid), this._storage.releaseDisplayId(t12);
    }, s6 = new x(this.container.getMaterialItems.bind(this.container), this.view.featuresTilingScheme.tileInfo);
    this._graphicStore = new I2(this.view.featuresTilingScheme, this.view.state.scale, this.uid, this.graphics, e12, t11, this._hashToCIM), this._meshFactory = new l5(null, this.uid, s6), this._templateStore = s6, this.handles.add([l2(() => this.renderer, (e13) => {
      this._createMatcher(e13, s6, this.container.stage.resourceManager);
      for (const t12 of this.graphics)
        this._pendingUpdate.updated.add(t12);
      this.requestUpdate();
    }), this.view.graphicsTileStore.on("update", (e13) => this._onTileUpdate(e13)), this.container.on("attach", () => {
      ie3 && this.container.enableRenderingBounds(() => this._graphicStore.getAllBounds()), this.graphics.items.length > 0 && this._graphicsChangeHandler({ target: this.graphics, added: this.graphics.items, removed: [], moved: [] }), this.handles.add(this.graphics.on("change", (e14) => this._graphicsChangeHandler(e14)), "graphics");
      const e13 = this.container.stage.resourceManager;
      this._createMatcher(this.renderer, s6, e13), this._graphicStore.setResourceManager(e13), this._attached = true, this.notifyChange("updating");
    })]);
    const i5 = this.view.graphicsTileStore.tiles;
    this._onTileUpdate({ added: i5, removed: [] });
  }
  get updating() {
    return !this._attached || null !== this._updatingGraphicsTimer || this._tileUpdateSet.size > 0 || this._tilesToUpdate.size > 0 || this._attributeStore.isUpdating();
  }
  hitTest(e12) {
    if (!this.view || !this.view.position)
      return [];
    const { resolution: t11, rotation: s6 } = this.view.state;
    return this._graphicStore.hitTest(e12.x, e12.y, 2, t11, s6);
  }
  update(e12) {
    f(this._controller.signal);
    const t11 = e12.state, { resolution: s6 } = t11;
    if (this._graphicStore.updateLevel(s6), this._graphicStoreUpdate = true, this.updateRequested = false, this._pendingUpdate.updated.size > 0) {
      if (!this._processing)
        return void this._updateGraphics();
      this._needsProcessing = true;
    }
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = true, this.requestUpdateCallback());
  }
  processUpdate(e12) {
    this.updateRequested && (this.updateRequested = false, this.update(e12));
  }
  graphicUpdateHandler(e12) {
    const { graphic: t11, property: s6, newValue: i5 } = e12;
    switch (s6) {
      case "attributes":
      case "geometry":
      case "symbol":
        this._pendingUpdate.updated.add(t11), this.requestUpdate();
        break;
      case "visible":
        this._setFilterState(t11.uid, i5), this._attributeStore.sendUpdates();
    }
  }
  setHighlight(e12) {
    const t11 = e12.map((e13) => this._displayIds.get(e13));
    this._attributeStore.setHighlight(e12, t11);
  }
  _getIntersectingTiles(e12) {
    const t11 = this._graphicStore.getBounds(e12);
    if (!t11 || 0 === s2(t11) || 0 === l3(t11))
      return [];
    const s6 = p(t11, this.view.spatialReference);
    return r(s6) ? [.../* @__PURE__ */ new Set([...this.view.graphicsTileStore.boundsIntersections(s6[0]), ...this.view.graphicsTileStore.boundsIntersections(s6[1])])] : this.view.graphicsTileStore.boundsIntersections(t11);
  }
  async _updateTile(e12) {
    f(this._controller.signal);
    const t11 = e12.tile, s6 = this._getGraphicsData(this._templateStore, t11, e12.addedOrModified), i5 = await this._processGraphics(t11, s6);
    return f(this._controller.signal), this._patchTile(t11.key, { type: "update", addOrUpdate: i5, remove: e12.removed, end: true, clear: false, sort: false }), i5;
  }
  _patchTile(e12, t11) {
    if (!this._tiles.has(e12))
      return;
    const s6 = this._tiles.get(e12);
    this.container.onTileData(s6, t11), this.container.requestRender();
  }
  _graphicsChangeHandler(e12) {
    const t11 = this._pendingUpdate;
    for (const s6 of e12.added)
      t11.added.add(s6);
    for (const s6 of e12.moved)
      t11.updated.add(s6);
    for (const s6 of e12.removed)
      this._pendingUpdate.added.has(s6) ? t11.added.delete(s6) : t11.removed.add(s6);
    this._processing ? this._needsProcessing = true : this._updateGraphics();
  }
  _getGraphicsToUpdate() {
    const e12 = { added: [], removed: [], updated: [] };
    if (!this.graphics)
      return e12;
    const t11 = this._pendingUpdate;
    for (const s6 of this.graphics.items)
      t11.added.has(s6) ? e12.added.push(s6) : t11.updated.has(s6) && e12.updated.push(s6);
    for (const s6 of t11.removed)
      this._graphicStore.has(s6) && e12.removed.push(s6);
    return t11.added.clear(), t11.removed.clear(), t11.updated.clear(), e12;
  }
  async _updateGraphics() {
    this._processing = true;
    const { added: e12, removed: t11, updated: s6 } = this._getGraphicsToUpdate(), i5 = this._tilesToUpdate;
    let r8;
    try {
      if (!this._graphicStoreUpdate) {
        const e13 = this.view.state, { resolution: t12 } = e13;
        this._graphicStore.updateLevel(t12);
      }
      const o7 = [], a5 = new Array(e12.length + t11.length);
      for (let e13 = 0; e13 < s6.length; e13++) {
        const t12 = s6[e13], h5 = this._getIntersectingTiles(t12);
        for (const e14 of h5) {
          r8 = e14.id;
          re(r8, e14, i5).removed.push(this._displayIds.get(t12.uid));
        }
        o7.push(this._updateGraphic(t12, null)), a5[e13] = t12;
      }
      const h4 = s6.length;
      for (let t12 = 0; t12 < e12.length; t12++) {
        const s7 = e12[t12];
        a5[h4 + t12] = s7, this._graphicsSet.add(s7), o7.push(this._addGraphic(s7));
      }
      for (const e13 of t11) {
        this._abortProcessingGraphic(e13.uid);
        const t12 = this._getIntersectingTiles(e13);
        for (const s7 of t12) {
          r8 = s7.id;
          re(r8, s7, i5).removed.push(this._displayIds.get(e13.uid));
        }
        this._graphicsSet.delete(e13), this._graphicStore.remove(e13);
      }
      let n7;
      this._flipUpdatingGraphics(), await Promise.all(o7);
      for (let e13 = 0; e13 < a5.length; e13++) {
        n7 = a5[e13];
        const t12 = this._getIntersectingTiles(n7);
        for (const e14 of t12) {
          r8 = e14.id;
          re(r8, e14, i5).addedOrModified.push(n7);
        }
      }
      this._graphicStore.updateZ();
      const l8 = [];
      for (const [e13, t12] of i5)
        l8.push(this._updateTile(t12));
      await Promise.all(l8);
    } catch (o7) {
      g(o7), 0;
    }
    for (const a5 of t11)
      try {
        const e13 = await this._getSymbolForGraphic(a5, null);
        if (e13) {
          const t12 = e13.hash();
          this._hashToExpandedSymbol.delete(t12);
        }
      } catch (o7) {
        g(o7), 0;
      }
    i5.clear(), this.notifyChange("updating"), this._processing = false, this._needsProcessing && (this._needsProcessing = false, this._updateGraphics());
  }
  _getArcadeInfo(e12) {
    const t11 = (e12.attributes ? Object.keys(e12.attributes) : []).map((t12) => ({ name: t12, alias: t12, type: "string" == typeof e12.attributes[t12] ? "esriFieldTypeString" : "esriFieldTypeDouble" }));
    return t(e12.geometry) ? null : { geometryType: v(e12.geometry), spatialReference: k.fromJSON(e12.geometry.spatialReference), fields: t11 };
  }
  _getSymbolForGraphic(e12, t11) {
    return f(this._controller.signal), r(e12.symbol) ? Promise.resolve(e12.symbol) : r(this.renderer) ? this.renderer.getSymbolAsync(e12, { scale: this.view.scale, signal: r(t11) ? t11.signal : null }) : Promise.resolve(this._getNullSymbol(e12));
  }
  _getCIMSymbol(e12, t11, s6) {
    let i5 = this._hashToCIM.get(t11);
    if (i5)
      return Promise.resolve(i5);
    const r8 = q2(e12);
    if (r(r8)) {
      if ("CIMSymbolReference" === r8.type)
        return i5 = r8, this._hashToCIM.set(t11, i5), Promise.resolve(i5);
      let e13 = this._hashToCIMSymbolPromise.get(t11);
      return e13 || (e13 = r8.fetchCIMSymbol(s6).then((e14) => (this._hashToCIM.set(t11, e14.data), this._hashToCIMSymbolPromise.delete(t11), e14)).catch((e14) => (this._hashToCIMSymbolPromise.delete(t11), w(e14), null)), this._hashToCIMSymbolPromise.set(t11, e13), e13);
    }
    return Promise.resolve(null);
  }
  _expandCIMSymbol(e12, t11, s6, i5) {
    const r8 = this._hashToExpandedSymbol.get(s6);
    if (r8)
      return Promise.resolve(r8);
    let o7 = this._hashToExpandedSymbolPromise.get(s6);
    if (o7)
      return o7;
    const a5 = this.container.stage, h4 = this._getArcadeInfo(t11), n7 = S2(null), l8 = o(e12, n7);
    return o7 = n3(l8, h4, a5.resourceManager, i5), this._hashToExpandedSymbolPromise.set(s6, o7), o7.then((e13) => (this._hashToExpandedSymbol.set(s6, e13), this._hashToExpandedSymbolPromise.delete(s6), e13)), o7;
  }
  async _getSymbolResources(e12, t11) {
    f(this._controller.signal);
    return this.container.stage ? this._getSymbolForGraphic(e12, t11).then((i5) => {
      const r8 = i5.hash();
      return this._getCIMSymbol(i5, r8, t11).then((i6) => t(i6) ? null : this._expandCIMSymbol(i6, e12, r8, t11).then((e13) => {
        const t12 = e13.layers.filter((e14) => "text" === e14.type && "string" == typeof e14.text);
        if (t12 && t12.length > 0) {
          const i7 = new Array(t12.length);
          for (let e14 = 0; e14 < t12.length; e14++) {
            const r9 = t12[e14], o8 = [], [a5] = n2(r9.text);
            r9.text = a5;
            for (let e15 = 0; e15 < a5.length; e15++)
              o8.push(a5.charCodeAt(e15));
            i7[e14] = { symbol: r9, id: e14, glyphIds: o8 };
          }
          const o7 = /* @__PURE__ */ new Map();
          return this.container.getMaterialItems(i7).then((s6) => {
            for (let e14 = 0; e14 < t12.length; e14++) {
              const i8 = t12[e14];
              o7.set(i8.cim, { text: i8.text, mosaicItem: s6[e14].mosaicItem });
            }
            return { symbol: e13, textInfo: o7, hash: r8 };
          });
        }
        return { symbol: e13, hash: r8 };
      }));
    }).catch((e13) => (w(e13), null)) : null;
  }
  async _projectAndNormalizeGeometry(e12, t11) {
    if (f(this._controller.signal), t(e12.geometry) || "mesh" === e12.geometry.type)
      return null;
    let s6 = e12.geometry;
    if (c2(s6)) {
      const e13 = s6.rings;
      s6.rings = e13;
    } else if (y2(s6)) {
      const e13 = s6.paths;
      s6.paths = e13;
    } else if (s(s6)) {
      const i6 = await this._getSymbolForGraphic(e12, t11);
      if (f(this._controller.signal), h2(i6.type) || u4(i6.type)) {
        s6 = s6.center;
      } else
        s6 = d3(s6);
    }
    await f3(s6.spatialReference, this.view.spatialReference);
    const i5 = f6(s6), r8 = g2(i5, s6.spatialReference, this.view.spatialReference);
    return u(r8), r8;
  }
  _onTileUpdate(e12) {
    const t11 = R(this.view.spatialReference);
    if (e12.added && e12.added.length > 0)
      for (const s6 of e12.added)
        this._addNewTile(s6, t11);
    if (e12.removed && e12.removed.length > 0)
      for (const s6 of e12.removed)
        this._removeTile(s6.key);
  }
  async _addGraphic(e12) {
    this._abortProcessingGraphic(e12.uid), f(this._controller.signal);
    const t11 = new AbortController();
    this._graphicIdToAbortController.set(e12.uid, t11);
    const s6 = { signal: t11.signal };
    try {
      await this._addOrUpdateGraphic(e12, s6), f(this._controller.signal), this._graphicIdToAbortController.delete(e12.uid);
    } catch (i5) {
      if (this._graphicIdToAbortController.delete(e12.uid), !g(i5))
        throw i5;
    }
  }
  _updateGraphic(e12, t11) {
    f(this._controller.signal);
    const s6 = this._projectAndNormalizeGeometry(e12, t11), i5 = this._getSymbolResources(e12, t11);
    return Promise.all([s6, i5]).then(([t12, s7]) => {
      f(this._controller.signal), this._graphicStore.addOrModify(e12, s7, t12);
    });
  }
  _addOrUpdateGraphic(e12, t11) {
    f(this._controller.signal);
    const s6 = this._projectAndNormalizeGeometry(e12, t11), i5 = this._getSymbolResources(e12, t11);
    return Promise.all([s6, i5]).then(([t12, s7]) => {
      f(this._controller.signal), this._graphicsSet.has(e12) && this._graphicStore.addOrModify(e12, s7, t12);
    });
  }
  _addTile(e12) {
    const t11 = this.view.featuresTilingScheme.getTileBounds(u3(), e12), s6 = new a4(e12, t11[0], t11[3]);
    return this._tiles.set(e12, s6), this.container.addChild(s6), s6;
  }
  async _addNewTile(e12, t11) {
    const s6 = this._addTile(e12.key), i5 = this._graphicStore.queryTileData(this._templateStore, e12);
    if (0 === i5.length)
      return;
    if (t11) {
      const s7 = Math.round((t11.valid[1] - t11.valid[0]) / e12.resolution);
      for (const e13 of i5)
        e13.geometry && (l(e13.geometry) || f2(e13.geometry)) && this._wrapPoints(e13, s7);
    }
    const r8 = e12.key;
    this._tileUpdateSet.add(e12.key), this.notifyChange("updating");
    try {
      const t12 = { type: "update", clear: false, addOrUpdate: await this._processGraphics(e12, i5), remove: [], end: true, sort: false };
      s6.patch(t12), this._tileUpdateSet.delete(r8), this.notifyChange("updating");
    } catch (o7) {
      if (this._tileUpdateSet.delete(r8), this.notifyChange("updating"), !g(o7))
        throw o7;
    }
  }
  _removeTile(e12) {
    if (!this._tiles.has(e12))
      return;
    const t11 = this._tiles.get(e12);
    this.container.removeChild(t11), t11.destroy(), this._tiles.delete(e12);
  }
  _setFilterState(e12, t11) {
    const s6 = this._displayIds.get(e12), i5 = this._attributeStore.getHighlightFlag(e12);
    this._attributeStore.setData(s6, 0, 0, i5 | (t11 ? U2 : 0));
  }
  _getGraphicsData(e12, t11, s6) {
    const i5 = this.view, r8 = R(i5.spatialReference), o7 = this._graphicStore.getGraphicsData(e12, t11, s6);
    if (r8) {
      const e13 = Math.round((r8.valid[1] - r8.valid[0]) / t11.resolution);
      for (const t12 of o7)
        t12.geometry && (l(t12.geometry) || f2(t12.geometry)) && this._wrapPoints(t12, e13);
    }
    return o7;
  }
  _wrapPoints(e12, t11) {
    const s6 = e12.geometry;
    f2(s6) ? this._wrapMultipoint(s6, t11) : this._wrapPoint(e12, t11);
  }
  _wrapMultipoint(e12, t11) {
    const s6 = e12.points, i5 = [];
    let r8 = 0, o7 = 0;
    for (const [a5, h4] of s6) {
      if (i5.push([a5 + r8, h4]), r8 = 0, t11 === c5) {
        const e13 = 5 * g3;
        a5 + o7 < e13 ? (i5.push([t11, 0]), r8 = -t11) : a5 + o7 > c5 - e13 && (i5.push([-t11, 0]), r8 = t11);
      } else
        a5 + o7 < -g3 ? (i5.push([t11, 0]), r8 = -t11) : a5 + o7 > c5 + g3 && (i5.push([-t11, 0]), r8 = t11);
      o7 += a5;
    }
    e12.points = i5;
  }
  _wrapPoint(e12, t11) {
    const s6 = e12.geometry;
    if (t11 === c5) {
      const i5 = 5 * g3;
      s6.x < i5 ? e12.geometry = { points: [[s6.x, s6.y], [t11, 0]] } : s6.x > c5 - i5 && (e12.geometry = { points: [[s6.x, s6.y], [-t11, 0]] });
    } else
      s6.x < -g3 ? e12.geometry = { points: [[s6.x, s6.y], [t11, 0]] } : s6.x > c5 + g3 && (e12.geometry = { points: [[s6.x, s6.y], [-t11, 0]] });
  }
  _processGraphics(e12, t11, s6) {
    if (!(t11 && t11.length) || !this._meshFactory)
      return null;
    const i5 = o6.from(t11, this.uid), r8 = this._meshFactory;
    return this._matcher.then((t12) => r8.analyzeGraphics(i5, this.container.stage.resourceManager, t12, null, null, s6).then(() => (this._attributeStore.sendUpdates(), this._processAnalyzedGraphics(e12, i5))));
  }
  _processAnalyzedGraphics(e12, t11) {
    const s6 = this._meshFactory, i5 = t11.getSize(), r8 = t11.getCursor(), o7 = { features: i5, records: i5, metrics: 0 }, a5 = new E3(e12.key.id, o7, S.DEFAULT, false, false), h4 = [];
    for (; r8.next(); ) {
      const t12 = r8.readGraphic();
      t12.insertAfter = -1 === t12.insertAfter ? -1 : this._displayIds.get(t12.insertAfter), t12.displayId = this._displayIds.get(t12.attributes[this.uid]);
      const i6 = new e10(t12.displayId);
      i6.insertAfter = t12.insertAfter, h4.push(i6), s6.writeGraphic(a5, r8, e12.level, this.container.stage.resourceManager);
    }
    const n7 = e12.tileInfoView.tileInfo.isWrappable, l8 = a5.serialize(n7);
    if (1 !== l8.length)
      return new g4();
    const d7 = l8[0].message;
    return g4.fromVertexData(d7, h4);
  }
  _abortProcessingGraphic(e12) {
    if (this._graphicIdToAbortController.has(e12)) {
      this._graphicIdToAbortController.get(e12).abort();
    }
  }
  _getNullSymbol(e12) {
    const t11 = e12.geometry;
    return y2(t11) ? O2 : c2(t11) || s(t11) ? j2 : N;
  }
  _flipUpdatingGraphics() {
    this._updatingGraphicsTimer && clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = setTimeout(() => {
      this._updatingGraphicsTimer = null, this.notifyChange("updating");
    }, 160), this.notifyChange("updating");
  }
};
e([d({ constructOnly: true })], oe.prototype, "requestUpdateCallback", void 0), e([d()], oe.prototype, "container", void 0), e([d({ constructOnly: true })], oe.prototype, "graphics", void 0), e([d()], oe.prototype, "updating", null), e([d()], oe.prototype, "view", void 0), e([d()], oe.prototype, "updateRequested", void 0), oe = e([n("esri.views.2d.layers.support.GraphicsView2D")], oe);
var ae2 = oe;

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicBoundsRenderer.js
var g6 = Math.PI / 180;
var v2 = 4;
var x3 = class extends a3 {
  constructor(t11) {
    super(), this._dvsMat3 = e5(), this._localOrigin = { x: 0, y: 0 }, this._getBounds = t11;
  }
  destroy() {
    this._vao && (this._vao.dispose(true), this._vao = null, this._vertexBuffer = null, this._indexBuffer = null), this._program && (this._program.dispose(), this._program = null);
  }
  doRender(t11) {
    const { context: e12 } = t11, s6 = this._getBounds();
    if (s6.length < 1)
      return;
    this._createShaderProgram(e12), this._updateMatricesAndLocalOrigin(t11), this._updateBufferData(e12, s6), e12.setBlendingEnabled(true), e12.setDepthTestEnabled(false), e12.setStencilWriteMask(0), e12.setStencilTestEnabled(false), e12.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), e12.setColorMask(true, true, true, true);
    const r8 = this._program;
    e12.bindVAO(this._vao), e12.useProgram(r8), r8.setUniformMatrix3fv("u_dvsMat3", this._dvsMat3), e12.gl.lineWidth(1), e12.drawElements(E2.LINES, 8 * s6.length, C.UNSIGNED_INT, 0), e12.bindVAO();
  }
  _createTransforms() {
    return { dvs: e5() };
  }
  _createShaderProgram(t11) {
    if (this._program)
      return;
    const e12 = "precision highp float;\n        uniform mat3 u_dvsMat3;\n\n        attribute vec2 a_position;\n\n        void main() {\n          mediump vec3 pos = u_dvsMat3 * vec3(a_position, 1.0);\n          gl_Position = vec4(pos.xy, 0.0, 1.0);\n        }", s6 = "precision mediump float;\n      void main() {\n        gl_FragColor = vec4(0.75, 0.0, 0.0, 0.75);\n      }";
    this._program = t11.programCache.acquire(e12, s6, b3().attributes);
  }
  _updateMatricesAndLocalOrigin(o7) {
    const { state: l8 } = o7, { displayMat3: u5, size: c6, resolution: _2, pixelRatio: m, rotation: h4, viewpoint: d7 } = l8, p3 = g6 * h4, { x: v3, y: x4 } = d7.targetGeometry, b4 = z(v3, l8.spatialReference);
    this._localOrigin.x = b4, this._localOrigin.y = x4;
    const y7 = m * c6[0], B2 = m * c6[1], M2 = _2 * y7, A2 = _2 * B2, O3 = r2(this._dvsMat3);
    i(O3, O3, u5), M(O3, O3, t3(y7 / 2, B2 / 2)), f4(O3, O3, r3(c6[0] / M2, -B2 / A2, 1)), h(O3, O3, -p3);
  }
  _updateBufferData(t11, e12) {
    const { x: s6, y: r8 } = this._localOrigin, i5 = 2 * v2 * e12.length, o7 = new Float32Array(i5), a5 = new Uint32Array(8 * e12.length);
    let n7 = 0, f11 = 0;
    for (const l8 of e12)
      l8 && (o7[2 * n7 + 0] = l8[0] - s6, o7[2 * n7 + 1] = l8[1] - r8, o7[2 * n7 + 2] = l8[0] - s6, o7[2 * n7 + 3] = l8[3] - r8, o7[2 * n7 + 4] = l8[2] - s6, o7[2 * n7 + 5] = l8[3] - r8, o7[2 * n7 + 6] = l8[2] - s6, o7[2 * n7 + 7] = l8[1] - r8, a5[f11 + 0] = n7 + 0, a5[f11 + 1] = n7 + 3, a5[f11 + 2] = n7 + 3, a5[f11 + 3] = n7 + 2, a5[f11 + 4] = n7 + 2, a5[f11 + 5] = n7 + 1, a5[f11 + 6] = n7 + 1, a5[f11 + 7] = n7 + 0, n7 += 4, f11 += 8);
    if (this._vertexBuffer ? this._vertexBuffer.setData(o7.buffer) : this._vertexBuffer = c3.createVertex(t11, F.DYNAMIC_DRAW, o7.buffer), this._indexBuffer ? this._indexBuffer.setData(a5) : this._indexBuffer = c3.createIndex(t11, F.DYNAMIC_DRAW, a5), !this._vao) {
      const e13 = b3();
      this._vao = new f5(t11, e13.attributes, e13.bufferLayouts, { geometry: this._vertexBuffer }, this._indexBuffer);
    }
  }
};
var b3 = () => ge("bounds", { geometry: [{ location: 0, name: "a_position", count: 2, type: C.FLOAT }] });

// node_modules/@arcgis/core/views/2d/layers/graphics/BaseGraphicContainer.js
var t10 = class extends o2 {
  constructor(e12) {
    super(e12), this.hasHighlight = () => true;
  }
  destroy() {
    super.destroy(), this._boundsRenderer && (this._boundsRenderer.destroy(), this._boundsRenderer = null);
  }
  enableRenderingBounds(e12) {
    this._boundsRenderer = new x3(e12), this.requestRender();
  }
  get hasLabels() {
    return false;
  }
  onTileData(e12, s6) {
    e12.patch(s6), this.contains(e12) || this.addChild(e12), this.requestRender();
  }
  onTileError(e12) {
    e12.clear(), this.contains(e12) || this.addChild(e12);
  }
  _renderChildren(e12, s6) {
    for (const t11 of this.children)
      t11.isReady && t11.hasData && (t11.commit(e12), e12.context.setStencilFunction(I.EQUAL, t11.stencilRef, 255), t11._displayList.replay(e12, t11, s6));
  }
};

export {
  ae2 as ae,
  t10 as t
};
//# sourceMappingURL=chunk-TOHMM6FQ.js.map
