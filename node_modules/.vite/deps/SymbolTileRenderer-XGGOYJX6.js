import {
  c as c3,
  i,
  o as o3
} from "./chunk-2HUXPKKU.js";
import {
  i as i2
} from "./chunk-WL7KJZAL.js";
import {
  o as o4
} from "./chunk-LXO3MKKK.js";
import "./chunk-JX3YCNPL.js";
import "./chunk-JERZLQLG.js";
import {
  W
} from "./chunk-JWKDNFWF.js";
import "./chunk-ATJYWC6C.js";
import "./chunk-KXE4LGFJ.js";
import "./chunk-SASFTPK5.js";
import "./chunk-UJS24K6P.js";
import "./chunk-UKBGUXUQ.js";
import "./chunk-AKNCAMEF.js";
import {
  m
} from "./chunk-3CED37X7.js";
import "./chunk-FMIFCFD7.js";
import "./chunk-WL7AHHN3.js";
import {
  he
} from "./chunk-UGLXR5OV.js";
import "./chunk-RGZ7VIMW.js";
import {
  E,
  I
} from "./chunk-6FQZDXGD.js";
import {
  s
} from "./chunk-5QPLPQX7.js";
import "./chunk-PNNMRFHO.js";
import "./chunk-YRAX326I.js";
import "./chunk-HH3D3A65.js";
import "./chunk-OA3NMCNZ.js";
import "./chunk-YDPQRKY4.js";
import "./chunk-567AWHAB.js";
import "./chunk-TZD2AXJG.js";
import "./chunk-FZCDFXBT.js";
import "./chunk-KD6KBT2L.js";
import "./chunk-RVR2DEVB.js";
import "./chunk-AS3OSZXK.js";
import "./chunk-IYLBVJ6T.js";
import "./chunk-Z7AZMEL6.js";
import {
  f as f3
} from "./chunk-FUKESVWQ.js";
import {
  c as c2
} from "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-33INAWJA.js";
import {
  F
} from "./chunk-FPMD6IB4.js";
import "./chunk-RIOXX6J2.js";
import "./chunk-MEW2XKT2.js";
import {
  n as n3
} from "./chunk-RB3LJE4I.js";
import "./chunk-6EODZIDR.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-PQO66WZ2.js";
import "./chunk-3NPGGTI6.js";
import {
  z
} from "./chunk-YZNDHJDJ.js";
import {
  n as n2
} from "./chunk-4P4OV7G6.js";
import {
  f as f2,
  o as o2
} from "./chunk-ZUDEVIXR.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-YL26MZEL.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-RN2KRYDN.js";
import {
  u
} from "./chunk-56RHM4A6.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  D,
  g
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  a,
  c,
  f,
  l,
  o,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/MetricReader.js
var e2 = 6;
var r2 = 4294967296;
var o5 = class {
  constructor(t2) {
    this._head = t2, this._cursor = t2;
  }
  static from(t2) {
    const s2 = i3.from(new Float32Array(t2));
    return new o5(s2);
  }
  get id() {
    return this._cursor.id;
  }
  get baseZoom() {
    return this._cursor.baseZoom;
  }
  get anchorX() {
    return this._cursor.anchorX;
  }
  get anchorY() {
    return this._cursor.anchorY;
  }
  get directionX() {
    return this._cursor.directionX;
  }
  get directionY() {
    return this._cursor.directionY;
  }
  get size() {
    return this._cursor.size;
  }
  get materialKey() {
    return this._cursor.materialKey;
  }
  get boundsCount() {
    return this._cursor.boundsCount;
  }
  computedMinZoom() {
    return this._cursor.computedMinZoom();
  }
  setComputedMinZoom(t2) {
    return this._cursor.setComputedMinZoom(t2);
  }
  boundsComputedAnchorX(t2) {
    return this._cursor.boundsComputedAnchorX(t2);
  }
  boundsComputedAnchorY(t2) {
    return this._cursor.boundsComputedAnchorY(t2);
  }
  setBoundsComputedAnchorX(t2, s2) {
    return this._cursor.setBoundsComputedAnchorX(t2, s2);
  }
  setBoundsComputedAnchorY(t2, s2) {
    return this._cursor.setBoundsComputedAnchorY(t2, s2);
  }
  boundsX(t2) {
    return this._cursor.boundsX(t2);
  }
  boundsY(t2) {
    return this._cursor.boundsY(t2);
  }
  boundsWidth(t2) {
    return this._cursor.boundsWidth(t2);
  }
  boundsHeight(t2) {
    return this._cursor.boundsHeight(t2);
  }
  link(s2) {
    if (r(s2._head))
      return this._cursor.link(s2._head);
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    var _a;
    const t2 = new o5((_a = this._head) == null ? void 0 : _a.copy());
    if (!t2._head)
      return t2;
    let s2 = t2._head, e4 = t2._head._link;
    for (; e4; )
      s2._link = e4.copy(), s2 = e4, e4 = s2._link;
    return t2;
  }
  peekId() {
    return this._cursor.peekId() ?? this._cursor._link.peekId();
  }
  nextId() {
    const t2 = this.id;
    for (; t2 === this.id; )
      if (!this.next())
        return false;
    return true;
  }
  save() {
    this._savedCursor = this._cursor, this._savedOffset = this._cursor._offset;
  }
  restore() {
    this._cursor = this._savedCursor, this._cursor._offset = this._savedOffset;
  }
  next() {
    if (!this._cursor)
      return false;
    if (!this._cursor.next()) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link, this._cursor._offset = 0;
    }
    return true;
  }
  lookup(t2) {
    for (this._cursor = this._head; this._cursor && !this._cursor.lookup(t2); ) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link;
    }
    return !!this._cursor;
  }
  delete(s2) {
    let e4 = this._head, r3 = null;
    for (; e4; ) {
      if (e4.delete(s2))
        return e4.isEmpty() && r(r3) && (r3._link = e4._link), true;
      r3 = e4, e4 = e4._link;
    }
    return false;
  }
};
var i3 = class {
  constructor(t2) {
    this._offset = -1, this._link = null, this._count = 0, this._deletedCount = 0, this._offsets = { instance: null }, this._buffer = t2;
  }
  static from(t2) {
    return new i3(new Float32Array(t2));
  }
  isEmpty() {
    return this._deletedCount === this.count;
  }
  get count() {
    return this._count || (this._count = this._computeCount()), this._count;
  }
  get id() {
    return this._buffer[this._offset + 0];
  }
  set id(t2) {
    this._buffer[this._offset + 0] = t2;
  }
  get baseZoom() {
    return this._buffer[this._offset + 1];
  }
  get anchorX() {
    return this._buffer[this._offset + 2];
  }
  get anchorY() {
    return this._buffer[this._offset + 3];
  }
  get directionX() {
    return this._buffer[this._offset + 4];
  }
  get directionY() {
    return this._buffer[this._offset + 5];
  }
  get size() {
    return this._buffer[this._offset + 6];
  }
  get materialKey() {
    return this._buffer[this._offset + 7];
  }
  computedMinZoom() {
    return this._buffer[this._offset + 8];
  }
  setComputedMinZoom(t2) {
    this._buffer[this._offset + 8] = t2;
  }
  get boundsCount() {
    return this._buffer[this._offset + 9];
  }
  boundsComputedAnchorX(t2) {
    return this._buffer[this._offset + 10 + t2 * e2 + 0];
  }
  boundsComputedAnchorY(t2) {
    return this._buffer[this._offset + 10 + t2 * e2 + 1];
  }
  setBoundsComputedAnchorX(t2, s2) {
    this._buffer[this._offset + 10 + t2 * e2 + 0] = s2;
  }
  setBoundsComputedAnchorY(t2, s2) {
    this._buffer[this._offset + 10 + t2 * e2 + 1] = s2;
  }
  boundsX(t2) {
    return this._buffer[this._offset + 10 + t2 * e2 + 2];
  }
  boundsY(t2) {
    return this._buffer[this._offset + 10 + t2 * e2 + 3];
  }
  boundsWidth(t2) {
    return this._buffer[this._offset + 10 + t2 * e2 + 4];
  }
  boundsHeight(t2) {
    return this._buffer[this._offset + 10 + t2 * e2 + 5];
  }
  link(t2) {
    let s2 = this;
    for (; s2._link; )
      s2 = s2._link;
    s2._link = t2;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t2 = new i3(this._buffer);
    return t2._link = this._link, t2._offset = this._offset, t2._deletedCount = this._deletedCount, t2._offsets = this._offsets, t2._count = this._count, t2;
  }
  peekId() {
    const t2 = this._offset + 10 + this.boundsCount * e2 + 0;
    return t2 >= this._buffer.length ? 0 : this._buffer[t2];
  }
  next() {
    let t2 = 0;
    for (; this._offset < this._buffer.length && t2++ < 100 && (-1 === this._offset ? this._offset = 0 : this._offset += 10 + this.boundsCount * e2, this.id === r2); )
      ;
    return this.id !== r2 && this._offset < this._buffer.length;
  }
  delete(t2) {
    const s2 = this._offset, e4 = this.lookup(t2);
    if (e4)
      for (this.id = 4294967295, ++this._deletedCount; this.next() && this.id === t2; )
        this.id = 4294967295, ++this._deletedCount;
    return this._offset = s2, e4;
  }
  lookup(t2) {
    const e4 = this._offset;
    if (t(this._offsets.instance)) {
      this._offsets.instance = /* @__PURE__ */ new Map();
      const t3 = this.copy();
      t3._offset = -1;
      let s2 = 0;
      for (; t3.next(); )
        t3.id !== s2 && (this._offsets.instance.set(t3.id, t3._offset), s2 = t3.id);
    }
    return !!this._offsets.instance.has(t2) && (this._offset = this._offsets.instance.get(t2), this.id !== r2 || (this._offset = e4, false));
  }
  _computeCount() {
    const t2 = this._offset;
    let s2 = 0;
    for (this._offset = -1; this.next(); )
      s2++;
    return this._offset = t2, s2;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js
var a2 = class {
  constructor(t2) {
    if (!Array.isArray(t2))
      return void (this.data = t2);
    this.data = t2[0];
    let e4 = this;
    for (let n7 = 1; n7 < t2.length; n7++)
      e4.next = new a2([t2[n7]]), e4 = e4.next;
  }
  *values() {
    let t2 = this;
    for (; t2; )
      yield t2.data, t2 = t2.next;
  }
  forEach(t2) {
    let a6 = this;
    for (; a6; )
      t2(a6.data), a6 = a6.next;
  }
  find(t2) {
    var _a;
    return t2(this.data) ? this : (_a = this.next) == null ? void 0 : _a.find(t2);
  }
  max(t2, a6 = this) {
    const e4 = t2(this.data) > t2(a6.data) ? this : a6;
    return this.next ? this.next.max(t2, e4) : e4;
  }
  remove(t2, a6 = null) {
    return this === t2 ? a6 ? (a6.next = this.next, a6) : this.next : this.next.remove(t2, this);
  }
  get last() {
    return this.next ? this.next.last : this;
  }
};
var e3 = class {
  constructor(e4) {
    this._head = null, t(e4) || (this._head = new a2(e4));
  }
  get head() {
    return this._head;
  }
  maxAvailableSpace() {
    if (t(this._head))
      return 0;
    const a6 = this._head.max((t2) => t2.end - t2.start);
    return a6.data.end - a6.data.start;
  }
  firstFit(a6) {
    if (t(this._head))
      return null;
    let e4 = null, n7 = this._head;
    for (; n7; ) {
      const t2 = n7.data.end - n7.data.start;
      if (t2 === a6)
        return e4 ? e4.next = n7.next : this._head = n7.next, n7.data.start;
      if (t2 > a6) {
        const t3 = n7.data.start;
        return n7.data.start += a6, t3;
      }
      e4 = n7, n7 = n7.next;
    }
    return null;
  }
  free(e4, n7) {
    const r3 = e4 + n7;
    if (t(this._head)) {
      const t2 = new a2({ start: e4, end: r3 });
      return void (this._head = t2);
    }
    if (r3 <= this._head.data.start) {
      if (r3 === this._head.data.start)
        return void (this._head.data.start -= n7);
      const t2 = new a2({ start: e4, end: r3 });
      return t2.next = this._head, void (this._head = t2);
    }
    let s2 = this._head, d2 = s2.next;
    for (; d2; ) {
      if (d2.data.start >= r3) {
        if (s2.data.end === e4) {
          if (s2.data.end += n7, s2.data.end === d2.data.start) {
            const t3 = d2.data.end - d2.data.start;
            return s2.data.end += t3, void (s2.next = d2.next);
          }
          return;
        }
        if (d2.data.start === r3)
          return void (d2.data.start -= n7);
        const t2 = new a2({ start: e4, end: r3 });
        return t2.next = s2.next, void (s2.next = t2);
      }
      s2 = d2, d2 = d2.next;
    }
    if (e4 === s2.data.end)
      return void (s2.data.end += n7);
    const i5 = new a2({ start: e4, end: r3 });
    s2.next = i5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureDisplayList.js
var n4 = class {
  constructor(t2, e4, i5, n7, a6) {
    this.target = t2, this.geometryType = e4, this.materialKey = i5, this.indexFrom = n7, this.indexCount = a6;
  }
  get indexEnd() {
    return this.indexFrom + this.indexCount;
  }
  extend(t2) {
    this.indexCount += t2;
  }
};
var a3 = class {
  constructor(t2, e4) {
    this.geometryType = 0, this._target = t2, this.geometryType = e4;
  }
  static from(e4, i5, n7, d2) {
    const r3 = new a3(e4, i5);
    if (r(d2))
      for (const t2 of d2)
        n7.seekIndex(t2), r3.addRecord(n7);
    else
      for (; n7.next(); )
        r3.addRecord(n7);
    return r3;
  }
  addRecord(t2) {
    const a6 = this._target, d2 = this.geometryType, r3 = t2.materialKey;
    let s2 = t2.indexFrom, o7 = t2.indexCount;
    const h2 = t2.vertexFrom, x = t2.vertexCount;
    if (o7 || (s2 = h2, o7 = x), t(this._head)) {
      const t3 = new n4(a6, d2, r3, s2, o7);
      return void (this._head = new a2(t3));
    }
    let m2 = null, c7 = this._head;
    for (; c7; ) {
      if (s2 < c7.data.indexFrom)
        return this._insert(r3, s2, o7, m2, c7);
      m2 = c7, c7 = c7.next;
    }
    this._insert(r3, s2, o7, m2, null);
  }
  forEach(e4) {
    r(this._head) && this._head.forEach(e4);
  }
  *infos() {
    if (r(this._head))
      for (const t2 of this._head.values())
        yield t2;
  }
  _insert(a6, d2, r3, s2, o7) {
    if (t(s2) && t(o7)) {
      const t2 = new n4(this._target, this.geometryType, a6, d2, r3);
      this._head = new a2(t2);
    }
    return t(s2) && r(o7) ? this._insertAtHead(a6, d2, r3, o7) : r(s2) && t(o7) ? this._insertAtEnd(a6, d2, r3, s2) : r(s2) && r(o7) ? this._insertAtMiddle(a6, d2, r3, s2, o7) : void 0;
  }
  _insertAtHead(t2, e4, a6, d2) {
    const r3 = e4 + a6;
    if (t2 === d2.data.materialKey && r3 === d2.data.indexFrom)
      d2.data.indexFrom = e4, d2.data.indexCount += a6;
    else {
      const r4 = new n4(this._target, this.geometryType, t2, e4, a6);
      this._head = new a2(r4), this._head.next = d2;
    }
  }
  _insertAtEnd(t2, e4, a6, d2) {
    if (d2.data.materialKey === t2 && d2.data.indexEnd === e4)
      d2.data.indexCount += a6;
    else {
      const r3 = new n4(this._target, this.geometryType, t2, e4, a6), s2 = new a2(r3);
      d2.next = s2;
    }
  }
  _insertAtMiddle(t2, e4, a6, d2, r3) {
    const s2 = e4 + a6;
    if (d2.data.materialKey === t2 && d2.data.indexEnd === e4)
      d2.data.indexCount += a6, d2.data.materialKey === r3.data.materialKey && d2.data.indexEnd === r3.data.indexFrom && (d2.data.indexCount += r3.data.indexCount, d2.next = r3.next);
    else if (t2 === r3.data.materialKey && s2 === r3.data.indexFrom)
      r3.data.indexFrom = e4, r3.data.indexCount += a6;
    else {
      const s3 = new n4(this._target, this.geometryType, t2, e4, a6), o7 = new a2(s3);
      d2.next = o7, o7.next = r3;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/BufferPool.js
var i4 = a("esri-2d-log-allocations");
var n5 = class {
  constructor(t2) {
    this._array = t2;
  }
  get array() {
    return this._array;
  }
  get length() {
    return this._array.length;
  }
  static create(t2) {
    const e4 = _.acquire(t2);
    return new n5(e4);
  }
  expand(t2) {
    const e4 = _.acquire(t2);
    e4.set(this._array), _.release(this._array), this._array = e4;
  }
  destroy() {
    _.release(this._array);
  }
  set(t2, e4) {
    this._array.set(t2._array, e4);
  }
  slice() {
    const t2 = _.acquire(this._array.byteLength);
    return t2.set(this._array), new n5(t2);
  }
};
var o6 = class {
  constructor() {
    this._data = new ArrayBuffer(o6.BYTE_LENGTH), this._freeList = new e3({ start: 0, end: this._data.byteLength });
  }
  static get BYTE_LENGTH() {
    return 64e6;
  }
  get buffer() {
    return this._data;
  }
  allocate(t2) {
    const e4 = this._freeList.firstFit(t2);
    return t(e4) ? null : new Uint32Array(this._data, e4, t2 / Uint32Array.BYTES_PER_ELEMENT);
  }
  free(t2) {
    this._freeList.free(t2.byteOffset, t2.byteLength);
  }
};
var c4 = class {
  constructor() {
    this._bytesAllocated = 0, this._pages = [], this._pagesByBuffer = /* @__PURE__ */ new Map(), this._addPage();
  }
  get _bytesTotal() {
    return this._pages.length * o6.BYTE_LENGTH;
  }
  acquire(t2) {
    if (this._bytesAllocated += t2, i4 && console.log(`Allocating ${t2}, (${this._bytesAllocated} / ${this._bytesTotal})`), t2 > o6.BYTE_LENGTH)
      return new Uint32Array(t2 / Uint32Array.BYTES_PER_ELEMENT);
    for (const r3 of this._pages) {
      const s2 = r3.allocate(t2);
      if (r(s2))
        return s2;
    }
    return f(this._addPage().allocate(t2), "Expected to allocate page");
  }
  release(t2) {
    this._bytesAllocated -= t2.byteLength, i4 && console.log(`Freeing ${t2.byteLength}, (${this._bytesAllocated} / ${this._bytesTotal})`);
    const e4 = this._pagesByBuffer.get(t2.buffer);
    e4 && e4.free(t2);
  }
  _addPage() {
    const t2 = new o6();
    return this._pages.push(t2), this._pagesByBuffer.set(t2.buffer, t2), t2;
  }
};
var _ = new c4();

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Buffer.js
var a4 = 1.25;
var u2 = 32767;
var d = u2 << 16 | u2;
var f4 = class {
  constructor(t2, i5, e4) {
    const s2 = n5.create(i5 * e4 * Uint32Array.BYTES_PER_ELEMENT);
    this.size = i5, this.strideInt = e4, this.bufferType = t2, this.dirty = { start: 1 / 0, end: 0 }, this._gpu = null, this._cpu = s2, this.clear();
  }
  get elementSize() {
    return this._cpu.length / this.strideInt;
  }
  get invalidated() {
    return this.bufferSize && !this._gpu;
  }
  get invalidatedComputeBuffer() {
    return this.bufferSize && !this._gpuComputeTriangles;
  }
  invalidate() {
    this._invalidateTriangleBuffer(), o(this._gpu, (t2) => t2.dispose()), this._gpu = null;
  }
  _invalidateTriangleBuffer() {
    o(this._gpuComputeTriangles, (t2) => t2.dispose()), this._gpuComputeTriangles = null;
  }
  destroy() {
    o(this._gpu, (t2) => t2.dispose()), o(this._gpuComputeTriangles, (t2) => t2.dispose()), o(this._cpu, (t2) => t2.destroy()), o(this._cpu2, (t2) => t2.destroy());
  }
  clear() {
    this.dirty.start = 1 / 0, this.dirty.end = 0, this.freeList = new e3({ start: 0, end: this._cpu.length / this.strideInt }), this.fillPointer = 0;
  }
  ensure(t2) {
    if (this.maxAvailableSpace() >= t2)
      return;
    if (t2 * this.strideInt > this._cpu.length - this.fillPointer) {
      this.invalidate();
      const i5 = this._cpu.length / this.strideInt, e4 = Math.round((i5 + t2) * a4), r3 = e4 * this.strideInt;
      this._cpu.expand(r3 * Uint32Array.BYTES_PER_ELEMENT), this.freeList.free(i5, e4 - i5);
    }
  }
  set(t2, i5) {
    this._cpu.array[t2] !== i5 && (this._cpu.array[t2] = i5, this.dirty.start = Math.min(t2, this.dirty.start), this.dirty.end = Math.max(t2, this.dirty.end));
  }
  getGPUBuffer(t2, e4 = false) {
    if (!this.bufferSize)
      return null;
    if (e4) {
      if ("index" !== this.bufferType)
        throw new Error("Tired to get triangle buffer, but target is not an index buffer");
      return t(this._gpuComputeTriangles) && (this._gpuComputeTriangles = this._createComputeBuffer(t2)), this._gpuComputeTriangles;
    }
    return t(this._gpu) && (this._gpu = this._createBuffer(t2)), this._gpu;
  }
  getCPUBuffer() {
    if (!this._cpu2) {
      const t2 = this._cpu.slice();
      this._cpu2 = t2;
    }
    return this._cpu2.length !== this._cpu.length && this._cpu2.expand(this._cpu.length * this._cpu.array.BYTES_PER_ELEMENT), this._cpu2.set(this._cpu), this._cpu2;
  }
  get bufferSize() {
    return this._cpu.length / this.strideInt;
  }
  maxAvailableSpace() {
    return this.freeList.maxAvailableSpace();
  }
  insert(t2, i5, r3, s2) {
    const h2 = r3 * this.strideInt;
    if (!h2)
      return 0;
    const n7 = i5 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, a6 = new Uint32Array(t2, n7, h2), u4 = f(this.freeList.firstFit(r3), "First fit region must be defined") * this.strideInt, d2 = h2, f6 = u4 / this.strideInt - i5;
    if (0 !== s2)
      for (let e4 = 0; e4 < a6.length; e4++)
        a6[e4] += s2;
    return this._cpu.array.set(a6, u4), this.dirty.start = Math.min(this.dirty.start, u4), this.dirty.end = Math.max(this.dirty.end, u4 + d2), this.fillPointer = Math.max(this.fillPointer, u4 + d2), f6;
  }
  free(t2, i5, e4) {
    const r3 = t2 * this.strideInt, s2 = (t2 + i5) * this.strideInt;
    if (true === e4)
      for (let h2 = t2; h2 !== t2 + i5; h2++)
        this._cpu.array[h2 * this.strideInt] = d;
    this.dirty.start = Math.min(this.dirty.start, r3), this.dirty.end = Math.max(this.dirty.end, s2), this.freeList.free(t2, i5);
  }
  upload() {
    if (this.dirty.end) {
      if (this._invalidateTriangleBuffer(), t(this._gpu))
        return this.dirty.start = 1 / 0, void (this.dirty.end = 0);
      this._gpu.setSubDataFromView(this._cpu.array, this.dirty.start, this.dirty.start, this.dirty.end), this.dirty.start = 1 / 0, this.dirty.end = 0;
    }
  }
  _createBuffer(t2) {
    const i5 = F.DYNAMIC_DRAW;
    return "index" === this.bufferType ? c2.createIndex(t2, i5, this._cpu.array) : c2.createVertex(t2, i5, this._cpu.array);
  }
  _createComputeBuffer(t2) {
    const i5 = F.DYNAMIC_DRAW, e4 = new Uint32Array(this.fillPointer / 3);
    for (let r3 = 0; r3 < this.fillPointer; r3 += 3)
      e4[r3 / 3] = this._cpu.array[r3];
    return c2.createIndex(t2, i5, e4);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Geometry.js
var h = 0;
var u3 = 1;
var c5 = class {
  constructor(e4, t2) {
    this._vaos = /* @__PURE__ */ new Map(), this._indicesInvalid = false, this.geometryType = e4;
  }
  destroy() {
    for (const [t2, r3] of this._vaos)
      r(r3) && r3.dispose(false);
    this._indexBuffer = l(this._indexBuffer), this._vertexBuffer = l(this._vertexBuffer);
  }
  insert(e4, t2, i5) {
    if (!e4.records.byteLength)
      return;
    const s2 = e4.stride;
    if (this._vertexBuffer && this._indexBuffer) {
      const i6 = e4.indices.byteLength / 4, f6 = e4.vertices.byteLength / s2;
      this._indexBuffer.ensure(i6), this._vertexBuffer.ensure(f6);
      const { vertices: n7, indices: d2 } = e4, h2 = i.from(e4.records), u4 = this._vertexBuffer.insert(n7, 0, n7.byteLength / s2, 0), c7 = this._indexBuffer.insert(d2, 0, d2.byteLength / 4, u4);
      if (h2.forEach((e5) => {
        e5.indexFrom += c7, e5.vertexFrom += u4;
      }), f(this._records, "Expected records to be defined").link(h2), t2)
        this._indicesInvalid = true;
      else if (this._displayList) {
        const e5 = h2.getCursor();
        for (; e5.next(); )
          this._displayList.addRecord(e5);
      }
    } else {
      const r3 = e4.indices.byteLength / 4, i6 = e4.vertices.byteLength / s2, f6 = s2 / Uint32Array.BYTES_PER_ELEMENT;
      this._records = i.from(e4.records), this._indexBuffer = new f4("index", r3, 1), this._vertexBuffer = new f4("vertex", i6, f6), this._indexBuffer.insert(e4.indices, 0, e4.indices.byteLength / 4, 0), this._vertexBuffer.insert(e4.vertices, 0, e4.vertices.byteLength / s2, 0), t2 && (this._indicesInvalid = true);
    }
  }
  remove(e4) {
    if (!t(this._records))
      for (const t2 of e4) {
        const e5 = this._records.getCursor();
        if (!e5.lookup(t2))
          continue;
        const r3 = e5.indexFrom, i5 = e5.vertexFrom;
        let s2 = e5.indexCount, f6 = e5.vertexCount;
        for (; e5.next() && e5.id === t2; )
          s2 += e5.indexCount, f6 += e5.vertexCount;
        this._indexBuffer.free(r3, s2), this._vertexBuffer.free(i5, f6, true), this._records.delete(t2);
      }
  }
  getVAO(e4, t2, r3, f6) {
    if (!this._vertexBuffer || !this._indexBuffer || t(this._records) || !this._vertexBuffer.bufferSize)
      return null;
    const n7 = f6 ? u3 : h;
    let o7 = this._vaos.get(n7);
    (this._vertexBuffer.invalidated || this._indexBuffer.invalidated || f6 && this._indexBuffer.invalidatedComputeBuffer) && (o(o7, (e5) => e5.dispose(false)), o7 = null), this._vertexBuffer.upload(), this._indexBuffer.upload();
    const c7 = this._indexBuffer.getGPUBuffer(e4, 1 === n7), _2 = this._vertexBuffer.getGPUBuffer(e4);
    return o7 || (o7 = new f3(e4, r3, t2, { geometry: _2 }, c7), this._vaos.set(n7, o7)), o7;
  }
  forEachCommand(e4) {
    if (!t(this._records)) {
      if (this._sortIndices(this._records), !this._displayList) {
        const e5 = this._cursorIndexOrder;
        this._displayList = a3.from(this, this.geometryType, this._records.getCursor(), e5);
      }
      this._displayList.forEach(e4);
    }
  }
  _sortIndices(e4) {
    const t2 = !!this._indexBuffer.bufferSize;
    if (!this._indicesInvalid)
      return;
    this._indicesInvalid = false;
    let r3 = 0;
    const i5 = e4.getCursor(), s2 = [], f6 = [], n7 = [];
    for (; i5.next(); )
      f6.push(i5.index), n7.push(i5.sortKey), s2.push(i5.id);
    f6.sort((e5, t3) => {
      const r4 = n7[t3], i6 = n7[e5];
      return i6 === r4 ? s2[t3] - s2[e5] : r4 - i6;
    });
    const o7 = e4.getCursor(), d2 = t2 ? this._indexBuffer.getCPUBuffer() : this._vertexBuffer.getCPUBuffer();
    for (const h2 of f6) {
      if (!o7.seekIndex(h2))
        throw new Error("Expected to find index");
      if (t2) {
        const { indexFrom: e5, indexCount: t3 } = o7;
        o7.indexFrom = r3;
        for (let i6 = 0; i6 < t3; i6++)
          this._indexBuffer.set(r3++, d2.array[e5 + i6]);
      } else {
        const { vertexFrom: e5, vertexCount: t3 } = o7, i6 = this._vertexBuffer.strideInt, s3 = e5 * i6, f7 = s3 + t3 * i6;
        o7.vertexFrom = r3 / i6;
        for (let n8 = s3; n8 < f7; n8++)
          this._vertexBuffer.set(r3++, d2.array[n8]);
      }
    }
    this._cursorIndexOrder = f6, this._displayList = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureTile.js
var l2 = 50;
var f5 = 4;
var S = 100;
var g2 = 0;
var y = class extends c3 {
  constructor(t2, r3, s2, i5, a6) {
    super(t2, r3, s2), this.instanceId = g2++, this.patchCount = 0, this._renderState = { current: { geometry: /* @__PURE__ */ new Map(), metrics: null }, next: null, swap: false, swapFrames: 0, locked: false }, this._patches = new s(S), this._bufferPatches = new s(S), this._lastCommitTime = 0, this.transforms.labelMat2d = n2(), this._store = i5, this._requestLabelUpdate = a6;
  }
  destroy() {
    super.destroy(), this._renderState.current.geometry.forEach((e4) => e4.destroy());
  }
  get labelMetrics() {
    return this._renderState.current.metrics;
  }
  get hasData() {
    return !!this._renderState.current.geometry.size;
  }
  getGeometry(e4) {
    return this._renderState.current.geometry.get(e4);
  }
  setTransform(e4, t2) {
    super.setTransform(e4, t2);
    const r3 = this.transforms.labelMat2d, s2 = e4.getScreenTransform(r3, t2), i5 = n3();
    z(i5, [this.x, this.y], s2), f2(r3, i5), o2(r3, e4.viewMat2d, r3);
  }
  patch(e4, r3) {
    this.patchCount++, a("esri-2d-update-debug") && true === e4.clear && console.debug(this.key.id, "FeatureTile:patch:clear", e4.clear), e4.clear && this._patches.size >= l2 && this._dropPatches();
    const s2 = e4, i5 = s2.addOrUpdate && this.key.id !== s2.addOrUpdate.tileKeyOrigin;
    r3 && i5 ? this._bufferPatches.enqueue(s2) : (s2.sort = s2.sort && !r3, this._patches.enqueue(s2)), this.requestRender();
  }
  commit(e4) {
    if (this._lastCommitTime !== e4.time) {
      this._lastCommitTime = e4.time;
      for (let e5 = 0; e5 < f5; e5++)
        this._updateMesh(), this.isReady && this._updateBufferMesh();
      this._renderState.swap && (this._swapRenderStates(), this.requestRender());
    }
  }
  lock() {
    this._renderState.locked = true;
  }
  unlock() {
    this._renderState.locked = false, this._flushUpdates(), this._swap();
  }
  _swapRenderStates() {
    if (this._renderState.next) {
      if (this._renderState.locked)
        return this._renderState.swap = true, void this.requestRender();
      this._renderState.swap = true, this._swap();
    }
  }
  _swap() {
    this._renderState.swap && (this._renderState.swap = false, r(this._renderState.next) && (this._renderState.current.geometry.forEach((e4) => e4.destroy()), this._renderState.current = this._renderState.next, this._renderState.next = null, this._requestLabelUpdate()));
  }
  _flushUpdates() {
    let e4 = this._patches.maxSize;
    for (; this._patches.size && e4--; )
      this._updateMesh(), this._swap();
  }
  _updateBufferMesh() {
    const e4 = this._bufferPatches.peek();
    if (!r(e4) || !e4.clear || null === this._renderState.next)
      for (; this._bufferPatches.size; ) {
        const e5 = this._bufferPatches.dequeue();
        r(e5) && this._patchBuffer(e5);
      }
  }
  _updateMesh() {
    const e4 = this._patches.dequeue();
    r(e4) && (true === e4.clear && (r(this._renderState.next) && (this._renderState.next.geometry.forEach((e5) => e5.destroy()), this._renderState.next = null), this._renderState.next = { geometry: /* @__PURE__ */ new Map(), metrics: null }, a("esri-2d-update-debug") && console.debug(this.key.id, "FeatureTile:_updateMesh - Creating new renderState")), this.requestRender(), this._patch(e4), e4.end && (a("esri-2d-update-debug") && console.debug(this.key.id, "FeatureTile:_updateMesh - Encountered end message"), this.ready(), this._swapRenderStates()));
  }
  _patch(e4) {
    he((t2) => {
      this._remove(t2, e4.remove), this._insert(t2, e4, false);
    });
  }
  _patchBuffer(e4) {
    he((t2) => {
      this._insert(t2, e4, true);
    });
  }
  _insert(e4, r3, a6) {
    var _a;
    try {
      const n7 = c(this._renderState.next, this._renderState.current), h2 = (_a = r3.addOrUpdate) == null ? void 0 : _a.data[e4], d2 = n7.geometry;
      if (t(h2))
        return;
      d2.has(e4) || (a("esri-2d-update-debug") && console.debug(this.key.id, `FeatureTile:_insert - Creating geometry buffer ${e4}`), d2.set(e4, new c5(e4, this.stage))), a("esri-2d-update-debug") && console.debug(this.key.id, `FeatureTile:_insert - Inserting into ${e4}, version=${r3.addOrUpdate.version} stride=${h2.stride}`), d2.get(e4).insert(h2, r3.sort, a6), e4 === E.LABEL && this._insertLabelMetrics(r3.type, h2.metrics, r3.clear);
    } catch (n7) {
    }
  }
  _insertLabelMetrics(e4, t2, r3) {
    const a6 = c(this._renderState.next, this._renderState.current);
    if (t(t2))
      return;
    const n7 = o5.from(t2);
    if (t(a6.metrics))
      a6.metrics = n7;
    else {
      if ("update" === e4) {
        const e5 = n7.getCursor();
        for (; e5.next(); )
          a6.metrics.delete(e5.id);
      }
      a6.metrics.link(n7);
    }
  }
  _remove(e4, t2) {
    const r3 = c(this._renderState.next, this._renderState.current).geometry.get(e4);
    t2 && t2.length && r3 && (r3.remove(t2), this._removeLabelMetrics(t2));
  }
  _removeLabelMetrics(e4) {
    const { metrics: t2 } = c(this._renderState.next, this._renderState.current);
    if (!t(t2) && e4.length)
      for (const r3 of e4)
        for (; t2.delete(r3); )
          ;
  }
  _dropPatches() {
    const e4 = new Array();
    let t2 = false;
    for (; this._patches.size; ) {
      const r3 = this._patches.dequeue();
      if (t(r3))
        break;
      if (r3.clear) {
        if (t2)
          break;
        t2 = true;
      }
      e4.push(r3);
    }
    this._patches.clear(), e4.forEach((e5) => this._patches.enqueue(e5));
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/support/WGLFeatureView.js
var a5 = a("featurelayer-order-by-server-enabled");
var n6 = class extends o3 {
  constructor(e4, t2, i5, s2) {
    super(e4), this._pointToCallbacks = [], this._layer = i5, this._layerView = t2, this._onUpdate = s2;
  }
  renderChildren(e4) {
    if (this.attributeView.update(), this.hasAnimation) {
      e4.painter.effects.integrate.draw(e4, e4.attributeView);
    }
    super.renderChildren(e4);
  }
  hasEmptyAttributeView() {
    return this.attributeView.isEmpty();
  }
  isUpdating() {
    return this.attributeView.isUpdating();
  }
  hitTest(e4) {
    const i5 = D();
    return this._pointToCallbacks.push({ point: e4, resolver: i5 }), this.requestRender(), i5.promise;
  }
  onTileData(e4, t2) {
    const i5 = a5 && "orderBy" in this._layer && this._layer.orderBy, s2 = (i5 == null ? void 0 : i5.length) && !i5[0].valueExpression && i5[0].field, r3 = i5 && this._layerView.orderByFields === s2;
    e4.patch(t2, r3), this.contains(e4) || this.addChild(e4), this.requestRender();
  }
  onTileError(e4) {
    this.contains(e4) || this.addChild(e4);
  }
  updateTransitionProperties(e4, t2) {
    super.updateTransitionProperties(e4, t2), this._layerView.featureEffectView.transitionStep(e4, t2), this._layerView.featureEffectView.transitioning && this.requestRender();
  }
  doRender(e4) {
    const { minScale: t2, maxScale: i5 } = this._layer, s2 = e4.state.scale;
    s2 <= (t2 || 1 / 0) && s2 >= i5 && super.doRender(e4);
  }
  onAttributeStoreUpdate() {
    this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this._onUpdate();
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  setStencilReference(e4) {
    const { rendererSchema: t2 } = e4.rendererInfo;
    if ("dot-density" === t2.type && t2.dotSize > 1) {
      const e5 = 1;
      for (const t3 of this.children)
        t3.stencilRef = t3.key.level + e5;
    } else
      super.setStencilReference(e4);
  }
  get hasLabels() {
    if ("sublayers" in this._layer)
      return this._layer.sublayers.some((e5) => e5.labelingInfo && e5.labelingInfo.length && e5.labelsVisible);
    const e4 = this._layer.featureReduction, t2 = e4 && "labelingInfo" in e4 && e4.labelsVisible && e4.labelingInfo && e4.labelingInfo.length;
    return this._layer.labelingInfo && this._layer.labelingInfo.length && this._layer.labelsVisible || !!t2;
  }
  prepareRenderPasses(e4) {
    const t2 = e4.registerRenderPass({ name: "label", brushes: [W.label], target: () => this.hasLabels ? this.children : null, drawPhase: I.LABEL | I.LABEL_ALPHA }), s2 = e4.registerRenderPass({ name: "geometry", brushes: [W.fill, W.dotDensity, W.line, W.marker, W.heatmap, W.pieChart, W.text], target: () => this.children, enableDefaultDraw: () => !this._layerView.featureEffectView.hasEffects, effects: [{ apply: e4.effects.outsideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.excludedEffects }, { apply: e4.effects.insideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.includedEffects }, { apply: e4.effects.hittest, enable: () => !!this._pointToCallbacks.length, args: () => this._pointToCallbacks }] }), a6 = e4.registerRenderPass({ name: "highlight", brushes: [W.fill, W.dotDensity, W.line, W.marker, W.pieChart, W.text], target: () => this.children, drawPhase: I.HIGHLIGHT, enableDefaultDraw: () => false, effects: [{ apply: e4.effects.highlight, enable: () => !!this._layerView.hasHighlight() }] });
    return [...super.prepareRenderPasses(e4), s2, a6, t2];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/SymbolTileRenderer.js
var p = class extends o4 {
  constructor() {
    super(...arguments), this.type = "symbol";
  }
  install(e4) {
    const t2 = () => this.notifyChange("updating"), i5 = new n6(this.tileInfoView, this.layerView, this.layer, t2);
    this.featuresView = i5, e4.addChild(i5);
  }
  uninstall(e4) {
    e4.removeChild(this.featuresView), this.featuresView.destroy(), this.featuresView = null;
  }
  fetchResource(e4, t2) {
    const { url: s2 } = e4, r3 = this.featuresView.stage;
    try {
      return r3.resourceManager.fetchResource(s2, { signal: t2.signal });
    } catch (a6) {
      return g(a6) ? Promise.resolve({ width: 0, height: 0 }) : Promise.reject(a6);
    }
  }
  isUpdating() {
    var _a;
    const e4 = super.isUpdating(), i5 = !this.featuresView || this.featuresView.isUpdating(), s2 = (_a = this.featuresView) == null ? void 0 : _a.hasEmptyAttributeView(), r3 = e4 || i5 || e4 && s2;
    return a("esri-2d-log-updating") && console.log(`Updating SymbolTileRenderer ${r3}
  -> updatingTiles ${e4}
  -> hasFeaturesView ${!!this.featuresView}
  -> updatingFeaturesView ${i5}`), r3;
  }
  hitTest(e4) {
    return this.featuresView.hitTest(e4);
  }
  supportsRenderer(e4) {
    return null != e4 && ["simple", "class-breaks", "unique-value", "dot-density", "dictionary", "heatmap", "pie-chart"].includes(e4.type);
  }
  onConfigUpdate(e4) {
    let t2 = null;
    if ("visualVariables" in e4) {
      const i5 = (i2(e4).visualVariables || []).map((e5) => {
        const t3 = e5.clone();
        return "normalizationField" in e5 && (t3.normalizationField = null), e5.valueExpression && "$view.scale" !== e5.valueExpression && (t3.valueExpression = null, t3.field = "nop"), t3;
      });
      t2 = m(i5);
    }
    this.featuresView.setRendererInfo(e4, t2, this.layerView.featureEffect);
  }
  onTileData(e4) {
    const t2 = this.tiles.get(e4.tileKey);
    t2 && e4.data && this.featuresView.onTileData(t2, e4.data), this.layerView.view.labelManager.requestUpdate();
  }
  onTileError(e4) {
    const t2 = this.tiles.get(e4.tileKey);
    t2 && this.featuresView.onTileError(t2);
  }
  forceAttributeTextureUpload() {
    this.featuresView.attributeView.forceTextureUpload();
  }
  lockGPUUploads() {
    this.featuresView.attributeView.lockTextureUpload(), this.tiles.forEach((e4) => e4.lock());
  }
  unlockGPUUploads() {
    this.featuresView.attributeView.unlockTextureUpload(), this.tiles.forEach((e4) => e4.unlock());
  }
  async getMaterialItems(e4) {
    return this.featuresView.getMaterialItems(e4);
  }
  invalidateLabels() {
    this.featuresView.hasLabels && this.layerView.view.labelManager.requestUpdate();
  }
  createTile(e4) {
    const t2 = this.tileInfoView.getTileBounds(u(), e4), i5 = () => this.layerView.view.labelManager.requestUpdate();
    return new y(e4, t2[0], t2[3], this.featuresView.attributeView, i5);
  }
  disposeTile(e4) {
    this.featuresView.removeChild(e4), e4.destroy(), this.layerView.view.labelManager.requestUpdate();
  }
};
p = e([n("esri.views.2d.layers.features.tileRenderers.SymbolTileRenderer")], p);
var c6 = p;
export {
  c6 as default
};
//# sourceMappingURL=SymbolTileRenderer-XGGOYJX6.js.map
