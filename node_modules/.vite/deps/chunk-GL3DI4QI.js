import {
  o
} from "./chunk-4OFLHC3C.js";
import {
  i as i2
} from "./chunk-DSCM4HDL.js";
import {
  b
} from "./chunk-YZNDHJDJ.js";
import {
  An,
  Hn,
  rn
} from "./chunk-PZWU5EHT.js";
import {
  J
} from "./chunk-6O2ARNGD.js";
import {
  x as x2
} from "./chunk-LJLQIETB.js";
import {
  U,
  l
} from "./chunk-T7BEWVV3.js";
import {
  n as n3
} from "./chunk-OIPX3EDD.js";
import {
  d as d2,
  i,
  u
} from "./chunk-NWRK6QLX.js";
import {
  x
} from "./chunk-PKZEO23A.js";
import {
  n as n2
} from "./chunk-AIRC226G.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/interactive/GraphicManipulator.js
var C = class extends y {
  constructor(e2) {
    super(e2), this.layer = null, this.interactive = true, this.selectable = false, this.grabbable = true, this.dragging = false, this.cursor = null, this.events = new n3.EventEmitter(), this._circleCollisionCache = null, this._graphicSymbolChangedHandle = null, this._originalSymbol = null;
  }
  set graphic(e2) {
    this._circleCollisionCache = null, this._originalSymbol = e2.symbol, this._set("graphic", e2), this.attachSymbolChanged();
  }
  get elevationInfo() {
    const e2 = "elevationInfo" in this.graphic.layer && this.graphic.layer.elevationInfo, t2 = i2(this.graphic), i3 = e2 ? e2.offset : 0;
    return new x2({ mode: t2, offset: i3 });
  }
  set focusedSymbol(e2) {
    e2 !== this._get("focusedSymbol") && (this._set("focusedSymbol", e2), this._updateGraphicSymbol(), this._circleCollisionCache = null);
  }
  grabbableForEvent() {
    return true;
  }
  set grabbing(e2) {
    e2 !== this._get("grabbing") && (this._set("grabbing", e2), this._updateGraphicSymbol());
  }
  set hovering(e2) {
    e2 !== this._get("hovering") && (this._set("hovering", e2), this._updateGraphicSymbol());
  }
  set selected(e2) {
    e2 !== this._get("selected") && (this._set("selected", e2), this._updateGraphicSymbol(), this.events.emit("select-changed", { action: e2 ? "select" : "deselect" }));
  }
  get _focused() {
    return this._get("hovering") || this._get("grabbing");
  }
  destroy() {
    this.detachSymbolChanged(), this._resetGraphicSymbol(), this._set("view", null);
  }
  intersectionDistance(e2) {
    const t2 = this.graphic;
    if (false === t2.visible)
      return null;
    const i3 = t2.geometry;
    if (t(i3))
      return null;
    const r2 = this._get("focusedSymbol"), l2 = r(r2) ? r2 : t2.symbol;
    return "2d" === this.view.type ? this._intersectDistance2D(this.view, e2, i3, l2) : this._intersectDistance3D(this.view, e2, t2);
  }
  attach() {
    this.attachSymbolChanged(), r(this.layer) && this.layer.add(this.graphic);
  }
  detach() {
    this.detachSymbolChanged(), this._resetGraphicSymbol(), r(this.layer) && this.layer.remove(this.graphic);
  }
  attachSymbolChanged() {
    this.detachSymbolChanged(), this._graphicSymbolChangedHandle = l(() => {
      var _a;
      return (_a = this.graphic) == null ? void 0 : _a.symbol;
    }, (e2) => {
      r(e2) && e2 !== this.focusedSymbol && e2 !== this._originalSymbol && (this._originalSymbol = e2, this._focused && r(this.focusedSymbol) && (this.graphic.symbol = this.focusedSymbol));
    }, U);
  }
  detachSymbolChanged() {
    r(this._graphicSymbolChangedHandle) && (this._graphicSymbolChangedHandle.remove(), this._graphicSymbolChangedHandle = null);
  }
  _updateGraphicSymbol() {
    this.graphic.symbol = this._focused && r(this.focusedSymbol) ? this.focusedSymbol : this._originalSymbol;
  }
  _resetGraphicSymbol() {
    this.graphic.symbol = this._originalSymbol;
  }
  _intersectDistance2D(e2, t2, i3, r2) {
    if (r2 = r2 || J(i3), t(r2))
      return null;
    const l2 = 1;
    let c = this._circleCollisionCache;
    if ("point" !== i3.type || "simple-marker" !== r2.type)
      return o(t2, i3, e2) ? l2 : null;
    if (t(c) || !c.originalPoint.equals(i3)) {
      const t3 = i3, o2 = e2.spatialReference;
      if (An(t3.spatialReference, o2)) {
        const e3 = rn(t3, o2);
        c = { originalPoint: t3.clone(), mapPoint: e3, radiusPx: u(r2.size) }, this._circleCollisionCache = c;
      }
    }
    if (r(c)) {
      const i4 = d2(t2, D), o2 = e2.toScreen(c.mapPoint), s = c.radiusPx, h = o2.x + u(r2.xoffset), p = o2.y - u(r2.yoffset);
      return b(i4, [h, p]) < s * s ? l2 : null;
    }
    return null;
  }
  _intersectDistance3D(e2, t2, i3) {
    const o2 = e2.toMap(t2, { include: [i3] });
    return o2 && Hn(o2, j, e2.renderSpatialReference) ? x(j, e2.state.camera.eye) : null;
  }
};
e([d({ constructOnly: true, nonNullable: true })], C.prototype, "graphic", null), e([d()], C.prototype, "elevationInfo", null), e([d({ constructOnly: true, nonNullable: true })], C.prototype, "view", void 0), e([d({ value: null })], C.prototype, "focusedSymbol", null), e([d({ constructOnly: true })], C.prototype, "layer", void 0), e([d()], C.prototype, "interactive", void 0), e([d()], C.prototype, "selectable", void 0), e([d()], C.prototype, "grabbable", void 0), e([d({ value: false })], C.prototype, "grabbing", null), e([d()], C.prototype, "dragging", void 0), e([d()], C.prototype, "hovering", null), e([d({ value: false })], C.prototype, "selected", null), e([d()], C.prototype, "cursor", void 0), C = e([n("esri.views.interactive.GraphicManipulator")], C);
var j = n2();
var D = i();

export {
  C
};
//# sourceMappingURL=chunk-GL3DI4QI.js.map
