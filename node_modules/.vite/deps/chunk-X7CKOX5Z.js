import {
  g,
  h as h6
} from "./chunk-7OZR6JFF.js";
import {
  e as e9,
  e2 as e10,
  f as f3,
  o as o8,
  o2 as o9,
  t as t5
} from "./chunk-NXOQBIK7.js";
import {
  A as A2,
  E as E5
} from "./chunk-ERNXFM5T.js";
import {
  i as i7
} from "./chunk-6ITXWFMK.js";
import {
  e as e11
} from "./chunk-SV4VP57N.js";
import {
  L as L3
} from "./chunk-5LWMNFCG.js";
import {
  E as E4,
  _,
  c as c4,
  i as i6,
  l as l3
} from "./chunk-5EXPMKQP.js";
import {
  W,
  a as a3,
  c as c3,
  h as h5
} from "./chunk-B7F3T673.js";
import {
  t as t4
} from "./chunk-QXYW5CVF.js";
import {
  W as W2
} from "./chunk-SQ4XLXZO.js";
import {
  i as i5
} from "./chunk-E3V32BOJ.js";
import {
  V
} from "./chunk-D764DGF2.js";
import {
  c as c5,
  f as f2,
  i as i4
} from "./chunk-B3IXFXV6.js";
import {
  r as r9
} from "./chunk-ODYLXHP4.js";
import {
  l as l2
} from "./chunk-DVE4HUBR.js";
import {
  o as o6
} from "./chunk-OYNEZ5VG.js";
import {
  h as h3
} from "./chunk-TTKSAULB.js";
import {
  o as o5
} from "./chunk-TEJEYVH4.js";
import {
  o as o7
} from "./chunk-HEZ2ATGC.js";
import {
  c as c2,
  e as e8,
  i as i3,
  n2,
  n3,
  n4,
  o as o2,
  o2 as o3,
  o3 as o4,
  r as r6,
  r2 as r7,
  t as t3
} from "./chunk-GKICNYWA.js";
import {
  T
} from "./chunk-3DCTMZI6.js";
import {
  D,
  E as E2,
  I
} from "./chunk-FPMD6IB4.js";
import {
  e2 as e7,
  f,
  r as r5,
  t as t2
} from "./chunk-MOZ4GR2L.js";
import {
  E,
  L as L2,
  O as O2,
  c,
  i as i2,
  u,
  x
} from "./chunk-MQBVOUKB.js";
import {
  a as a2
} from "./chunk-S5PZEGLP.js";
import {
  y
} from "./chunk-MOXYEJRV.js";
import {
  L as L4,
  d2 as d,
  h as h4,
  x as x2
} from "./chunk-EEJIELE6.js";
import {
  E as E3
} from "./chunk-Y55TYMBP.js";
import {
  C,
  N,
  O as O4,
  n as n5
} from "./chunk-MDCKEJ7B.js";
import {
  O as O3
} from "./chunk-VMF4NMEB.js";
import {
  e as e6
} from "./chunk-YFBAFAZ2.js";
import {
  e as e5
} from "./chunk-LUU3J646.js";
import {
  j
} from "./chunk-3NPGGTI6.js";
import {
  l
} from "./chunk-ZN2MGN4S.js";
import {
  r as r8
} from "./chunk-D7AOY7GH.js";
import {
  r as r4
} from "./chunk-U7B2WKBH.js";
import {
  a
} from "./chunk-QKRZMDWG.js";
import {
  h
} from "./chunk-ASC3X65B.js";
import {
  B,
  h as h2
} from "./chunk-TMBOFNWA.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  A,
  L,
  O,
  P,
  e as e4,
  i,
  o,
  q,
  r as r3,
  s as s3,
  z
} from "./chunk-PKZEO23A.js";
import {
  e as e3,
  n,
  r as r2
} from "./chunk-AIRC226G.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  w
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  e as e2,
  m,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechnique.js
var F = class extends f2 {
  constructor() {
    super(...arguments), this.isSchematic = false, this.usePBR = false, this.mrrFactors = r2(0, 1, 0.5), this.hasVertexColors = false, this.hasSymbolColors = false, this.doubleSided = false, this.doubleSidedType = "normal", this.cullFace = n5.Back, this.emissiveFactor = r2(0, 0, 0), this.instancedDoublePrecision = false, this.normals = "default", this.receiveSSAO = true, this.receiveShadows = true, this.castShadows = true, this.shadowMappingEnabled = false, this.ambient = r2(0.2, 0.2, 0.2), this.diffuse = r2(0.8, 0.8, 0.8), this.externalColor = r4(1, 1, 1, 1), this.colorMixMode = "multiply", this.opacity = 1, this.layerOpacity = 1, this.origin = n(), this.hasSlicePlane = false, this.hasSliceHighlight = true, this.offsetTransparentBackfaces = false, this.vvSizeEnabled = false, this.vvSizeMinSize = [1, 1, 1], this.vvSizeMaxSize = [100, 100, 100], this.vvSizeOffset = [0, 0, 0], this.vvSizeFactor = [1, 1, 1], this.vvSizeValue = [1, 1, 1], this.vvColorEnabled = false, this.vvColorValues = [0, 0, 0, 0, 0, 0, 0, 0], this.vvColorColors = [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], this.vvSymbolAnchor = [0, 0, 0], this.vvSymbolRotationMatrix = e5(), this.vvOpacityEnabled = false, this.vvOpacityValues = [], this.vvOpacityOpacities = [], this.transparent = false, this.writeDepth = true, this.customDepthTest = N.Less, this.textureAlphaMode = C.Blend, this.textureAlphaCutoff = o7, this.textureAlphaPremultiplied = false, this.hasOccludees = false, this.renderOccluded = h4.Occlude;
  }
};
var _2 = class extends c5 {
  constructor() {
    super(...arguments), this.origin = n(), this.slicePlaneLocalOrigin = this.origin;
  }
};
var E6 = class extends e9 {
  initializeConfiguration(e12, t7) {
    t7.spherical = e12.viewingMode === l.Global, t7.doublePrecisionRequiresObfuscation = r9(e12.rctx), t7.textureCoordinateType = t7.hasColorTexture || t7.hasMetalnessAndRoughnessTexture || t7.hasEmissionTexture || t7.hasOcclusionTexture || t7.hasNormalTexture ? o6.Default : o6.None;
  }
  initializeProgram(e12) {
    return this._initializeProgram(e12, E6.shader);
  }
  _initializeProgram(e12, t7) {
    const i8 = t7.get().build(this.configuration);
    return new o8(e12.rctx, i8, E3);
  }
  _convertDepthTestFunction(e12) {
    return e12 === N.Lequal ? I.LEQUAL : I.LESS;
  }
  _setPipeline(e12, t7) {
    const i8 = this.configuration, s4 = e12 === O4.NONE, r10 = e12 === O4.FrontFace;
    return W({ blending: i8.output !== o5.Color && i8.output !== o5.Alpha || !i8.transparent ? null : s4 ? c4 : E4(e12), culling: V2(i8) && h5(i8.cullFace), depthTest: { func: l3(e12, this._convertDepthTestFunction(i8.customDepthTest)) }, depthWrite: s4 || r10 ? i8.writeDepth && a3 : null, colorWrite: c3, stencilWrite: i8.hasOccludees ? e10 : null, stencilTest: i8.hasOccludees ? t7 ? o9 : f3 : null, polygonOffset: s4 || r10 ? null : i6(i8.enableOffset) });
  }
  initializePipeline() {
    return this._occludeePipelineState = this._setPipeline(this.configuration.transparencyPassType, true), this._setPipeline(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e12, t7) {
    return t7 ? this._occludeePipelineState : super.getPipelineState(e12, t7);
  }
};
function V2(e12) {
  return e12.cullFace !== n5.None || !e12.hasSlicePlane && (!e12.transparent && !e12.doubleSidedMode);
}
E6.shader = new t5(W2, () => import("./DefaultMaterial.glsl-YBGEYGDT.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechniqueConfiguration.js
var c6 = class extends i7 {
  constructor() {
    super(...arguments), this.output = o5.Color, this.alphaDiscardMode = C.Opaque, this.doubleSidedMode = i5.None, this.pbrMode = l2.Disabled, this.cullFace = n5.None, this.transparencyPassType = O4.NONE, this.normalType = i4.Attribute, this.textureCoordinateType = o6.None, this.customDepthTest = N.Less, this.spherical = false, this.hasVertexColors = false, this.hasSymbolColors = false, this.hasVerticalOffset = false, this.hasSlicePlane = false, this.hasSliceHighlight = true, this.hasColorTexture = false, this.hasMetalnessAndRoughnessTexture = false, this.hasEmissionTexture = false, this.hasOcclusionTexture = false, this.hasNormalTexture = false, this.hasScreenSizePerspective = false, this.hasVertexTangents = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.hasModelTransformation = false, this.offsetBackfaces = false, this.vvSize = false, this.vvColor = false, this.receiveShadows = false, this.receiveAmbientOcclusion = false, this.textureAlphaPremultiplied = false, this.instanced = false, this.instancedColor = false, this.instancedDoublePrecision = false, this.doublePrecisionRequiresObfuscation = false, this.writeDepth = true, this.transparent = false, this.enableOffset = true, this.cullAboveGround = false, this.snowCover = false;
  }
};
e([e11({ count: o5.COUNT })], c6.prototype, "output", void 0), e([e11({ count: C.COUNT })], c6.prototype, "alphaDiscardMode", void 0), e([e11({ count: i5.COUNT })], c6.prototype, "doubleSidedMode", void 0), e([e11({ count: l2.COUNT })], c6.prototype, "pbrMode", void 0), e([e11({ count: n5.COUNT })], c6.prototype, "cullFace", void 0), e([e11({ count: O4.COUNT })], c6.prototype, "transparencyPassType", void 0), e([e11({ count: i4.COUNT })], c6.prototype, "normalType", void 0), e([e11({ count: o6.COUNT })], c6.prototype, "textureCoordinateType", void 0), e([e11({ count: N.COUNT })], c6.prototype, "customDepthTest", void 0), e([e11()], c6.prototype, "spherical", void 0), e([e11()], c6.prototype, "hasVertexColors", void 0), e([e11()], c6.prototype, "hasSymbolColors", void 0), e([e11()], c6.prototype, "hasVerticalOffset", void 0), e([e11()], c6.prototype, "hasSlicePlane", void 0), e([e11()], c6.prototype, "hasSliceHighlight", void 0), e([e11()], c6.prototype, "hasColorTexture", void 0), e([e11()], c6.prototype, "hasMetalnessAndRoughnessTexture", void 0), e([e11()], c6.prototype, "hasEmissionTexture", void 0), e([e11()], c6.prototype, "hasOcclusionTexture", void 0), e([e11()], c6.prototype, "hasNormalTexture", void 0), e([e11()], c6.prototype, "hasScreenSizePerspective", void 0), e([e11()], c6.prototype, "hasVertexTangents", void 0), e([e11()], c6.prototype, "hasOccludees", void 0), e([e11()], c6.prototype, "hasMultipassTerrain", void 0), e([e11()], c6.prototype, "hasModelTransformation", void 0), e([e11()], c6.prototype, "offsetBackfaces", void 0), e([e11()], c6.prototype, "vvSize", void 0), e([e11()], c6.prototype, "vvColor", void 0), e([e11()], c6.prototype, "receiveShadows", void 0), e([e11()], c6.prototype, "receiveAmbientOcclusion", void 0), e([e11()], c6.prototype, "textureAlphaPremultiplied", void 0), e([e11()], c6.prototype, "instanced", void 0), e([e11()], c6.prototype, "instancedColor", void 0), e([e11()], c6.prototype, "instancedDoublePrecision", void 0), e([e11()], c6.prototype, "doublePrecisionRequiresObfuscation", void 0), e([e11()], c6.prototype, "writeDepth", void 0), e([e11()], c6.prototype, "transparent", void 0), e([e11()], c6.prototype, "enableOffset", void 0), e([e11()], c6.prototype, "cullAboveGround", void 0), e([e11()], c6.prototype, "snowCover", void 0), e([e11({ constValue: true })], c6.prototype, "hasVvInstancing", void 0), e([e11({ constValue: false })], c6.prototype, "useCustomDTRExponentForWater", void 0), e([e11({ constValue: false })], c6.prototype, "supportsTextureAtlas", void 0), e([e11({ constValue: true })], c6.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RealisticTreeTechnique.js
var t6 = class extends E6 {
  initializeConfiguration(i8, s4) {
    super.initializeConfiguration(i8, s4), s4.hasMetalnessAndRoughnessTexture = false, s4.hasEmissionTexture = false, s4.hasOcclusionTexture = false, s4.hasNormalTexture = false, s4.hasModelTransformation = false, s4.normalType = i4.Attribute, s4.doubleSidedMode = i5.WindingOrder, s4.hasVertexTangents = false;
  }
  initializeProgram(e12) {
    return this._initializeProgram(e12, t6.shader);
  }
};
t6.shader = new t5(V, () => import("./RealisticTree.glsl-KMUS2OID.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial.js
var R = class extends d {
  constructor(e12) {
    super(e12, _3), this.supportsEdges = true, this.techniqueConfig = new c6(), this.vertexBufferLayout = j2(this.parameters), this.instanceBufferLayout = e12.instanced ? B2(this.parameters) : null;
  }
  isVisibleInPass(e12) {
    return e12 !== A2.MATERIAL_DEPTH_SHADOWMAP_ALL && e12 !== A2.MATERIAL_DEPTH_SHADOWMAP_DEFAULT && e12 !== A2.MATERIAL_DEPTH_SHADOWMAP_HIGHLIGHT || this.parameters.castShadows;
  }
  isVisible() {
    const t7 = this.parameters;
    if (!super.isVisible() || 0 === t7.layerOpacity)
      return false;
    const { instanced: r10, hasVertexColors: s4, hasSymbolColors: i8, vvColorEnabled: a4 } = t7, n6 = r(r10) && r10.includes("color"), o10 = "replace" === t7.colorMixMode, h8 = t7.opacity > 0, c7 = t7.externalColor && t7.externalColor[3] > 0;
    return s4 && (n6 || a4 || i8) ? !!o10 || h8 : s4 ? o10 ? c7 : h8 : n6 || a4 || i8 ? !!o10 || h8 : o10 ? c7 : h8;
  }
  getConfiguration(t7, r10) {
    return this.techniqueConfig.output = t7, this.techniqueConfig.hasNormalTexture = !!this.parameters.normalTextureId, this.techniqueConfig.hasColorTexture = !!this.parameters.textureId, this.techniqueConfig.hasVertexTangents = this.parameters.hasVertexTangents, this.techniqueConfig.instanced = !!this.parameters.instanced, this.techniqueConfig.instancedDoublePrecision = this.parameters.instancedDoublePrecision, this.techniqueConfig.vvSize = this.parameters.vvSizeEnabled, this.techniqueConfig.hasVerticalOffset = r(this.parameters.verticalOffset), this.techniqueConfig.hasScreenSizePerspective = r(this.parameters.screenSizePerspective), this.techniqueConfig.hasSlicePlane = this.parameters.hasSlicePlane, this.techniqueConfig.hasSliceHighlight = this.parameters.hasSliceHighlight, this.techniqueConfig.alphaDiscardMode = this.parameters.textureAlphaMode, this.techniqueConfig.normalType = "screenDerivative" === this.parameters.normals ? i4.ScreenDerivative : i4.Attribute, this.techniqueConfig.transparent = this.parameters.transparent, this.techniqueConfig.writeDepth = this.parameters.writeDepth, r(this.parameters.customDepthTest) && (this.techniqueConfig.customDepthTest = this.parameters.customDepthTest), this.techniqueConfig.hasOccludees = this.parameters.hasOccludees, this.techniqueConfig.cullFace = this.parameters.hasSlicePlane ? n5.None : this.parameters.cullFace, this.techniqueConfig.hasMultipassTerrain = r10.multipassTerrain.enabled, this.techniqueConfig.cullAboveGround = r10.multipassTerrain.cullAboveGround, this.techniqueConfig.hasModelTransformation = r(this.parameters.modelTransformation), t7 !== o5.Color && t7 !== o5.Alpha || (this.techniqueConfig.hasVertexColors = this.parameters.hasVertexColors, this.techniqueConfig.hasSymbolColors = this.parameters.hasSymbolColors, this.parameters.treeRendering ? this.techniqueConfig.doubleSidedMode = i5.WindingOrder : this.techniqueConfig.doubleSidedMode = this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? i5.View : this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ? i5.WindingOrder : i5.None, this.techniqueConfig.instancedColor = r(this.parameters.instanced) && this.parameters.instanced.includes("color"), this.techniqueConfig.receiveShadows = this.parameters.receiveShadows && this.parameters.shadowMappingEnabled, this.techniqueConfig.receiveAmbientOcclusion = !!r10.ssaoHelper.ready && this.parameters.receiveSSAO, this.techniqueConfig.vvColor = this.parameters.vvColorEnabled, this.techniqueConfig.textureAlphaPremultiplied = !!this.parameters.textureAlphaPremultiplied, this.techniqueConfig.pbrMode = this.parameters.usePBR ? this.parameters.isSchematic ? l2.Schematic : l2.Normal : l2.Disabled, this.techniqueConfig.hasMetalnessAndRoughnessTexture = !!this.parameters.metallicRoughnessTextureId, this.techniqueConfig.hasEmissionTexture = !!this.parameters.emissiveTextureId, this.techniqueConfig.hasOcclusionTexture = !!this.parameters.occlusionTextureId, this.techniqueConfig.offsetBackfaces = !(!this.parameters.transparent || !this.parameters.offsetTransparentBackfaces), this.techniqueConfig.transparencyPassType = r10.transparencyPassType, this.techniqueConfig.enableOffset = r10.camera.relativeElevation < _, this.techniqueConfig.snowCover = this.hasSnowCover(r10)), this.techniqueConfig;
  }
  hasSnowCover(t7) {
    return r(t7.weather) && t7.weatherVisible && "snowy" === t7.weather.type && "enabled" === t7.weather.snowCover;
  }
  intersect(c7, u2, p, m2, f4, d2, g2) {
    if (r(this.parameters.verticalOffset)) {
      const e12 = m2.camera;
      o(z2, p[12], p[13], p[14]);
      let c8 = null;
      switch (m2.viewingMode) {
        case l.Global:
          c8 = z(U2, z2);
          break;
        case l.Local:
          c8 = r3(U2, G);
      }
      let u3 = 0;
      const g3 = e4(k, z2, e12.eye), T3 = s3(g3), C2 = q(g3, g3, 1 / T3);
      let v2 = null;
      this.parameters.screenSizePerspective && (v2 = P(c8, C2)), u3 += L4(e12, T3, this.parameters.verticalOffset, v2, this.parameters.screenSizePerspective), q(c8, c8, u3), O(W3, c8, m2.transform.inverseRotation), f4 = e4(V3, f4, W3), d2 = e4(H, d2, W3);
    }
    x2(c7, u2, m2, f4, d2, y(m2.verticalOffset), g2);
  }
  requiresSlot(e12) {
    return e12 === (this.parameters.transparent ? this.parameters.writeDepth ? E5.TRANSPARENT_MATERIAL : E5.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL : E5.OPAQUE_MATERIAL) || e12 === E5.DRAPED_MATERIAL;
  }
  createGLMaterial(e12) {
    return e12.output === o5.Color || e12.output === o5.Alpha || e12.output === o5.Depth || e12.output === o5.Normal || e12.output === o5.Shadow || e12.output === o5.Highlight ? new w2(e12) : null;
  }
  createBufferWriter() {
    return new N2(this.vertexBufferLayout, this.instanceBufferLayout);
  }
};
var w2 = class extends h3 {
  constructor(e12) {
    super({ ...e12, ...e12.material.parameters });
  }
  _updateParameters(e12) {
    const r10 = this._material.parameters;
    this.updateTexture(r10.textureId);
    const s4 = e12.camera.viewInverseTransposeMatrix;
    return o(r10.origin, s4[3], s4[7], s4[11]), this._material.setParameters(this.textureBindParameters), this.ensureTechnique(r10.treeRendering ? t6 : E6, e12);
  }
  _updateShadowState(e12) {
    e12.shadowMap.enabled !== this._material.parameters.shadowMappingEnabled && this._material.setParameters({ shadowMappingEnabled: e12.shadowMap.enabled });
  }
  _updateOccludeeState(e12) {
    e12.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e12.hasOccludees });
  }
  beginSlot(e12) {
    return this._output !== o5.Color && this._output !== o5.Alpha || (this._updateShadowState(e12), this._updateOccludeeState(e12)), this._updateParameters(e12);
  }
};
var D2 = class extends F {
  constructor() {
    super(...arguments), this.initTextureTransparent = false, this.treeRendering = false, this.hasVertexTangents = false;
  }
};
var _3 = new D2();
var N2 = class {
  constructor(e12, t7) {
    this.vertexBufferLayout = e12, this.instanceBufferLayout = t7;
  }
  allocate(e12) {
    return this.vertexBufferLayout.createBuffer(e12);
  }
  elementCount(e12) {
    return e12.indices.get(O3.POSITION).length;
  }
  write(e12, t7, r10, s4) {
    h6(t7, this.vertexBufferLayout, e12.transformation, e12.invTranspTransformation, r10, s4);
  }
};
function j2(e12) {
  const t7 = e12.textureId || e12.normalTextureId || e12.metallicRoughnessTextureId || e12.emissiveTextureId || e12.occlusionTextureId, r10 = T().vec3f(O3.POSITION).vec3f(O3.NORMAL);
  return e12.hasVertexTangents && r10.vec4f(O3.TANGENT), t7 && r10.vec2f(O3.UV0), e12.hasVertexColors && r10.vec4u8(O3.COLOR), e12.hasSymbolColors && r10.vec4u8(O3.SYMBOLCOLOR), r10;
}
function B2(t7) {
  let r10 = T();
  return r10 = t7.instancedDoublePrecision ? r10.vec3f(O3.MODELORIGINHI).vec3f(O3.MODELORIGINLO).mat3f(O3.MODEL).mat3f(O3.MODELNORMAL) : r10.mat4f(O3.MODEL).mat4f(O3.MODELNORMAL), r(t7.instanced) && t7.instanced.includes("color") && (r10 = r10.vec4f(O3.INSTANCECOLOR)), r(t7.instanced) && t7.instanced.includes("featureAttribute") && (r10 = r10.vec4f(O3.INSTANCEFEATUREATTRIBUTE)), r10;
}
var V3 = n();
var H = n();
var G = r2(0, 0, 1);
var U2 = n();
var W3 = n();
var z2 = n();
var k = n();

// node_modules/@arcgis/core/views/3d/layers/graphics/wosrLoader.js
var b = s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");
async function w3(e12, t7) {
  const r10 = await h7(e12, t7);
  return { resource: r10, textures: await P2(r10.textureDefinitions, t7) };
}
async function h7(r10, n6) {
  const i8 = r(n6) && n6.streamDataRequester;
  if (i8)
    return v(r10, i8, n6);
  const u2 = await a(U(r10, e2(n6)));
  if (true === u2.ok)
    return u2.value.data;
  w(u2.error), j3(u2.error);
}
async function v(e12, r10, n6) {
  const a4 = await a(r10.request(e12, "json", n6));
  if (true === a4.ok)
    return a4.value;
  w(a4.error), j3(a4.error.details.url);
}
function j3(e12) {
  throw new s2("", `Request for object resource failed: ${e12}`);
}
function A3(e12) {
  const t7 = e12.params, r10 = t7.topology;
  let n6 = true;
  switch (t7.vertexAttributes || (b.warn("Geometry must specify vertex attributes"), n6 = false), t7.topology) {
    case "PerAttributeArray":
      break;
    case "Indexed":
    case null:
    case void 0: {
      const e13 = t7.faces;
      if (e13) {
        if (t7.vertexAttributes)
          for (const r11 in t7.vertexAttributes) {
            const t8 = e13[r11];
            t8 && t8.values ? (null != t8.valueType && "UInt32" !== t8.valueType && (b.warn(`Unsupported indexed geometry indices type '${t8.valueType}', only UInt32 is currently supported`), n6 = false), null != t8.valuesPerElement && 1 !== t8.valuesPerElement && (b.warn(`Unsupported indexed geometry values per element '${t8.valuesPerElement}', only 1 is currently supported`), n6 = false)) : (b.warn(`Indexed geometry does not specify face indices for '${r11}' attribute`), n6 = false);
          }
      } else
        b.warn("Indexed geometries must specify faces"), n6 = false;
      break;
    }
    default:
      b.warn(`Unsupported topology '${r10}'`), n6 = false;
  }
  e12.params.material || (b.warn("Geometry requires material"), n6 = false);
  const a4 = e12.params.vertexAttributes;
  for (const s4 in a4) {
    a4[s4].values || (b.warn("Geometries with externally defined attributes are not yet supported"), n6 = false);
  }
  return n6;
}
function M(e12, t7) {
  const r10 = [], n6 = [], s4 = [], o10 = [], l4 = e12.resource, c7 = r8.parse(l4.version || "1.0", "wosr");
  k2.validate(c7);
  const p = l4.model.name, f4 = l4.model.geometries, x3 = l4.materialDefinitions, b2 = e12.textures;
  let w4 = 0;
  const h8 = /* @__PURE__ */ new Map();
  for (let i8 = 0; i8 < f4.length; i8++) {
    const e13 = f4[i8];
    if (!A3(e13))
      continue;
    const l5 = T2(e13), c8 = e13.params.vertexAttributes, p2 = [];
    for (const t8 in c8) {
      const e14 = c8[t8], r11 = e14.values;
      p2.push([t8, { data: r11, size: e14.valuesPerElement, exclusive: true }]);
    }
    const v2 = [];
    if ("PerAttributeArray" !== e13.params.topology) {
      const t8 = e13.params.faces;
      for (const e14 in t8)
        v2.push([e14, new Uint32Array(t8[e14].values)]);
    }
    const j4 = b2 && b2[l5.texture];
    if (j4 && !h8.has(l5.texture)) {
      const { image: e14, params: t8 } = j4, r11 = new L3(e14, t8);
      o10.push(r11), h8.set(l5.texture, r11);
    }
    const M2 = h8.get(l5.texture), U4 = M2 ? M2.id : void 0;
    let P3 = s4[l5.material] ? s4[l5.material][l5.texture] : null;
    if (!P3) {
      const e14 = x3[l5.material.substring(l5.material.lastIndexOf("/") + 1)].params;
      1 === e14.transparency && (e14.transparency = 0);
      const r11 = j4 && j4.alphaChannelUsage, n7 = e14.transparency > 0 || "transparency" === r11 || "maskAndTransparency" === r11, o11 = j4 ? I2(j4.alphaChannelUsage) : void 0, i9 = { ambient: e3(e14.diffuse), diffuse: e3(e14.diffuse), opacity: 1 - (e14.transparency || 0), transparent: n7, textureAlphaMode: o11, textureAlphaCutoff: 0.33, textureId: U4, initTextureTransparent: true, doubleSided: true, cullFace: n5.None, colorMixMode: e14.externalColorMixMode || "tint", textureAlphaPremultiplied: !!j4 && !!j4.params.preMultiplyAlpha };
      r(t7) && t7.materialParamsMixin && Object.assign(i9, t7.materialParamsMixin), P3 = new R(i9), s4[l5.material] || (s4[l5.material] = {}), s4[l5.material][l5.texture] = P3;
    }
    n6.push(P3);
    const k3 = new g(p2, v2);
    w4 += v2.position ? v2.position.length : 0, r10.push(k3);
  }
  return { name: p, stageResources: { textures: o10, materials: n6, geometries: r10 }, pivotOffset: l4.model.pivotOffset, boundingBox: U3(r10), numberOfVertices: w4, lodThreshold: null };
}
function U3(e12) {
  const t7 = B();
  return e12.forEach((e13) => {
    const r10 = e13.boundingInfo;
    r(r10) && (h2(t7, r10.getBBMin()), h2(t7, r10.getBBMax()));
  }), t7;
}
async function P2(e12, t7) {
  const r10 = [];
  for (const o10 in e12) {
    const n7 = e12[o10], s5 = n7.images[0].data;
    if (!s5) {
      b.warn("Externally referenced texture data is not yet supported");
      continue;
    }
    const i8 = n7.encoding + ";base64," + s5, u2 = "/textureDefinitions/" + o10, l4 = "rgba" === n7.channels ? n7.alphaChannelUsage || "transparency" : "none", c7 = { noUnpackFlip: true, wrap: { s: D.REPEAT, t: D.REPEAT }, preMultiplyAlpha: I2(l4) !== C.Opaque }, m2 = r(t7) && t7.disableTextures ? Promise.resolve(null) : t4(i8, t7);
    r10.push(m2.then((e13) => ({ refId: u2, image: e13, params: c7, alphaChannelUsage: l4 })));
  }
  const n6 = await Promise.all(r10), s4 = {};
  for (const a4 of n6)
    s4[a4.refId] = a4;
  return s4;
}
function I2(e12) {
  switch (e12) {
    case "mask":
      return C.Mask;
    case "maskAndTransparency":
      return C.MaskBlend;
    case "none":
      return C.Opaque;
    default:
      return C.Blend;
  }
}
function T2(e12) {
  const t7 = e12.params;
  return { id: 1, material: t7.material, texture: t7.texture, region: t7.texture };
}
var k2 = new r8(1, 2, "wosr");

// node_modules/@arcgis/core/views/3d/layers/graphics/objectResourceUtils.js
async function J(s4, o10) {
  const i8 = X(a2(s4));
  if ("wosr" === i8.fileType) {
    const e12 = await (o10.cache ? o10.cache.loadWOSR(i8.url, o10) : w3(i8.url, o10)), t7 = M(e12, o10);
    return { lods: [t7], referenceBoundingBox: t7.boundingBox, isEsriSymbolResource: false, isWosr: true, remove: e12.remove };
  }
  const a4 = await (o10.cache ? o10.cache.loadGLTF(i8.url, o10, o10.usePBR) : c2(new n3(o10.streamDataRequester), i8.url, o10, o10.usePBR)), u2 = m(a4.model.meta, "ESRI_proxyEllipsoid");
  a4.meta.isEsriSymbolResource && r(u2) && a4.meta.uri.includes("/RealisticTrees/") && te(a4, u2);
  const n6 = a4.meta.isEsriSymbolResource ? { usePBR: o10.usePBR, isSchematic: false, treeRendering: !!a4.customMeta.esriTreeRendering, mrrFactors: [0, 1, 0.2] } : { usePBR: o10.usePBR, isSchematic: false, treeRendering: false, mrrFactors: [0, 1, 0.5] }, l4 = { ...o10.materialParamsMixin, treeRendering: !!a4.customMeta.esriTreeRendering };
  if (null != i8.specifiedLodIndex) {
    const e12 = Y(a4, n6, l4, i8.specifiedLodIndex);
    let t7 = e12[0].boundingBox;
    if (0 !== i8.specifiedLodIndex) {
      t7 = Y(a4, n6, l4, 0)[0].boundingBox;
    }
    return { lods: e12, referenceBoundingBox: t7, isEsriSymbolResource: a4.meta.isEsriSymbolResource, isWosr: false, remove: a4.remove };
  }
  const c7 = Y(a4, n6, l4);
  return { lods: c7, referenceBoundingBox: c7[0].boundingBox, isEsriSymbolResource: a4.meta.isEsriSymbolResource, isWosr: false, remove: a4.remove };
}
function X(e12) {
  const t7 = e12.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);
  if (t7)
    return { fileType: "gltf", url: t7[1], specifiedLodIndex: null != t7[4] ? Number(t7[4]) : null };
  return e12.match(/(.*\.(json|json\.gz))$/) ? { fileType: "wosr", url: e12, specifiedLodIndex: null } : { fileType: "unknown", url: e12, specifiedLodIndex: null };
}
function Y(e12, t7, s4, a4) {
  const u2 = e12.model, n6 = e5(), l4 = new Array(), c7 = /* @__PURE__ */ new Map(), m2 = /* @__PURE__ */ new Map();
  return u2.lods.forEach((e13, i8) => {
    if (void 0 !== a4 && i8 !== a4)
      return;
    const d2 = { name: e13.name, stageResources: { textures: new Array(), materials: new Array(), geometries: new Array() }, lodThreshold: r(e13.lodThreshold) ? e13.lodThreshold : null, pivotOffset: [0, 0, 0], numberOfVertices: 0, boundingBox: B() };
    l4.push(d2), e13.parts.forEach((e14) => {
      const i9 = e14.material + (e14.attributes.normal ? "_normal" : "") + (e14.attributes.color ? "_color" : "") + (e14.attributes.texCoord0 ? "_texCoord0" : "") + (e14.attributes.tangent ? "_tangent" : ""), a5 = u2.materials.get(e14.material), l5 = r(e14.attributes.texCoord0), f4 = r(e14.attributes.normal), p = Z(a5.alphaMode);
      if (!c7.has(i9)) {
        if (l5) {
          if (r(a5.textureColor) && !m2.has(a5.textureColor)) {
            const e15 = u2.textures.get(a5.textureColor), t8 = { ...e15.parameters, preMultiplyAlpha: p !== C.Opaque };
            m2.set(a5.textureColor, new L3(e15.data, t8));
          }
          if (r(a5.textureNormal) && !m2.has(a5.textureNormal)) {
            const e15 = u2.textures.get(a5.textureNormal);
            m2.set(a5.textureNormal, new L3(e15.data, e15.parameters));
          }
          if (r(a5.textureOcclusion) && !m2.has(a5.textureOcclusion)) {
            const e15 = u2.textures.get(a5.textureOcclusion);
            m2.set(a5.textureOcclusion, new L3(e15.data, e15.parameters));
          }
          if (r(a5.textureEmissive) && !m2.has(a5.textureEmissive)) {
            const e15 = u2.textures.get(a5.textureEmissive);
            m2.set(a5.textureEmissive, new L3(e15.data, e15.parameters));
          }
          if (r(a5.textureMetallicRoughness) && !m2.has(a5.textureMetallicRoughness)) {
            const e15 = u2.textures.get(a5.textureMetallicRoughness);
            m2.set(a5.textureMetallicRoughness, new L3(e15.data, e15.parameters));
          }
        }
        const o10 = a5.color[0] ** (1 / o4), n7 = a5.color[1] ** (1 / o4), d3 = a5.color[2] ** (1 / o4), x4 = a5.emissiveFactor[0] ** (1 / o4), g2 = a5.emissiveFactor[1] ** (1 / o4), h8 = a5.emissiveFactor[2] ** (1 / o4), b2 = r(a5.textureColor) && l5 ? m2.get(a5.textureColor) : null;
        c7.set(i9, new R({ ...t7, transparent: p === C.Blend, customDepthTest: N.Lequal, textureAlphaMode: p, textureAlphaCutoff: a5.alphaCutoff, diffuse: [o10, n7, d3], ambient: [o10, n7, d3], opacity: a5.opacity, doubleSided: a5.doubleSided, doubleSidedType: "winding-order", cullFace: a5.doubleSided ? n5.None : n5.Back, hasVertexColors: !!e14.attributes.color, hasVertexTangents: !!e14.attributes.tangent, normals: f4 ? "default" : "screenDerivative", castShadows: true, receiveSSAO: true, textureId: r(b2) ? b2.id : void 0, colorMixMode: a5.colorMixMode, normalTextureId: r(a5.textureNormal) && l5 ? m2.get(a5.textureNormal).id : void 0, textureAlphaPremultiplied: r(b2) && !!b2.params.preMultiplyAlpha, occlusionTextureId: r(a5.textureOcclusion) && l5 ? m2.get(a5.textureOcclusion).id : void 0, emissiveTextureId: r(a5.textureEmissive) && l5 ? m2.get(a5.textureEmissive).id : void 0, metallicRoughnessTextureId: r(a5.textureMetallicRoughness) && l5 ? m2.get(a5.textureMetallicRoughness).id : void 0, emissiveFactor: [x4, g2, h8], mrrFactors: [a5.metallicFactor, a5.roughnessFactor, t7.mrrFactors[2]], isSchematic: false, ...s4 }));
      }
      const x3 = ee(e14.indices || e14.attributes.position.count, e14.primitiveType), S = e14.attributes.position.count, A4 = r7(i2, S);
      t2(A4, e14.attributes.position, e14.transform);
      const N3 = [[O3.POSITION, { data: A4.typedBuffer, size: A4.elementCount, exclusive: true }]], I3 = [[O3.POSITION, x3]];
      if (r(e14.attributes.normal)) {
        const t8 = r7(i2, S);
        j(n6, e14.transform), r5(t8, e14.attributes.normal, n6), N3.push([O3.NORMAL, { data: t8.typedBuffer, size: t8.elementCount, exclusive: true }]), I3.push([O3.NORMAL, x3]);
      }
      if (r(e14.attributes.tangent)) {
        const t8 = r7(c, S);
        j(n6, e14.transform), r6(t8, e14.attributes.tangent, n6), N3.push([O3.TANGENT, { data: t8.typedBuffer, size: t8.elementCount, exclusive: true }]), I3.push([O3.TANGENT, x3]);
      }
      if (r(e14.attributes.texCoord0)) {
        const t8 = r7(u, S);
        n2(t8, e14.attributes.texCoord0), N3.push([O3.UV0, { data: t8.typedBuffer, size: t8.elementCount, exclusive: true }]), I3.push([O3.UV0, x3]);
      }
      if (r(e14.attributes.color)) {
        const t8 = r7(x, S);
        if (4 === e14.attributes.color.elementCount)
          e14.attributes.color instanceof c ? o2(t8, e14.attributes.color, 255) : e14.attributes.color instanceof x ? e8(t8, e14.attributes.color) : e14.attributes.color instanceof L2 && o2(t8, e14.attributes.color, 1 / 256);
        else {
          t3(t8, 255, 255, 255, 255);
          const r10 = new O2(t8.buffer, 0, 4);
          e14.attributes.color instanceof i2 ? f(r10, e14.attributes.color, 255) : e14.attributes.color instanceof O2 ? e7(r10, e14.attributes.color) : e14.attributes.color instanceof E && f(r10, e14.attributes.color, 1 / 256);
        }
        N3.push([O3.COLOR, { data: t8.typedBuffer, size: t8.elementCount, exclusive: true }]), I3.push([O3.COLOR, x3]);
      }
      const L5 = new g(N3, I3);
      d2.stageResources.geometries.push(L5), d2.stageResources.materials.push(c7.get(i9)), l5 && (r(a5.textureColor) && d2.stageResources.textures.push(m2.get(a5.textureColor)), r(a5.textureNormal) && d2.stageResources.textures.push(m2.get(a5.textureNormal)), r(a5.textureOcclusion) && d2.stageResources.textures.push(m2.get(a5.textureOcclusion)), r(a5.textureEmissive) && d2.stageResources.textures.push(m2.get(a5.textureEmissive)), r(a5.textureMetallicRoughness) && d2.stageResources.textures.push(m2.get(a5.textureMetallicRoughness))), d2.numberOfVertices += S;
      const F2 = L5.boundingInfo;
      r(F2) && (h2(d2.boundingBox, F2.getBBMin()), h2(d2.boundingBox, F2.getBBMax()));
    });
  }), l4;
}
function Z(e12) {
  switch (e12) {
    case "BLEND":
      return C.Blend;
    case "MASK":
      return C.Mask;
    case "OPAQUE":
    case null:
    case void 0:
      return C.Opaque;
  }
}
function ee(e12, t7) {
  switch (t7) {
    case E2.TRIANGLES:
      return n4(e12);
    case E2.TRIANGLE_STRIP:
      return o3(e12);
    case E2.TRIANGLE_FAN:
      return i3(e12);
  }
}
function te(e12, t7) {
  for (let r10 = 0; r10 < e12.model.lods.length; ++r10) {
    const o10 = e12.model.lods[r10];
    e12.customMeta.esriTreeRendering = true;
    for (const i8 of o10.parts) {
      const o11 = i8.attributes.normal;
      if (t(o11))
        return;
      const x3 = i8.attributes.position, g2 = x3.count, b2 = n(), R2 = n(), B3 = n(), M2 = r7(x, g2), T3 = r7(i2, g2), w4 = h(e6(), i8.transform);
      for (let s4 = 0; s4 < g2; s4++) {
        x3.getVec(s4, R2), o11.getVec(s4, b2), L(R2, R2, i8.transform), e4(B3, R2, t7.center), i(B3, B3, t7.radius);
        const a4 = B3[2], u2 = s3(B3), p = Math.min(0.45 + 0.55 * u2 * u2, 1);
        i(B3, B3, t7.radius), L(B3, B3, w4), z(B3, B3), r10 + 1 !== e12.model.lods.length && e12.model.lods.length > 1 && A(B3, B3, b2, a4 > -1 ? 0.2 : Math.min(-4 * a4 - 3.8, 1)), T3.setVec(s4, B3), M2.set(s4, 0, 255 * p), M2.set(s4, 1, 255 * p), M2.set(s4, 2, 255 * p), M2.set(s4, 3, 255);
      }
      i8.attributes.normal = T3, i8.attributes.color = M2;
    }
  }
}

export {
  _2 as _,
  R,
  B2 as B,
  w3 as w,
  J,
  X,
  Y
};
//# sourceMappingURL=chunk-X7CKOX5Z.js.map
