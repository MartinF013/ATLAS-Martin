import {
  v
} from "./chunk-YZ46FBEM.js";
import {
  h
} from "./chunk-TH2ECCFL.js";
import {
  e as e2
} from "./chunk-PQO66WZ2.js";
import {
  S
} from "./chunk-HR2OX32D.js";
import {
  u
} from "./chunk-56RHM4A6.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  R
} from "./chunk-3NMRL5CR.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  x
} from "./chunk-U3PSONS6.js";

// node_modules/@arcgis/core/views/2d/viewStateUtils.js
var t = Math.PI / 180;
function n2(n3) {
  return n3 * t;
}
function r(t2, o) {
  const r2 = n2(o.rotation), u4 = Math.abs(Math.cos(r2)), a = Math.abs(Math.sin(r2)), [s, c] = o.size;
  return t2[0] = Math.round(c * a + s * u4), t2[1] = Math.round(c * u4 + s * a), t2;
}
function u2(t2, n3, o, r2) {
  const [u4, a] = n3, [s, c] = r2, i = 0.5 * o;
  return t2[0] = u4 - i * s, t2[1] = a - i * c, t2[2] = u4 + i * s, t2[3] = a + i * c, t2;
}

// node_modules/@arcgis/core/views/2d/layers/support/ExportStrategy.js
var u3 = u();
var g = [0, 0];
var f = new e2(0, 0, 0, 0);
var x2 = { container: null, fetchSource: null, requestUpdate: null, imageMaxWidth: 2048, imageMaxHeight: 2048, imageRotationSupported: false, imageNormalizationSupported: false, hidpi: false };
var y2 = class extends y {
  constructor(t2) {
    super(t2), this._imagePromise = null, this.bitmaps = [], this.hidpi = x2.hidpi, this.imageMaxWidth = x2.imageMaxWidth, this.imageMaxHeight = x2.imageMaxHeight, this.imageRotationSupported = x2.imageRotationSupported, this.imageNormalizationSupported = x2.imageNormalizationSupported, this.update = x(async (t3, e3) => {
      if (!t3.stationary || this.destroyed)
        return null;
      const i = t3.state, o = R(i.spatialReference), r2 = this.hidpi ? t3.pixelRatio : 1, s = this.imageNormalizationSupported && i.worldScreenWidth && i.worldScreenWidth < i.size[0];
      s ? (g[0] = i.worldScreenWidth, g[1] = i.size[1]) : this.imageRotationSupported ? (g[0] = i.size[0], g[1] = i.size[1]) : r(g, i);
      const a = Math.floor(g[0] * r2) > this.imageMaxWidth || Math.floor(g[1] * r2) > this.imageMaxHeight, n3 = o && (i.extent.xmin < o.valid[0] || i.extent.xmax > o.valid[1]), l = !this.imageNormalizationSupported && n3, d2 = !a && !l, h2 = this.imageRotationSupported ? i.rotation : 0;
      if (d2) {
        const t4 = s ? i.paddedViewState.center : i.center;
        this._imagePromise = this._singleExport(i, g, t4, i.resolution, h2, r2, e3);
      } else {
        let t4 = Math.min(this.imageMaxWidth, this.imageMaxHeight);
        l && (t4 = Math.min(i.worldScreenWidth, t4)), this._imagePromise = this._tiledExport(i, t4, r2, e3);
      }
      return this._imagePromise.then(async (t4) => {
        if (this._imagePromise = null, !this.destroyed) {
          this.bitmaps = t4 ?? [];
          for (const e4 of this.container.children)
            t4.includes(e4) || e4.fadeOut().then(() => {
              e4.remove();
            });
          for (const e4 of t4)
            this.container.addChild(e4), e4.fadeIn();
        }
      }).catch((t4) => {
        throw this._imagePromise = null, t4;
      });
    }, 5e3);
  }
  destroy() {
    this.bitmaps = [];
  }
  get updating() {
    return !this.destroyed && null !== this._imagePromise;
  }
  updateExports(t2) {
    for (const e3 of this.container.children) {
      if (!e3.visible || !e3.stage)
        return;
      t2(e3), e3.invalidateTexture(), e3.requestRender();
    }
  }
  async _export(t2, e3, i, o, r2, s) {
    const a = await this.fetchSource(t2, Math.floor(e3 * r2), Math.floor(i * r2), { rotation: o, pixelRatio: r2, signal: s }), p = new v(a, "additive");
    return p.x = t2.xmin, p.y = t2.ymax, p.resolution = t2.width / e3, p.rotation = o, p.pixelRatio = r2, p;
  }
  async _singleExport(t2, e3, i, o, r2, a, p) {
    u2(u3, i, o, e3);
    const n3 = new M(u3[0], u3[1], u3[2], u3[3], t2.spatialReference);
    return [await this._export(n3, e3[0], e3[1], r2, a, p)];
  }
  _tiledExport(t2, e3, i, o) {
    const r2 = S.create({ size: e3, spatialReference: t2.spatialReference, scales: [t2.scale] }), a = new h(r2), p = a.getTileCoverage(t2);
    if (!p)
      return null;
    const m = [];
    return p.forEach((r3, p2, n3, l) => {
      f.set(r3, p2, n3, l), a.getTileBounds(u3, f);
      const d2 = new M(u3[0], u3[1], u3[2], u3[3], t2.spatialReference);
      m.push(this._export(d2, e3, e3, 0, i, o));
    }), Promise.all(m);
  }
};
e([d()], y2.prototype, "_imagePromise", void 0), e([d()], y2.prototype, "bitmaps", void 0), e([d()], y2.prototype, "container", void 0), e([d()], y2.prototype, "fetchSource", void 0), e([d()], y2.prototype, "hidpi", void 0), e([d()], y2.prototype, "imageMaxWidth", void 0), e([d()], y2.prototype, "imageMaxHeight", void 0), e([d()], y2.prototype, "imageRotationSupported", void 0), e([d()], y2.prototype, "imageNormalizationSupported", void 0), e([d()], y2.prototype, "requestUpdate", void 0), e([d()], y2.prototype, "updating", null), y2 = e([n("esri.views.2d.layers.support.ExportStrategy")], y2);
var S2 = y2;

export {
  S2 as S
};
//# sourceMappingURL=chunk-AQHDXFPK.js.map
