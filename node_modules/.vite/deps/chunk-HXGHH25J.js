import {
  r as r2
} from "./chunk-2HDG7SIE.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  r
} from "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";

// node_modules/@arcgis/core/layers/support/rasterTransforms/BaseRasterTransform.js
var t = class extends l {
  get affectsPixelSize() {
    return false;
  }
  forwardTransform(r3) {
    return r3;
  }
  inverseTransform(r3) {
    return r3;
  }
};
e([d()], t.prototype, "affectsPixelSize", null), e([d({ json: { write: true } })], t.prototype, "spatialReference", void 0), t = e([n("esri.layers.support.rasterTransforms.BaseRasterTransform")], t);
var a = t;

// node_modules/@arcgis/core/layers/support/rasterTransforms/GCSShiftTransform.js
var a2 = class extends a {
  constructor() {
    super(...arguments), this.type = "gcs-shift", this.tolerance = 1e-8;
  }
  forwardTransform(r3) {
    return "point" === (r3 = r3.clone()).type ? (r3.x > 180 + this.tolerance && (r3.x -= 360), r3) : (r3.xmin >= 180 - this.tolerance ? (r3.xmax -= 360, r3.xmin -= 360) : r3.xmax > 180 + this.tolerance && (r3.xmin = -180, r3.xmax = 180), r3);
  }
  inverseTransform(r3) {
    return "point" === (r3 = r3.clone()).type ? (r3.x < -this.tolerance && (r3.x += 360), r3) : (r3.xmin < -this.tolerance && (r3.xmin += 360, r3.xmax += 360), r3);
  }
};
e([r2({ GCSShiftXform: "gcs-shift" })], a2.prototype, "type", void 0), e([d()], a2.prototype, "tolerance", void 0), a2 = e([n("esri.layers.support.rasterTransforms.GCSShiftTransform")], a2);
var c = a2;

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e2 = class extends a {
  constructor() {
    super(...arguments), this.type = "identity";
  }
};
e([r2({ IdentityXform: "identity" })], e2.prototype, "type", void 0), e2 = e([n("esri.layers.support.rasterTransforms.IdentityTransform")], e2);
var p = e2;

// node_modules/@arcgis/core/layers/support/rasterTransforms/PolynomialTransform.js
function l2(e4, r3, o3) {
  const { x: t2, y: s } = r3;
  if (o3 < 2) {
    return { x: e4[0] + t2 * e4[2] + s * e4[4], y: e4[1] + t2 * e4[3] + s * e4[5] };
  }
  if (2 === o3) {
    const r4 = t2 * t2, o4 = s * s, n3 = t2 * s;
    return { x: e4[0] + t2 * e4[2] + s * e4[4] + r4 * e4[6] + n3 * e4[8] + o4 * e4[10], y: e4[1] + t2 * e4[3] + s * e4[5] + r4 * e4[7] + n3 * e4[9] + o4 * e4[11] };
  }
  const n2 = t2 * t2, i2 = s * s, f2 = t2 * s, p2 = n2 * t2, l3 = n2 * s, a4 = t2 * i2, c3 = s * i2;
  return { x: e4[0] + t2 * e4[2] + s * e4[4] + n2 * e4[6] + f2 * e4[8] + i2 * e4[10] + p2 * e4[12] + l3 * e4[14] + a4 * e4[16] + c3 * e4[18], y: e4[1] + t2 * e4[3] + s * e4[5] + n2 * e4[7] + f2 * e4[9] + i2 * e4[11] + p2 * e4[13] + l3 * e4[15] + a4 * e4[17] + c3 * e4[19] };
}
function a3(e4, r3, o3) {
  const { xmin: t2, ymin: s, xmax: n2, ymax: i2, spatialReference: f2 } = r3;
  let a4 = [];
  if (o3 < 2)
    a4.push({ x: t2, y: i2 }), a4.push({ x: n2, y: i2 }), a4.push({ x: t2, y: s }), a4.push({ x: n2, y: s });
  else {
    let e5 = 10;
    for (let r4 = 0; r4 < e5; r4++)
      a4.push({ x: t2, y: s + (i2 - s) * r4 / (e5 - 1) }), a4.push({ x: n2, y: s + (i2 - s) * r4 / (e5 - 1) });
    e5 = 8;
    for (let r4 = 1; r4 <= e5; r4++)
      a4.push({ x: t2 + (n2 - t2) * r4 / e5, y: s }), a4.push({ x: t2 + (n2 - t2) * r4 / e5, y: i2 });
  }
  a4 = a4.map((r4) => l2(e4, r4, o3));
  const c3 = a4.map((e5) => e5.x), u2 = a4.map((e5) => e5.y);
  return new M({ xmin: Math.min.apply(null, c3), xmax: Math.max.apply(null, c3), ymin: Math.min.apply(null, u2), ymax: Math.max.apply(null, u2), spatialReference: f2 });
}
function c2(e4) {
  const [r3, o3, t2, s, n2, i2] = e4, f2 = t2 * i2 - n2 * s, p2 = n2 * s - t2 * i2;
  return [(n2 * o3 - r3 * i2) / f2, (t2 * o3 - r3 * s) / p2, i2 / f2, s / p2, -n2 / f2, -t2 / p2];
}
var u = class extends a {
  constructor() {
    super(...arguments), this.polynomialOrder = 1, this.type = "polynomial";
  }
  readForwardCoefficients(e4, r3) {
    const { coeffX: o3, coeffY: t2 } = r3;
    if (!(o3 == null ? void 0 : o3.length) || !(t2 == null ? void 0 : t2.length) || o3.length !== t2.length)
      return null;
    const s = [];
    for (let n2 = 0; n2 < o3.length; n2++)
      s.push(o3[n2]), s.push(t2[n2]);
    return s;
  }
  writeForwardCoefficients(e4, r3, o3) {
    const t2 = [], s = [];
    for (let n2 = 0; n2 < (e4 == null ? void 0 : e4.length); n2++)
      n2 % 2 == 0 ? t2.push(e4[n2]) : s.push(e4[n2]);
    r3.coeffX = t2, r3.coeffY = s;
  }
  get inverseCoefficients() {
    let e4 = this._get("inverseCoefficients");
    const r3 = this._get("forwardCoefficients");
    return !e4 && r3 && this.polynomialOrder < 2 && (e4 = c2(r3)), e4;
  }
  set inverseCoefficients(e4) {
    this._set("inverseCoefficients", e4);
  }
  readInverseCoefficients(e4, r3) {
    const { inverseCoeffX: o3, inverseCoeffY: t2 } = r3;
    if (!(o3 == null ? void 0 : o3.length) || !(t2 == null ? void 0 : t2.length) || o3.length !== t2.length)
      return null;
    const s = [];
    for (let n2 = 0; n2 < o3.length; n2++)
      s.push(o3[n2]), s.push(t2[n2]);
    return s;
  }
  writeInverseCoefficients(e4, r3, o3) {
    const t2 = [], s = [];
    for (let n2 = 0; n2 < (e4 == null ? void 0 : e4.length); n2++)
      n2 % 2 == 0 ? t2.push(e4[n2]) : s.push(e4[n2]);
    r3.inverseCoeffX = t2, r3.inverseCoeffY = s;
  }
  get affectsPixelSize() {
    return this.polynomialOrder > 0;
  }
  forwardTransform(e4) {
    if ("point" === e4.type) {
      const r3 = l2(this.forwardCoefficients, e4, this.polynomialOrder);
      return new j({ x: r3.x, y: r3.y, spatialReference: e4.spatialReference });
    }
    return a3(this.forwardCoefficients, e4, this.polynomialOrder);
  }
  inverseTransform(e4) {
    if ("point" === e4.type) {
      const r3 = l2(this.inverseCoefficients, e4, this.polynomialOrder);
      return new j({ x: r3.x, y: r3.y, spatialReference: e4.spatialReference });
    }
    return a3(this.inverseCoefficients, e4, this.polynomialOrder);
  }
};
e([d({ json: { write: true } })], u.prototype, "polynomialOrder", void 0), e([d()], u.prototype, "forwardCoefficients", void 0), e([o("forwardCoefficients", ["coeffX", "coeffY"])], u.prototype, "readForwardCoefficients", null), e([r("forwardCoefficients")], u.prototype, "writeForwardCoefficients", null), e([d({ json: { write: true } })], u.prototype, "inverseCoefficients", null), e([o("inverseCoefficients", ["inverseCoeffX", "inverseCoeffY"])], u.prototype, "readInverseCoefficients", null), e([r("inverseCoefficients")], u.prototype, "writeInverseCoefficients", null), e([d()], u.prototype, "affectsPixelSize", null), e([r2({ PolynomialXform: "polynomial" })], u.prototype, "type", void 0), u = e([n("esri.layers.support.rasterTransforms.PolynomialTransform")], u);
var m = u;

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var o2 = { GCSShiftXform: c, IdentityXform: p, PolynomialXform: m };
var e3 = Object.keys(o2);
function f(r3) {
  const t2 = r3 == null ? void 0 : r3.type;
  return !r3 || e3.includes(t2);
}
function i(r3) {
  const t2 = r3 == null ? void 0 : r3.type;
  if (!t2)
    return null;
  const n2 = o2[r3 == null ? void 0 : r3.type];
  if (n2) {
    const t3 = new n2();
    return t3.read(r3), t3;
  }
  return null;
}

export {
  c,
  m,
  f,
  i
};
//# sourceMappingURL=chunk-HXGHH25J.js.map
