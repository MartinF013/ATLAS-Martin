import {
  D,
  T,
  V,
  c,
  g,
  h,
  m,
  s,
  y as y2,
  z
} from "./chunk-NVOCHKIH.js";
import "./chunk-DGELARKE.js";
import {
  O
} from "./chunk-Z7BSDVJ3.js";
import {
  d,
  y
} from "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-5Z5455ZY.js";
import {
  a
} from "./chunk-D7DLEBS2.js";
import {
  u
} from "./chunk-NWRK6QLX.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  R,
  k2 as k,
  p
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  e
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/smartMapping/statistics/support/utils.js
var h2 = null;
function y3(e2, t, n) {
  return e2.x < 0 ? e2.x += t : e2.x > n && (e2.x -= t), e2;
}
function I(e2, n, r2, o) {
  const u2 = p(r2) ? R(r2) : null, a2 = u2 ? Math.round((u2.valid[1] - u2.valid[0]) / n.scale[0]) : null;
  return e2.map((e3) => {
    const r3 = new j(e(e3.geometry));
    return O(n, r3, r3, r3.hasZ, r3.hasM), e3.geometry = u2 ? y3(r3, a2, o[0]) : r3, e3;
  });
}
function $(e2, t = 18, n, o, i, s3) {
  const l = new Float64Array(i * s3);
  t = Math.round(u(t));
  let u2 = Number.POSITIVE_INFINITY, a2 = Number.NEGATIVE_INFINITY, m2 = 0, d3 = 0, p3 = 0, h3 = 0;
  const y4 = d(o, n);
  for (const { geometry: r2, attributes: c3 } of e2) {
    const { x: e3, y: n2 } = r2, o2 = Math.max(0, e3 - t), I3 = Math.max(0, n2 - t), $2 = Math.min(s3, n2 + t), g3 = Math.min(i, e3 + t), j2 = +y4(c3);
    for (let r3 = I3; r3 < $2; r3++)
      for (let s4 = o2; s4 < g3; s4++) {
        const o3 = r3 * i + s4, c4 = y(s4 - e3, r3 - n2, t), y5 = l[o3];
        m2 = l[o3] += c4 * j2;
        const I4 = m2 - y5;
        d3 += I4, p3 += I4 * I4, m2 < u2 && (u2 = m2), m2 > a2 && (a2 = m2), h3++;
      }
  }
  if (!h3)
    return { mean: 0, stddev: 0, min: 0, max: 0, mid: 0, count: 0 };
  const I2 = (a2 - u2) / 2;
  return { mean: d3 / h3, stdDev: Math.sqrt((p3 - d3 * d3 / h3) / h3), min: u2, max: a2, mid: I2, count: h3 };
}
async function g2(e2, t) {
  if (!t)
    return [];
  const n = e2.field, r2 = e2.valueExpression, i = e2.normalizationType, s3 = e2.normalizationField, l = e2.normalizationTotal, u2 = [], a2 = e2.viewInfoParams;
  let f = null, c3 = null;
  if (r2) {
    if (!h2) {
      const { arcadeUtils: e3 } = await a();
      h2 = e3;
    }
    f = h2.createFunction(r2), c3 = a2 && h2.getViewInfo({ viewingMode: a2.viewingMode, scale: a2.scale, spatialReference: new k(a2.spatialReference) });
  }
  const p3 = e2.fieldInfos, y4 = !(t[0] && "declaredClass" in t[0] && "esri.Graphic" === t[0].declaredClass) && p3 ? { fields: p3 } : null;
  return t.forEach((e3) => {
    const t2 = e3.attributes;
    let o;
    if (r2) {
      const t3 = y4 ? { ...e3, layer: y4 } : e3, n2 = h2.createExecContext(t3, c3);
      o = h2.executeFunction(f, n2);
    } else
      t2 && (o = t2[n]);
    if (i && isFinite(o)) {
      const e4 = t2 && parseFloat(t2[s3]);
      o = T(o, i, e4, l);
    }
    u2.push(o);
  }), u2;
}

// node_modules/@arcgis/core/smartMapping/statistics/support/statsWorker.js
async function d2(i) {
  const { attribute: e2, features: s3 } = i, { normalizationType: r2, normalizationField: m2, minValue: u2, maxValue: f, fieldType: d3 } = e2, p3 = await g2({ field: e2.field, valueExpression: e2.valueExpression, normalizationType: r2, normalizationField: m2, normalizationTotal: e2.normalizationTotal, viewInfoParams: e2.viewInfoParams, fieldInfos: e2.fieldInfos }, s3), v2 = s({ normalizationType: r2, normalizationField: m2, minValue: u2, maxValue: f }), c3 = { value: 0.5, fieldType: d3 }, z3 = "esriFieldTypeString" === d3 ? m({ values: p3, supportsNullCount: v2, percentileParams: c3 }) : c({ values: p3, minValue: u2, maxValue: f, useSampleStdDev: !r2, supportsNullCount: v2, percentileParams: c3 });
  return V(z3, "esriFieldTypeDate" === d3);
}
async function p2(i) {
  const { attribute: e2, features: n } = i, o = await g2({ field: e2.field, valueExpression: e2.valueExpression, viewInfoParams: e2.viewInfoParams, fieldInfos: e2.fieldInfos }, n), t = g(o);
  return h(t, e2.domain, e2.returnAllCodedValues);
}
async function v(i) {
  const { attribute: e2, features: n } = i, { field: o, normalizationType: t, normalizationField: l, normalizationTotal: s3, classificationMethod: r2 } = e2, f = await g2({ field: o, valueExpression: e2.valueExpression, normalizationType: t, normalizationField: l, normalizationTotal: s3, viewInfoParams: e2.viewInfoParams, fieldInfos: e2.fieldInfos }, n), d3 = y2(f, { field: o, normalizationType: t, normalizationField: l, normalizationTotal: s3, classificationMethod: r2, standardDeviationInterval: e2.standardDeviationInterval, numClasses: e2.numClasses, minValue: e2.minValue, maxValue: e2.maxValue });
  return D(d3, r2);
}
async function c2(i) {
  const { attribute: e2, features: n } = i, { field: o, normalizationType: t, normalizationField: l, normalizationTotal: s3, classificationMethod: r2 } = e2, m2 = await g2({ field: o, valueExpression: e2.valueExpression, normalizationType: t, normalizationField: l, normalizationTotal: s3, viewInfoParams: e2.viewInfoParams, fieldInfos: e2.fieldInfos }, n);
  return z(m2, { field: o, normalizationType: t, normalizationField: l, normalizationTotal: s3, classificationMethod: r2, standardDeviationInterval: e2.standardDeviationInterval, numBins: e2.numBins, minValue: e2.minValue, maxValue: e2.maxValue });
}
async function z2(a2) {
  const { attribute: n, features: o } = a2, { field: t, radius: l, fieldOffset: s3, transform: r2, spatialReference: m2, size: u2 } = n, f = I(o, r2, m2, u2), { count: d3, min: p3, max: v2, mean: c3, stdDev: z3 } = $(f, l, s3, t, u2[0], u2[1]);
  return { count: d3, min: p3, max: v2, avg: c3, stddev: z3 };
}
export {
  v as classBreaks,
  z2 as heatmapStatistics,
  c2 as histogram,
  d2 as summaryStatistics,
  p2 as uniqueValues
};
//# sourceMappingURL=statsWorker-7L6GTKSV.js.map
