import {
  u
} from "./chunk-VQLKKADV.js";
import {
  a as a2
} from "./chunk-I5UNY2WQ.js";
import {
  E,
  I,
  O
} from "./chunk-FPMD6IB4.js";
import {
  a
} from "./chunk-MDCKEJ7B.js";
import {
  n4 as n
} from "./chunk-2QOWZFCU.js";
import {
  r,
  s,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule.js
var t2 = class {
  constructor(t4, o3) {
    this._module = t4, this._loadModule = o3;
  }
  get() {
    return this._module;
  }
  async reload() {
    return this._module = await this._loadModule(), this._module;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique.js
var e = class {
  constructor(i2, t4, e3) {
    this.release = e3, t4 && (this.initializeConfiguration(i2, t4), this._configuration = t4.snapshot()), this._program = this.initializeProgram(i2), this._pipeline = this.initializePipeline(i2.rctx.capabilities);
  }
  destroy() {
    this._program = s(this._program), this._pipeline = this._configuration = null;
  }
  reload(t4) {
    s(this._program), this._program = this.initializeProgram(t4), this._pipeline = this.initializePipeline(t4.rctx.capabilities);
  }
  get program() {
    return this._program;
  }
  get compiled() {
    return this.program.isCompiled;
  }
  get key() {
    return this._configuration.key;
  }
  get configuration() {
    return this._configuration;
  }
  bindPass(i2, t4) {
    this.program.bindPass(i2, t4);
  }
  bindDraw(i2, t4) {
    this.program.bindDraw(i2, t4), this.program.rebindTextures();
  }
  bindPipelineState(i2, t4 = null, e3) {
    i2.setPipelineState(this.getPipelineState(t4, e3));
  }
  ensureAttributeLocations(i2) {
    this.program.assertCompatibleVertexAttributeLocations(i2);
  }
  get primitiveType() {
    return E.TRIANGLES;
  }
  getPipelineState(i2, t4) {
    return this._pipeline;
  }
  initializeConfiguration(i2, t4) {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Program.js
var o = class {
  constructor(t4, e3, o3) {
    this._context = t4, this._locations = o3, this._textures = /* @__PURE__ */ new Map(), this._freeTextureUnits = new n({ deallocator: null }), this._glProgram = t4.programCache.acquire(e3.generate("vertex"), e3.generate("fragment"), o3), this._glProgram.stop = () => {
      throw new Error("Wrapped _glProgram used directly");
    }, this.bindPass = e3.generateBind(a2.Pass, this), this.bindDraw = e3.generateBind(a2.Draw, this), this._fragmentUniforms = u() ? e3.fragmentUniforms : null;
  }
  dispose() {
    this._glProgram.dispose();
  }
  get glName() {
    return this._glProgram.glName;
  }
  get isCompiled() {
    return this._glProgram.isCompiled;
  }
  setUniform1b(t4, e3) {
    this._glProgram.setUniform1i(t4, e3 ? 1 : 0);
  }
  setUniform1i(t4, e3) {
    this._glProgram.setUniform1i(t4, e3);
  }
  setUniform1f(t4, e3) {
    this._glProgram.setUniform1f(t4, e3);
  }
  setUniform2f(t4, e3, r2) {
    this._glProgram.setUniform2f(t4, e3, r2);
  }
  setUniform2fv(t4, e3) {
    this._glProgram.setUniform2fv(t4, e3);
  }
  setUniform3f(t4, e3, r2, i2) {
    this._glProgram.setUniform3f(t4, e3, r2, i2);
  }
  setUniform3fv(t4, e3) {
    this._glProgram.setUniform3fv(t4, e3);
  }
  setUniform4f(t4, e3, r2, i2, s3) {
    this._glProgram.setUniform4f(t4, e3, r2, i2, s3);
  }
  setUniform4fv(t4, e3) {
    this._glProgram.setUniform4fv(t4, e3);
  }
  setUniformMatrix3fv(t4, e3) {
    this._glProgram.setUniformMatrix3fv(t4, e3);
  }
  setUniformMatrix4fv(t4, e3) {
    this._glProgram.setUniformMatrix4fv(t4, e3);
  }
  setUniform1fv(t4, e3) {
    this._glProgram.setUniform1fv(t4, e3);
  }
  setUniform1iv(t4, e3) {
    this._glProgram.setUniform1iv(t4, e3);
  }
  setUniform2iv(t4, e3) {
    this._glProgram.setUniform3iv(t4, e3);
  }
  setUniform3iv(t4, e3) {
    this._glProgram.setUniform3iv(t4, e3);
  }
  setUniform4iv(t4, e3) {
    this._glProgram.setUniform4iv(t4, e3);
  }
  assertCompatibleVertexAttributeLocations(t4) {
    t4.locations !== this._locations && console.error("VertexAttributeLocations are incompatible");
  }
  stop() {
    this._textures.clear(), this._freeTextureUnits.clear();
  }
  bindTexture(e3, r2) {
    if (t(r2) || null == r2.glName) {
      const t4 = this._textures.get(e3);
      return t4 && (this._context.bindTexture(null, t4.unit), this._freeTextureUnit(t4), this._textures.delete(e3)), null;
    }
    let i2 = this._textures.get(e3);
    return null == i2 ? (i2 = this._allocTextureUnit(r2), this._textures.set(e3, i2)) : i2.texture = r2, this._context.useProgram(this), this.setUniform1i(e3, i2.unit), this._context.bindTexture(r2, i2.unit), i2.unit;
  }
  rebindTextures() {
    this._context.useProgram(this), this._textures.forEach((t4, e3) => {
      this._context.bindTexture(t4.texture, t4.unit), this.setUniform1i(e3, t4.unit);
    }), r(this._fragmentUniforms) && this._fragmentUniforms.forEach((t4) => {
      "sampler2D" !== t4.type && "samplerCube" !== t4.type || this._textures.has(t4.name) || console.error(`Texture sampler ${t4.name} has no bound texture`);
    });
  }
  _allocTextureUnit(t4) {
    return { texture: t4, unit: 0 === this._freeTextureUnits.length ? this._textures.size : this._freeTextureUnits.pop() };
  }
  _freeTextureUnit(t4) {
    this._freeTextureUnits.push(t4.unit);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/StencilUtils.js
var i = { func: I.LESS };
var s2 = { func: I.ALWAYS };
var e2 = { mask: 255 };
var l = { mask: 0 };
var t3 = (a3) => ({ function: { func: I.NOTEQUAL, ref: a3, mask: a3 }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.KEEP } });
var u2 = (a3) => ({ function: { func: I.ALWAYS, ref: a3, mask: a3 }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.REPLACE } });
var f = { function: { func: I.ALWAYS, ref: a.OutlineVisualElementMask, mask: a.OutlineVisualElementMask }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.ZERO } };
var o2 = { function: { func: I.ALWAYS, ref: a.OutlineVisualElementMask, mask: a.OutlineVisualElementMask }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.REPLACE } };
var P = { function: { func: I.EQUAL, ref: a.OutlineVisualElementMask, mask: a.OutlineVisualElementMask }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.KEEP } };
var m = { function: { func: I.NOTEQUAL, ref: a.OutlineVisualElementMask, mask: a.OutlineVisualElementMask }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.KEEP } };

export {
  t2 as t,
  e,
  o,
  i,
  s2 as s,
  e2,
  l,
  t3 as t2,
  u2 as u,
  f,
  o2,
  P,
  m
};
//# sourceMappingURL=chunk-NXOQBIK7.js.map
