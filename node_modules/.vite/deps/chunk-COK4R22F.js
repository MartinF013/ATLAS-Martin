import {
  I as I2,
  P as P2,
  n,
  t as t3,
  v as v3
} from "./chunk-T6XN76GI.js";
import {
  t as t2
} from "./chunk-EZ4QR7V3.js";
import {
  E as E2,
  a as a3,
  c as c3,
  f as f3,
  l as l2,
  o as o2,
  v as v2
} from "./chunk-EMETVH63.js";
import {
  J,
  P,
  U,
  x
} from "./chunk-V56SVRSV.js";
import {
  M,
  f as f2,
  g
} from "./chunk-XZHFGTRH.js";
import {
  w
} from "./chunk-JZY7CGEI.js";
import {
  te
} from "./chunk-6SWQ7R36.js";
import {
  L
} from "./chunk-4I3W4KD5.js";
import {
  d as d2
} from "./chunk-FU5UMT3R.js";
import {
  h,
  r as r2
} from "./chunk-F5A4XAOJ.js";
import {
  z
} from "./chunk-RN2KRYDN.js";
import {
  A,
  D,
  a as a2,
  f
} from "./chunk-TMBOFNWA.js";
import {
  o,
  u
} from "./chunk-56RHM4A6.js";
import {
  a as a4
} from "./chunk-D7DLEBS2.js";
import {
  c as c2,
  d,
  s as s2
} from "./chunk-4PRVTUEZ.js";
import {
  c
} from "./chunk-VLCG72SW.js";
import {
  E,
  I
} from "./chunk-3NMRL5CR.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  a2 as a,
  l,
  r,
  t,
  v2 as v,
  y2 as y
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/graphics/data/QueryEngine.js
function V(e) {
  return e.every((e2) => "exceedslimit" !== e2.statisticType);
}
var W = "feature-store:unsupported-query";
var K = new h(2e6);
var X = 0;
var Y = class {
  constructor(e) {
    this.capabilities = { query: t2 }, this.geometryType = e.geometryType, this.hasM = e.hasM, this.hasZ = e.hasZ, this.objectIdField = e.objectIdField, this.spatialReference = e.spatialReference, this.definitionExpression = e.definitionExpression, this.featureStore = e.featureStore, this.aggregateAdapter = e.aggregateAdapter, this._changeHandle = this.featureStore.events.on("changed", () => this.clearCache()), this.timeInfo = e.timeInfo, e.cacheSpatialQueries && (this._geometryQueryCache = new r2(X++ + "$$", K)), this.fieldsIndex = new d2(e.fields), e.scheduler && e.priority && (this._frameTask = e.scheduler.registerTask(e.priority));
  }
  destroy() {
    this._frameTask = a(this._frameTask), this.clearCache(), l(this._geometryQueryCache), this._changeHandle = a(this._changeHandle), l(this.fieldsIndex);
  }
  get featureAdapter() {
    return this.featureStore.featureAdapter;
  }
  get fullExtent() {
    const e = this.featureStore.fullBounds;
    return t(e) ? null : { xmin: e[0], ymin: e[1], xmax: e[2], ymax: e[3], spatialReference: x(this.spatialReference) };
  }
  get timeExtent() {
    return this.timeInfo ? (this._timeExtent || (this._timeExtent = t3(this.timeInfo, this.featureStore)), this._timeExtent) : null;
  }
  clearCache() {
    var _a;
    (_a = this._geometryQueryCache) == null ? void 0 : _a.clear(), this._allItems = null, this._timeExtent = null;
  }
  async executeQuery(e, t4) {
    try {
      return (await this._executeQuery(e, {}, t4)).createQueryResponse();
    } catch (i) {
      if (i !== U)
        throw i;
      return new v2([], e, this).createQueryResponse();
    }
  }
  async executeQueryForCount(e = {}, t4) {
    try {
      return (await this._executeQuery(e, { returnGeometry: false, returnCentroid: false, outSR: null }, t4)).createQueryResponseForCount();
    } catch (i) {
      if (i !== U)
        throw i;
      return 0;
    }
  }
  async executeQueryForExtent(e, t4) {
    const i = e.outSR;
    try {
      const s3 = await this._executeQuery(e, { returnGeometry: true, returnCentroid: false, outSR: null }, t4), r3 = s3.size;
      if (!r3)
        return { count: 0, extent: null };
      A(te2, D), this.featureStore.forEachBounds(s3.items, (e2) => f(te2, e2), ee);
      const a5 = { xmin: te2[0], ymin: te2[1], xmax: te2[3], ymax: te2[4], spatialReference: x(this.spatialReference) };
      this.hasZ && isFinite(te2[2]) && isFinite(te2[5]) && (a5.zmin = te2[2], a5.zmax = te2[5]);
      const n2 = g(a5, s3.spatialReference, i);
      if (n2.spatialReference = x(i || this.spatialReference), n2.xmax - n2.xmin == 0) {
        const e2 = z(n2.spatialReference);
        n2.xmin -= e2, n2.xmax += e2;
      }
      if (n2.ymax - n2.ymin == 0) {
        const e2 = z(n2.spatialReference);
        n2.ymin -= e2, n2.ymax += e2;
      }
      if (this.hasZ && null != n2.zmin && null != n2.zmax && n2.zmax - n2.zmin == 0) {
        const e2 = z(n2.spatialReference);
        n2.zmin -= e2, n2.zmax += e2;
      }
      return { count: r3, extent: n2 };
    } catch (s3) {
      if (s3 === U)
        return { count: 0, extent: null };
      throw s3;
    }
  }
  async executeQueryForIds(e, t4) {
    return this.executeQueryForIdSet(e, t4).then((e2) => Array.from(e2));
  }
  async executeQueryForIdSet(e, t4) {
    try {
      const i = await this._executeQuery(e, { returnGeometry: true, returnCentroid: false, outSR: null }, t4), s3 = i.items, r3 = /* @__PURE__ */ new Set();
      return await this._reschedule(() => {
        for (const e2 of s3)
          r3.add(i.featureAdapter.getObjectId(e2));
      }, t4), r3;
    } catch (i) {
      if (i === U)
        return /* @__PURE__ */ new Set();
      throw i;
    }
  }
  async executeQueryForSnapping(e, t4) {
    const { point: i, distance: s3, types: r3 } = e;
    if (r3 === E2.NONE)
      return { candidates: [] };
    const a5 = await this._reschedule(() => this._checkQuerySupport(e.query), t4), o3 = !E(i.spatialReference, this.spatialReference);
    o3 && await f2(i.spatialReference, this.spatialReference);
    const u2 = "number" == typeof s3 ? s3 : s3.x, c4 = "number" == typeof s3 ? s3 : s3.y, h2 = { xmin: i.x - u2, xmax: i.x + u2, ymin: i.y - c4, ymax: i.y + c4, spatialReference: i.spatialReference }, l3 = o3 ? g(h2, this.spatialReference) : h2;
    if (!l3)
      return { candidates: [] };
    const m2 = (await L(d(i), null, { signal: t4 }))[0], p = (await L(d(l3), null, { signal: t4 }))[0];
    if (t(m2) || t(p))
      return { candidates: [] };
    const f4 = new v2(this._searchFeatures(this._getQueryBBoxes(p.toJSON())), a5, this);
    await this._reschedule(() => this._executeObjectIdsQuery(f4), t4), await this._reschedule(() => this._executeTimeQuery(f4), t4), await this._reschedule(() => this._executeAttributesQuery(f4), t4);
    const d3 = m2.toJSON(), y2 = o3 ? g(d3, this.spatialReference) : d3, g2 = o3 ? Math.max(l3.xmax - l3.xmin, l3.ymax - l3.ymin) / 2 : s3;
    return f4.createSnappingResponse({ ...e, point: y2, distance: g2 }, i.spatialReference);
  }
  async executeQueryForLatestObservations(e, t4) {
    if (!this.timeInfo || !this.timeInfo.trackIdField)
      throw new s(W, "Missing timeInfo or timeInfo.trackIdField", { query: e, timeInfo: this.timeInfo });
    try {
      const i = await this._executeQuery(e, {}, t4);
      return await this._reschedule(() => this._filterLatest(i), t4), i.createQueryResponse();
    } catch (s3) {
      if (s3 !== U)
        throw s3;
      return new v2([], e, this).createQueryResponse();
    }
  }
  async executeQueryForSummaryStatistics(e = {}, t4, i) {
    const { field: s3, normalizationField: r3, valueExpression: a5 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s3, normalizationField: r3, valueExpression: a5 }, i)).createSummaryStatisticsResponse(t4);
  }
  async executeQueryForUniqueValues(e = {}, t4, i) {
    const { field: s3, valueExpression: r3 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s3, valueExpression: r3 }, i)).createUniqueValuesResponse(t4);
  }
  async executeQueryForClassBreaks(e = {}, t4, i) {
    const { field: s3, normalizationField: r3, valueExpression: a5 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s3, normalizationField: r3, valueExpression: a5 }, i)).createClassBreaksResponse(t4);
  }
  async executeQueryForHistogram(e = {}, t4, i) {
    const { field: s3, normalizationField: r3, valueExpression: a5 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s3, normalizationField: r3, valueExpression: a5 }, i)).createHistogramResponse(t4);
  }
  async _schedule(e, t4) {
    return r(this._frameTask) ? this._frameTask.schedule(e, t4) : e(w);
  }
  async _reschedule(e, t4) {
    return r(this._frameTask) ? this._frameTask.reschedule(e, t4) : e(w);
  }
  _getAll(e) {
    return t(this._allItems) && (this._allItems = this.featureStore.toArray()), new v2(this._allItems, e, this);
  }
  async _executeQuery(e, t4, i) {
    e = m(e), e = await this._schedule(() => P(e, this.definitionExpression, this.spatialReference), i), e = await this._reschedule(() => this._checkQuerySupport(e), i), e = { ...e, ...t4 };
    const r3 = await this._reschedule(() => this._executeSceneFilterQuery(e, i), i), a5 = await this._reschedule(() => this._executeGeometryQuery(e, r3, i), i);
    return await this._reschedule(() => this._executeAggregateIdsQuery(a5), i), await this._reschedule(() => this._executeObjectIdsQuery(a5), i), await this._reschedule(() => this._executeTimeQuery(a5), i), await this._reschedule(() => this._executeAttributesQuery(a5), i), a5;
  }
  async _executeSceneFilterQuery(e, t4) {
    if (t(e.sceneFilter))
      return null;
    const { outSR: i, returnGeometry: s3, returnCentroid: r3 } = e, a5 = this.featureStore.featureSpatialReference, o3 = e.sceneFilter.geometry, u2 = t(a5) || E(a5, o3.spatialReference) ? o3 : g(o3, a5);
    if (!u2)
      return null;
    const c4 = s3 || r3, h2 = I(i) && !E(this.spatialReference, i) && c4 ? async (e2) => this._project(e2, i) : (e2) => e2, l3 = this.featureAdapter, m2 = this._searchFeatures(this._getQueryBBoxes(u2));
    if ("disjoint" === e.sceneFilter.spatialRelationship) {
      if (!m2.length)
        return null;
      const i2 = /* @__PURE__ */ new Set();
      for (const e2 of m2)
        i2.add(l3.getObjectId(e2));
      const s4 = await this._reschedule(() => this.featureStore.toArray(), t4), r4 = await this._reschedule(async () => {
        const r5 = await v3("esriSpatialRelDisjoint", u2, this.geometryType, this.hasZ, this.hasM), a6 = (e2) => !i2.has(l3.getObjectId(e2)) || r5(l3.getGeometry(e2)), n2 = await this._runSpatialFilter(s4, a6, t4);
        return new v2(n2, e, this);
      }, t4);
      return h2(r4);
    }
    if (!m2.length)
      return new v2([], e, this);
    if (this._canExecuteSinglePass(u2, e))
      return h2(new v2(m2, e, this));
    const p = await v3("esriSpatialRelContains", u2, this.geometryType, this.hasZ, this.hasM), f4 = await this._runSpatialFilter(m2, (e2) => p(l3.getGeometry(e2)), t4);
    return h2(new v2(f4, e, this));
  }
  async _executeGeometryQuery(i, s3, r3) {
    if (r(s3) && 0 === s3.items.length)
      return s3;
    i = r(s3) ? s3.query : i;
    const { geometry: a5, outSR: u2, spatialRel: c4, returnGeometry: h2, returnCentroid: l3 } = i, m2 = this.featureStore.featureSpatialReference, p = !a5 || t(m2) || E(m2, a5.spatialReference) ? a5 : g(a5, m2), f4 = h2 || l3, d3 = I(u2) && !E(this.spatialReference, u2), y2 = this._geometryQueryCache && t(s3) ? d3 && f4 ? JSON.stringify({ originalFilterGeometry: a5, spatialRelationship: c4, outSpatialReference: u2 }) : JSON.stringify({ originalFilterGeometry: a5, spatialRelationship: c4 }) : null, g2 = y2 ? this._geometryQueryCache.get(y2) : null;
    if (r(g2))
      return new v2(g2, i, this);
    const x2 = async (e) => (d3 && f4 && await this._project(e, u2), y2 && this._geometryQueryCache.put(y2, e.items, e.items.length + 1), e);
    if (!p)
      return x2(r(s3) ? s3 : this._getAll(i));
    const _ = this.featureAdapter;
    let w2 = this._searchFeatures(this._getQueryBBoxes(a5));
    if ("esriSpatialRelDisjoint" === c4) {
      if (!w2.length)
        return x2(r(s3) ? s3 : this._getAll(i));
      const e = /* @__PURE__ */ new Set();
      for (const i2 of w2)
        e.add(_.getObjectId(i2));
      const t4 = r(s3) ? s3.items : await this._reschedule(() => this.featureStore.toArray(), r3), a6 = await this._reschedule(async () => {
        const s4 = await v3(c4, p, this.geometryType, this.hasZ, this.hasM), a7 = (t5) => !e.has(_.getObjectId(t5)) || s4(_.getGeometry(t5)), n2 = await this._runSpatialFilter(t4, a7, r3);
        return new v2(n2, i, this);
      }, r3);
      return x2(a6);
    }
    if (r(s3)) {
      const i2 = new y();
      w2 = w2.filter((e) => v(s3.items, e, s3.items.length, i2) >= 0);
    }
    if (!w2.length) {
      const e = new v2([], i, this);
      return y2 && this._geometryQueryCache.put(y2, e.items, 1), e;
    }
    if (this._canExecuteSinglePass(p, i))
      return x2(new v2(w2, i, this));
    const S = await v3(c4, p, this.geometryType, this.hasZ, this.hasM), Q = await this._runSpatialFilter(w2, (e) => S(_.getGeometry(e)), r3);
    return x2(new v2(Q, i, this));
  }
  _executeAggregateIdsQuery(e) {
    if (0 === e.items.length || !e.query.aggregateIds || !e.query.aggregateIds.length || t(this.aggregateAdapter))
      return;
    const t4 = /* @__PURE__ */ new Set();
    for (const s3 of e.query.aggregateIds) {
      this.aggregateAdapter.getFeatureObjectIds(s3).forEach((e2) => t4.add(e2));
    }
    const i = this.featureAdapter.getObjectId;
    e.items = e.items.filter((e2) => t4.has(i(e2)));
  }
  _executeObjectIdsQuery(e) {
    if (0 === e.items.length || !e.query.objectIds || !e.query.objectIds.length)
      return;
    const t4 = new Set(e.query.objectIds), i = this.featureAdapter.getObjectId;
    e.items = e.items.filter((e2) => t4.has(i(e2)));
  }
  _executeTimeQuery(e) {
    if (0 === e.items.length)
      return;
    const t4 = n(this.timeInfo, e.query.timeExtent, this.featureAdapter);
    t(t4) || (e.items = e.items.filter(t4));
  }
  _executeAttributesQuery(e) {
    if (0 === e.items.length)
      return;
    const t4 = l2(e.query.where, this.fieldsIndex);
    if (t4) {
      if (!t4.isStandardized)
        throw new TypeError("Where clause is not standardized");
      e.items = e.items.filter((e2) => t4.testFeature(e2, this.featureAdapter));
    }
  }
  async _runSpatialFilter(e, t4, i) {
    if (!t4)
      return e;
    if (t(this._frameTask))
      return e.filter((e2) => t4(e2));
    let s3 = 0;
    const r3 = new Array(), a5 = async (n2) => {
      for (; s3 < e.length; ) {
        const o3 = e[s3++];
        t4(o3) && (r3.push(o3), n2.madeProgress()), n2.done && await this._reschedule((e2) => a5(e2), i);
      }
    };
    return this._reschedule((e2) => a5(e2), i).then(() => r3);
  }
  _filterLatest(e) {
    const { trackIdField: t4, startTimeField: i, endTimeField: s3 } = this.timeInfo, r3 = s3 || i, a5 = /* @__PURE__ */ new Map(), n2 = this.featureAdapter.getAttribute;
    for (const o3 of e.items) {
      const e2 = n2(o3, t4), i2 = n2(o3, r3), s4 = a5.get(e2);
      (!s4 || i2 > n2(s4, r3)) && a5.set(e2, o3);
    }
    e.items = Array.from(a5.values());
  }
  _canExecuteSinglePass(e, t4) {
    const { spatialRel: i } = t4;
    return I2(e) && ("esriSpatialRelEnvelopeIntersects" === i || "esriGeometryPoint" === this.geometryType && ("esriSpatialRelIntersects" === i || "esriSpatialRelContains" === i || "esriSpatialRelWithin" === i));
  }
  async _project(e, t4) {
    if (!t4 || E(this.spatialReference, t4))
      return e;
    const i = this.featureAdapter, s3 = await M(e.items.map((e2) => J(this.geometryType, this.hasZ, this.hasM, i.getGeometry(e2))), this.spatialReference, t4);
    return e.items = s3.map((t5, s4) => i.cloneWithGeometry(e.items[s4], te(t5, this.hasZ, this.hasM))), e;
  }
  _getQueryBBoxes(e) {
    if (I2(e)) {
      if (s2(e))
        return [o(e.xmin, e.ymin, e.xmax, e.ymax)];
      if (c2(e))
        return e.rings.map((e2) => o(Math.min(e2[0][0], e2[2][0]), Math.min(e2[0][1], e2[2][1]), Math.max(e2[0][0], e2[2][0]), Math.max(e2[0][1], e2[2][1])));
    }
    return [c(u(), e)];
  }
  _searchFeatures(e) {
    for (const i of e)
      this.featureStore.forEachInBounds(i, (e2) => ie.add(e2));
    const t4 = Array.from(ie.values());
    return ie.clear(), t4;
  }
  async _checkStatisticsSupport(e, t4) {
    if (e.distance < 0 || null != e.geometryPrecision || e.multipatchOption || e.pixelSize || e.relationParam || e.text || e.outStatistics || e.groupByFieldsForStatistics || e.having || e.orderByFields)
      throw new s(W, "Unsupported query options", { query: e });
    return this._checkAttributesQuerySupport(e), Promise.all([this._checkStatisticsParamsSupport(t4), P2(e, this.geometryType, this.spatialReference), f2(this.spatialReference, e.outSR)]).then(() => e);
  }
  async _checkStatisticsParamsSupport(e) {
    let t4 = [];
    if (e.valueExpression) {
      const { arcadeUtils: i } = await a4();
      t4 = i.extractFieldNames(e.valueExpression);
    }
    if (e.field && t4.push(e.field), e.normalizationField && t4.push(e.normalizationField), !t4.length)
      throw new s(W, "params should have at least a field or valueExpression", { params: e });
    c3(this.fieldsIndex, t4, "params contains missing fields");
  }
  async _checkQuerySupport(e) {
    if (e.distance < 0 || null != e.geometryPrecision || e.multipatchOption || e.pixelSize || e.relationParam || e.text)
      throw new s(W, "Unsupported query options", { query: e });
    return this._checkAttributesQuerySupport(e), this._checkStatisticsQuerySupport(e), Promise.all([P2(e, this.geometryType, this.spatialReference), f2(this.spatialReference, e.outSR)]).then(() => e);
  }
  _checkAttributesQuerySupport(e) {
    const { outFields: t4, orderByFields: s3, returnDistinctValues: r3, outStatistics: a5 } = e, n2 = a5 ? a5.map((e2) => e2.outStatisticFieldName && e2.outStatisticFieldName.toLowerCase()).filter(Boolean) : [];
    if (s3 && s3.length > 0) {
      const e2 = " asc", t5 = " desc", i = s3.map((i2) => {
        const s4 = i2.toLowerCase();
        return s4.includes(e2) ? s4.split(e2)[0] : s4.includes(t5) ? s4.split(t5)[0] : i2;
      }).filter((e3) => !n2.includes(e3));
      c3(this.fieldsIndex, i, "orderByFields contains missing fields");
    }
    if (t4 && t4.length > 0)
      c3(this.fieldsIndex, t4, "outFields contains missing fields");
    else if (r3)
      throw new s(W, "outFields should be specified for returnDistinctValues", { query: e });
    o2(this.fieldsIndex, e.where);
  }
  _checkStatisticsQuerySupport(e) {
    const { outStatistics: t4, groupByFieldsForStatistics: s3, having: r3 } = e, a5 = s3 && s3.length, n2 = t4 && t4.length;
    if (r3) {
      if (!a5 || !n2)
        throw new s(W, "outStatistics and groupByFieldsForStatistics should be specified with having", { query: e });
      a3(this.fieldsIndex, r3, t4);
    }
    if (n2) {
      if (!V(t4))
        return;
      const r4 = t4.map((e2) => e2.onStatisticField).filter(Boolean);
      c3(this.fieldsIndex, r4, "onStatisticFields contains missing fields"), a5 && c3(this.fieldsIndex, s3, "groupByFieldsForStatistics contains missing fields");
      for (const s4 of t4) {
        const { onStatisticField: t5, statisticType: r5 } = s4;
        if (("percentile_disc" === r5 || "percentile_cont" === r5) && "statisticParameters" in s4) {
          const { statisticParameters: t6 } = s4;
          if (!t6)
            throw new s(W, "statisticParamters should be set for percentile type", { definition: s4, query: e });
        } else if ("count" !== r5 && t5 && f3(t5, this.fieldsIndex))
          throw new s(W, "outStatistics contains non-numeric fields", { definition: s4, query: e });
      }
    }
  }
  async _getQueryEngineResultForStats(e, t4, i) {
    e = m(e);
    try {
      e = await this._schedule(() => P(e, this.definitionExpression, this.spatialReference), i), e = await this._reschedule(() => this._checkStatisticsSupport(e, t4), i);
      const s3 = await this._reschedule(() => this._executeSceneFilterQuery(e, i), i), r3 = await this._reschedule(() => this._executeGeometryQuery(e, s3, i), i);
      return await this._reschedule(() => this._executeAggregateIdsQuery(r3), i), await this._reschedule(() => this._executeObjectIdsQuery(r3), i), await this._reschedule(() => this._executeTimeQuery(r3), i), await this._reschedule(() => this._executeAttributesQuery(r3), i), r3;
    } catch (r3) {
      if (r3 !== U)
        throw r3;
      return new v2([], e, this);
    }
  }
};
var ee = a2();
var te2 = a2();
var ie = /* @__PURE__ */ new Set();

export {
  Y
};
//# sourceMappingURL=chunk-COK4R22F.js.map
