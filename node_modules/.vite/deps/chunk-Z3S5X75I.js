import {
  o
} from "./chunk-NMRWU44S.js";
import {
  e as e2
} from "./chunk-YL26MZEL.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  i
} from "./chunk-U3PSONS6.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  a,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/input/keys.js
var t2 = a("mac") ? "Meta" : "Ctrl";
var o2 = { 8: "Backspace", 9: "Tab", 13: "Enter", 27: "Escape", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete" };
for (let s4 = 48; s4 < 58; s4++)
  o2[s4] = String.fromCharCode(s4);
for (let s4 = 1; s4 < 25; s4++)
  o2[111 + s4] = `F${s4}`;
for (let s4 = 65; s4 < 91; s4++)
  o2[s4] = [String.fromCharCode(s4 + 32), String.fromCharCode(s4)];
function a2(e4) {
  if (void 0 !== e4.key)
    return i(e4);
  const t3 = o2[e4.keyCode];
  return Array.isArray(t3) ? e4.shiftKey ? t3[1] : t3[0] : t3;
}
function n2(r) {
  switch (r) {
    case "Ctrl":
    case "Alt":
    case "Shift":
    case "Meta":
    case "Primary":
      return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/input/EventMatch.js
var e3 = class {
  constructor(e4, t3 = []) {
    this.eventType = e4, this.keyModifiers = t3;
  }
  matches(e4) {
    if (e4.type !== this.eventType)
      return false;
    if (0 === this.keyModifiers.length)
      return true;
    const t3 = e4.modifiers;
    for (const i3 of this.keyModifiers)
      if (!t3.has(i3))
        return false;
    return true;
  }
};

// node_modules/@arcgis/core/views/input/InputHandler.js
var n3 = s.getLogger("esri.views.input.InputHandler");
var i2 = class {
  constructor(e4) {
    this._manager = null, this._incoming = {}, this._outgoing = {}, this._incomingEventMatches = null, this._incomingEventTypes = null, this._outgoingEventTypes = null, this._hasSideEffects = e4;
  }
  get incomingEventMatches() {
    if (!this._incomingEventMatches) {
      this._incomingEventMatches = [];
      for (const e4 in this._incoming) {
        const t3 = this._incoming[e4];
        for (const e5 of t3)
          this._incomingEventMatches.push(e5.match);
      }
    }
    return this._incomingEventMatches;
  }
  get incomingEventTypes() {
    return this._incomingEventTypes || (this._incomingEventTypes = this.incomingEventMatches.map((e4) => e4.eventType)), this._incomingEventTypes;
  }
  get outgoingEventTypes() {
    return this._outgoingEventTypes || (this._outgoingEventTypes = Object.keys(this._outgoing)), this._outgoingEventTypes;
  }
  get hasSideEffects() {
    return this._hasSideEffects;
  }
  get hasPendingInputs() {
    return false;
  }
  onInstall(e4) {
    this._manager ? n3.error("This InputHandler has already been registered with an InputManager") : (e4.setEventCallback((e5) => this._handleEvent(e5)), e4.setUninstallCallback(() => this._onUninstall()), this._manager = e4);
  }
  onUninstall() {
  }
  registerIncoming(e4, n4, i3) {
    let a4;
    "function" == typeof n4 ? (i3 = n4, a4 = []) : a4 = n4 || [];
    const o3 = "string" == typeof e4 ? new e3(e4, a4) : e4, h = () => {
      this._incomingEventTypes = null, this._incomingEventMatches = null;
    }, r = (e5) => {
      const t3 = this._incoming[e5.match.eventType];
      if (t3) {
        const n5 = t3.indexOf(e5);
        t3.splice(n5, 1), h(), this._manager && this._manager.updateDependencies();
      }
    }, g2 = new s2(o3, i3, { onPause: r, onRemove: r, onResume: (e5) => {
      const t3 = this._incoming[e5.match.eventType];
      t3 && !t3.includes(e5) && (t3.push(e5), h(), this._manager && this._manager.updateDependencies());
    } });
    let c2 = this._incoming[o3.eventType];
    return c2 || (c2 = [], this._incoming[o3.eventType] = c2), c2.push(g2), h(), this._manager && this._manager.updateDependencies(), g2;
  }
  registerOutgoing(e4) {
    if (this._outgoing[e4])
      throw Error("There is already a callback registered for this outgoing InputEvent: " + e4);
    const t3 = new a3(e4, { onEmit: (e5, t4, n4, i3) => {
      this._manager.emit(e5.eventType, t4, n4, i3);
    }, onRemove: (e5) => {
      delete this._outgoing[e5.eventType], this._manager.updateDependencies();
    } });
    return this._outgoing[e4] = t3, this._outgoingEventTypes = null, this._manager && this._manager.updateDependencies(), t3;
  }
  startCapturingPointer(e4) {
    this._manager.setPointerCapture(e4, true);
  }
  stopCapturingPointer(e4) {
    this._manager.setPointerCapture(e4, false);
  }
  refreshHasPendingInputs() {
    this._manager.refreshHasPendingInputs();
  }
  _onUninstall() {
    this._manager ? (this.onUninstall(), this._manager = null) : n3.error("This InputHandler is not registered with an InputManager");
  }
  _handleEvent(e4) {
    const t3 = this._incoming[e4.type];
    if (t3) {
      for (const n4 of t3)
        if (n4.match.matches(e4) && (n4.callback(e4), e4.shouldStopPropagation()))
          break;
    }
  }
};
var s2 = class {
  constructor(e4, t3, n4) {
    this.match = e4, this._callback = t3, this._handler = n4;
  }
  pause() {
    this._handler.onPause(this);
  }
  resume() {
    this._handler.onResume(this);
  }
  remove() {
    this._handler.onRemove(this);
  }
  get callback() {
    return this._callback;
  }
};
var a3 = class {
  constructor(e4, t3) {
    this.eventType = e4, this._removed = false, this._handler = t3;
  }
  emit(e4, t3, n4) {
    this._removed || this._handler.onEmit(this, e4, t3, n4);
  }
  remove() {
    this._removed = true, this._handler.onRemove(this);
  }
};

// node_modules/@arcgis/core/views/input/handlers/LatestPointer.js
var s3 = class extends i2 {
  constructor(t3) {
    super(true), this._onChange = t3, this._value = "mouse", this._x = null, this._y = null, this.registerIncoming("pointer-move", (t4) => {
      const s4 = "touch" === t4.data.native.pointerType;
      this._setValue(s4 ? "touch" : "mouse", t4.data.x, t4.data.y);
    });
  }
  _setValue(t3, s4, e4) {
    t3 === this._value && this._x === s4 && this._y === e4 || (this._value = t3, this._x = s4, this._y = e4, this._onChange(t3, s4, e4));
  }
};

// node_modules/@arcgis/core/views/input/InputManager.js
var d2 = s.getLogger("esri.views.input.InputManager");
var c = class extends y {
  constructor(e4) {
    super(e4), this._pointerCaptures = /* @__PURE__ */ new Map(), this._nameToGroup = {}, this._handlers = [], this._currentPropagation = null, this._updateDependenciesAfterPropagation = false, this._sourceEvents = /* @__PURE__ */ new Set(), this._keyModifiers = /* @__PURE__ */ new Set(), this._activeKeyModifiers = /* @__PURE__ */ new Set(), this._stoppedPropagationEventIds = /* @__PURE__ */ new Set(), this.primaryKey = t2, this.latestPointerType = "mouse", this._propertiesPool = new o({ latestPointerLocation: P }, this), this.latestPointerLocation = null, this.test = { timestamp: void 0, hasCurrentPropagation: () => !!this._currentPropagation };
  }
  initialize() {
    this.eventSource.onEventReceived = this._onEventReceived.bind(this), this._installRecognizers();
  }
  destroy() {
    const e4 = Object.keys(this._nameToGroup);
    for (const t3 of e4)
      this.uninstallHandlers(t3);
    this.eventSource = null, this._currentPropagation = null, this._propertiesPool.destroy();
  }
  get hasPendingInputs() {
    return this._handlers.some((e4) => e4.handler.hasPendingInputs);
  }
  installHandlers(e4, t3, r = g.INTERNAL) {
    if (this._nameToGroup[e4])
      return void d2.error("There is already an InputHandler group registered under the name `" + e4 + "`");
    if (0 === t3.length)
      return void d2.error("Can't register a group of zero handlers");
    const i3 = { name: e4, handlers: t3.map((e5) => ({ handler: e5, active: true, removed: false, priorityIndex: 0, groupPriority: r, eventCallback: null, uninstallCallback: null })) };
    this._nameToGroup[e4] = i3;
    for (let n4 = i3.handlers.length - 1; n4 >= 0; n4--) {
      const e5 = i3.handlers[n4];
      this._handlers.push(e5), e5.handler.onInstall({ updateDependencies: () => {
        this.updateDependencies();
      }, emit: (t4, r2, i4, n5, s4) => {
        this._emitInputEvent(e5.priorityIndex + 1, t4, r2, i4, s4, n5);
      }, setPointerCapture: (t4, r2) => {
        this._setPointerCapture(i3, e5, t4, r2);
      }, setEventCallback: (t4) => {
        e5.eventCallback = t4;
      }, setUninstallCallback: (t4) => {
        e5.uninstallCallback = t4;
      }, refreshHasPendingInputs: () => {
        this.notifyChange("hasPendingInputs");
      } });
    }
    this.updateDependencies();
  }
  uninstallHandlers(e4) {
    const t3 = this._nameToGroup[e4];
    t3 ? (t3.handlers.forEach((e5) => {
      e5.removed = true, e5.uninstallCallback();
    }), delete this._nameToGroup[e4], this._currentPropagation ? this._currentPropagation.needsHandlerGarbageCollect = true : this._garbageCollectRemovedHandlers()) : d2.error("There is no InputHandler group registered under the name `" + e4 + "`");
  }
  hasHandlers(e4) {
    return void 0 !== this._nameToGroup[e4];
  }
  updateDependencies() {
    if (this._currentPropagation)
      return void (this._updateDependenciesAfterPropagation = true);
    this._updateDependenciesAfterPropagation = false;
    const e4 = /* @__PURE__ */ new Set(), t3 = /* @__PURE__ */ new Set();
    this._handlersPriority = [];
    for (let r = this._handlers.length - 1; r >= 0; r--) {
      const e5 = this._handlers[r];
      e5.priorityIndex = r, this._handlersPriority.push(e5);
    }
    this._handlersPriority = this._sortHandlersPriority(this._handlersPriority);
    for (let r = this._handlersPriority.length - 1; r >= 0; r--) {
      const i3 = this._handlersPriority[r];
      i3.priorityIndex = r;
      let n4 = i3.handler.hasSideEffects;
      if (!n4) {
        for (const t4 of i3.handler.outgoingEventTypes)
          if (e4.has(t4)) {
            n4 = true;
            break;
          }
      }
      if (n4)
        for (const r2 of i3.handler.incomingEventMatches) {
          e4.add(r2.eventType);
          for (const e5 of r2.keyModifiers)
            n2(e5) || t3.add(e5);
        }
      i3.active = n4;
    }
    this._sourceEvents = e4, this._keyModifiers = t3, this._pointerCaptures.size > 0 && this._sourceEvents.add("pointer-capture-lost"), this._keyModifiers.size > 0 && (this._sourceEvents.add("key-down"), this._sourceEvents.add("key-up")), this.eventSource && (this.eventSource.activeEvents = this._sourceEvents);
  }
  _setLatestPointer(e4, t3, r) {
    this._get("latestPointerType") !== e4 && this._set("latestPointerType", e4);
    const n4 = this._get("latestPointerLocation");
    if (t(n4) || n4.x !== t3 || n4.y !== r) {
      const e5 = this._propertiesPool.get("latestPointerLocation");
      e5.x = t3, e5.y = r, this._set("latestPointerLocation", e5);
    }
  }
  _onEventReceived(e4, t3) {
    if ("pointer-capture-lost" === e4) {
      const e5 = t3;
      this._pointerCaptures.delete(e5.native.pointerId);
    }
    this._updateKeyModifiers(e4, t3);
    const r = null != this.test.timestamp ? this.test.timestamp : t3.native ? t3.native.timestamp : void 0, i3 = t3.native ? t3.native.cancelable : void 0;
    this._emitInputEventFromSource(e4, t3, r, i3);
  }
  _updateKeyModifiers(e4, t3) {
    if (!t3)
      return;
    let r = false;
    const i3 = () => {
      if (!r) {
        const e5 = /* @__PURE__ */ new Set();
        this._activeKeyModifiers.forEach((t4) => {
          e5.add(t4);
        }), this._activeKeyModifiers = e5, r = true;
      }
    }, n4 = (e5, t4) => {
      t4 && !this._activeKeyModifiers.has(e5) ? (i3(), this._activeKeyModifiers.add(e5)) : !t4 && this._activeKeyModifiers.has(e5) && (i3(), this._activeKeyModifiers.delete(e5));
    };
    if ("key-down" === e4 || "key-up" === e4) {
      const r2 = t3.key;
      this._keyModifiers.has(r2) && n4(r2, "key-down" === e4);
    }
    const s4 = t3.native;
    n4("Alt", !(!s4 || !s4.altKey)), n4("Ctrl", !(!s4 || !s4.ctrlKey)), n4("Shift", !(!s4 || !s4.shiftKey)), n4("Meta", !(!s4 || !s4.metaKey)), n4("Primary", this._activeKeyModifiers.has(this.primaryKey));
  }
  _installRecognizers() {
    this._latestPointerHandler = new s3((e4, t3, r) => this._setLatestPointer(e4, t3, r)), this.installHandlers("input-manager-logic", [this._latestPointerHandler], g.ALWAYS), this.recognizers.length > 0 && this.installHandlers("default", this.recognizers, g.INTERNAL);
  }
  _setPointerCapture(e4, t3, r, i3) {
    const n4 = e4.name + "-" + t3.priorityIndex, s4 = this._pointerCaptures.get(r.pointerId) || /* @__PURE__ */ new Set();
    this._pointerCaptures.set(r.pointerId, s4), i3 ? (s4.add(n4), 1 === s4.size && this.eventSource && this.eventSource.setPointerCapture(r, true)) : s4.has(n4) && (s4.delete(n4), 0 === s4.size && (this._pointerCaptures.delete(r.pointerId), this.eventSource && this.eventSource.setPointerCapture(r, false)));
  }
  _garbageCollectRemovedHandlers() {
    this._handlers = this._handlers.filter((e4) => !e4.removed), this.updateDependencies();
  }
  _emitInputEventFromSource(e4, t3, r, i3) {
    this._emitInputEvent(0, e4, t3, r, i3);
  }
  _emitInputEvent(e4, t3, r, i3, n4, s4) {
    const o3 = void 0 !== i3 ? i3 : this._currentPropagation ? this._currentPropagation.timestamp : performance.now(), a4 = void 0 !== n4 && n4, p = { event: new u(t3, r, o3, s4 || this._activeKeyModifiers, a4), priorityIndex: e4 };
    this._currentPropagation ? this._currentPropagation.events.push(p) : this._doNewPropagation(p);
  }
  _doNewPropagation(e4) {
    this._currentPropagation = { events: new e2(), currentHandler: null, needsHandlerGarbageCollect: false, timestamp: e4.event.timestamp }, this._currentPropagation.events.push(e4), this._continuePropagation();
  }
  _continuePropagation() {
    const e4 = this._currentPropagation;
    if (e4) {
      for (; this._currentPropagation.events.length > 0; ) {
        const { event: t3, priorityIndex: r } = this._currentPropagation.events.pop(), i3 = t3.data && t3.data.eventId;
        if (!(null != i3 && this._stoppedPropagationEventIds.has(i3)))
          for (e4.currentHandler = this._handlersPriority[r]; e4.currentHandler; ) {
            if (e4.currentHandler.removed)
              e4.needsHandlerGarbageCollect = true;
            else {
              if (e4.currentHandler.active && !t3.shouldStopPropagation() && e4.currentHandler.eventCallback(t3), t3.shouldStopPropagation()) {
                null != i3 && this._stoppedPropagationEventIds.add(i3);
                break;
              }
              if (t3.shouldPausePropagation(() => this._continuePropagation()))
                return void this._pausePropagation({ event: t3, priorityIndex: e4.currentHandler.priorityIndex + 1 });
            }
            e4.currentHandler = this._handlersPriority[e4.currentHandler.priorityIndex + 1];
          }
      }
      e4.needsHandlerGarbageCollect && this._garbageCollectRemovedHandlers(), this.hasPendingInputs || this._stoppedPropagationEventIds.clear(), this._currentPropagation = null, this._updateDependenciesAfterPropagation && this.updateDependencies();
    }
  }
  _pausePropagation(e4) {
    const t3 = new e2();
    for (t3.push(e4); this._currentPropagation.events.length; )
      t3.push(this._currentPropagation.events.pop());
    this._currentPropagation.events = t3, this._currentPropagation.currentHandler = null;
  }
  _compareHandlerPriority(e4, t3) {
    if (e4.handler.hasSideEffects !== t3.handler.hasSideEffects)
      return e4.handler.hasSideEffects ? 1 : -1;
    if (e4.groupPriority !== t3.groupPriority)
      return e4.groupPriority > t3.groupPriority ? -1 : 1;
    for (const r of e4.handler.incomingEventMatches)
      for (const e5 of t3.handler.incomingEventMatches) {
        if (r.eventType !== e5.eventType)
          continue;
        const t4 = r.keyModifiers.filter((t5) => e5.keyModifiers.includes(t5));
        if (t4.length === r.keyModifiers.length !== (t4.length === e5.keyModifiers.length))
          return r.keyModifiers.length > e5.keyModifiers.length ? -1 : 1;
      }
    return e4.priorityIndex > t3.priorityIndex ? -1 : 1;
  }
  _sortHandlersPriority(e4) {
    const t3 = [];
    for (const r of e4) {
      let e5 = 0;
      for (; e5 < t3.length && this._compareHandlerPriority(r, t3[e5]) >= 0; )
        e5++;
      t3.splice(e5, 0, r);
    }
    return t3;
  }
  get debug() {
    const e4 = (e5) => {
      const t3 = this._setPointerCapture;
      this._setPointerCapture = () => {
      }, e5(), this._setPointerCapture = t3;
    };
    return { injectEvent: (t3, r) => {
      e4(() => {
        this._onEventReceived(t3, r);
      });
    }, disablePointerCapture: e4 };
  }
};
e([d({ readOnly: true })], c.prototype, "hasPendingInputs", null), e([d()], c.prototype, "eventSource", void 0), e([d()], c.prototype, "recognizers", void 0), e([d({ readOnly: true })], c.prototype, "latestPointerType", void 0), e([d({ readOnly: true })], c.prototype, "latestPointerLocation", void 0), c = e([n("esri.views.input.InputManager")], c);
var u = class {
  constructor(e4, t3, r, i3, n4) {
    this.type = e4, this.data = t3, this.timestamp = r, this.modifiers = i3, this.cancelable = n4, this._propagationState = _.NONE, this._resumeCallback = null;
  }
  stopPropagation() {
    this._propagationState |= _.STOPPED;
  }
  shouldStopPropagation() {
    return 0 != (this._propagationState & _.STOPPED);
  }
  async(e4) {
    this._propagationState |= _.PAUSED;
    const t3 = (e5, t4) => {
      this._propagationState &= ~_.PAUSED;
      const r = this._resumeCallback;
      if (this._resumeCallback = null, r && r(), t4)
        throw e5;
      return e5;
    };
    return ("function" == typeof e4 ? e4() : e4).then((e5) => t3(e5, false), (e5) => t3(e5, true));
  }
  shouldPausePropagation(e4) {
    return !!(this._propagationState & _.PAUSED) && (this._resumeCallback = e4, true);
  }
  preventDefault() {
    this.data.native.preventDefault();
  }
};
var _;
!function(e4) {
  e4[e4.NONE = 0] = "NONE", e4[e4.STOPPED = 1] = "STOPPED", e4[e4.PAUSED = 2] = "PAUSED";
}(_ || (_ = {}));
var g = { ALWAYS: 1, DEFAULT: 0, TOOL: -1, WIDGET: -2, INTERNAL: -3 };
var P = class {
};

export {
  a2 as a,
  i2 as i,
  c,
  g
};
//# sourceMappingURL=chunk-Z3S5X75I.js.map
