import {
  a,
  l as l2,
  x
} from "./chunk-EQ3EWUVK.js";
import {
  L as L2,
  M,
  O as O2,
  R,
  V,
  h as h2,
  j as j3,
  k,
  v
} from "./chunk-FFHGE66H.js";
import {
  e2 as e4,
  r as r3,
  t as t3
} from "./chunk-MOZ4GR2L.js";
import {
  T,
  i as i2
} from "./chunk-MQBVOUKB.js";
import {
  e as e3,
  o
} from "./chunk-YFBAFAZ2.js";
import {
  e as e2
} from "./chunk-LUU3J646.js";
import {
  j as j2
} from "./chunk-3NPGGTI6.js";
import {
  Un,
  qn
} from "./chunk-PZWU5EHT.js";
import {
  B,
  C,
  c,
  f,
  h,
  i,
  q,
  u
} from "./chunk-ASC3X65B.js";
import {
  N,
  O,
  W,
  z
} from "./chunk-RN2KRYDN.js";
import {
  F,
  L
} from "./chunk-PKZEO23A.js";
import {
  n as n2,
  r as r2,
  t as t2
} from "./chunk-AIRC226G.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/geometry/support/MeshTransform.js
var T2;
var B2 = T2 = class extends l {
  constructor(r5) {
    super(r5), this.origin = n2(), this.translation = n2(), this.rotation = a(), this.scale = r2(1, 1, 1), this.geographic = true;
  }
  get localMatrix() {
    const r5 = e3();
    return q(r5, this.scale), f(r5, r5, x(this.rotation), l2(this.rotation)), c(r5, r5, this.translation), r5;
  }
  get localMatrixInverse() {
    return h(e3(), this.localMatrix);
  }
  applyLocal(r5, o2) {
    return L(o2, r5, this.localMatrix);
  }
  applyLocalInverse(r5, o2) {
    return L(o2, r5, this.localMatrixInverse);
  }
  project(r5, o2) {
    const t4 = new Float64Array(r5.length), s = T.fromTypedArray(t4), e5 = T.fromTypedArray(r5);
    if (this.geographic) {
      const r6 = O(o2), i4 = e3();
      return qn(o2, this.origin, i4, r6), u(i4, i4, this.localMatrix), t3(s, e5, i4), Un(t4, r6, 0, t4, o2, 0, t4.length / 3), t4;
    }
    const { localMatrix: i3, origin: a2 } = this;
    C(i3, o) ? e4(s, e5) : t3(s, e5, i3);
    for (let n3 = 0; n3 < t4.length; n3 += 3)
      t4[n3 + 0] += a2[0], t4[n3 + 1] += a2[1], t4[n3 + 2] += a2[2];
    return t4;
  }
  getOriginPoint(r5) {
    const [o2, t4, s] = this.origin;
    return new j({ x: o2, y: t4, z: s, spatialReference: r5 });
  }
  equals(r5) {
    return r(r5) && this.geographic === r5.geographic && F(this.origin, r5.origin) && B(this.localMatrix, r5.localMatrix);
  }
  clone() {
    const r5 = { origin: t2(this.origin), translation: t2(this.translation), rotation: a(this.rotation), scale: t2(this.scale), geographic: this.geographic };
    return new T2(r5);
  }
};
e([d({ type: [Number], nonNullable: true, json: { write: true } })], B2.prototype, "origin", void 0), e([d({ type: [Number], nonNullable: true, json: { write: true } })], B2.prototype, "translation", void 0), e([d({ type: [Number], nonNullable: true, json: { write: true } })], B2.prototype, "rotation", void 0), e([d({ type: [Number], nonNullable: true, json: { write: true } })], B2.prototype, "scale", void 0), e([d({ type: Boolean, nonNullable: true, json: { write: true } })], B2.prototype, "geographic", void 0), e([d()], B2.prototype, "localMatrix", null), e([d()], B2.prototype, "localMatrixInverse", null), B2 = T2 = e([n("esri.geometry.support.MeshTransform")], B2);
var L3 = B2;

// node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function r4(r5, e5) {
  return r5.isGeographic || r5.isWebMercator && ((e5 == null ? void 0 : e5.geographic) ?? true);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/georeference.js
function x2(n3, r5, t4) {
  return r4(r5.spatialReference, t4) ? B3(n3, r5, t4) : b(n3, r5, t4);
}
function _(t4, o2, e5) {
  const { position: a2, normal: i3, tangent: l3 } = t4;
  if (t(o2))
    return { position: a2, normal: i3, tangent: l3 };
  const s = o2.localMatrix;
  return x2({ position: R(a2, new Float64Array(a2.length), s), normal: r(i3) ? v(i3, new Float32Array(i3.length), s) : null, tangent: r(l3) ? V(l3, new Float32Array(l3.length), s) : null }, o2.getOriginPoint(e5), { geographic: o2.geographic });
}
function k2(n3, r5, t4) {
  if (t4 == null ? void 0 : t4.useTransform) {
    const { position: o2, normal: e5, tangent: a2 } = n3;
    return { vertexAttributes: { position: o2, normal: e5, tangent: a2 }, transform: new L3({ origin: [r5.x, r5.y, r5.z ?? 0], geographic: r4(r5.spatialReference, t4) }) };
  }
  return { vertexAttributes: x2(n3, r5, t4), transform: null };
}
function M2(n3, r5, t4) {
  return r4(r5.spatialReference, t4) ? G(n3, r5, t4) : Y(n3, r5, t4);
}
function P(r5, t4, o2, e5) {
  if (t(t4))
    return M2(r5, o2, e5);
  const a2 = _(r5, t4, o2.spatialReference);
  return o2.equals(t4.getOriginPoint(o2.spatialReference)) ? Y(a2, o2, e5) : r4(o2.spatialReference, e5) ? G(a2, o2, e5) : Y(a2, o2, e5);
}
function b(n3, r5, t4) {
  const o2 = new Float64Array(n3.position.length), e5 = n3.position, a2 = r5.x, i3 = r5.y, l3 = r5.z || 0, { horizontal: s, vertical: f2 } = C2(t4 ? t4.unit : null, r5.spatialReference);
  for (let c2 = 0; c2 < e5.length; c2 += 3)
    o2[c2 + 0] = e5[c2 + 0] * s + a2, o2[c2 + 1] = e5[c2 + 1] * s + i3, o2[c2 + 2] = e5[c2 + 2] * f2 + l3;
  return { position: o2, normal: n3.normal, tangent: n3.tangent };
}
function B3(n3, r5, t4) {
  const o2 = r5.spatialReference, e5 = O3(r5, t4, D), a2 = new Float64Array(n3.position.length), i3 = L4(n3.position, e5, o2, a2), l3 = j2(I, e5);
  return { position: i3, normal: N2(i3, a2, n3.normal, l3, o2), tangent: S(i3, a2, n3.tangent, l3, o2) };
}
function L4(n3, r5, t4, o2) {
  t3(T.fromTypedArray(o2), T.fromTypedArray(n3), r5);
  const e5 = new Float64Array(n3.length);
  return O2(o2, e5, t4);
}
function N2(r5, t4, o2, e5, a2) {
  if (t(o2))
    return null;
  const i3 = new Float32Array(o2.length);
  return r3(i2.fromTypedArray(i3), i2.fromTypedArray(o2), e5), h2(i3, r5, t4, a2, i3), i3;
}
function S(r5, t4, o2, e5, a2) {
  if (t(o2))
    return null;
  const i3 = new Float32Array(o2.length);
  r3(i2.fromTypedArray(i3, 4 * Float32Array.BYTES_PER_ELEMENT), i2.fromTypedArray(o2, 4 * Float32Array.BYTES_PER_ELEMENT), e5);
  for (let n3 = 3; n3 < i3.length; n3 += 4)
    i3[n3] = o2[n3];
  return L2(i3, r5, t4, a2, i3), i3;
}
function Y(n3, r5, t4) {
  const o2 = new Float64Array(n3.position.length), e5 = n3.position, a2 = r5.x, i3 = r5.y, l3 = r5.z || 0, { horizontal: s, vertical: f2 } = C2(t4 ? t4.unit : null, r5.spatialReference);
  for (let c2 = 0; c2 < e5.length; c2 += 3)
    o2[c2 + 0] = (e5[c2 + 0] - a2) / s, o2[c2 + 1] = (e5[c2 + 1] - i3) / s, o2[c2 + 2] = (e5[c2 + 2] - l3) / f2;
  return { position: o2, normal: n3.normal, tangent: n3.tangent };
}
function G(n3, r5, t4) {
  const o2 = r5.spatialReference;
  O3(r5, t4, D);
  const e5 = h(H, D), a2 = new Float64Array(n3.position.length), l3 = U(n3.position, o2, e5, a2), s = j2(I, e5);
  return { position: l3, normal: q2(n3.normal, n3.position, a2, o2, s), tangent: V2(n3.tangent, n3.position, a2, o2, s) };
}
function O3(n3, r5, t4) {
  qn(n3.spatialReference, [n3.x, n3.y, n3.z || 0], t4, O(n3.spatialReference));
  const { horizontal: o2, vertical: e5 } = C2(r5 ? r5.unit : null, n3.spatialReference);
  return i(t4, t4, [o2, o2, e5]), t4;
}
function U(n3, r5, t4, o2) {
  const e5 = M(n3, r5, o2), a2 = T.fromTypedArray(e5), i3 = new Float64Array(e5.length), l3 = T.fromTypedArray(i3);
  return t3(l3, a2, t4), i3;
}
function q2(r5, t4, o2, e5, a2) {
  if (t(r5))
    return null;
  const i3 = j3(r5, t4, o2, e5, new Float32Array(r5.length)), l3 = i2.fromTypedArray(i3);
  return r3(l3, l3, a2), i3;
}
function V2(r5, t4, o2, e5, a2) {
  if (t(r5))
    return null;
  const i3 = k(r5, t4, o2, e5, new Float32Array(r5.length)), l3 = i2.fromTypedArray(i3, 4 * Float32Array.BYTES_PER_ELEMENT);
  return r3(l3, l3, a2), i3;
}
function C2(r5, a2) {
  if (t(r5))
    return J;
  const i3 = a2.isGeographic ? 1 : z(a2), l3 = a2.isGeographic ? 1 : W(a2), s = N(1, r5, "meters");
  return { horizontal: s * i3, vertical: s * l3 };
}
var D = e3();
var H = e3();
var I = e2();
var J = { horizontal: 1, vertical: 1 };

export {
  L3 as L,
  r4 as r,
  x2 as x,
  _,
  k2 as k,
  M2 as M,
  P
};
//# sourceMappingURL=chunk-C3M7GLTQ.js.map
