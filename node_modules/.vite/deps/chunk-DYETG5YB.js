import {
  d,
  i,
  t
} from "./chunk-CLGCKZUR.js";
import {
  N
} from "./chunk-RN2KRYDN.js";
import {
  m2 as m
} from "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  k2 as k,
  o
} from "./chunk-3NMRL5CR.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";

// node_modules/@arcgis/core/geometry/support/geodesicUtils.js
function f(e) {
  if (!e)
    return null;
  if (o(e) && e.wkid) {
    const t2 = d[e.wkid];
    if (t2)
      return t2;
  }
  if (e.wkt) {
    const t2 = p(e.wkt);
    if (t2)
      return t2;
  }
  return null;
}
function p(e) {
  const t2 = t.exec(e);
  if (!t2 || 2 !== t2.length)
    return null;
  const n = t2[1].split(",");
  if (!n || n.length < 3)
    return null;
  const s2 = parseFloat(n[1]), a = parseFloat(n[2]);
  if (isNaN(s2) || isNaN(a))
    return null;
  return { a: s2, f: 0 === a ? 0 : 1 / a };
}
function u(e) {
  const t2 = f(e || k.WGS84);
  if (d2(t2))
    return t2;
  const n = t2.a * (1 - t2.f);
  return Object.assign(t2, { b: n, eSq: 1 - (n / t2.a) ** 2, radius: (2 * t2.a + n) / 3, densificationRatio: 1e4 / ((2 * t2.a + n) / 3) });
}
function d2(e) {
  return "b" in e && "eSq" in e && "radius" in e;
}
function g(e, t2, n) {
  const { a: i2, eSq: a } = u(n), r = Math.sqrt(a), o2 = Math.sin(t2[1] * i), c = i2 * t2[0] * i;
  let l;
  if (a > 0) {
    l = i2 * ((1 - a) * (o2 / (1 - a * (o2 * o2)) - 1 / (2 * r) * Math.log((1 - r * o2) / (1 + r * o2)))) * 0.5;
  } else
    l = i2 * o2;
  return e[0] = c, e[1] = l, e;
}
function M(e) {
  return null !== f(e);
}
function w(n, i2 = "square-meters") {
  if (n.some((e) => !M(e.spatialReference)))
    throw new s("geodesic-areas:invalid-spatial-reference", "the input geometries spatial reference is not supported");
  const s2 = [];
  for (let e = 0; e < n.length; e++) {
    const t2 = n[e], i3 = t2.spatialReference, { radius: a2, densificationRatio: r2 } = u(i3), o3 = a2 * r2;
    s2.push(R(t2, o3));
  }
  const a = [], r = [0, 0], o2 = [0, 0];
  for (let e = 0; e < s2.length; e++) {
    const { rings: n2, spatialReference: c } = s2[e];
    let l = 0;
    for (let e2 = 0; e2 < n2.length; e2++) {
      const t2 = n2[e2];
      g(r, t2[0], c), g(o2, t2[t2.length - 1], c);
      let i3 = o2[0] * r[1] - r[0] * o2[1];
      for (let e3 = 0; e3 < t2.length - 1; e3++)
        g(r, t2[e3 + 1], c), g(o2, t2[e3], c), i3 += o2[0] * r[1] - r[0] * o2[1];
      l += i3;
    }
    l = N(l, "square-meters", i2), a.push(l / -2);
  }
  return a;
}
function y(n, i2 = "meters") {
  if (!n)
    throw new s("geodesic-lengths:invalid-geometries", "the input geometries type is not supported");
  if (n.some((e) => !M(e.spatialReference)))
    throw new s("geodesic-lengths:invalid-spatial-reference", "the input geometries spatial reference is not supported");
  const s2 = [];
  for (let e = 0; e < n.length; e++) {
    const a = n[e], { spatialReference: r } = a, o2 = "polyline" === a.type ? a.paths : a.rings;
    let c = 0;
    for (let e2 = 0; e2 < o2.length; e2++) {
      const t2 = o2[e2];
      let n2 = 0;
      for (let e3 = 1; e3 < t2.length; e3++) {
        const i3 = t2[e3 - 1][0], s3 = t2[e3][0], a2 = t2[e3 - 1][1], o3 = t2[e3][1];
        if (a2 !== o3 || i3 !== s3) {
          const e4 = { distance: null };
          z(e4, [i3, a2], [s3, o3], r), n2 += e4.distance;
        }
      }
      c += n2;
    }
    c = N(c, "meters", i2), s2.push(c);
  }
  return s2;
}
function R(t2, n) {
  if ("polyline" !== t2.type && "polygon" !== t2.type)
    throw new s("geodesic-densify:invalid-geometry", "the input geometry is neither polyline nor polygon");
  const { spatialReference: i2 } = t2;
  if (!M(i2))
    throw new s("geodesic-densify:invalid-spatial-reference", "the input geometry spatial reference is not supported");
  const s2 = "polyline" === t2.type ? t2.paths : t2.rings, a = [], r = [0, 0], l = { distance: null };
  for (const e of s2) {
    const t3 = [];
    a.push(t3), t3.push([e[0][0], e[0][1]]);
    let s3, o2, c = e[0][0], h = e[0][1];
    for (let a2 = 0; a2 < e.length - 1; a2++) {
      if (s3 = e[a2 + 1][0], o2 = e[a2 + 1][1], c === s3 && h === o2)
        continue;
      const f2 = [c, h];
      z(l, [c, h], [s3, o2], i2);
      const { azimuth: p2, distance: u2 } = l, d3 = u2 / n;
      if (d3 > 1) {
        for (let e2 = 1; e2 <= d3 - 1; e2++) {
          v2(r, f2, p2, e2 * n, i2), t3.push(r.slice(0));
        }
        v2(r, f2, p2, (u2 + Math.floor(d3 - 1) * n) / 2, i2), t3.push(r.slice(0));
      }
      v2(r, f2, p2, u2, i2), t3.push(r.slice(0)), c = r[0], h = r[1];
    }
  }
  return "polyline" === t2.type ? new m({ paths: a, spatialReference: i2 }) : new v({ rings: a, spatialReference: i2 });
}
function v2(e, t2, n, i2, a) {
  const r = t2[0], o2 = t2[1], c = r * i, l = o2 * i, h = n * i, { a: f2, b: p2, f: d3 } = u(a), m2 = Math.sin(h), g2 = Math.cos(h), M2 = (1 - d3) * Math.tan(l), w2 = 1 / Math.sqrt(1 + M2 * M2), y2 = M2 * w2, R2 = Math.atan2(M2, g2), v3 = w2 * m2, z2 = v3 * v3, b = 1 - z2, j2 = b * (f2 * f2 - p2 * p2) / (p2 * p2), q = 1 + j2 / 16384 * (4096 + j2 * (j2 * (320 - 175 * j2) - 768)), x = j2 / 1024 * (256 + j2 * (j2 * (74 - 47 * j2) - 128));
  let A, N2, S, k2, P = i2 / (p2 * q), F = 2 * Math.PI;
  for (; Math.abs(P - F) > 1e-12; )
    S = Math.cos(2 * R2 + P), A = Math.sin(P), N2 = Math.cos(P), k2 = x * A * (S + x / 4 * (N2 * (2 * S * S - 1) - x / 6 * S * (4 * A * A - 3) * (4 * S * S - 3))), F = P, P = i2 / (p2 * q) + k2;
  const U = y2 * A - w2 * N2 * g2, C = Math.atan2(y2 * N2 + w2 * A * g2, (1 - d3) * Math.sqrt(z2 + U * U)), E2 = Math.atan2(A * m2, w2 * N2 - y2 * A * g2), G = d3 / 16 * b * (4 + d3 * (4 - 3 * b)), I = C / i, O = (c + (E2 - (1 - G) * d3 * v3 * (P + G * A * (S + G * N2 * (2 * S * S - 1))))) / i;
  return e[0] = O, e[1] = I, e;
}
function z(e, t2, n, i2) {
  const a = t2[0] * i, r = t2[1] * i, o2 = n[0] * i, c = n[1] * i, { a: l, b: h, f: f2, radius: p2 } = u(i2), d3 = o2 - a, m2 = Math.atan((1 - f2) * Math.tan(r)), g2 = Math.atan((1 - f2) * Math.tan(c)), M2 = Math.sin(m2), w2 = Math.cos(m2), y2 = Math.sin(g2), R2 = Math.cos(g2);
  let v3, z2, b, j2, q, x, A, N2, S, k2, P = 1e3, F = d3;
  do {
    if (A = Math.sin(F), N2 = Math.cos(F), b = Math.sqrt(R2 * A * (R2 * A) + (w2 * y2 - M2 * R2 * N2) * (w2 * y2 - M2 * R2 * N2)), 0 === b)
      return e.distance = 0, e.azimuth = void 0, e.reverseAzimuth = void 0, e;
    q = M2 * y2 + w2 * R2 * N2, x = Math.atan2(b, q), S = w2 * R2 * A / b, z2 = 1 - S * S, j2 = q - 2 * M2 * y2 / z2, isNaN(j2) && (j2 = 0), k2 = f2 / 16 * z2 * (4 + f2 * (4 - 3 * z2)), v3 = F, F = d3 + (1 - k2) * f2 * S * (x + k2 * b * (j2 + k2 * q * (2 * j2 * j2 - 1)));
  } while (Math.abs(F - v3) > 1e-12 && --P > 0);
  if (0 === P) {
    const t3 = p2, n2 = Math.acos(Math.sin(r) * Math.sin(c) + Math.cos(r) * Math.cos(c) * Math.cos(o2 - a)) * t3, i3 = o2 - a, l2 = Math.sin(i3) * Math.cos(c), h2 = Math.cos(r) * Math.sin(c) - Math.sin(r) * Math.cos(c) * Math.cos(i3), f3 = Math.atan2(l2, h2);
    return e.azimuth = f3 / i, e.distance = n2, e.reverseAzimuth = void 0, e;
  }
  const U = z2 * (l * l - h * h) / (h * h), C = U / 1024 * (256 + U * (U * (74 - 47 * U) - 128)), E2 = h * (1 + U / 16384 * (4096 + U * (U * (320 - 175 * U) - 768))) * (x - C * b * (j2 + C / 4 * (q * (2 * j2 * j2 - 1) - C / 6 * j2 * (4 * b * b - 3) * (4 * j2 * j2 - 3)))), G = Math.atan2(R2 * Math.sin(F), w2 * y2 - M2 * R2 * Math.cos(F)), I = Math.atan2(w2 * Math.sin(F), w2 * y2 * Math.cos(F) - M2 * R2);
  return e.azimuth = G / i, e.distance = E2, e.reverseAzimuth = I / i, e;
}

export {
  M,
  w,
  y,
  R,
  v2 as v,
  z
};
//# sourceMappingURL=chunk-DYETG5YB.js.map
