import {
  x
} from "./chunk-KP6RIJS6.js";
import {
  o as o5
} from "./chunk-K37I5IIG.js";
import {
  r as r3
} from "./chunk-HRAEK6P4.js";
import {
  s
} from "./chunk-K6UIDSFF.js";
import {
  o as o4
} from "./chunk-XEIRRA3E.js";
import {
  i
} from "./chunk-ODYLXHP4.js";
import {
  o as o2
} from "./chunk-AWPZQDE5.js";
import {
  e as e3
} from "./chunk-FAF3GP2W.js";
import {
  n as n4
} from "./chunk-DNPZNIDB.js";
import {
  e as e5
} from "./chunk-AALA53RH.js";
import {
  u
} from "./chunk-IJHFAZOW.js";
import {
  o
} from "./chunk-BMA2CXVS.js";
import {
  e as e4
} from "./chunk-46N7XS5M.js";
import {
  e
} from "./chunk-4MKQUQD4.js";
import {
  o as o3
} from "./chunk-A3QLZKCF.js";
import {
  a
} from "./chunk-OYAHQ564.js";
import {
  e as e2
} from "./chunk-LGILR4HN.js";
import {
  i2
} from "./chunk-I5UNY2WQ.js";
import {
  n as n3
} from "./chunk-NAB3NF54.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  r
} from "./chunk-YZNDHJDJ.js";
import {
  n as n2,
  r as r2
} from "./chunk-RTHP2LNT.js";
import {
  n
} from "./chunk-P6G64ARX.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/IsNaN.glsl.js
function o6(o8) {
  const e6 = n3`bool isNaN( float val )
{
return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;
}`;
  o8.code.add(e6);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/AdjustProjectedPosition.glsl.js
var i3 = r2(0.5, -4e-4);
function c(o8, c2) {
  const f = o8.vertex;
  f.include(o6), f.constants.add("depthBias", "vec2", i3), f.uniforms.add(new e2("inverseViewport", (o9, r4) => r4.inverseViewport)), c2.legacy ? (f.uniforms.add(new o4("localView")), f.uniforms.add(new e4("proj", (o9, r4) => r4.camera.projectionMatrix)), f.code.add(n3`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {
float offsetXY = depthBias.x;
vec4 projNormal = proj * localView * vec4(globalNormal, 0.0);
return offsetXY * projPos.w * 2.0 * inverseViewport * normalize(projNormal.xyz).xy;
}`)) : (f.uniforms.add(new e3("transformNormalViewFromGlobal", (o9) => o9.transformNormalViewFromGlobal)), f.uniforms.add(new e4("transformProjFromView", (o9) => o9.transformProjFromView)), f.code.add(n3`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {
float offsetXY = depthBias.x;
vec4 projNormal = transformProjFromView * vec4(transformNormalViewFromGlobal * globalNormal, 0.0);
return offsetXY * projPos.w * 2.0 * inverseViewport * normalize(projNormal.xyz).xy;
}`)), f.code.add(n3`float _calculateProjectedBiasZ(vec4 projPos) {
float offsetZ = depthBias.y;
return sqrt(max(projPos.z,0.0)) * offsetZ;
}
vec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {
vec2 offsetXY = calculateProjectedBiasXY(projPos, worldNormal);
if (!isNaN(offsetXY.x) && !isNaN(offsetXY.y)) {
projPos.xy += offsetXY;
}
projPos.z += _calculateProjectedBiasZ(projPos);
return projPos;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardByCoverage.glsl.js
function a2(a3, r4) {
  const d2 = a3.fragment;
  d2.constants.add("coverageTestThreshold", "float", 0.01), r4.antialiasing ? d2.code.add(n3`#define discardByCoverage(radius, coverage) { if (coverage < coverageTestThreshold) discard; }`) : d2.code.add(n3`#define discardByCoverage(radius, coverage) { float coverageLimit = radius <= 0.5 ? coverageTestThreshold : 0.75; if (coverage < coverageLimit) discard; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardNonSilhouetteEdges.glsl.js
function o7(o8, r4) {
  const l = o8.vertex;
  r4.silhouette ? (l.code.add(n3`bool isSilhouetteEdge(vec3 viewDir, vec3 normalA, vec3 normalB) {
float faceAVisible = dot(viewDir, normalA);
float faceBVisible = dot(viewDir, normalB);
return faceAVisible * faceBVisible < 0.0;
}`), r4.legacy ? l.code.add(n3`bool discardNonSilhouetteEdges(vec3 viewPos, vec3 worldPos) {
vec3 viewNormalA = _modelToViewNormal(normalA);
vec3 viewNormalB = _modelToViewNormal(normalB);
vec3 viewDir = -viewPos;
if (isSilhouetteEdge(viewDir, viewNormalA, viewNormalB)) {
return false;
}
gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
return true;
}`) : l.code.add(n3`bool discardNonSilhouetteEdges(vec3 viewPos, vec3 worldPos) {
vec3 worldNormalA = _modelToWorldNormal(normalA);
vec3 worldNormalB = _modelToWorldNormal(normalB);
vec3 viewDir = -worldPos;
if (isSilhouetteEdge(viewDir, worldNormalA, worldNormalB)) {
return false;
}
gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
return true;
}`)) : l.code.add(n3`bool discardNonSilhouetteEdges(vec3 viewPos, vec3 worldPos) {
return false;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/EdgeUtil.glsl.js
function u2(u4, v2) {
  const p = u4.vertex;
  p.include(a), p.uniforms.add(new o3("distanceFalloffFactor", (o8) => o8.distanceFalloffFactor)), p.code.add(n3`float distanceBasedPerspectiveFactor(float distance) {
return clamp(sqrt(distanceFalloffFactor / distance), 0.0, 1.0);
}`), p.uniforms.add(new s("componentDataTex")), p.uniforms.add(new o5("componentDataTexInvDim")), u4.attributes.add(O.COMPONENTINDEX, "float"), p.constants.add("componentColorFieldOffset", "float", 0), p.constants.add("componentOtherFieldOffset", "float", 1), p.constants.add("componentVerticalOffsetFieldOffset", "float", 2), p.constants.add("componentFieldCount", "float", 3), p.constants.add("lineWidthFractionFactor", "float", 8), p.constants.add("extensionLengthOffset", "float", 128), p.constants.add("componentTexWidth", "float", 4096), p.constants.add("verticalOffsetScale", "float", 2 * x), p.code.add(n3`vec2 _componentTextureCoords(float componentIndex, float fieldOffset) {
float fieldIndex = componentFieldCount * componentIndex + fieldOffset;
float rowIndex = floor(fieldIndex / componentTexWidth);
float colIndex = mod(fieldIndex, componentTexWidth);
vec2 linearIndex = vec2(
(colIndex + 0.5) / componentTexWidth,
(rowIndex + 0.5) * componentDataTexInvDim.y
);
return linearIndex;
}
struct ComponentData {
vec4 color;
float lineWidth;
float extensionLength;
float type;
float verticalOffset;
};
ComponentData readComponentData() {
vec2 colorIndex = _componentTextureCoords(componentIndex, componentColorFieldOffset);
vec2 otherIndex = _componentTextureCoords(componentIndex, componentOtherFieldOffset);
vec2 verticalOffsetIndex = _componentTextureCoords(componentIndex, componentVerticalOffsetFieldOffset);
vec4 colorValue = texture2D(componentDataTex, colorIndex);
vec4 otherValue = texture2D(componentDataTex, otherIndex);
float verticalOffset = (rgba2float(texture2D(componentDataTex, verticalOffsetIndex)) - 0.5) * verticalOffsetScale;
return ComponentData(
vec4(colorValue.rgb, colorValue.a * otherValue.w),
otherValue.x * (255.0 / lineWidthFractionFactor),
otherValue.y * 255.0 - extensionLengthOffset,
-(otherValue.z * 255.0) + 0.5,
verticalOffset
);
}`), v2.legacy ? p.code.add(n3`vec3 _modelToWorldNormal(vec3 normal) {
return (model * vec4(normal, 0.0)).xyz;
}
vec3 _modelToViewNormal(vec3 normal) {
return (localView * model * vec4(normal, 0.0)).xyz;
}`) : (p.uniforms.add(new o2("transformNormalGlobalFromModel", (o8) => o8.transformNormalGlobalFromModel)), p.code.add(n3`vec3 _modelToWorldNormal(vec3 normal) {
return transformNormalGlobalFromModel * normal;
}`)), v2.silhouette ? (u4.attributes.add(O.NORMALA, "vec3"), u4.attributes.add(O.NORMALB, "vec3"), p.code.add(n3`vec3 worldNormal() {
return _modelToWorldNormal(normalize(normalA + normalB));
}`)) : (u4.attributes.add(O.NORMAL, "vec3"), p.code.add(n3`vec3 worldNormal() {
return _modelToWorldNormal(normal);
}`)), v2.legacy ? p.code.add(n3`void worldAndViewFromModelPosition(vec3 modelPos, float verticalOffset, out vec3 worldPos, out vec3 viewPos) {
worldPos = (model * vec4(modelPos, 1.0)).xyz;
viewPos = (localView * vec4(worldPos, 1.0)).xyz;
}`) : (p.include(i, v2), p.include(i, v2), p.uniforms.add([new e3("transformViewFromCameraRelativeRS", (o8) => o8.transformViewFromCameraRelativeRS), new o2("transformWorldFromModelRS", (o8) => o8.transformWorldFromModelRS), new o("transformWorldFromModelTL", (o8) => o8.transformWorldFromModelTL), new o("transformWorldFromModelTH", (o8) => o8.transformWorldFromModelTH), new e("transformWorldFromViewTL", (o8) => o8.transformWorldFromViewTL), new e("transformWorldFromViewTH", (o8) => o8.transformWorldFromViewTH)]), p.code.add(n3`
      void worldAndViewFromModelPosition(vec3 modelPos, float verticalOffset, out vec3 worldPos, out vec3 viewPos) {
        vec3 rotatedModelPosition = transformWorldFromModelRS * modelPos;

        vec3 transformCameraRelativeFromModel = dpAdd(
          transformWorldFromModelTL,
          transformWorldFromModelTH,
          -transformWorldFromViewTL,
          -transformWorldFromViewTH
        );

        worldPos = transformCameraRelativeFromModel + rotatedModelPosition;

        if (verticalOffset != 0.0) {
          vec3 vUp = ${v2.spherical ? n3`normalize(transformWorldFromModelTL + rotatedModelPosition);` : n3`vec3(0.0, 0.0, 1.0);`}
          worldPos += verticalOffset * vUp;
        }

        viewPos = transformViewFromCameraRelativeRS * worldPos;
      }
    `)), p.uniforms.add(new e4("transformProjFromView", (o8, e6) => e6.camera.projectionMatrix)), p.code.add(n3`vec4 projFromViewPosition(vec3 position) {
return transformProjFromView * vec4(position, 1.0);
}`), p.code.add(n3`float calculateExtensionLength(float extensionLength, float lineLength) {
return extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);
}`);
}
function v(o8) {
  return o8.mode === x2.SKETCH || o8.mode === x2.MIXED;
}
var x2;
!function(o8) {
  o8[o8.SOLID = 0] = "SOLID", o8[o8.SKETCH = 1] = "SKETCH", o8[o8.MIXED = 2] = "MIXED", o8[o8.COUNT = 3] = "COUNT";
}(x2 || (x2 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardShortEdges.glsl.js
function i4(i6, d2) {
  const s2 = i6.vertex;
  switch (d2.mode) {
    case x2.SKETCH:
      s2.code.add(n3`#define discardShortEdges(unpackedAttributes, lineLengthPixels) { if (lineLengthPixels <= 3.0) { gl_Position = vec4(10.0, 10.0, 10.0, 1.0); return; }}`);
      break;
    case x2.MIXED:
      s2.code.add(n3`#define discardShortEdges(unpackedAttributes, lineLengthPixels) { if (unpackedAttributes.type <= 0.0 && lineLengthPixels <= 3.0) { gl_Position = vec4(10.0, 10.0, 10.0, 1.0); return; }}`);
      break;
    case x2.SOLID:
      s2.code.add(n3`#define discardShortEdges(unpackedAttributes, lineLengthPixels) {}`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/UnpackAttributes.glsl.js
function i5(i6, o8) {
  const d2 = i6.vertex;
  switch (i6.attributes.add(O.SIDENESS, "vec2"), o8.mode === x2.MIXED ? d2.code.add(n3`struct UnpackedAttributes {
vec2 sideness;
vec2 sidenessNorm;
float lineWidthPixels;
float extensionLengthPixels;
float type;
};`) : d2.code.add(n3`struct UnpackedAttributes {
vec2 sideness;
vec2 sidenessNorm;
float lineWidthPixels;
float extensionLengthPixels;
};`), o8.mode) {
    case x2.MIXED:
      d2.code.add(n3`UnpackedAttributes unpackAttributes(ComponentData component) {
vec2 sidenessNorm = sideness;
vec2 sideness = sidenessNorm * 2.0 - 1.0;
float fType = component.type;
float extensionLengthPixels = component.extensionLength;
float lineWidth = component.lineWidth;
if (fType <= 0.0) {
extensionLengthPixels *= variantExtension * 2.0 - 1.0;
}
return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels, fType);
}`);
      break;
    case x2.SKETCH:
      d2.code.add(n3`UnpackedAttributes unpackAttributes(ComponentData component) {
vec2 sidenessNorm = sideness;
vec2 sideness = sidenessNorm * 2.0 - 1.0;
float extensionLengthPixels = component.extensionLength;
extensionLengthPixels *= variantExtension * 2.0 - 1.0;
float lineWidth = component.lineWidth;
return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);
}`);
      break;
    case x2.SOLID:
      d2.code.add(n3`UnpackedAttributes unpackAttributes(ComponentData component) {
vec2 sidenessNorm = sideness;
vec2 sideness = sidenessNorm * 2.0 - 1.0;
float extensionLengthPixels = component.extensionLength;
float lineWidth = component.lineWidth;
return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);
}`);
      break;
    case x2.COUNT:
      break;
    default:
      n(o8.mode);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/LineAmplitude.glsl.js
function d(d2, u4) {
  const i6 = d2.vertex;
  switch (d2.include(i5, u4), v(u4) && i6.uniforms.add(new r3("strokesAmplitude")), u4.mode) {
    case x2.SOLID:
      i6.code.add(n3`float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {
return 0.0;
}`);
      break;
    case x2.SKETCH:
      i6.code.add(n3`float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {
return strokesAmplitude;
}`);
      break;
    case x2.MIXED:
      i6.code.add(n3`float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {
float type = unpackedAttributes.type;
if (type <= 0.0) {
return strokesAmplitude;
}
else {
return 0.0;
}
}`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/LineOffset.glsl.js
function u3(u4, n5) {
  const i6 = u4.vertex;
  u4.include(i5, n5);
  const d2 = u4.fragment;
  switch (v(n5) && (i6.uniforms.add(new o5("strokesTextureScale")), i6.uniforms.add(new r3("strokesLog2Resolution")), i6.uniforms.add(new r3("strokeVariants")), u4.varyings.add("vStrokeUV", "vec2"), d2.uniforms.add(new s("strokesTexture")), d2.uniforms.add(new r3("strokesNormalizationScale")), i6.code.add(n3`void calculateStyleOutputsSketch(float lineLength, UnpackedAttributes unpackedAttributes) {
vec2 sidenessNorm = unpackedAttributes.sidenessNorm;
float lineIndex = clamp(ceil(log2(lineLength)), 0.0, strokesLog2Resolution);
vStrokeUV = vec2(exp2(lineIndex) * sidenessNorm.y, lineIndex * strokeVariants + variantStroke + 0.5) * strokesTextureScale;
vStrokeUV.x += variantOffset;
}`), u4.fragment.include(a), d2.code.add(n3`float calculateLineOffsetSketch() {
float offsetNorm = rgba2float(texture2D(strokesTexture, vStrokeUV));
return (offsetNorm - 0.5) * strokesNormalizationScale;
}
float calculateLinePressureSketch() {
return rgba2float(texture2D(strokesTexture, vStrokeUV + vec2(0.0, 0.5)));
}`)), n5.mode) {
    case x2.SOLID:
      i6.code.add(n3`void calculateStyleOutputs(UnpackedAttributes unpackedAttributes) {}`), d2.code.add(n3`float calculateLineOffset() {
return 0.0;
}
float calculateLinePressure() {
return 1.0;
}`);
      break;
    case x2.SKETCH:
      i6.code.add(n3`void calculateStyleOutputs(UnpackedAttributes unpackedAttributes)
{
calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);
}`), d2.code.add(n3`float calculateLineOffset() {
return calculateLineOffsetSketch();
}
float calculateLinePressure() {
return calculateLinePressureSketch();
}`);
      break;
    case x2.MIXED:
      u4.varyings.add("vType", "float"), i6.code.add(n3`void calculateStyleOutputs(UnpackedAttributes unpackedAttributes)
{
vType = unpackedAttributes.type;
if (unpackedAttributes.type <= 0.0) {
calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);
}
}`), d2.code.add(n3`float calculateLineOffset() {
if (vType <= 0.0) {
return calculateLineOffsetSketch();
}
else {
return 0.0;
}
}
float calculateLinePressure() {
if (vType <= 0.0) {
return calculateLinePressureSketch();
}
else {
return 1.0;
}
}`);
  }
}

// node_modules/@arcgis/core/chunks/EdgeShader.glsl.js
function w(i6) {
  const w2 = new i2(), A2 = w2.vertex, L = w2.fragment;
  return i6.legacy && A2.uniforms.add(new o4("model")), i6.antialiasing && (A2.code.add(n3`#define ANTIALIASING 1`), L.code.add(n3`#define ANTIALIASING 1`)), w2.include(c, i6), w2.include(u2, i6), w2.include(d, i6), w2.include(i5, i6), w2.include(u3, i6), w2.include(u, i6), w2.include(o7, i6), w2.include(a2, i6), w2.include(i4, i6), w2.include(n4, i6), w2.varyings.add("vColor", "vec4"), w2.varyings.add("vRadius", "float"), w2.varyings.add("vPosition", "vec3"), w2.varyings.add("vWorldPosition", "vec3"), w2.varyings.add("vViewPos", "vec3"), w2.varyings.add("vLineLengthPixels", "float"), w2.varyings.add("vSizeFalloffFactor", "float"), A2.uniforms.add(new e2("pixelToNDC", (i7, o8) => r(h, 2 / o8.camera.fullViewport[2], 2 / o8.camera.fullViewport[3]))), A2.uniforms.add(new e5("viewport", (e6, i7) => i7.camera.fullViewport)), A2.uniforms.add(new o3("pixelRatio", (e6, i7) => i7.camera.pixelRatio)), w2.attributes.add(O.POSITION0, "vec3"), w2.attributes.add(O.POSITION1, "vec3"), w2.attributes.add(O.VARIANTOFFSET, "float"), w2.attributes.add(O.VARIANTSTROKE, "float"), w2.attributes.add(O.VARIANTEXTENSION, "float"), A2.code.add(n3`const float opaqueCutoff = 1.0 / 255.0;
void calculateGeometricOutputs(vec3 viewPosV0, vec3 viewPosV1, vec3 worldPosV0, vec3 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {
vec2 sideness = unpackedAttributes.sideness;
vec2 sidenessNorm = unpackedAttributes.sidenessNorm;
vWorldPosition = mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;
vec3 viewPos = mix(viewPosV0, viewPosV1, sidenessNorm.y);
vViewPos = viewPos;
vec4 projPosV0 = projFromViewPosition(viewPosV0);
vec4 projPosV1 = projFromViewPosition(viewPosV1);
vec4 projPos = projFromViewPosition(viewPos);
vec3 screenSpaceLineNDC = (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);
vec2 ndcToPixel = viewport.zw * 0.5;
vec2 screenSpaceLinePixels = screenSpaceLineNDC.xy * ndcToPixel;
float lineLengthPixels = length(screenSpaceLinePixels);
float dzPerPixel = screenSpaceLineNDC.z / lineLengthPixels;
vec2 screenSpaceDirection = screenSpaceLinePixels / lineLengthPixels;
vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;
float falloffFactor = distanceBasedPerspectiveFactor(-viewPos.z) * pixelRatio;
float lineWidthPixels = unpackedAttributes.lineWidthPixels * falloffFactor;
float extensionLengthPixels = calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;
float lineAmplitudePixels = calculateLineAmplitude(unpackedAttributes) * pixelRatio;
vSizeFalloffFactor = falloffFactor;
float lineWidthAndAmplitudePixels = lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;
float extendedLineLengthPixels = lineLengthPixels + extensionLengthPixels + extensionLengthPixels;
#ifdef ANTIALIASING
const float aaPaddingPixels = 1.0;
float halfAAPaddedLineWidthAndAmplitudePixels = lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;
float aaPaddedRoundedCapSizePixels = lineWidthPixels * 0.5 + aaPaddingPixels;
#else
float halfAAPaddedLineWidthAndAmplitudePixels = max(lineWidthAndAmplitudePixels, 1.0) * 0.5;
float aaPaddedRoundedCapSizePixels = max(lineWidthPixels, 1.0) * 0.5;
#endif
vec2 halfAAPaddedLineWidthAndAmplitudeNDC = halfAAPaddedLineWidthAndAmplitudePixels * pixelToNDC;
vec2 aaPaddedRoundedCapSizeNDC = aaPaddedRoundedCapSizePixels * pixelToNDC;
vec2 extensionLengthNDC = extensionLengthPixels * pixelToNDC;
vec2 ndcOffset = (
screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)
+ perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC
);
projPos.xy += ndcOffset * projPos.w;
projPos.z += (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;
projPos = adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));
float aaPaddedLineWithCapsLengthPixels = extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;
float pixelPositionAlongLine = aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;
vPosition = vec3(
halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,
pixelPositionAlongLine,
pixelPositionAlongLine / extendedLineLengthPixels
);
vRadius = lineWidthPixels * 0.5;
vLineLengthPixels = extendedLineLengthPixels;
discardShortEdges(unpackedAttributes, lineLengthPixels);
gl_Position = projPos;
}
void main() {
ComponentData component = readComponentData();
UnpackedAttributes unpackedAttributes = unpackAttributes(component);
vec3 worldPosV0, worldPosV1, viewPosV0, viewPosV1;
worldAndViewFromModelPosition(position0, component.verticalOffset, worldPosV0, viewPosV0);
worldAndViewFromModelPosition(position1, component.verticalOffset, worldPosV1, viewPosV1);
vColor = component.color;
if (vColor.a < opaqueCutoff) {
gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
return;
}
if (discardNonSilhouetteEdges(viewPosV0, worldPosV0)) {
return;
}
calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal(), unpackedAttributes);
calculateStyleOutputs(unpackedAttributes);
}`), w2.fragment.code.add(n3`
    vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {
      float lineOffset = calculateLineOffset();
      float positionX = position.x - lineOffset;

      if (radius < 1.0) {
        // Handle this specifically for subpixel sizes:
        // 1. Compute correct coverage (note coverage is computed by
        //    0.5 - dist, so we make sure that that will lead to correct
        //    subpixel coverage
        // 2. Ignore rounded caps
        float coverageX = clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);
        float coverageY = clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);

        float coverage = min(coverageX, coverageY);

        return vec2(0.5 - coverage, 0.0);
      }
      else {
        // Between -radius -> 0 for start cap, 0 for line, 0 -> radius
        float positionOnCap = position.y - clamp(position.y, 0.0, lineLength);

        vec2 lineToPosition = vec2(positionX, positionOnCap);
        return vec2(length(lineToPosition) - radius, positionOnCap / radius);
      }
    }

    void main() {
      ${i6.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, vViewPos.z);" : ""}
      float radius = vRadius * calculateLinePressure();

      vec2 distance = lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);
      float coverage = clamp(0.5 - distance.x, 0.0, 1.0);

      discardByCoverage(radius, coverage);
      discardBySlice(vWorldPosition);

      float alpha = vColor.a * coverage;

      gl_FragColor = vec4(vColor.rgb, alpha);

    }
  `), w2;
}
var h = n2();
var A = Object.freeze(Object.defineProperty({ __proto__: null, build: w }, Symbol.toStringTag, { value: "Module" }));

export {
  x2 as x,
  w,
  A
};
//# sourceMappingURL=chunk-GHUFWF6Z.js.map
