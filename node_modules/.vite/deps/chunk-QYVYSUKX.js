import {
  s as s3
} from "./chunk-IUU35NDY.js";
import {
  m
} from "./chunk-TZD2AXJG.js";
import {
  r as r4
} from "./chunk-YXFNNKMT.js";
import {
  A as A2
} from "./chunk-5EXPMKQP.js";
import {
  M as M2,
  W as W2
} from "./chunk-B7F3T673.js";
import {
  t as t4
} from "./chunk-QXYW5CVF.js";
import {
  D as D2
} from "./chunk-Z7AZMEL6.js";
import {
  f as f3
} from "./chunk-FUKESVWQ.js";
import {
  c as c2,
  i
} from "./chunk-T3KDRLPE.js";
import {
  n as n4,
  u as u2
} from "./chunk-EJ7RFMRW.js";
import {
  u
} from "./chunk-VQLKKADV.js";
import {
  t as t3
} from "./chunk-33INAWJA.js";
import {
  A,
  C,
  D,
  E,
  F,
  G,
  I,
  L as L2,
  M,
  N,
  O,
  P,
  R,
  S,
  T,
  U,
  V,
  W,
  X,
  Y,
  _,
  f as f2,
  n as n3,
  r as r3,
  t as t2
} from "./chunk-FPMD6IB4.js";
import {
  t as t5
} from "./chunk-MHB3L22D.js";
import {
  o as o4
} from "./chunk-MV2XZ5BA.js";
import {
  o as o3
} from "./chunk-BPZGJQOB.js";
import {
  o as o2,
  q,
  s as s2
} from "./chunk-PKZEO23A.js";
import {
  n as n2,
  r as r2
} from "./chunk-AIRC226G.js";
import {
  n5 as n
} from "./chunk-2QOWZFCU.js";
import {
  L,
  f
} from "./chunk-U3PSONS6.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  c,
  o,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/webgl/ContextState.js
var h = class {
  constructor() {
    this.blend = false, this.blendColor = { r: 0, g: 0, b: 0, a: 0 }, this.blendFunction = { srcRGB: R.ONE, dstRGB: R.ZERO, srcAlpha: R.ONE, dstAlpha: R.ZERO }, this.blendEquation = { mode: T.ADD, modeAlpha: T.ADD }, this.colorMask = { r: true, g: true, b: true, a: true }, this.faceCulling = false, this.cullFace = N.BACK, this.frontFace = S.CCW, this.scissorTest = false, this.scissorRect = { x: 0, y: 0, width: 0, height: 0 }, this.depthTest = false, this.depthFunction = I.LESS, this.clearDepth = 1, this.depthWrite = true, this.depthRange = { zNear: 0, zFar: 1 }, this.viewport = null, this.stencilTest = false, this.polygonOffsetFill = false, this.polygonOffset = [0, 0], this.stencilFunction = { face: N.FRONT_AND_BACK, func: I.ALWAYS, ref: 0, mask: 1 }, this.clearStencil = 0, this.stencilWriteMask = 1, this.stencilOperation = { face: N.FRONT_AND_BACK, fail: O.KEEP, zFail: O.KEEP, zPass: O.KEEP }, this.clearColor = { r: 0, g: 0, b: 0, a: 0 }, this.program = null, this.vertexBuffer = null, this.indexBuffer = null, this.uniformBuffer = null, this.pixelPackBuffer = null, this.pixelUnpackBuffer = null, this.copyReadBuffer = null, this.copyWriteBuffer = null, this.uniformBufferBindingPoints = new Array(), this.readFramebuffer = null, this.drawFramebuffer = null, this.renderbuffer = null, this.activeTexture = 0, this.textureUnitMap = new Array();
  }
};

// node_modules/@arcgis/core/views/support/AllocationTracer.js
var o5 = class {
  constructor(o8) {
    this._allocations = /* @__PURE__ */ new Map(), o8 ? Error.stackTraceLimit = 1 / 0 : (this.add = () => {
    }, this.remove = () => {
    });
  }
  add(o8) {
    this._allocations.set(o8, new Error().stack);
  }
  remove(o8) {
    this._allocations.delete(o8);
  }
  print() {
    if (this._allocations.size > 0) {
      console.log(`${this._allocations.size} live object allocations:`);
      const o8 = /* @__PURE__ */ new Map();
      this._allocations.forEach((s8) => {
        o8.set(s8, (o8.get(s8) ?? 0) + 1);
      }), o8.forEach((o9, s8) => {
        const t9 = s8.split("\n");
        t9.shift(), t9.shift(), console.log(`${o9}: ${t9.shift()}`), t9.forEach((o10) => console.log("   ", o10));
      });
    }
  }
};

// node_modules/@arcgis/core/views/webgl/InstanceCounter.js
var e = { RECORD_ALLOCATIONS: false };
var s4 = class {
  constructor() {
    for (this._current = new Array(), this._max = new Array(), this._allocations = new o5(e.RECORD_ALLOCATIONS); this._current.length < t2.COUNT; )
      this._current.push(0), this._max.push(0);
  }
  resetMax() {
    for (this._max.length = 0; this._max.length < this._current.length; )
      this._max.push(0);
  }
  increment(t9, r9) {
    const e4 = ++this._current[t9];
    this._max[t9] = Math.max(e4, this._max[t9]), this._allocations.add(r9);
  }
  decrement(t9, r9) {
    --this._current[t9], this._allocations.remove(r9);
  }
  get max() {
    return this._max;
  }
  get current() {
    return this._current;
  }
  get total() {
    return this.current.reduce((t9, r9) => t9 + r9, 0);
  }
  printResourceCount() {
    if (this.total > 0) {
      console.log("Live objects:");
      for (let t9 = 0; t9 < t2.COUNT; ++t9) {
        const e4 = this._current[t9];
        e4 > 0 && console.log(`${t2[t9]}: ${e4}`);
      }
    }
    this._allocations.print();
  }
};

// node_modules/@arcgis/core/views/webgl/testDoublePrecisionArithmetic.js
function A3(A6, _4) {
  const g = new D2(A6, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L2.NEAREST, width: 1, height: 1 });
  function B(n6, e4) {
    const o8 = `

  precision highp float;

  attribute vec2 position;

  uniform vec3 u_highA;
  uniform vec3 u_lowA;
  uniform vec3 u_highB;
  uniform vec3 u_lowB;

  varying vec4 v_color;

  ${_4 ? "#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION" : ""}

  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION

  vec3 dpPlusFrc(vec3 a, vec3 b) {
    return mix(a, a + b, vec3(notEqual(b, vec3(0))));
  }

  vec3 dpMinusFrc(vec3 a, vec3 b) {
    return mix(vec3(0), a - b, vec3(notEqual(a, b)));
  }

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = dpPlusFrc(hiA, hiB);
    vec3 e = dpMinusFrc(t1, hiA);
    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
    return t1 + t2;
  }

  #else

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = hiA + hiB;
    vec3 e = t1 - hiA;
    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
    return t1 + t2;
  }

  #endif

  const float MAX_RGBA_FLOAT =
    255.0 / 256.0 +
    255.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 / 256.0;

  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);

  vec4 float2rgba(const float value) {
    // Make sure value is in the domain we can represent
    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);

    // Decompose value in 32bit fixed point parts represented as
    // uint8 rgba components. Decomposition uses the fractional part after multiplying
    // by a power of 256 (this removes the bits that are represented in the previous
    // component) and then converts the fractional part to 8bits.
    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);

    // Convert uint8 values (from 0 to 255) to floating point representation for
    // the shader
    const float toU8AsFloat = 1.0 / 255.0;

    return fixedPointU8 * toU8AsFloat;
  }

  void main() {
    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);

    v_color = float2rgba(val.z / 25.0);

    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);
  }
  `, r9 = "\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ", i2 = A6.programCache.acquire(o8, r9, /* @__PURE__ */ new Map([["position", 0]])), a2 = new Float32Array(6);
    t5(n6, a2, 3);
    const c4 = new Float32Array(6);
    return t5(e4, c4, 3), A6.useProgram(i2), i2.setUniform3f("u_highA", a2[0], a2[2], a2[4]), i2.setUniform3f("u_lowA", a2[1], a2[3], a2[5]), i2.setUniform3f("u_highB", c4[0], c4[2], c4[4]), i2.setUniform3f("u_lowB", c4[1], c4[3], c4[5]), i2;
  }
  const E4 = c2.createVertex(A6, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), b = new f3(A6, /* @__PURE__ */ new Map([["position", 0]]), { geometry: [new t3("position", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: E4 }), F3 = r2(5633261287538229e-9, 2626832878767164e-9, 1.4349880495278358e6), w2 = r2(563327146742708e-8, 2.6268736381334523e6, 1434963231608387e-9), T3 = B(F3, w2), O2 = A6.getBoundFramebufferObject(), { x: U2, y: I3, width: R3, height: N2 } = A6.getViewport();
  A6.bindFramebuffer(g), A6.setViewport(0, 0, 1, 1), A6.bindVAO(b), A6.drawArrays(E.TRIANGLE_STRIP, 0, 4);
  const S2 = new Uint8Array(4);
  g.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, S2), T3.dispose(), b.dispose(false), E4.dispose(), g.dispose(), A6.setViewport(U2, I3, R3, N2), A6.bindFramebuffer(O2);
  const D3 = (F3[2] - w2[2]) / 25, y2 = r4(S2);
  return Math.abs(D3 - y2);
}

// node_modules/@arcgis/core/views/webgl/testFloatBufferBlend.js
var T2;
var _2;
var F2;
var x = { exports: {} };
function A4(T3) {
  var _a, _b, _c, _d, _e;
  if (!T3.gl)
    return false;
  if (T3.type === o4.WEBGL1)
    return !(!((_a = T3.capabilities.textureFloat) == null ? void 0 : _a.textureFloat) || !((_b = T3.capabilities.colorBufferFloat) == null ? void 0 : _b.textureFloat));
  if (!(((_c = T3.capabilities.textureFloat) == null ? void 0 : _c.textureFloat) && ((_d = T3.capabilities.colorBufferFloat) == null ? void 0 : _d.textureFloat) && ((_e = T3.capabilities.colorBufferFloat) == null ? void 0 : _e.floatBlend)))
    return false;
  const _4 = new D2(T3, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.FLOAT, internalFormat: U.RGBA32F, samplingMode: L2.NEAREST, width: 1, height: 1 }), F3 = c2.createVertex(T3, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), A6 = new f3(T3, /* @__PURE__ */ new Map([["a_pos", 0]]), { geometry: [new t3("a_pos", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: F3 }), R3 = "\n  precision highp float;\n  attribute vec2 a_pos;\n\n  void main() {\n    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n  }\n  ", v2 = "\n   precision highp float;\n\n   void main() {\n    gl_FragColor = vec4(0.5, 0.5, 0.5, 0.5);\n   }\n  ", S2 = T3.programCache.acquire(R3, v2, /* @__PURE__ */ new Map([["a_pos", 0]]));
  T3.useProgram(S2);
  const h4 = T3.getBoundFramebufferObject(), { x: P2, y: L3, width: B, height: C2 } = T3.getViewport();
  T3.bindFramebuffer(_4), T3.setViewport(0, 0, 1, 1), T3.bindVAO(A6), T3.drawArrays(E.TRIANGLE_STRIP, 0, 4);
  const w2 = W2({ blending: A2 });
  T3.setPipelineState(w2), T3.drawArrays(E.TRIANGLE_STRIP, 0, 4), x.exports.init(T3);
  const O2 = T3.gl.getError();
  return T3.setViewport(P2, L3, B, C2), T3.bindFramebuffer(h4), S2.dispose(), A6.dispose(false), F3.dispose(), _4.dispose(), 1282 !== O2 || (console.warn("Device claims support for WebGL extension EXT_float_blend but does not support it. Using fall back."), false);
}
T2 = x, _2 = function() {
  var e4 = function(e5) {
    window.console && window.console.log && window.console.log(e5);
  }, t9 = function(t10) {
    window.console && window.console.error ? window.console.error(t10) : e4(t10);
  }, r9 = { enable: { 1: { 0: true } }, disable: { 1: { 0: true } }, getParameter: { 1: { 0: true } }, drawArrays: { 3: { 0: true } }, drawElements: { 4: { 0: true, 2: true } }, createShader: { 1: { 0: true } }, getShaderParameter: { 2: { 1: true } }, getProgramParameter: { 2: { 1: true } }, getShaderPrecisionFormat: { 2: { 0: true, 1: true } }, getVertexAttrib: { 2: { 1: true } }, vertexAttribPointer: { 6: { 2: true } }, bindTexture: { 2: { 0: true } }, activeTexture: { 1: { 0: true } }, getTexParameter: { 2: { 0: true, 1: true } }, texParameterf: { 3: { 0: true, 1: true } }, texParameteri: { 3: { 0: true, 1: true, 2: true } }, texImage2D: { 9: { 0: true, 2: true, 6: true, 7: true }, 6: { 0: true, 2: true, 3: true, 4: true } }, texSubImage2D: { 9: { 0: true, 6: true, 7: true }, 7: { 0: true, 4: true, 5: true } }, copyTexImage2D: { 8: { 0: true, 2: true } }, copyTexSubImage2D: { 8: { 0: true } }, generateMipmap: { 1: { 0: true } }, compressedTexImage2D: { 7: { 0: true, 2: true } }, compressedTexSubImage2D: { 8: { 0: true, 6: true } }, bindBuffer: { 2: { 0: true } }, bufferData: { 3: { 0: true, 2: true } }, bufferSubData: { 3: { 0: true } }, getBufferParameter: { 2: { 0: true, 1: true } }, pixelStorei: { 2: { 0: true, 1: true } }, readPixels: { 7: { 4: true, 5: true } }, bindRenderbuffer: { 2: { 0: true } }, bindFramebuffer: { 2: { 0: true } }, checkFramebufferStatus: { 1: { 0: true } }, framebufferRenderbuffer: { 4: { 0: true, 1: true, 2: true } }, framebufferTexture2D: { 5: { 0: true, 1: true, 2: true } }, getFramebufferAttachmentParameter: { 3: { 0: true, 1: true, 2: true } }, getRenderbufferParameter: { 2: { 0: true, 1: true } }, renderbufferStorage: { 4: { 0: true, 1: true } }, clear: { 1: { 0: { enumBitwiseOr: ["COLOR_BUFFER_BIT", "DEPTH_BUFFER_BIT", "STENCIL_BUFFER_BIT"] } } }, depthFunc: { 1: { 0: true } }, blendFunc: { 2: { 0: true, 1: true } }, blendFuncSeparate: { 4: { 0: true, 1: true, 2: true, 3: true } }, blendEquation: { 1: { 0: true } }, blendEquationSeparate: { 2: { 0: true, 1: true } }, stencilFunc: { 3: { 0: true } }, stencilFuncSeparate: { 4: { 0: true, 1: true } }, stencilMaskSeparate: { 2: { 0: true } }, stencilOp: { 3: { 0: true, 1: true, 2: true } }, stencilOpSeparate: { 4: { 0: true, 1: true, 2: true, 3: true } }, cullFace: { 1: { 0: true } }, frontFace: { 1: { 0: true } }, drawArraysInstancedANGLE: { 4: { 0: true } }, drawElementsInstancedANGLE: { 5: { 0: true, 2: true } }, blendEquationEXT: { 1: { 0: true } } }, n6 = null, o8 = null;
  function a2(e5) {
    if (null == n6)
      for (var t10 in n6 = {}, o8 = {}, e5)
        "number" == typeof e5[t10] && (n6[e5[t10]] = t10, o8[t10] = e5[t10]);
  }
  function i2() {
    if (null == n6)
      throw "WebGLDebugUtils.init(ctx) not called";
  }
  function f5(e5) {
    return i2(), void 0 !== n6[e5];
  }
  function u3(e5) {
    i2();
    var t10 = n6[e5];
    return void 0 !== t10 ? "gl." + t10 : "/*UNKNOWN WebGL ENUM*/ 0x" + e5.toString(16);
  }
  function l2(e5, t10, n7, a3) {
    var i3;
    if (void 0 !== (i3 = r9[e5]) && void 0 !== (i3 = i3[t10]) && i3[n7]) {
      if ("object" == typeof i3[n7] && void 0 !== i3[n7].enumBitwiseOr) {
        for (var f6 = i3[n7].enumBitwiseOr, l3 = 0, c5 = [], s9 = 0; s9 < f6.length; ++s9) {
          var d2 = o8[f6[s9]];
          0 != (a3 & d2) && (l3 |= d2, c5.push(u3(d2)));
        }
        return l3 === a3 ? c5.join(" | ") : u3(a3);
      }
      return u3(a3);
    }
    return null === a3 ? "null" : void 0 === a3 ? "undefined" : a3.toString();
  }
  function c4(e5, t10) {
    for (var r10 = "", n7 = t10.length, o9 = 0; o9 < n7; ++o9)
      r10 += (0 == o9 ? "" : ", ") + l2(e5, n7, o9, t10[o9]);
    return r10;
  }
  function s8(e5, t10, r10) {
    e5.__defineGetter__(r10, function() {
      return t10[r10];
    }), e5.__defineSetter__(r10, function(e6) {
      t10[r10] = e6;
    });
  }
  function d(e5, r10, n7, o9) {
    o9 = o9 || e5, a2(e5), r10 = r10 || function(e6, r11, n8) {
      for (var o10 = "", a3 = n8.length, i4 = 0; i4 < a3; ++i4)
        o10 += (0 == i4 ? "" : ", ") + l2(r11, a3, i4, n8[i4]);
      t9("WebGL error " + u3(e6) + " in " + r11 + "(" + o10 + ")");
    };
    var i3 = {};
    function f6(e6, t10) {
      return function() {
        n7 && n7(t10, arguments);
        var a3 = e6[t10].apply(e6, arguments), f7 = o9.getError();
        return 0 != f7 && (i3[f7] = true, r10(f7, t10, arguments)), a3;
      };
    }
    var c5 = {};
    for (var g2 in e5)
      if ("function" == typeof e5[g2])
        if ("getExtension" != g2)
          c5[g2] = f6(e5, g2);
        else {
          var b2 = f6(e5, g2);
          c5[g2] = function() {
            return d(b2.apply(e5, arguments), r10, n7, o9);
          };
        }
      else
        s8(c5, e5, g2);
    return c5.getError = function() {
      for (var t10 in i3)
        if (i3.hasOwnProperty(t10) && i3[t10])
          return i3[t10] = false, t10;
      return e5.NO_ERROR;
    }, c5;
  }
  function g(e5) {
    var t10 = e5.getParameter(e5.MAX_VERTEX_ATTRIBS), r10 = e5.createBuffer();
    e5.bindBuffer(e5.ARRAY_BUFFER, r10);
    for (var n7 = 0; n7 < t10; ++n7)
      e5.disableVertexAttribArray(n7), e5.vertexAttribPointer(n7, 4, e5.FLOAT, false, 0, 0), e5.vertexAttrib1f(n7, 0);
    e5.deleteBuffer(r10);
    var o9 = e5.getParameter(e5.MAX_TEXTURE_IMAGE_UNITS);
    for (n7 = 0; n7 < o9; ++n7)
      e5.activeTexture(e5.TEXTURE0 + n7), e5.bindTexture(e5.TEXTURE_CUBE_MAP, null), e5.bindTexture(e5.TEXTURE_2D, null);
    for (e5.activeTexture(e5.TEXTURE0), e5.useProgram(null), e5.bindBuffer(e5.ARRAY_BUFFER, null), e5.bindBuffer(e5.ELEMENT_ARRAY_BUFFER, null), e5.bindFramebuffer(e5.FRAMEBUFFER, null), e5.bindRenderbuffer(e5.RENDERBUFFER, null), e5.disable(e5.BLEND), e5.disable(e5.CULL_FACE), e5.disable(e5.DEPTH_TEST), e5.disable(e5.DITHER), e5.disable(e5.SCISSOR_TEST), e5.blendColor(0, 0, 0, 0), e5.blendEquation(e5.FUNC_ADD), e5.blendFunc(e5.ONE, e5.ZERO), e5.clearColor(0, 0, 0, 0), e5.clearDepth(1), e5.clearStencil(-1), e5.colorMask(true, true, true, true), e5.cullFace(e5.BACK), e5.depthFunc(e5.LESS), e5.depthMask(true), e5.depthRange(0, 1), e5.frontFace(e5.CCW), e5.hint(e5.GENERATE_MIPMAP_HINT, e5.DONT_CARE), e5.lineWidth(1), e5.pixelStorei(e5.PACK_ALIGNMENT, 4), e5.pixelStorei(e5.UNPACK_ALIGNMENT, 4), e5.pixelStorei(e5.UNPACK_FLIP_Y_WEBGL, false), e5.pixelStorei(e5.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), e5.UNPACK_COLORSPACE_CONVERSION_WEBGL && e5.pixelStorei(e5.UNPACK_COLORSPACE_CONVERSION_WEBGL, e5.BROWSER_DEFAULT_WEBGL), e5.polygonOffset(0, 0), e5.sampleCoverage(1, false), e5.scissor(0, 0, e5.canvas.width, e5.canvas.height), e5.stencilFunc(e5.ALWAYS, 0, 4294967295), e5.stencilMask(4294967295), e5.stencilOp(e5.KEEP, e5.KEEP, e5.KEEP), e5.viewport(0, 0, e5.canvas.width, e5.canvas.height), e5.clear(e5.COLOR_BUFFER_BIT | e5.DEPTH_BUFFER_BIT | e5.STENCIL_BUFFER_BIT); e5.getError(); )
      ;
  }
  function b(e5) {
    var t10, r10, n7 = [], o9 = [], a3 = {}, i3 = 1, f6 = false, u4 = [], l3 = 0, c5 = 0, d2 = false, b2 = 0, E4 = {};
    function p(e6) {
      return "function" == typeof e6 ? e6 : function(t11) {
        e6.handleEvent(t11);
      };
    }
    e5.getContext = (r10 = e5.getContext, function() {
      var n8 = r10.apply(e5, arguments);
      if (n8 instanceof WebGLRenderingContext) {
        if (n8 != t10) {
          if (t10)
            throw "got different context";
          a3 = S2(t10 = n8);
        }
        return a3;
      }
      return n8;
    });
    var m2 = function(e6) {
      n7.push(p(e6));
    }, T3 = function(e6) {
      o9.push(p(e6));
    };
    function _4(e6) {
      var t11 = e6.addEventListener;
      e6.addEventListener = function(r11, n8, o10) {
        switch (r11) {
          case "webglcontextlost":
            m2(n8);
            break;
          case "webglcontextrestored":
            T3(n8);
            break;
          default:
            t11.apply(e6, arguments);
        }
      };
    }
    function F3() {
      for (var e6 = Object.keys(E4), t11 = 0; t11 < e6.length; ++t11)
        delete E4[e6];
    }
    function x3() {
      ++c5, f6 || l3 == c5 && e5.loseContext();
    }
    function A6(e6, t11) {
      var r11 = e6[t11];
      return function() {
        if (x3(), !f6)
          return r11.apply(e6, arguments);
      };
    }
    function R3() {
      for (var e6 = 0; e6 < u4.length; ++e6) {
        var r11 = u4[e6];
        r11 instanceof WebGLBuffer ? t10.deleteBuffer(r11) : r11 instanceof WebGLFramebuffer ? t10.deleteFramebuffer(r11) : r11 instanceof WebGLProgram ? t10.deleteProgram(r11) : r11 instanceof WebGLRenderbuffer ? t10.deleteRenderbuffer(r11) : r11 instanceof WebGLShader ? t10.deleteShader(r11) : r11 instanceof WebGLTexture && t10.deleteTexture(r11);
      }
    }
    function v2(e6) {
      return { statusMessage: e6, preventDefault: function() {
        d2 = true;
      } };
    }
    return _4(e5), e5.loseContext = function() {
      if (!f6) {
        for (f6 = true, l3 = 0, ++i3; t10.getError(); )
          ;
        F3(), E4[t10.CONTEXT_LOST_WEBGL] = true;
        var r11 = v2("context lost"), o10 = n7.slice();
        setTimeout(function() {
          for (var t11 = 0; t11 < o10.length; ++t11)
            o10[t11](r11);
          b2 >= 0 && setTimeout(function() {
            e5.restoreContext();
          }, b2);
        }, 0);
      }
    }, e5.restoreContext = function() {
      f6 && o9.length && setTimeout(function() {
        if (!d2)
          throw "can not restore. webglcontestlost listener did not call event.preventDefault";
        R3(), g(t10), f6 = false, c5 = 0, d2 = false;
        for (var e6 = o9.slice(), r11 = v2("context restored"), n8 = 0; n8 < e6.length; ++n8)
          e6[n8](r11);
      }, 0);
    }, e5.loseContextInNCalls = function(e6) {
      if (f6)
        throw "You can not ask a lost contet to be lost";
      l3 = c5 + e6;
    }, e5.getNumCalls = function() {
      return c5;
    }, e5.setRestoreTimeout = function(e6) {
      b2 = e6;
    }, e5;
    function S2(e6) {
      for (var r11 in e6)
        "function" == typeof e6[r11] ? a3[r11] = A6(e6, r11) : s8(a3, e6, r11);
      a3.getError = function() {
        if (x3(), !f6)
          for (; e7 = t10.getError(); )
            E4[e7] = true;
        for (var e7 in E4)
          if (E4[e7])
            return delete E4[e7], e7;
        return a3.NO_ERROR;
      };
      for (var n8 = ["createBuffer", "createFramebuffer", "createProgram", "createRenderbuffer", "createShader", "createTexture"], o10 = 0; o10 < n8.length; ++o10) {
        var l4 = n8[o10];
        a3[l4] = function(t11) {
          return function() {
            if (x3(), f6)
              return null;
            var r12 = t11.apply(e6, arguments);
            return r12.__webglDebugContextLostId__ = i3, u4.push(r12), r12;
          };
        }(e6[l4]);
      }
      var c6 = ["getActiveAttrib", "getActiveUniform", "getBufferParameter", "getContextAttributes", "getAttachedShaders", "getFramebufferAttachmentParameter", "getParameter", "getProgramParameter", "getProgramInfoLog", "getRenderbufferParameter", "getShaderParameter", "getShaderInfoLog", "getShaderSource", "getTexParameter", "getUniform", "getUniformLocation", "getVertexAttrib"];
      for (o10 = 0; o10 < c6.length; ++o10)
        l4 = c6[o10], a3[l4] = function(t11) {
          return function() {
            return x3(), f6 ? null : t11.apply(e6, arguments);
          };
        }(a3[l4]);
      var d3 = ["isBuffer", "isEnabled", "isFramebuffer", "isProgram", "isRenderbuffer", "isShader", "isTexture"];
      for (o10 = 0; o10 < d3.length; ++o10)
        l4 = d3[o10], a3[l4] = function(t11) {
          return function() {
            return x3(), !f6 && t11.apply(e6, arguments);
          };
        }(a3[l4]);
      return a3.checkFramebufferStatus = function(t11) {
        return function() {
          return x3(), f6 ? a3.FRAMEBUFFER_UNSUPPORTED : t11.apply(e6, arguments);
        };
      }(a3.checkFramebufferStatus), a3.getAttribLocation = function(t11) {
        return function() {
          return x3(), f6 ? -1 : t11.apply(e6, arguments);
        };
      }(a3.getAttribLocation), a3.getVertexAttribOffset = function(t11) {
        return function() {
          return x3(), f6 ? 0 : t11.apply(e6, arguments);
        };
      }(a3.getVertexAttribOffset), a3.isContextLost = function() {
        return f6;
      }, a3;
    }
  }
  return { init: a2, mightBeEnum: f5, glEnumToString: u3, glFunctionArgToString: l2, glFunctionArgsToString: c4, makeDebugContext: d, makeLostContextSimulatingCanvas: b, resetToInitialState: g };
}, void 0 !== (F2 = _2()) && (T2.exports = F2);

// node_modules/@arcgis/core/views/webgl/testSamplerPrecision.js
var w = s.getLogger("esri.views.WebGLDriverTest");
function h2(e4) {
  const h4 = new D2(e4, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L2.NEAREST, width: 1, height: 1 }), T3 = "\nprecision highp float;\nattribute vec2 a_pos;\nuniform highp sampler2D u_texture;\nvarying vec4 v_color;\n\nfloat getBit(in float bitset, in int bitIndex) {\n  float offset = pow(2.0, float(bitIndex));\n  return mod(floor(bitset / offset), 2.0);\n}\n\nvoid main() {\n  vec4 value = texture2D(u_texture, vec2(0.0));\n  float bit = getBit(value.x * 255.0, 1);\n\n  v_color = bit * vec4(1.0);\n  gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n}\n", _4 = "\nprecision highp float;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = v_color;\n}\n", v2 = new Uint8Array(4), b = c2.createVertex(e4, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), E4 = new f3(e4, /* @__PURE__ */ new Map([["a_position", 0]]), { geometry: [new t3("a_position", 2, C.SHORT, 0, 4)] }, { geometry: b }), A6 = e4.programCache.acquire(T3, _4, /* @__PURE__ */ new Map([["a_pos", 0]]));
  e4.useProgram(A6);
  const x3 = new u2(e4, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L2.NEAREST, width: 1, height: 1 }, new Uint8Array([2, 255, 0, 0]));
  A6.setUniform1i("u_texture", 0), e4.bindTexture(x3, 0);
  const y2 = e4.getBoundFramebufferObject();
  e4.bindFramebuffer(h4), e4.useProgram(A6);
  const { x: D3, y: R3, width: j, height: N2 } = e4.getViewport();
  e4.setViewport(0, 0, 1, 1), e4.bindVAO(E4), e4.drawArrays(E.TRIANGLE_STRIP, 0, 4), e4.setViewport(D3, R3, j, N2), h4.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, v2), A6.dispose(), E4.dispose(false), b.dispose(), h4.dispose();
  const B = 255 !== v2[0] || 255 !== v2[1] || 255 !== v2[2] || 255 !== v2[3];
  return B && w.warn(`A problem was detected with your graphics driver. Your driver does not appear to honor sampler precision specifiers, which may result in rendering issues due to numerical instability. We recommend ensuring that your drivers have been updated to the latest version. Applying lowp sampler workaround. [${v2[0]}.${v2[1]}.${v2[2]}.${v2[3]}]`), e4.bindFramebuffer(y2), B;
}

// node_modules/@arcgis/core/views/webgl/testSVGPremultipliedAlpha.js
async function f4(f5) {
  const w2 = new Image();
  if (w2.src = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='5' height='5' version='1.1' viewBox='0 0 5 5' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='5' height='5' fill='%23f00' fill-opacity='.5'/%3E%3C/svg%3E%0A", w2.width = 5, w2.height = 5, await w2.decode(), !f5.gl)
    return true;
  const _4 = new D2(f5, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L2.NEAREST, width: 1, height: 1 }), E4 = c2.createVertex(f5, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), h4 = new f3(f5, /* @__PURE__ */ new Map([["a_pos", 0]]), m, { geometry: E4 }), v2 = "\n  precision highp float;\n\n  attribute vec2 a_pos;\n  varying vec2 v_uv;\n\n  void main() {\n    v_uv = a_pos;\n    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n  }\n  ", T3 = "\n  precision highp float;\n\n  varying vec2 v_uv;\n  uniform sampler2D u_texture;\n\n  void main() {\n    gl_FragColor = texture2D(u_texture, v_uv);\n  }\n  ", x3 = f5.programCache.acquire(v2, T3, /* @__PURE__ */ new Map([["a_pos", 0]]));
  f5.useProgram(x3);
  const A6 = new u2(f5, { dataType: G.UNSIGNED_BYTE, pixelFormat: P.RGBA, preMultiplyAlpha: false, wrapMode: D.CLAMP_TO_EDGE, samplingMode: L2.LINEAR }, w2);
  f5.bindTexture(A6, 0), x3.setUniform1i("u_texture", 0);
  const b = f5.getBoundFramebufferObject(), { x: y2, y: B, width: C2, height: F3 } = f5.getViewport();
  f5.bindFramebuffer(_4), f5.setViewport(0, 0, 1, 1), f5.setClearColor(0, 0, 0, 0), f5.setBlendingEnabled(false), f5.clearSafe(_.COLOR_BUFFER_BIT), f5.bindVAO(h4), f5.drawArrays(E.TRIANGLE_STRIP, 0, 4);
  const R3 = new Uint8Array(4);
  return _4.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, R3), x3.dispose(), h4.dispose(false), E4.dispose(), _4.dispose(), A6.dispose(), f5.setViewport(y2, B, C2, F3), f5.bindFramebuffer(b), w2.src = "", 255 === R3[0];
}

// node_modules/@arcgis/core/views/webgl/WebGLDriverTest.js
var o6 = class {
  constructor(e4) {
    this.context = e4, this._floatBufferBlendWorking = A4(e4), f4(e4).then((e5) => this._svgAlwaysPremultipliesAlpha = !e5);
  }
  get floatBufferBlendWorking() {
    if (t(this._floatBufferBlendWorking))
      throw new Error("floatBufferBlendWorking test not yet available");
    return this._floatBufferBlendWorking;
  }
  get svgAlwaysPremultipliesAlpha() {
    if (t(this._svgAlwaysPremultipliesAlpha))
      throw new Error("svgAlwaysPremultipliesAlpha test not yet available");
    return this._svgAlwaysPremultipliesAlpha;
  }
  get doublePrecisionRequiresObfuscation() {
    if (t(this._doublePrecisionRequiresObfuscation)) {
      const e4 = A3(this.context, false), i2 = A3(this.context, true);
      this._doublePrecisionRequiresObfuscation = 0 !== e4 && (0 === i2 || e4 / i2 > 5);
    }
    return this._doublePrecisionRequiresObfuscation;
  }
  get ignoresSamplerPrecision() {
    return t(this._ignoresSamplerPrecision) && (this._ignoresSamplerPrecision = h2(this.context)), this._ignoresSamplerPrecision;
  }
};

// node_modules/@arcgis/core/views/webgl/capabilities/DisjointTimerQuery.js
var E2 = class {
  constructor(e4, E4, t9, T3, r9, _4, i2, u3) {
    this.createQuery = e4, this.resultAvailable = E4, this.getResult = t9, this.disjoint = T3, this.beginTimeElapsed = r9, this.endTimeElapsed = _4, this.createTimestamp = i2, this.timestampBits = u3;
  }
};
function t6(t9, T3) {
  if (T3.disjointTimerQuery)
    return null;
  let r9 = t9.getExtension("EXT_disjoint_timer_query_webgl2");
  return r9 && n4(t9) ? new E2(() => t9.createQuery(), (e4) => t9.getQueryParameter(e4, t9.QUERY_RESULT_AVAILABLE), (e4) => t9.getQueryParameter(e4, t9.QUERY_RESULT), () => t9.getParameter(r9.GPU_DISJOINT_EXT), (e4) => t9.beginQuery(r9.TIME_ELAPSED_EXT, e4), () => t9.endQuery(r9.TIME_ELAPSED_EXT), (e4) => r9.queryCounterEXT(e4, r9.TIMESTAMP_EXT), () => t9.getQuery(r9.TIMESTAMP_EXT, r9.QUERY_COUNTER_BITS_EXT)) : (r9 = t9.getExtension("EXT_disjoint_timer_query"), r9 ? new E2(() => r9.createQueryEXT(), (e4) => r9.getQueryObjectEXT(e4, r9.QUERY_RESULT_AVAILABLE_EXT), (e4) => r9.getQueryObjectEXT(e4, r9.QUERY_RESULT_EXT), () => t9.getParameter(r9.GPU_DISJOINT_EXT), (e4) => r9.beginQueryEXT(r9.TIME_ELAPSED_EXT, e4), () => r9.endQueryEXT(r9.TIME_ELAPSED_EXT), (e4) => r9.queryCounterEXT(e4, r9.TIMESTAMP_EXT), () => r9.getQueryEXT(r9.TIMESTAMP_EXT, r9.QUERY_COUNTER_BITS_EXT)) : null);
}

// node_modules/@arcgis/core/views/webgl/capabilities/DrawBuffers.js
function A5(A6, _4) {
  if (_4.disjointTimerQuery)
    return null;
  if (n4(A6))
    return { drawBuffers: A6.drawBuffers.bind(A6), MAX_DRAW_BUFFERS: A6.MAX_DRAW_BUFFERS, MAX_COLOR_ATTACHMENTS: A6.MAX_COLOR_ATTACHMENTS };
  if (_4.drawBuffers)
    return null;
  const e4 = A6.getExtension("WEBGL_draw_buffers");
  return e4 ? { drawBuffers: e4.drawBuffersWEBGL.bind(e4), MAX_DRAW_BUFFERS: e4.MAX_DRAW_BUFFERS_WEBGL, MAX_COLOR_ATTACHMENTS: e4.MAX_COLOR_ATTACHMENTS_WEBGL } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Instancing.js
function r5(r9) {
  if (n4(r9))
    return { drawArraysInstanced: r9.drawArraysInstanced.bind(r9), drawElementsInstanced: r9.drawElementsInstanced.bind(r9), vertexAttribDivisor: r9.vertexAttribDivisor.bind(r9) };
  const t9 = r9.getExtension("ANGLE_instanced_arrays");
  return t9 ? { drawArraysInstanced: t9.drawArraysInstancedANGLE.bind(t9), drawElementsInstanced: t9.drawElementsInstancedANGLE.bind(t9), vertexAttribDivisor: t9.vertexAttribDivisorANGLE.bind(t9) } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/load.js
function _3(t9, _4) {
  if (_4.compressedTextureETC)
    return null;
  const e4 = t9.getExtension("WEBGL_compressed_texture_etc");
  return e4 ? { COMPRESSED_R11_EAC: e4.COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC: e4.COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC: e4.COMPRESSED_RG11_EAC, COMPRESSED_SIGNED_RG11_EAC: e4.COMPRESSED_SIGNED_RG11_EAC, COMPRESSED_RGB8_ETC2: e4.COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2: e4.COMPRESSED_SRGB8_ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: e4.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: e4.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_RGBA8_ETC2_EAC: e4.COMPRESSED_RGBA8_ETC2_EAC, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: e4.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC } : null;
}
function e2(t9, _4) {
  if (_4.compressedTextureS3TC)
    return null;
  const e4 = t9.getExtension("WEBGL_compressed_texture_s3tc");
  return e4 ? { COMPRESSED_RGB_S3TC_DXT1: e4.COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1: e4.COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3: e4.COMPRESSED_RGBA_S3TC_DXT3_EXT, COMPRESSED_RGBA_S3TC_DXT5: e4.COMPRESSED_RGBA_S3TC_DXT5_EXT } : null;
}
function E3(_4, e4) {
  if (n4(_4))
    return { MIN: _4.MIN, MAX: _4.MAX };
  if (e4.blendMinMax)
    return null;
  {
    const t9 = _4.getExtension("EXT_blend_minmax");
    return t9 ? { MIN: t9.MIN_EXT, MAX: t9.MAX_EXT } : null;
  }
}
function n5(t9, _4) {
  if (_4.textureFilterAnisotropic)
    return null;
  const e4 = t9.getExtension("EXT_texture_filter_anisotropic") || t9.getExtension("MOZ_EXT_texture_filter_anisotropic") || t9.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
  return e4 ? { MAX_TEXTURE_MAX_ANISOTROPY: e4.MAX_TEXTURE_MAX_ANISOTROPY_EXT, TEXTURE_MAX_ANISOTROPY: e4.TEXTURE_MAX_ANISOTROPY_EXT } : null;
}
function R2(_4, e4) {
  if (n4(_4))
    return { textureFloat: true, textureFloatLinear: !e4.textureFloatLinear && !!_4.getExtension("OES_texture_float_linear"), textureHalfFloat: true, textureHalfFloatLinear: true, HALF_FLOAT: _4.HALF_FLOAT, R16F: _4.R16F, RG16F: _4.RG16F, RGBA16F: _4.RGBA16F, R32F: _4.R32F, RG32F: _4.RG32F, RGBA32F: _4.RGBA32F, R11F_G11F_B10F: _4.R11F_G11F_B10F, RGB16F: _4.RGB16F };
  if (_4 instanceof WebGLRenderingContext) {
    const t9 = !e4.textureHalfFloat && _4.getExtension("OES_texture_half_float");
    return { textureFloat: !e4.textureFloat && !!_4.getExtension("OES_texture_float"), textureFloatLinear: !e4.textureFloatLinear && !!_4.getExtension("OES_texture_float_linear"), textureHalfFloat: !!t9, textureHalfFloatLinear: !e4.textureHalfFloatLinear && !!_4.getExtension("OES_texture_half_float_linear"), HALF_FLOAT: t9 ? t9.HALF_FLOAT_OES : void 0 };
  }
  return null;
}
function r6(_4, e4) {
  if (n4(_4)) {
    const t9 = !e4.colorBufferHalfFloat && _4.getExtension("EXT_color_buffer_half_float") || !e4.colorBufferFloat && _4.getExtension("EXT_color_buffer_float"), E4 = !e4.colorBufferFloat && _4.getExtension("EXT_color_buffer_float"), n6 = !e4.floatBlend && !e4.colorBufferFloat && _4.getExtension("EXT_float_blend");
    return t9 || E4 || n6 ? { textureFloat: !!E4, textureHalfFloat: !!t9, floatBlend: !!n6, R16F: _4.R16F, RG16F: _4.RG16F, RGBA16F: _4.RGBA16F, R32F: _4.R32F, RG32F: _4.RG32F, RGBA32F: _4.RGBA32F, R11F_G11F_B10F: _4.R11F_G11F_B10F, RGB16F: _4.RGB16F } : null;
  }
  if (_4 instanceof WebGLRenderingContext) {
    const t9 = !e4.colorBufferHalfFloat && _4.getExtension("EXT_color_buffer_half_float"), E4 = !e4.colorBufferFloat && _4.getExtension("WEBGL_color_buffer_float"), n6 = !e4.floatBlend && !e4.colorBufferFloat && _4.getExtension("EXT_float_blend");
    return t9 || E4 || n6 ? { textureFloat: !!E4, textureHalfFloat: !!t9, floatBlend: !!n6, RGBA16F: t9 ? t9.RGBA16F_EXT : void 0, RGB16F: t9 ? t9.RGB16F_EXT : void 0, RGBA32F: E4 ? E4.RGBA32F_EXT : void 0 } : null;
  }
  return null;
}
function o7(_4, e4, E4, n6, R3) {
  if (n6 && n4(_4))
    return true;
  if (e4[E4])
    return false;
  for (const t9 of R3)
    if (_4.getExtension(t9))
      return true;
  return false;
}
function l(_4, e4) {
  if (!n4(_4))
    return null;
  if (e4.textureNorm16)
    return null;
  const E4 = _4.getExtension("EXT_texture_norm16");
  return E4 ? { R16: E4.R16_EXT, RG16: E4.RG16_EXT, RGB16: E4.RGB16_EXT, RGBA16: E4.RGBA16_EXT, R16_SNORM: E4.R16_SNORM_EXT, RG16_SNORM: E4.RG16_SNORM_EXT, RGB16_SNORM: E4.RGB16_SNORM_EXT, RGBA16_SNORM: E4.RGBA16_SNORM_EXT } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/LoseContext.js
function e3(e4, t9) {
  const n6 = t9.loseContext && e4.getExtension("WEBGL_lose_context");
  return n6 ? { loseRenderingContext: () => n6.loseContext() } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/VertexArrayObjects.js
function r7(r9, t9) {
  if (n4(r9))
    return { createVertexArray: r9.createVertexArray.bind(r9), deleteVertexArray: r9.deleteVertexArray.bind(r9), bindVertexArray: r9.bindVertexArray.bind(r9) };
  if (t9.vao)
    return null;
  const n6 = r9.getExtension("OES_vertex_array_object") || r9.getExtension("MOZ_OES_vertex_array_object") || r9.getExtension("WEBKIT_OES_vertex_array_object");
  return n6 ? { createVertexArray: n6.createVertexArrayOES.bind(n6), deleteVertexArray: n6.deleteVertexArrayOES.bind(n6), bindVertexArray: n6.bindVertexArrayOES.bind(n6) } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Capabilities.js
var x2 = class {
  constructor(t9, e4) {
    this.gl = t9, this._depthTexture = null, this._standardDerivatives = null, this._shaderTextureLOD = null, this._fragDepth = null, this._textureFloatLinear = null, this._disabledExtensions = e4.disabledExtensions || {}, this._debugWebGLExtensions = e4.debugWebGLExtensions || {};
  }
  get drawBuffers() {
    return this._drawBuffers || (this._drawBuffers = A5(this.gl, this._disabledExtensions)), this._drawBuffers;
  }
  get instancing() {
    return this._instancing || (this._instancing = r5(this.gl)), this._instancing;
  }
  get vao() {
    return this._vertexArrayObject || (this._vertexArrayObject = r7(this.gl, this._disabledExtensions)), this._vertexArrayObject;
  }
  get compressedTextureETC() {
    return this._compressedTextureETC || (this._compressedTextureETC = _3(this.gl, this._disabledExtensions)), this._compressedTextureETC;
  }
  get compressedTextureS3TC() {
    return this._compressedTextureS3TC || (this._compressedTextureS3TC = e2(this.gl, this._disabledExtensions)), this._compressedTextureS3TC;
  }
  get textureFilterAnisotropic() {
    return this._textureFilterAnisotropic || (this._textureFilterAnisotropic = n5(this.gl, this._disabledExtensions)), this._textureFilterAnisotropic;
  }
  get disjointTimerQuery() {
    return this._disjointTimerQuery || (this._disjointTimerQuery = t6(this.gl, this._disabledExtensions)), this._disjointTimerQuery;
  }
  get textureFloat() {
    return this._textureFloat || (this._textureFloat = R2(this.gl, this._disabledExtensions)), this._textureFloat;
  }
  get colorBufferFloat() {
    return this._colorBufferFloat || (this._colorBufferFloat = r6(this.gl, this._disabledExtensions)), this._colorBufferFloat;
  }
  get blendMinMax() {
    return this._minMaxBlending || (this._minMaxBlending = E3(this.gl, this._disabledExtensions)), this._minMaxBlending;
  }
  get depthTexture() {
    return null === this._depthTexture && (this._depthTexture = o7(this.gl, this._disabledExtensions, "depthTexture", true, ["WEBGL_depth_texture", "MOZ_WEBGL_depth_texture", "WEBKIT_WEBGL_depth_texture"])), this._depthTexture;
  }
  get standardDerivatives() {
    return null === this._standardDerivatives && (this._standardDerivatives = o7(this.gl, this._disabledExtensions, "standardDerivatives", true, ["OES_standard_derivatives"])), this._standardDerivatives;
  }
  get shaderTextureLOD() {
    return null === this._shaderTextureLOD && (this._shaderTextureLOD = o7(this.gl, this._disabledExtensions, "shaderTextureLOD", true, ["EXT_shader_texture_lod"])), this._shaderTextureLOD;
  }
  get fragDepth() {
    return null === this._fragDepth && (this._fragDepth = o7(this.gl, this._disabledExtensions, "fragDepth", true, ["EXT_frag_depth"])), this._fragDepth;
  }
  get loseContext() {
    return this._loseContext || (this._loseContext = e3(this.gl, this._debugWebGLExtensions)), this._loseContext;
  }
  get textureNorm16() {
    return this._textureNorm16 || (this._textureNorm16 = l(this.gl, this._disabledExtensions)), this._textureNorm16;
  }
  get textureFloatLinear() {
    return null === this._textureFloatLinear && (this._textureFloatLinear = o7(this.gl, this._disabledExtensions, "textureFloatLinear", false, ["OES_texture_float_linear"])), this._textureFloatLinear;
  }
  enable(t9) {
    return this[t9];
  }
};

// node_modules/@arcgis/core/views/webgl/RenderingContext.js
var y = class {
  constructor(t9, e4) {
    this.gl = t9, this.instanceCounter = new s4(), this.programCache = new s3(this), this._state = new h(), this._numOfDrawCalls = 0, this._numOfTriangles = 0, this.type = n4(t9) ? o4.WEBGL2 : o4.WEBGL1, this._loadExtensions(), this.configure(e4);
  }
  configure(t9) {
    this._capabilities = new x2(this.gl, t9), this._parameters = this._loadParameters(t9);
    const e4 = this.gl.getParameter(this.gl.VIEWPORT);
    this._state = new h(), this._state.viewport = { x: e4[0], y: e4[1], width: e4[2], height: e4[3] }, this._stateTracker = new M2({ setBlending: (t10) => {
      if (t10) {
        this.setBlendingEnabled(true), this.setBlendEquationSeparate(t10.opRgb, t10.opAlpha), this.setBlendFunctionSeparate(t10.srcRgb, t10.dstRgb, t10.srcAlpha, t10.dstAlpha);
        const e5 = t10.color;
        this.setBlendColor(e5.r, e5.g, e5.b, e5.a);
      } else
        this.setBlendingEnabled(false);
    }, setCulling: (t10) => {
      t10 ? (this.setFaceCullingEnabled(true), this.setCullFace(t10.face), this.setFrontFace(t10.mode)) : this.setFaceCullingEnabled(false);
    }, setPolygonOffset: (t10) => {
      t10 ? (this.setPolygonOffsetFillEnabled(true), this.setPolygonOffset(t10.factor, t10.units)) : this.setPolygonOffsetFillEnabled(false);
    }, setDepthTest: (t10) => {
      t10 ? (this.setDepthTestEnabled(true), this.setDepthFunction(t10.func)) : this.setDepthTestEnabled(false);
    }, setStencilTest: (t10) => {
      if (t10) {
        this.setStencilTestEnabled(true);
        const e5 = t10.function;
        this.setStencilFunction(e5.func, e5.ref, e5.mask);
        const s8 = t10.operation;
        this.setStencilOp(s8.fail, s8.zFail, s8.zPass);
      } else
        this.setStencilTestEnabled(false);
    }, setDepthWrite: (t10) => {
      t10 ? (this.setDepthWriteEnabled(true), this.setDepthRange(t10.zNear, t10.zFar)) : this.setDepthWriteEnabled(false);
    }, setColorWrite: (t10) => {
      t10 ? this.setColorMask(t10.r, t10.g, t10.b, t10.a) : this.setColorMask(false, false, false, false);
    }, setStencilWrite: (t10) => {
      t10 ? this.setStencilWriteMask(t10.mask) : this.setStencilWriteMask(0);
    } }), this.enforceState(), this._driverTest = new o6(this);
  }
  get driverTest() {
    return this._driverTest;
  }
  get contextAttributes() {
    return this.gl.getContextAttributes();
  }
  get parameters() {
    return this._parameters;
  }
  dispose() {
    this.programCache.dispose(), this.bindVAO(null), this.unbindBuffer(A.ARRAY_BUFFER), this.unbindBuffer(A.ELEMENT_ARRAY_BUFFER), n4(this.gl) && (this.unbindBuffer(A.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A.PIXEL_PACK_BUFFER), this.unbindBuffer(A.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A.COPY_READ_BUFFER), this.unbindBuffer(A.COPY_WRITE_BUFFER)), this._state.textureUnitMap.length = 0, u() && this.instanceCounter.printResourceCount();
  }
  setPipelineState(t9) {
    this._stateTracker.setPipeline(t9);
  }
  setBlendingEnabled(t9) {
    this._state.blend !== t9 && (true === t9 ? this.gl.enable(this.gl.BLEND) : this.gl.disable(this.gl.BLEND), this._state.blend = t9, this._stateTracker.invalidateBlending());
  }
  externalProgramUpdate() {
    var _a;
    (_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = null;
  }
  externalTextureUnitUpdate(t9, e4) {
    for (let s8 = 0; s8 < t9.length; ++s8)
      this._state.textureUnitMap[t9[s8]] = null;
    e4 >= 0 && (this._state.activeTexture = e4);
  }
  externalVertexArrayObjectUpdate() {
    const t9 = this.capabilities.vao;
    t9 && (t9.bindVertexArray(null), this._state.vertexArrayObject = null), this._state.vertexBuffer = null, this._state.indexBuffer = null;
  }
  externalVertexBufferUpdate() {
    this._state.vertexBuffer = null;
  }
  externalIndexBufferUpdate() {
    this._state.indexBuffer = null;
  }
  setBlendColor(t9, e4, s8, i2) {
    t9 === this._state.blendColor.r && e4 === this._state.blendColor.g && s8 === this._state.blendColor.b && i2 === this._state.blendColor.a || (this.gl.blendColor(t9, e4, s8, i2), this._state.blendColor.r = t9, this._state.blendColor.g = e4, this._state.blendColor.b = s8, this._state.blendColor.a = i2, this._stateTracker.invalidateBlending());
  }
  setBlendFunction(t9, e4) {
    t9 === this._state.blendFunction.srcRGB && e4 === this._state.blendFunction.dstRGB || (this.gl.blendFunc(t9, e4), this._state.blendFunction.srcRGB = t9, this._state.blendFunction.srcAlpha = t9, this._state.blendFunction.dstRGB = e4, this._state.blendFunction.dstAlpha = e4, this._stateTracker.invalidateBlending());
  }
  setBlendFunctionSeparate(t9, e4, s8, i2) {
    this._state.blendFunction.srcRGB === t9 && this._state.blendFunction.srcAlpha === s8 && this._state.blendFunction.dstRGB === e4 && this._state.blendFunction.dstAlpha === i2 || (this.gl.blendFuncSeparate(t9, e4, s8, i2), this._state.blendFunction.srcRGB = t9, this._state.blendFunction.srcAlpha = s8, this._state.blendFunction.dstRGB = e4, this._state.blendFunction.dstAlpha = i2, this._stateTracker.invalidateBlending());
  }
  setBlendEquation(t9) {
    this._state.blendEquation.mode !== t9 && (this.gl.blendEquation(t9), this._state.blendEquation.mode = t9, this._state.blendEquation.modeAlpha = t9, this._stateTracker.invalidateBlending());
  }
  setBlendEquationSeparate(t9, e4) {
    this._state.blendEquation.mode === t9 && this._state.blendEquation.modeAlpha === e4 || (this.gl.blendEquationSeparate(t9, e4), this._state.blendEquation.mode = t9, this._state.blendEquation.modeAlpha = e4, this._stateTracker.invalidateBlending());
  }
  setColorMask(t9, e4, s8, i2) {
    this._state.colorMask.r === t9 && this._state.colorMask.g === e4 && this._state.colorMask.b === s8 && this._state.colorMask.a === i2 || (this.gl.colorMask(t9, e4, s8, i2), this._state.colorMask.r = t9, this._state.colorMask.g = e4, this._state.colorMask.b = s8, this._state.colorMask.a = i2, this._stateTracker.invalidateColorWrite());
  }
  setClearColor(t9, e4, s8, i2) {
    this._state.clearColor.r === t9 && this._state.clearColor.g === e4 && this._state.clearColor.b === s8 && this._state.clearColor.a === i2 || (this.gl.clearColor(t9, e4, s8, i2), this._state.clearColor.r = t9, this._state.clearColor.g = e4, this._state.clearColor.b = s8, this._state.clearColor.a = i2);
  }
  setFaceCullingEnabled(t9) {
    this._state.faceCulling !== t9 && (true === t9 ? this.gl.enable(this.gl.CULL_FACE) : this.gl.disable(this.gl.CULL_FACE), this._state.faceCulling = t9, this._stateTracker.invalidateCulling());
  }
  setPolygonOffsetFillEnabled(t9) {
    this._state.polygonOffsetFill !== t9 && (true === t9 ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL), this._state.polygonOffsetFill = t9, this._stateTracker.invalidatePolygonOffset());
  }
  setPolygonOffset(t9, e4) {
    this._state.polygonOffset[0] === t9 && this._state.polygonOffset[1] === e4 || (this._state.polygonOffset[0] = t9, this._state.polygonOffset[1] = e4, this.gl.polygonOffset(t9, e4), this._stateTracker.invalidatePolygonOffset());
  }
  setCullFace(t9) {
    this._state.cullFace !== t9 && (this.gl.cullFace(t9), this._state.cullFace = t9, this._stateTracker.invalidateCulling());
  }
  setFrontFace(t9) {
    this._state.frontFace !== t9 && (this.gl.frontFace(t9), this._state.frontFace = t9, this._stateTracker.invalidateCulling());
  }
  setScissorTestEnabled(t9) {
    this._state.scissorTest !== t9 && (true === t9 ? this.gl.enable(this.gl.SCISSOR_TEST) : this.gl.disable(this.gl.SCISSOR_TEST), this._state.scissorTest = t9);
  }
  setScissorRect(t9, e4, s8, i2) {
    this._state.scissorRect.x === t9 && this._state.scissorRect.y === e4 && this._state.scissorRect.width === s8 && this._state.scissorRect.height === i2 || (this.gl.scissor(t9, e4, s8, i2), this._state.scissorRect.x = t9, this._state.scissorRect.y = e4, this._state.scissorRect.width = s8, this._state.scissorRect.height = i2);
  }
  setDepthTestEnabled(t9) {
    this._state.depthTest !== t9 && (true === t9 ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST), this._state.depthTest = t9, this._stateTracker.invalidateDepthTest());
  }
  setClearDepth(t9) {
    this._state.clearDepth !== t9 && (this.gl.clearDepth(t9), this._state.clearDepth = t9);
  }
  setDepthFunction(t9) {
    this._state.depthFunction !== t9 && (this.gl.depthFunc(t9), this._state.depthFunction = t9, this._stateTracker.invalidateDepthTest());
  }
  setDepthWriteEnabled(t9) {
    this._state.depthWrite !== t9 && (this.gl.depthMask(t9), this._state.depthWrite = t9, this._stateTracker.invalidateDepthWrite());
  }
  setDepthRange(t9, e4) {
    this._state.depthRange.zNear === t9 && this._state.depthRange.zFar === e4 || (this.gl.depthRange(t9, e4), this._state.depthRange.zNear = t9, this._state.depthRange.zFar = e4, this._stateTracker.invalidateDepthWrite());
  }
  setStencilTestEnabled(t9) {
    this._state.stencilTest !== t9 && (true === t9 ? this.gl.enable(this.gl.STENCIL_TEST) : this.gl.disable(this.gl.STENCIL_TEST), this._state.stencilTest = t9, this._stateTracker.invalidateStencilTest());
  }
  setClearStencil(t9) {
    t9 !== this._state.clearStencil && (this.gl.clearStencil(t9), this._state.clearStencil = t9);
  }
  setStencilFunction(t9, e4, s8) {
    this._state.stencilFunction.func === t9 && this._state.stencilFunction.ref === e4 && this._state.stencilFunction.mask === s8 || (this.gl.stencilFunc(t9, e4, s8), this._state.stencilFunction.face = N.FRONT_AND_BACK, this._state.stencilFunction.func = t9, this._state.stencilFunction.ref = e4, this._state.stencilFunction.mask = s8, this._stateTracker.invalidateStencilTest());
  }
  setStencilFunctionSeparate(t9, e4, s8, i2) {
    this._state.stencilFunction.face === t9 && this._state.stencilFunction.func === e4 && this._state.stencilFunction.ref === s8 && this._state.stencilFunction.mask === i2 || (this.gl.stencilFuncSeparate(t9, e4, s8, i2), this._state.stencilFunction.face = t9, this._state.stencilFunction.func = e4, this._state.stencilFunction.ref = s8, this._state.stencilFunction.mask = i2, this._stateTracker.invalidateStencilTest());
  }
  setStencilWriteMask(t9) {
    this._state.stencilWriteMask !== t9 && (this.gl.stencilMask(t9), this._state.stencilWriteMask = t9, this._stateTracker.invalidateStencilWrite());
  }
  setStencilOp(t9, e4, s8) {
    this._state.stencilOperation.face === N.FRONT_AND_BACK && this._state.stencilOperation.fail === t9 && this._state.stencilOperation.zFail === e4 && this._state.stencilOperation.zPass === s8 || (this.gl.stencilOp(t9, e4, s8), this._state.stencilOperation.face = N.FRONT_AND_BACK, this._state.stencilOperation.fail = t9, this._state.stencilOperation.zFail = e4, this._state.stencilOperation.zPass = s8, this._stateTracker.invalidateStencilTest());
  }
  setStencilOpSeparate(t9, e4, s8, i2) {
    this._state.stencilOperation.face === t9 && this._state.stencilOperation.fail === e4 && this._state.stencilOperation.zFail === s8 && this._state.stencilOperation.zPass === i2 || (this.gl.stencilOpSeparate(t9, e4, s8, i2), this._state.stencilOperation.face = t9, this._state.stencilOperation.fail = e4, this._state.stencilOperation.zFail = s8, this._state.stencilOperation.zPass = i2, this._stateTracker.invalidateStencilTest());
  }
  setActiveTexture(t9, e4 = false) {
    const s8 = this._state.activeTexture;
    return t9 >= 0 && (e4 || t9 !== this._state.activeTexture) && (this.gl.activeTexture(X + t9), this._state.activeTexture = t9), s8;
  }
  clear(t9) {
    t9 && this.gl.clear(t9);
  }
  clearSafe(t9, e4 = 255) {
    t9 && (t9 & _.COLOR_BUFFER_BIT && this.setColorMask(true, true, true, true), t9 & _.DEPTH_BUFFER_BIT && this.setDepthWriteEnabled(true), t9 & _.STENCIL_BUFFER_BIT && this.setStencilWriteMask(e4), this.gl.clear(t9));
  }
  drawArrays(t9, e4, s8) {
    if (u() && (this._numOfDrawCalls++, this._numOfTriangles += I2(t9, s8)), this.gl.drawArrays(t9, e4, s8), u()) {
      const t10 = i(this);
      t10 && console.error("drawArrays:", t10);
    }
  }
  drawElements(e4, s8, i2, a2) {
    if (u() && (this._numOfDrawCalls++, this._numOfTriangles += I2(e4, s8)), this.gl.drawElements(e4, s8, i2, a2), u()) {
      const r9 = i(this);
      if (r9) {
        const n6 = this.getBoundVAO(), l2 = n6 == null ? void 0 : n6.indexBuffer, h4 = n6 == null ? void 0 : n6.vertexBuffers, f5 = { indexBuffer: l2, vertexBuffers: h4 }, o8 = { mode: e4, count: s8, type: i2, offset: a2 }, _4 = o(l2, (t9) => t9.size) ?? 0, u3 = a2 + s8, c4 = _4 < u3 ? `. Buffer is too small. Attempted to draw index ${u3} of ${_4}` : "";
        console.error(`drawElements: ${r9}${c4}`, { args: o8, vao: f5 });
      }
    }
  }
  logInfo() {
    u() && console.log(`DrawCalls: ${this._numOfDrawCalls}, Triangles: ${this._numOfTriangles}`);
  }
  resetInfo() {
    u() && (this._numOfDrawCalls = 0, this._numOfTriangles = 0);
  }
  get capabilities() {
    return this._capabilities;
  }
  setViewport(t9, e4, s8, i2) {
    s8 = Math.max(Math.round(s8), 1), i2 = Math.max(Math.round(i2), 1);
    const a2 = this._state.viewport;
    a2.x === t9 && a2.y === e4 && a2.width === s8 && a2.height === i2 || (a2.x = t9, a2.y = e4, a2.width = s8, a2.height = i2, this.gl.viewport(t9, e4, s8, i2));
  }
  getViewport() {
    return { x: this._state.viewport.x, y: this._state.viewport.y, width: this._state.viewport.width, height: this._state.viewport.height };
  }
  useProgram(t9) {
    var _a;
    this._state.program !== t9 && ((_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = t9, this.gl.useProgram((t9 == null ? void 0 : t9.glName) ?? null));
  }
  bindTexture(t9, i2, a2 = false) {
    (i2 >= this.parameters.maxTextureImageUnits || i2 < 0) && console.error("Input texture unit is out of range of available units!");
    const r9 = this._state.textureUnitMap[i2];
    return t(t9) || null == t9.glName ? (r(r9) && (this.setActiveTexture(i2, a2), this.gl.bindTexture(r9.descriptor.target, null)), this._state.textureUnitMap[i2] = null, r9) : a2 || r9 !== t9 ? (this.setActiveTexture(i2, a2), this.gl.bindTexture(t9.descriptor.target, t9.glName), t9.applyChanges(), this._state.textureUnitMap[i2] = t9, r9) : (t9.isDirty && (this.setActiveTexture(i2, a2), t9.applyChanges()), r9);
  }
  unbindTexture(t9) {
    if (!t(t9))
      for (let e4 = 0; e4 < this.parameters.maxTextureImageUnits; e4++)
        this._state.textureUnitMap[e4] === t9 && (this.bindTexture(null, e4), this._state.textureUnitMap[e4] = null);
  }
  bindFramebuffer(t9, s8 = false) {
    if (s8 || this._state.readFramebuffer !== t9 || this._state.drawFramebuffer !== t9) {
      if (t(t9))
        return this.gl.bindFramebuffer(n3.FRAMEBUFFER, null), this._state.readFramebuffer = null, void (this._state.drawFramebuffer = null);
      t9.initializeAndBind(n3.FRAMEBUFFER), this._state.readFramebuffer = t9, this._state.drawFramebuffer = t9;
    }
  }
  bindFramebufferSeparate(t9, s8, a2 = false) {
    const r9 = s8 === n3.READ_FRAMEBUFFER, n6 = r9 ? this._state.readFramebuffer : this._state.drawFramebuffer;
    (a2 || n6 !== t9) && (t(t9) ? this.gl.bindFramebuffer(s8, null) : t9.initializeAndBind(s8), r9 ? this._state.readFramebuffer = c(t9, null) : this._state.drawFramebuffer = c(t9, null));
  }
  blitFramebuffer(t9, e4, s8 = 0, i2 = 0, a2 = t9.width, r9 = t9.height, n6 = 0, l2 = 0, h4 = e4.width, f5 = e4.height, o8 = _.COLOR_BUFFER_BIT, _4 = L2.NEAREST) {
    this.bindFramebufferSeparate(t9, n3.READ_FRAMEBUFFER), this.bindFramebufferSeparate(e4, n3.DRAW_FRAMEBUFFER);
    this.gl.blitFramebuffer(s8, i2, a2, r9, n6, l2, h4, f5, o8, _4);
  }
  bindBuffer(t9, e4) {
    if (t9)
      switch (e4 ?? (e4 = t9.bufferType), e4) {
        case A.ARRAY_BUFFER:
          this._state.vertexBuffer = v(this.gl, t9, e4, this._state.vertexBuffer);
          break;
        case A.ELEMENT_ARRAY_BUFFER:
          this._state.indexBuffer = v(this.gl, t9, e4, this._state.indexBuffer);
          break;
        case A.UNIFORM_BUFFER:
          this._state.uniformBuffer = v(this.gl, t9, e4, this._state.uniformBuffer);
          break;
        case A.PIXEL_PACK_BUFFER:
          this._state.pixelPackBuffer = v(this.gl, t9, e4, this._state.pixelPackBuffer);
          break;
        case A.PIXEL_UNPACK_BUFFER:
          this._state.pixelUnpackBuffer = v(this.gl, t9, e4, this._state.pixelUnpackBuffer);
          break;
        case A.COPY_READ_BUFFER:
          this._state.copyReadBuffer = v(this.gl, t9, e4, this._state.copyReadBuffer);
          break;
        case A.COPY_WRITE_BUFFER:
          this._state.copyWriteBuffer = v(this.gl, t9, e4, this._state.copyWriteBuffer);
      }
  }
  bindRenderbuffer(t9) {
    const e4 = this.gl;
    t9 || (e4.bindRenderbuffer(e4.RENDERBUFFER, null), this._state.renderbuffer = null), this._state.renderbuffer !== t9 && (e4.bindRenderbuffer(e4.RENDERBUFFER, t9.glName), this._state.renderbuffer = t9);
  }
  _getBufferBinding(t9, s8) {
    if (s8 >= this.parameters.maxUniformBufferBindings || s8 < 0)
      return console.error("Uniform buffer binding point is out of range!"), null;
    const i2 = this._state.uniformBufferBindingPoints;
    let a2 = i2[s8];
    return t(a2) && (a2 = { buffer: null, offset: 0, size: 0 }, i2[s8] = a2), a2;
  }
  bindBufferBase(t9, s8, i2) {
    const a2 = this._getBufferBinding(t9, s8);
    if (t(a2))
      return;
    if (a2.buffer === i2 && 0 === a2.offset && 0 === a2.size)
      return;
    this.gl.bindBufferBase(t9, s8, i2 ? i2.glName : null), a2.buffer = i2, a2.offset = 0, a2.size = 0;
  }
  bindBufferRange(t9, s8, i2, a2, r9) {
    const n6 = this._getBufferBinding(t9, s8);
    if (t(n6))
      return;
    if (n6.buffer === i2 && n6.offset === a2 && n6.size === r9)
      return;
    if (a2 % this._parameters.uniformBufferOffsetAlignment != 0)
      return void console.error("Uniform buffer binding offset is not a multiple of the context offset alignment");
    this.gl.bindBufferRange(t9, s8, i2.glName, a2, r9), n6.buffer = i2, n6.offset = a2, n6.size = r9;
  }
  bindUBO(t9, s8, i2, a2) {
    t(s8) ? this.bindBufferBase(A.UNIFORM_BUFFER, t9, null) : (u() && (a2 ?? s8.byteLength) > this._parameters.maxUniformBlockSize && console.error("Attempting to bind more data than the maximum uniform block size"), s8.initialize(), void 0 !== i2 && void 0 !== a2 ? this.bindBufferRange(A.UNIFORM_BUFFER, t9, s8.buffer, i2, a2) : this.bindBufferBase(A.UNIFORM_BUFFER, t9, s8.buffer));
  }
  unbindUBO(t9) {
    for (let e4 = 0, i2 = this._state.uniformBufferBindingPoints.length; e4 < i2; e4++) {
      const i3 = this._state.uniformBufferBindingPoints[e4];
      r(i3) && i3.buffer === t9.buffer && this.bindBufferBase(A.UNIFORM_BUFFER, e4, null);
    }
  }
  unbindBuffer(t9) {
    switch (t9) {
      case A.ARRAY_BUFFER:
        this._state.vertexBuffer = v(this.gl, null, t9, this._state.vertexBuffer);
        break;
      case A.ELEMENT_ARRAY_BUFFER:
        this._state.indexBuffer = v(this.gl, null, t9, this._state.indexBuffer);
        break;
      case A.UNIFORM_BUFFER:
        this._state.uniformBuffer = v(this.gl, null, t9, this._state.uniformBuffer);
        break;
      case A.PIXEL_PACK_BUFFER:
        this._state.pixelPackBuffer = v(this.gl, null, t9, this._state.pixelPackBuffer);
        break;
      case A.PIXEL_UNPACK_BUFFER:
        this._state.pixelUnpackBuffer = v(this.gl, null, t9, this._state.pixelUnpackBuffer);
        break;
      case A.COPY_READ_BUFFER:
        this._state.copyReadBuffer = v(this.gl, null, t9, this._state.copyReadBuffer);
        break;
      case A.COPY_WRITE_BUFFER:
        this._state.copyWriteBuffer = v(this.gl, null, t9, this._state.copyWriteBuffer);
    }
  }
  bindVAO(t9 = null) {
    t(t9) ? this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null) : this._state.vertexArrayObject !== t9 && (t9.bind(), this._state.vertexArrayObject = t9);
  }
  async clientWaitAsync(t9 = n(10)) {
    const e4 = this.gl, s8 = e4.fenceSync(W.SYNC_GPU_COMMANDS_COMPLETE, 0);
    let i2;
    this.instanceCounter.increment(t2.Sync, s8), e4.flush();
    do {
      await L(t9), i2 = e4.clientWaitSync(s8, 0, 0);
    } while (i2 === r3.TIMEOUT_EXPIRED);
    if (this.instanceCounter.decrement(t2.Sync, s8), e4.deleteSync(s8), i2 === r3.WAIT_FAILED)
      throw new Error("Client wait failed");
  }
  getBoundFramebufferObject(t9 = n3.FRAMEBUFFER) {
    return t9 === n3.READ_FRAMEBUFFER ? this._state.readFramebuffer : this._state.drawFramebuffer;
  }
  getBoundVAO() {
    return this._state.vertexArrayObject;
  }
  resetState() {
    this.useProgram(null), this.bindVAO(null), this.bindFramebuffer(null, true), this.unbindBuffer(A.ARRAY_BUFFER), this.unbindBuffer(A.ELEMENT_ARRAY_BUFFER), n4(this.gl) && (this.unbindBuffer(A.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A.PIXEL_PACK_BUFFER), this.unbindBuffer(A.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A.COPY_READ_BUFFER), this.unbindBuffer(A.COPY_WRITE_BUFFER));
    for (let t9 = 0; t9 < this.parameters.maxTextureImageUnits; ++t9)
      this.bindTexture(null, t9);
    this.setBlendingEnabled(false), this.setBlendFunction(R.ONE, R.ZERO), this.setBlendEquation(T.ADD), this.setBlendColor(0, 0, 0, 0), this.setFaceCullingEnabled(false), this.setCullFace(N.BACK), this.setFrontFace(S.CCW), this.setPolygonOffsetFillEnabled(false), this.setPolygonOffset(0, 0), this.setScissorTestEnabled(false), this.setScissorRect(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.setDepthTestEnabled(false), this.setDepthFunction(I.LESS), this.setDepthRange(0, 1), this.setStencilTestEnabled(false), this.setStencilFunction(I.ALWAYS, 0, 0), this.setStencilOp(O.KEEP, O.KEEP, O.KEEP), this.setClearColor(0, 0, 0, 0), this.setClearDepth(1), this.setClearStencil(0), this.setColorMask(true, true, true, true), this.setStencilWriteMask(4294967295), this.setDepthWriteEnabled(true), this.setViewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
  }
  enforceState() {
    var _a, _b, _c;
    const t9 = this.gl, e4 = this.capabilities.vao;
    e4 && e4.bindVertexArray(null);
    for (let s8 = 0; s8 < this.parameters.maxVertexAttributes; s8++)
      t9.disableVertexAttribArray(s8);
    if (this._state.vertexBuffer ? t9.bindBuffer(this._state.vertexBuffer.bufferType, this._state.vertexBuffer.glName) : t9.bindBuffer(A.ARRAY_BUFFER, null), this._state.indexBuffer ? t9.bindBuffer(this._state.indexBuffer.bufferType, this._state.indexBuffer.glName) : t9.bindBuffer(A.ELEMENT_ARRAY_BUFFER, null), n4(t9)) {
      this._state.uniformBuffer ? t9.bindBuffer(this._state.uniformBuffer.bufferType, this._state.uniformBuffer.glName) : t9.bindBuffer(A.UNIFORM_BUFFER, null);
      for (let e5 = 0; e5 < this._parameters.maxUniformBufferBindings; e5++) {
        const i2 = this._state.uniformBufferBindingPoints[e5];
        if (r(i2)) {
          const { buffer: s8, offset: a2, size: r9 } = i2;
          null !== s8 ? 0 === a2 && 0 === r9 ? t9.bindBufferBase(A.UNIFORM_BUFFER, e5, s8.glName) : t9.bindBufferRange(A.UNIFORM_BUFFER, e5, s8.glName, a2, r9) : t9.bindBufferBase(A.UNIFORM_BUFFER, e5, null);
        }
      }
      this._state.pixelPackBuffer ? t9.bindBuffer(this._state.pixelPackBuffer.bufferType, this._state.pixelPackBuffer.glName) : t9.bindBuffer(A.PIXEL_PACK_BUFFER, null), this._state.pixelUnpackBuffer ? t9.bindBuffer(this._state.pixelUnpackBuffer.bufferType, this._state.pixelUnpackBuffer.glName) : t9.bindBuffer(A.PIXEL_UNPACK_BUFFER, null), this._state.copyReadBuffer ? t9.bindBuffer(this._state.copyReadBuffer.bufferType, this._state.copyReadBuffer.glName) : t9.bindBuffer(A.COPY_READ_BUFFER, null), this._state.copyWriteBuffer ? t9.bindBuffer(this._state.copyWriteBuffer.bufferType, this._state.copyWriteBuffer.glName) : t9.bindBuffer(A.COPY_WRITE_BUFFER, null), t9.bindFramebuffer(n3.READ_FRAMEBUFFER, null), t9.readBuffer(t9.BACK), this._state.readFramebuffer && (t9.bindFramebuffer(n3.READ_FRAMEBUFFER, this._state.readFramebuffer.glName), t9.readBuffer(f2.COLOR_ATTACHMENT0)), t9.bindFramebuffer(n3.DRAW_FRAMEBUFFER, ((_a = this._state.drawFramebuffer) == null ? void 0 : _a.glName) ?? null);
    } else
      this._state.readFramebuffer = this._state.drawFramebuffer, t9.bindFramebuffer(n3.FRAMEBUFFER, ((_b = this._state.drawFramebuffer) == null ? void 0 : _b.glName) ?? null);
    if (e4 && this._state.vertexArrayObject) {
      const t10 = this._state.vertexArrayObject;
      this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null), this.bindVAO(t10);
    }
    t9.useProgram(((_c = this._state.program) == null ? void 0 : _c.glName) ?? null), t9.blendColor(this._state.blendColor.r, this._state.blendColor.g, this._state.blendColor.b, this._state.blendColor.a), t9.bindRenderbuffer(t9.RENDERBUFFER, this._state.renderbuffer ? this._state.renderbuffer.glName : null), true === this._state.blend ? t9.enable(this.gl.BLEND) : t9.disable(this.gl.BLEND), t9.blendEquationSeparate(this._state.blendEquation.mode, this._state.blendEquation.modeAlpha), t9.blendFuncSeparate(this._state.blendFunction.srcRGB, this._state.blendFunction.dstRGB, this._state.blendFunction.srcAlpha, this._state.blendFunction.dstAlpha), t9.clearColor(this._state.clearColor.r, this._state.clearColor.g, this._state.clearColor.b, this._state.clearColor.a), t9.clearDepth(this._state.clearDepth), t9.clearStencil(this._state.clearStencil), t9.colorMask(this._state.colorMask.r, this._state.colorMask.g, this._state.colorMask.b, this._state.colorMask.a), t9.cullFace(this._state.cullFace), t9.depthFunc(this._state.depthFunction), t9.depthRange(this._state.depthRange.zNear, this._state.depthRange.zFar), true === this._state.depthTest ? t9.enable(t9.DEPTH_TEST) : t9.disable(t9.DEPTH_TEST), t9.depthMask(this._state.depthWrite), t9.frontFace(this._state.frontFace), t9.lineWidth(1), true === this._state.faceCulling ? t9.enable(t9.CULL_FACE) : t9.disable(t9.CULL_FACE), t9.polygonOffset(this._state.polygonOffset[0], this._state.polygonOffset[1]), true === this._state.polygonOffsetFill ? t9.enable(t9.POLYGON_OFFSET_FILL) : t9.disable(t9.POLYGON_OFFSET_FILL), t9.scissor(this._state.scissorRect.x, this._state.scissorRect.y, this._state.scissorRect.width, this._state.scissorRect.height), true === this._state.scissorTest ? t9.enable(t9.SCISSOR_TEST) : t9.disable(t9.SCISSOR_TEST), t9.stencilFunc(this._state.stencilFunction.func, this._state.stencilFunction.ref, this._state.stencilFunction.mask), t9.stencilOpSeparate(this._state.stencilOperation.face, this._state.stencilOperation.fail, this._state.stencilOperation.zFail, this._state.stencilOperation.zPass), true === this._state.stencilTest ? t9.enable(t9.STENCIL_TEST) : t9.disable(t9.STENCIL_TEST), t9.stencilMask(this._state.stencilWriteMask);
    for (let i2 = 0; i2 < this.parameters.maxTextureImageUnits; i2++) {
      t9.activeTexture(X + i2), t9.bindTexture(M.TEXTURE_2D, null), t9.bindTexture(M.TEXTURE_CUBE_MAP, null), n4(t9) && (t9.bindTexture(M.TEXTURE_3D, null), t9.bindTexture(M.TEXTURE_2D_ARRAY, null));
      const e5 = this._state.textureUnitMap[i2];
      r(e5) && t9.bindTexture(e5.descriptor.target, e5.glName);
    }
    t9.activeTexture(X + this._state.activeTexture), t9.viewport(this._state.viewport.x, this._state.viewport.y, this._state.viewport.width, this._state.viewport.height), this.resetInfo();
  }
  _loadExtensions() {
    this.type === o4.WEBGL1 && this.gl.getExtension("OES_element_index_uint"), this.gl.getExtension("KHR_parallel_shader_compile");
  }
  _loadParameters(t9) {
    const e4 = this.capabilities.textureFilterAnisotropic, s8 = t9.maxAnisotropy ?? 1 / 0, i2 = n4(this.gl), a2 = this.gl, r9 = { versionString: this.gl.getParameter(this.gl.VERSION), maxVertexTextureImageUnits: this.gl.getParameter(this.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxVertexAttributes: this.gl.getParameter(this.gl.MAX_VERTEX_ATTRIBS), maxMaxAnisotropy: e4 ? Math.min(this.gl.getParameter(e4.MAX_TEXTURE_MAX_ANISOTROPY), s8) : 1, maxTextureImageUnits: this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), maxTextureSize: this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE), maxUniformBufferBindings: i2 ? a2.getParameter(a2.MAX_UNIFORM_BUFFER_BINDINGS) : 0, maxVertexUniformBlocks: i2 ? a2.getParameter(a2.MAX_VERTEX_UNIFORM_BLOCKS) : 0, maxFragmentUniformBlocks: i2 ? a2.getParameter(a2.MAX_FRAGMENT_UNIFORM_BLOCKS) : 0, maxUniformBlockSize: i2 ? a2.getParameter(a2.MAX_UNIFORM_BLOCK_SIZE) : 0, uniformBufferOffsetAlignment: i2 ? a2.getParameter(a2.UNIFORM_BUFFER_OFFSET_ALIGNMENT) : 1, maxArrayTextureLayers: i2 ? a2.getParameter(a2.MAX_ARRAY_TEXTURE_LAYERS) : 1, maxSamples: i2 ? a2.getParameter(a2.MAX_SAMPLES) : 1 };
    return u2.TEXTURE_UNIT_FOR_UPDATES = r9.maxTextureImageUnits - 1, r9;
  }
};
function v(t9, e4, s8, i2) {
  return e4 ? i2 !== e4 && t9.bindBuffer(s8, e4.glName) : t9.bindBuffer(s8, null), e4;
}
function I2(t9, e4) {
  switch (t9) {
    case E.POINTS:
      return 2 * e4;
    case E.TRIANGLES:
      return e4 / 3;
    case E.TRIANGLE_STRIP:
    case E.TRIANGLE_FAN:
      return e4 - 2;
    default:
      return 0;
  }
}

// node_modules/@arcgis/core/views/magnifier/resources.js
async function s5(s8) {
  const r9 = import("./mask-svg-TT45E5RV.js"), i2 = import("./overlay-svg-4DR7AQD6.js"), o8 = t4((await r9).default, { signal: s8 }), e4 = t4((await i2).default, { signal: s8 }), m2 = { mask: await o8, overlay: await e4 };
  return f(s8), m2;
}

// node_modules/@arcgis/core/views/navigation/FilteredFiniteDifference.js
var t7 = class {
  constructor(t9) {
    this.gain = t9;
  }
  update(t9) {
    if (this.hasLastValue) {
      const e4 = this.computeDelta(t9);
      this._updateDelta(e4);
    }
    this.lastValue = t9;
  }
  reset() {
    this.lastValue = void 0, this.filteredDelta = void 0;
  }
  get hasLastValue() {
    return void 0 !== this.lastValue;
  }
  get hasFilteredDelta() {
    return void 0 !== this.filteredDelta;
  }
  computeDelta(t9) {
    return t9 - this.lastValue;
  }
  _updateDelta(t9) {
    this.hasFilteredDelta ? this.filteredDelta = (1 - this.gain) * this.filteredDelta + this.gain * t9 : this.filteredDelta = t9;
  }
};

// node_modules/@arcgis/core/views/navigation/Momentum.js
var t8 = class {
  constructor(t9, i2, o8) {
    this._initialVelocity = t9, this._stopVelocity = i2, this._friction = o8, this._duration = Math.abs(Math.log(Math.abs(this._initialVelocity) / this._stopVelocity) / Math.log(1 - this._friction));
  }
  get duration() {
    return this._duration;
  }
  isFinished(t9) {
    return t9 > this.duration;
  }
  get friction() {
    return this._friction;
  }
  value(t9) {
    return this.valueFromInitialVelocity(this._initialVelocity, t9);
  }
  valueDelta(t9, i2) {
    const o8 = this.value(t9);
    return this.value(t9 + i2) - o8;
  }
  valueFromInitialVelocity(t9, i2) {
    i2 = Math.min(i2, this.duration);
    const o8 = 1 - this.friction;
    return t9 * (o8 ** i2 - 1) / Math.log(o8);
  }
};

// node_modules/@arcgis/core/views/navigation/PanPlanarMomentumEstimator.js
var c3 = class extends t8 {
  constructor(e4, t9, i2, s8, n6) {
    super(e4, t9, i2), this.sceneVelocity = s8, this.direction = n6;
  }
  value(e4) {
    return super.valueFromInitialVelocity(this.sceneVelocity, e4);
  }
};
var h3 = class {
  constructor(e4 = 300, t9 = 12, i2 = 0.84) {
    this.minimumInitialVelocity = e4, this.stopVelocity = t9, this.friction = i2, this.enabled = true, this.time = new t7(0.6), this.screen = [new t7(0.4), new t7(0.4)], this.scene = [new t7(0.6), new t7(0.6), new t7(0.6)], this.tmpDirection = n2();
  }
  add(e4, t9, i2) {
    if (this.enabled) {
      if (this.time.hasLastValue) {
        if (this.time.computeDelta(i2) < 0.015)
          return;
      }
      this.screen[0].update(e4[0]), this.screen[1].update(e4[1]), this.scene[0].update(t9[0]), this.scene[1].update(t9[1]), this.scene[2].update(t9[2]), this.time.update(i2);
    }
  }
  reset() {
    this.screen[0].reset(), this.screen[1].reset(), this.scene[0].reset(), this.scene[1].reset(), this.scene[2].reset(), this.time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this.screen[0].hasFilteredDelta)
      return null;
    const e4 = this.screen[0].filteredDelta, t9 = this.screen[1].filteredDelta, i2 = Math.sqrt(e4 * e4 + t9 * t9) / this.time.filteredDelta;
    return Math.abs(i2) < this.minimumInitialVelocity ? null : this.createMomentum(i2, this.stopVelocity, this.friction);
  }
  createMomentum(s8, n6, r9) {
    o2(this.tmpDirection, this.scene[0].filteredDelta, this.scene[1].filteredDelta, this.scene[2].filteredDelta);
    const h4 = s2(this.tmpDirection);
    h4 > 0 && q(this.tmpDirection, this.tmpDirection, 1 / h4);
    const l2 = h4 / this.time.filteredDelta;
    return new c3(s8, n6, r9, l2, this.tmpDirection);
  }
};

// node_modules/@arcgis/core/views/navigation/MomentumEstimator.js
var s6 = class {
  constructor(t9 = 2.5, i2 = 0.01, s8 = 0.95, l2 = 12) {
    this.minimumInitialVelocity = t9, this.stopVelocity = i2, this.friction = s8, this.maxVelocity = l2, this.enabled = true, this.value = new t7(0.8), this.time = new t7(0.3);
  }
  add(t9, e4) {
    if (this.enabled) {
      if (this.time.hasLastValue) {
        if (this.time.computeDelta(e4) < 0.01)
          return;
        if (this.value.hasFilteredDelta) {
          const e5 = this.value.computeDelta(t9);
          this.value.filteredDelta * e5 < 0 && this.value.reset();
        }
      }
      this.time.update(e4), this.value.update(t9);
    }
  }
  reset() {
    this.value.reset(), this.time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this.value.hasFilteredDelta)
      return null;
    let e4 = this.value.filteredDelta / this.time.filteredDelta;
    return e4 = o3(e4, -this.maxVelocity, this.maxVelocity), Math.abs(e4) < this.minimumInitialVelocity ? null : this.createMomentum(e4, this.stopVelocity, this.friction);
  }
  createMomentum(t9, e4, s8) {
    return new t8(t9, e4, s8);
  }
};

// node_modules/@arcgis/core/views/navigation/RotationMomentumEstimator.js
var a = class extends s6 {
  constructor(t9 = 3, a2 = 0.01, s8 = 0.95, e4 = 12) {
    super(t9, a2, s8, e4);
  }
  add(t9, a2) {
    if (this.value.hasLastValue) {
      const a3 = this.value.lastValue;
      let s8 = t9 - a3;
      for (; s8 > Math.PI; )
        s8 -= 2 * Math.PI;
      for (; s8 < -Math.PI; )
        s8 += 2 * Math.PI;
      t9 = a3 + s8;
    }
    super.add(t9, a2);
  }
};

// node_modules/@arcgis/core/views/navigation/ZoomMomentumEstimator.js
var r8 = class extends t8 {
  constructor(e4, t9, r9) {
    super(e4, t9, r9);
  }
  value(e4) {
    const t9 = super.value(e4);
    return Math.exp(t9);
  }
  valueDelta(e4, t9) {
    const r9 = super.value(e4), s8 = super.value(e4 + t9) - r9;
    return Math.exp(s8);
  }
};
var s7 = class extends s6 {
  constructor(e4 = 2.5, t9 = 0.01, r9 = 0.95, s8 = 12) {
    super(e4, t9, r9, s8);
  }
  add(e4, t9) {
    super.add(Math.log(e4), t9);
  }
  createMomentum(e4, t9, s8) {
    return new r8(e4, t9, s8);
  }
};

export {
  t6 as t,
  y,
  t7 as t2,
  t8 as t3,
  h3 as h,
  a,
  s7 as s,
  s5 as s2
};
//# sourceMappingURL=chunk-QYVYSUKX.js.map
