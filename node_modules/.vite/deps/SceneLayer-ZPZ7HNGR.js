import {
  w as w2
} from "./chunk-7Y6VVOP3.js";
import {
  l as l5
} from "./chunk-E6HTI5QN.js";
import {
  t as t6
} from "./chunk-EY24INV2.js";
import {
  l as l4,
  m as m4,
  s as s3,
  u as u3
} from "./chunk-3DTDACBY.js";
import {
  A,
  K
} from "./chunk-G4NYIT2C.js";
import "./chunk-ZG7SHSSS.js";
import "./chunk-CNBLQ5VM.js";
import "./chunk-WRJQ7542.js";
import "./chunk-QFYBIFWB.js";
import "./chunk-PNUWGOXY.js";
import {
  An,
  Wn
} from "./chunk-PZWU5EHT.js";
import "./chunk-7LOJJ46D.js";
import "./chunk-VNR743PA.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-SWCA522B.js";
import {
  p2 as p3,
  r as r4,
  t as t5
} from "./chunk-YPIBZ3CH.js";
import "./chunk-XLCZFN6R.js";
import "./chunk-OMNBM2E4.js";
import {
  l as l3
} from "./chunk-WKHS6QIX.js";
import "./chunk-6O7ZZEV7.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-OBCAVCXI.js";
import {
  t as t3
} from "./chunk-RFOZTYJH.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-L2YBXQTH.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-4XBERLPX.js";
import {
  p as p4
} from "./chunk-SZPDY7KN.js";
import {
  i as i2
} from "./chunk-Y6YGVGFR.js";
import {
  p as p2
} from "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import {
  j as j3
} from "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import "./chunk-MZX3HN4G.js";
import {
  d as d4
} from "./chunk-T47JAOQZ.js";
import "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import {
  d as d2
} from "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-RIWDMEW4.js";
import {
  n as n2
} from "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  v as v2
} from "./chunk-OG6CQEZJ.js";
import {
  c as c2
} from "./chunk-X5Z3DJQ4.js";
import {
  O
} from "./chunk-BUWXVMJU.js";
import {
  c,
  d as d3,
  l as l2,
  m as m3,
  p
} from "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import "./chunk-D3XXPCBB.js";
import {
  t as t4
} from "./chunk-OWBMOIIV.js";
import {
  b as b2
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  a,
  j as j2
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import {
  B
} from "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import {
  r as r3
} from "./chunk-ACJD5XFJ.js";
import {
  i
} from "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import {
  c as c3
} from "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import {
  U as U2
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  G
} from "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import {
  l,
  u2 as u
} from "./chunk-ICD7AJSY.js";
import {
  d,
  e as e2,
  n8 as n,
  r2,
  t6 as t2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  g,
  w
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m as m2
} from "./chunk-G5JBUC5N.js";
import {
  m,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/support/RangeInfo.js
var s4 = class extends l {
  constructor() {
    super(...arguments), this.name = null, this.field = null, this.currentRangeExtent = null, this.fullRangeExtent = null, this.type = "rangeInfo";
  }
};
e([d({ type: String, json: { read: true, write: true } })], s4.prototype, "name", void 0), e([d({ type: String, json: { read: true, write: true } })], s4.prototype, "field", void 0), e([d({ type: [Number], json: { read: true, write: true } })], s4.prototype, "currentRangeExtent", void 0), e([d({ type: [Number], json: { read: true, write: true } })], s4.prototype, "fullRangeExtent", void 0), e([d({ type: ["rangeInfo"], readOnly: true, json: { read: false, write: true } })], s4.prototype, "type", void 0), s4 = e([n("esri.layers.support.RangeInfo")], s4);

// node_modules/@arcgis/core/layers/support/PolygonCollection.js
var c4;
var p5 = c4 = class extends u(j.ofType(v)) {
  constructor(e3) {
    super(e3);
  }
  clone() {
    return new c4(this.items.map((e3) => e3.clone()));
  }
  write(e3, r5) {
    return this.toJSON(r5);
  }
  toJSON(e3) {
    var _a;
    const r5 = (_a = e3 == null ? void 0 : e3.layer) == null ? void 0 : _a.spatialReference;
    return r5 ? this.toArray().map((t7) => {
      if (!r5.equals(t7.spatialReference)) {
        if (!An(t7.spatialReference, r5))
          return e3 && e3.messages && e3.messages.push(new t2("scenefilter:unsupported", "Scene filters with incompatible spatial references are not supported", { modification: this, spatialReference: e3.layer.spatialReference, context: e3 })), null;
        const s6 = new v();
        Wn(t7, s6, r5), t7 = s6;
      }
      const s5 = t7.toJSON(e3);
      return delete s5.spatialReference, s5;
    }).filter((e4) => null != e4) : ((e3 == null ? void 0 : e3.messages) && e3.messages.push(new t2("scenefilter:unsupported", "Writing Scene filters without context layer is not supported", { modification: this, spatialReference: e3.layer.spatialReference, context: e3 })), this.toArray().map((r6) => r6.toJSON(e3)));
  }
  static fromJSON(e3, r5) {
    const t7 = new c4();
    return e3.forEach((e4) => t7.add(v.fromJSON(e4, r5))), t7;
  }
};
p5 = c4 = e([n("esri.layers.support.PolygonCollection")], p5);
var l6 = p5;

// node_modules/@arcgis/core/layers/support/SceneFilter.js
var g2;
var f = g2 = class extends l {
  constructor(e3) {
    super(e3), this.spatialRelationship = "disjoint", this.geometries = new l6(), this._geometriesSource = null, this._handles = new u2();
  }
  initialize() {
    this._handles.add(a(() => this.geometries, "after-changes", () => this.geometries = this.geometries, U));
  }
  destroy() {
    this._handles.destroy();
  }
  readGeometries(e3, o2, r5) {
    this._geometriesSource = { url: i(e3, r5), context: r5 };
  }
  async loadGeometries(e3, r5) {
    if (t(this._geometriesSource))
      return;
    const { url: s5, context: t7 } = this._geometriesSource, p6 = await U2(s5, { responseType: "json", signal: m(r5, "signal") }), n3 = e3.toJSON(), c5 = p6.data.map((e4) => ({ ...e4, spatialReference: n3 }));
    this.geometries = l6.fromJSON(c5, t7), this._geometriesSource = null;
  }
  clone() {
    return new g2({ geometries: m2(this.geometries), spatialRelationship: this.spatialRelationship });
  }
};
e([d({ type: ["disjoint", "contains"], nonNullable: true, json: { write: true } })], f.prototype, "spatialRelationship", void 0), e([d({ type: l6, nonNullable: true, json: { write: true } }), w2({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries" })], f.prototype, "geometries", void 0), e([o(["web-scene", "portal-item"], "geometries")], f.prototype, "readGeometries", null), f = g2 = e([n("esri.layers.support.SceneFilter")], f);
var j4 = f;

// node_modules/@arcgis/core/layers/SceneLayer.js
var X = ["3DObject", "Point"];
var Y = s.getLogger("esri.layers.SceneLayer");
var ee = l3();
var te = class extends A(p2(c2(v2(t4(O(i2(b2))))))) {
  constructor(...e3) {
    super(...e3), this.featureReduction = null, this.rangeInfos = null, this.operationalLayerType = "ArcGISSceneServiceLayer", this.type = "scene", this.fields = null, this.floorInfo = null, this.outFields = null, this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.excludeObjectIds = new j(), this.definitionExpression = null, this.filter = null, this.path = null, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.priority = null, this.semantic = null, this.cachedDrawingInfo = { color: false }, this.popupEnabled = true, this.popupTemplate = null, this.objectIdField = null, this.globalIdField = null, this._fieldUsageInfo = {}, this.screenSizePerspectiveEnabled = true;
  }
  normalizeCtorArgs(e3, t7) {
    return "string" == typeof e3 ? { url: e3, ...t7 } : e3;
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFieldDomain(e3, t7) {
    var _a, _b, _c;
    const r5 = (_b = (_a = this.getFeatureType(t7 == null ? void 0 : t7.feature)) == null ? void 0 : _a.domains) == null ? void 0 : _b[e3];
    return r5 && "inherited" !== r5.type ? r5 : ((_c = this.getField(e3)) == null ? void 0 : _c.domain) ?? null;
  }
  getFeatureType(e3) {
    return e3 && r(this.associatedLayer) ? this.associatedLayer.getFeatureType(e3) : null;
  }
  get types() {
    return r(this.associatedLayer) ? this.associatedLayer.types : [];
  }
  get typeIdField() {
    return r(this.associatedLayer) ? this.associatedLayer.typeIdField : null;
  }
  get formTemplate() {
    return r(this.associatedLayer) ? this.associatedLayer.formTemplate : null;
  }
  get fieldsIndex() {
    return new d2(this.fields);
  }
  readNodePages(e3, t7, r5) {
    return "Point" === t7.layerType && (e3 = t7.pointNodePages), null == e3 || "object" != typeof e3 ? null : s3.fromJSON(e3, r5);
  }
  set elevationInfo(e3) {
    this._set("elevationInfo", e3), this.loaded && this._validateElevationInfo();
  }
  get geometryType() {
    return ie[this.profile] || "mesh";
  }
  set renderer(e3) {
    c3(e3, this.fieldsIndex), this._set("renderer", e3);
  }
  readCachedDrawingInfo(e3) {
    return null != e3 && "object" == typeof e3 || (e3 = {}), null == e3.color && (e3.color = false), e3;
  }
  get capabilities() {
    const e3 = r(this.associatedLayer) && this.associatedLayer.capabilities ? this.associatedLayer.capabilities : t6, { query: t7, editing: { supportsGlobalId: r5, supportsRollbackOnFailure: i3, supportsUploadWithItemId: s5, supportsReturnServiceEditsInSourceSpatialReference: o2 }, data: { supportsZ: a2, supportsM: p6, isVersioned: l7, supportsAttachment: d5 }, operations: { supportsEditing: y, supportsUpdate: u4, supportsQuery: c5, supportsQueryAttachments: f2 } } = e3, h = e3.operations.supportsChangeTracking;
    return { query: t7, editing: { supportsGlobalId: r5, supportsReturnServiceEditsInSourceSpatialReference: o2, supportsRollbackOnFailure: i3, supportsGeometryUpdate: false, supportsUploadWithItemId: s5 }, data: { supportsAttachment: d5, supportsZ: a2, supportsM: p6, isVersioned: l7 }, operations: { supportsQuery: c5, supportsQueryAttachments: f2, supportsEditing: y && h, supportsAdd: false, supportsDelete: false, supportsUpdate: u4 && h } };
  }
  get editingEnabled() {
    return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this.userHasEditingPrivileges;
  }
  set editingEnabled(e3) {
    null != e3 ? this._override("editingEnabled", e3) : this._clearOverride("editingEnabled");
  }
  get defaultPopupTemplate() {
    return r(this.associatedLayer) || this.attributeStorageInfo ? this.createPopupTemplate() : null;
  }
  readObjectIdField(e3, t7) {
    return !e3 && t7.fields && t7.fields.some((t8) => ("esriFieldTypeOID" === t8.type && (e3 = t8.name), !!e3)), e3 || void 0;
  }
  readGlobalIdField(e3, t7) {
    return !e3 && t7.fields && t7.fields.some((t8) => ("esriFieldTypeGlobalID" === t8.type && (e3 = t8.name), !!e3)), e3 || void 0;
  }
  get displayField() {
    return r(this.associatedLayer) ? this.associatedLayer.displayField : null;
  }
  readProfile(e3, t7) {
    const r5 = t7.store.profile;
    return null != r5 && re[r5] ? re[r5] : (Y.error("Unknown or missing profile", { profile: r5, layer: this }), "mesh-pyramids");
  }
  load(e3) {
    const t7 = r(e3) ? e3.signal : null, r5 = this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e3).catch(w).then(() => this._fetchService(t7)).then(() => Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, t7), this._setAssociatedFeatureLayer(t7), r(this.filter) ? this.filter.loadGeometries(this.spatialReference) : null])).then(() => this._validateElevationInfo()).then(() => this._applyAssociatedLayerOverrides()).then(() => this._populateFieldUsageInfo()).then(() => t3(this, { origin: "service" }, t7)).then(() => c3(this.renderer, this.fieldsIndex)).then(() => this.finishLoadEditablePortalLayer(e3));
    return this.addResolvingPromise(r5), Promise.resolve(this);
  }
  async beforeSave() {
    r(this.filter) && await this.load();
  }
  createQuery() {
    const e3 = new b();
    return "mesh" !== this.geometryType && (e3.returnGeometry = true, e3.returnZ = true), e3.where = this.definitionExpression || "1=1", e3.sqlFormat = "standard", e3;
  }
  queryExtent(e3, t7) {
    return this._getAssociatedLayerForQuery().then((r5) => r5.queryExtent(e3 || this.createQuery(), t7));
  }
  queryFeatureCount(e3, t7) {
    return this._getAssociatedLayerForQuery().then((r5) => r5.queryFeatureCount(e3 || this.createQuery(), t7));
  }
  queryFeatures(e3, t7) {
    return this._getAssociatedLayerForQuery().then((r5) => r5.queryFeatures(e3 || this.createQuery(), t7)).then((e4) => {
      if (e4 == null ? void 0 : e4.features)
        for (const t8 of e4.features)
          t8.layer = this, t8.sourceLayer = this;
      return e4;
    });
  }
  queryObjectIds(e3, t7) {
    return this._getAssociatedLayerForQuery().then((r5) => r5.queryObjectIds(e3 || this.createQuery(), t7));
  }
  queryAttachments(e3, t7) {
    return this._getAssociatedLayerForQuery().then((r5) => r5.queryAttachments(e3, t7));
  }
  getFieldUsageInfo(e3) {
    const t7 = { supportsLabelingInfo: false, supportsRenderer: false, supportsPopupTemplate: false, supportsLayerQuery: false };
    return this.loaded ? this._fieldUsageInfo[e3] || t7 : (Y.error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), t7);
  }
  createPopupTemplate(e3) {
    return d4(this, e3);
  }
  _getAssociatedLayerForQuery() {
    const e3 = this.associatedLayer;
    return r(e3) && e3.loaded ? Promise.resolve(e3) : this._loadAssociatedLayerForQuery();
  }
  async _loadAssociatedLayerForQuery() {
    if (await this.load(), t(this.associatedLayer))
      throw new s2("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    try {
      await this.associatedLayer.load();
    } catch (e3) {
      throw new s2("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded", { layer: this, error: e3 });
    }
    return this.associatedLayer;
  }
  hasCachedStatistics(e3) {
    return null != this.statisticsInfo && this.statisticsInfo.some((t7) => t7.name === e3);
  }
  async queryCachedStatistics(e3, t7) {
    if (await this.load(t7), !this.statisticsInfo)
      throw new s2("scenelayer:no-cached-statistics", "Cached statistics are not available for this layer");
    const r5 = this.fieldsIndex.get(e3);
    if (!r5)
      throw new s2("scenelayer:field-unexisting", `Field '${e3}' does not exist on the layer`);
    for (const s5 of this.statisticsInfo)
      if (s5.name === r5.name) {
        const e4 = G(this.parsedUrl.path, s5.href);
        return U2(e4, { query: { f: "json", token: this.apiKey }, responseType: "json", signal: t7 ? t7.signal : null }).then((e5) => e5.data);
      }
    throw new s2("scenelayer:no-cached-statistics", "Cached statistics for this attribute are not available");
  }
  async saveAs(e3, t7) {
    return this._debouncedSaveOperations(K.SAVE_AS, { ...t7, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }, e3);
  }
  async save() {
    const e3 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" };
    return this._debouncedSaveOperations(K.SAVE, e3);
  }
  async applyEdits(e3, t7) {
    const r5 = await import("./editingSupport-ZEPOY3EL.js");
    if (await this.load(), t(this.associatedLayer))
      throw new s2(`${this.type}-layer:not-editable`, "Service is not editable");
    return await this.associatedLayer.load(), r5.applyEdits(this, this.associatedLayer.source, e3, t7);
  }
  on(e3, t7) {
    return super.on(e3, t7);
  }
  validateLayer(e3) {
    if (e3.layerType && !X.includes(e3.layerType))
      throw new s2("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type", { layerType: e3.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor))
      throw new s2("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    if (this.version.major > 2)
      throw new s2("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    function t7(e4, t8) {
      let r5 = false, i3 = false;
      if (null == e4)
        r5 = true, i3 = true;
      else {
        const s5 = t8 && t8.isGeographic;
        switch (e4) {
          case "east-north-up":
          case "earth-centered":
            r5 = true, i3 = s5;
            break;
          case "vertex-reference-frame":
            r5 = true, i3 = !s5;
            break;
          default:
            r5 = false;
        }
      }
      if (!r5)
        throw new s2("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid.");
      if (!i3)
        throw new s2("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
    }
    t7(this.normalReferenceFrame, this.spatialReference);
  }
  _getTypeKeywords() {
    const e3 = [];
    if ("points" === this.profile)
      e3.push("Point");
    else {
      if ("mesh-pyramids" !== this.profile)
        throw new s2("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile);
      e3.push("3DObject");
    }
    return e3;
  }
  _populateFieldUsageInfo() {
    if (this._fieldUsageInfo = {}, this.fields)
      for (const e3 of this.fields) {
        const t7 = !(!this.attributeStorageInfo || !this.attributeStorageInfo.some((t8) => t8.name === e3.name)), r5 = !!(r(this.associatedLayer) && this.associatedLayer.fields && this.associatedLayer.fields.some((t8) => t8 && e3.name === t8.name)), i3 = { supportsLabelingInfo: t7, supportsRenderer: t7, supportsPopupTemplate: t7 || r5, supportsLayerQuery: r5 };
        this._fieldUsageInfo[e3.name] = i3;
      }
  }
  _applyAssociatedLayerOverrides() {
    this._applyAssociatedLayerFieldsOverrides(), this._applyAssociatedLayerPopupOverrides();
  }
  _applyAssociatedLayerFieldsOverrides() {
    if (t(this.associatedLayer) || !this.associatedLayer.fields)
      return;
    let e3 = null;
    for (const t7 of this.associatedLayer.fields) {
      const r5 = this.getField(t7.name);
      r5 ? (!r5.domain && t7.domain && (r5.domain = t7.domain.clone()), r5.editable = t7.editable, r5.nullable = t7.nullable, r5.length = t7.length) : (e3 || (e3 = this.fields ? this.fields.slice() : []), e3.push(t7.clone()));
    }
    e3 && this._set("fields", e3);
  }
  _applyAssociatedLayerPopupOverrides() {
    if (t(this.associatedLayer))
      return;
    const e3 = ["popupTemplate", "popupEnabled"], t7 = e2(this);
    for (let r5 = 0; r5 < e3.length; r5++) {
      const i3 = e3[r5], s5 = this.originIdOf(i3), o2 = this.associatedLayer.originIdOf(i3);
      s5 < o2 && (o2 === r2.SERVICE || o2 === r2.PORTAL_ITEM) && t7.setAtOrigin(i3, this.associatedLayer[i3], o2);
    }
  }
  async _setAssociatedFeatureLayer(e3) {
    if (!["mesh-pyramids", "points"].includes(this.profile))
      return;
    const t7 = new l5(this.parsedUrl, this.portalItem, this.apiKey, e3);
    try {
      this.associatedLayer = await t7.fetch();
    } catch (r5) {
      g(r5) || this._logWarningOnPopupEnabled();
    }
  }
  async _logWarningOnPopupEnabled() {
    await j2(() => this.popupEnabled && null != this.popupTemplate);
    const e3 = `this SceneLayer: ${this.title}`;
    null == this.attributeStorageInfo ? Y.warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${e3}`) : Y.info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${e3}`);
  }
  _validateElevationInfo() {
    const e3 = this.elevationInfo;
    e3 && ("mesh-pyramids" === this.profile && "relative-to-scene" === e3.mode && Y.warn(".elevationInfo=", "Mesh scene layers don't support relative-to-scene elevation mode"), e3.featureExpressionInfo && "0" !== e3.featureExpressionInfo.expression && Y.warn(".elevationInfo=", "Scene layers do not support featureExpressionInfo"));
  }
};
e([d({ types: { key: "type", base: t5, typeMap: { selection: p3 } }, json: { origins: { "web-scene": { name: "layerDefinition.featureReduction", write: true }, "portal-item": { name: "layerDefinition.featureReduction", write: true } } } })], te.prototype, "featureReduction", void 0), e([d({ type: [s4], json: { read: false, origins: { "web-scene": { name: "layerDefinition.rangeInfos", write: true }, "portal-item": { name: "layerDefinition.rangeInfos", write: true } } } })], te.prototype, "rangeInfos", void 0), e([d({ json: { read: false } })], te.prototype, "associatedLayer", void 0), e([d({ type: ["show", "hide"] })], te.prototype, "listMode", void 0), e([d({ type: ["ArcGISSceneServiceLayer"] })], te.prototype, "operationalLayerType", void 0), e([d({ json: { read: false }, readOnly: true })], te.prototype, "type", void 0), e([d({ ...ee.fields, readOnly: true, json: { read: false, origins: { service: { read: true } } } })], te.prototype, "fields", void 0), e([d()], te.prototype, "types", null), e([d()], te.prototype, "typeIdField", null), e([d()], te.prototype, "formTemplate", null), e([d({ readOnly: true })], te.prototype, "fieldsIndex", null), e([d({ type: p4, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], te.prototype, "floorInfo", void 0), e([d(ee.outFields)], te.prototype, "outFields", void 0), e([d({ type: s3, readOnly: true, json: { read: false } })], te.prototype, "nodePages", void 0), e([o("service", "nodePages", ["nodePages", "pointNodePages"])], te.prototype, "readNodePages", null), e([d({ type: [l4], readOnly: true })], te.prototype, "materialDefinitions", void 0), e([d({ type: [u3], readOnly: true })], te.prototype, "textureSetDefinitions", void 0), e([d({ type: [m4], readOnly: true })], te.prototype, "geometryDefinitions", void 0), e([d({ readOnly: true })], te.prototype, "serviceUpdateTimeStamp", void 0), e([d({ readOnly: true })], te.prototype, "attributeStorageInfo", void 0), e([d({ readOnly: true })], te.prototype, "statisticsInfo", void 0), e([d({ type: j.ofType(Number), nonNullable: true, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.excludeObjectIds", write: { enabled: true } } })], te.prototype, "excludeObjectIds", void 0), e([d({ type: String, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], te.prototype, "definitionExpression", void 0), e([d({ type: j4, json: { name: "layerDefinition.polygonFilter", write: true } })], te.prototype, "filter", void 0), e([d({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], te.prototype, "path", void 0), e([d(d3)], te.prototype, "elevationInfo", null), e([d({ type: String })], te.prototype, "geometryType", null), e([d(m3)], te.prototype, "labelsVisible", void 0), e([d({ type: [j3], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: { reader: r4 }, write: false } }, name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: r4 }, write: true } })], te.prototype, "labelingInfo", void 0), e([d(c)], te.prototype, "legendEnabled", void 0), e([d({ type: Number, json: { origins: { "web-document": { default: 1, write: { enabled: true, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } }, read: { source: ["opacity", "layerDefinition.drawingInfo.transparency"], reader(e3, t7) {
  var _a, _b;
  if ("number" == typeof e3 && e3 >= 0 && e3 <= 1)
    return e3;
  const r5 = (_b = (_a = t7.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.transparency;
  return void 0 !== r5 ? r3(r5) : void 0;
} } }, "portal-item": { write: true }, service: { read: false } } } })], te.prototype, "opacity", void 0), e([d({ type: ["Low", "High"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], te.prototype, "priority", void 0), e([d({ type: ["Labels"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], te.prototype, "semantic", void 0), e([d({ types: n2, json: { origins: { service: { read: { source: "drawingInfo.renderer" } } }, name: "layerDefinition.drawingInfo.renderer", write: true }, value: null })], te.prototype, "renderer", null), e([d({ json: { read: false } })], te.prototype, "cachedDrawingInfo", void 0), e([o("service", "cachedDrawingInfo")], te.prototype, "readCachedDrawingInfo", null), e([d({ readOnly: true, json: { read: false } })], te.prototype, "capabilities", null), e([d({ type: Boolean, json: { read: false } })], te.prototype, "editingEnabled", null), e([d(p)], te.prototype, "popupEnabled", void 0), e([d({ type: B, json: { name: "popupInfo", write: true } })], te.prototype, "popupTemplate", void 0), e([d({ readOnly: true, json: { read: false } })], te.prototype, "defaultPopupTemplate", null), e([d({ type: String, json: { read: false } })], te.prototype, "objectIdField", void 0), e([o("service", "objectIdField", ["objectIdField", "fields"])], te.prototype, "readObjectIdField", null), e([d({ type: String, json: { read: false } })], te.prototype, "globalIdField", void 0), e([o("service", "globalIdField", ["globalIdField", "fields"])], te.prototype, "readGlobalIdField", null), e([d({ readOnly: true, type: String, json: { read: false } })], te.prototype, "displayField", null), e([d({ type: String, json: { read: false } })], te.prototype, "profile", void 0), e([o("service", "profile", ["store.profile"])], te.prototype, "readProfile", null), e([d({ readOnly: true, type: String, json: { origins: { service: { read: { source: "store.normalReferenceFrame" } } }, read: false } })], te.prototype, "normalReferenceFrame", void 0), e([d(l2)], te.prototype, "screenSizePerspectiveEnabled", void 0), te = e([n("esri.layers.SceneLayer")], te);
var re = { "mesh-pyramids": "mesh-pyramids", meshpyramids: "mesh-pyramids", "features-meshes": "mesh-pyramids", points: "points", "features-points": "points", lines: "lines", "features-lines": "lines", polygons: "polygons", "features-polygons": "polygons" };
var ie = { "mesh-pyramids": "mesh", points: "point", lines: "polyline", polygons: "polygon" };
var se = te;
export {
  se as default
};
//# sourceMappingURL=SceneLayer-ZPZ7HNGR.js.map
