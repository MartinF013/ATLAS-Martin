import {
  h3 as h,
  h4 as h2
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j,
  p
} from "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  r
} from "./chunk-ZIHDQYKE.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  m
} from "./chunk-G5JBUC5N.js";

// node_modules/@arcgis/core/geometry/Multipoint.js
var h3;
function l(t) {
  return (s, e2) => null == s ? e2 : null == e2 ? s : t(s, e2);
}
function c(t) {
  return t && ("esri.geometry.SpatialReference" === t.declaredClass || null != t.wkid);
}
var u = h3 = class extends p {
  constructor(...t) {
    super(...t), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t, s) {
    if (!t && !s)
      return null;
    const e2 = {};
    Array.isArray(t) ? (e2.points = t, e2.spatialReference = s) : c(t) ? e2.spatialReference = t : (t.points && (e2.points = t.points), t.spatialReference && (e2.spatialReference = t.spatialReference), t.hasZ && (e2.hasZ = t.hasZ), t.hasM && (e2.hasM = t.hasM));
    const i = e2.points && e2.points[0];
    return i && (void 0 === e2.hasZ && void 0 === e2.hasM ? (e2.hasZ = i.length > 2, e2.hasM = false) : void 0 === e2.hasZ ? e2.hasZ = i.length > 3 : void 0 === e2.hasM && (e2.hasM = i.length > 3)), e2;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t = this.points;
    if (!t.length)
      return null;
    const s = new M(), e2 = this.hasZ, i = this.hasM, r2 = e2 ? 3 : 2, o = t[0], a = l(Math.min), p2 = l(Math.max);
    let h4, c3, u3, m4, [f2, y] = o, [d2, g] = o;
    for (let n2 = 0, l2 = t.length; n2 < l2; n2++) {
      const s2 = t[n2], [o2, l3] = s2;
      if (f2 = a(f2, o2), y = a(y, l3), d2 = p2(d2, o2), g = p2(g, l3), e2 && s2.length > 2) {
        const t2 = s2[2];
        h4 = a(h4, t2), u3 = p2(u3, t2);
      }
      if (i && s2.length > r2) {
        const t2 = s2[r2];
        c3 = a(c3, t2), m4 = p2(m4, t2);
      }
    }
    return s.xmin = f2, s.ymin = y, s.xmax = d2, s.ymax = g, s.spatialReference = this.spatialReference, e2 ? (s.zmin = h4, s.zmax = u3) : (s.zmin = null, s.zmax = null), i ? (s.mmin = c3, s.mmax = m4) : (s.mmin = null, s.mmax = null), s;
  }
  writePoints(t, e2) {
    e2.points = m(this.points);
  }
  addPoint(t) {
    return h2(this, t), Array.isArray(t) ? this.points.push(t) : this.points.push(t.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t = { points: m(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t.hasZ = true), this.hasM && (t.hasM = true), new h3(t);
  }
  getPoint(t) {
    if (!this._validateInputs(t))
      return null;
    const s = this.points[t], e2 = { x: s[0], y: s[1], spatialReference: this.spatialReference };
    let i = 2;
    return this.hasZ && (e2.z = s[2], i = 3), this.hasM && (e2.m = s[i]), new j(e2);
  }
  removePoint(t) {
    if (!this._validateInputs(t))
      return null;
    const s = new j(this.points.splice(t, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s;
  }
  setPoint(t, s) {
    return this._validateInputs(t) ? (h2(this, s), Array.isArray(s) || (s = s.toArray()), this.points[t] = s, this.notifyChange("points"), this) : this;
  }
  toJSON(t) {
    return this.write({}, t);
  }
  _validateInputs(t) {
    return null != t && t >= 0 && t < this.points.length;
  }
};
e([d({ readOnly: true })], u.prototype, "cache", null), e([d()], u.prototype, "extent", null), e([d({ type: [[Number]], json: { write: { isRequired: true } } })], u.prototype, "points", void 0), e([r("points")], u.prototype, "writePoints", null), u = h3 = e([n("esri.geometry.Multipoint")], u), u.prototype.toJSON.isDefaultToJSON = true;
var m2 = u;

// node_modules/@arcgis/core/geometry/Polyline.js
var c2;
function u2(t) {
  return !Array.isArray(t[0]);
}
var f = c2 = class extends p {
  constructor(...t) {
    super(...t), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(t, e2) {
    let s, r2, i = null, a = null;
    return t && !Array.isArray(t) ? (i = t.paths ? t.paths : null, e2 || (t.spatialReference ? e2 = t.spatialReference : t.paths || (e2 = t)), s = t.hasZ, r2 = t.hasM) : i = t, i = i || [], e2 = e2 || k.WGS84, i.length && i[0] && null != i[0][0] && "number" == typeof i[0][0] && (i = [i]), a = i[0] && i[0][0], a && (void 0 === s && void 0 === r2 ? (s = a.length > 2, r2 = false) : void 0 === s ? s = !r2 && a.length > 3 : void 0 === r2 && (r2 = !s && a.length > 3)), { paths: i, spatialReference: e2, hasZ: s, hasM: r2 };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: t } = this, e2 = h(this);
    if (!e2)
      return null;
    const s = new M(e2);
    return s.spatialReference = t, s;
  }
  writePaths(t, s) {
    s.paths = m(this.paths);
  }
  addPath(t) {
    if (!t)
      return;
    const e2 = this.paths, s = e2.length;
    if (u2(t)) {
      const r2 = [];
      for (let e3 = 0, s2 = t.length; e3 < s2; e3++)
        r2[e3] = t[e3].toArray();
      e2[s] = r2;
    } else
      e2[s] = t.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t = new c2();
    return t.spatialReference = this.spatialReference, t.paths = m(this.paths), t.hasZ = this.hasZ, t.hasM = this.hasM, t;
  }
  getPoint(t, e2) {
    if (!this._validateInputs(t, e2))
      return null;
    const s = this.paths[t][e2], r2 = this.hasZ, i = this.hasM;
    return r2 && !i ? new j(s[0], s[1], s[2], void 0, this.spatialReference) : i && !r2 ? new j(s[0], s[1], void 0, s[2], this.spatialReference) : r2 && i ? new j(s[0], s[1], s[2], s[3], this.spatialReference) : new j(s[0], s[1], this.spatialReference);
  }
  insertPoint(t, e2, s) {
    return this._validateInputs(t, e2, true) ? (h2(this, s), Array.isArray(s) || (s = s.toArray()), this.paths[t].splice(e2, 0, s), this.notifyChange("paths"), this) : this;
  }
  removePath(t) {
    if (!this._validateInputs(t, null))
      return null;
    const e2 = this.paths.splice(t, 1)[0], s = this.spatialReference, r2 = e2.map((t2) => new j(t2, s));
    return this.notifyChange("paths"), r2;
  }
  removePoint(t, e2) {
    if (!this._validateInputs(t, e2))
      return null;
    const s = new j(this.paths[t].splice(e2, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), s;
  }
  setPoint(t, e2, s) {
    return this._validateInputs(t, e2) ? (h2(this, s), Array.isArray(s) || (s = s.toArray()), this.paths[t][e2] = s, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t, e2, s = false) {
    if (null == t || t < 0 || t >= this.paths.length)
      return false;
    if (null != e2) {
      const r2 = this.paths[t];
      if (s && (e2 < 0 || e2 > r2.length))
        return false;
      if (!s && (e2 < 0 || e2 >= r2.length))
        return false;
    }
    return true;
  }
  toJSON(t) {
    return this.write({}, t);
  }
};
e([d({ readOnly: true })], f.prototype, "cache", null), e([d({ readOnly: true })], f.prototype, "extent", null), e([d({ type: [[[Number]]], json: { write: { isRequired: true } } })], f.prototype, "paths", void 0), e([r("paths")], f.prototype, "writePaths", null), f = c2 = e([n("esri.geometry.Polyline")], f), f.prototype.toJSON.isDefaultToJSON = true;
var m3 = f;

export {
  m2 as m,
  m3 as m2
};
//# sourceMappingURL=chunk-CHNDTVQJ.js.map
