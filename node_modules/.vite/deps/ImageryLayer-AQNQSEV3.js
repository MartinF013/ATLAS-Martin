import {
  B,
  V,
  f as f3,
  i as i2,
  i2 as i3,
  i3 as i4,
  k as k2,
  l as l3,
  m2 as m3,
  n as n5,
  n2 as n6,
  o as o6,
  p as p3,
  te,
  u as u3
} from "./chunk-4ENPO4FB.js";
import {
  P,
  R,
  S as S2,
  U as U2,
  _,
  f as f2,
  h,
  l as l4,
  p as p4
} from "./chunk-3SB6OSK7.js";
import {
  u as u2,
  u2 as u4
} from "./chunk-I2XAFJCJ.js";
import {
  u
} from "./chunk-YRAX326I.js";
import "./chunk-DGELARKE.js";
import {
  n as n4,
  s as s5
} from "./chunk-MR6FXIW4.js";
import "./chunk-RRFFPL7N.js";
import "./chunk-JYR7GBAU.js";
import "./chunk-IG4CY4XM.js";
import "./chunk-HB4HVKJV.js";
import "./chunk-CC32E45Q.js";
import {
  s as s4
} from "./chunk-22YODLVL.js";
import "./chunk-TB42IUV7.js";
import "./chunk-ZWMYDR2G.js";
import "./chunk-ZZY5IDKU.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import {
  L
} from "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import {
  e as e4,
  n as n3,
  o as o5
} from "./chunk-6FKG7JUE.js";
import {
  e as e3
} from "./chunk-VNR743PA.js";
import {
  a as a3
} from "./chunk-6O7ZZEV7.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-L2YBXQTH.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import {
  x
} from "./chunk-4XBERLPX.js";
import {
  p as p2
} from "./chunk-GKRQ3NBT.js";
import {
  o as o4
} from "./chunk-MZX3HN4G.js";
import {
  d as d4
} from "./chunk-T47JAOQZ.js";
import "./chunk-6GPADSSO.js";
import {
  d as d3
} from "./chunk-FU5UMT3R.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import {
  n as n2
} from "./chunk-RIWDMEW4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import {
  o as o3
} from "./chunk-T7SYNS2R.js";
import {
  y
} from "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  v as v5
} from "./chunk-OG6CQEZJ.js";
import {
  c as c2
} from "./chunk-X5Z3DJQ4.js";
import {
  O
} from "./chunk-BUWXVMJU.js";
import {
  c,
  f,
  p,
  w as w2
} from "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import {
  y as y2
} from "./chunk-TBT57L4K.js";
import {
  a as a2
} from "./chunk-D3XXPCBB.js";
import {
  t as t2
} from "./chunk-OWBMOIIV.js";
import {
  b as b2
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import {
  l as l2
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-QFTOW2ST.js";
import {
  j as j3
} from "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-RN2KRYDN.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import {
  B as B2
} from "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import {
  r as r3
} from "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  j as j2
} from "./chunk-5N3FSR63.js";
import {
  i
} from "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import {
  d as d2,
  v as v4
} from "./chunk-4PRVTUEZ.js";
import {
  o
} from "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import {
  m as m2
} from "./chunk-CHNDTVQJ.js";
import {
  v2 as v3
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import {
  s as s3
} from "./chunk-XRL56EGK.js";
import {
  r as r2
} from "./chunk-ZIHDQYKE.js";
import {
  o as o2
} from "./chunk-GSRNZQFV.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n,
  v2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  $,
  w
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  S,
  a,
  v
} from "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  e as e2,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/support/RasterFunction.js
var u5;
var c3 = /* @__PURE__ */ new Set(["raster", "raster2", "dem", "fillraster"]);
var p5 = /* @__PURE__ */ new Set(["rasters"]);
var m4 = (t4) => t4 && t4.rasterFunction ? d5.fromJSON(t4) : t4;
var f4 = (t4) => t4 && t4 instanceof d5 ? t4.toJSON() : t4;
var l5 = (t4) => (t4 == null ? void 0 : t4.functionName) && !t4.declaredClass;
var y3 = (t4) => l5(t4) ? new d5(t4) : t4;
var F = (t4) => {
  if (null == t4)
    return null;
  t4 = m(t4);
  const r4 = {};
  for (const e6 of Object.keys(t4))
    c3.has(e6.toLowerCase()) ? r4[e6] = m4(t4[e6]) : p5.has(e6.toLowerCase()) && Array.isArray(t4[e6]) ? r4[e6] = t4[e6].map(m4) : r4[e6] = t4[e6];
  return r4;
};
var d5 = u5 = class extends l {
  constructor(t4) {
    super(t4), this.functionName = null, this.outputPixelType = "unknown", this.variableName = null, this.rasterFunctionDefinition = null;
  }
  set functionArguments(t4) {
    if (t4) {
      const r4 = Object.keys(t4);
      if (r4.some((r5) => c3.has(r5.toLowerCase()) && l5(t4[r5])) || r4.some((r5) => p5.has(r5.toLowerCase()) && Array.isArray(t4[r5]) && t4[r5].some((t5) => l5(t5)))) {
        t4 = m(t4);
        for (const e6 of r4)
          c3.has(e6.toLowerCase()) ? t4[e6] = y3(t4[e6]) : p5.has(e6.toLowerCase()) && Array.isArray(t4[e6]) && (t4[e6] = t4[e6].map((t5) => y3(t5)));
      }
    }
    this._set("functionArguments", t4);
  }
  readFunctionArguments(t4) {
    return F(t4);
  }
  writeFunctionArguments(t4, r4, e6) {
    const o7 = {};
    for (const n9 of Object.keys(t4))
      c3.has(n9.toLowerCase()) ? o7[n9] = f4(t4[n9]) : p5.has(n9.toLowerCase()) && Array.isArray(t4[n9]) ? o7[n9] = t4[n9].map(f4) : o7[n9] = f4(t4[n9]);
    r4[e6] = o7;
  }
  readFunctionName(t4, r4) {
    const e6 = r4.rasterFunctionInfos, o7 = r4.name;
    return o7 || (e6 && e6.length && "None" !== e6[0].name ? e6[0].name : r4.rasterFunctionDefinition ? r4.rasterFunctionDefinition.name : r4.rasterFunction);
  }
  clone() {
    return new u5({ functionName: this.functionName, functionArguments: m(this.functionArguments), outputPixelType: this.outputPixelType, variableName: this.variableName, rasterFunctionDefinition: m(this.rasterFunctionDefinition) });
  }
};
e([d({ json: { type: Object, name: "rasterFunctionArguments" } })], d5.prototype, "functionArguments", null), e([o2("functionArguments")], d5.prototype, "readFunctionArguments", null), e([r2("functionArguments")], d5.prototype, "writeFunctionArguments", null), e([d({ json: { type: String, write: { target: "rasterFunction" } } })], d5.prototype, "functionName", void 0), e([o2("functionName", ["rasterFunction", "rasterFunctionInfos", "rasterFunctionDefinition"])], d5.prototype, "readFunctionName", null), e([r3({ C128: "c128", C64: "c64", F32: "f32", F64: "f64", S16: "s16", S32: "s32", S8: "s8", U1: "u1", U16: "u16", U2: "u2", U32: "u32", U4: "u4", U8: "u8", UNKNOWN: "unknown" }, { ignoreUnknown: false }), d({ json: { default: "unknown" } })], d5.prototype, "outputPixelType", void 0), e([d({ type: String, json: { read: true, write: true } })], d5.prototype, "variableName", void 0), e([d({ type: Object, json: { name: "rasterFunctionDefinition" } })], d5.prototype, "rasterFunctionDefinition", void 0), d5 = u5 = e([n("esri.layers.support.RasterFunction")], d5);
var w3 = d5;

// node_modules/@arcgis/core/layers/support/rasterFunctionUtils.js
var e5 = { StretchFunction: { arguments: { ComputeGamma: { isDataset: false, isPublic: false, name: "ComputeGamma", type: "RasterFunctionVariable", value: false }, DRA: { isDataset: false, isPublic: false, name: "DRA", type: "RasterFunctionVariable", value: false }, EstimateStatsHistogram: { isDataset: false, isPublic: false, name: "EstimateStatsHistogram", type: "RasterFunctionVariable", value: false }, Gamma: { displayName: "Gamma", isDataset: false, isPublic: false, name: "Gamma", type: "RasterFunctionVariable" }, Histograms: { isDataset: false, isPublic: false, name: "Histograms", type: "RasterFunctionVariable" }, Max: { isDataset: false, isPublic: false, name: "Max", type: "RasterFunctionVariable", value: 255 }, MaxPercent: { isDataset: false, isPublic: false, name: "MaxPercent", type: "RasterFunctionVariable", value: 0.5 }, Min: { isDataset: false, isPublic: false, name: "Min", type: "RasterFunctionVariable", value: 0 }, MinPercent: { isDataset: false, isPublic: false, name: "MinPercent", type: "RasterFunctionVariable", value: 0.25 }, NumberOfStandardDeviations: { isDataset: false, isPublic: false, name: "NumberOfStandardDeviation", type: "RasterFunctionVariable", value: 2 }, Raster: { isDataset: true, isPublic: false, name: "Raster", type: "RasterFunctionVariable" }, SigmoidStrengthLevel: { isDataset: false, isPublic: false, name: "SigmoidStrengthLevel", type: "RasterFunctionVariable", value: 2 }, Statistics: { isDataset: false, isPublic: false, name: "Statistics", type: "RasterFunctionVariable" }, StretchType: { isDataset: false, isPublic: false, name: "StretchType", type: "RasterFunctionVariable", value: 0 }, type: "StretchFunctionArguments", UseGamma: { isDataset: false, isPublic: false, name: "UseGamma", type: "RasterFunctionVariable", value: false } }, description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", function: { description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", name: "Stretch", pixelType: "UNKNOWN", type: "StretchFunction" }, functionType: 0, name: "Stretch", thumbnail: "" }, RemapFunction: { name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.", function: { type: "RemapFunction", pixelType: "UNKNOWN", name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, UseTable: { name: "UseTable", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, InputRanges: { name: "InputRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Input Ranges" }, OutputValues: { name: "OutputValues", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Output Values" }, NoDataRanges: { name: "NoDataRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "NoData Ranges" }, Table: { name: "Table", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputField: { name: "InputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, OutputField: { name: "OutputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputMaxField: { name: "InputMaxField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, RemapTableType: { name: "RemapTableType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, AllowUnmatched: { name: "AllowUnmatched", isPublic: false, isDataset: false, value: true, type: "RasterFunctionVariable" }, type: "RemapFunctionArguments" }, functionType: 0, thumbnail: "" }, ColormapFunction: { name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.", function: { type: "ColormapFunction", pixelType: "UNKNOWN", name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, ColormapName: { name: "ColormapName", isPublic: false, isDataset: false, value: "Gray", type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, type: "ColormapFunctionArguments" }, functionType: 0, thumbnail: "" }, ShadedReliefFunction: { name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.", function: { type: "ShadedReliefFunction", pixelType: "UNKNOWN", name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "ShadedReliefFunctionArguments" }, functionType: 0, thumbnail: "" }, HillshadeFunction: { name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image", function: { type: "HillshadeFunction", pixelType: "UNKNOWN", name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image" }, arguments: { DEM: { name: "DEM", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "HillshadeFunctionArguments" }, functionType: 0, thumbnail: "" }, ResampleFunction: { name: "Resample", description: "Changes the cell size of a raster.", function: { type: "ResampleFunction", pixelType: "UNKNOWN", name: "Resample", description: "Changes the cell size of a raster." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ResamplingType: { name: "ResamplingType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, InputCellSize: { name: "InputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, OutputCellSize: { name: "OutputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, type: "ResampleFunctionArguments" }, functionType: 0, thumbnail: "" } };

// node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c4 = { u1: [0, 1], u2: [0, 3], u4: [0, 15], u8: [0, 255], s8: [-128, 127], u16: [0, 65535], s16: [-32768, 32767] };
var l6 = { simple_scalar: "Simple Scalar", wind_barb: "Wind Barb", single_arrow: "Single Arrow", beaufort_kn: "Beaufort Wind (Knots)", beaufort_m: "Beaufort Wind (MetersPerSecond)", ocean_current_m: "Ocean Current (MetersPerSecond)", ocean_current_kn: "Ocean Current (Knots)" };
var m5 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function f5(e6) {
  return m5.has(e6.type);
}
function p6(t4, n9) {
  if (!t4 || !n9)
    return m(t4 || n9);
  const r4 = m(t4);
  if (n9.rasterFunctionDefinition) {
    const e6 = n9.rasterFunctionDefinition;
    (e6.thumbnail || e6.thumbnailEx) && (e6.thumbnail = e6.thumbnailEx = null), g2(r4.rasterFunctionDefinition.arguments, n9);
  } else if ("none" !== n9.functionName.toLowerCase()) {
    b3(r4.functionArguments).Raster = n9;
  }
  return r4;
}
function g2(e6, t4) {
  for (const n9 in e6)
    "raster" === n9.toLowerCase() && ("RasterFunctionVariable" === e6[n9].type ? (e6[n9] = t4.rasterFunctionDefinition, e6[n9].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e6[n9].type && g2(e6[n9].arguments, t4));
}
function d6(t4) {
  const r4 = m(e5[t4.functionName + "Function"]), o7 = t4.functionArguments;
  for (const e6 in o7)
    "raster" === e6.toLowerCase() ? (r4.arguments[e6] = d6(o7[e6]), r4.arguments[e6].type = "RasterFunctionTemplate") : "colormap" === e6.toLowerCase() ? (r4.arguments[e6].value = N(o7[e6]), r4.arguments.ColorSchemeType.value = 0) : r4.arguments[e6].value = o7[e6];
  return r4;
}
function h2(e6, t4) {
  switch (t4 = t4 || {}, e6.type) {
    case "raster-stretch":
      return v6(e6, t4);
    case "class-breaks":
      return T(e6, t4);
    case "unique-value":
      return A(e6, t4);
    case "raster-colormap":
      return F2(e6, t4);
    case "vector-field":
      return y4(e6, t4);
    case "raster-shaded-relief":
      return w4(e6, t4);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b3(e6) {
  const t4 = e6.Raster;
  return t4 && "esri.layers.support.RasterFunction" === t4.declaredClass ? b3(t4.functionArguments) : e6;
}
var R2 = { none: 0, standardDeviation: 3, histogramEqualization: 4, minMax: 5, percentClip: 6, sigmoid: 9 };
function y4(e6, n9) {
  const r4 = new w3();
  r4.functionName = "VectorFieldRenderer";
  const { dataType: o7, bandProperties: a5 } = n9, i7 = "vector-uv" === o7;
  let s6, c8;
  a5 && 2 === a5.length && (s6 = a5.map((e7) => e7.BandName.toLowerCase()).indexOf("magnitude"), c8 = a5.map((e7) => e7.BandName.toLowerCase()).indexOf("direction")), -1 !== s6 && null !== s6 || (s6 = 0, c8 = 1);
  const m9 = "arithmetic" === e6.rotationType ? 1 : 2, f7 = "flow-from" === e6.flowRepresentation ? 0 : 1, p13 = e6.visualVariables ? e6.visualVariables.find((e7) => "Magnitude" === e7.field) : new j3(), g4 = { magnitudeBandID: s6, directionBandID: c8, isUVComponents: i7, referenceSystem: m9, massFlowAngleRepresentation: f7, symbolTileSize: 50, symbolTileSizeUnits: 100, calculationMethod: "Vector Average", symbologyName: l6[e6.style.toLowerCase().replace("-", "_")], minimumMagnitude: p13.minDataValue, maximumMagnitude: p13.maxDataValue, minimumSymbolSize: p13.minSize, maximumSymbolSize: p13.maxSize };
  return r4.functionArguments = g4, n9.convertToRFT ? new w3({ rasterFunctionDefinition: d6(r4) }) : r4;
}
function w4(e6, n9) {
  const a5 = n9.convertToRFT;
  if ("elevation" !== n9.dataType)
    return new w3();
  const i7 = new w3();
  i7.functionName = "Hillshade";
  const s6 = "traditional" === e6.hillshadeType ? 0 : 1, u8 = "none" === e6.scalingType ? 1 : 3, c8 = { HillshadeType: s6, SlopeType: u8, ZFactor: e6.zFactor };
  return 0 === s6 && (c8.Azimuth = e6.azimuth, c8.Altitude = e6.altitude), 3 === u8 && (c8.PSPower = e6.pixelSizePower, c8.PSZFactor = e6.pixelSizeFactor), i7.functionArguments = c8, i7.variableName = "Raster", e6.colorRamp && (i7.functionName = "ShadedRelief", a5 ? c8.ColorRamp = _(e6.colorRamp) : c8.Colormap = h(e6.colorRamp, 256)), a5 ? new w3({ rasterFunctionDefinition: d6(i7) }) : i7;
}
function v6(e6, n9) {
  var _a;
  const i7 = n9.convertToRFT, u8 = new w3();
  u8.functionName = "Stretch";
  const c8 = R2[n5.toJSON(e6.stretchType)], l9 = "u8", m9 = { StretchType: c8, Statistics: x2(e6.statistics), DRA: e6.dynamicRangeAdjustment, UseGamma: e6.useGamma, Gamma: e6.gamma, ComputeGamma: e6.computeGamma };
  if (null != e6.outputMin && (m9.Min = e6.outputMin), null != e6.outputMax && (m9.Max = e6.outputMax), c8 === R2.standardDeviation ? (m9.NumberOfStandardDeviations = e6.numberOfStandardDeviations, u8.outputPixelType = l9) : c8 === R2.percentClip ? (m9.MinPercent = e6.minPercent, m9.MaxPercent = e6.maxPercent, u8.outputPixelType = l9) : c8 === R2.minMax ? u8.outputPixelType = l9 : c8 === R2.sigmoid && (m9.SigmoidStrengthLevel = e6.sigmoidStrengthLevel), u8.functionArguments = m9, u8.variableName = "Raster", e6.colorRamp) {
    const s6 = e6.colorRamp, c9 = new w3();
    if (i7)
      c9.functionArguments = { ColorRamp: _(s6) };
    else {
      const t4 = f2(s6);
      if (t4)
        c9.functionArguments = { colorRamp: t4 };
      else if (!n9.convertColorRampToColormap || "algorithmic" !== s6.type && "multipart" !== s6.type) {
        const t5 = e6.colorRamp.toJSON();
        "algorithmic" === t5.type ? t5.algorithm = t5.algorithm || "esriCIELabAlgorithm" : "multipart" === t5.type && ((_a = t5.colorRamps) == null ? void 0 : _a.length) && t5.colorRamps.forEach((e7) => e7.algorithm = e7.algorithm || "esriCIELabAlgorithm"), c9.functionArguments = { colorRamp: t5 };
      } else
        c9.functionArguments = { Colormap: h(s6, 256) };
    }
    return c9.variableName = "Raster", c9.functionName = "Colormap", c9.functionArguments.Raster = u8, i7 ? new w3({ rasterFunctionDefinition: d6(c9) }) : c9;
  }
  return i7 ? new w3({ rasterFunctionDefinition: d6(u8) }) : u8;
}
function T(e6, n9) {
  const r4 = [], o7 = [], a5 = [], i7 = [], s6 = 1e-6, { pixelType: u8, rasterAttributeTable: c8 } = n9, l9 = c8 && c8.features, m9 = C(c8);
  if (l9 && Array.isArray(l9) && e6.classBreakInfos) {
    e6.classBreakInfos.forEach((t4, n10) => {
      const r6 = t4.symbol.color;
      let o9;
      r6.a && l9.forEach((a6) => {
        o9 = a6.attributes[e6.field], (o9 >= t4.minValue && o9 < t4.maxValue || n10 === e6.classBreakInfos.length - 1 && o9 >= t4.minValue) && i7.push([a6.attributes[m9], r6.r, r6.g, r6.b]);
      });
    });
    const r5 = u8 ? S3(i7, u8) : i7, o8 = new w3();
    return o8.functionName = "Colormap", o8.functionArguments = {}, o8.functionArguments.Colormap = r5, o8.variableName = "Raster", n9.convertToRFT ? new w3({ rasterFunctionDefinition: d6(o8) }) : o8;
  }
  e6.classBreakInfos.forEach((e7, t4) => {
    const n10 = e7.symbol && e7.symbol.color;
    n10.a ? (0 === t4 ? r4.push(e7.minValue, e7.maxValue + s6) : r4.push(e7.minValue + s6, e7.maxValue + s6), o7.push(t4), i7.push([t4, n10.r, n10.g, n10.b])) : a5.push(e7.minValue, e7.maxValue);
  });
  const f7 = u8 ? S3(i7, u8) : i7, p13 = new w3();
  p13.functionName = "Remap", p13.functionArguments = { InputRanges: r4, OutputValues: o7, NoDataRanges: a5 }, p13.variableName = "Raster";
  const g4 = new w3();
  return g4.functionName = "Colormap", g4.functionArguments = { Colormap: f7, Raster: p13 }, n9.convertToRFT ? new w3({ rasterFunctionDefinition: d6(g4) }) : g4;
}
function S3(e6, t4) {
  const n9 = c4[String(t4).toLowerCase()];
  return n9 && e6.push([Math.floor(n9[0] - 1), 0, 0, 0], [Math.ceil(n9[1] + 1), 0, 0, 0]), e6;
}
function C(e6) {
  if (!e6)
    return;
  const { fields: t4 } = e6, n9 = t4 && t4.find((e7) => e7 && e7.name && "value" === e7.name.toLowerCase());
  return n9 && n9.name;
}
function A(e6, n9) {
  var _a, _b;
  const r4 = [], { pixelType: o7, rasterAttributeTable: a5 } = n9, i7 = a5 && a5.features, s6 = C(a5), u8 = (_b = (_a = e6.defaultSymbol) == null ? void 0 : _a.color) == null ? void 0 : _b.toRgb(), c8 = e6.uniqueValueInfos;
  if (c8)
    if (i7) {
      const t4 = /* @__PURE__ */ new Map();
      c8.forEach((e7) => {
        var _a2;
        const n11 = e7.value, r5 = (_a2 = e7.symbol.color) == null ? void 0 : _a2.toRgb();
        null != n11 && r5 && t4.set(String(n11), r5);
      });
      const n10 = e6.field;
      i7.forEach(({ attributes: e7 }) => {
        const o8 = String(e7[n10]), a6 = e7[s6];
        if (t4.has(o8)) {
          const e8 = t4.get(o8);
          r4.push([a6, ...e8]);
        } else
          u8 && r4.push([a6, ...u8]);
      });
    } else
      for (let t4 = 0; t4 < c8.length; t4++) {
        const e7 = c8[t4], n10 = e7.symbol.color, o8 = +e7.value;
        if (n10 == null ? void 0 : n10.a) {
          if (isNaN(o8))
            return null;
          r4.push([o8, n10.r, n10.g, n10.b]);
        }
      }
  const l9 = o7 && r4.length > 0 ? S3(r4, o7) : r4, m9 = new w3();
  return m9.functionName = "Colormap", m9.functionArguments = {}, m9.functionArguments.Colormap = l9, m9.variableName = "Raster", n9.convertToRFT ? new w3({ rasterFunctionDefinition: d6(m9) }) : m9;
}
function F2(e6, n9) {
  const r4 = e6.extractColormap();
  if (!r4 || 0 === r4.length)
    return;
  const { pixelType: o7 } = n9, a5 = o7 ? S3(r4, o7) : r4, i7 = new w3();
  return i7.functionName = "Colormap", i7.functionArguments = {}, i7.functionArguments.Colormap = a5, n9.convertToRFT ? new w3({ rasterFunctionDefinition: d6(i7) }) : i7;
}
function x2(e6) {
  const t4 = [];
  return e6.forEach((e7) => {
    const n9 = e7;
    if (Array.isArray(n9))
      t4.push(n9);
    else {
      if (null == n9.min || null == n9.max)
        return;
      const e8 = [n9.min, n9.max, n9.avg || 0, n9.stddev || 0];
      t4.push(e8);
    }
  }), t4;
}
function N(e6) {
  const t4 = [], n9 = [];
  return e6.forEach((e7) => {
    t4.push(e7[0]), n9.push(R([...e7.slice(1), 255]));
  }), { type: "RasterColormap", values: t4, colors: n9 };
}

// node_modules/@arcgis/core/layers/support/MosaicRule.js
var u6;
var m6 = o()({ MT_FIRST: "first", MT_LAST: "last", MT_MIN: "min", MT_MAX: "max", MT_MEAN: "mean", MT_BLEND: "blend", MT_SUM: "sum" });
var h3 = o()({ esriMosaicNone: "none", esriMosaicCenter: "center", esriMosaicNadir: "nadir", esriMosaicViewpoint: "viewpoint", esriMosaicAttribute: "attribute", esriMosaicLockRaster: "lock-raster", esriMosaicNorthwest: "northwest", esriMosaicSeamline: "seamline" });
function M2(e6) {
  let t4;
  switch (e6 ? e6.toLowerCase().replace("esrimosaic", "") : "") {
    case "byattribute":
    case "attribute":
      t4 = "esriMosaicAttribute";
      break;
    case "lockraster":
      t4 = "esriMosaicLockRaster";
      break;
    case "center":
      t4 = "esriMosaicCenter";
      break;
    case "northwest":
      t4 = "esriMosaicNorthwest";
      break;
    case "nadir":
      t4 = "esriMosaicNadir";
      break;
    case "viewpoint":
      t4 = "esriMosaicViewpoint";
      break;
    case "seamline":
      t4 = "esriMosaicSeamline";
      break;
    default:
      t4 = "esriMosaicNone";
  }
  return h3.fromJSON(t4);
}
var w5 = u6 = class extends l {
  constructor(e6) {
    super(e6), this.ascending = true, this.itemRenderingRule = null, this.lockRasterIds = null, this.method = null, this.multidimensionalDefinition = null, this.objectIds = null, this.operation = null, this.sortField = null, this.sortValue = null, this.viewpoint = null, this.where = null;
  }
  readAscending(e6, t4) {
    return null != t4.ascending ? t4.ascending : null == t4.sortAscending || t4.sortAscending;
  }
  readMethod(e6, t4) {
    return M2(t4.mosaicMethod || t4.defaultMosaicMethod);
  }
  readOperation(e6, t4) {
    const o7 = t4.mosaicOperation, r4 = t4.mosaicOperator && t4.mosaicOperator.toLowerCase(), i7 = o7 || (r4 ? m6.toJSON(r4) : null);
    return m6.fromJSON(i7) || "first";
  }
  castSortValue(e6) {
    return null == e6 || "string" == typeof e6 || "number" == typeof e6 ? e6 : `${e6}`;
  }
  clone() {
    return new u6({ ascending: this.ascending, itemRenderingRule: m(this.itemRenderingRule), lockRasterIds: m(this.lockRasterIds), method: this.method, multidimensionalDefinition: m(this.multidimensionalDefinition), objectIds: m(this.objectIds), operation: this.operation, sortField: this.sortField, sortValue: this.sortValue, viewpoint: m(this.viewpoint), where: this.where });
  }
};
e([d({ type: Boolean, json: { write: true } })], w5.prototype, "ascending", void 0), e([o2("ascending", ["ascending", "sortAscending"])], w5.prototype, "readAscending", null), e([d({ type: w3, json: { write: true } })], w5.prototype, "itemRenderingRule", void 0), e([d({ type: [S], json: { write: { overridePolicy() {
  return { enabled: "lock-raster" === this.method };
} } } })], w5.prototype, "lockRasterIds", void 0), e([d({ type: String, json: { type: h3.jsonValues, write: { target: "mosaicMethod", writer: h3.write } } })], w5.prototype, "method", void 0), e([o2("method", ["mosaicMethod", "defaultMosaicMethod"])], w5.prototype, "readMethod", null), e([d({ type: [p3], json: { write: true } })], w5.prototype, "multidimensionalDefinition", void 0), e([d({ type: [S], json: { name: "fids", write: true } })], w5.prototype, "objectIds", void 0), e([d({ json: { type: m6.jsonValues, read: { reader: m6.read }, write: { target: "mosaicOperation", writer: m6.write } } })], w5.prototype, "operation", void 0), e([o2("operation", ["mosaicOperation", "mosaicOperator"])], w5.prototype, "readOperation", null), e([d({ type: String, json: { write: { overridePolicy() {
  return { enabled: "attribute" === this.method };
} } } })], w5.prototype, "sortField", void 0), e([d({ type: [String, Number], json: { write: { allowNull: true, overridePolicy() {
  return { enabled: "attribute" === this.method, allowNull: true };
} } } })], w5.prototype, "sortValue", void 0), e([s3("sortValue")], w5.prototype, "castSortValue", null), e([d({ type: j, json: { write: true } })], w5.prototype, "viewpoint", void 0), e([d({ type: String, json: { write: true } })], w5.prototype, "where", void 0), w5 = u6 = e([n("esri.layers.support.MosaicRule")], w5);
var y5 = w5;

// node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var d7 = class extends l {
  constructor() {
    super(...arguments), this.layer = null, this.adjustAspectRatio = void 0, this.bandIds = void 0, this.compression = void 0, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.interpolation = null, this.noData = null, this.noDataInterpretation = void 0, this.pixelType = void 0, this.lercVersion = 2;
  }
  writeAdjustAspectRatio(e6, r4, t4) {
    this.layer.version < 10.3 || (r4[t4] = e6);
  }
  writeCompressionQuality(e6, r4, t4) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e6 && (r4[t4] = e6);
  }
  writeCompressionTolerance(e6, r4, t4) {
    "lerc" === this.format && null != e6 && (r4[t4] = e6);
  }
  get format() {
    var _a;
    return "vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type) ? "lerc" : this.layer.format;
  }
  writeLercVersion(e6, r4, t4) {
    "lerc" === this.format && this.layer.version >= 10.5 && (r4[t4] = e6);
  }
  get version() {
    const e6 = this.layer;
    return e6.commitProperty("bandIds"), e6.commitProperty("format"), e6.commitProperty("compressionQuality"), e6.commitProperty("compressionTolerance"), e6.commitProperty("interpolation"), e6.commitProperty("noData"), e6.commitProperty("noDataInterpretation"), e6.commitProperty("mosaicRule"), e6.commitProperty("renderingRule"), e6.commitProperty("adjustAspectRatio"), e6.commitProperty("pixelFilter"), e6.commitProperty("renderer"), e6.commitProperty("definitionExpression"), (this._get("version") || 0) + 1;
  }
  set version(e6) {
    this._set("version", e6);
  }
  get mosaicRule() {
    const e6 = this.layer;
    let r4 = e6.mosaicRule;
    const t4 = e6.definitionExpression;
    return r4 ? t4 && t4 !== r4.where && (r4 = r4.clone(), r4.where = t4) : t4 && (r4 = new y5({ where: t4 })), r4;
  }
  get renderingRule() {
    var _a;
    const e6 = this.layer;
    let r4 = e6.renderingRule;
    const t4 = e6.pixelFilter, o7 = !e6.format || e6.format.includes("jpg") || e6.format.includes("png");
    return r4 = this._addResampleRasterFunction(r4), o7 && !t4 && "vector-field" !== ((_a = e6.renderer) == null ? void 0 : _a.type) && (r4 = this.combineRendererWithRenderingRule()), r4;
  }
  combineRendererWithRenderingRule() {
    var _a;
    const e6 = this.layer, { rasterInfo: r4, renderingRule: t4, renderer: o7 } = e6;
    if (!o7 || !f5(o7))
      return t4;
    return p6(h2(o7, { rasterAttributeTable: r4.attributeTable, pixelType: r4.pixelType, dataType: r4.dataType, bandProperties: (_a = r4.keyProperties) == null ? void 0 : _a.BandProperties, convertColorRampToColormap: e6.version < 10.6, convertToRFT: !!(t4 == null ? void 0 : t4.rasterFunctionDefinition) }), t4);
  }
  _addResampleRasterFunction(e6) {
    var _a;
    if (!("vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type)) || "Resample" === (e6 == null ? void 0 : e6.functionName))
      return e6;
    const r4 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10;
    let t4 = new w3({ functionName: "Resample", functionArguments: { ResamplingType: r4, InputCellSize: { x: this.layer.pixelSizeX, y: this.layer.pixelSizeY } } });
    return t4 = (e6 == null ? void 0 : e6.rasterFunctionDefinition) ? new w3({ rasterFunctionDefinition: d6(t4) }) : t4, p6(t4, e6);
  }
};
e([d()], d7.prototype, "layer", void 0), e([d({ json: { write: true } })], d7.prototype, "adjustAspectRatio", void 0), e([r2("adjustAspectRatio")], d7.prototype, "writeAdjustAspectRatio", null), e([d({ json: { write: true } }), o3("layer.bandIds")], d7.prototype, "bandIds", void 0), e([d({ json: { write: true } })], d7.prototype, "compression", void 0), e([d({ json: { write: true } }), o3("layer.compressionQuality")], d7.prototype, "compressionQuality", void 0), e([r2("compressionQuality")], d7.prototype, "writeCompressionQuality", null), e([d({ json: { write: true } }), o3("layer.compressionTolerance")], d7.prototype, "compressionTolerance", void 0), e([r2("compressionTolerance")], d7.prototype, "writeCompressionTolerance", null), e([d({ json: { write: true } })], d7.prototype, "format", null), e([d({ type: String, json: { read: { reader: o6.read }, write: { writer: o6.write } } }), o3("layer.interpolation")], d7.prototype, "interpolation", void 0), e([d({ json: { write: true } }), o3("layer.noData")], d7.prototype, "noData", void 0), e([d({ type: String, json: { read: { reader: i3.read }, write: { writer: i3.write } } }), o3("layer.noDataInterpretation")], d7.prototype, "noDataInterpretation", void 0), e([d({ json: { write: true } })], d7.prototype, "pixelType", void 0), e([d({ json: { write: true } })], d7.prototype, "lercVersion", void 0), e([r2("lercVersion")], d7.prototype, "writeLercVersion", null), e([d({ type: Number })], d7.prototype, "version", null), e([d({ json: { write: true } })], d7.prototype, "mosaicRule", null), e([d({ json: { write: true } })], d7.prototype, "renderingRule", null), d7 = e([n("esri.layers.mixins.ExportImageServiceParameters")], d7);

// node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p7 = class extends l {
  constructor() {
    super(...arguments), this.north = null, this.up = null, this.spatialReference = null;
  }
};
e([d({ type: Number, json: { write: true } })], p7.prototype, "north", void 0), e([d({ type: Number, json: { write: true } })], p7.prototype, "up", void 0), e([d({ type: k, json: { write: true } })], p7.prototype, "spatialReference", void 0), p7 = e([n("esri.rest.support.ImageAngleResult")], p7);
var i5 = p7;

// node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p8 = class extends l {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
e([d({ json: { write: true } })], p8.prototype, "catalogItemVisibilities", void 0), e([d({ type: x, json: { write: true } })], p8.prototype, "catalogItems", void 0), e([d({ type: j, json: { write: true } })], p8.prototype, "location", void 0), e([d({ json: { write: true } })], p8.prototype, "name", void 0), e([d({ json: { write: true } })], p8.prototype, "objectId", void 0), e([d({ json: { write: true } })], p8.prototype, "processedValues", void 0), e([d({ json: { write: true } })], p8.prototype, "properties", void 0), e([d({ json: { write: true } })], p8.prototype, "value", void 0), p8 = e([n("esri.rest.support.ImageIdentifyResult")], p8);
var l7 = p8;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t3 = class extends l {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
e([d({ json: { write: true } })], t3.prototype, "geometries", void 0), t3 = e([n("esri.rest.support.ImagePixelLocationResult")], t3);
var p9 = t3;

// node_modules/@arcgis/core/rest/support/ImageSample.js
var i6 = class extends l {
  constructor() {
    super(...arguments), this.attributes = null, this.location = null, this.locationId = null, this.rasterId = null, this.resolution = null, this.pixelValue = null;
  }
};
e([d({ json: { write: true } })], i6.prototype, "attributes", void 0), e([d({ type: j, json: { write: true } })], i6.prototype, "location", void 0), e([d({ json: { write: true } })], i6.prototype, "locationId", void 0), e([d({ json: { write: true } })], i6.prototype, "rasterId", void 0), e([d({ json: { write: true } })], i6.prototype, "resolution", void 0), e([d({ json: { write: true } })], i6.prototype, "pixelValue", void 0), i6 = e([n("esri.rest.support.ImageSample")], i6);
var p10 = i6;

// node_modules/@arcgis/core/rest/support/ImageSampleResult.js
var p11 = class extends l {
  constructor() {
    super(...arguments), this.samples = null;
  }
};
e([d({ type: [p10], json: { write: true } })], p11.prototype, "samples", void 0), p11 = e([n("esri.rest.support.ImageSampleResult")], p11);
var c5 = p11;

// node_modules/@arcgis/core/rest/imageService.js
function u7(e6) {
  const t4 = e6 == null ? void 0 : e6.time;
  if (t4 && (null != t4.start || null != t4.end)) {
    const n9 = [];
    null != t4.start && n9.push(t4.start), null == t4.end || n9.includes(t4.end) || n9.push(t4.end), e6.time = n9.join(",");
  }
}
async function p12(e6, r4, i7) {
  const m9 = n3(e6), c8 = r4.geometry ? [r4.geometry] : [], l9 = await L(c8), p13 = r4.toJSON();
  u7(p13);
  const f7 = l9 && l9[0];
  r(f7) && (p13.geometry = f7.toJSON());
  const g4 = o5({ ...m9.query, f: "json", ...p13 });
  return e4(g4, i7);
}
async function f6(n9, i7, m9) {
  var _a;
  const c8 = i7.toJSON();
  r(c8.angleName) && (c8.angleName = c8.angleName.join(",")), r(i7.point) && ((_a = i7.point.spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (c8.point.spatialReference = h4(i7.point.spatialReference)), r(i7.spatialReference) && i7.spatialReference.imageCoordinateSystem && (c8.spatialReference = R3(i7.spatialReference));
  const u8 = n3(n9), p13 = o5({ ...u8.query, f: "json", ...c8 }), f7 = e4(p13, m9), { data: g4 } = await U(`${u8.path}/computeAngles`, f7);
  return g4.spatialReference = g4.spatialReference ? null != g4.spatialReference.geodataXform ? new k({ wkid: 0, imageCoordinateSystem: g4.spatialReference }) : k.fromJSON(g4.spatialReference) : null, "NaN" === g4.north && (g4.north = null), "NaN" === g4.up && (g4.up = null), new i5(g4);
}
async function g3(t4, n9, r4) {
  var _a;
  const i7 = n9.toJSON(), { geometries: c8 } = n9;
  for (let e6 = 0; e6 < c8.length; e6++)
    ((_a = c8[e6].spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (i7.geometries.geometries[e6].spatialReference = h4(c8[e6].spatialReference));
  const l9 = n3(t4), u8 = o5({ ...l9.query, f: "json", ...i7 }), p13 = e4(u8, r4), { data: f7 } = await U(`${l9.path}/computePixelLocation`, p13);
  return p9.fromJSON(f7);
}
async function y6(t4, n9, a5) {
  const s6 = await p12(t4, n9, a5), r4 = n3(t4), { data: i7 } = await U(`${r4.path}/computeStatisticsHistograms`, s6), { statistics: m9 } = i7;
  return (m9 == null ? void 0 : m9.length) && m9.forEach((e6) => {
    e6.avg = e6.mean, e6.stddev = e6.standardDeviation;
  }), { statistics: m9, histograms: i7.histograms };
}
async function d8(t4, n9, a5) {
  const s6 = await p12(t4, n9, a5), r4 = n3(t4), { data: i7 } = await U(`${r4.path}/computeHistograms`, s6);
  return { histograms: i7.histograms };
}
async function N2(r4, i7, m9) {
  var _a, _b, _c;
  const l9 = i7.toJSON();
  u7(l9), ((_a = l9.outFields) == null ? void 0 : _a.length) && (l9.outFields = l9.outFields.join(","));
  const p13 = (_b = await L(i7.geometry)) == null ? void 0 : _b[0];
  r(p13) && (l9.geometry = p13.toJSON());
  const f7 = n3(r4), g4 = o5({ ...f7.query, f: "json", ...l9 }), y9 = e4(g4, m9), { data: d12 } = await U(`${f7.path}/getSamples`, y9), N3 = (_c = d12 == null ? void 0 : d12.samples) == null ? void 0 : _c.map((e6) => {
    const t4 = "NaN" === e6.value || "" === e6.value ? null : e6.value.split(" ").map((e7) => Number(e7));
    return { ...e6, pixelValue: t4 };
  });
  return c5.fromJSON({ samples: N3 });
}
async function S4(r4, m9, c8) {
  const l9 = n3(r4), u8 = m9.geometry ? [m9.geometry] : [];
  return L(u8).then((n9) => {
    const o7 = m9.toJSON(), r5 = n9 && n9[0];
    r(r5) && (o7.geometry = JSON.stringify(r5.toJSON()));
    const i7 = o5({ ...l9.query, f: "json", ...o7 }), u9 = e4(i7, c8);
    return U(l9.path + "/identify", u9);
  }).then((e6) => l7.fromJSON(e6.data));
}
function h4(e6) {
  const { imageCoordinateSystem: t4 } = e6;
  if (t4) {
    const { id: e7, referenceServiceName: n9 } = t4;
    return null != e7 ? n9 ? { icsid: e7, icsns: n9 } : { icsid: e7 } : { ics: t4 };
  }
  return e6.toJSON();
}
function R3(e6, t4) {
  const n9 = h4(e6), { icsid: o7, icsns: a5, wkid: s6 } = n9;
  return null != o7 ? null == a5 || (t4 == null ? void 0 : t4.toLowerCase().includes("/" + a5.toLowerCase() + "/")) ? `0:${o7}` : JSON.stringify(n9) : s6 ? s6.toString() : JSON.stringify(n9);
}

// node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
async function n7(n9, m9, p13) {
  var _a, _b;
  const f7 = n3(n9), u8 = o5({ ...f7.query, f: "json" }), h6 = e4(u8, p13), d12 = `${f7.path}/${m9}/info`, c8 = U(`${d12}`, h6), g4 = U(`${d12}/keyProperties`, h6), x3 = await Promise.allSettled([c8, g4]), y9 = "fulfilled" === x3[0].status ? x3[0].value.data : null, v7 = "fulfilled" === x3[1].status ? x3[1].value.data : null;
  let P2 = null;
  ((_a = y9.statistics) == null ? void 0 : _a.length) && (P2 = y9.statistics.map((e6) => ({ min: e6[0], max: e6[1], avg: e6[2], stddev: e6[3] })));
  const S5 = M.fromJSON(y9.extent), j6 = Math.ceil(S5.width / y9.pixelSizeX - 0.1), w6 = Math.ceil(S5.height / y9.pixelSizeY - 0.1), b4 = S5.spatialReference, k3 = new j({ x: y9.pixelSizeX, y: y9.pixelSizeY, spatialReference: b4 }), z = ((_b = y9.histograms) == null ? void 0 : _b.length) ? y9.histograms : null, L3 = new p4({ origin: y9.origin, blockWidth: y9.blockWidth, blockHeight: y9.blockHeight, firstPyramidLevel: y9.firstPyramidLevel, maximumPyramidLevel: y9.maxPyramidLevel });
  return new l4({ width: j6, height: w6, bandCount: y9.bandCount, extent: S5, spatialReference: b4, pixelSize: k3, pixelType: y9.pixelType.toLowerCase(), statistics: P2, histograms: z, keyProperties: v7, storageInfo: L3 });
}

// node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n8;
var m7 = n8 = class extends l {
  constructor() {
    super(...arguments), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n8(m({ angleNames: this.angleNames, point: this.point, spatialReference: this.spatialReference, rasterId: this.rasterId }));
  }
};
e([d({ type: [String], json: { name: "angleName", write: true } })], m7.prototype, "angleNames", void 0), e([d({ type: j, json: { write: true } })], m7.prototype, "point", void 0), e([d({ type: k, json: { write: true } })], m7.prototype, "spatialReference", void 0), e([d({ type: S, json: { write: true } })], m7.prototype, "rasterId", void 0), m7 = n8 = e([n("esri.rest.support.ImageAngleParameters")], m7);
var l8 = m7;

// node_modules/@arcgis/core/rest/support/ImageHistogramParameters.js
var y7;
var j4 = y7 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.mosaicRule = null, this.renderingRule = null, this.pixelSize = null, this.raster = void 0, this.timeExtent = null;
  }
  writeGeometry(e6, r4, t4) {
    null != e6 && (r4.geometryType = v4(e6), r4[t4] = e6.toJSON());
  }
  clone() {
    return new y7(m({ geometry: this.geometry, mosaicRule: this.mosaicRule, renderingRule: this.renderingRule, pixelSize: this.pixelSize, raster: this.raster, timeExtent: this.timeExtent }));
  }
};
e([d({ types: i, json: { read: d2 } })], j4.prototype, "geometry", void 0), e([r2("geometry")], j4.prototype, "writeGeometry", null), e([d({ type: y5, json: { write: true } })], j4.prototype, "mosaicRule", void 0), e([d({ type: w3, json: { write: true } })], j4.prototype, "renderingRule", void 0), e([d({ type: j, json: { write: true } })], j4.prototype, "pixelSize", void 0), e([d({ json: { write: true } })], j4.prototype, "raster", void 0), e([d({ type: y2, json: { read: { source: "time" }, write: { target: "time" } } })], j4.prototype, "timeExtent", void 0), j4 = y7 = e([n("esri.rest.support.ImageHistogramParameters")], j4);
var d9 = j4;

// node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var y8;
var c6 = y8 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.renderingRules = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(e6, t4, r4) {
    null != e6 && (t4.geometryType = v4(e6), t4[r4] = JSON.stringify(e6.toJSON()));
  }
  set mosaicRule(e6) {
    let t4 = e6;
    t4 && t4.mosaicMethod && (t4 = y5.fromJSON({ ...t4.toJSON(), mosaicMethod: t4.mosaicMethod, mosaicOperation: t4.mosaicOperation })), this._set("mosaicRule", t4);
  }
  writeMosaicRule(e6, t4, r4) {
    null != e6 && (t4[r4] = JSON.stringify(e6.toJSON()));
  }
  set renderingRule(e6) {
    let t4 = e6;
    t4 && t4.rasterFunction && (t4 = w3.fromJSON({ ...t4.toJSON(), rasterFunction: t4.rasterFunction, rasterFunctionArguments: t4.rasterFunctionArguments })), this._set("renderingRule", t4);
  }
  writeRenderingRule(e6, t4, r4) {
    null != e6 && (t4[r4] = JSON.stringify(e6.toJSON())), e6.rasterFunctionDefinition && (t4[r4] = JSON.stringify(e6.rasterFunctionDefinition));
  }
  writeRenderingRules(e6, t4, r4) {
    null != e6 && (t4[r4] = JSON.stringify(e6.map((e7) => e7.rasterFunctionDefinition || e7.toJSON())));
  }
  writePixelSize(e6, t4, r4) {
    null != e6 && (t4[r4] = JSON.stringify(e6));
  }
  writeTimeExtent(e6, t4, r4) {
    if (null != e6) {
      const o7 = r(e6.start) ? e6.start.getTime() : null, s6 = r(e6.end) ? e6.end.getTime() : null;
      t4[r4] = null != o7 ? null != s6 ? `${o7},${s6}` : `${o7}` : null;
    }
  }
  clone() {
    return new y8(m({ geometry: this.geometry, mosaicRule: this.mosaicRule, renderingRule: this.renderingRule, pixelSize: this.pixelSize, returnGeometry: this.returnGeometry, returnCatalogItems: this.returnCatalogItems, returnPixelValues: this.returnPixelValues, maxItemCount: this.maxItemCount, processAsMultidimensional: this.processAsMultidimensional, raster: this.raster, viewId: this.viewId, timeExtent: this.timeExtent }));
  }
};
e([d({ json: { write: true } })], c6.prototype, "geometry", void 0), e([r2("geometry")], c6.prototype, "writeGeometry", null), e([d({ type: y5, json: { write: true } })], c6.prototype, "mosaicRule", null), e([r2("mosaicRule")], c6.prototype, "writeMosaicRule", null), e([d({ type: w3, json: { write: true } })], c6.prototype, "renderingRule", null), e([r2("renderingRule")], c6.prototype, "writeRenderingRule", null), e([d({ type: [w3], json: { write: true } })], c6.prototype, "renderingRules", void 0), e([r2("renderingRules")], c6.prototype, "writeRenderingRules", null), e([d({ type: j, json: { write: true } })], c6.prototype, "pixelSize", void 0), e([r2("pixelSize")], c6.prototype, "writePixelSize", null), e([d({ type: Boolean, json: { write: true } })], c6.prototype, "returnGeometry", void 0), e([d({ type: Boolean, json: { write: true } })], c6.prototype, "returnCatalogItems", void 0), e([d({ type: Boolean, json: { write: true } })], c6.prototype, "returnPixelValues", void 0), e([d({ type: Number, json: { write: true } })], c6.prototype, "maxItemCount", void 0), e([d({ type: y2, json: { write: { target: "time" } } })], c6.prototype, "timeExtent", void 0), e([r2("timeExtent")], c6.prototype, "writeTimeExtent", null), e([d({ json: { write: true } })], c6.prototype, "raster", void 0), e([d({ json: { write: true } })], c6.prototype, "viewId", void 0), e([d({ type: Boolean, json: { write: true } })], c6.prototype, "processAsMultidimensional", void 0), c6 = y8 = e([n("esri.rest.support.ImageIdentifyParameters")], c6);
var d10 = c6;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m8;
var c7 = m8 = class extends l {
  constructor() {
    super(...arguments), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r4, e6, o7) {
    e6.geometries = { geometryType: "esriGeometryPoint", geometries: r4.map((r5) => r5.toJSON()) };
  }
  clone() {
    return new m8({ geometries: this.geometries.map((r4) => r4.clone()), rasterId: this.rasterId });
  }
};
e([d({ type: [j], json: { write: true } })], c7.prototype, "geometries", void 0), e([r2("geometries")], c7.prototype, "writeGeometry", null), e([d({ type: S, json: { write: true } })], c7.prototype, "rasterId", void 0), c7 = m8 = e([n("esri.rest.support.ImagePixelLocationParameters")], c7);
var a4 = c7;

// node_modules/@arcgis/core/rest/support/ImageSampleParameters.js
var d11;
var j5 = d11 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.interpolation = "nearest", this.mosaicRule = null, this.outFields = null, this.pixelSize = null, this.returnFirstValueOnly = true, this.sampleDistance = null, this.sampleCount = null, this.sliceId = null, this.timeExtent = null;
  }
  writeGeometry(t4, e6, o7) {
    null != t4 && (e6.geometryType = v4(t4), e6[o7] = t4.toJSON());
  }
  set locations(t4) {
    if (t4 == null ? void 0 : t4.length) {
      const e6 = new m2({ spatialReference: t4[0].spatialReference });
      e6.points = t4.map((t5) => [t5.x, t5.y]), this._set("locations", t4), this.geometry = e6;
    }
  }
  clone() {
    return new d11(m({ geometry: this.geometry, locations: this.locations, interpolation: this.interpolation, mosaicRule: this.mosaicRule, outFields: this.outFields, raster: this.raster, returnFirstValueOnly: this.returnFirstValueOnly, sampleDistance: this.sampleDistance, sampleCount: this.sampleCount, sliceId: this.sliceId, pixelSize: this.pixelSize, timeExtent: this.timeExtent }));
  }
};
e([d({ types: i, json: { read: d2 } })], j5.prototype, "geometry", void 0), e([r2("geometry")], j5.prototype, "writeGeometry", null), e([d()], j5.prototype, "locations", null), e([d({ type: String, json: { type: o6.jsonValues, read: o6.read, write: o6.write } })], j5.prototype, "interpolation", void 0), e([d({ type: y5, json: { write: true } })], j5.prototype, "mosaicRule", void 0), e([d({ type: [String], json: { write: true } })], j5.prototype, "outFields", void 0), e([d({ type: j, json: { write: true } })], j5.prototype, "pixelSize", void 0), e([d({ type: String, json: { write: true } })], j5.prototype, "raster", void 0), e([d({ type: Boolean, json: { write: true } })], j5.prototype, "returnFirstValueOnly", void 0), e([d({ type: Number, json: { write: true } })], j5.prototype, "sampleDistance", void 0), e([d({ type: Number, json: { write: true } })], j5.prototype, "sampleCount", void 0), e([d({ type: Number, json: { write: true } })], j5.prototype, "sliceId", void 0), e([d({ type: y2, json: { read: { source: "time" }, write: { target: "time" } } })], j5.prototype, "timeExtent", void 0), j5 = d11 = e([n("esri.rest.support.ImageSampleParameters")], j5);
var h5 = j5;

// node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var Re = s.getLogger("esri.layers.mixins.ArcGISImageService");
var ve = o()({ U1: "u1", U2: "u2", U4: "u4", U8: "u8", S8: "s8", U16: "u16", S16: "s16", U32: "u32", S32: "s32", F32: "f32", F64: "f64", C64: "c64", C128: "c128", UNKNOWN: "unknown" });
var Se = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var be = v2(a, { min: 0, max: 255 });
function Ie(e6) {
  var _a;
  if (!e6)
    return null;
  const t4 = (_a = JSON.stringify(e6).match(/"rasterFunction":"(.*?")/gi)) == null ? void 0 : _a.map((e7) => e7.replace('"rasterFunction":"', "").replace('"', ""));
  return t4 ? t4.join("/") : null;
}
var xe = (a5) => {
  let u8 = class extends a5 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this._defaultServiceMosaicRule = null, this._serviceSourceType = null, this._serviceSupportsMosaicRule = null, this.rasterAttributeTableFieldPrefix = "Raster.", this.adjustAspectRatio = null, this.bandCount = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalInfo = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelSizeX = null, this.pixelSizeY = null, this.pixelFilter = null, this.raster = void 0, this.viewId = void 0, this.symbolizer = null, this.rasterAttributeTable = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new d7({ layer: this }));
    }
    readDefaultServiceMosaicRule(e6, t4) {
      return this._serviceSupportsMosaicRule ? y5.fromJSON(t4) : null;
    }
    readServiceSourceType(e6, t4) {
      return this._isMosaicDataset(t4) ? "mosaic-dataset" : "raster-dataset";
    }
    readServiceSupportsMosaicRule(e6, t4) {
      return this._isMosaicRuleSupported(t4);
    }
    get rasterFunctionNamesIndex() {
      const e6 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || r(this.rasterFunctionInfos) && this.rasterFunctionInfos.length < 1 || r(this.rasterFunctionInfos) && this.rasterFunctionInfos.forEach((t4) => {
        e6.set(t4.name.toLowerCase().replace(/ /gi, "_"), t4.name);
      }), e6;
    }
    readBandIds(e6, t4) {
      if (Array.isArray(e6) && e6.length > 0 && e6.every((e7) => "number" == typeof e7))
        return e6;
    }
    readCapabilities(e6, t4) {
      return this._readCapabilities(t4);
    }
    writeCompressionQuality(e6, t4, r4) {
      null != e6 && "lerc" !== this.format && (t4[r4] = e6);
    }
    writeCompressionTolerance(e6, t4, r4) {
      "lerc" === this.format && null != e6 && (t4[r4] = e6);
    }
    get fieldsIndex() {
      return this.fields ? new d3(this.fields) : null;
    }
    set format(e6) {
      e6 && Se.has(e6.toLowerCase()) && this._set("format", e6.toLowerCase());
    }
    readFormat(e6, t4) {
      return "esriImageServiceDataTypeVector-UV" === t4.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t4.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e6, t4) {
      return null != t4.minLOD && null != t4.maxLOD ? e6 : 0;
    }
    readMaxScale(e6, t4) {
      return null != t4.minLOD && null != t4.maxLOD ? e6 : 0;
    }
    set mosaicRule(e6) {
      let t4 = e6;
      t4 && t4.mosaicMethod && (t4 = y5.fromJSON({ ...t4.toJSON(), mosaicMethod: t4.mosaicMethod, mosaicOperation: t4.mosaicOperation })), this._set("mosaicRule", t4);
    }
    readMosaicRule(e6, t4) {
      const r4 = e6 || t4.mosaicRule;
      return r4 ? y5.fromJSON(r4) : this._isMosaicRuleSupported(t4) ? y5.fromJSON(t4) : null;
    }
    writeMosaicRule(e6, t4, r4) {
      let i7 = this.mosaicRule;
      const s6 = this.definitionExpression;
      i7 ? s6 && s6 !== i7.where && (i7 = i7.clone(), i7.where = s6) : s6 && (i7 = new y5({ where: s6 })), this._isValidCustomizedMosaicRule(i7) && (t4[r4] = i7.toJSON());
    }
    writeNoData(e6, t4, r4) {
      null != e6 && "number" == typeof e6 && (t4[r4] = be(e6));
    }
    readObjectIdField(e6, t4) {
      if (!e6) {
        const r4 = t4.fields.filter((e7) => "esriFieldTypeOID" === e7.type || "oid" === e7.type);
        e6 = r4 && r4[0] && r4[0].name;
      }
      return e6;
    }
    get parsedUrl() {
      return this.url ? j2(this.url) : null;
    }
    set renderer(e6) {
      this.loaded && (e6 = this._configRenderer(e6)), this._set("renderer", e6);
    }
    readRenderer(e6, t4, i7) {
      var _a, _b;
      const s6 = (_b = (_a = t4 == null ? void 0 : t4.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer, n9 = u3(s6, i7);
      return null == n9 ? null : ("vector-field" === n9.type && t4.symbolTileSize && !s6.symbolTileSize && (n9.symbolTileSize = t4.symbolTileSize), f5(n9) || Re.warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), n9);
    }
    writeRenderer(e6, t4, r4) {
      t4.layerDefinition = t4.layerDefinition || {}, t4.layerDefinition.drawingInfo = t4.layerDefinition.drawingInfo || {}, t4.layerDefinition.drawingInfo.renderer = e6.toJSON(), "vector-field" === e6.type && (t4.symbolTileSize = e6.symbolTileSize);
    }
    get rasterFields() {
      const e6 = this.rasterAttributeTableFieldPrefix || "Raster.", t4 = new y({ name: "Raster.ItemPixelValue", alias: "Item Pixel Value", domain: null, editable: false, length: 50, type: "string" }), r4 = new y({ name: "Raster.ServicePixelValue", alias: "Service Pixel Value", domain: null, editable: false, length: 50, type: "string" }), i7 = new y({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Service Pixel Value", domain: null, editable: false, length: 50, type: "string" });
      let s6 = this.fields ? m(this.fields) : [];
      s6.push(r4), this.capabilities.operations.supportsQuery && this.fields && this.fields.length > 0 && s6.push(t4), this.version >= 10.4 && r(this.rasterFunctionInfos) && this.rasterFunctionInfos.some((e7) => "none" === e7.name.toLowerCase()) && s6.push(i7), r(this.rasterFunctionInfos) && this.rasterFunctionInfos.filter((e7) => "none" !== e7.name.toLowerCase()).forEach((e7) => {
        s6.push(new y({ name: "Raster.ServicePixelValue." + e7.name, alias: e7.name, domain: null, editable: false, length: 50, type: "string" }));
      }), this._isVectorDataSet() && (s6.push(new y({ name: "Raster.Magnitude", alias: "Magnitude", domain: null, editable: false, type: "double" })), s6.push(new y({ name: "Raster.Direction", alias: "Direction", domain: null, editable: false, type: "double" })));
      const n9 = this.rasterInfo.attributeTable && this.rasterInfo.attributeTable.fields || null;
      if (n9 && n9.length > 0) {
        const t5 = n9.filter((e7) => "esriFieldTypeOID" !== e7.type && "value" !== e7.name.toLowerCase()).map((t6) => {
          const r5 = m(t6);
          return r5.name = e6 + t6.name, r5;
        });
        s6 = s6.concat(t5);
      }
      return s6;
    }
    set renderingRule(e6) {
      let t4 = e6;
      t4 && t4.rasterFunction && (t4 = w3.fromJSON({ ...t4.toJSON(), rasterFunction: t4.rasterFunction, rasterFunctionArguments: t4.rasterFunctionArguments })), this._set("renderingRule", t4);
    }
    readRenderingRule(e6, t4) {
      const r4 = t4.rasterFunctionInfos;
      return t4.renderingRule || r4 && r4.length && "None" !== r4[0].name ? this._isRFTJson(t4.renderingRule) ? w3.fromJSON({ rasterFunctionDefinition: t4.renderingRule }) : w3.fromJSON(t4.renderingRule || { rasterFunctionInfos: t4.rasterFunctionInfos }) : null;
    }
    writeRenderingRule(e6, t4, r4) {
      const i7 = e6.toJSON();
      i7.rasterFunctionDefinition ? t4[r4] = i7.rasterFunctionDefinition : t4[r4] = i7;
    }
    readSpatialReference(e6, t4) {
      const r4 = e6 || t4.extent.spatialReference;
      return r4 ? k.fromJSON(r4) : null;
    }
    readPixelType(e6) {
      return ve.fromJSON(e6) || e6;
    }
    writePixelType(e6, t4, r4) {
      (t(this.serviceRasterInfo) || this.pixelType !== this.serviceRasterInfo.pixelType) && (t4[r4] = ve.toJSON(e6));
    }
    readVersion(e6, t4) {
      let r4 = t4.currentVersion;
      return r4 || (r4 = t4.hasOwnProperty("fields") || t4.hasOwnProperty("timeInfo") ? 10 : 9.3), r4;
    }
    applyFilter(e6) {
      let t4 = e6;
      return this.pixelFilter && (t4 = this._clonePixelData(e6), this.pixelFilter(t4)), t4;
    }
    async applyRenderer(e6, t4) {
      let r4 = e6;
      if (!this._isPicture() && this.renderer && this.symbolizer && !this.pixelFilter) {
        const i7 = JSON.stringify(this._cachedRendererJson) !== JSON.stringify(this.renderer.toJSON()), s6 = this._rasterJobHandler.instance, { bandIds: n9 } = this;
        if (s6) {
          i7 && (this.symbolizer.bind(), await s6.updateSymbolizer(this.symbolizer, t4), this._cachedRendererJson = this.renderer.toJSON());
          const o7 = await s6.symbolize({ bandIds: n9, ...e6 }, t4);
          r4 = { extent: e6.extent, pixelBlock: o7 };
        } else
          r4 = { extent: e6.extent, pixelBlock: this.symbolizer.symbolize({ bandIds: n9, ...e6 }) };
      }
      return r4;
    }
    destroy() {
      this._shutdownJobHandler();
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    async computeAngles(e6, t4) {
      if (await this._fetchCapabilities(t4 == null ? void 0 : t4.signal), !this.capabilities.operations.supportsComputeAngles)
        throw new s2("imagery-layer:compute-angles", "this operation is not supported on the input image service");
      return e6 = v(l8, e6).clone(), f6(this.url, e6, this._getRequestOptions(t4));
    }
    async computePixelSpaceLocations(e6, t4) {
      if (await this._fetchCapabilities(t4 == null ? void 0 : t4.signal), !this.capabilities.operations.supportsComputePixelLocation)
        throw new s2("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return e6 = v(a4, e6).clone(), g3(this.url, e6, this._getRequestOptions(t4));
    }
    async computeHistograms(e6, t4) {
      if (await this._fetchCapabilities(t4 == null ? void 0 : t4.signal), !this.capabilities.operations.supportsComputeHistograms)
        throw new s2("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
      e6 = v(d9, e6).clone();
      const { raster: r4, mosaicRule: i7, renderingRule: s6 } = this;
      return s6 && null == e6.renderingRule && (e6.renderingRule = s6), i7 && null == e6.mosaicRule && (e6.mosaicRule = i7), r4 && null == e6.raster && (e6.raster = r4), d8(this.url, e6, this._getRequestOptions(t4));
    }
    async computeStatisticsHistograms(e6, t4) {
      if (await this._fetchCapabilities(t4 == null ? void 0 : t4.signal), !this.capabilities.operations.supportsComputeStatisticsHistograms)
        throw new s2("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
      e6 = v(d9, e6).clone();
      const { raster: r4, mosaicRule: i7, renderingRule: s6 } = this;
      return s6 && null == e6.renderingRule && (e6.renderingRule = s6), i7 && null == e6.mosaicRule && (e6.mosaicRule = i7), r4 && null == e6.raster && (e6.raster = r4), y6(this.url, e6, this._getRequestOptions(t4));
    }
    getField(e6) {
      const { fieldsIndex: t4 } = this;
      return r(t4) ? t4.get(e6) : void 0;
    }
    getFieldDomain(e6, t4) {
      const r4 = this.getField(e6);
      return r4 ? r4.domain : null;
    }
    fetchImage(e6, t4, r4, i7 = {}) {
      if (null == e6 || null == t4 || null == r4)
        return Promise.reject(new s2("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required."));
      const s6 = this.renderer || this.symbolizer ? this.generateRasterInfo(this.renderingRule, { signal: i7.signal }) : null;
      return $(s6).then((s7) => {
        s7 && (this.rasterInfo = s7);
        const n9 = { imageServiceParameters: this.getExportImageServiceParameters(e6, t4, r4, i7.timeExtent), imageProps: { extent: e6, width: t4, height: r4, format: this.format }, requestAsImageElement: i7.requestAsImageElement && !this.pixelFilter || false, signal: i7.signal };
        return this._requestArrayBuffer(n9);
      });
    }
    fetchKeyProperties(e6) {
      return U(this.parsedUrl.path + "/keyProperties", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e6 == null ? void 0 : e6.renderingRule : null }) }).then((e7) => e7.data);
    }
    fetchRasterAttributeTable(e6) {
      return this.version < 10.1 ? Promise.reject(new s2("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : U(this.parsedUrl.path + "/rasterAttributeTable", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e6 == null ? void 0 : e6.renderingRule : null }) }).then((e7) => x.fromJSON(e7.data));
    }
    getCatalogItemRasterInfo(e6, t4) {
      const r4 = { ...t4, query: this._getQueryParams() };
      return n7(this.parsedUrl.path, e6, r4);
    }
    async getCatalogItemICSInfo(e6, t4) {
      var _a, _b, _c;
      const { data: r4 } = await U(this.parsedUrl.path + "/" + e6 + "/info/ics", { query: this._getQueryParams(), ...t4 }), i7 = r4 && r4.ics;
      if (!i7)
        return;
      let s6 = null;
      try {
        s6 = (await U(this.parsedUrl.path + "/" + e6 + "/info", { query: this._getQueryParams(), ...t4 })).data.extent;
      } catch {
      }
      if (!s6 || !s6.spatialReference)
        return { ics: i7, icsToPixelTransform: null, icsExtent: null, northDirection: null };
      const o7 = this.version >= 10.7 ? U(this.parsedUrl.path + "/" + e6 + "/info/icstopixel", { query: this._getQueryParams(), ...t4 }).then((e7) => e7.data).catch(() => ({})) : {}, a6 = s6.spatialReference, l9 = { geometries: JSON.stringify({ geometryType: "esriGeometryEnvelope", geometries: [s6] }), inSR: a6.wkid || JSON.stringify(a6), outSR: "0:" + e6 }, u9 = U(this.parsedUrl.path + "/project", { query: this._getQueryParams(l9), ...t4 }).then((e7) => e7.data).catch(() => ({})), p13 = 5, c8 = (s6.xmin + s6.xmax) / 2, m9 = (s6.ymax - s6.ymin) / (p13 + 1), d12 = s6.ymin + m9, h6 = [];
      for (let n9 = 0; n9 < p13; n9++)
        h6.push({ x: c8, y: d12 + m9 * n9 });
      const f7 = { geometries: JSON.stringify({ geometryType: "esriGeometryPoint", geometries: h6 }), inSR: a6.wkid || JSON.stringify(a6), outSR: "0:" + e6 }, y9 = U(this.parsedUrl.path + "/project", { query: this._getQueryParams(f7), ...t4 }).then((e7) => e7.data).catch(() => ({})), g4 = await Promise.all([o7, u9, y9]);
      let R4 = g4[0].ipxf;
      if (null == R4) {
        const e7 = (_a = i7.geodataXform) == null ? void 0 : _a.xf_0;
        "topup" === ((_b = e7 == null ? void 0 : e7.name) == null ? void 0 : _b.toLowerCase()) && 6 === ((_c = e7 == null ? void 0 : e7.coefficients) == null ? void 0 : _c.length) && (R4 = { affine: { name: "ics [sensor: Frame] to pixel (column, row) transformation", coefficients: e7.coefficients, cellsizeRatio: 0, type: "GeometricXform" } });
      }
      const v7 = M.fromJSON(g4[1] && g4[1].geometries && g4[1].geometries[0]);
      v7 && (v7.spatialReference = new k({ wkid: 0, imageCoordinateSystem: i7 }));
      const S5 = g4[2].geometries ? g4[2].geometries.filter((e7) => null != e7 && null != e7.x && null != e7.y && "NaN" !== e7.x && "NaN" !== e7.y) : [], b4 = S5.length;
      if (b4 < 3)
        return { ics: i7, icsToPixelTransform: R4, icsExtent: v7, northDirection: null };
      let I = 0, x3 = 0, w6 = 0, _2 = 0;
      for (let n9 = 0; n9 < b4; n9++)
        I += S5[n9].x, x3 += S5[n9].y, w6 += S5[n9].x * S5[n9].x, _2 += S5[n9].x * S5[n9].y;
      const F3 = (b4 * _2 - I * x3) / (b4 * w6 - I * I);
      let D = 0;
      const j6 = S5[p13 - 1].x > S5[0].x, T3 = S5[p13 - 1].y > S5[0].y;
      return F3 === 1 / 0 ? D = T3 ? 90 : 270 : 0 === F3 ? D = j6 ? 0 : 180 : F3 > 0 ? D = j6 ? 180 * Math.atan(F3) / Math.PI : 180 * Math.atan(F3) / Math.PI + 180 : F3 < 0 && (D = T3 ? 180 + 180 * Math.atan(F3) / Math.PI : 360 + 180 * Math.atan(F3) / Math.PI), { ics: i7, icsToPixelTransform: R4, icsExtent: v7, northDirection: D };
    }
    async generateRasterInfo(e6, t4) {
      var _a;
      if ((!e6 || "none" === ((_a = e6 == null ? void 0 : e6.functionName) == null ? void 0 : _a.toLowerCase()) || this._isVectorFieldResampleFunction(e6)) && r(this.serviceRasterInfo))
        return this.serviceRasterInfo;
      const r4 = Ie(e6);
      if (this._functionRasterInfos[r4])
        return this._functionRasterInfos[r4];
      const i7 = this._generateRasterInfo(e6, t4);
      this._functionRasterInfos[r4] = i7;
      try {
        return await i7;
      } catch {
        return this._functionRasterInfos[r4] = null, null;
      }
    }
    getExportImageServiceParameters(e6, t4, r4, i7) {
      var _a;
      e6 = e6.clone().shiftCentralMeridian();
      const s6 = R3(e6.spatialReference, this.parsedUrl.path);
      r(this.serviceRasterInfo) && this.pixelType !== this.serviceRasterInfo.pixelType && (this.exportImageServiceParameters.pixelType = this.pixelType);
      const n9 = this.exportImageServiceParameters.toJSON(), { bandIds: o7, noData: a6 } = n9;
      let { renderingRule: l9 } = n9;
      const u9 = (_a = this.renderingRule) == null ? void 0 : _a.rasterFunctionDefinition, c8 = !this.renderer || "raster-stretch" === this.renderer.type;
      if ((o7 == null ? void 0 : o7.length) && this._hasRenderingRule(this.renderingRule) && !u9 && c8) {
        const e7 = { rasterFunction: "ExtractBand", rasterFunctionArguments: { BandIds: o7 } };
        if ("Stretch" === l9.rasterFunction)
          e7.rasterFunctionArguments.Raster = l9.rasterFunctionArguments.Raster, l9.rasterFunctionArguments.Raster = e7;
        else if ("Colormap" === l9.rasterFunction) {
          const t5 = l9.rasterFunctionArguments.Raster;
          "Stretch" === (t5 == null ? void 0 : t5.rasterFunction) ? (e7.rasterFunctionArguments.Raster = t5.rasterFunctionArguments.Raster, t5.rasterFunctionArguments.Raster = e7) : (e7.rasterFunctionArguments.Raster = t5, l9.rasterFunctionArguments.Raster = e7);
        } else
          e7.rasterFunctionArguments.Raster = l9, l9 = e7;
        n9.bandIds = void 0;
      } else
        n9.bandIds = o7 == null ? void 0 : o7.join(",");
      a6 instanceof Array && a6.length > 0 && (n9.noData = a6.join(","));
      const m9 = this._serviceSupportsMosaicRule ? this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, i7) : null;
      n9.mosaicRule = m9 && JSON.stringify(m9), n9.renderingRule = this._getRenderingRuleString(w3.fromJSON(l9));
      const d12 = {};
      if (i7) {
        const { start: e7, end: t5 } = i7.toJSON();
        e7 && t5 && e7 === t5 ? d12.time = "" + e7 : null == e7 && null == t5 || (d12.time = `${null == e7 ? "null" : e7},${null == t5 ? "null" : t5}`);
      }
      return { bbox: e6.xmin + "," + e6.ymin + "," + e6.xmax + "," + e6.ymax, bboxSR: s6, imageSR: s6, size: t4 + "," + r4, ...n9, ...d12 };
    }
    async getSamples(e6, t4) {
      if (await this._fetchCapabilities(t4 == null ? void 0 : t4.signal), !this.capabilities.operations.supportsGetSamples)
        throw new s2("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
      e6 = v(h5, e6).clone();
      const { raster: r4 } = this;
      return r4 && null == e6.raster && (e6.raster = r4), N2(this.url, e6, this._getRequestOptions(t4));
    }
    async identify(e6, t4) {
      if (await this._fetchCapabilities(t4 == null ? void 0 : t4.signal), !this.capabilities.operations.supportsIdentify)
        throw new s2("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      e6 = v(d10, e6).clone();
      const { raster: r4, mosaicRule: i7, renderingRule: s6 } = this;
      if (s6 && null == e6.renderingRule && (e6.renderingRule = s6), i7 && null == e6.mosaicRule) {
        const t5 = this._combineMosaicRuleWithTimeExtent(i7, e6.timeExtent);
        e6.mosaicRule = e2(t5);
      }
      return r4 && null == e6.raster && (e6.raster = r4), S4(this.url, e6, this._getRequestOptions(t4));
    }
    createQuery() {
      const e6 = new b();
      return e6.outFields = ["*"], e6.returnGeometry = true, e6.where = this.definitionExpression || "1=1", e6;
    }
    async queryRasters(e6, t4) {
      return { query: e6, requestOptions: t4 } = await this._prepareForQuery(e6, t4), s4(this.url, e6, t4);
    }
    async queryObjectIds(e6, t4) {
      return { query: e6, requestOptions: t4 } = await this._prepareForQuery(e6, t4), s5(this.url, e6, t4);
    }
    async queryRasterCount(e6, t4) {
      return { query: e6, requestOptions: t4 } = await this._prepareForQuery(e6, t4), n4(this.url, e6, t4);
    }
    async queryVisibleRasters(e6, t4) {
      var _a, _b;
      if (!e6)
        throw new s2("imagery-layer: query-visible-rasters", "missing query parameter");
      const { pixelSize: r4, returnDomainValues: i7, returnTopmostRaster: s6, showNoDataRecords: n9 } = t4 || { pixelSize: null, returnDomainValues: false, returnTopmostRaster: false, showNoDataRecords: false };
      let a6 = false, l9 = null, u9 = null;
      const m9 = "raster.servicepixelvalue", d12 = this.rasterFunctionNamesIndex;
      if (r(e6.outFields) && (a6 = e6.outFields.some((e7) => !e7.toLowerCase().includes(m9)), this.version >= 10.4)) {
        const t5 = e6.outFields.filter((e7) => e7.toLowerCase().includes(m9) && e7.length > m9.length).map((e7) => {
          const t6 = e7.slice(m9.length + 1);
          return [this._updateRenderingRulesFunctionName(t6, d12), t6];
        });
        l9 = t5.map((e7) => new w3({ functionName: e7[0] })), u9 = t5.map((e7) => e7[1]), 0 === l9.length ? this.renderingRule ? (l9.push(this.renderingRule), u9.push(this.renderingRule.functionName)) : l9 = null : this.renderingRule && !l9.some((e7) => e7.functionName === this.renderingRule.functionName) && (l9.push(this.renderingRule), u9.push(this.renderingRule.functionName));
      }
      const h6 = t(e6.outSpatialReference) || e6.outSpatialReference.equals(this.spatialReference), f7 = e6.timeExtent || this.timeExtent, y9 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, f7), g4 = this._getQueryParams({ geometry: e6.geometry, timeExtent: f7, mosaicRule: y9, renderingRule: this.version < 10.4 ? this.renderingRule : null, renderingRules: l9, pixelSize: r4, returnCatalogItems: a6, returnGeometry: h6, raster: this.raster, maxItemCount: s6 ? 1 : null });
      delete g4.f;
      const R4 = new d10(g4);
      try {
        await this.generateRasterInfo(this.renderingRule);
        const r5 = await S4(this.url, R4, { signal: t4 == null ? void 0 : t4.signal, query: { ...this.customParameters } }), s7 = e6.outFields, o7 = r5.value.toLowerCase().includes("nodata");
        if (!(a6 && !h6 && ((_a = r5 == null ? void 0 : r5.catalogItems) == null ? void 0 : _a.features.length) && (n9 || !o7)))
          return this._processVisibleRastersResponse(r5, { returnDomainValues: i7, templateRRFunctionNames: u9, showNoDataRecords: n9, templateFields: s7 });
        const l10 = this.objectIdField || "ObjectId", c8 = r5.catalogItems.features, m10 = c8.map((e7) => {
          var _a2;
          return (_a2 = e7.attributes) == null ? void 0 : _a2[l10];
        }), d13 = new b({ objectIds: m10, returnGeometry: true, outSpatialReference: e6.outSpatialReference, outFields: [l10] }), f8 = await this.queryRasters(d13);
        return ((_b = f8 == null ? void 0 : f8.features) == null ? void 0 : _b.length) && f8.features.forEach((t5) => {
          c8.forEach((r6) => {
            r6.attributes[l10] === t5.attributes[l10] && (r6.geometry = new v3(t5.geometry), r(e6.outSpatialReference) && (r6.geometry.spatialReference = e6.outSpatialReference));
          });
        }), this._processVisibleRastersResponse(r5, { returnDomainValues: i7, templateRRFunctionNames: u9, showNoDataRecords: n9, templateFields: s7 });
      } catch {
        throw new s2("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
      }
    }
    async fetchVariableStatisticsHistograms(e6, t4) {
      const r4 = U(this.parsedUrl.path + "/statistics", { query: this._getQueryParams({ variable: e6 }), signal: t4 }).then((e7) => {
        var _a;
        return (_a = e7.data) == null ? void 0 : _a.statistics;
      }), i7 = U(this.parsedUrl.path + "/histograms", { query: this._getQueryParams({ variable: e6 }), signal: t4 }).then((e7) => {
        var _a;
        return (_a = e7.data) == null ? void 0 : _a.histograms;
      }), s6 = await Promise.all([r4, i7]);
      return s6[0] && s6[0].forEach((e7) => {
        e7.avg = e7.mean, e7.stddev = e7.standardDeviation;
      }), { statistics: s6[0] || null, histograms: s6[1] || null };
    }
    async createFlowMesh(e6, t4) {
      const r4 = this._rasterJobHandler.instance;
      return r4 ? r4.createFlowMesh(e6, t4) : u4(e6.meshType, e6.simulationSettings, e6.flowData, r(t4.signal) ? t4.signal : new AbortController().signal);
    }
    async _fetchService(e6) {
      await this._fetchServiceInfo(e6), r(this.serviceRasterInfo) && !this.rasterInfo && (this.rasterInfo = this.serviceRasterInfo);
      const t4 = this.sourceJSON, r4 = r(this.serviceRasterInfo) ? Promise.resolve(this.serviceRasterInfo) : m3(this.parsedUrl.path, t4, { signal: e6, query: this._getQueryParams() }).then((e7) => (this._set("serviceRasterInfo", e7), e7)), i7 = this._hasRenderingRule(this.renderingRule) ? this.generateRasterInfo(this.renderingRule, { signal: e6 }) : null, s6 = this._getRasterFunctionInfos();
      return Promise.all([r4, i7, s6]).then((e7) => {
        e7[1] ? this._set("rasterInfo", e7[1]) : this._set("rasterInfo", e7[0]), e7[2] && this._set("rasterFunctionInfos", e7[2]), this.renderer && !this._isSupportedRenderer(this.renderer) && (this._set("renderer", null), Re.warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("renderer", this._configRenderer(this.renderer)), this.own(l2(() => this.renderingRule, (e8) => {
          (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this.generateRasterInfo(e8).then((e9) => {
            e9 && (this.rasterInfo = e9);
          });
        }));
        const { serviceRasterInfo: t5 } = this;
        r(t5) && t5.multidimensionalInfo && this._updateMultidimensionalDefinition(t5);
      });
    }
    _combineMosaicRuleWithTimeExtent(e6, t4) {
      var _a;
      const r4 = this.timeInfo;
      if (t(e6) || t(this.multidimensionalInfo) || t(t4) || t(r4 == null ? void 0 : r4.startField))
        return e6;
      const { startField: i7 } = r4, s6 = this.multidimensionalInfo.variables.some((e7) => e7.dimensions.some((e8) => e8.name === i7)) ? i7 : "StdTime";
      if (e6 = e6.clone(), "mosaic-dataset" === this._serviceSourceType)
        return e6.multidimensionalDefinition = (_a = e6.multidimensionalDefinition) == null ? void 0 : _a.filter((e7) => e7.dimensionName !== s6), this._cleanupMultidimensionalDefinition(e6);
      e6.multidimensionalDefinition = e6.multidimensionalDefinition || [];
      const n9 = e6.multidimensionalDefinition.filter((e7) => e7.dimensionName === s6), o7 = r(t4.start) ? t4.start.getTime() : null, a6 = r(t4.end) ? t4.end.getTime() : null, l9 = null == o7 || null == a6 || o7 === a6, u9 = l9 ? [o7 || a6] : [[o7, a6]], m9 = this.version >= 10.8;
      if (n9.length)
        n9.forEach((e7) => {
          e7.dimensionName === s6 && (m9 ? (e7.dimensionName = null, e7.isSlice = null, e7.values = null) : (e7.isSlice = l9, e7.values = u9));
        });
      else if (!m9) {
        const t5 = e6.multidimensionalDefinition.filter((e7) => null != e7.variableName && null == e7.dimensionName);
        t5.length ? t5.forEach((e7) => {
          e7.dimensionName = s6, e7.isSlice = l9, e7.values = u9;
        }) : e6.multidimensionalDefinition.push(new p3({ variableName: "", dimensionName: s6, isSlice: l9, values: u9 }));
      }
      return this._cleanupMultidimensionalDefinition(e6);
    }
    _cleanupMultidimensionalDefinition(e6) {
      return t(e6) ? null : (e6.multidimensionalDefinition && (e6.multidimensionalDefinition = e6.multidimensionalDefinition.filter((e7) => !(!e7.variableName && !e7.dimensionName)), 0 === e6.multidimensionalDefinition.length && (e6.multidimensionalDefinition = null)), "mosaic-dataset" !== this._serviceSourceType && null == e6.multidimensionalDefinition ? null : e6);
    }
    async _prepareForQuery(e6, t4) {
      if (await this._fetchCapabilities(t4 == null ? void 0 : t4.signal), !this.capabilities.operations.supportsQuery)
        throw new s2("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      return e6 = r(e6) ? v(b, e6) : this.createQuery(), t4 = this._getRequestOptions(t4), this.raster && (t4.query = { ...t4.query, raster: this.raster }), { query: e6, requestOptions: t4 };
    }
    async _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const e6 = new n6();
      this._rasterJobHandler.connectionPromise = e6.initialize().then(() => {
        this._rasterJobHandler.instance = e6;
      }, () => null), await this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null;
    }
    _isSupportedRenderer(e6) {
      const { rasterInfo: t4, renderingRule: r4 } = this;
      return "unique-value" === e6.type && this._hasRenderingRule(r4) && 1 === t4.bandCount && ["u8", "s8"].includes(t4.pixelType) || V(this.rasterInfo).includes(this.renderer.type);
    }
    async _fetchCapabilities(e6) {
      return this.capabilities || await this._fetchServiceInfo(e6), this.capabilities;
    }
    async _fetchServiceInfo(e6) {
      var _a;
      let t4 = this.sourceJSON;
      if (!t4) {
        const { data: r4, ssl: i7 } = await U(this.parsedUrl.path, { query: this._getQueryParams(), signal: e6 });
        t4 = r4, this.sourceJSON = t4, i7 && (this.url = this.url.replace(/^http:/i, "https:"));
      }
      if (((_a = t4.capabilities) == null ? void 0 : _a.toLowerCase().split(",").map((e7) => e7.trim()).indexOf("tilesonly")) > -1)
        throw new s2("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
      this.read(t4, { origin: "service", url: this.parsedUrl });
    }
    _isMosaicDataset(e6) {
      var _a;
      return e6.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e6.serviceSourceType : ((_a = e6.fields) == null ? void 0 : _a.length) > 0;
    }
    _isMosaicRuleSupported(e6) {
      var _a;
      if (!e6)
        return false;
      const t4 = this._isMosaicDataset(e6), r4 = e6.currentVersion >= 10.71 && e6.hasMultidimensions && e6.timeInfo && !(e6.objectIdField && ((_a = e6.fields) == null ? void 0 : _a.length) > 1);
      return t4 || r4;
    }
    _isVectorFieldResampleFunction(e6) {
      if (t(e6))
        return false;
      const { functionName: t4, functionArguments: r4 } = e6, i7 = "resample" === (t4 == null ? void 0 : t4.toLowerCase()), s6 = (r4 == null ? void 0 : r4.ResampleType) || (r4 == null ? void 0 : r4.resampleType);
      return i7 && (7 === s6 || 10 === s6);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e6) {
      var _a, _b;
      if (!this._isPicture() && !this.pixelFilter || this._isVectorDataSet()) {
        if (!this.bandIds && this.rasterInfo.bandCount >= 3) {
          const e7 = B(this.rasterInfo);
          !e7 || 3 === this.rasterInfo.bandCount && 0 === e7[0] && 1 === e7[1] && 2 === e7[2] || (this.bandIds = e7);
        }
        e6 || (e6 = k2(this.rasterInfo, { bandIds: this.bandIds, variableName: this.renderingRule ? null : (_b = (_a = this.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition) == null ? void 0 : _b[0].variableName }));
        const t4 = te(e6.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = t4, this.symbolizer.rasterInfo = this.rasterInfo) : this.symbolizer = new U2({ rendererJSON: t4, rasterInfo: this.rasterInfo }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e6;
    }
    _clonePixelData(e6) {
      return null == e6 ? e6 : { extent: e6.extent && e6.extent.clone(), pixelBlock: r(e6.pixelBlock) && e6.pixelBlock.clone() };
    }
    _getQueryParams(e6) {
      r(e6 == null ? void 0 : e6.renderingRule) && "string" != typeof e6.renderingRule && (e6.renderingRule = this._getRenderingRuleString(e6.renderingRule));
      const { raster: t4, viewId: r4 } = this;
      return { raster: t4, viewId: r4, f: "json", ...e6, ...this.customParameters };
    }
    _getRequestOptions(e6) {
      return { ...e6, query: { ...e6 == null ? void 0 : e6.query, ...this.customParameters } };
    }
    _decodePixelBlock(e6, t4, r4) {
      return this._rasterJobHandler.instance ? this._rasterJobHandler.instance.decode({ data: e6, options: t4 }) : S2(e6, t4, r4);
    }
    async _getRasterFunctionInfos(e6) {
      var _a;
      const t4 = this.sourceJSON.rasterFunctionInfos;
      if (this.serviceRasterInfo)
        return t4;
      if (t4 && this.version >= 10.3) {
        if (1 === t4.length && "none" === t4[0].name.toLowerCase())
          return t4;
        return (_a = (await U(this.parsedUrl.path + "/rasterFunctionInfos", { query: this._getQueryParams(), signal: e6 })).data) == null ? void 0 : _a.rasterFunctionInfos;
      }
      return null;
    }
    async _requestArrayBuffer(e6) {
      var _a;
      const { imageProps: t4, requestAsImageElement: r4, signal: i7 } = e6;
      if (r4 && !this.pixelFilter && ((_a = t4.format) == null ? void 0 : _a.indexOf("png")) > -1) {
        return { imageElement: (await U(this.parsedUrl.path + "/exportImage", { responseType: "image", query: this._getQueryParams({ f: "image", ...e6.imageServiceParameters }), signal: i7 })).data, params: t4 };
      }
      const s6 = this._initJobHandler(), a6 = U(this.parsedUrl.path + "/exportImage", { responseType: "array-buffer", query: this._getQueryParams({ f: "image", ...e6.imageServiceParameters }), signal: i7 }), l9 = (await Promise.all([a6, s6]))[0].data, u9 = t4.format || "jpgpng";
      let p13 = u9;
      if ("bsq" !== p13 && "bip" !== p13 && (p13 = P(l9)), !p13)
        throw new s2("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(l9)));
      const c8 = { signal: i7 }, m9 = "gif" === u9 || "bmp" === u9 || u9.includes("png") && ("png" === p13 || "jpg" === p13) ? S2(l9, { useCanvas: true, ...t4 }, c8) : this._decodePixelBlock(l9, { width: t4.width, height: t4.height, planes: null, pixelType: null, noDataValue: null, format: u9 }, c8);
      return { pixelData: { pixelBlock: await m9, extent: t4.extent }, params: t4 };
    }
    _generateRasterInfo(e6, t4) {
      const r4 = { ...t4, query: this._getQueryParams() };
      return f3(this.parsedUrl.path, e6, r4);
    }
    _isValidCustomizedMosaicRule(e6) {
      var _a;
      return e6 && JSON.stringify(e6.toJSON()) !== JSON.stringify((_a = this._defaultServiceMosaicRule) == null ? void 0 : _a.toJSON());
    }
    _updateMultidimensionalDefinition(e6) {
      if (this._isValidCustomizedMosaicRule(this.mosaicRule))
        return;
      const t4 = i4(e6);
      if (r(t4) && t4.length > 0) {
        this.mosaicRule = this.mosaicRule || new y5();
        const e7 = this.mosaicRule.multidimensionalDefinition;
        (!e7 || e7 && e7.length <= 0) && (this.mosaicRule.multidimensionalDefinition = t4);
      }
    }
    _processVisibleRastersResponse(e6, r4) {
      r4 = r4 || {};
      const i7 = e6.value, { templateRRFunctionNames: s6, showNoDataRecords: n9, returnDomainValues: o7, templateFields: a6 } = r4, l9 = e6.processedValues;
      let u9 = e6.catalogItems && e6.catalogItems.features, c8 = e6.properties && e6.properties.Values && e6.properties.Values.map((e7) => e7.replace(/ /gi, ", ")) || [];
      const m9 = this.objectIdField || "ObjectId", d12 = "string" == typeof i7 && i7.toLowerCase().includes("nodata"), h6 = [];
      if (i7 && !u9 && !d12) {
        const e7 = {};
        e7[m9] = 0;
        c8 = [i7], u9 = [new g(this.fullExtent, null, e7)];
      }
      if (!u9)
        return [];
      let f7, y9, g4;
      this._updateResponseFieldNames(u9, a6), d12 && !n9 && (u9 = []);
      for (let t4 = 0; t4 < u9.length; t4++) {
        if (f7 = u9[t4], null != i7) {
          if (y9 = c8[t4], g4 = this.renderingRule && l9 && l9.length > 0 && s6 && s6.length > 0 && s6.includes(this.renderingRule.functionName) ? l9[s6.indexOf(this.renderingRule.functionName)] : i7, "nodata" === y9.toLowerCase() && !n9)
            continue;
          const e7 = "Raster.ItemPixelValue", r5 = "Raster.ServicePixelValue";
          f7.attributes[e7] = y9, f7.attributes[r5] = g4, this._updateFeatureWithMagDirValues(f7, y9);
          const o8 = this.fields && this.fields.length > 0;
          let a7 = this.renderingRule && r(this.serviceRasterInfo) && this.serviceRasterInfo.attributeTable ? o8 ? y9 : i7 : g4;
          this.renderingRule || (a7 = o8 ? y9 : i7), this._updateFeatureWithRasterAttributeTableValues(f7, a7);
        }
        if (f7.sourceLayer = f7.layer = this, o7 && this._updateFeatureWithDomainValues(f7), s6 && l9 && s6.length === l9.length)
          for (let e7 = 0; e7 < s6.length; e7++) {
            const t5 = "Raster.ServicePixelValue." + s6[e7];
            f7.attributes[t5] = l9[e7];
          }
        h6.push(u9[t4]);
      }
      return h6;
    }
    _updateFeatureWithRasterAttributeTableValues(e6, t4) {
      const r4 = this.rasterInfo && this.rasterInfo.attributeTable || r(this.serviceRasterInfo) && this.serviceRasterInfo.attributeTable, i7 = r4 && r4.features;
      if (!i7)
        return;
      const s6 = r4.fields, n9 = s6.map((e7) => e7.name).filter((e7) => "value" === e7.toLowerCase()), o7 = n9 && n9[0];
      if (!o7)
        return;
      const a6 = i7.filter((e7) => e7.attributes[o7] === (null != t4 ? parseInt(t4, 10) : null));
      a6 && a6[0] && s6.forEach((t5) => {
        const r5 = this.rasterAttributeTableFieldPrefix + t5.name;
        e6.attributes[r5] = a6[0].attributes[t5.name];
      });
    }
    _updateFeatureWithMagDirValues(e6, t4) {
      if (!this._isVectorDataSet())
        return;
      const r4 = t4.split(/,\s*/).map((e7) => parseFloat(e7)), i7 = r4.map((e7) => [e7]), s6 = r4.map((e7) => ({ minValue: e7, maxValue: e7, noDataValue: null })), n9 = new u({ height: 1, width: 1, pixelType: "f32", pixels: i7, statistics: s6 });
      null != this.pixelFilter && this.pixelFilter({ pixelBlock: n9, extent: new M(0, 0, 0, 0, this.spatialReference) });
      const o7 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n9.pixels[0][0], n9.pixels[1][0]] : u2([n9.pixels[0][0], n9.pixels[1][0]]);
      e6.attributes["Raster.Magnitude"] = o7[0], e6.attributes["Raster.Direction"] = o7[1];
    }
    _updateFeatureWithDomainValues(e6) {
      const t4 = this.fields && this.fields.filter((e7) => e7.domain && "coded-value" === e7.domain.type);
      null != t4 && t4.forEach((t5) => {
        const r4 = e6.attributes[t5.name];
        if (null != r4) {
          const i7 = t5.domain.codedValues.find((e7) => e7.code === r4);
          i7 && (e6.attributes[t5.name] = i7.name);
        }
      });
    }
    _updateResponseFieldNames(e6, t4) {
      if (!t4 || t4.length < 1)
        return;
      const r4 = this.fieldsIndex;
      t(r4) || e6.forEach((e7) => {
        if (e7 && e7.attributes) {
          for (const i7 of t4)
            if (r4.has(i7)) {
              const t5 = r4.get(i7).name;
              t5 !== i7 && (e7.attributes[i7] = e7.attributes[t5], delete e7.attributes[t5]);
            }
        }
      });
    }
    _getRenderingRuleString(e6) {
      if (this._hasRenderingRule(e6)) {
        let t4 = e6.toJSON();
        return t4 = t4.rasterFunctionDefinition ?? t4, (t4.thumbnail || t4.thumbnailEx) && (t4.thumbnail = t4.thumbnailEx = null), JSON.stringify(t4);
      }
      return null;
    }
    _hasRenderingRule(e6) {
      return e6 && e6.functionName && "none" !== e6.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e6, t4) {
      if (!e6 || e6.length < 1)
        return;
      if ("Raw" === e6)
        return e6.replace("Raw", "None");
      const r4 = e6.toLowerCase().replace(/ /gi, "_");
      return t4.has(r4) ? t4.get(r4) : e6;
    }
    _isRFTJson(e6) {
      return e6 && e6.name && e6.arguments && e6.function && e6.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _readCapabilities(e6) {
      const t4 = e6.capabilities ? e6.capabilities.toLowerCase().split(",").map((e7) => e7.trim()) : ["image", "catalog"], { currentVersion: r4, advancedQueryCapabilities: i7, maxRecordCount: s6 } = e6, n9 = t4.includes("image"), o7 = "esriImageServiceDataTypeElevation" === e6.serviceDataType, a6 = !!(e6.spatialReference || e6.extent && e6.extent.spatialReference), l9 = t4.includes("edit");
      return { data: { supportsAttachment: false }, operations: { supportsComputeHistograms: n9, supportsExportImage: n9, supportsIdentify: n9, supportsMeasure: t4.includes("mensuration") && a6, supportsDownload: t4.includes("download"), supportsQuery: t4.includes("catalog") && e6.fields && e6.fields.length > 0, supportsGetSamples: r4 >= 10.2 && n9, supportsProject: r4 >= 10.3 && n9, supportsComputeStatisticsHistograms: r4 >= 10.4 && n9, supportsQueryBoundary: r4 >= 10.6 && n9, supportsCalculateVolume: r4 >= 10.7 && o7, supportsComputePixelLocation: r4 >= 10.7 && t4.includes("catalog"), supportsComputeAngles: r4 >= 10.91, supportsAdd: l9, supportsDelete: l9, supportsEditing: l9, supportsUpdate: l9, supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsChangeTracking: false, supportsQueryAttachments: false, supportsResizeAttachments: false, supportsSync: false, supportsExceedsLimitStatistics: false, supportsQueryAnalytics: false, supportsQueryTopFeatures: false }, query: { maxRecordCount: s6, maxRecordCountFactor: void 0, supportsStatistics: !!(i7 == null ? void 0 : i7.supportsStatistics), supportsOrderBy: !!(i7 == null ? void 0 : i7.supportsOrderBy), supportsDistinct: !!(i7 == null ? void 0 : i7.supportsDistinct), supportsPagination: !!(i7 == null ? void 0 : i7.supportsPagination), supportsStandardizedQueriesOnly: !!(i7 == null ? void 0 : i7.useStandardizedQueries), supportsPercentileStatistics: !!(i7 == null ? void 0 : i7.supportsPercentileStatistics), supportsCentroid: !!(i7 == null ? void 0 : i7.supportsReturningGeometryCentroid), supportsDistance: !!(i7 == null ? void 0 : i7.supportsQueryWithDistance), supportsExtent: !!(i7 == null ? void 0 : i7.supportsReturningQueryExtent), supportsGeometryProperties: !!(i7 == null ? void 0 : i7.supportsReturningGeometryProperties), supportsHavingClause: !!(i7 == null ? void 0 : i7.supportsHavingClause), supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryGeometry: false, supportsResultType: false, supportsMaxRecordCountFactor: false, supportsSqlExpression: false, supportsTopFeaturesQuery: false, supportsQueryByOthers: false, supportsHistoricMoment: false, supportsFormatPBF: false, supportsDisjointSpatialRelationship: false, supportsCacheHint: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: !!(i7 == null ? void 0 : i7.supportsDefaultSR), supportsCompactGeometry: false, standardMaxRecordCount: void 0, tileMaxRecordCount: void 0 } };
    }
  };
  return e([d()], u8.prototype, "_functionRasterInfos", void 0), e([d()], u8.prototype, "_rasterJobHandler", void 0), e([d({ dependsOn: ["_serviceSupportsMosaicRule"] })], u8.prototype, "_defaultServiceMosaicRule", void 0), e([o2("_defaultServiceMosaicRule", ["defaultMosaicMethod"])], u8.prototype, "readDefaultServiceMosaicRule", null), e([d()], u8.prototype, "_cachedRendererJson", void 0), e([d({ readOnly: true })], u8.prototype, "_serviceSourceType", void 0), e([o2("_serviceSourceType", ["serviceSourceType", "fields"])], u8.prototype, "readServiceSourceType", null), e([d({ readOnly: true })], u8.prototype, "_serviceSupportsMosaicRule", void 0), e([o2("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], u8.prototype, "readServiceSupportsMosaicRule", null), e([d()], u8.prototype, "rasterAttributeTableFieldPrefix", void 0), e([d({ readOnly: true })], u8.prototype, "rasterFunctionNamesIndex", null), e([d()], u8.prototype, "adjustAspectRatio", void 0), e([d({ readOnly: true }), o3("serviceRasterInfo.bandCount")], u8.prototype, "bandCount", void 0), e([d({ type: [S], json: { write: true } })], u8.prototype, "bandIds", void 0), e([o2("bandIds")], u8.prototype, "readBandIds", null), e([d({ readOnly: true, json: { read: false } })], u8.prototype, "capabilities", void 0), e([o2("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], u8.prototype, "readCapabilities", null), e([d({ type: Number })], u8.prototype, "compressionQuality", void 0), e([r2("compressionQuality")], u8.prototype, "writeCompressionQuality", null), e([d({ type: Number })], u8.prototype, "compressionTolerance", void 0), e([r2("compressionTolerance")], u8.prototype, "writeCompressionTolerance", null), e([d({ json: { read: { source: "copyrightText" } } })], u8.prototype, "copyright", void 0), e([d({ type: String, json: { name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], u8.prototype, "definitionExpression", void 0), e([d({ readOnly: true, constructOnly: true })], u8.prototype, "exportImageServiceParameters", void 0), e([d()], u8.prototype, "rasterInfo", void 0), e([d({ readOnly: true, type: [y] })], u8.prototype, "fields", void 0), e([d({ readOnly: true })], u8.prototype, "fieldsIndex", null), e([d({ type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"], json: { write: true } })], u8.prototype, "format", null), e([o2("service", "format", ["serviceDataType"])], u8.prototype, "readFormat", null), e([d({ type: M })], u8.prototype, "fullExtent", void 0), e([d({ readOnly: true })], u8.prototype, "hasMultidimensions", void 0), e([d({ json: { read: { source: "maxImageHeight" } } })], u8.prototype, "imageMaxHeight", void 0), e([d({ json: { read: { source: "maxImageWidth" } } })], u8.prototype, "imageMaxWidth", void 0), e([d({ type: String, json: { type: o6.jsonValues, read: o6.read, write: o6.write } })], u8.prototype, "interpolation", void 0), e([d()], u8.prototype, "minScale", void 0), e([o2("service", "minScale")], u8.prototype, "readMinScale", null), e([d()], u8.prototype, "maxScale", void 0), e([o2("service", "maxScale")], u8.prototype, "readMaxScale", null), e([d({ type: y5 })], u8.prototype, "mosaicRule", null), e([o2("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], u8.prototype, "readMosaicRule", null), e([r2("mosaicRule")], u8.prototype, "writeMosaicRule", null), e([d({ readOnly: true }), o3("serviceRasterInfo.multidimensionalInfo")], u8.prototype, "multidimensionalInfo", void 0), e([d({ json: { type: S } })], u8.prototype, "noData", void 0), e([r2("noData")], u8.prototype, "writeNoData", null), e([d({ type: String, json: { type: i3.jsonValues, read: i3.read, write: i3.write } })], u8.prototype, "noDataInterpretation", void 0), e([d({ type: String, readOnly: true, json: { read: { source: ["fields"] } } })], u8.prototype, "objectIdField", void 0), e([o2("objectIdField")], u8.prototype, "readObjectIdField", null), e([d({})], u8.prototype, "geometryType", void 0), e([d({})], u8.prototype, "typeIdField", void 0), e([d({})], u8.prototype, "types", void 0), e([d({ readOnly: true })], u8.prototype, "parsedUrl", null), e([d({ readOnly: true }), o3("serviceRasterInfo.pixelSize.x")], u8.prototype, "pixelSizeX", void 0), e([d({ readOnly: true }), o3("serviceRasterInfo.pixelSize.y")], u8.prototype, "pixelSizeY", void 0), e([d({ type: Function })], u8.prototype, "pixelFilter", void 0), e([d()], u8.prototype, "raster", void 0), e([d()], u8.prototype, "viewId", void 0), e([d({ types: l3, json: { name: "layerDefinition.drawingInfo.renderer", origins: { "web-scene": { types: i2, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e6) => ({ enabled: e6 && "vector-field" !== e6.type && "flow" !== e6.type }) } } } } })], u8.prototype, "renderer", null), e([o2("renderer")], u8.prototype, "readRenderer", null), e([r2("renderer")], u8.prototype, "writeRenderer", null), e([d()], u8.prototype, "symbolizer", void 0), e([d(w2)], u8.prototype, "opacity", void 0), e([d({ readOnly: true }), o3("serviceRasterInfo.attributeTable")], u8.prototype, "rasterAttributeTable", void 0), e([d({ readOnly: true })], u8.prototype, "rasterFields", null), e([d({ constructOnly: true })], u8.prototype, "rasterFunctionInfos", void 0), e([d({ type: w3 })], u8.prototype, "renderingRule", null), e([o2("renderingRule", ["renderingRule", "rasterFunctionInfos"])], u8.prototype, "readRenderingRule", null), e([r2("renderingRule")], u8.prototype, "writeRenderingRule", null), e([d()], u8.prototype, "serviceDataType", void 0), e([d({ readOnly: true, type: k })], u8.prototype, "spatialReference", void 0), e([o2("spatialReference", ["spatialReference", "extent"])], u8.prototype, "readSpatialReference", null), e([d({ json: { type: ve.jsonValues } })], u8.prototype, "pixelType", void 0), e([o2("pixelType")], u8.prototype, "readPixelType", null), e([r2("pixelType")], u8.prototype, "writePixelType", null), e([d({ constructOnly: true, type: l4 })], u8.prototype, "serviceRasterInfo", void 0), e([d()], u8.prototype, "sourceJSON", void 0), e([d(f)], u8.prototype, "url", void 0), e([d({ readOnly: true })], u8.prototype, "version", void 0), e([o2("version", ["currentVersion", "fields", "timeInfo"])], u8.prototype, "readVersion", null), u8 = e([n("esri.layers.mixins.ArcGISImageService")], u8), u8;
};

// node_modules/@arcgis/core/layers/ImageryLayer.js
var L2 = class extends a2(a3(n2(t2(c2(v5(xe(o4(p2(O(b2)))))))))) {
  constructor(...e6) {
    super(...e6), this.legendEnabled = true, this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.type = "imagery";
  }
  normalizeCtorArgs(e6, r4) {
    return "string" == typeof e6 ? { url: e6, ...r4 } : e6;
  }
  load(e6) {
    const r4 = r(e6) ? e6.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e6).catch(w).then(() => this._fetchService(r4))), Promise.resolve(this);
  }
  writeOperationalLayerType(e6, r4, t4) {
    var _a;
    const o7 = "vector-field" === ((_a = this.renderer) == null ? void 0 : _a.type);
    r4[t4] = o7 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  createPopupTemplate(e6) {
    const r4 = this.rasterFields, t4 = this.title, o7 = /* @__PURE__ */ new Set();
    let i7 = false, s6 = false;
    this.capabilities && (i7 = this.capabilities.operations.supportsQuery && this.fields && this.fields.length > 0, s6 = "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType);
    const a5 = /* @__PURE__ */ new Set();
    i7 && a5.add("raster.itempixelvalue");
    for (const p13 of r4) {
      const e7 = p13.name.toLowerCase();
      a5.has(e7) || e7.includes("raster.servicepixelvalue.") || o7.add(p13.name);
    }
    return s6 && o7.add("raster.magnitude").add("raster.direction"), d4({ fields: r4, title: t4 }, { ...e6, visibleFieldNames: o7 });
  }
  queryFeatures(e6, r4) {
    return this.queryRasters(e6, r4).then((e7) => {
      if (e7 == null ? void 0 : e7.features)
        for (const r5 of e7.features)
          r5.layer = r5.sourceLayer = this;
      return e7;
    });
  }
  queryFeatureCount(e6, r4) {
    return this.queryRasterCount(e6, r4);
  }
  redraw() {
    this.emit("redraw");
  }
  serviceSupportsSpatialReference(e6) {
    return e3(this, e6);
  }
};
e([d(c)], L2.prototype, "legendEnabled", void 0), e([d({ type: ["show", "hide"] })], L2.prototype, "listMode", void 0), e([d({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], L2.prototype, "isReference", void 0), e([d({ type: ["ArcGISImageServiceLayer"], json: { origins: { "web-map": { type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"], read: false, write: { target: "layerType", ignoreOrigin: true } } } } })], L2.prototype, "operationalLayerType", void 0), e([r2("web-map", "operationalLayerType")], L2.prototype, "writeOperationalLayerType", null), e([d(p)], L2.prototype, "popupEnabled", void 0), e([d({ type: B2, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], L2.prototype, "popupTemplate", void 0), e([d({ readOnly: true })], L2.prototype, "defaultPopupTemplate", null), e([d({ readOnly: true, json: { read: false } })], L2.prototype, "type", void 0), L2 = e([n("esri.layers.ImageryLayer")], L2);
var T2 = L2;
export {
  T2 as default
};
//# sourceMappingURL=ImageryLayer-AQNQSEV3.js.map
