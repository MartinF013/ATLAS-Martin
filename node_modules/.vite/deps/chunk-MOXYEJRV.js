import {
  n as n3
} from "./chunk-MLAOYRDT.js";
import {
  _
} from "./chunk-W2HLA6I3.js";
import {
  S as S2
} from "./chunk-DLM6NKXW.js";
import {
  e as e4
} from "./chunk-TQLSOIYV.js";
import {
  e as e3
} from "./chunk-YFBAFAZ2.js";
import {
  e as e2
} from "./chunk-LUU3J646.js";
import {
  y
} from "./chunk-3NPGGTI6.js";
import {
  h,
  n as n2,
  o,
  u as u2
} from "./chunk-ASC3X65B.js";
import {
  S,
  e,
  u
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/verticalOffsetUtils.js
var u3 = class {
  constructor() {
    this._transform = e3(), this._transformInverse = new M({ value: this._transform }, h, e3), this._transformInverseTranspose = new M(this._transformInverse, o, e3), this._transformTranspose = new M({ value: this._transform }, o, e3), this._transformInverseRotation = new M({ value: this._transform }, y, e2);
  }
  _invalidateLazyTransforms() {
    this._transformInverse.invalidate(), this._transformInverseTranspose.invalidate(), this._transformTranspose.invalidate(), this._transformInverseRotation.invalidate();
  }
  get transform() {
    return this._transform;
  }
  get inverse() {
    return this._transformInverse.value;
  }
  get inverseTranspose() {
    return this._transformInverseTranspose.value;
  }
  get inverseRotation() {
    return this._transformInverseRotation.value;
  }
  get transpose() {
    return this._transformTranspose.value;
  }
  setTransformMatrix(t) {
    n2(this._transform, t);
  }
  multiplyTransform(t) {
    u2(this._transform, this._transform, t);
  }
  set(t) {
    n2(this._transform, t), this._invalidateLazyTransforms();
  }
  setAndInvalidateLazyTransforms(t, s) {
    this.setTransformMatrix(t), this.multiplyTransform(s), this._invalidateLazyTransforms();
  }
};
var M = class {
  constructor(t, s, e5) {
    this.original = t, this.update = s, this.dirty = true, this.transform = e5();
  }
  invalidate() {
    this.dirty = true;
  }
  get value() {
    return this.dirty && (this.update(this.transform, this.original.value), this.dirty = false), this.transform;
  }
};
var v = class {
  constructor(t = 0) {
    this.offset = t, this.tmpVertex = n();
  }
  applyToVertex(t, s, e5) {
    const i = t + this.localOrigin[0], r2 = s + this.localOrigin[1], a = e5 + this.localOrigin[2], o2 = this.offset / Math.sqrt(i * i + r2 * r2 + a * a);
    return this.tmpVertex[0] = t + i * o2, this.tmpVertex[1] = s + r2 * o2, this.tmpVertex[2] = e5 + a * o2, this.tmpVertex;
  }
  applyToAabb(t) {
    for (let r2 = 0; r2 < 3; ++r2)
      O[r2] = t[0 + r2] + this.localOrigin[r2], z[r2] = t[3 + r2] + this.localOrigin[r2], T[r2] = O[r2];
    const s = this.applyToVertex(O[0], O[1], O[2]);
    for (let r2 = 0; r2 < 3; ++r2)
      t[r2] = s[r2], t[r2 + 3] = s[r2];
    const e5 = (s2) => {
      const e6 = this.applyToVertex(s2[0], s2[1], s2[2]);
      for (let i2 = 0; i2 < 3; ++i2)
        t[i2 + 0] = Math.min(t[i2 + 0], e6[i2]), t[i2 + 3] = Math.max(t[i2 + 3], e6[i2]);
    };
    for (let r2 = 1; r2 < 8; ++r2) {
      for (let t2 = 0; t2 < 3; ++t2)
        T[t2] = 0 == (r2 & 1 << t2) ? O[t2] : z[t2];
      e5(T);
    }
    let i = 0;
    for (let r2 = 0; r2 < 3; ++r2) {
      O[r2] * z[r2] < 0 && (i |= 1 << r2);
    }
    if (0 !== i && 7 !== i) {
      for (let r2 = 0; r2 < 8; ++r2)
        if (0 == (i & r2)) {
          for (let t2 = 0; t2 < 3; ++t2)
            i[t2] ? T[t2] = 0 : T[t2] = 0 != (r2 & 1 << t2) ? O[t2] : z[t2];
          e5(T);
        }
    }
    for (let r2 = 0; r2 < 3; ++r2)
      t[r2 + 0] -= this.localOrigin[r2], t[r2 + 3] -= this.localOrigin[r2];
    return t;
  }
};
var O = n();
var z = n();
var T = n();
var g = class {
  constructor(t = 0) {
    this.componentLocalOriginLength = 0, this._tmpVertex = n(), this._mbs = _(), this._obb = { center: n(), halfSize: n3(), quaternion: null }, this._totalOffset = 0, this._offset = 0, this._resetOffset(t);
  }
  _resetOffset(t) {
    this._offset = t, this._totalOffset = t;
  }
  set offset(t) {
    this._resetOffset(t);
  }
  get offset() {
    return this._offset;
  }
  set componentOffset(t) {
    this._totalOffset = this._offset + t;
  }
  set localOrigin(t) {
    this.componentLocalOriginLength = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
  }
  applyToVertex(t, s, e5) {
    const i = t, r2 = s, a = e5 + this.componentLocalOriginLength, o2 = this._totalOffset / Math.sqrt(i * i + r2 * r2 + a * a);
    return this._tmpVertex[0] = t + i * o2, this._tmpVertex[1] = s + r2 * o2, this._tmpVertex[2] = e5 + a * o2, this._tmpVertex;
  }
  applyToAabb(t) {
    const s = t[0], e5 = t[1], i = t[2] + this.componentLocalOriginLength, r2 = t[3], a = t[4], o2 = t[5] + this.componentLocalOriginLength, h2 = s * r2 < 0 ? 0 : Math.min(Math.abs(s), Math.abs(r2)), n4 = e5 * a < 0 ? 0 : Math.min(Math.abs(e5), Math.abs(a)), f = i * o2 < 0 ? 0 : Math.min(Math.abs(i), Math.abs(o2)), l = Math.sqrt(h2 * h2 + n4 * n4 + f * f);
    if (l < this._totalOffset)
      return t[0] -= s < 0 ? this._totalOffset : 0, t[1] -= e5 < 0 ? this._totalOffset : 0, t[2] -= i < 0 ? this._totalOffset : 0, t[3] += r2 > 0 ? this._totalOffset : 0, t[4] += a > 0 ? this._totalOffset : 0, t[5] += o2 > 0 ? this._totalOffset : 0, t;
    const m = Math.max(Math.abs(s), Math.abs(r2)), b = Math.max(Math.abs(e5), Math.abs(a)), _2 = Math.max(Math.abs(i), Math.abs(o2)), c = Math.sqrt(m * m + b * b + _2 * _2), p = this._totalOffset / c, u4 = this._totalOffset / l;
    return t[0] += s * (s > 0 ? p : u4), t[1] += e5 * (e5 > 0 ? p : u4), t[2] += i * (i > 0 ? p : u4), t[3] += r2 * (r2 < 0 ? p : u4), t[4] += a * (a < 0 ? p : u4), t[5] += o2 * (o2 < 0 ? p : u4), t;
  }
  applyToMbs(t) {
    const s = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]), e5 = this._totalOffset / s;
    return this._mbs[0] = t[0] + t[0] * e5, this._mbs[1] = t[1] + t[1] * e5, this._mbs[2] = t[2] + t[2] * e5, this._mbs[3] = t[3] + t[3] * this._totalOffset / s, this._mbs;
  }
  applyToObb(t) {
    const s = t.center, e5 = this._totalOffset / Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]);
    this._obb.center[0] = s[0] + s[0] * e5, this._obb.center[1] = s[1] + s[1] * e5, this._obb.center[2] = s[2] + s[2] * e5, S(this._obb.halfSize, t.halfSize, t.quaternion), u(this._obb.halfSize, this._obb.halfSize, t.center);
    const i = this._totalOffset / Math.sqrt(this._obb.halfSize[0] * this._obb.halfSize[0] + this._obb.halfSize[1] * this._obb.halfSize[1] + this._obb.halfSize[2] * this._obb.halfSize[2]);
    return this._obb.halfSize[0] += this._obb.halfSize[0] * i, this._obb.halfSize[1] += this._obb.halfSize[1] * i, this._obb.halfSize[2] += this._obb.halfSize[2] * i, e(this._obb.halfSize, this._obb.halfSize, t.center), S2(I, t.quaternion), S(this._obb.halfSize, this._obb.halfSize, I), this._obb.halfSize[0] *= this._obb.halfSize[0] < 0 ? -1 : 1, this._obb.halfSize[1] *= this._obb.halfSize[1] < 0 ? -1 : 1, this._obb.halfSize[2] *= this._obb.halfSize[2] < 0 ? -1 : 1, this._obb.quaternion = t.quaternion, this._obb;
  }
};
var x = class {
  constructor(t = 0) {
    this.offset = t, this.sphere = _(), this.tmpVertex = n();
  }
  applyToVertex(t, s, e5) {
    const i = this.objectTransform.transform;
    let r2 = i[0] * t + i[4] * s + i[8] * e5 + i[12], a = i[1] * t + i[5] * s + i[9] * e5 + i[13], o2 = i[2] * t + i[6] * s + i[10] * e5 + i[14];
    const h2 = this.offset / Math.sqrt(r2 * r2 + a * a + o2 * o2);
    r2 += r2 * h2, a += a * h2, o2 += o2 * h2;
    const n4 = this.objectTransform.inverse;
    return this.tmpVertex[0] = n4[0] * r2 + n4[4] * a + n4[8] * o2 + n4[12], this.tmpVertex[1] = n4[1] * r2 + n4[5] * a + n4[9] * o2 + n4[13], this.tmpVertex[2] = n4[2] * r2 + n4[6] * a + n4[10] * o2 + n4[14], this.tmpVertex;
  }
  applyToMinMax(t, s) {
    const e5 = this.offset / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
    t[0] += t[0] * e5, t[1] += t[1] * e5, t[2] += t[2] * e5;
    const i = this.offset / Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]);
    s[0] += s[0] * i, s[1] += s[1] * i, s[2] += s[2] * i;
  }
  applyToAabb(t) {
    const s = this.offset / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
    t[0] += t[0] * s, t[1] += t[1] * s, t[2] += t[2] * s;
    const e5 = this.offset / Math.sqrt(t[3] * t[3] + t[4] * t[4] + t[5] * t[5]);
    return t[3] += t[3] * e5, t[4] += t[4] * e5, t[5] += t[5] * e5, t;
  }
  applyToBoundingSphere(t) {
    const s = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]), e5 = this.offset / s;
    return this.sphere[0] = t[0] + t[0] * e5, this.sphere[1] = t[1] + t[1] * e5, this.sphere[2] = t[2] + t[2] * e5, this.sphere[3] = t[3] + t[3] * this.offset / s, this.sphere;
  }
};
var S3 = new x();
function y2(s) {
  return r(s) ? (S3.offset = s, S3) : null;
}
var q = new g();
function V(s) {
  return r(s) ? (q.offset = s, q) : null;
}
var d = new v();
function L(s) {
  return r(s) ? (d.offset = s, d) : null;
}
var j = "terrain";
var I = e4();

export {
  u3 as u,
  y2 as y,
  V,
  L,
  j
};
//# sourceMappingURL=chunk-MOXYEJRV.js.map
