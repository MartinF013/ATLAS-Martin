import {
  d as d3,
  l as l3,
  s as s3
} from "./chunk-L6YDAPZR.js";
import {
  n as n3
} from "./chunk-5SHHATAH.js";
import {
  b as b2,
  je
} from "./chunk-3ITGQWSQ.js";
import {
  Y
} from "./chunk-COK4R22F.js";
import {
  o as o2
} from "./chunk-QJN4GT4E.js";
import {
  C,
  E as E2,
  a2,
  s as s2
} from "./chunk-PUR7HIYZ.js";
import {
  r as r2
} from "./chunk-EHWEX2VK.js";
import {
  k
} from "./chunk-HPO2NV7P.js";
import {
  e as e3
} from "./chunk-AIONJO5O.js";
import {
  o,
  u as u2
} from "./chunk-MDCKEJ7B.js";
import {
  L
} from "./chunk-JZY7CGEI.js";
import {
  y as y2
} from "./chunk-OMNBM2E4.js";
import {
  x
} from "./chunk-4XBERLPX.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import {
  m
} from "./chunk-EGR3VVZG.js";
import {
  d as d2
} from "./chunk-JJRJ6TV3.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  a,
  f,
  h,
  l as l2
} from "./chunk-T7BEWVV3.js";
import {
  n as n2
} from "./chunk-P6G64ARX.js";
import {
  g as g3
} from "./chunk-BLINZ65M.js";
import {
  E
} from "./chunk-TT2HIXWQ.js";
import {
  i
} from "./chunk-EPCCNF3D.js";
import {
  M as M2
} from "./chunk-Q72YFZUL.js";
import {
  M,
  g as g2
} from "./chunk-YPZEGNLG.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  A,
  g
} from "./chunk-U3PSONS6.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  e as e2,
  l,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/QueryEngine.js
var c = Y;
var l4 = class extends y {
  constructor(e4) {
    super(e4), this._dataQueryEngineInstance = null;
  }
  get queryGeometryType() {
    switch (this.layer.geometryType) {
      case "multipoint":
      case "point":
      case "polygon":
      case "polyline":
        return this.layer.geometryType;
      case "mesh":
        return "polygon";
      default:
        return;
    }
  }
  get defaultQueryJSON() {
    return new b({ outSpatialReference: this.spatialReference }).toJSON();
  }
  get dataQueryEngine() {
    return this._ensureDataQueryEngine();
  }
  destroy() {
    this.clear();
  }
  clear() {
    return !!this._dataQueryEngineInstance && (this._dataQueryEngineInstance.destroy(), this._dataQueryEngineInstance = null, true);
  }
  async executeQueryForIdSet(e4, r3) {
    return this.dataQueryEngine.executeQueryForIdSet(this._ensureQueryJSON(e4, r3));
  }
  async executeQueryForCount(e4, r3) {
    return this.dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e4), r3);
  }
  async executeQueryForExtent(e4, r3) {
    const { count: t2, extent: s4 } = await this.dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e4), r3);
    return { count: t2, extent: M2.fromJSON(s4) };
  }
  async executeQueryForIds(e4, r3) {
    return this.dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e4), r3);
  }
  async executeQueryForLatestObservations(e4, r3) {
    const t2 = await this.dataQueryEngine.executeQueryForLatestObservations(this._ensureQueryJSON(e4), r3), s4 = x.fromJSON(t2);
    return s4.features.forEach((e5) => {
      e5.layer = this.layer, e5.sourceLayer = this.layer;
    }), s4;
  }
  async executeQuery(e4, r3) {
    const t2 = await this.dataQueryEngine.executeQuery(this._ensureQueryJSON(e4), r3), s4 = x.fromJSON(t2);
    return s4.features.forEach((e5) => {
      e5.layer = this.layer, e5.sourceLayer = this.layer;
    }), s4;
  }
  _ensureQueryJSON(e4, r3) {
    let s4 = this.defaultQueryJSON;
    return r(e4) && ("outSpatialReference" in e4 && !e4.outSpatialReference && (e4.outSpatialReference = this.spatialReference), s4 = e4.toJSON()), r(r3) && (s4 = { ...s4, sceneFilter: { ...r3, geometry: r3.geometry.toJSON() } }), s4;
  }
  _ensureDataQueryEngine() {
    if (this._dataQueryEngineInstance)
      return this._dataQueryEngineInstance;
    const e4 = "timeInfo" in this.layer && this.layer.timeInfo && this.layer.timeInfo.toJSON() || null, r3 = this.layer.objectIdField, t2 = i.toJSON(this.queryGeometryType), s4 = this.layer.fields.map((e5) => e5.toJSON()), a3 = this.layerView.view.resourceController.scheduler, n4 = this.priority, o3 = this.spatialReference.toJSON(), i2 = this.layerView.processor.featureStore, { hasZ: u3, hasM: l5 } = this.layerView;
    return this._dataQueryEngineInstance = new c({ hasZ: u3, hasM: l5, geometryType: t2, fields: s4, timeInfo: e4, spatialReference: o3, objectIdField: r3, featureStore: i2, scheduler: a3, priority: n4 }), this._dataQueryEngineInstance;
  }
};
e([d({ constructOnly: true })], l4.prototype, "layerView", void 0), e([d({ constructOnly: true })], l4.prototype, "priority", void 0), e([d({ readOnly: true, aliasOf: "layerView.view.spatialReference" })], l4.prototype, "spatialReference", void 0), e([d({ readOnly: true, aliasOf: "layerView.layer" })], l4.prototype, "layer", void 0), e([d({ readOnly: true })], l4.prototype, "queryGeometryType", null), e([d({ readOnly: true })], l4.prototype, "defaultQueryJSON", null), l4 = e([n("esri.views.3d.layers.graphics.QueryEngine")], l4);

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFilterVisibility.js
var m2 = s.getLogger("esri.views.3d.layers.graphics.Graphics3DFilterVisibility");
var F = class extends y {
  constructor(...e4) {
    super(...e4), this._dirty = false, this._querying = false, this._handles = new u();
  }
  get updating() {
    return this._dirty || this._querying || r(this._queryResult);
  }
  setup(e4, t2) {
    this._layerView = e4, this._core = t2, this._objectIdField = e4.layer.objectIdField, this._queryEngine = new l4({ layerView: this._layerView, priority: L.FILTER_VISIBILITY });
    const i2 = this._layerView.view.resourceController.scheduler;
    this._handles.add(i2.registerTask(L.FILTER_VISIBILITY, this)), this._handles.add(a(() => {
      var _a;
      return (_a = t2.owner) == null ? void 0 : _a.loadedGraphics;
    }, "after-changes", (e5) => this._graphicsChanged(e5), { onListenerAdd: () => this.dirty = true })), this.filterChanged();
  }
  destroy() {
    this._handles.destroy(), this._handles = null, this.clear(), this._layerView = null, this._core = null;
  }
  clear() {
    this._queryEngine.clear() && (this._core.modifyGraphics3DGraphicVisibilities((e4) => e4.clearVisibilityFlag(C.FILTER)), this._queryResult = null, this._querying = false), this.dirty = false;
  }
  _graphicsChanged(e4) {
    this._queryEngine && 0 == (e4.type & E.ADD) || (this.dirty = true);
  }
  updateVisibility(e4) {
    this.active && (e4.hasVisibilityFlag(C.FILTER, E2.GRAPHIC) || e4.setVisibilityFlag(C.FILTER, false, E2.GRAPHIC), this.dirty = true);
  }
  filterChanged() {
    const e4 = this._recomputeFilter();
    e4 !== this._featureFilter && (this._featureFilter = e4, this.dirty = true);
    const t2 = "layerFilter" in this._layerView ? this._layerView.layerFilter : null;
    t2 !== this._sceneFilter && (this._sceneFilter = t2, this.dirty = true);
  }
  get active() {
    return (this._featureFilter || this._sceneFilter) && this._core.graphics3DGraphics.size > 0;
  }
  _recomputeFilter() {
    const e4 = "filter" in this._layerView ? this._layerView.filter : null, t2 = "timeExtent" in this._layerView ? this._layerView.timeExtent : null, i2 = o2(this._layerView);
    if (t(t2) && t(i2))
      return e4;
    const r3 = r(e4) ? e4.clone() : new y2();
    if (r(t2) && (r3.timeExtent = r(r3.timeExtent) ? r3.timeExtent.intersection(t2) : t2), r(i2)) {
      const e5 = null == r3.where || "" === r3.where;
      r3.where = e5 ? i2 : `(${r3.where}) AND (${i2})`;
    }
    return r3;
  }
  get running() {
    return this._dirty && !this._querying || r(this._queryResult);
  }
  runTask(e4) {
    if (!this.active)
      return void this.clear();
    !this._dirty || this._querying || e4.done || (this._querying = true, this.dirty = false, this._queryEngine.executeQueryForIdSet(this._featureFilter, this._sceneFilter).then((e5) => {
      this._queryResult = e5, this._querying = false;
    }).catch((e5) => {
      if (!g(e5)) {
        m2.warn("FeatureFilter query failed: " + e5, { error: e5 });
        const t3 = /* @__PURE__ */ new Set();
        this._core.graphics3DGraphics.forEach((e6) => t3.add(this._getFeatureId(e6.graphic))), this._queryResult = t3, this._querying = false;
      }
    }), e4.madeProgress());
    const t2 = this._queryResult;
    r(t2) && !e4.done && (this._core.modifyGraphics3DGraphicVisibilities((i2) => {
      if (e4.done)
        return false;
      const r3 = t2.has(this._getFeatureId(i2.graphic));
      return !!i2.setVisibilityFlag(C.FILTER, r3, E2.GRAPHIC) && (e4.madeProgress(), true);
    }), e4.done || (this._queryResult = null));
  }
  _getFeatureId(e4) {
    return null == e4.objectId ? e4.attributes[this._objectIdField] : e4.objectId;
  }
  set dirty(e4) {
    this._dirty = e4;
  }
};
e([d({ readOnly: true })], F.prototype, "updating", null), e([d({ readOnly: true })], F.prototype, "running", null), e([d()], F.prototype, "_dirty", void 0), e([d()], F.prototype, "_querying", void 0), e([d()], F.prototype, "_queryResult", void 0), F = e([n("esri.views.3d.layers.graphics.Graphics3DFilterVisibility")], F);

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFeatureProcessor.js
var I = class extends d2 {
  constructor(e4) {
    super(e4), this.type = "graphics-3d", this.elevationFeatureExpressionEnabled = false, this.dataExtent = null, this.drapeSourceType = e3.Features, this.preferredUpdatePolicy = o.ASYNC, this.suspendResumeExtent = null;
  }
  normalizeCtorArgs(e4) {
    const t2 = e4.frustumVisibilityEnabled ? new d3() : null, i2 = e4.scaleVisibilityEnabled ? new b2() : null, s4 = (e4.filterVisibilityEnabled || e4.timeExtentEnabled) && "multipatch" !== e4.owner.layer.geometryType ? new F() : null, r3 = e4.elevationAlignmentEnabled ? new l3() : null, { owner: n4, updateClippingExtent: a3, dataExtent: o3, elevationFeatureExpressionEnabled: l5, preferredUpdatePolicy: p } = e4;
    return { owner: n4, updateClippingExtent: a3, dataExtent: o3, frustumVisibility: t2, scaleVisibility: i2, filterVisibility: s4, elevationAlignment: r3, elevationFeatureExpressionEnabled: l5, preferredUpdatePolicy: p };
  }
  initialize() {
    const e4 = new je({ owner: this, layer: this.layer, preferredUpdatePolicy: this.preferredUpdatePolicy, elevationFeatureExpressionEnabled: this.elevationFeatureExpressionEnabled, graphicSymbolSupported: false, hasZ: this.owner.hasZ, hasM: this.owner.hasM });
    this._set("graphicsCore", e4), this.scaleVisibility && this.updatingHandles.add(() => this.layer.effectiveScaleRange, () => this.scaleVisibility.layerMinMaxScaleChangeHandler());
    const t2 = this.filterVisibility;
    r(t2) && (this.updatingHandles.add(() => "filter" in this.owner && this.owner.filter, () => t2.filterChanged()), this.updatingHandles.add(() => "timeExtent" in this.owner && this.owner.timeExtent, () => t2.filterChanged()), this.updatingHandles.add(() => "layerFilter" in this.owner && this.owner.layerFilter, () => t2.filterChanged())), this.elevationAlignment && this.updatingHandles.add(() => this.layer.elevationInfo, (e5, t3) => {
      m(e5, t3) && this.updatingHandles.addPromise(this.graphicsCore.elevationInfoChange());
    }), this.updatingHandles.add(() => this.layer.labelsVisible, () => this.graphicsCore.updateVisibilityInfo()), this.updatingHandles.add(() => this.layer.labelingInfo, (e5, t3) => {
      m(e5, t3) && this.graphicsCore.updateLabelingInfo();
    }), this.updatingHandles.add(() => this.preferredUpdatePolicy, (e5) => this.graphicsCore.preferredUpdatePolicy = e5);
  }
  destroy() {
    this.handles.removeAll(), this.updatingHandles.removeAll(), this._set("frustumVisibility", l(this.frustumVisibility)), this._set("scaleVisibility", l(this.scaleVisibility)), this._set("filterVisibility", l(this.filterVisibility)), this._set("elevationAlignment", l(this.elevationAlignment)), this._set("objectStates", l(this.objectStates)), this._set("graphicsCore", l(this.graphicsCore)), this._set("owner", null);
  }
  get layer() {
    return this.owner.layer;
  }
  get suspendResumeExtentMode() {
    return "suspendResumeExtentMode" in this.owner ? this.owner.suspendResumeExtentMode : "computed";
  }
  get scaleVisibilitySuspended() {
    var _a;
    return (_a = this.scaleVisibility) == null ? void 0 : _a.suspended;
  }
  get suspended() {
    return this.owner.suspended;
  }
  get legendEnabled() {
    return t(this.frustumVisibility) || !this.frustumVisibility.suspended;
  }
  get suspendInfo() {
    var _a;
    const e4 = {};
    return ((_a = this.scaleVisibility) == null ? void 0 : _a.suspended) && (e4.outsideScaleRange = true), r(this.frustumVisibility) && this.frustumVisibility.suspended && (e4.outsideOfView = true), e4;
  }
  get updating() {
    var _a, _b;
    return !!(((_a = this.graphicsCore) == null ? void 0 : _a.updating) || r(this.frustumVisibility) && this.frustumVisibility.updating || ((_b = this.updatingHandles) == null ? void 0 : _b.updating));
  }
  get updatingRemaining() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.updatingRemaining) ?? 0;
  }
  get featureStore() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.featureStore;
  }
  get view() {
    return this.owner.view;
  }
  get loadedGraphics() {
    return this.owner.loadedGraphics;
  }
  get fullOpacity() {
    var _a;
    return (_a = this.owner) == null ? void 0 : _a.fullOpacity;
  }
  get filter() {
    return "filter" in this.owner ? this.owner.filter : null;
  }
  get slicePlaneEnabled() {
    return this.owner.slicePlaneEnabled;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  get featureSpatialReference() {
    return "featureSpatialReference" in this.owner ? this.owner.featureSpatialReference : this.owner.view.spatialReference;
  }
  get graphics3DGraphics() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphics;
  }
  get graphics3DGraphicsByObjectID() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphicsByObjectID;
  }
  get symbolUpdateType() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.symbolUpdateType;
  }
  get displayFeatureLimit() {
    var _a;
    const e4 = this.view.resourceController.memoryController.memoryFactor, t2 = (_a = this.graphicsCore) == null ? void 0 : _a.displayFeatureLimit;
    if (1 === e4)
      return t2;
    const i2 = Math.ceil(t2.maximumNumberOfFeatures * e4), s4 = Math.ceil(t2.maximumTotalNumberOfFeatures * e4), r3 = Math.ceil(t2.minimumTotalNumberOfFeatures * e4);
    return { ...t2, maximumNumberOfFeatures: i2, maximumTotalNumberOfFeatures: s4, minimumTotalNumberOfFeatures: r3 };
  }
  get usedMemory() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.usedMemory) ?? 0;
  }
  get usedMemoryPerFeature() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.usedMemoryPerGraphic) ?? 0;
  }
  get unprocessedMemoryEstimate() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.unprocessedMemoryEstimate) ?? 0;
  }
  get performanceInfo() {
    return { core: this.graphicsCore.performanceInfo, elevationUpdating: this.elevationAlignment.updating, visibilityFrustum: t(this.frustumVisibility) || !this.frustumVisibility.suspended, visibilityScale: !this.scaleVisibility.suspended };
  }
  async setup() {
    r(this.frustumVisibility) && this.frustumVisibility.setup(this);
    const e4 = this.owner, t2 = this.owner.view.basemapTerrain, i2 = (e5, t3, i3) => this.graphicsCore.spatialIndex.queryGraphicUIDsInExtent(e5, t3, i3);
    if (this.scaleVisibility && this.scaleVisibility.setup(this, this.layer, i2, this.graphicsCore, t2), r(this.filterVisibility) && ("filter" in e4 || "timeExtent" in e4) && this.filterVisibility.setup(e4, this.graphicsCore), this.elevationAlignment) {
      const t3 = e4.view.elevationProvider;
      this.elevationAlignment.setup(this, i2, this.graphicsCore, t3);
    }
    this._set("objectStates", new s3(this.graphicsCore)), this._set("labeling", this.owner.view.labeler.addGraphicsOwner(this.graphicsCore, this.scaleVisibility)), this._set("deconfliction", e4.view.deconflictor.addGraphicsOwner(this.graphicsCore)), await A(this.graphicsCore.setup({ elevationAlignment: this.elevationAlignment, scaleVisibility: this.scaleVisibility, filterVisibility: this.filterVisibility, deconflictor: this.deconfliction, labeler: this.labeling, objectStates: this.objectStates })), this.updatingHandles.add(() => this.layer.renderer, (e5) => this.updatingHandles.addPromise(this.graphicsCore.rendererChange(e5))), this.updatingHandles.add(() => e4.fullOpacity, () => this.graphicsCore.opacityChange()), this._setupSuspendResumeExtent(), this.updateClippingExtent && (this.updatingHandles.add(() => e4.view.clippingArea, () => this._updateClippingExtent()), this._updateClippingExtent()), this.graphicsCore.startCreateGraphics(), this.graphicsCore.labelsEnabled && await A(this.graphicsCore.updateLabelingInfo());
  }
  maskOccludee(e4) {
    const { set: t2, handle: i2 } = this.objectStates.acquireSet(u2.MaskOccludee, null);
    return this.objectStates.setUid(t2, e4.uid), i2;
  }
  highlight(e4, i2) {
    if (e4 instanceof b) {
      const { set: t2, handle: s4 } = this.objectStates.acquireSet(u2.Highlight, i2);
      return this.owner.queryObjectIds(e4).then((e5) => this.objectStates.setObjectIds(t2, e5)), s4;
    }
    if ("number" == typeof e4 || "string" == typeof e4)
      return this.highlight([e4], i2);
    if (e4 instanceof g3)
      return this.highlight([e4], i2);
    if ("toArray" in e4 && (e4 = e4.toArray()), Array.isArray(e4) && e4.length > 0) {
      if (e4[0] instanceof g3) {
        const t2 = e4;
        if (null == n3(this.layer.fieldsIndex, t2[0].attributes, i2)) {
          const e5 = t2.map((e6) => e6.uid), { set: i3, handle: s4 } = this.objectStates.acquireSet(u2.Highlight, null);
          return this.objectStates.setUids(i3, e5), s4;
        }
        e4 = t2.map((e5) => n3(this.layer.fieldsIndex, e5.attributes, i2));
      }
      if ("number" == typeof e4[0] || "string" == typeof e4[0]) {
        const t2 = e4, { set: s4, handle: r3 } = this.objectStates.acquireSet(u2.Highlight, i2);
        return this.objectStates.setObjectIds(s4, t2), r3;
      }
    }
    return P;
  }
  whenGraphicBounds(e4, t2) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.whenGraphicBounds(e4, t2);
  }
  computeAttachmentOrigin(e4, t2) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.computeAttachmentOrigin(e4, t2);
  }
  notifyGraphicGeometryChanged(e4) {
    this.graphicsCore.notifyGraphicGeometryChanged(e4);
  }
  notifyGraphicVisibilityChanged(e4) {
    this.graphicsCore.notifyGraphicVisibilityChanged(e4);
  }
  getRenderingInfo(e4, t2, i2) {
    const s4 = a2(e4, { renderer: t2, arcade: i2 });
    if (r(s4) && s4.color) {
      const e5 = s4.color;
      e5[0] = e5[0] / 255, e5[1] = e5[1] / 255, e5[2] = e5[2] / 255;
    }
    return s4;
  }
  getRenderingInfoAsync(e4, t2, i2, s4) {
    return s2(e4, { renderer: t2, arcade: i2, ...s4 });
  }
  getSymbolLayerSize(e4, t2) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.getSymbolLayerSize(e4, t2);
  }
  setObjectIdVisibility(e4, t2) {
    var _a;
    (_a = this.graphicsCore) == null ? void 0 : _a.setObjectIdVisibility(e4, t2);
  }
  _updateClippingExtent() {
    const e4 = this.owner.view.clippingArea;
    this.graphicsCore.setClippingExtent(e4, this.owner.view.spatialReference) && (this.updateClippingExtent(e4) || this.graphicsCore.recreateAllGraphics());
  }
  _setupSuspendResumeExtent() {
    (this.frustumVisibility || this.scaleVisibility) && this.handles.add(l2(() => this.suspendResumeExtentMode, () => {
      switch (this.handles.remove(M3), this.suspendResumeExtentMode) {
        case "computed":
          this.handles.add([l2(() => this.graphicsCore.computedExtent, (e4) => this._updateSuspendResumeExtent(e4), h), l2(() => this.graphicsCore.extentPadding, () => this._updateSuspendResumeExtent(this.graphicsCore.computedExtent))], M3);
          break;
        case "data":
          this.handles.add([f(() => this.dataExtent, (e4) => this._updateSuspendResumeExtent(e4), h), l2(() => this.graphicsCore.extentPadding, () => this._updateSuspendResumeExtent(e2(this.dataExtent)))], M3);
          break;
        default:
          n2(this.suspendResumeExtentMode);
      }
    }, h));
  }
  _updateSuspendResumeExtent(e4) {
    e4 ? this._suspendResumeExtentChanged(this._extentToSuspendResumeRect(e4, this.suspendResumeExtent)) : this._suspendResumeExtentChanged(null);
  }
  _extentToSuspendResumeRect(e4, t2) {
    const i2 = this.owner.view.spatialReference;
    if (!e4.spatialReference.equals(i2)) {
      if (!g2(e4, i2))
        return;
      e4 = M(e4, i2);
    }
    return k(e4, t2, r2, this.graphicsCore.extentPadding);
  }
  _suspendResumeExtentChanged(e4) {
    r(this.frustumVisibility) && this.frustumVisibility.setExtent(e4), this.scaleVisibility && this.scaleVisibility.setExtent(e4);
  }
};
e([d()], I.prototype, "type", void 0), e([d({ constructOnly: true })], I.prototype, "owner", void 0), e([d()], I.prototype, "layer", null), e([d({ constructOnly: true })], I.prototype, "updateClippingExtent", void 0), e([d({ constructOnly: true })], I.prototype, "elevationFeatureExpressionEnabled", void 0), e([d({ constructOnly: true })], I.prototype, "graphicsCore", void 0), e([d({ constructOnly: true })], I.prototype, "scaleVisibility", void 0), e([d({ constructOnly: true })], I.prototype, "filterVisibility", void 0), e([d({ constructOnly: true })], I.prototype, "elevationAlignment", void 0), e([d({ constructOnly: true })], I.prototype, "frustumVisibility", void 0), e([d({ readOnly: true })], I.prototype, "deconfliction", void 0), e([d({ readOnly: true })], I.prototype, "labeling", void 0), e([d({ readOnly: true })], I.prototype, "objectStates", void 0), e([d()], I.prototype, "suspendResumeExtentMode", null), e([d()], I.prototype, "dataExtent", void 0), e([d()], I.prototype, "scaleVisibilitySuspended", null), e([d()], I.prototype, "suspended", null), e([d()], I.prototype, "legendEnabled", null), e([d()], I.prototype, "suspendInfo", null), e([d()], I.prototype, "updating", null), e([d()], I.prototype, "updatingRemaining", null), e([d()], I.prototype, "featureStore", null), e([d()], I.prototype, "view", null), e([d()], I.prototype, "loadedGraphics", null), e([d()], I.prototype, "fullOpacity", null), e([d()], I.prototype, "filter", null), e([d()], I.prototype, "slicePlaneEnabled", null), e([d()], I.prototype, "drapeSourceType", void 0), e([d()], I.prototype, "updatePolicy", null), e([d()], I.prototype, "preferredUpdatePolicy", void 0), e([d()], I.prototype, "displayFeatureLimit", null), I = e([n("esri.views.3d.layers.graphics.Graphics3DFeatureProcessor")], I);
var F2 = I;
var M3 = "suspendResumeExtentMode";
var P = { remove() {
}, pause() {
}, resume() {
} };

export {
  l4 as l,
  F2 as F
};
//# sourceMappingURL=chunk-IHCVEO7N.js.map
