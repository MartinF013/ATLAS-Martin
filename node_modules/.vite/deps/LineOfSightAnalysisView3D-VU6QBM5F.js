import {
  n as n9
} from "./chunk-2CQUD5GK.js";
import {
  a as a2
} from "./chunk-FDKIF5RK.js";
import {
  S
} from "./chunk-7ZQJSAEA.js";
import "./chunk-3UQ4HI6Q.js";
import {
  _
} from "./chunk-TVBLDFP3.js";
import {
  c as c3,
  m as m3
} from "./chunk-GAAASXOF.js";
import {
  a as a3
} from "./chunk-R5LRVAQP.js";
import {
  te,
  w as w4
} from "./chunk-EEPTXXKK.js";
import {
  n as n7
} from "./chunk-KQRXZVEP.js";
import {
  C
} from "./chunk-OGZ4KF5L.js";
import "./chunk-JYMQQ22E.js";
import "./chunk-JYWDI7GA.js";
import "./chunk-MQZSD3AZ.js";
import "./chunk-5CAQC3RU.js";
import "./chunk-A5WV4QY7.js";
import "./chunk-PH7BQFVK.js";
import {
  f,
  l as l6,
  u as u3
} from "./chunk-XXIV5GSE.js";
import "./chunk-7Y6VVOP3.js";
import "./chunk-QFYBIFWB.js";
import {
  p as p2
} from "./chunk-22MSECLU.js";
import "./chunk-PTJ3MGYO.js";
import {
  d as d5,
  f as f2,
  u as u4
} from "./chunk-DSCM4HDL.js";
import {
  s as s2
} from "./chunk-WGMCNMOI.js";
import "./chunk-UV5UBITC.js";
import "./chunk-Y7MFFYJY.js";
import "./chunk-KW6WHTET.js";
import "./chunk-PUU4QXN5.js";
import "./chunk-EHWEX2VK.js";
import "./chunk-HPO2NV7P.js";
import "./chunk-22O7HU3A.js";
import "./chunk-Y75V5CF3.js";
import "./chunk-PQM6RARY.js";
import "./chunk-2Y5KPYOJ.js";
import "./chunk-BBUIX72C.js";
import "./chunk-5ZS6RUSM.js";
import "./chunk-R3PFJUIG.js";
import "./chunk-7LH2XNVI.js";
import "./chunk-PXOPYXIX.js";
import "./chunk-WSQIVEW5.js";
import "./chunk-ZTFWVZTL.js";
import "./chunk-ELZC3DZT.js";
import "./chunk-TGUQXVQU.js";
import "./chunk-4LQ6NAOX.js";
import "./chunk-K37I5IIG.js";
import "./chunk-GKYJJGE3.js";
import "./chunk-AWIG2DGF.js";
import "./chunk-3236UEJN.js";
import "./chunk-KSOWE6GO.js";
import "./chunk-TCYVDK2B.js";
import "./chunk-ZLORWBMB.js";
import "./chunk-LJAT5UYW.js";
import "./chunk-CNL2CHF7.js";
import "./chunk-HRAEK6P4.js";
import "./chunk-K6UIDSFF.js";
import {
  T
} from "./chunk-52W4YMC2.js";
import "./chunk-AIONJO5O.js";
import "./chunk-YLSPLHY5.js";
import "./chunk-4GGQTXXY.js";
import "./chunk-2DP653N7.js";
import "./chunk-QZCFKQOH.js";
import "./chunk-QMP4VG7M.js";
import "./chunk-5RP42VZJ.js";
import "./chunk-KD6KBT2L.js";
import "./chunk-XEWFCJLT.js";
import "./chunk-ZEDAE7EU.js";
import "./chunk-YXFNNKMT.js";
import "./chunk-7OZR6JFF.js";
import "./chunk-NXOQBIK7.js";
import "./chunk-ERNXFM5T.js";
import "./chunk-6ITXWFMK.js";
import "./chunk-SV4VP57N.js";
import "./chunk-5LWMNFCG.js";
import "./chunk-PWYPPSAW.js";
import "./chunk-5EXPMKQP.js";
import "./chunk-B7F3T673.js";
import "./chunk-QXYW5CVF.js";
import "./chunk-Z7AZMEL6.js";
import "./chunk-FUKESVWQ.js";
import "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-XEIRRA3E.js";
import "./chunk-B3IXFXV6.js";
import "./chunk-XNOIZLCR.js";
import "./chunk-I22L7HNU.js";
import "./chunk-44UD36FH.js";
import "./chunk-ODYLXHP4.js";
import "./chunk-Y5AGUEHG.js";
import "./chunk-DVE4HUBR.js";
import "./chunk-RC6OMMF6.js";
import "./chunk-AWPZQDE5.js";
import "./chunk-OYNEZ5VG.js";
import "./chunk-R67CDTDF.js";
import "./chunk-UCWSHVC4.js";
import "./chunk-DHZ2TSD5.js";
import "./chunk-ZV3LDRB3.js";
import "./chunk-FAF3GP2W.js";
import "./chunk-YSWURJZW.js";
import "./chunk-5JKCNCL2.js";
import "./chunk-2YDCEMEJ.js";
import "./chunk-O7YSDCZE.js";
import "./chunk-767LZ6IM.js";
import "./chunk-TTKSAULB.js";
import "./chunk-WJDUBZ7S.js";
import "./chunk-DNPZNIDB.js";
import "./chunk-WW7VYUQW.js";
import "./chunk-FCDEMPPS.js";
import "./chunk-TEJEYVH4.js";
import "./chunk-HEZ2ATGC.js";
import "./chunk-ECNFP4CF.js";
import "./chunk-AALA53RH.js";
import "./chunk-BOVIIQLB.js";
import "./chunk-IJHFAZOW.js";
import "./chunk-DMGVDNFD.js";
import "./chunk-YAQGRU5B.js";
import "./chunk-M3GMIUQS.js";
import "./chunk-BMA2CXVS.js";
import "./chunk-46N7XS5M.js";
import "./chunk-4MKQUQD4.js";
import "./chunk-A3QLZKCF.js";
import "./chunk-OYAHQ564.js";
import "./chunk-LGILR4HN.js";
import "./chunk-I5UNY2WQ.js";
import "./chunk-EYJ2F5XB.js";
import "./chunk-5EPJG7SL.js";
import "./chunk-TR3U55RZ.js";
import "./chunk-3DCTMZI6.js";
import "./chunk-33INAWJA.js";
import "./chunk-5WOO2FX6.js";
import "./chunk-FPMD6IB4.js";
import "./chunk-J73IXFNW.js";
import "./chunk-MQBVOUKB.js";
import "./chunk-PLLZPG4O.js";
import {
  V,
  d as d6,
  n as n8,
  r as r4,
  w as w3
} from "./chunk-3LEH5KDJ.js";
import {
  i as i2,
  t as t5,
  x as x3
} from "./chunk-WQLER7IU.js";
import "./chunk-7GTYHKA3.js";
import "./chunk-MOXYEJRV.js";
import "./chunk-EEJIELE6.js";
import "./chunk-Y55TYMBP.js";
import "./chunk-NAB3NF54.js";
import "./chunk-MHB3L22D.js";
import "./chunk-MDCKEJ7B.js";
import "./chunk-MLAOYRDT.js";
import "./chunk-VMF4NMEB.js";
import "./chunk-NAIF4GWX.js";
import "./chunk-72PB636Q.js";
import "./chunk-RIOXX6J2.js";
import {
  O as O2
} from "./chunk-SOZCO2CU.js";
import "./chunk-53KI6WDE.js";
import {
  d as d4,
  l as l5,
  m as m2,
  p
} from "./chunk-W2HLA6I3.js";
import {
  l as l4,
  v
} from "./chunk-Q6AASANP.js";
import {
  t as t3
} from "./chunk-ZYIEYKCD.js";
import "./chunk-DLM6NKXW.js";
import "./chunk-TQLSOIYV.js";
import {
  e as e4
} from "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-WTYOB7O7.js";
import {
  t as t4
} from "./chunk-EDJZEIRN.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-MV2XZ5BA.js";
import "./chunk-3NPGGTI6.js";
import {
  u as u5
} from "./chunk-G4ERZR5M.js";
import "./chunk-GRW2GUB3.js";
import {
  n as n6
} from "./chunk-RBVTRJPJ.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-ZZCCRN4U.js";
import "./chunk-TWQ374WD.js";
import "./chunk-GT2OBOXC.js";
import "./chunk-Z3S5X75I.js";
import "./chunk-YK4ZKK2Q.js";
import "./chunk-NMRWU44S.js";
import "./chunk-LBBA3SFR.js";
import "./chunk-2KZBVPWA.js";
import "./chunk-CXIMLSDF.js";
import "./chunk-ZDSMRGKC.js";
import "./chunk-I6H66HCE.js";
import "./chunk-4P4OV7G6.js";
import "./chunk-ZUDEVIXR.js";
import "./chunk-RRFFPL7N.js";
import "./chunk-JYR7GBAU.js";
import "./chunk-IG4CY4XM.js";
import "./chunk-HB4HVKJV.js";
import "./chunk-CC32E45Q.js";
import "./chunk-V7M26XZ7.js";
import "./chunk-ZN2MGN4S.js";
import {
  L,
  Q
} from "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-XZTXACPW.js";
import "./chunk-EHYYP2L2.js";
import "./chunk-ZUEYZA7M.js";
import "./chunk-74GUBHRJ.js";
import "./chunk-E447OCKN.js";
import "./chunk-LPU5TMA4.js";
import "./chunk-25QHXOZB.js";
import "./chunk-AA7FGPNP.js";
import "./chunk-UHJVTABQ.js";
import "./chunk-W66LN57L.js";
import "./chunk-PNUWGOXY.js";
import "./chunk-FUQI3AAI.js";
import "./chunk-22YODLVL.js";
import "./chunk-TB42IUV7.js";
import "./chunk-ZWMYDR2G.js";
import "./chunk-ZZY5IDKU.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-6FKG7JUE.js";
import {
  un,
  zn
} from "./chunk-PZWU5EHT.js";
import "./chunk-7LOJJ46D.js";
import "./chunk-VNR743PA.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-SWCA522B.js";
import "./chunk-YPIBZ3CH.js";
import "./chunk-XLCZFN6R.js";
import "./chunk-OMNBM2E4.js";
import "./chunk-WKHS6QIX.js";
import "./chunk-6O7ZZEV7.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-OBCAVCXI.js";
import "./chunk-RFOZTYJH.js";
import "./chunk-J6DXGG2A.js";
import "./chunk-L2YBXQTH.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-4XBERLPX.js";
import "./chunk-7ZPDA3EC.js";
import "./chunk-SZPDY7KN.js";
import "./chunk-Y6YGVGFR.js";
import "./chunk-GKRQ3NBT.js";
import "./chunk-OXEYQYNR.js";
import "./chunk-OXRBYKVX.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-YLU2PLJS.js";
import "./chunk-MZX3HN4G.js";
import "./chunk-T47JAOQZ.js";
import "./chunk-6GPADSSO.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-ODX6X222.js";
import "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-RIWDMEW4.js";
import "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import "./chunk-OG6CQEZJ.js";
import "./chunk-X5Z3DJQ4.js";
import "./chunk-BUWXVMJU.js";
import "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import "./chunk-D3XXPCBB.js";
import "./chunk-OWBMOIIV.js";
import "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import {
  x as x2
} from "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import {
  c as c2
} from "./chunk-K2FQEYBG.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  U as U2,
  a,
  h as h2,
  l as l3,
  w as w2
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-BLINZ65M.js";
import "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  D,
  F,
  j as j4
} from "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import {
  j as j3
} from "./chunk-TT2HIXWQ.js";
import {
  n as n5
} from "./chunk-OIPX3EDD.js";
import {
  d as d3
} from "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import {
  l as l2
} from "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import {
  J,
  U,
  e as e3,
  q,
  r as r3,
  u,
  x,
  z
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import {
  e as e2,
  n as n4,
  t as t2
} from "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import {
  j2
} from "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d as d2,
  n2,
  n8 as n3,
  r as r2,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  O,
  j
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  d,
  m
} from "./chunk-G5JBUC5N.js";
import {
  c,
  h,
  i2 as i,
  l,
  n,
  o,
  r,
  t,
  w
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightConfiguration.js
var s3 = class extends y {
  constructor(o2) {
    super(o2), this.innerWidth = 2, this.outerWidth = 8, this.visibleInnerColor = new l2([3, 252, 111, 1]), this.visibleOuterColor = new l2([3, 252, 111, 0.15]), this.occludedInnerColor = new l2([252, 3, 69, 1]), this.occludedOuterColor = new l2([252, 3, 69, 0.1]), this.undefinedInnerColor = new l2([255, 255, 255, 1]), this.undefinedOuterColor = new l2([127, 127, 127, 0.2]);
  }
};
e([d2({ type: Number })], s3.prototype, "innerWidth", void 0), e([d2({ type: Number })], s3.prototype, "outerWidth", void 0), e([d2({ type: l2 })], s3.prototype, "visibleInnerColor", void 0), e([d2({ type: l2 })], s3.prototype, "visibleOuterColor", void 0), e([d2({ type: l2 })], s3.prototype, "occludedInnerColor", void 0), e([d2({ type: l2 })], s3.prototype, "occludedOuterColor", void 0), e([d2({ type: l2 })], s3.prototype, "undefinedInnerColor", void 0), e([d2({ type: l2 })], s3.prototype, "undefinedOuterColor", void 0), s3 = e([n3("esri.views.3d.analysis.LineOfSight.LineOfSightConfiguration")], s3);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSightAnalysisResult.js
var s4 = class extends y {
  constructor(o2) {
    super(o2), this.target = null, this.intersectedGraphic = null, this.intersectedLocation = null, this.elevationAlignedTargetLocation = null, this.visible = void 0;
  }
};
e([d2()], s4.prototype, "target", void 0), e([d2()], s4.prototype, "intersectedGraphic", void 0), e([d2()], s4.prototype, "intersectedLocation", void 0), e([d2()], s4.prototype, "elevationAlignedTargetLocation", void 0), e([d2({ type: Boolean })], s4.prototype, "visible", void 0), s4 = e([n3("esri.views.3d.analysis.LineOfSightAnalysisResult")], s4);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightComputation.js
var i3 = class extends y {
  constructor(t6) {
    super(t6), this.elevationAlignedTargetLocation = null, this.inputPoints = { isValid: false, observer: n4(), observerSurfaceNormal: null, observerFeatureId: null, target: n4(), targetSurfaceNormal: null, targetFeatureId: null, observerAdjusted: n4(), targetAdjusted: n4() }, this.computationResult = { start: n4(), end: n4(), intersection: n4(), isValid: false, isTargetVisible: false }, this.result = null;
  }
  notifyResultChanged() {
    this.notifyChange("computationResult");
  }
  notifyInputPointsChanged() {
    this.notifyChange("inputPoints");
  }
};
e([d2()], i3.prototype, "target", void 0), e([d2()], i3.prototype, "elevationAlignedTargetLocation", void 0), e([d2()], i3.prototype, "inputPoints", void 0), e([d2()], i3.prototype, "computationResult", void 0), e([d2()], i3.prototype, "result", void 0), i3 = e([n3("esri.views.3d.analysis.LineOfSight.LineOfSightComputation")], i3);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightIntersectionResult.js
var a4;
var n10 = a4 = class extends y {
  constructor(r5) {
    super(r5);
  }
  clone() {
    return new a4({ type: this.type, id: m(this.id), point: m(this.point), normal: m(this.normal), ray: m(this.ray), graphic: this.graphic });
  }
  equals(r5) {
    return this.type === r5.type && this.id === r5.id && w(this.point, r5.point) && i(this.normal, r5.normal) && m2(this.ray, r5.ray) && this.graphic === r5.graphic;
  }
};
e([d2()], n10.prototype, "type", void 0), e([d2({ constructOnly: true })], n10.prototype, "id", void 0), e([d2({ constructOnly: true })], n10.prototype, "point", void 0), e([d2({ constructOnly: true })], n10.prototype, "normal", void 0), e([d2({ constructOnly: true })], n10.prototype, "graphic", void 0), e([d2({ constructOnly: true })], n10.prototype, "ray", void 0), n10 = a4 = e([n3("esri.views.3d.analysis.LineOfSight.LineOfSightIntersectionResult")], n10);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightRayIntersector.js
var O3 = class extends y {
  constructor(e5) {
    super(e5), this._terrainIntersectionOptionsLayerUids = /* @__PURE__ */ new Set(["terrain"]);
  }
  initialize() {
    this.intersector = x3(this.view.state.viewingMode), this.intersector.options.hud = false, this.intersector.options.store = t5.MIN;
  }
  getScreenPointIntersection(e5) {
    const r5 = d3(e5, t3.get()), t6 = s2(this.view.state.camera, r5, M);
    return this._getRayIntersection(t6);
  }
  _getRayIntersection(e5, r5) {
    if (t(e5) || t(this.view.sceneIntersectionHelper))
      return null;
    this.intersector.options.store = t5.MIN, this.view.sceneIntersectionHelper.intersectToolIntersectorRay(e5, this.intersector, r5);
    const o2 = this.intersector.results.min;
    if (!o2.getIntersectionPoint(H))
      return null;
    const i4 = this.view.renderCoordsHelper.fromRenderCoords(H, this.view.spatialReference), n13 = e2(o2.normal);
    if (n8(o2))
      return new n10({ type: i2.OBJECT, id: `${o2.target.layerUid}/${o2.target.nodeIndex}/${o2.target.componentIndex}`, point: i4, normal: n13, ray: l5(e5), graphic: null });
    if (r4(o2))
      return new n10({ type: i2.TERRAIN, id: o2.target.lij.slice(), point: i4, normal: n13, ray: l5(e5), graphic: null });
    const c4 = d6(o2, this.view);
    if (r(c4)) {
      const r6 = c4.layer, t6 = c4.sourceLayer;
      let s6;
      if (t6)
        if ("scene" === t6.type)
          s6 = O2(c4, t6.objectIdField);
        else
          s6 = c4.uid;
      else
        s6 = c4.uid;
      return new n10({ type: i2.OBJECT, id: `${r6.uid}/${s6}`, point: i4, normal: n13, ray: l5(e5), graphic: c4 });
    }
    return null;
  }
  updateFromGroundIntersection(e5, r5, t6) {
    const o2 = H, i4 = L2, n13 = T2, m5 = _2, u7 = x4;
    r3(i4, e5), this.view.renderCoordsHelper.worldUpAtPosition(i4, n13), z(n13, n13);
    const h3 = this.view.basemapTerrain.elevationBounds, f4 = this.view.renderCoordsHelper.getAltitude(i4), g = h3 ? Math.abs(h3.max - h3.min) : 100, I = f4 > 0 ? 1 : -1;
    q(m5, n13, I * (g + Math.abs(r5))), u(o2, i4, m5), p(o2, i4, M);
    const j6 = this._getRayIntersection(M, { include: this._terrainIntersectionOptionsLayerUids });
    return r(j6) && r(j6.point) ? (this.view.renderCoordsHelper.toRenderCoords(j6.point, u7), q(m5, n13, I * r5), u(t6, u7, m5), t2(j6.normal)) : (r3(t6, e5), null);
  }
};
e([d2()], O3.prototype, "view", void 0), e([d2()], O3.prototype, "intersector", void 0), O3 = e([n3("esri.views.3d.analysis.LineOfSight.LineOfSightRayIntersector")], O3);
var H = n4();
var L2 = n4();
var T2 = n4();
var _2 = n4();
var x4 = n4();
var M = d4();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightController.js
var X = s.getLogger("esri.views.3d.analysis.LineOfSight.LineOfSightController");
var Y = class extends n5.EventedMixin(y) {
  constructor(e5) {
    super(e5), this.updateOnCameraChange = true, this._effectiveObserverElevationMode = "absolute-height", this._observerFeatureId = null, this._updatingHandles = new c2(), this._frameTask = Q, this._handles = new u2(), this._computationHandles = new u2(), this._externalObserverUpdate = true;
  }
  initialize() {
    var _a;
    const e5 = (_a = this.view.resourceController) == null ? void 0 : _a.scheduler;
    this._frameTask = e5 ? e5.registerTask(L.LINE_OF_SIGHT_TOOL) : Q, this._intersector = new O3({ view: this.view }), this._handles.add([this._connectObserver(), this._connectComputations(), this._connectTargets()]);
  }
  destroy() {
    this._handles.destroy(), this._computationHandles.destroy(), this._computations.removeAll(), this._updatingHandles.destroy();
  }
  get updating() {
    return this._frameTask.updating || this._updatingHandles.updating;
  }
  get priority() {
    return this._frameTask.priority;
  }
  set priority(e5) {
    this._frameTask.priority = e5;
  }
  get _computations() {
    return this.analysisViewData.computations;
  }
  get _elevationAlignedObserverPositionRenderSpace() {
    return this.analysisViewData.observerEngineLocation;
  }
  set _elevationAlignedObserverPositionRenderSpace(e5) {
    this.analysisViewData.observerEngineLocation = e5;
  }
  get _screenPixelSize() {
    return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace);
  }
  getLineOfSightComputationDependencies(e5) {
    const { inputPoints: t6 } = e5;
    return { inputPoints: t6 };
  }
  _computeResult(e5) {
    const t6 = e5.computation, { inputPoints: o2, computationResult: i4 } = t6, { observerAdjusted: n13, targetAdjusted: r5 } = o2, { start: s6, end: a5 } = i4;
    r3(s6, n13), r3(a5, r5);
    this._canCompute(t6) ? this._computeIntersection(e5) : this._interpolateIntersection(e5), t6.notifyResultChanged(), this.emit("result-changed", { target: e5.computation.target, result: t6.result });
  }
  _updateAdjustedPointsFromFeatures(e5) {
    const o2 = this.view, { sceneIntersectionHelper: i4 } = o2, { inputPoints: n13 } = e5, { observerAdjusted: r5, observerFeatureId: s6, targetFeatureId: a5, targetAdjusted: c4 } = n13;
    if (t(s6) && t(a5))
      return;
    const p4 = x(r5, c4), d8 = this._intersector.intersector, h3 = p(n13.observer, n13.target, te2);
    d8.options.store = t5.ALL, i4.intersectToolIntersectorRay(h3, d8);
    let g = null, v3 = null, m5 = null, f4 = null;
    for (const _4 of d8.results.all) {
      const e6 = d6(_4, this.view);
      if (t(e6) || t(_4.distanceInRenderSpace))
        continue;
      const i5 = l6(e6);
      t(i5) || (r(s6) && i5 === s6 && (t(g) && (g = this._getFeatureDistanceThreshold(_4, o2, p4)), _4.distanceInRenderSpace < g && (m5 = _4)), r(a5) && i5 === a5 && (t(v3) && (v3 = this._getFeatureDistanceThreshold(_4, o2, p4)), t(f4) && _4.distanceInRenderSpace < p4 && p4 - _4.distanceInRenderSpace < v3 && (f4 = _4)));
    }
    r(m5) && m5.getIntersectionPoint(r5) && (n13.observerSurfaceNormal = m5.getTransformedNormal(n4())), r(f4) && f4.getIntersectionPoint(c4) && (n13.targetSurfaceNormal = f4.getTransformedNormal(n4()));
  }
  _getFeatureDistanceThreshold(e5, t6, o2) {
    if (w3(e5)) {
      const i4 = V(e5, t6);
      if (r(i4))
        return Math.min(i4 * ie, o2);
    }
    return 1e-5 * o2;
  }
  _adjustStartEndPositions(e5) {
    const t6 = this._screenPixelSize, o2 = this.view, { inputPoints: i4 } = e5, { observer: n13, observerSurfaceNormal: r5, target: s6, targetSurfaceNormal: a5, observerAdjusted: c4, targetAdjusted: l8 } = i4, p4 = ee;
    r3(c4, n13), r3(l8, s6), this._updateAdjustedPointsFromFeatures(e5), r(r5) ? r3(p4, r5) : e3(p4, l8, c4);
    const d8 = t6;
    z(p4, p4), q(p4, p4, Math.min(d8, 1)), u(c4, c4, p4), r(a5) ? r3(p4, a5) : e3(p4, c4, l8);
    const h3 = o2.state.camera.computeScreenPixelSizeAt(l8);
    z(p4, p4), q(p4, p4, Math.min(h3, 1)), u(l8, l8, p4);
  }
  _computeIntersection({ computation: e5, interpolationInfo: t6 }) {
    const { view: o2 } = this, { sceneIntersectionHelper: i4, renderCoordsHelper: n13 } = o2;
    if (t(i4))
      return;
    const r5 = this._intersector.intersector, { computationResult: s6, inputPoints: a5 } = e5, { observer: c4, target: p4 } = a5, { start: d8, end: h3 } = s6, g = p(d8, h3, te2);
    r5.options.store = t5.MIN, i4.intersectToolIntersectorRay(g, r5);
    const v3 = r5.results.min, m5 = s6.intersection, f4 = ee;
    let _4 = true;
    if (r(v3) && v3.getIntersectionPoint(m5)) {
      r3(t6.originalIntersection, m5), r3(t6.originalObserver, d8), r3(t6.originalTarget, h3), n13.fromRenderCoords(m5, f4, o2.spatialReference);
      const e6 = 1 - U(h3, p4) / U(d8, p4);
      _4 = U(c4, m5) >= e6 * U(c4, p4);
    }
    const b = new j2(f4, o2.spatialReference);
    {
      const { result: t7, target: i5 } = e5;
      r(t7) ? (t7.target = i5, t7.intersectedGraphic = _4 ? null : d6(v3, o2), t7.intersectedLocation = _4 ? null : b, t7.visible = _4) : e5.result = new s4({ target: i5, elevationAlignedTargetLocation: e5.elevationAlignedTargetLocation, intersectedGraphic: _4 ? null : d6(v3, o2), intersectedLocation: _4 ? null : b, visible: _4 });
    }
    s6.isValid = a5.isValid = true, s6.isTargetVisible = _4;
  }
  _interpolateIntersection({ computation: e5, interpolationInfo: t6 }) {
    const { computationResult: o2, inputPoints: i4 } = e5, { start: n13, end: r5, intersection: s6 } = o2, { originalIntersection: a5, originalObserver: c4, originalTarget: l8 } = t6;
    if (r3(s6, a5), i4.isValid) {
      const e6 = ee, t7 = U(c4, a5) / U(c4, l8);
      J(e6, n13, c4), q(e6, e6, 1 - t7), u(s6, s6, e6), J(e6, r5, l8), q(e6, e6, t7), u(s6, s6, e6), o2.isValid = true;
    } else
      e5.result = null, o2.isValid = false, o2.isTargetVisible = false;
  }
  _canCompute(e5) {
    const t6 = this.analysisViewData.elevationAlignedObserver, o2 = this.view.frustum;
    if (t(t6) || t(e5.elevationAlignedTargetLocation) || t(o2))
      return false;
    const { observerAdjusted: i4, targetAdjusted: n13 } = e5.inputPoints, r5 = o2.intersectsPoint(i4), s6 = o2.intersectsPoint(n13);
    return r5 && s6;
  }
  _onObserverPositionChange(e5, o2, i4, n13, r5) {
    if (this._externalObserverUpdate = r5, t(e5))
      return this.analysisViewData.elevationAlignedObserver = null, void (this._observerFeatureId = null);
    if (t(o2))
      return a2(this.analysis, e5.spatialReference, X), void (this.analysisViewData.elevationAlignedObserver = null);
    const s6 = this._getEffectiveElevationInfo(o2, i4), { absoluteZ: a5, elevation: c4 } = d5(o2.x, o2.y, o2.z, this.view.spatialReference, this.view, s6), u7 = o2.clone();
    u7.z = a5, this._effectiveObserverElevationMode = s6.mode, this.analysisViewData.elevationAlignedObserver = u7;
    const p4 = n4();
    this.view.renderCoordsHelper.toRenderCoords(u7, p4), this._elevationAlignedObserverPositionRenderSpace = p4, this._observerGroundOffsetRenderSpace = a5 - c4, this._observerFeatureId = l6(n13), this.priority = L.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _onObserverRenderSpacePositionChangeForComputation(e5, t6, o2, i4, n13) {
    const { inputPoints: r5 } = e5;
    switch (r3(r5.observer, t6), r5.observerFeatureId = n13, r5.observerSurfaceNormal = null, i4) {
      case "on-the-ground":
      case "relative-to-ground": {
        const e6 = this._intersector.updateFromGroundIntersection(r5.observer, o2, r5.observer);
        t(r5.observerFeatureId) && (r5.observerSurfaceNormal = e6);
      }
    }
    this._adjustStartEndPositions(e5), e5.notifyInputPointsChanged(), this.priority = L.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _onTargetPositionChange(e5, o2, i4, n13, r5, s6 = true) {
    const a5 = e5.inputPoints;
    if (s6 && (a5.isValid = false), t(i4))
      return r(o2) && a2(this.analysis, o2.spatialReference, X), e5.elevationAlignedTargetLocation = null, void e5.notifyInputPointsChanged();
    const c4 = this._getEffectiveElevationInfo(i4, n13), { absoluteZ: p4, elevation: d8 } = d5(i4.x, i4.y, i4.z, this.view.spatialReference, this.view, c4), h3 = i4.clone();
    switch (h3.z = p4, e5.elevationAlignedTargetLocation = h3, this.view.renderCoordsHelper.toRenderCoords(e5.elevationAlignedTargetLocation, a5.target), a5.targetFeatureId = l6(r5), a5.targetSurfaceNormal = null, c4.mode) {
      case "on-the-ground":
      case "relative-to-ground": {
        const e6 = this._intersector.updateFromGroundIntersection(a5.target, p4 - d8, a5.target);
        t(a5.targetFeatureId) && (a5.targetSurfaceNormal = e6);
      }
    }
    this._adjustStartEndPositions(e5), e5.notifyInputPointsChanged(), this.priority = L.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _connectComputationToTarget(e5) {
    return r2([l3(() => ({ computation: e5, targetPosition: e5.target.position, targetElevationInfo: e5.target.elevationInfo, targetFeatureInfo: e5.target.feature, projectedTargetPosition: un(e5.target.position, this.view.spatialReference) }), ({ computation: e6, targetPosition: t6, targetElevationInfo: o2, targetFeatureInfo: i4, projectedTargetPosition: n13 }) => {
      r(n13.pending) ? this._updatingHandles.addPromise(n13.pending) : this._onTargetPositionChange(e6, t6, n13.geometry, o2, i4);
    }, w2)]);
  }
  _connectComputationToObserver(e5) {
    return l3(() => ({ computation: e5, observer: this.analysisViewData.elevationAlignedObserver }), ({ computation: e6 }) => {
      this._externalObserverUpdate && (e6.inputPoints.isValid = false, e6.notifyInputPointsChanged());
    }, w2);
  }
  _connectComputationToRenderSpaceObserver(e5) {
    return l3(() => ({ computation: e5, observer: this._elevationAlignedObserverPositionRenderSpace, observerGroundOffset: this._observerGroundOffsetRenderSpace, observerElevationMode: this._effectiveObserverElevationMode, observerFeatureId: this._observerFeatureId }), ({ computation: e6, observer: t6, observerGroundOffset: o2, observerElevationMode: i4, observerFeatureId: n13 }) => {
      this._onObserverRenderSpacePositionChangeForComputation(e6, t6, o2, i4, n13);
    }, w2);
  }
  _connectComputationToCamera(e5) {
    return l3(() => ({ camera: this.view.state.camera, isDirty: this._isCameraDirty }), ({ isDirty: t6 }) => {
      !this.updateOnCameraChange || e5.inputPoints.isValid && !t6 || e5.notifyInputPointsChanged();
    }, U2);
  }
  _connectComputationToSlicePlane(e5) {
    return l3(() => this.view.slicePlane, () => {
      e5.inputPoints.isValid = false, e5.notifyInputPointsChanged();
    });
  }
  _connectComputationToElevation(e5) {
    const t6 = (o2, i4) => {
      const n13 = this.analysis.observer, r5 = e5.target;
      let s6 = null, a5 = null, c4 = null, p4 = null, d8 = null, h3 = null;
      if (r(n13) && r(n13.position)) {
        const e6 = un(n13.position, this.view.spatialReference);
        if (r(e6.pending))
          return this._updatingHandles.addPromise(e6.pending), void e6.pending.finally(() => t6(o2, i4));
        s6 = e6.geometry, a5 = n13.elevationInfo, c4 = n13.feature;
      }
      if (r(r5.position)) {
        const e6 = un(r5.position, this.view.spatialReference);
        if (r(e6.pending))
          return this._updatingHandles.addPromise(e6.pending), void e6.pending.finally(() => t6(o2, i4));
        p4 = e6.geometry, d8 = r5.elevationInfo, h3 = r5.feature;
      }
      t(s6) && t(p4) || (zn(o2, i4, oe, this.view.spatialReference), r(s6) && F(oe, s6) && this._onObserverPositionChange(r(n13) ? n13.position : null, s6, a5, c4, false), r(p4) && F(oe, p4) && this._onTargetPositionChange(e5, r5.position, p4, d8, h3, false), r(s6) && r(p4) && j4(oe, s6, p4) && e5.notifyInputPointsChanged());
    };
    return this.view.elevationProvider.on("elevation-change", (e6) => t6(e6.extent, e6.spatialReference));
  }
  _connectComputationToTask(e5) {
    let t6 = n;
    const o2 = { computation: e5, interpolationInfo: { originalIntersection: n4(), originalObserver: n4(), originalTarget: n4() } };
    return r2([l3(() => this.getLineOfSightComputationDependencies(e5), () => {
      t6 = h(t6), t6 = O(async (e6) => {
        await j(this._frameTask.schedule(() => this._computeResult(o2), e6));
      });
    }, { sync: true, initial: true, equals: d }), n2(() => t6 = h(t6))]);
  }
  _connectComputation(e5) {
    const t6 = this._computationHandles;
    t6.has(e5) || t6.add([this._connectComputationToTarget(e5), this._connectComputationToObserver(e5), this._connectComputationToRenderSpaceObserver(e5), this._connectComputationToCamera(e5), this._connectComputationToSlicePlane(e5), this._connectComputationToElevation(e5), this._connectComputationToTask(e5)], e5);
  }
  _disconnectComputation(e5) {
    this._computationHandles.remove(e5);
  }
  _onComputationCollectionChange({ added: e5, removed: t6 }) {
    for (const o2 of t6)
      this._disconnectComputation(o2);
    for (const o2 of e5)
      this._connectComputation(o2);
  }
  _onTargetCollectionChange({ added: e5, removed: t6 }) {
    for (const o2 of t6)
      this._removeTarget(o2);
    for (const o2 of e5)
      this._addTarget(o2);
  }
  _onCursorTargetChange(e5, t6) {
    r(t6) && this._removeTarget(t6), r(e5) && this._addTarget(e5);
  }
  _addTarget(e5) {
    this._computations.some((t6) => t6.target === e5) || this._computations.add(new i3({ target: e5 }));
  }
  _removeTarget(e5) {
    const t6 = this._computations.findIndex((t7) => t7.target === e5);
    this._computations.removeAt(t6);
  }
  _connectObserver() {
    return r2([l3(() => ({ observerPosition: r(this.analysis.observer) ? this.analysis.observer.position : null, projectedObserverPosition: un(r(this.analysis.observer) ? this.analysis.observer.position : null, this.view.spatialReference), observerElevationInfo: r(this.analysis.observer) ? this.analysis.observer.elevationInfo : null, observerFeatureInfo: r(this.analysis.observer) ? this.analysis.observer.feature : null }), ({ observerPosition: e5, projectedObserverPosition: t6, observerElevationInfo: o2, observerFeatureInfo: i4 }) => {
      r(t6.pending) ? this._updatingHandles.addPromise(t6.pending) : this._onObserverPositionChange(e5, t6.geometry, o2, i4, true);
    }, w2)]);
  }
  _connectComputations() {
    return a(() => this._computations, "change", (e5) => this._onComputationCollectionChange(e5), { onListenerAdd: (e5) => {
      for (const t6 of e5)
        this._connectComputation(t6);
    }, onListenerRemove: (e5) => {
      for (const t6 of e5)
        this._disconnectComputation(t6);
    }, sync: true });
  }
  _connectTargets() {
    return r2([this._updatingHandles.addOnCollectionChange(() => this.analysis.targets, (e5) => this._onTargetCollectionChange(e5), { initial: true, final: true }), l3(() => this.analysisViewData.cursorTarget, (e5, t6) => {
      this._onCursorTargetChange(e5, t6);
    })]);
  }
  get _isCameraDirty() {
    const e5 = this.analysisViewData.elevationAlignedObserver, { view: t6 } = this, { renderCoordsHelper: o2 } = t6;
    if (t(e5) || t(o2))
      return false;
    const i4 = ee;
    o2.toRenderCoords(e5, i4);
    const n13 = t6.state.camera.computeScreenPixelSizeAt(i4);
    return Math.abs((n13 - this._screenPixelSize) / this._screenPixelSize) > $;
  }
  _getEffectiveElevationInfo(e5, t6) {
    return e5.hasZ ? c(t6, { mode: "absolute-height", offset: 0 }) : { mode: "on-the-ground", offset: 0 };
  }
};
e([d2({ constructOnly: true })], Y.prototype, "analysis", void 0), e([d2({ constructOnly: true })], Y.prototype, "analysisViewData", void 0), e([d2({ constructOnly: true })], Y.prototype, "view", void 0), e([d2()], Y.prototype, "updating", null), e([d2()], Y.prototype, "priority", null), e([d2()], Y.prototype, "updateOnCameraChange", void 0), e([d2()], Y.prototype, "_computations", null), e([d2()], Y.prototype, "_elevationAlignedObserverPositionRenderSpace", null), e([d2()], Y.prototype, "_observerGroundOffsetRenderSpace", void 0), e([d2()], Y.prototype, "_effectiveObserverElevationMode", void 0), e([d2()], Y.prototype, "_observerFeatureId", void 0), e([d2()], Y.prototype, "_screenPixelSize", null), e([d2({ readOnly: true })], Y.prototype, "_updatingHandles", void 0), e([d2()], Y.prototype, "_frameTask", void 0), e([d2()], Y.prototype, "_isCameraDirty", null), Y = e([n3("esri.views.3d.analysis.LineOfSight.LineOfSightController")], Y);
var $ = 0.1;
var ee = n4();
var te2 = d4();
var oe = D();
var ie = 0.05;

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightToolConfiguration.js
var s5 = class extends y {
  constructor(e5) {
    super(e5), this.enabled = true, this.glowColor = new l2([255, 127, 0]), this.glowWidth = 8, this.innerColor = new l2([255, 255, 255]), this.innerWidth = 0.75, this.globalAlpha = 0.75;
  }
};
e([d2({ type: Boolean })], s5.prototype, "enabled", void 0), e([d2({ type: l2 })], s5.prototype, "glowColor", void 0), e([d2({ type: Number })], s5.prototype, "glowWidth", void 0), e([d2({ type: l2 })], s5.prototype, "innerColor", void 0), e([d2({ type: Number })], s5.prototype, "innerWidth", void 0), e([d2({ type: Number })], s5.prototype, "globalAlpha", void 0), s5 = e([n3("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightLaserLineConfiguration")], s5);
var p3 = class extends y {
  constructor(e5) {
    super(e5), this.size = 0.5, this.color = new l2([255, 127, 0, 0.75]);
  }
};
e([d2({ type: Number })], p3.prototype, "size", void 0), e([d2({ type: l2 })], p3.prototype, "color", void 0), p3 = e([n3("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightObserverConfiguration")], p3);
var n11 = class extends y {
  constructor(e5) {
    super(e5), this.size = 0.5, this.visibleColor = new l2([3, 252, 111, 0.75]), this.occludedColor = new l2([252, 3, 69, 0.75]), this.undefinedColor = new l2([127, 127, 127, 0.75]);
  }
};
e([d2({ type: Number })], n11.prototype, "size", void 0), e([d2({ type: l2 })], n11.prototype, "visibleColor", void 0), e([d2({ type: l2 })], n11.prototype, "occludedColor", void 0), e([d2({ type: l2 })], n11.prototype, "undefinedColor", void 0), n11 = e([n3("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightTargetConfiguration")], n11);
var l7 = class extends y {
  constructor(e5) {
    super(e5), this.innerWidth = 2, this.outerWidth = 8, this.visibleInnerColor = new l2([3, 252, 111, 1]), this.visibleOuterColor = new l2([3, 252, 111, 0.15]), this.occludedInnerColor = new l2([252, 3, 69, 1]), this.occludedOuterColor = new l2([252, 3, 69, 0.1]), this.undefinedInnerColor = new l2([255, 255, 255, 1]), this.undefinedOuterColor = new l2([127, 127, 127, 0.2]);
  }
};
e([d2({ type: Number })], l7.prototype, "innerWidth", void 0), e([d2({ type: Number })], l7.prototype, "outerWidth", void 0), e([d2({ type: l2 })], l7.prototype, "visibleInnerColor", void 0), e([d2({ type: l2 })], l7.prototype, "visibleOuterColor", void 0), e([d2({ type: l2 })], l7.prototype, "occludedInnerColor", void 0), e([d2({ type: l2 })], l7.prototype, "occludedOuterColor", void 0), e([d2({ type: l2 })], l7.prototype, "undefinedInnerColor", void 0), e([d2({ type: l2 })], l7.prototype, "undefinedOuterColor", void 0);
var d7 = class extends y {
  constructor(e5) {
    super(e5), this.laserLine = new s5(), this.observer = new p3(), this.target = new n11(), this.lineOfSight = new l7();
  }
};
e([d2({ type: s5 })], d7.prototype, "laserLine", void 0), e([d2({ type: p3 })], d7.prototype, "observer", void 0), e([d2({ type: n11 })], d7.prototype, "target", void 0), e([d2({ type: l7 })], d7.prototype, "lineOfSight", void 0), d7 = e([n3("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightToolConfiguration")], d7);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/lineOfSightToolUtils.js
function m4(t6, r5, s6) {
  return { geometry: T.createSphereGeometry(t6, 32, 32), material: w4(l2.toUnitRGBA(r5)), stateMask: s6 };
}
function n12(o2) {
  const t6 = [];
  return o2.customColor1 && t6.push(m4(o2.size, o2.customColor1, u5.Custom1)), o2.customColor2 && t6.push(m4(o2.size, o2.customColor2, u5.Custom2)), o2.customColor3 && t6.push(m4(o2.size, o2.customColor3, u5.Custom3)), o2.color && t6.push(m4(o2.size, o2.color)), t6;
}
function u6(o2, e5) {
  const i4 = n12(e5), s6 = new te({ view: o2, renderObjects: i4, elevationInfo: { mode: "absolute-height", offset: 0 } });
  return n9(s6), s6;
}

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightTool.js
var R;
!function(e5) {
  e5.Ready = "ready", e5.Creating = "creating", e5.Created = "created";
}(R || (R = {}));
var j5 = j3.ofType(f);
var P = s.getLogger("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightTool");
var H2 = class extends a3 {
  constructor(e5) {
    super(e5), this.preferManipulatorCursor = true, this.removeIncompleteOnCancel = false, this.configuration = new d7(), this.analysisViewData = null, this._laserlineVisualElement = null, this._grabbedManipulator = null, this._analysisHandles = new u2(), this._handles = new u2(), this._manipulatorHandles = new u2(), this._targetTrackerManipulator = null;
  }
  initialize() {
    this._intersector = new O3({ view: this.view }), this._handles.add(l3(() => this.state, (e5) => {
      e5 === R.Created && this.finishToolCreation();
    }, w2)), this._observerManipulator = this._createObserverManipulator(), this._handles.add([l3(() => ({ ...this.configuration.observer }), () => this._updateObserverManipulatorStyle(), U2), l3(() => this.analysisViewData.elevationAlignedObserver, (e5) => this._onObserverLocationChange(e5), w2), l3(() => ({ ...this.configuration.laserLine }), () => this._createVisualElements(), w2), l3(() => this._laserLineRendererDependencies(), (e5) => this._updateLaserLineRenderer(e5)), this._connectComputations()]);
  }
  destroy() {
    this._handles = l(this._handles), this._manipulatorHandles = l(this._manipulatorHandles), this._analysisHandles = l(this._analysisHandles), this._observerManipulator = null, this._clearCursorTracker(), this._removeVisualElements(), this._intersector = null, this._set("analysis", null);
  }
  get state() {
    return this.active ? r(this._grabbedManipulator) ? R.Created : R.Creating : r(this.analysis.observer) && r(this.analysis.observer.position) ? R.Created : R.Ready;
  }
  get cursor() {
    return this.active && this._showTracker ? "crosshair" : null;
  }
  get updating() {
    return !!r(this.analysisViewData) && this.analysisViewData.updating;
  }
  get _showTracker() {
    return this.active && "mouse" === this._latestPointerMovePointerType;
  }
  get _shouldRenderTracker() {
    return this._showTracker && r(this.analysis.observer) && r(this.analysis.observer.position) && !this.hasFocusedManipulators;
  }
  continue() {
    this.view.activeTool = this;
  }
  stop() {
    this.view.activeTool = null;
  }
  onEditableChange() {
    this.analysisViewData.editable = this.internallyEditable;
  }
  onInputEvent(e5) {
    switch (e5.type) {
      case "immediate-double-click":
        this._doubleClickHandler(e5);
        break;
      case "key-down":
        this._keyDownHandler(e5);
        break;
      case "pointer-move":
        this._pointerMoveHandler(e5);
    }
  }
  onInputEventAfter(e5) {
    if ("immediate-click" === e5.type)
      this._clickHandler(e5);
  }
  onShow() {
  }
  onHide() {
    this._grabbedManipulator = null;
  }
  onDeactivate() {
    this._clearCursorTracker();
  }
  _connectComputations() {
    return a(() => this.analysisViewData.computations, "change", (e5) => this._onComputationsCollectionChange(e5), { onListenerAdd: (e5) => {
      for (const t6 of e5)
        this._connectComputation(t6);
    }, onListenerRemove: (e5) => {
      for (const t6 of e5)
        this._disconnectComputation(t6);
    }, sync: true });
  }
  _onComputationsCollectionChange({ added: e5, removed: t6 }) {
    for (const i4 of t6)
      this._disconnectComputation(i4);
    for (const i4 of e5)
      this._connectComputation(i4);
  }
  _connectComputation(e5) {
    if (this.destroyed)
      return void P.warn("Attempting to connect an analysis to a destroyed LineOfSight tool. Ignoring.");
    const t6 = this._analysisHandles;
    if (t6.has(e5))
      return;
    const i4 = this._createTargetManipulator(e5.target);
    t(this._targetTrackerManipulator) && i4.metadata.target === this.analysisViewData.cursorTarget && (this._targetTrackerManipulator = i4, this._targetTrackerManipulator.available = false, this._targetTrackerManipulator.interactive = false, this._updateLaserLineRenderer()), t6.add([l3(() => this._getLineOfSightManipulatorStateDependencies(e5), () => this._updateManipulatorState(i4, e5), w2), l3(() => e5.elevationAlignedTargetLocation, (e6) => this._onTargetLocationChange(e6, i4), w2)], e5);
  }
  _disconnectComputation(e5) {
    if (this.destroyed)
      return void P.warn("Attempting to disconnect an analysis from a destroyed LineOfSight tool. Ignoring.");
    this._analysisHandles.remove(e5);
    const t6 = this._getTargetManipulator(e5.target);
    r(t6) && (this.manipulators.remove(t6), this._manipulatorHandles.remove(t6), r(this._targetTrackerManipulator) && this._targetTrackerManipulator === t6 && (this._targetTrackerManipulator = null));
  }
  _clearCursorTracker() {
    this.analysisViewData.cursorTarget = l(this.analysisViewData.cursorTarget);
  }
  _createManipulator(e5, t6, i4) {
    const r5 = u6(this.view, e5);
    return r5.metadata = i4, this._manipulatorHandles.add([t6(r5), r5.events.on("grab-changed", (e6) => this._manipulatorGrabChanged(r5, e6)), r5.events.on("immediate-click", (e6) => this._manipulatorClick(r5, e6))], r5), this.manipulators.add(r5), r5;
  }
  _createTargetManipulator(e5) {
    const t6 = this.configuration, i4 = { size: t6.target.size, customColor1: t6.target.visibleColor, customColor2: t6.target.occludedColor, customColor3: t6.target.undefinedColor, visible: true }, r5 = { target: e5, type: "target" }, a5 = this._createManipulator(i4, (e6) => this._createTargetManipulatorDragPipeline(e6), r5);
    return r(e5.position) ? a5.elevationAlignedLocation = e5.position : a5.available = false, a5;
  }
  _getTargetManipulator(e5) {
    let t6 = null;
    return this.manipulators.forEach((i4) => {
      const r5 = i4.manipulator;
      t(t6) && "target" === r5.metadata.type && r5.metadata.target === e5 && (t6 = r5);
    }), t6;
  }
  _createObserverManipulator() {
    const e5 = this.configuration, t6 = { size: e5.observer.size, color: e5.observer.color, visible: true };
    return this._createManipulator(t6, (e6) => this._createObserverManipulatorDragPipeline(e6), { type: "observer", intersection: null });
  }
  _updateObserverManipulatorStyle() {
    const e5 = this._observerManipulator, t6 = this.configuration.observer, i4 = { size: t6.size, color: t6.color, visible: e5.available };
    e5.renderObjects = n12(i4);
  }
  _screenToIntersection() {
    return (e5) => {
      const t6 = this._intersector.getScreenPointIntersection(e5.screenEnd);
      return t(t6) ? null : { ...e5, intersection: t6 };
    };
  }
  _createTargetManipulatorDragPipeline(e5) {
    return p2(e5, (t6, i4, r5) => {
      i4.next(this._screenToIntersection()).next(this._updateTargetDragStep(e5)).next(() => this._updateLaserLineRenderer()), r5.next(this._cancelTargetDragStep(e5.metadata.target)).next(() => this._updateLaserLineRenderer());
    });
  }
  _createObserverManipulatorDragPipeline(e5) {
    return p2(e5, (e6, t6, i4) => {
      t6.next(this._screenToIntersection()).next(this._updateObserverDragStep()).next(() => this._updateLaserLineRenderer()), i4.next(this._cancelObserverDragStep()).next(() => this._updateLaserLineRenderer());
    });
  }
  _updateObserverDragStep() {
    return (e5) => (r(e5.intersection.point) ? (t(this.analysis.observer) && (this.analysis.observer = new u3()), this._updateFromIntersection(this.analysis.observer, e5.intersection)) : this.analysis.observer = null, e5);
  }
  _cancelObserverDragStep() {
    const e5 = r(this.analysis.observer) && r(this.analysis.observer.position) ? this.analysis.observer.clone() : null;
    return (t6) => (this.analysis.observer = e5, t6);
  }
  _updateTargetDragStep(e5) {
    return (t6) => {
      this._updateFromIntersection(e5.metadata.target, t6.intersection);
      const i4 = t6.intersection.point;
      return r(i4) && (e5.elevationAlignedLocation = i4), t6;
    };
  }
  _cancelTargetDragStep(e5) {
    const t6 = o(e5.position, (e6) => e6.clone());
    return (i4) => (e5.position = t6, i4);
  }
  _manipulatorGrabChanged(e5, t6) {
    switch (t6.action) {
      case "start":
        this._grabbedManipulator = e5;
        break;
      case "end":
        this._grabbedManipulator === e5 && (this._grabbedManipulator = null);
    }
  }
  _updateManipulatorState(e5, t6) {
    const { isValid: i4, isTargetVisible: r5 } = t6.computationResult;
    e5.state = i4 ? r5 ? u5.Custom1 : u5.Custom2 : u5.Custom3;
  }
  _getLineOfSightManipulatorStateDependencies(e5) {
    const { isValid: t6, isTargetVisible: i4 } = e5.computationResult;
    return { isValid: t6, isTargetVisible: i4 };
  }
  _laserLineRendererDependencies() {
    return { laserlineVisualElement: this._laserlineVisualElement, grabbedManipulator: this._grabbedManipulator, shouldRenderTracker: this._shouldRenderTracker, observerPosition: r(this.analysis.observer) ? this.analysis.observer.position : null, visible: this.visible };
  }
  _updateLaserLineRenderer(e5 = this._laserLineRendererDependencies()) {
    const { laserlineVisualElement: t6, grabbedManipulator: i4, shouldRenderTracker: r5, observerPosition: a5, visible: n13 } = e5;
    if (t(t6))
      return;
    const s6 = r(i4) ? i4 : r5 && r(a5) ? this._targetTrackerManipulator : null;
    this.configuration.laserLine.enabled && r(s6) && n13 ? (t6.visible = true, t6.heightManifoldTarget = s6.renderLocation, s6 !== this._observerManipulator ? t6.lineVerticalPlaneSegment = l4(this._observerManipulator.renderLocation, s6.renderLocation, A) : t6.lineVerticalPlaneSegment = null) : (t6.visible = false, t6.heightManifoldTarget = null, t6.lineVerticalPlaneSegment = null);
  }
  _createVisualElements() {
    const e5 = this.configuration.laserLine;
    this._removeVisualElements(), this._laserlineVisualElement = new _({ view: this.view, attached: true, visible: this.visible, style: { glowColor: l2.toUnitRGB(e5.glowColor), glowWidth: e5.glowWidth, innerColor: l2.toUnitRGB(e5.innerColor), innerWidth: e5.innerWidth, globalAlpha: e5.globalAlpha } });
  }
  _removeVisualElements() {
    r(this._laserlineVisualElement) && (this._laserlineVisualElement.destroy(), this._laserlineVisualElement = null);
  }
  _onObserverLocationChange(e5) {
    t(e5) ? this._observerManipulator.available = false : (this._observerManipulator.metadata.intersection = null, this._observerManipulator.available = true, this._observerManipulator.elevationAlignedLocation = e5);
  }
  _onTargetLocationChange(e5, t6) {
    r(e5) ? (t6.elevationAlignedLocation = e5, t6 !== this._targetTrackerManipulator && (t6.available = true)) : t6.available = false;
  }
  _addPointFromClickEvent(e5) {
    const t6 = this._intersector.getScreenPointIntersection(e5);
    if (!t(t6) && !t(t6.point))
      if (r(this.analysis.observer) && r(this.analysis.observer.position)) {
        this._clearCursorTracker();
        const e6 = new f();
        this._updateFromIntersection(e6, t6), this.analysis.targets.add(e6);
      } else {
        const e6 = new u3();
        this._updateFromIntersection(e6, t6), this.analysis.observer = e6;
      }
  }
  _clickHandler(e5) {
    this.active && e5.button !== t4.Right && (this._addPointFromClickEvent(n6(e5)), e5.stopPropagation());
  }
  _doubleClickHandler(e5) {
    this.active && e5.button !== t4.Right && (this.stop(), e5.stopPropagation());
  }
  _keyDownHandler(e5) {
    this.active && "Escape" === e5.key && (this.stop(), e5.stopPropagation());
  }
  _pointerMoveHandler(e5) {
    if (this.hasFocusedManipulators)
      return;
    if (this._latestPointerMovePointerType = e5.pointerType, this._updateLaserLineRenderer(), !this._showTracker || t(this.analysis.observer) || t(this.analysis.observer.position))
      return;
    const t6 = n6(e5), i4 = this._intersector.getScreenPointIntersection(t6);
    r(i4) && r(i4.point) && (t(this.analysisViewData.cursorTarget) && (this.analysisViewData.cursorTarget = new f()), this._updateFromIntersection(this.analysisViewData.cursorTarget, i4), this._updateLaserLineRenderer());
  }
  _updateFromIntersection(e5, t6) {
    if (t(t6.point))
      return e5.position = null, e5.elevationInfo = null, void (e5.feature = null);
    switch (t6.type) {
      case i2.OBJECT:
        if (r(t6.graphic)) {
          const i5 = t6.graphic, r5 = u4(i5);
          "on-the-ground" === r5.mode && (r5.mode = "relative-to-ground", r5.offset = 0), e5.elevationInfo = new x2(r5), e5.feature = i5;
        } else
          e5.elevationInfo = null, e5.feature = null;
        break;
      case i2.TERRAIN:
      case i2.I3S:
        e5.elevationInfo = new x2({ mode: "on-the-ground" }), e5.feature = null;
        break;
      default:
        e5.elevationInfo = null, e5.feature = null;
    }
    const i4 = t6.point.clone();
    i4.z = f2(this.view, i4, { mode: "absolute-height", offset: 0 }, e5.elevationInfo), e5.position = i4;
  }
  _manipulatorClick(e5, t6) {
    if ("observer" === e5.metadata.type || e5.grabbing || e5.dragging || t6.button !== t4.Right || this.analysis.targets.length <= 1)
      return;
    const { target: i4 } = e5.metadata;
    this.analysis.targets.remove(i4), t6.stopPropagation();
  }
  get testInfo() {
    return { laserLineVisualElement: this._laserlineVisualElement };
  }
};
e([d2({ constructOnly: true })], H2.prototype, "view", void 0), e([d2({ constructOnly: true })], H2.prototype, "analysis", void 0), e([d2({ readOnly: true })], H2.prototype, "state", null), e([d2({ readOnly: true })], H2.prototype, "cursor", null), e([d2({ readOnly: true })], H2.prototype, "preferManipulatorCursor", void 0), e([d2()], H2.prototype, "removeIncompleteOnCancel", void 0), e([d2({ readOnly: true })], H2.prototype, "updating", null), e([d2({ type: d7 })], H2.prototype, "configuration", void 0), e([d2({ constructOnly: true })], H2.prototype, "analysisViewData", void 0), e([d2({ readOnly: true })], H2.prototype, "_showTracker", null), e([d2()], H2.prototype, "_latestPointerMovePointerType", void 0), e([d2()], H2.prototype, "_shouldRenderTracker", null), e([d2()], H2.prototype, "_laserlineVisualElement", void 0), e([d2()], H2.prototype, "_grabbedManipulator", void 0), H2 = e([n3("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightTool")], H2);
var A = v();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightVisualization.js
var V2 = class extends y {
  constructor(i4) {
    super(i4), this._lineOfSightVisualizations = [], this._computationHandles = new u2();
  }
  initialize() {
    this.own(this._connectComputations()), this._createObserverVisualization();
  }
  destroy() {
    this._computationHandles = l(this._computationHandles), this._observerVisualElement = l(this._observerVisualElement);
  }
  get visible() {
    return this.analysisViewData.visible;
  }
  get interactiveAndEditable() {
    return this.analysisViewData.interactive && this.analysisViewData.editable;
  }
  get testInfo() {
    return { visualizations: this._lineOfSightVisualizations };
  }
  get _configuration() {
    return this.analysisViewData.configuration;
  }
  _createLineOfSightVisualization() {
    const i4 = this._configuration, t6 = this.view, o2 = { view: t6, attached: true, width: i4.outerWidth, innerWidth: i4.innerWidth }, n13 = l2.toUnitRGBA(i4.visibleOuterColor), s6 = l2.toUnitRGBA(i4.visibleInnerColor), r5 = l2.toUnitRGBA(i4.occludedOuterColor), a5 = l2.toUnitRGBA(i4.occludedInnerColor), l8 = l2.toUnitRGBA(i4.undefinedOuterColor), c4 = l2.toUnitRGBA(i4.undefinedInnerColor), u7 = { visibleLineVisualElement: new C({ ...o2, color: n13, innerColor: s6 }), occludedLineVisualElement: new C({ ...o2, color: r5, innerColor: a5 }), undefinedLineVisualElement: new C({ ...o2, color: l8, innerColor: c4 }), targetVisualElement: new S({ view: t6, attached: true, ..._3, size: 8 }) };
    return this._lineOfSightVisualizations.push(u7), u7;
  }
  _destroyLineOfSightVisualization(i4) {
    i4.visibleLineVisualElement = l(i4.visibleLineVisualElement), i4.occludedLineVisualElement = l(i4.occludedLineVisualElement), i4.undefinedLineVisualElement = l(i4.undefinedLineVisualElement), i4.targetVisualElement = l(i4.targetVisualElement), this._lineOfSightVisualizations.splice(this._lineOfSightVisualizations.indexOf(i4), 1);
  }
  _updateLineOfSightVisualization(i4, t6, o2) {
    const n13 = this._configuration, { computationResult: s6, inputPoints: r5 } = i4, { start: l8, end: c4, intersection: u7, isValid: d8, isTargetVisible: m5 } = s6, { observer: h3 } = r5, f4 = O4;
    f4[12] = h3[0], f4[13] = h3[1], f4[14] = h3[2];
    const g = e3(y2, l8, h3), b = e3(C2, c4, h3), V3 = e3(E, u7, h3), { visibleLineVisualElement: _4, occludedLineVisualElement: L3, undefinedLineVisualElement: A2, targetVisualElement: w5 } = t6, z2 = t(this.analysisViewData.elevationAlignedObserver) || t(i4.elevationAlignedTargetLocation), S2 = this.visible && !z2;
    _4.visible = S2, L3.visible = S2, A2.visible = S2, w5.visible = S2, w5.attached = !o2.interactiveAndEditable, S2 && (_4.geometry = null, L3.geometry = null, A2.geometry = null, w5.geometry = i4.elevationAlignedTargetLocation, d8 ? m5 ? (_4.geometry = [[e2(g), e2(b)]], _4.transform = f4, _4.color = l2.toUnitRGBA(n13.visibleOuterColor), w5.color = l2.toUnitRGBA(n13.visibleInnerColor)) : (_4.geometry = [[e2(g), e2(V3)]], _4.transform = f4, _4.color = l2.toUnitRGBA(n13.occludedOuterColor), L3.geometry = [[e2(V3), e2(b)]], L3.transform = f4, w5.color = l2.toUnitRGBA(n13.occludedInnerColor)) : (A2.geometry = [[e2(g), e2(b)]], A2.transform = f4, w5.color = l2.toUnitRGBA(n13.undefinedInnerColor)));
  }
  _getLineOfSightVisualizationDependencies(i4) {
    const { computationResult: e5 } = i4, { occludedOuterColor: t6, visibleOuterColor: o2 } = this._configuration;
    return { computationResult: e5, occludedOuterColor: t6, visibleOuterColor: o2, visible: this.visible, interactiveAndEditable: this.interactiveAndEditable };
  }
  _connectComputation(i4) {
    const e5 = this._computationHandles;
    if (e5.has(i4))
      return;
    const t6 = this._createLineOfSightVisualization();
    e5.add([l3(() => this._getLineOfSightVisualizationDependencies(i4), (e6) => this._updateLineOfSightVisualization(i4, t6, e6), { sync: true, initial: true, equals: d }), n2(() => this._destroyLineOfSightVisualization(t6))], i4);
  }
  _disconnectComputation(i4) {
    this._computationHandles.remove(i4);
  }
  _connectComputations() {
    return a(() => this.analysisViewData.computations, "change", (i4) => this._onComputationsCollectionChange(i4), { sync: true, onListenerAdd: (i4) => {
      for (const e5 of i4)
        this._connectComputation(e5);
    }, onListenerRemove: (i4) => {
      for (const e5 of i4)
        this._disconnectComputation(e5);
    } });
  }
  _onComputationsCollectionChange({ added: i4, removed: e5 }) {
    for (const t6 of e5)
      this._disconnectComputation(t6);
    for (const t6 of i4)
      this._connectComputation(t6);
  }
  _createObserverVisualization() {
    const i4 = l2.toUnitRGBA(this._configuration.visibleInnerColor), t6 = new S({ view: this.view, attached: false, color: i4, ..._3 });
    this._observerVisualElement = t6, this.own(l3(() => ({ observer: this.analysisViewData.elevationAlignedObserver, interactiveAndEditable: this.interactiveAndEditable, visible: this.visible }), ({ observer: i5, interactiveAndEditable: e5, visible: o2 }) => {
      t(i5) || e5 || !o2 ? t6.attached = false : (t6.geometry = i5, this._observerVisualElement.attached = true);
    }, h2));
  }
};
e([d2({ constructOnly: true })], V2.prototype, "analysis", void 0), e([d2({ constructOnly: true })], V2.prototype, "analysisViewData", void 0), e([d2({ constructOnly: true })], V2.prototype, "view", void 0), e([d2({ readOnly: true })], V2.prototype, "visible", null), e([d2()], V2.prototype, "interactiveAndEditable", null), e([d2()], V2.prototype, "testInfo", null), e([d2()], V2.prototype, "_configuration", null), V2 = e([n3("esri.views.3d.analysis.LineOfSight.LineOfSightVisualization")], V2);
var _3 = { size: 6, pixelSnappingEnabled: false, primitive: "circle", elevationInfo: { mode: "absolute-height", offset: 0 }, outlineSize: 0 };
var y2 = n4();
var C2 = n4();
var E = n4();
var O4 = e4();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSightAnalysisView3D.js
var f3 = class extends n7(n5.EventedMixin(y)) {
  constructor(t6) {
    super(t6), this.type = "line-of-sight-view-3d", this.analysis = null, this.tool = null, this.computations = new j3(), this.elevationAlignedObserver = null, this.configuration = new s3(), this.observerEngineLocation = n4(), this.cursorTarget = null, this.editable = true;
  }
  initialize() {
    const t6 = this.view, i4 = this.analysis;
    this._analysisController = new Y({ analysis: i4, analysisViewData: this, view: t6 }), this._analysisVisualization = new V2({ analysis: i4, analysisViewData: this, view: t6 }), this.own([this._analysisController.on("result-changed", (t7) => {
      t7.target !== this.cursorTarget && this.emit("result-changed", t7);
    }), c3(this, H2)]);
  }
  destroy() {
    m3(this), this._analysisController = l(this._analysisController), this._analysisVisualization = l(this._analysisVisualization);
  }
  get results() {
    return this.computations.map((t6) => t6.result);
  }
  get priority() {
    return this._analysisController.priority;
  }
  set priority(t6) {
    this._analysisController.priority = t6;
  }
  get updating() {
    return r(this._analysisController) && this._analysisController.updating;
  }
  getResultForTarget(t6) {
    const i4 = this.computations.find((i5) => i5.target === t6);
    return o(i4, (t7) => t7.result);
  }
  get testInfo() {
    return { visualization: this._analysisVisualization, controller: this._analysisController };
  }
};
e([d2({ readOnly: true })], f3.prototype, "type", void 0), e([d2({ constructOnly: true, nonNullable: true })], f3.prototype, "analysis", void 0), e([d2()], f3.prototype, "tool", void 0), e([d2({ readOnly: true })], f3.prototype, "results", null), e([d2()], f3.prototype, "priority", null), e([d2()], f3.prototype, "computations", void 0), e([d2()], f3.prototype, "elevationAlignedObserver", void 0), e([d2()], f3.prototype, "configuration", void 0), e([d2()], f3.prototype, "observerEngineLocation", void 0), e([d2()], f3.prototype, "cursorTarget", void 0), e([d2()], f3.prototype, "updating", null), e([d2()], f3.prototype, "editable", void 0), e([d2()], f3.prototype, "_analysisController", void 0), e([d2()], f3.prototype, "_analysisVisualization", void 0), f3 = e([n3("esri.views.3d.analysis.LineOfSightAnalysisView3D")], f3);
var v2 = f3;
export {
  v2 as default
};
//# sourceMappingURL=LineOfSightAnalysisView3D-VU6QBM5F.js.map
