import {
  s as s3
} from "./chunk-XRL56EGK.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/support/PixelBlock.js
var n2;
var p = s.getLogger("esri.layers.support.PixelBlock");
var c = n2 = class extends l {
  constructor(t2) {
    super(t2), this.width = null, this.height = null, this.pixelType = "f32", this.validPixelCount = null, this.mask = null, this.maskIsAlpha = false, this.pixels = null, this.statistics = null;
  }
  static createEmptyBand(t2, e2) {
    return new (n2.getPixelArrayConstructor(t2))(e2);
  }
  static getPixelArrayConstructor(t2) {
    let e2;
    switch (t2) {
      case "u1":
      case "u2":
      case "u4":
      case "u8":
        e2 = Uint8Array;
        break;
      case "u16":
        e2 = Uint16Array;
        break;
      case "u32":
        e2 = Uint32Array;
        break;
      case "s8":
        e2 = Int8Array;
        break;
      case "s16":
        e2 = Int16Array;
        break;
      case "s32":
        e2 = Int32Array;
        break;
      case "f32":
      case "c64":
      case "c128":
      case "unknown":
        e2 = Float32Array;
        break;
      case "f64":
        e2 = Float64Array;
    }
    return e2;
  }
  castPixelType(t2) {
    if (!t2)
      return "f32";
    let e2 = t2.toLowerCase();
    return ["u1", "u2", "u4"].includes(e2) ? e2 = "u8" : ["unknown", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"].includes(e2) || (e2 = "f32"), e2;
  }
  getPlaneCount() {
    return this.pixels && this.pixels.length;
  }
  addData(t2) {
    if (!t2.pixels || t2.pixels.length !== this.width * this.height)
      throw new s2("pixelblock:invalid-or-missing-pixels", "add data requires valid pixels array that has same length defined by pixel block width * height");
    this.pixels || (this.pixels = []), this.statistics || (this.statistics = []), this.pixels.push(t2.pixels), this.statistics.push(t2.statistics || { minValue: null, maxValue: null });
  }
  getAsRGBA() {
    const t2 = new ArrayBuffer(this.width * this.height * 4);
    switch (this.pixelType) {
      case "s8":
      case "s16":
      case "u16":
      case "s32":
      case "u32":
      case "f32":
      case "f64":
        this._fillFromNon8Bit(t2);
        break;
      default:
        this._fillFrom8Bit(t2);
    }
    return new Uint8ClampedArray(t2);
  }
  getAsRGBAFloat() {
    const t2 = new Float32Array(this.width * this.height * 4);
    return this._fillFrom32Bit(t2), t2;
  }
  updateStatistics() {
    this.statistics = this.pixels.map((t3) => this._calculateBandStatistics(t3, this.mask));
    const t2 = this.mask;
    let e2 = 0;
    if (t2)
      for (let s5 = 0; s5 < t2.length; s5++)
        t2[s5] && e2++;
    else
      e2 = this.width * this.height;
    this.validPixelCount = e2;
  }
  clamp(t2) {
    if (!t2 || "f64" === t2 || "f32" === t2)
      return;
    let e2;
    switch (t2) {
      case "u8":
        e2 = [0, 255];
        break;
      case "u16":
        e2 = [0, 65535];
        break;
      case "u32":
        e2 = [0, 4294967295];
        break;
      case "s8":
        e2 = [-128, 127];
        break;
      case "s16":
        e2 = [-32768, 32767];
        break;
      case "s32":
        e2 = [-2147483648, 2147483647];
        break;
      default:
        e2 = [-34e38, 34e38];
    }
    const [s5, i2] = e2, l3 = this.pixels, r3 = this.width * this.height, a2 = l3.length;
    let o2, h2, p3;
    const c3 = [];
    for (let u3 = 0; u3 < a2; u3++) {
      p3 = n2.createEmptyBand(t2, r3), o2 = l3[u3];
      for (let t3 = 0; t3 < r3; t3++)
        h2 = o2[t3], p3[t3] = h2 > i2 ? i2 : h2 < s5 ? s5 : h2;
      c3.push(p3);
    }
    this.pixels = c3, this.pixelType = t2;
  }
  extractBands(t2) {
    if (t(t2) || 0 === t2.length || null == this.pixels || 0 === this.pixels.length)
      return this;
    const e2 = this.pixels.length, s5 = t2.some((t3) => t3 >= this.pixels.length), i2 = e2 === t2.length && !t2.some((t3, e3) => t3 !== e3);
    return s5 || i2 ? this : new n2({ pixelType: this.pixelType, width: this.width, height: this.height, mask: this.mask, validPixelCount: this.validPixelCount, maskIsAlpha: this.maskIsAlpha, pixels: t2.map((t3) => this.pixels[t3]), statistics: this.statistics && t2.map((t3) => this.statistics[t3]) });
  }
  clone() {
    const t2 = new n2({ width: this.width, height: this.height, pixelType: this.pixelType, maskIsAlpha: this.maskIsAlpha, validPixelCount: this.validPixelCount });
    let e2;
    this.mask && (this.mask instanceof Uint8Array ? t2.mask = new Uint8Array(this.mask) : t2.mask = this.mask.slice(0));
    const s5 = n2.getPixelArrayConstructor(this.pixelType);
    if (this.pixels && this.pixels.length > 0) {
      t2.pixels = [];
      const i2 = this.pixels[0].slice;
      for (e2 = 0; e2 < this.pixels.length; e2++)
        t2.pixels[e2] = i2 ? this.pixels[e2].slice(0, this.pixels[e2].length) : new s5(this.pixels[e2]);
    }
    if (this.statistics)
      for (t2.statistics = [], e2 = 0; e2 < this.statistics.length; e2++)
        t2.statistics[e2] = m(this.statistics[e2]);
    return t2;
  }
  _fillFrom8Bit(t2) {
    const { mask: e2, maskIsAlpha: s5, pixels: i2 } = this;
    if (!t2 || !i2 || !i2.length)
      return void p.error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    let l3, r3, a2, o2;
    l3 = r3 = a2 = i2[0], i2.length >= 3 ? (r3 = i2[1], a2 = i2[2]) : 2 === i2.length && (r3 = i2[1]);
    const h2 = new Uint32Array(t2), n3 = this.width * this.height;
    if (l3.length === n3)
      if (e2 && e2.length === n3)
        if (s5)
          for (o2 = 0; o2 < n3; o2++)
            e2[o2] && (h2[o2] = e2[o2] << 24 | a2[o2] << 16 | r3[o2] << 8 | l3[o2]);
        else
          for (o2 = 0; o2 < n3; o2++)
            e2[o2] && (h2[o2] = 255 << 24 | a2[o2] << 16 | r3[o2] << 8 | l3[o2]);
      else
        for (o2 = 0; o2 < n3; o2++)
          h2[o2] = 255 << 24 | a2[o2] << 16 | r3[o2] << 8 | l3[o2];
    else
      p.error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
  }
  _fillFromNon8Bit(t2) {
    const { pixels: e2, mask: s5, statistics: i2 } = this;
    if (!t2 || !e2 || !e2.length)
      return void p.error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    const l3 = this.pixelType;
    let r3 = 1, a2 = 0, o2 = 1;
    if (i2 && i2.length > 0)
      a2 = i2.map((t3) => t3.minValue).reduce((t3, e3) => Math.min(t3, e3)), o2 = i2.map((t3) => t3.maxValue - t3.minValue).reduce((t3, e3) => Math.max(t3, e3)), r3 = 255 / o2;
    else {
      let t3 = 255;
      "s8" === l3 ? (a2 = -128, t3 = 127) : "u16" === l3 ? t3 = 65535 : "s16" === l3 ? (a2 = -32768, t3 = 32767) : "u32" === l3 ? t3 = 4294967295 : "s32" === l3 ? (a2 = -2147483648, t3 = 2147483647) : "f32" === l3 ? (a2 = -34e38, t3 = 34e38) : "f64" === l3 && (a2 = -Number.MAX_VALUE, t3 = Number.MAX_VALUE), r3 = 255 / (t3 - a2);
    }
    const h2 = new Uint32Array(t2), n3 = this.width * this.height;
    let c3, u3, m3, x2, f2;
    if (c3 = u3 = m3 = e2[0], c3.length !== n3)
      return p.error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
    if (e2.length >= 2)
      if (u3 = e2[1], e2.length >= 3 && (m3 = e2[2]), s5 && s5.length === n3)
        for (x2 = 0; x2 < n3; x2++)
          s5[x2] && (h2[x2] = 255 << 24 | (m3[x2] - a2) * r3 << 16 | (u3[x2] - a2) * r3 << 8 | (c3[x2] - a2) * r3);
      else
        for (x2 = 0; x2 < n3; x2++)
          h2[x2] = 255 << 24 | (m3[x2] - a2) * r3 << 16 | (u3[x2] - a2) * r3 << 8 | (c3[x2] - a2) * r3;
    else if (s5 && s5.length === n3)
      for (x2 = 0; x2 < n3; x2++)
        f2 = (c3[x2] - a2) * r3, s5[x2] && (h2[x2] = 255 << 24 | f2 << 16 | f2 << 8 | f2);
    else
      for (x2 = 0; x2 < n3; x2++)
        f2 = (c3[x2] - a2) * r3, h2[x2] = 255 << 24 | f2 << 16 | f2 << 8 | f2;
  }
  _fillFrom32Bit(t2) {
    const { pixels: e2, mask: s5 } = this;
    if (!t2 || !e2 || !e2.length)
      return p.error("getAsRGBAFloat()", "Unable to convert to RGBA. The input pixel block is empty.");
    let i2, l3, r3, a2;
    i2 = l3 = r3 = e2[0], e2.length >= 3 ? (l3 = e2[1], r3 = e2[2]) : 2 === e2.length && (l3 = e2[1]);
    const o2 = this.width * this.height;
    if (i2.length !== o2)
      return p.error("getAsRGBAFloat()", "Unable to convert to RGBA. The pixelblock is invalid.");
    let h2 = 0;
    if (s5 && s5.length === o2)
      for (a2 = 0; a2 < o2; a2++)
        t2[h2++] = i2[a2], t2[h2++] = l3[a2], t2[h2++] = r3[a2], t2[h2++] = 1 & s5[a2];
    else
      for (a2 = 0; a2 < o2; a2++)
        t2[h2++] = i2[a2], t2[h2++] = l3[a2], t2[h2++] = r3[a2], t2[h2++] = 1;
  }
  _calculateBandStatistics(t2, e2) {
    let s5 = 1 / 0, i2 = -1 / 0;
    const l3 = t2.length;
    let r3, a2 = 0;
    if (e2)
      for (r3 = 0; r3 < l3; r3++)
        e2[r3] && (a2 = t2[r3], s5 = a2 < s5 ? a2 : s5, i2 = a2 > i2 ? a2 : i2);
    else
      for (r3 = 0; r3 < l3; r3++)
        a2 = t2[r3], s5 = a2 < s5 ? a2 : s5, i2 = a2 > i2 ? a2 : i2;
    return { minValue: s5, maxValue: i2 };
  }
};
e([d({ json: { write: true } })], c.prototype, "width", void 0), e([d({ json: { write: true } })], c.prototype, "height", void 0), e([d({ json: { write: true } })], c.prototype, "pixelType", void 0), e([s3("pixelType")], c.prototype, "castPixelType", null), e([d({ json: { write: true } })], c.prototype, "validPixelCount", void 0), e([d({ json: { write: true } })], c.prototype, "mask", void 0), e([d({ json: { write: true } })], c.prototype, "maskIsAlpha", void 0), e([d({ json: { write: true } })], c.prototype, "pixels", void 0), e([d({ json: { write: true } })], c.prototype, "statistics", void 0), c = n2 = e([n("esri.layers.support.PixelBlock")], c);
var u = c;

// node_modules/@arcgis/core/layers/support/rasterFunctions/pixelUtils.js
function i(e2) {
  return r(e2) && "esri.layers.support.PixelBlock" === e2.declaredClass && e2.pixels && e2.pixels.length > 0;
}
function l2(t2, e2) {
  if (!(e2 == null ? void 0 : e2.length) || !i(t2))
    return t2;
  const l3 = t2.pixels.length;
  return e2 && e2.some((t3) => t3 >= l3) || 1 === l3 && 1 === e2.length && 0 === e2[0] ? t2 : l3 !== e2.length || e2.some((t3, e3) => t3 !== e3) ? new u({ pixelType: t2.pixelType, width: t2.width, height: t2.height, mask: t2.mask, validPixelCount: t2.validPixelCount, maskIsAlpha: t2.maskIsAlpha, pixels: e2.map((e3) => t2.pixels[e3]), statistics: t2.statistics && e2.map((e3) => t2.statistics[e3]) }) : t2;
}
function o(t2) {
  if (!t2)
    return;
  const e2 = t2.colormap;
  if (!e2 || 0 === e2.length)
    return;
  const n3 = e2.sort((t3, e3) => t3[0] - e3[0]);
  let i2 = 0;
  n3[0][0] < 0 && (i2 = n3[0][0]);
  const l3 = Math.max(256, n3[n3.length - 1][0] - i2 + 1), o2 = new Uint8Array(4 * l3), r3 = [];
  let s5, a2 = 0, h2 = 0;
  const f2 = 5 === n3[0].length;
  if (l3 > 65536)
    return n3.forEach((t3) => {
      r3[t3[0] - i2] = f2 ? t3.slice(1) : t3.slice(1).concat([255]);
    }), { indexed2DColormap: r3, offset: i2, alphaSpecified: f2 };
  if (t2.fillUnspecified)
    for (s5 = n3[h2], a2 = s5[0] - i2; a2 < l3; a2++)
      o2[4 * a2] = s5[1], o2[4 * a2 + 1] = s5[2], o2[4 * a2 + 2] = s5[3], o2[4 * a2 + 3] = f2 ? s5[4] : 255, a2 === s5[0] - i2 && (s5 = h2 === n3.length - 1 ? s5 : n3[++h2]);
  else
    for (a2 = 0; a2 < n3.length; a2++)
      s5 = n3[a2], h2 = 4 * (s5[0] - i2), o2[h2] = s5[1], o2[h2 + 1] = s5[2], o2[h2 + 2] = s5[3], o2[h2 + 3] = f2 ? s5[4] : 255;
  return { indexedColormap: o2, offset: i2, alphaSpecified: f2 };
}
function r2(t2, e2) {
  if (!i(t2))
    return t2;
  if (!e2 && (e2.indexedColormap || e2.indexed2DColormap))
    return t2;
  const n3 = t2.clone(), l3 = n3.pixels;
  let o2 = n3.mask;
  const r3 = n3.width * n3.height;
  if (1 !== l3.length)
    return t2;
  const { indexedColormap: s5, indexed2DColormap: a2, offset: h2, alphaSpecified: f2 } = e2, c3 = s5.length - 1;
  let u3 = 0;
  const p3 = l3[0], x2 = new Uint8Array(p3.length), m3 = new Uint8Array(p3.length), d3 = new Uint8Array(p3.length);
  let y2, g2 = 0;
  if (s5)
    if (o2)
      for (u3 = 0; u3 < r3; u3++)
        o2[u3] && (g2 = 4 * (p3[u3] - h2), g2 < h2 || g2 > c3 ? o2[u3] = 0 : (x2[u3] = s5[g2], m3[u3] = s5[g2 + 1], d3[u3] = s5[g2 + 2], o2[u3] = s5[g2 + 3]));
    else {
      for (o2 = new Uint8Array(r3), u3 = 0; u3 < r3; u3++)
        g2 = 4 * (p3[u3] - h2), g2 < h2 || g2 > c3 ? o2[u3] = 0 : (x2[u3] = s5[g2], m3[u3] = s5[g2 + 1], d3[u3] = s5[g2 + 2], o2[u3] = s5[g2 + 3]);
      n3.mask = o2;
    }
  else if (o2)
    for (u3 = 0; u3 < r3; u3++)
      o2[u3] && (y2 = a2[p3[u3]], x2[u3] = y2[0], m3[u3] = y2[1], d3[u3] = y2[2], o2[u3] = y2[3]);
  else {
    for (o2 = new Uint8Array(r3), u3 = 0; u3 < r3; u3++)
      y2 = a2[p3[u3]], x2[u3] = y2[0], m3[u3] = y2[1], d3[u3] = y2[2], o2[u3] = y2[3];
    n3.mask = o2;
  }
  return n3.pixels = [x2, m3, d3], n3.statistics = null, n3.pixelType = "u8", n3.maskIsAlpha = f2, n3;
}
function s4(t2, e2) {
  if (!i(t2))
    return null;
  const { pixels: l3, mask: o2 } = t2, r3 = t2.width * t2.height, s5 = l3.length;
  let a2 = e2.lut;
  const { offset: h2 } = e2;
  let f2, c3;
  a2 && 1 === a2[0].length && (a2 = l3.map(() => a2));
  const u3 = [];
  let p3, x2, m3;
  if (h2)
    if (null == o2)
      for (f2 = 0; f2 < s5; f2++) {
        for (p3 = l3[f2], x2 = a2[f2], m3 = new Uint8Array(r3), c3 = 0; c3 < r3; c3++)
          m3[c3] = x2[p3[c3] - h2];
        u3.push(m3);
      }
    else
      for (f2 = 0; f2 < s5; f2++) {
        for (p3 = l3[f2], x2 = a2[f2], m3 = new Uint8Array(r3), c3 = 0; c3 < r3; c3++)
          o2[c3] && (m3[c3] = x2[p3[c3] - h2]);
        u3.push(m3);
      }
  else if (null == o2)
    for (f2 = 0; f2 < s5; f2++) {
      for (p3 = l3[f2], x2 = a2[f2], m3 = new Uint8Array(r3), c3 = 0; c3 < r3; c3++)
        m3[c3] = x2[p3[c3]];
      u3.push(m3);
    }
  else
    for (f2 = 0; f2 < s5; f2++) {
      for (p3 = l3[f2], x2 = a2[f2], m3 = new Uint8Array(r3), c3 = 0; c3 < r3; c3++)
        o2[c3] && (m3[c3] = x2[p3[c3]]);
      u3.push(m3);
    }
  const d3 = new u({ width: t2.width, height: t2.height, pixels: u3, mask: o2, pixelType: "u8" });
  return d3.updateStatistics(), d3;
}
function a(t2, e2) {
  if (!i(t2))
    return null;
  const n3 = t2.clone(), { pixels: l3 } = n3, o2 = n3.width * n3.height, r3 = e2.length, s5 = Math.floor(r3 / 2), a2 = e2[Math.floor(s5)], h2 = l3[0];
  let f2, c3, u3, p3, x2, m3, d3 = false;
  const y2 = new Uint8Array(o2), g2 = new Uint8Array(o2), w2 = new Uint8Array(o2);
  let k2 = n3.mask;
  const M2 = 4 === e2[0].mappedColor.length;
  for (k2 || (k2 = new Uint8Array(o2), k2.fill(M2 ? 255 : 1), n3.mask = k2), x2 = 0; x2 < o2; x2++)
    if (k2[x2]) {
      for (f2 = h2[x2], d3 = false, m3 = s5, c3 = a2, u3 = 0, p3 = r3 - 1; p3 - u3 > 1; ) {
        if (f2 === c3.value) {
          d3 = true;
          break;
        }
        f2 > c3.value ? u3 = m3 : p3 = m3, m3 = Math.floor((u3 + p3) / 2), c3 = e2[Math.floor(m3)];
      }
      d3 || (f2 === e2[u3].value ? (c3 = e2[u3], d3 = true) : f2 === e2[p3].value ? (c3 = e2[p3], d3 = true) : f2 < e2[u3].value ? (d3 = false, c3 = null) : f2 > e2[u3].value && (f2 < e2[p3].value ? (c3 = e2[u3], d3 = true) : p3 === r3 - 1 ? (d3 = false, c3 = null) : (c3 = e2[p3], d3 = true))), d3 ? (y2[x2] = c3.mappedColor[0], g2[x2] = c3.mappedColor[1], w2[x2] = c3.mappedColor[2], k2[x2] = c3.mappedColor[3]) : y2[x2] = g2[x2] = w2[x2] = k2[x2] = 0;
    }
  return n3.pixels = [y2, g2, w2], n3.mask = k2, n3.pixelType = "u8", n3.maskIsAlpha = M2, n3;
}
function h(t2, e2, n3, i2, l3, o2, r3, s5) {
  return { xmin: l3 <= n3 * t2 ? 0 : l3 < n3 * t2 + t2 ? l3 - n3 * t2 : t2, ymin: o2 <= i2 * e2 ? 0 : o2 < i2 * e2 + e2 ? o2 - i2 * e2 : e2, xmax: l3 + r3 <= n3 * t2 ? 0 : l3 + r3 < n3 * t2 + t2 ? l3 + r3 - n3 * t2 : t2, ymax: o2 + s5 <= i2 * e2 ? 0 : o2 + s5 < i2 * e2 + e2 ? o2 + s5 - i2 * e2 : e2 };
}
function f(t2, n3) {
  if (!t2 || 0 === t2.length)
    return null;
  const i2 = t2.find((t3) => t3.pixelBlock);
  if (!i2 || t(i2.pixelBlock))
    return null;
  const l3 = (i2.extent.xmax - i2.extent.xmin) / i2.pixelBlock.width, o2 = (i2.extent.ymax - i2.extent.ymin) / i2.pixelBlock.height, r3 = 0.01 * Math.min(l3, o2), s5 = t2.sort((t3, e2) => Math.abs(t3.extent.ymax - e2.extent.ymax) > r3 ? e2.extent.ymax - t3.extent.ymax : Math.abs(t3.extent.xmin - e2.extent.xmin) > r3 ? t3.extent.xmin - e2.extent.xmin : 0), a2 = Math.min.apply(null, s5.map((t3) => t3.extent.xmin)), h2 = Math.min.apply(null, s5.map((t3) => t3.extent.ymin)), f2 = Math.max.apply(null, s5.map((t3) => t3.extent.xmax)), c3 = Math.max.apply(null, s5.map((t3) => t3.extent.ymax)), p3 = { x: Math.round((n3.xmin - a2) / l3), y: Math.round((c3 - n3.ymax) / o2) }, x2 = { width: Math.round((f2 - a2) / l3), height: Math.round((c3 - h2) / o2) }, m3 = { width: Math.round((n3.xmax - n3.xmin) / l3), height: Math.round((n3.ymax - n3.ymin) / o2) };
  if (Math.round(x2.width / i2.pixelBlock.width) * Math.round(x2.height / i2.pixelBlock.height) !== s5.length || p3.x < 0 || p3.y < 0 || x2.width < m3.width || x2.height < m3.height)
    return null;
  return { extent: n3, pixelBlock: u2(s5.map((t3) => t3.pixelBlock), x2, { clipOffset: p3, clipSize: m3 }) };
}
function c2(t2, e2, n3, i2, l3, o2) {
  const { width: r3, height: s5 } = n3.block, { x: a2, y: f2 } = n3.offset, { width: c3, height: u3 } = n3.mosaic, p3 = h(r3, s5, i2, l3, a2, f2, c3, u3);
  let x2 = 0, m3 = 0;
  if (o2) {
    const t3 = o2.hasGCSSShiftTransform ? 360 : o2.halfWorldWidth, e3 = r3 * o2.resolutionX, n4 = o2.startX + i2 * e3, l4 = n4 + e3;
    n4 < t3 && l4 > t3 ? m3 = o2.rightPadding : n4 >= t3 && (x2 = o2.leftMargin - o2.rightPadding, m3 = 0);
  }
  if (p3.xmax -= m3, "number" != typeof e2)
    for (let h2 = p3.ymin; h2 < p3.ymax; h2++) {
      const n4 = (l3 * s5 + h2 - f2) * c3 + (i2 * r3 - a2) + x2, o3 = h2 * r3;
      for (let i3 = p3.xmin; i3 < p3.xmax; i3++)
        t2[n4 + i3] = e2[o3 + i3];
    }
  else
    for (let h2 = p3.ymin; h2 < p3.ymax; h2++) {
      const n4 = (l3 * s5 + h2 - f2) * c3 + (i2 * r3 - a2) + x2;
      for (let i3 = p3.xmin; i3 < p3.xmax; i3++)
        t2[n4 + i3] = e2;
    }
}
function u2(l3, o2, r3 = {}) {
  const { clipOffset: s5, clipSize: a2, alignmentInfo: h2, blockWidths: f2 } = r3;
  if (f2)
    return p2(l3, o2, { blockWidths: f2 });
  const u3 = l3.find((t2) => i(t2));
  if (t(u3))
    return null;
  const x2 = a2 ? a2.width : o2.width, m3 = a2 ? a2.height : o2.height, d3 = u3.width, y2 = u3.height, g2 = o2.width / d3, w2 = o2.height / y2, k2 = { offset: s5 || { x: 0, y: 0 }, mosaic: a2 || o2, block: { width: d3, height: y2 } }, M2 = u3.pixelType, A2 = u.getPixelArrayConstructor(M2), U2 = u3.pixels.length, C2 = [];
  let T, S;
  for (let t2 = 0; t2 < U2; t2++) {
    S = new A2(x2 * m3);
    for (let e2 = 0; e2 < w2; e2++)
      for (let n3 = 0; n3 < g2; n3++) {
        const o3 = l3[e2 * g2 + n3];
        i(o3) && (T = o3.pixels[t2], c2(S, T, k2, n3, e2, h2));
      }
    C2.push(S);
  }
  let B;
  if (l3.some((t2) => t(t2) || t2.mask && t2.mask.length > 0)) {
    B = new Uint8Array(x2 * m3);
    for (let e2 = 0; e2 < w2; e2++)
      for (let n3 = 0; n3 < g2; n3++) {
        const i2 = l3[e2 * g2 + n3], o3 = r(i2) ? i2.mask : null;
        c2(B, o3 || (i2 ? 1 : 0), k2, n3, e2, h2);
      }
  }
  const v = new u({ width: x2, height: m3, pixels: C2, pixelType: M2, mask: B });
  return v.updateStatistics(), v;
}
function p2(l3, o2, r3) {
  const s5 = l3.find((e2) => r(e2));
  if (t(s5))
    return null;
  const a2 = l3.some((e2) => !r(e2) || !!e2.mask), { width: h2, height: f2 } = o2, c3 = a2 ? new Uint8Array(h2 * f2) : null, { blockWidths: u3 } = r3, p3 = [], x2 = s5.getPlaneCount(), m3 = u.getPixelArrayConstructor(s5.pixelType);
  if (a2)
    for (let t2 = 0, e2 = 0; t2 < l3.length; e2 += u3[t2], t2++) {
      const n3 = l3[t2];
      if (!i(n3))
        continue;
      const o3 = n3.mask;
      for (let i2 = 0; i2 < f2; i2++)
        for (let l4 = 0; l4 < u3[t2]; l4++)
          c3[i2 * h2 + l4 + e2] = null == o3 ? 255 : o3[i2 * n3.width + l4];
    }
  for (let t2 = 0; t2 < x2; t2++) {
    const e2 = new m3(h2 * f2);
    for (let n3 = 0, o3 = 0; n3 < l3.length; o3 += u3[n3], n3++) {
      const r4 = l3[n3];
      if (!i(r4))
        continue;
      const s6 = r4.pixels[t2];
      if (null != s6)
        for (let t3 = 0; t3 < f2; t3++)
          for (let i2 = 0; i2 < u3[n3]; i2++)
            e2[t3 * h2 + i2 + o3] = s6[t3 * r4.width + i2];
    }
    p3.push(e2);
  }
  const d3 = new u({ width: h2, height: f2, mask: c3, pixels: p3, pixelType: s5.pixelType });
  return d3.updateStatistics(), d3;
}
function x(t2, e2, n3) {
  if (!i(t2))
    return null;
  const { width: l3, height: o2 } = t2, r3 = e2.x, s5 = e2.y, a2 = n3.width + r3, h2 = n3.height + s5;
  if (r3 < 0 || s5 < 0 || a2 > l3 || h2 > o2)
    return t2;
  if (0 === r3 && 0 === s5 && a2 === l3 && h2 === o2)
    return t2;
  t2.mask || (t2.mask = new Uint8Array(l3 * o2));
  const f2 = t2.mask;
  for (let i2 = 0; i2 < o2; i2++) {
    const t3 = i2 * l3;
    for (let e3 = 0; e3 < l3; e3++)
      f2[t3 + e3] = i2 < s5 || i2 >= h2 || e3 < r3 || e3 >= a2 ? 0 : 1;
  }
  return t2.updateStatistics(), t2;
}
function m2(t2) {
  if (!i(t2))
    return null;
  const e2 = t2.clone(), { width: n3, height: l3, pixels: o2, mask: r3 } = t2, s5 = o2[0], a2 = e2.pixels[0];
  for (let i2 = 2; i2 < l3 - 1; i2++) {
    const t3 = /* @__PURE__ */ new Map();
    for (let l4 = i2 - 2; l4 < i2 + 2; l4++)
      for (let e4 = 0; e4 < 4; e4++) {
        const i3 = l4 * n3 + e4;
        g(t3, s5[i3], r3 ? r3[i3] : 1);
      }
    a2[i2 * n3] = d2(t3), a2[i2 * n3 + 1] = a2[i2 * n3 + 2] = a2[i2 * n3];
    let e3 = 3;
    for (; e3 < n3 - 1; e3++) {
      let l4 = (i2 - 2) * n3 + e3 + 1;
      g(t3, s5[l4], r3 ? r3[l4] : 1), l4 = (i2 - 1) * n3 + e3 + 1, g(t3, s5[l4], r3 ? r3[l4] : 1), l4 = i2 * n3 + e3 + 1, g(t3, s5[l4], r3 ? r3[l4] : 1), l4 = (i2 + 1) * n3 + e3 + 1, g(t3, s5[l4], r3 ? r3[l4] : 1), l4 = (i2 - 2) * n3 + e3 - 3, y(t3, s5[l4], r3 ? r3[l4] : 1), l4 = (i2 - 1) * n3 + e3 - 3, y(t3, s5[l4], r3 ? r3[l4] : 1), l4 = i2 * n3 + e3 - 3, y(t3, s5[l4], r3 ? r3[l4] : 1), l4 = (i2 + 1) * n3 + e3 - 3, y(t3, s5[l4], r3 ? r3[l4] : 1), a2[i2 * n3 + e3] = d2(t3);
    }
    a2[i2 * n3 + e3 + 1] = a2[i2 * n3 + e3];
  }
  for (let i2 = 0; i2 < n3; i2++)
    a2[i2] = a2[n3 + i2] = a2[2 * n3 + i2], a2[(l3 - 1) * n3 + i2] = a2[(l3 - 2) * n3 + i2];
  return e2.updateStatistics(), e2;
}
function d2(t2) {
  if (0 === t2.size)
    return 0;
  let e2 = 0, n3 = -1, i2 = 0;
  const l3 = t2.keys();
  let o2 = l3.next();
  for (; !o2.done; )
    i2 = t2.get(o2.value), i2 > e2 && (n3 = o2.value, e2 = i2), o2 = l3.next();
  return n3;
}
function y(t2, e2, n3) {
  if (0 === n3)
    return;
  const i2 = t2.get(e2);
  1 === i2 ? t2.delete(e2) : t2.set(e2, i2 - 1);
}
function g(t2, e2, n3) {
  0 !== n3 && t2.set(e2, t2.has(e2) ? t2.get(e2) + 1 : 1);
}
function w(t2, e2, l3) {
  let { x: o2, y: r3 } = e2;
  const { width: s5, height: a2 } = l3;
  if (0 === o2 && 0 === r3 && a2 === t2.height && s5 === t2.width)
    return t2;
  const { width: h2, height: f2 } = t2, c3 = Math.max(0, r3), u3 = Math.max(0, o2), p3 = Math.min(o2 + s5, h2), x2 = Math.min(r3 + a2, f2);
  if (p3 < 0 || x2 < 0 || !i(t2))
    return null;
  o2 = Math.max(0, -o2), r3 = Math.max(0, -r3);
  const { pixels: m3, mask: d3 } = t2, y2 = s5 * a2, g2 = m3.length, w2 = [];
  for (let i2 = 0; i2 < g2; i2++) {
    const e3 = m3[i2], l4 = u.createEmptyBand(t2.pixelType, y2);
    for (let t3 = c3; t3 < x2; t3++) {
      const n3 = t3 * h2;
      let i3 = (t3 + r3 - c3) * s5 + o2;
      for (let t4 = u3; t4 < p3; t4++)
        l4[i3++] = e3[n3 + t4];
    }
    w2.push(l4);
  }
  const k2 = new Uint8Array(y2);
  for (let n3 = c3; n3 < x2; n3++) {
    const t3 = n3 * h2;
    let e3 = (n3 + r3 - c3) * s5 + o2;
    for (let n4 = u3; n4 < p3; n4++)
      k2[e3++] = d3 ? d3[t3 + n4] : 1;
  }
  const M2 = new u({ width: l3.width, height: l3.height, pixelType: t2.pixelType, pixels: w2, mask: k2 });
  return M2.updateStatistics(), M2;
}
function k(t2, e2 = true) {
  if (!i(t2))
    return null;
  const { pixels: l3, width: o2, height: r3, mask: s5, pixelType: a2 } = t2, h2 = [], f2 = Math.round(o2 / 2), c3 = Math.round(r3 / 2), u3 = r3 - 1, p3 = o2 - 1;
  for (let i2 = 0; i2 < l3.length; i2++) {
    const t3 = l3[i2], s6 = u.createEmptyBand(a2, f2 * c3);
    let x3 = 0;
    for (let n3 = 0; n3 < r3; n3 += 2)
      for (let i3 = 0; i3 < o2; i3 += 2) {
        const l4 = t3[n3 * o2 + i3];
        if (e2) {
          const e3 = i3 === p3 ? l4 : t3[n3 * o2 + i3 + 1], r4 = n3 === u3 ? l4 : t3[n3 * o2 + i3 + o2], a3 = i3 === p3 ? r4 : n3 === u3 ? e3 : t3[n3 * o2 + i3 + o2 + 1];
          s6[x3++] = (l4 + e3 + r4 + a3) / 4;
        } else
          s6[x3++] = l4;
      }
    h2.push(s6);
  }
  let x2 = null;
  if (s5) {
    x2 = new Uint8Array(f2 * c3);
    let t3 = 0;
    for (let n3 = 0; n3 < r3; n3 += 2)
      for (let i2 = 0; i2 < o2; i2 += 2) {
        const l4 = s5[n3 * o2 + i2];
        if (e2) {
          const e3 = i2 === p3 ? l4 : s5[n3 * o2 + i2 + 1], r4 = n3 === u3 ? l4 : s5[n3 * o2 + i2 + o2], a3 = i2 === p3 ? r4 : n3 === u3 ? e3 : s5[n3 * o2 + i2 + o2 + 1];
          x2[t3++] = l4 * e3 * r4 * a3 ? 1 : 0;
        } else
          x2[t3++] = l4;
      }
  }
  return new u({ width: f2, height: c3, pixelType: a2, pixels: h2, mask: x2 });
}
function M(t2, e2, n3) {
  if (!i(t2))
    return null;
  const { width: l3, height: o2 } = e2;
  let { width: r3, height: s5 } = t2;
  const a2 = /* @__PURE__ */ new Map(), h2 = { x: 0, y: 0 }, f2 = null == n3 ? 1 : 1 + n3;
  let c3 = t2;
  for (let i2 = 0; i2 < f2; i2++) {
    const t3 = Math.ceil(r3 / l3), n4 = Math.ceil(s5 / o2);
    for (let r4 = 0; r4 < n4; r4++) {
      h2.y = r4 * o2;
      for (let n5 = 0; n5 < t3; n5++) {
        h2.x = n5 * l3;
        const t4 = w(c3, h2, e2);
        a2.set(`${i2}/${r4}/${n5}`, t4);
      }
    }
    i2 < f2 - 1 && (c3 = k(c3)), r3 = Math.round(r3 / 2), s5 = Math.round(s5 / 2);
  }
  return a2;
}
function A(t2, e2, n3, i2, l3 = 0.5) {
  const { width: o2, height: r3 } = t2, { width: s5, height: a2 } = e2, h2 = i2.cols, f2 = i2.rows, c3 = Math.ceil(s5 / h2 - 0.1 / h2), u3 = Math.ceil(a2 / f2 - 0.1 / f2);
  let p3, x2, m3, d3, y2, g2, w2;
  const k2 = c3 * h2, M2 = k2 * u3 * f2, A2 = new Float32Array(M2), U2 = new Float32Array(M2), C2 = new Uint32Array(M2), T = new Uint32Array(M2);
  let S, B, v = 0;
  for (let P = 0; P < u3; P++)
    for (let t3 = 0; t3 < c3; t3++) {
      p3 = 12 * (P * c3 + t3), x2 = n3[p3], m3 = n3[p3 + 1], d3 = n3[p3 + 2], y2 = n3[p3 + 3], g2 = n3[p3 + 4], w2 = n3[p3 + 5];
      for (let e3 = 0; e3 < f2; e3++) {
        v = (P * f2 + e3) * k2 + t3 * h2, B = (e3 + 0.5) / f2;
        for (let t4 = 0; t4 < e3; t4++)
          S = (t4 + 0.5) / h2, A2[v + t4] = (x2 * S + m3 * B + d3) * o2 - l3, U2[v + t4] = (y2 * S + g2 * B + w2) * r3 - l3, C2[v + t4] = Math.round(A2[v + t4]), T[v + t4] = Math.round(U2[v + t4]);
      }
      p3 += 6, x2 = n3[p3], m3 = n3[p3 + 1], d3 = n3[p3 + 2], y2 = n3[p3 + 3], g2 = n3[p3 + 4], w2 = n3[p3 + 5];
      for (let e3 = 0; e3 < f2; e3++) {
        v = (P * f2 + e3) * k2 + t3 * h2, B = (e3 + 0.5) / f2;
        for (let t4 = e3; t4 < h2; t4++)
          S = (t4 + 0.5) / h2, A2[v + t4] = (x2 * S + m3 * B + d3) * o2 - l3, U2[v + t4] = (y2 * S + g2 * B + w2) * r3 - l3, C2[v + t4] = Math.round(A2[v + t4]), T[v + t4] = Math.round(U2[v + t4]);
      }
    }
  return { offsets_x: A2, offsets_y: U2, offsets_xi: C2, offsets_yi: T, gridWidth: k2 };
}
function U(t2, e2) {
  const { coefficients: n3, spacing: i2 } = e2, { offsets_x: l3, offsets_y: o2, gridWidth: r3 } = A(t2, t2, n3, { rows: i2[0], cols: i2[1] }, 0.5), { width: s5, height: a2 } = t2, h2 = new Float32Array(s5 * a2), f2 = 180 / Math.PI;
  for (let c3 = 0; c3 < a2; c3++)
    for (let t3 = 0; t3 < s5; t3++) {
      const e3 = c3 * r3 + t3, n4 = 0 === c3 ? e3 : e3 - r3, i3 = c3 === a2 - 1 ? e3 : e3 + r3, u3 = l3[n4] - l3[i3], p3 = o2[i3] - o2[n4];
      if (isNaN(u3) || isNaN(p3))
        h2[c3 * s5 + t3] = 90;
      else {
        let e4 = Math.atan2(p3, u3) * f2;
        e4 = (360 + e4) % 360, h2[c3 * s5 + t3] = e4;
      }
    }
  return h2;
}
function C(t2, e2, l3, o2, r3 = "nearest") {
  if (!i(t2))
    return null;
  "majority" === r3 && (t2 = m2(t2));
  const { pixels: s5, mask: a2, pixelType: h2 } = t2, f2 = t2.width, c3 = t2.height, u3 = u.getPixelArrayConstructor(h2), p3 = s5.length, { width: x2, height: d3 } = e2;
  let y2 = false;
  for (let n3 = 0; n3 < l3.length; n3 += 3)
    -1 === l3[n3] && -1 === l3[n3 + 1] && -1 === l3[n3 + 2] && (y2 = true);
  const { offsets_x: g2, offsets_y: w2, offsets_xi: k2, offsets_yi: M2, gridWidth: U2 } = A({ width: f2, height: c3 }, e2, l3, o2, "majority" === r3 ? 0 : 0.5);
  let C2;
  const T = (t3, e3, n3) => {
    const i2 = t3 instanceof Float32Array || t3 instanceof Float64Array ? 0 : 0.5;
    for (let l4 = 0; l4 < d3; l4++) {
      C2 = l4 * U2;
      for (let o3 = 0; o3 < x2; o3++) {
        if (g2[C2] < 0 || w2[C2] < 0)
          t3[l4 * x2 + o3] = 0;
        else if (n3)
          t3[l4 * x2 + o3] = e3[k2[C2] + M2[C2] * f2];
        else {
          const n4 = Math.floor(g2[C2]), r4 = Math.floor(w2[C2]), s6 = Math.ceil(g2[C2]), h3 = Math.ceil(w2[C2]), c4 = g2[C2] - n4, u4 = w2[C2] - r4;
          if (!a2 || a2[n4 + r4 * f2] && a2[n4 + r4 * f2] && a2[n4 + h3 * f2] && a2[s6 + h3 * f2]) {
            const a3 = (1 - c4) * e3[n4 + r4 * f2] + c4 * e3[s6 + r4 * f2], p4 = (1 - c4) * e3[n4 + h3 * f2] + c4 * e3[s6 + h3 * f2];
            t3[l4 * x2 + o3] = (1 - u4) * a3 + u4 * p4 + i2;
          } else
            t3[l4 * x2 + o3] = e3[k2[C2] + M2[C2] * f2];
        }
        C2++;
      }
    }
  }, S = [];
  let B;
  for (let n3 = 0; n3 < p3; n3++)
    B = new u3(x2 * d3), T(B, s5[n3], "nearest" === r3 || "majority" === r3), S.push(B);
  const v = new u({ width: x2, height: d3, pixelType: h2, pixels: S });
  if (a2)
    v.mask = new Uint8Array(x2 * d3), T(v.mask, a2, true);
  else if (y2) {
    v.mask = new Uint8Array(x2 * d3);
    for (let t3 = 0; t3 < x2 * d3; t3++)
      v.mask[t3] = g2[t3] < 0 || w2[t3] < 0 ? 0 : 1;
  }
  return v.updateStatistics(), v;
}

export {
  u,
  i,
  l2 as l,
  o,
  r2 as r,
  s4 as s,
  a,
  f,
  u2,
  x,
  M,
  U,
  C
};
//# sourceMappingURL=chunk-YRAX326I.js.map
