import {
  s as s3
} from "./chunk-5QPLPQX7.js";
import {
  c as c2
} from "./chunk-TB42IUV7.js";
import {
  o as o2
} from "./chunk-YG6VFATO.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import {
  d as d3
} from "./chunk-JJRJ6TV3.js";
import {
  n as n2
} from "./chunk-OIPX3EDD.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  Bt
} from "./chunk-5N3FSR63.js";
import {
  d as d2
} from "./chunk-4PRVTUEZ.js";
import {
  o
} from "./chunk-BPZGJQOB.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  D,
  L
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  c,
  e as e2,
  m,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/graphics/data/StreamFeatureManager.js
var o3 = "__esri_stream_id__";
var d4 = "__esri_timestamp__";
var a = 1e3;
var h = class {
  constructor(t4, e3, s4, i, r2 = 128) {
    this._trackIdToObservations = /* @__PURE__ */ new Map(), this._idCounter = 0, this._lastPurge = performance.now(), this._addOrUpdated = /* @__PURE__ */ new Map(), this._removed = [], this._maxAge = 0, this._timeInfo = s4, this._purgeOptions = i, this.store = t4, this.objectIdField = e3, this.purgeInterval = r2, this._useGeneratedIds = this.objectIdField === o3;
  }
  add(r2) {
    if (this._useGeneratedIds) {
      const t4 = this._nextId();
      r2.attributes[this.objectIdField] = t4, r2.objectId = t4;
    } else
      r2.objectId = r2.attributes[this.objectIdField];
    if (this._addOrUpdated.set(r2.objectId, r2), this._maxAge = Math.max(this._maxAge, r2.attributes[this._timeInfo.startTimeField]), !this._timeInfo.trackIdField)
      return t(this._trackIdLessObservations) && (this._trackIdLessObservations = new s3(1e5)), void this._trackIdLessObservations.enqueue(r2.objectId);
    const o4 = r2.attributes[this._timeInfo.trackIdField];
    if (!this._trackIdToObservations.has(o4)) {
      const s4 = r(this._purgeOptions) && null != this._purgeOptions.maxObservations ? this._purgeOptions.maxObservations : a, r3 = o(s4, 0, a);
      this._trackIdToObservations.set(o4, new s3(r3));
    }
    const d5 = this._trackIdToObservations.get(o4).enqueue(r2.objectId);
    r(d5) && (this._addOrUpdated.has(d5) ? this._addOrUpdated.delete(d5) : this._removed.push(d5));
  }
  checkForUpdates() {
    const t4 = this._getToAdd(), e3 = this._getToRemove(), s4 = performance.now();
    s4 - this._lastPurge >= this.purgeInterval && (this._purge(s4), this._lastPurge = s4);
    const r2 = [];
    if (r(e3))
      for (const o4 of e3) {
        const t5 = this.store.removeById(o4);
        r(t5) && r2.push(t5);
      }
    if (r(t4))
      for (const i of t4)
        i.attributes[d4] = s4, this.store.add(i);
    (t4 || r2) && this.store.update(t4, r2);
  }
  _getToAdd() {
    if (!this._addOrUpdated.size)
      return null;
    const t4 = new Array(this._addOrUpdated.size);
    let e3 = 0;
    return this._addOrUpdated.forEach((s4) => t4[e3++] = s4), this._addOrUpdated.clear(), t4;
  }
  _getToRemove() {
    const t4 = this._removed;
    return this._removed.length ? (this._removed = [], t4) : null;
  }
  _nextId() {
    const t4 = this._idCounter;
    return this._idCounter = (this._idCounter + 1) % 4294967294 + 1, t4;
  }
  _purge(t4) {
    const e3 = this._purgeOptions;
    r(e3) && (this._purgeSomeByDisplayCount(e3), this._purgeByAge(e3), this._purgeByAgeReceived(t4, e3), this._purgeTracks());
  }
  _purgeSomeByDisplayCount(t4) {
    if (!t4.displayCount)
      return;
    let e3 = this.store.size;
    if (e3 > t4.displayCount) {
      if (this._timeInfo.trackIdField) {
        for (const s4 of this._trackIdToObservations.values())
          if (e3 > t4.displayCount && s4.size) {
            const t5 = e2(s4.dequeue());
            this._removed.push(t5), e3--;
          }
      }
      if (r(this._trackIdLessObservations)) {
        let s4 = e3 - t4.displayCount;
        for (; s4-- > 0; ) {
          const t5 = this._trackIdLessObservations.dequeue();
          r(t5) && this._removed.push(t5);
        }
      }
    }
  }
  _purgeByAge(t4) {
    var _a;
    if (!t4.age || !((_a = this._timeInfo) == null ? void 0 : _a.startTimeField))
      return;
    const e3 = 60 * t4.age * 1e3, s4 = this._maxAge - e3;
    this.store.forEach((t5) => {
      t5.attributes[this._timeInfo.startTimeField] < s4 && this._removed.push(t5.objectId);
    });
  }
  _purgeByAgeReceived(t4, e3) {
    if (!e3.ageReceived)
      return;
    const s4 = t4 - 60 * e3.ageReceived * 1e3;
    this.store.forEach((t5) => {
      t5.attributes[d4] < s4 && this._removed.push(t5.objectId);
    });
  }
  _purgeTracks() {
    this._trackIdToObservations.forEach((t4, e3) => {
      0 === t4.size && this._trackIdToObservations.delete(e3);
    });
  }
};

// node_modules/@arcgis/core/layers/graphics/sources/connections/StreamConnection.js
var t2 = class extends n2.EventedMixin(d3) {
  onFeature(r2) {
    this.emit("feature", r2);
  }
};
t2 = e([n("esri.layers.graphics.sources.connections.StreamConnection")], t2);
var c3 = t2;

// node_modules/@arcgis/core/layers/graphics/sources/connections/WebSocketConnection.js
var p = s.getLogger("esri.layers.graphics.sources.connections.WebSocketConnection");
var u;
!function(e3) {
  e3[e3.CONNECTING = 0] = "CONNECTING", e3[e3.OPEN = 1] = "OPEN", e3[e3.CLOSING = 2] = "CLOSING", e3[e3.CLOSED = 3] = "CLOSED";
}(u || (u = {}));
var m2 = class extends c3 {
  constructor(e3) {
    super(), this.errorString = null;
    const { geometryType: t4, spatialReference: o4, sourceSpatialReference: r2 } = e3;
    this._config = e3, this._featureZScaler = o2(t4, r2, o4), this._open();
  }
  async _open() {
    await this._tryCreateWebSocket(), this.destroyed || await this._handshake();
  }
  destroy() {
    r(this._websocket) && (this._websocket.onopen = null, this._websocket.onclose = null, this._websocket.onerror = null, this._websocket.onmessage = null, this._websocket.close()), this._websocket = null;
  }
  get connectionStatus() {
    if (t(this._websocket))
      return "disconnected";
    switch (this._websocket.readyState) {
      case u.CONNECTING:
      case u.OPEN:
        return "connected";
      case u.CLOSING:
      case u.CLOSED:
        return "disconnected";
    }
  }
  async _tryCreateWebSocket(e3 = this._config.source.path, o4 = 1e3, r2 = 0) {
    try {
      if (this.destroyed)
        return;
      const t4 = Bt(e3, this._config.customParameters);
      this._websocket = await this._createWebSocket(t4), this.notifyChange("connectionStatus");
    } catch (s4) {
      const c4 = o4 / 1e3;
      return this._config.maxReconnectionAttempts && r2 >= this._config.maxReconnectionAttempts ? (p.error(new s2("websocket-connection", "Exceeded maxReconnectionAttempts attempts. No further attempts will be made")), void this.destroy()) : (p.error(new s2("websocket-connection", `Failed to connect. Attempting to reconnect in ${c4}s`, s4)), await L(o4), this._tryCreateWebSocket(e3, Math.min(1.5 * o4, 1e3 * this._config.maxReconnectionInterval), r2 + 1));
    }
  }
  _createWebSocket(e3) {
    return new Promise((t4, o4) => {
      const r2 = new WebSocket(e3);
      r2.onopen = () => {
        if (r2.onopen = null, this.destroyed)
          return r2.onclose = null, void r2.close();
        r2.onclose = (e4) => this._onClose(e4), r2.onerror = (e4) => this._onError(e4), r2.onmessage = (e4) => this._onMessage(e4), t4(r2);
      }, r2.onclose = (e4) => {
        r2.onopen = r2.onclose = null, o4(e4);
      };
    });
  }
  async _handshake(e3 = 1e4) {
    const o4 = this._websocket;
    if (t(o4))
      return;
    const r2 = D(), n3 = o4.onmessage, { filter: i, outFields: a2, spatialReference: l } = this._config;
    return r2.timeout(e3), o4.onmessage = (e4) => {
      var _a;
      let s4 = null;
      try {
        s4 = JSON.parse(e4.data);
      } catch (c4) {
      }
      s4 && "object" == typeof s4 || (p.error(new s2("websocket-connection", "Protocol violation. Handshake failed - malformed message", e4.data)), r2.reject(), this.destroy()), ((_a = s4.spatialReference) == null ? void 0 : _a.wkid) !== (l == null ? void 0 : l.wkid) && (p.error(new s2("websocket-connection", `Protocol violation. Handshake failed - expected wkid of ${l.wkid}`, e4.data)), r2.reject(), this.destroy()), "json" !== s4.format && (p.error(new s2("websocket-connection", "Protocol violation. Handshake failed - format is not set", e4.data)), r2.reject(), this.destroy()), i && s4.filter !== i && p.error(new s2("websocket-connection", "Tried to set filter, but server doesn't support it")), a2 && s4.outFields !== a2 && p.error(new s2("websocket-connection", "Tried to set outFields, but server doesn't support it")), o4.onmessage = n3, r2.resolve();
    }, o4.send(JSON.stringify({ filter: i, outFields: a2, format: "json", spatialReference: { wkid: l.wkid } })), r2.promise;
  }
  _onMessage(e3) {
    try {
      const o4 = JSON.parse(e3.data);
      if ("featureResult" !== o4.type)
        throw new s2("websocket-connection", "Protocol violation - Expected to find message of type 'featureResult'", o4);
      for (const e4 of o4.features)
        r(this._featureZScaler) && this._featureZScaler(e4.geometry), this.onFeature(e4);
    } catch (o4) {
      return p.error(new s2("websocket-connection", "Failed to parse message", o4)), void this.destroy();
    }
  }
  _onError(e3) {
    const t4 = "Encountered an error over WebSocket connection";
    this._set("errorString", t4), p.error("websocket-connection", t4);
  }
  _onClose(e3) {
    this._websocket = null, this.notifyChange("connectionStatus"), 1e3 !== e3.code && p.error("websocket-connection", `WebSocket closed unexpectedly with error code ${e3.code}`), this.destroyed || this._open();
  }
};
e([d()], m2.prototype, "connectionStatus", null), e([d()], m2.prototype, "errorString", void 0), m2 = e([n("esri.layers.graphics.sources.connections.WebSocketConnection")], m2);

// node_modules/@arcgis/core/layers/graphics/sources/connections/GeoEventConnection.js
var p2 = s.getLogger("esri.layers.graphics.sources.connections.GeoEventConnection");
var g = 1e4;
var _ = { maxQueryDepth: 5, maxRecordCountFactor: 3 };
var w = class extends m2 {
  constructor(e3) {
    super({ ..._, ...e3 });
  }
  async _open() {
    const e3 = await this._fetchServiceDefinition(this._config.source);
    e3.timeInfo.trackIdField || p2.warn("GeoEvent service was configured without a TrackIdField. This may result in certain functionality being disabled. The purgeOptions.maxObservations property will have no effect.");
    const t4 = this._fetchWebSocketUrl(e3.streamUrls, this._config.spatialReference);
    this._buddyServicesQuery || (this._buddyServicesQuery = this._queryBuddyServices()), await this._buddyServicesQuery, await this._tryCreateWebSocket(t4);
    const { filter: r2, outFields: o4 } = this._config;
    this.destroyed || this._setFilter(r2, o4);
  }
  _onMessage(e3) {
    let t4;
    try {
      t4 = this._enrich(JSON.parse(e3.data)), r(this._featureZScaler) && this._featureZScaler(t4.geometry);
    } catch (o4) {
      return void p2.error(new s2("geoevent-connection", "Failed to parse message", o4));
    }
    this.onFeature(t4);
  }
  async _fetchServiceDefinition(e3) {
    const r2 = { f: "json", ...this._config.customParameters }, o4 = U(e3.path, { query: r2, responseType: "json" }), s4 = (await o4).data;
    return this._serviceDefinition = s4, s4;
  }
  _fetchWebSocketUrl(e3, t4) {
    const r2 = e3[0], { urls: o4, token: s4 } = r2, i = this._inferWebSocketBaseUrl(o4);
    return Bt(`${i}/subscribe`, { outSR: "" + t4.wkid, token: s4 });
  }
  _inferWebSocketBaseUrl(e3) {
    if (1 === e3.length)
      return e3[0];
    for (const t4 of e3)
      if (t4.includes("wss"))
        return t4;
    return p2.error(new s2("geoevent-connection", "Unable to infer WebSocket url", e3)), null;
  }
  async _setFilter(e3, t4) {
    const o4 = this._websocket;
    if (t(o4) || t(e3) && t(t4))
      return;
    const s4 = JSON.stringify({ filter: this._serializeFilter(e3, t4) });
    let n3 = false;
    const a2 = D(), u2 = () => {
      n3 || (this.destroyed || this._websocket !== o4 || p2.error(new s2("geoevent-connection", "Server timed out when setting filter")), a2.reject());
    }, f = (e4) => {
      const t5 = JSON.parse(e4.data);
      t5.filter && (t5.error && (p2.error(new s2("geoevent-connection", "Failed to set service filter", t5.error)), this._set("errorString", `Could not set service filter - ${t5.error}`), a2.reject(t5.error)), o4.onmessage = this._onMessage.bind(this), n3 = true, a2.resolve());
    };
    return o4.onmessage = f, o4.send(s4), setTimeout(u2, g), a2.promise;
  }
  _serializeFilter(e3, t4) {
    const o4 = {};
    if (t(e3) && t(t4))
      return o4;
    if (r(e3) && e3.geometry)
      try {
        const t5 = d2(e3.geometry);
        if ("extent" !== t5.type)
          throw new s2(`Expected extent but found type ${t5.type}`);
        o4.geometry = JSON.stringify(t5.shiftCentralMeridian());
      } catch (n3) {
        p2.error(new s2("geoevent-connection", "Encountered an error when setting connection geometryDefinition", n3));
      }
    return r(e3) && e3.where && "1 = 1" !== e3.where && (o4.where = e3.where), r(t4) && (o4.outFields = t4.join(",")), o4;
  }
  _enrich(e3) {
    if (!this._relatedFeatures)
      return e3;
    const t4 = this._serviceDefinition.relatedFeatures.joinField, o4 = e3.attributes[t4];
    if (!this._relatedFeatures.has(o4))
      return p2.warn("geoevent-connection", "Feature join failed. Is the join field configured correctly?", e3), e3;
    const { attributes: s4, geometry: i } = this._relatedFeatures.get(o4);
    for (const r2 in s4)
      e3.attributes[r2] = s4[r2];
    return i && (e3.geometry = i), e3.geometry || e3.centroid || p2.error(new s2("geoevent-connection", "Found malformed feature - no geometry found", e3)), e3;
  }
  async _queryBuddyServices() {
    try {
      const { relatedFeatures: e3, keepLatestArchive: t4 } = this._serviceDefinition, r2 = this._queryRelatedFeatures(e3), o4 = this._queryArchive(t4);
      await r2;
      const s4 = await o4;
      if (!s4)
        return;
      for (const i of s4.features)
        this.onFeature(this._enrich(i));
    } catch (e3) {
      p2.error(new s2("geoevent-connection", "Encountered an error when querying buddy services", { error: e3 }));
    }
  }
  async _queryRelatedFeatures(e3) {
    if (!e3)
      return;
    const t4 = await this._queryBuddy(e3.featuresUrl);
    this._addRelatedFeatures(t4);
  }
  async _queryArchive(e3) {
    if (e3)
      return this._queryBuddy(e3.featuresUrl);
  }
  async _queryBuddy(e3) {
    const t4 = new (await import("./@arcgis_core_layers_FeatureLayer.js")).default({ url: e3 }), { capabilities: r2 } = await t4.load(), o4 = r2.query.supportsMaxRecordCountFactor, s4 = r2.query.supportsPagination, i = r2.query.supportsCentroid, c4 = this._config.maxRecordCountFactor, u2 = t4.capabilities.query.maxRecordCount, f = o4 ? u2 * c4 : u2, d5 = new b();
    if (d5.outFields = c(this._config.outFields, ["*"]), d5.where = c(m(this._config.filter, "where"), "1=1"), d5.returnGeometry = true, d5.returnExceededLimitFeatures = true, d5.outSpatialReference = k.fromJSON(this._config.spatialReference), i && (d5.returnCentroid = true), o4 && (d5.maxRecordCountFactor = c4), s4)
      return d5.num = f, t4.destroy(), this._queryPages(e3, d5);
    const y = await c2(e3, d5, this._config.sourceSpatialReference);
    return t4.destroy(), y.data;
  }
  async _queryPages(e3, t4, r2 = [], o4 = 0) {
    t4.start = r(t4.num) ? o4 * t4.num : null;
    const { data: i } = await c2(e3, t4, this._config.sourceSpatialReference);
    return i.exceededTransferLimit && o4 < this._config.maxQueryDepth ? (i.features.forEach((e4) => r2.push(e4)), this._queryPages(e3, t4, r2, o4 + 1)) : (r2.forEach((e4) => i.features.push(e4)), i);
  }
  _addRelatedFeatures(e3) {
    const t4 = /* @__PURE__ */ new Map(), r2 = e3.features, o4 = this._serviceDefinition.relatedFeatures.joinField;
    for (const s4 of r2) {
      const e4 = s4.attributes[o4];
      t4.set(e4, s4);
    }
    this._relatedFeatures = t4;
  }
};
w = e([n("esri.layers.graphics.sources.connections.GeoEventConnection")], w);
var F = w;

// node_modules/@arcgis/core/layers/graphics/sources/connections/createConnection.js
function t3(t4, o4, r2, c4, i, s4, a2, m3) {
  const p3 = 0 === t4.path.indexOf("wss://") || 0 === t4.path.indexOf("ws://"), f = { source: t4, sourceSpatialReference: o4, spatialReference: r2, geometryType: c4, filter: i, maxReconnectionAttempts: s4, maxReconnectionInterval: a2, customParameters: m3 };
  return p3 ? new m2(f) : new F(f);
}

export {
  h,
  t3 as t
};
//# sourceMappingURL=chunk-D3I6HXMB.js.map
