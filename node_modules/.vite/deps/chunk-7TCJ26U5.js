import {
  e as e2
} from "./chunk-T6BL6FYR.js";
import {
  i
} from "./chunk-U7I6IKUN.js";
import {
  o as o2
} from "./chunk-7LOTF6IL.js";
import {
  G
} from "./chunk-22MSECLU.js";
import {
  r as r2
} from "./chunk-SOZCO2CU.js";
import {
  L,
  Q
} from "./chunk-JZY7CGEI.js";
import {
  Bn
} from "./chunk-PZWU5EHT.js";
import {
  ee,
  se
} from "./chunk-RN2KRYDN.js";
import {
  o,
  x as x2
} from "./chunk-PKZEO23A.js";
import {
  n as n2
} from "./chunk-AIRC226G.js";
import {
  E
} from "./chunk-3NMRL5CR.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  j,
  x
} from "./chunk-U3PSONS6.js";
import {
  a2 as a,
  h,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/interactive/snapping/SnappingDragPipelineStep.js
var d2 = class {
  constructor() {
    this.next = new G();
  }
  createSnapDragEventPipelineStep({ predicate: d4 = () => true, cancel: c, snappingManager: m2, snappingContext: x4, updatingHandles: u }) {
    if (t(m2))
      return (e3) => e3;
    let y3 = null, f2 = null;
    const g2 = () => {
      y3 = h(y3), m2.doneSnapping(), r(f2) && f2.frameTask.remove(), f2 = null;
    };
    c.next((e3) => (g2(), e3)), this.next = new G();
    const v2 = x(async ({ frameTask: e3, point: t2, context: n3, event: r3, dx: a2, dy: i2 }, s) => {
      const p2 = await e3.schedule(() => m2.snap(t2, n3, s), s);
      if (p2.valid) {
        let l = await e3.schedule(() => p2.apply(), s);
        t2 !== P && (l = m2.update(P, n3)), r2(l, h4) || (r3.mapEnd.x = l.x + a2, r3.mapEnd.y = l.y + i2, this.next.execute(r3));
      }
    });
    let P, h4;
    return (e3) => {
      if (!d4(e3))
        return e3;
      if ("start" === e3.action) {
        const n3 = "3d" === m2.view.type ? m2.view.resourceController.scheduler.registerTask(L.SNAPPING) : Q;
        f2 = { context: new e2({ editGeometryOperations: x4.editGeometryOperations, elevationInfo: x4.elevationInfo, pointer: x4.pointer, vertexHandle: r(e3.info) ? e3.info.handle : null, excludeFeature: x4.excludeFeature, visualizer: x4.visualizer }), originalPos: r(e3.snapOrigin) ? x4.coordinateHelper.vectorToDehydratedPoint(e3.snapOrigin) : e3.mapStart, frameTask: n3 };
      }
      if (r(f2)) {
        const n3 = f2.context.coordinateHelper.vectorToDehydratedPoint(f2.context.coordinateHelper.arrayToVector([f2.originalPos.x, f2.originalPos.y, f2.originalPos.z]));
        n3.x += e3.mapEnd.x - e3.mapStart.x, n3.y += e3.mapEnd.y - e3.mapStart.y;
        const a2 = e3.mapStart.x - f2.originalPos.x, o3 = e3.mapStart.y - f2.originalPos.y, i2 = { ...e3, action: "update" }, s = f2.context, p2 = m2.update(n3, f2.context);
        if (h4 = p2, e3.mapEnd.x = p2.x + a2, e3.mapEnd.y = p2.y + o3, P = n3, "end" !== e3.action) {
          const e4 = f2.frameTask;
          r(y3) || (y3 = new AbortController()), u.addPromise(j(v2({ frameTask: e4, event: i2, context: s, point: n3, dx: a2, dy: o3 }, y3.signal)));
        }
      }
      return "end" === e3.action && g2(), e3;
    };
  }
};

// node_modules/@arcgis/core/views/support/euclideanLengthMeasurementUtils.js
function f(t2) {
  return p(t2, "direct");
}
function h2(t2) {
  return p(t2, "horizontal");
}
function p(t2, i2) {
  const { hasZ: o3, spatialReference: c } = t2, u = i(c);
  let l = 0;
  const s = ee(u);
  if (t(s))
    return null;
  const f2 = "direct" === i2 ? x3 : Z;
  for (const r3 of t2.paths) {
    if (r3.length < 2)
      continue;
    const t3 = r3.length - 1;
    for (let e3 = 0; e3 < t3; ++e3) {
      const t4 = r3[e3];
      S[0] = t4[0], S[1] = t4[1], S[2] = o3 ? t4[2] : 0;
      const i3 = r3[e3 + 1];
      k[0] = i3[0], k[1] = i3[1], k[2] = o3 ? i3[2] : 0;
      const u2 = f2(S, k, c);
      if (t(u2))
        return null;
      l += u2.value;
    }
  }
  return o2(l, s);
}
function m(t2, n3) {
  const { spatialReference: r3 } = t2;
  return E(r3, n3.spatialReference) ? (S[0] = t2.x, S[1] = t2.y, S[2] = t2.hasZ ? t2.z : 0, k[0] = n3.x, k[1] = n3.y, k[2] = n3.hasZ ? n3.z : 0, R(S, k, r3)) : null;
}
function y2(t2, n3) {
  const { spatialReference: r3 } = t2;
  return E(r3, n3.spatialReference) ? (S[0] = t2.x, S[1] = t2.y, S[2] = t2.hasZ ? t2.z : 0, k[0] = n3.x, k[1] = n3.y, k[2] = n3.hasZ ? n3.z : 0, Z(S, k, r3)) : null;
}
function d3(t2, n3) {
  const { spatialReference: r3 } = t2;
  return E(r3, n3.spatialReference) ? (S[0] = t2.x, S[1] = t2.y, S[2] = t2.hasZ ? t2.z : 0, k[0] = n3.x, k[1] = n3.y, k[2] = n3.hasZ ? n3.z : 0, g(S, k, r3)) : null;
}
function v(t2) {
  return S[0] = t2.x, S[1] = t2.y, S[2] = t2.hasZ ? t2.z : 0, U(S, t2.spatialReference);
}
function R(n3, e3, i2) {
  const o3 = b(n3, e3, i2);
  return r(o3) ? { direct: o2(o3.direct, o3.unit), horizontal: o2(o3.horizontal, o3.unit), vertical: o2(o3.vertical, o3.unit) } : null;
}
function x3(n3, e3, i2) {
  const o3 = b(n3, e3, i2, "direct");
  return r(o3) ? o2(o3.direct, o3.unit) : null;
}
function Z(n3, e3, i2) {
  const o3 = b(n3, e3, i2, "horizontal");
  return r(o3) ? o2(o3.horizontal, o3.unit) : null;
}
function g(n3, e3, i2) {
  const o3 = b(n3, e3, i2, "vertical");
  return r(o3) ? o2(o3.verticalSigned, o3.unit) : null;
}
function U(n3, e3) {
  const o3 = se(e3);
  return r(o3) ? o2(n3[2], o3) : null;
}
function b(t2, r3, i2, u) {
  const s = i(i2), f2 = ee(s);
  if (t(f2))
    return null;
  const h4 = r3[2] - t2[2];
  if ("vertical" === u)
    return { verticalSigned: h4, unit: f2 };
  if (!Bn(t2, i2, M, s) || !Bn(r3, i2, q, s))
    return null;
  if ("direct" === u) {
    return { direct: x2(q, M), unit: f2 };
  }
  if (o(w, t2[0], t2[1], r3[2]), !Bn(w, i2, w, s))
    return null;
  const p2 = x2(w, q);
  if ("horizontal" === u)
    return { horizontal: p2, unit: f2 };
  return { direct: x2(q, M), horizontal: p2, vertical: Math.abs(h4), unit: f2 };
}
var S = n2();
var k = n2();
var M = n2();
var q = n2();
var w = n2();

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOperation.js
var h3 = class extends y {
  constructor(t2) {
    super(t2), this.stagedPoint = null, this._abortController = null, this._snap = x(async (t3, r3, s, o3) => {
      const e3 = await this._frameTask.schedule(() => r3.snap(t3, s, o3), o3);
      e3.valid && await this._frameTask.schedule(() => {
        this.stagedPoint = e3.apply(), t3 !== this._snapMapPoint && (this.stagedPoint = r3.update(this._snapMapPoint, s));
      }, o3);
    });
  }
  initialize() {
    var _a, _b;
    const t2 = "3d" === this.view.type ? (_b = (_a = this.view) == null ? void 0 : _a.resourceController) == null ? void 0 : _b.scheduler : null;
    this._frameTask = r(t2) ? t2.registerTask(L.SNAPPING) : Q;
  }
  destroy() {
    this._abortController = h(this._abortController), this._frameTask = a(this._frameTask);
  }
  async snap(t2, r3, s) {
    return this.stagedPoint = r3.update(t2, s), this._snapMapPoint = t2, t(this._abortController) && (this._abortController = new AbortController()), this._snap(t2, r3, s, this._abortController.signal);
  }
  abort() {
    this._abortController = h(this._abortController);
  }
};
e([d({ constructOnly: true })], h3.prototype, "view", void 0), e([d()], h3.prototype, "stagedPoint", void 0), h3 = e([n("esri.views.interactive.snapping.SnappingOperation")], h3);

export {
  h3 as h,
  d2 as d,
  f,
  h2,
  m,
  y2 as y,
  d3 as d2,
  v,
  x3 as x,
  Z,
  g
};
//# sourceMappingURL=chunk-7TCJ26U5.js.map
