import {
  A,
  F,
  I,
  K,
  M,
  O,
  W,
  g,
  h,
  p,
  w,
  x
} from "./chunk-GXI3XMFU.js";
import {
  m as m2
} from "./chunk-X64NQ2GK.js";
import {
  DateTime,
  S,
  c,
  d,
  f,
  i2 as i,
  l,
  m,
  o,
  t3 as t,
  v,
  y
} from "./chunk-LBBA3SFR.js";
import {
  d as d2
} from "./chunk-FU5UMT3R.js";
import {
  k2
} from "./chunk-3NMRL5CR.js";
import {
  k
} from "./chunk-U3PSONS6.js";

// node_modules/@arcgis/core/arcade/featureset/support/cache.js
var a = class {
  constructor() {
    this._databaseTypeMetaData = {}, this._layerInfo = {};
  }
  clearDatabaseType(a4) {
    void 0 === this._databaseTypeMetaData[a4] && delete this._databaseTypeMetaData[a4];
  }
  getDatabaseType(a4) {
    return "MUSTBESET" === a4 || void 0 === this._databaseTypeMetaData[a4] ? null : this._databaseTypeMetaData[a4];
  }
  setDatabaseType(a4, e) {
    this._databaseTypeMetaData[a4] = e;
  }
  getLayerInfo(a4) {
    return void 0 === this._layerInfo[a4] ? null : this._layerInfo[a4];
  }
  setLayerInfo(a4, e) {
    this._layerInfo[a4] = e;
  }
  clearLayerInfo(a4) {
    void 0 !== this._layerInfo[a4] && delete this._layerInfo[a4];
  }
};
a.applicationCache = null;

// node_modules/@arcgis/core/arcade/featureset/support/sqlUtils.js
function n(e, r) {
  return c2(e.parseTree, r, e.parameters);
}
function a2(e, r, t4) {
  return c2(e, r, t4);
}
function s(t4, n2, a4, s3) {
  return m2.create(c2(t4.parseTree, t.Standardised, t4.parameters, n2, a4), s3);
}
function o2(t4, a4, s3 = "AND") {
  return m2.create("((" + n(t4, t.Standardised) + ")" + s3 + "(" + n(a4, t.Standardised) + "))", t4.fieldsIndex);
}
function c2(e, r, t4, n2 = null, a4 = null) {
  let s3, o4, f4, d5;
  switch (e.type) {
    case "interval":
      return T(c2(e.value, r, t4, n2, a4), e.qualifier, e.op);
    case "case-expression": {
      let s4 = " CASE ";
      "simple" === e.format && (s4 += c2(e.operand, r, t4, n2, a4));
      for (let o5 = 0; o5 < e.clauses.length; o5++)
        s4 += " WHEN " + c2(e.clauses[o5].operand, r, t4, n2, a4) + " THEN " + c2(e.clauses[o5].value, r, t4, n2, a4);
      return null !== e.else && (s4 += " ELSE " + c2(e.else, r, t4, n2, a4)), s4 += " END ", s4;
    }
    case "parameter": {
      const n3 = t4[e.value.toLowerCase()];
      if ("string" == typeof n3) {
        return "'" + t4[e.value.toLowerCase()].toString().replace(/'/g, "''") + "'";
      }
      if (n3 instanceof Date)
        return i2(n3, r);
      if (n3 instanceof Array) {
        const e2 = [];
        for (let t5 = 0; t5 < n3.length; t5++)
          "string" == typeof n3[t5] ? e2.push("'" + n3[t5].toString().replace(/'/g, "''") + "'") : n3[t5] instanceof Date ? e2.push(i2(n3[t5], r)) : e2.push(n3[t5].toString());
        return e2;
      }
      return n3.toString();
    }
    case "expression-list":
      o4 = [];
      for (const s4 of e.value)
        o4.push(c2(s4, r, t4, n2, a4));
      return o4;
    case "unary-expression":
      return " ( NOT " + c2(e.expr, r, t4, n2, a4) + " ) ";
    case "binary-expression":
      switch (e.operator) {
        case "AND":
          return " (" + c2(e.left, r, t4, n2, a4) + " AND " + c2(e.right, r, t4, n2, a4) + ") ";
        case "OR":
          return " (" + c2(e.left, r, t4, n2, a4) + " OR " + c2(e.right, r, t4, n2, a4) + ") ";
        case "IS":
          if ("null" !== e.right.type)
            throw new Error("Unsupported RHS for IS");
          return " (" + c2(e.left, r, t4, n2, a4) + " IS NULL )";
        case "ISNOT":
          if ("null" !== e.right.type)
            throw new Error("Unsupported RHS for IS");
          return " (" + c2(e.left, r, t4, n2, a4) + " IS NOT NULL )";
        case "IN":
          return s3 = [], "expression-list" === e.right.type ? (s3 = c2(e.right, r, t4, n2, a4), " (" + c2(e.left, r, t4, n2, a4) + " IN (" + s3.join(",") + ")) ") : (d5 = c2(e.right, r, t4, n2, a4), d5 instanceof Array ? " (" + c2(e.left, r, t4, n2, a4) + " IN (" + d5.join(",") + ")) " : " (" + c2(e.left, r, t4, n2, a4) + " IN (" + d5 + ")) ");
        case "NOT IN":
          return s3 = [], "expression-list" === e.right.type ? (s3 = c2(e.right, r, t4, n2, a4), " (" + c2(e.left, r, t4, n2, a4) + " NOT IN (" + s3.join(",") + ")) ") : (d5 = c2(e.right, r, t4, n2, a4), d5 instanceof Array ? " (" + c2(e.left, r, t4, n2, a4) + " NOT IN (" + d5.join(",") + ")) " : " (" + c2(e.left, r, t4, n2, a4) + " NOT IN (" + d5 + ")) ");
        case "BETWEEN":
          return f4 = c2(e.right, r, t4, n2, a4), " (" + c2(e.left, r, t4, n2, a4) + " BETWEEN " + f4[0] + " AND " + f4[1] + " ) ";
        case "NOTBETWEEN":
          return f4 = c2(e.right, r, t4, n2, a4), " (" + c2(e.left, r, t4, n2, a4) + " NOT BETWEEN " + f4[0] + " AND " + f4[1] + " ) ";
        case "LIKE":
          return "" !== e.escape ? " (" + c2(e.left, r, t4, n2, a4) + " LIKE " + c2(e.right, r, t4, n2, a4) + " ESCAPE '" + e.escape + "') " : " (" + c2(e.left, r, t4, n2, a4) + " LIKE " + c2(e.right, r, t4, n2, a4) + ") ";
        case "NOT LIKE":
          return "" !== e.escape ? " (" + c2(e.left, r, t4, n2, a4) + " NOT LIKE " + c2(e.right, r, t4, n2, a4) + " ESCAPE '" + e.escape + "') " : " (" + c2(e.left, r, t4, n2, a4) + " NOT LIKE " + c2(e.right, r, t4, n2, a4) + ") ";
        case "<>":
        case "<":
        case ">":
        case ">=":
        case "<=":
        case "=":
        case "*":
        case "-":
        case "+":
        case "/":
          return " (" + c2(e.left, r, t4, n2, a4) + " " + e.operator + " " + c2(e.right, r, t4, n2, a4) + ") ";
      }
      throw new Error("Not Supported Operator " + e.operator);
    case "null":
      return "null";
    case "boolean":
      return true === e.value ? "1" : "0";
    case "string":
      return "'" + e.value.toString().replace(/'/g, "''") + "'";
    case "timestamp":
    case "date":
      return i2(e.value, r);
    case "number":
      return e.value.toString();
    case "current-time":
      return u("date" === e.mode, r);
    case "column-reference":
      return n2 && n2.toLowerCase() === e.column.toLowerCase() ? "(" + a4 + ")" : e.column;
    case "function": {
      const s4 = c2(e.args, r, t4, n2, a4);
      return l2(e.name, s4, r);
    }
  }
  throw new Error("Unsupported sql syntax " + e.type);
}
function l2(r, t4, n2) {
  switch (r.toLowerCase().trim()) {
    case "abs":
      if (1 !== t4.length)
        throw new Error("Invalid Parameter for call to ABS");
      return "abs(" + t4[0] + ")";
    case "ceiling":
    case "ceil":
      if (1 !== t4.length)
        throw new Error("Invalid Parameter for call to CEILING");
      switch (n2) {
        case t.Standardised:
        case t.StandardisedNoInterval:
      }
      return "CEILING(" + t4[0] + ")";
    case "floor":
      if (1 !== t4.length)
        throw new Error("Invalid Parameter for call to Floor");
      return "FLOOR(" + t4[0] + ")";
    case "log":
      if (1 !== t4.length)
        throw new Error("Invalid Parameter for call to LOG");
      return "LOG(" + t4[0] + ")";
    case "log10":
      if (1 !== t4.length)
        throw new Error("Invalid Parameter for call to LOG10");
      return "LOG10(" + t4[0] + ")";
    case "power":
      if (2 !== t4.length)
        throw new Error("Invalid Parameter for call to POWER");
      return "POWER(" + t4[0] + "," + t4[1] + ")";
    case "round":
      if (2 === t4.length)
        return "ROUND(" + t4[0] + "," + t4[1] + ")";
      if (1 === t4.length)
        return "ROUND(" + t4[0] + ")";
      throw new Error("Invalid Parameter for call to ROUND");
    case "truncate":
      if (t4.length < 1 || t4.length > 2)
        throw new Error("Invalid Parameter for TRUNCATE function");
      return n2 === t.SqlServer ? "ROUND(" + t4[0] + (1 === t4.length ? "0" : "," + t4[1]) + ",1)" : "TRUNCATE(" + t4[0] + (1 === t4.length ? ")" : "," + t4[1] + ")");
    case "char_length":
    case "len":
      if (1 !== t4.length)
        throw new Error("Invalid Parameter for CHAR_LENGTH function");
      switch (n2) {
        case t.SqlServer:
          return "LEN(" + t4[0] + ")";
        case t.Oracle:
          return "LENGTH(" + t4[0] + ")";
        default:
          return "CHAR_LENGTH(" + t4[0] + ")";
      }
    case "concat":
      if (t4.length < 1)
        throw new Error("Invalid Parameter for CONCAT function");
      {
        let e = "CONCAT(";
        for (let r2 = 0; r2 < t4.length; r2++)
          0 !== r2 && (e += ","), e += t4[r2];
        return e += ")", e;
      }
    case "lower":
    case "lcase":
      if (1 !== t4.length)
        throw new Error("Invalid Parameter for Lower function");
      return "LOWER(" + t4[0] + ")";
    case "upper":
    case "ucase":
      if (1 !== t4.length)
        throw new Error("Invalid Parameter for Upper function");
      return "UPPER(" + t4[0] + ")";
    case "substring": {
      let r2 = "";
      switch (n2) {
        case t.Oracle:
          return r2 = "SUBSTR(" + t4[0] + "," + t4[1], 3 === t4.length && (r2 += "," + t4[2]), r2 += ")", r2;
        case t.SqlServer:
          return r2 = 3 === t4.length ? "SUBSTRING(" + t4[0] + "," + t4[1] + "," + t4[2] + ")" : "SUBSTRING(" + t4[0] + ",  " + t4[1] + ", LEN(" + t4[0] + ") - " + t4[1] + ")", r2;
        default:
          return r2 = "SUBSTRING(" + t4[0] + " FROM " + t4[1], 3 === t4.length && (r2 += " FOR " + t4[2]), r2 += ")", r2;
      }
    }
    case "extract":
      return "EXTRACT(" + t4[0].replace(/\'/g, "") + " FROM " + t4[1] + ")";
  }
  throw new Error("Function Not Recognised");
}
function i2(r, n2) {
  const a4 = r instanceof Date ? DateTime.fromJSDate(r) : DateTime.fromSQL(r), s3 = 0 === a4.hour && 0 === a4.minute && 0 === a4.second && 0 === a4.millisecond;
  switch (n2) {
    case t.FILEGDB:
    case t.Standardised:
    case t.StandardisedNoInterval:
      return s3 ? `date '${a4.toFormat("yyyy-LL-dd")}'` : `date '${a4.toFormat("yyyy-LL-dd HH:mm:ss")}'`;
    case t.Oracle:
      return s3 ? `TO_DATE('${a4.toFormat("yyyy-LL-dd")}','YYYY-MM-DD')` : `TO_DATE('${a4.toFormat("yyyy-LL-dd HH:mm:ss")}','YYYY-MM-DD HH24:MI:SS')`;
    case t.SqlServer:
      return `'${a4.toFormat(s3 ? "yyyy-LL-dd" : "yyyy-LL-dd HH:mm:ss")}'`;
    case t.PGDB:
      return `#${a4.toFormat(s3 ? "LL-dd-yyyy" : "LL-dd-yyyy HH:mm:ss")}#`;
    case t.Postgres:
      return `TIMESTAMP '${a4.toFormat(s3 ? "yyyy-LL-dd" : "yyyy-LL-dd HH:mm:ss")}'`;
    default:
      return `date '${a4.toFormat("yyyy-LL-dd HH:mm:ss")}'`;
  }
}
function u(r, t4) {
  switch (t4) {
    case t.FILEGDB:
    case t.Standardised:
    case t.StandardisedNoInterval:
    case t.Oracle:
      return r ? "CURRENT_DATE" : "CURRENT_TIMESTAMP";
    case t.SqlServer:
      return r ? "CAST(GETDATE() AS DATE)" : "GETDATE()";
    case t.PGDB:
    case t.Postgres:
    default:
      return r ? "CURRENT_DATE" : "CURRENT_TIMESTAMP";
  }
}
function f2(e, r, t4 = {}) {
  const n2 = {}, a4 = {}, s3 = { esriFieldTypeSmallInteger: "integer", esriFieldTypeInteger: "integer", esriFieldTypeSingle: "double", esriFieldTypeDouble: "double", esriFieldTypeString: "string", esriFieldTypeDate: "date", esriFieldTypeOID: "integer", oid: "integer", long: "integer", "small-integer": "integer", integer: "integer", single: "double", double: "double", date: "date", string: "string" };
  for (const o4 of r) {
    const e2 = s3[o4.type];
    n2[o4.name.toLowerCase()] = void 0 === e2 ? "" : e2;
  }
  for (const o4 in t4) {
    const e2 = s3[t4[o4]];
    a4[o4.toLowerCase()] = void 0 === e2 ? "" : e2;
  }
  switch (d3(n2, e.parseTree, e.parameters, a4)) {
    case "double":
      return "double";
    case "integer":
      return "integer";
    case "date":
      return "date";
    case "string":
      return "string";
  }
  return "";
}
function d3(e, r, t4, n2) {
  let a4;
  switch (r.type) {
    case "interval":
      return "integer";
    case "case-expression": {
      const a5 = [];
      if ("simple" === r.format) {
        for (let s3 = 0; s3 < r.clauses.length; s3++)
          a5.push(d3(e, r.clauses[s3].value, t4, n2));
        null !== r.else && a5.push(d3(e, r.else, t4, n2));
      } else {
        for (let s3 = 0; s3 < r.clauses.length; s3++)
          a5.push(d3(e, r.else, t4, n2));
        null !== r.else && a5.push(d3(e, r.else, t4, n2));
      }
      return g2(a5);
    }
    case "parameter": {
      const e2 = n2[r.value.toLowerCase()];
      if (void 0 === e2 && t4) {
        const e3 = t4[r.value.toLowerCase()];
        if (void 0 === e3)
          return "";
        if (null === e3)
          return "";
        if ("string" == typeof e3 || e3 instanceof String)
          return "string";
        if ("boolean" == typeof e3)
          return "boolean";
        if (e3 instanceof Date)
          return "date";
        if ("number" == typeof e3)
          return e3 % 1 == 0 ? "integer" : "double";
      }
      return void 0 === e2 ? "" : e2;
    }
    case "expression-list": {
      const a5 = [];
      for (const s3 of r.value)
        a5.push(d3(e, s3, t4, n2));
      return a5;
    }
    case "unary-expression":
      return "boolean";
    case "binary-expression":
      switch (r.operator) {
        case "AND":
        case "OR":
        case "IN":
        case "NOT IN":
        case "BETWEEN":
        case "NOTBETWEEN":
        case "LIKE":
        case "NOT LIKE":
        case "<>":
        case "<":
        case ">":
        case ">=":
        case "<=":
        case "=":
          return "boolean";
        case "IS":
        case "ISNOT":
          if ("null" !== r.right.type)
            throw new Error("Unsupported RHS for IS");
          return "boolean";
        case "*":
        case "-":
        case "+":
        case "/":
          return g2([d3(e, r.left, t4, n2), d3(e, r.right, t4, n2)]);
        default:
          throw new Error("Not Supported Operator " + r.operator);
      }
    case "null":
      return "";
    case "boolean":
      return "boolean";
    case "string":
      return "string";
    case "number":
      return null === r.value ? "" : r.value % 1 == 0 ? "integer" : "double";
    case "date":
    case "timestamp":
    case "current-time":
      return "date";
    case "column-reference": {
      const t5 = e[r.column.toLowerCase()];
      return void 0 === t5 ? "" : t5;
    }
    case "function":
      switch (r.name.toLowerCase()) {
        case "position":
        case "extract":
        case "char_length":
          return "integer";
        case "round":
          return a4 = d3(e, r.args, t4, n2), a4 instanceof Array ? a4.length > 0 ? a4[0] : "" : a4;
        case "sign":
          return a4 = d3(e, r.args, t4, n2), a4 instanceof Array && (a4 = g2(a4)), "integer" === a4 || "double" === a4 ? a4 : "double";
        case "ceiling":
        case "floor":
        case "abs": {
          const a5 = d3(e, r.args, t4, n2);
          return a5 instanceof Array ? g2(a5) : a5;
        }
        case "area":
        case "length":
        case "log":
        case "log10":
        case "sin":
        case "cos":
        case "tan":
        case "asin":
        case "acos":
        case "atan":
        case "power":
        case "truncate":
          return "double";
        case "substring":
        case "trim":
        case "concat":
        case "lower":
        case "upper":
          return "string";
      }
      return "";
  }
  throw new Error("Unsupported sql syntax " + r.type);
}
var p2 = { boolean: 1, string: 2, integer: 3, double: 4, date: 5 };
function g2(e) {
  if (e) {
    let r = "";
    for (const t4 of e)
      "" !== t4 && (r = "" === r || p2[r] < p2[t4] ? t4 : r);
    return r;
  }
  return "";
}
function h2(e, r) {
  return y2(e.parseTree, r);
}
function E(e) {
  return "column-reference" === e.parseTree.type;
}
function y2(e, r) {
  if (null == e)
    return false;
  switch (e.type) {
    case "when-clause":
      return y2(e.operand, r) || y2(e.value, r);
    case "case-expression":
      for (const t4 of e.clauses)
        if (y2(t4, r))
          return true;
      return !("simple" !== e.format || !y2(e.operand, r)) || !(null === e.else || !y2(e.else, r));
    case "parameter":
    case "null":
    case "boolean":
    case "date":
    case "timestamp":
    case "string":
    case "number":
      return false;
    case "expression-list":
      for (const t4 of e.value)
        if (y2(t4, r))
          return true;
      return false;
    case "unary-expression":
      return y2(e.expr, r);
    case "binary-expression":
      return y2(e.left, r) || y2(e.right, r);
    case "column-reference":
      return r.toLowerCase() === e.column.toLowerCase();
    case "function":
      return y2(e.args, r);
  }
  return false;
}
function m3(e) {
  let r = "";
  return r += e.period.toUpperCase(), r;
}
function T(e, r, t4) {
  let n2 = "";
  return n2 = "interval-period" === r.type ? m3(r) : m3(r.start) + " TO " + m3(r.end), "INTERVAL " + t4 + " " + e + " " + n2;
}

// node_modules/@arcgis/core/arcade/featureset/support/FeatureSetIterator.js
var t2 = class {
  constructor(t4, e) {
    this._lastId = -1, this._progress = e, this._parent = t4;
  }
  reset() {
    this._lastId = -1;
  }
  nextBatch(t4) {
    if (null !== this._parent._mainSetInUse)
      return this._parent._mainSetInUse.then((e2) => this.nextBatch(t4), (e2) => this.nextBatch(t4));
    const e = { returnpromise: null, hasset: false }, n2 = [];
    return e.returnpromise = new Promise((s3, a4) => {
      this._parent._getSet(this._progress).then((i4) => {
        let r = i4._known.length - 1;
        if ("GETPAGES" === i4._known[i4._known.length - 1] && (r -= 1), this._lastId + t4 > r && i4._known.length > 0 && "GETPAGES" === i4._known[i4._known.length - 1])
          this._parent._expandPagedSet(i4, this._parent._maxQueryRate(), 0, 0, this._progress).then((n3) => {
            e.hasset = true, this._parent._mainSetInUse = null, this.nextBatch(t4).then(s3, a4);
          }, (t5) => {
            e.hasset = true, this._parent._mainSetInUse = null, a4(t5);
          });
        else {
          if (r >= this._lastId + t4 || 0 === i4._candidates.length) {
            for (let e2 = 0; e2 < t4; e2++) {
              const t5 = e2 + this._lastId + 1;
              if (t5 >= i4._known.length)
                break;
              n2[e2] = i4._known[t5];
            }
            return this._lastId += n2.length, 0 === n2.length && (e.hasset = true, this._parent._mainSetInUse = null, s3([])), void this._parent._getFeatureBatch(n2, this._progress).then((t5) => {
              e.hasset = true, this._parent._mainSetInUse = null, s3(t5);
            }, (t5) => {
              e.hasset = true, this._parent._mainSetInUse = null, a4(t5);
            });
          }
          this._parent._refineSetBlock(i4, this._parent._maxProcessingRate(), this._progress).then(() => {
            e.hasset = true, this._parent._mainSetInUse = null, this.nextBatch(t4).then(s3, a4);
          }, (t5) => {
            e.hasset = true, this._parent._mainSetInUse = null, a4(t5);
          });
        }
      }, (t5) => {
        e.hasset = true, this._parent._mainSetInUse = null, a4(t5);
      });
    }), false === e.hasset && (this._parent._mainSetInUse = e.returnpromise, e.hasset = true), e.returnpromise;
  }
  next() {
    if (null !== this._parent._mainSetInUse)
      return this._parent._mainSetInUse.then((t5) => this.next(), (t5) => this.next());
    const t4 = { returnpromise: null, hasset: false };
    return t4.returnpromise = new Promise((e, n2) => {
      this._parent._getSet(this._progress).then((s3) => {
        this._lastId < s3._known.length - 1 ? "GETPAGES" === s3._known[this._lastId + 1] ? this._parent._expandPagedSet(s3, this._parent._maxQueryRate(), 0, 0, this._progress).then((e2) => (t4.hasset = true, this._parent._mainSetInUse = null, this.next())).then(e, n2) : (this._lastId += 1, this._parent._getFeature(s3, s3._known[this._lastId], this._progress).then((n3) => {
          t4.hasset = true, this._parent._mainSetInUse = null, e(n3);
        }, (e2) => {
          t4.hasset = true, this._parent._mainSetInUse = null, n2(e2);
        })) : s3._candidates.length > 0 ? this._parent._refineSetBlock(s3, this._parent._maxProcessingRate(), this._progress).then(() => {
          t4.hasset = true, this._parent._mainSetInUse = null, this.next().then(e, n2);
        }, (e2) => {
          t4.hasset = true, this._parent._mainSetInUse = null, n2(e2);
        }) : (t4.hasset = true, this._parent._mainSetInUse = null, e(null));
      }, (e2) => {
        t4.hasset = true, this._parent._mainSetInUse = null, n2(e2);
      });
    }), false === t4.hasset && (this._parent._mainSetInUse = t4.returnpromise, t4.hasset = true), t4.returnpromise;
  }
  async count() {
    if (-1 !== this._parent._totalCount)
      return this._parent._totalCount;
    const t4 = await this._parent._getSet(this._progress), e = await this._refineAllSets(t4);
    return this._parent._totalCount = e._known.length, this._parent._totalCount;
  }
  async _refineAllSets(t4) {
    if (t4._known.length > 0 && "GETPAGES" === t4._known[t4._known.length - 1])
      return await this._parent._expandPagedSet(t4, this._parent._maxQueryRate(), 0, 1, this._progress), this._refineAllSets(t4);
    if (t4._candidates.length > 0) {
      if ("GETPAGES" === t4._known[t4._candidates.length - 1])
        return await this._parent._expandPagedSet(t4, this._parent._maxQueryRate(), 0, 2, this._progress), this._refineAllSets(t4);
      const e = await this._parent._refineSetBlock(t4, this._parent._maxProcessingRate(), this._progress);
      return e._candidates.length > 0 ? this._refineAllSets(e) : e;
    }
    return t4;
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/IdSet.js
var t3 = class {
  constructor(t4, s3, i4, e) {
    this._candidates = null, this._known = null, this._lastFetchedIndex = 0, this._ordered = false, this.pagesDefinition = null, this._candidates = t4, this._known = s3, this._ordered = i4, this.pagesDefinition = e;
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/stats.js
function c3(t4) {
  return t4 = +t4, isFinite(t4) ? t4 - t4 % 1 || (t4 < 0 ? -0 : 0 === t4 ? t4 : 0) : t4;
}
function u2(t4) {
  let n2 = 0;
  for (let e = 0; e < t4.length; e++)
    n2 += t4[e];
  return n2 / t4.length;
}
function l3(t4) {
  const n2 = u2(t4);
  let e = 0;
  for (let r = 0; r < t4.length; r++)
    e += (n2 - t4[r]) ** 2;
  return e / t4.length;
}
function s2(t4) {
  const n2 = u2(t4);
  let e = 0;
  for (let r = 0; r < t4.length; r++)
    e += (n2 - t4[r]) ** 2;
  return e / (t4.length - 1);
}
function i3(t4) {
  let n2 = 0;
  for (let e = 0; e < t4.length; e++)
    n2 += t4[e];
  return n2;
}
function o3(r, a4) {
  const c5 = [], u3 = {}, l4 = [];
  for (let s3 = 0; s3 < r.length; s3++) {
    if (void 0 !== r[s3] && null !== r[s3]) {
      const a5 = r[s3];
      if (y(a5) || l(a5))
        void 0 === u3[a5] && (c5.push(a5), u3[a5] = 1);
      else {
        let t4 = false;
        for (let n2 = 0; n2 < l4.length; n2++)
          true === c(l4[n2], a5) && (t4 = true);
        false === t4 && (l4.push(a5), c5.push(a5));
      }
    }
    if (c5.length >= a4 && -1 !== a4)
      return c5;
  }
  return c5;
}
function h3(t4) {
  switch (t4.toLowerCase()) {
    case "distinct":
      return "distinct";
    case "avg":
    case "mean":
      return "avg";
    case "min":
      return "min";
    case "sum":
      return "sum";
    case "max":
      return "max";
    case "stdev":
    case "stddev":
      return "stddev";
    case "var":
    case "variance":
      return "var";
    case "count":
      return "count";
  }
  return "";
}
function f3(t4, n2, e = 1e3) {
  switch (t4.toLowerCase()) {
    case "distinct":
      return o3(n2, e);
    case "avg":
    case "mean":
      return u2(n2);
    case "min":
      return Math.min.apply(Math, n2);
    case "sum":
      return i3(n2);
    case "max":
      return Math.max.apply(Math, n2);
    case "stdev":
    case "stddev":
      return Math.sqrt(l3(n2));
    case "var":
    case "variance":
      return l3(n2);
    case "count":
      return n2.length;
  }
  return 0;
}
async function g3(t4, n2, e) {
  const r = await x2(t4, n2, e, true);
  return 0 === r.length ? null : Math.min.apply(Math, r);
}
async function m4(t4, n2, e) {
  const r = await x2(t4, n2, e, true);
  return 0 === r.length ? null : Math.max.apply(Math, r);
}
async function w2(t4, n2, e) {
  let l4 = "";
  false === E(n2) && (l4 = f2(n2, t4.fields, null));
  const s3 = await x2(t4, n2, e, true);
  if (0 === s3.length)
    return null;
  const i4 = u2(s3);
  return null === i4 ? i4 : "integer" === l4 ? c3(i4) : i4;
}
async function d4(t4, n2, e) {
  const r = await x2(t4, n2, e, true);
  return 0 === r.length ? null : s2(r);
}
async function v2(t4, n2, e) {
  const r = await x2(t4, n2, e, true);
  return 0 === r.length ? null : Math.sqrt(s2(r));
}
async function p3(t4, n2, e) {
  const r = await x2(t4, n2, e, true);
  return 0 === r.length ? null : i3(r);
}
async function y3(t4, n2) {
  return t4.iterator(n2).count();
}
async function x2(t4, n2, e, r = false) {
  const a4 = t4.iterator(e), c5 = [], u3 = { ticker: 0 };
  let l4 = await a4.next();
  for (; null !== l4; ) {
    if (u3.ticker++, e.aborted)
      throw new Error("Cancelled");
    u3.ticker % 100 == 0 && (u3.ticker = 0, await new Promise((t6) => {
      setTimeout(t6, 0);
    }));
    const t5 = n2.calculateValue(l4);
    null === t5 ? false === r && (c5[c5.length] = t5) : c5[c5.length] = t5, l4 = await a4.next();
  }
  return c5;
}
async function M2(t4, n2, e = 1e3, r = null) {
  const a4 = t4.iterator(r), c5 = [], u3 = {}, l4 = { ticker: 0 };
  let s3 = await a4.next();
  for (; null !== s3; ) {
    if (l4.ticker++, r.aborted)
      throw new Error("Cancelled");
    l4.ticker % 100 == 0 && (l4.ticker = 0, await new Promise((t6) => {
      setTimeout(t6, 0);
    }));
    const t5 = n2.calculateValue(s3);
    if (null != t5 && void 0 === u3[t5] && (c5.push(t5), u3[t5] = 1), c5.length >= e && -1 !== e)
      return c5;
    s3 = await a4.next();
  }
  return c5;
}

// node_modules/@arcgis/core/arcade/featureset/support/FeatureSet.js
var k3 = class {
  constructor(e) {
    this.recentlyUsedQueries = null, this.featureSetQueryInterceptor = null, this._idstates = [], this._parent = null, this._wset = null, this._mainSetInUse = null, this._maxProcessing = 200, this._maxQuery = 500, this._totalCount = -1, this._databaseType = t.NotEvaluated, this._databaseTypeProbed = null, this.declaredRootClass = "esri.arcade.featureset.support.FeatureSet", this._featureCache = [], this.types = null, this.fields = null, this.geometryType = "", this.objectIdField = "", this.globalIdField = "", this.spatialReference = null, this.hasM = false, this.hasZ = false, this._transparent = false, this.loaded = false, this._loadPromise = null, this._fieldsIndex = null, e && e.lrucache && (this.recentlyUsedQueries = e.lrucache), e && e.interceptor && (this.featureSetQueryInterceptor = e.interceptor);
  }
  optimisePagingFeatureQueries(e) {
    this._parent && this._parent.optimisePagingFeatureQueries(e);
  }
  _hasMemorySource() {
    return true;
  }
  prop(e, t4) {
    return void 0 === t4 ? this[e] : (void 0 !== this[e] && (this[e] = t4), this);
  }
  end() {
    return null !== this._parent && true === this._parent._transparent ? this._parent.end() : this._parent;
  }
  _ensureLoaded() {
    return this.load();
  }
  load() {
    return null === this._loadPromise && (this._loadPromise = this.loadImpl()), this._loadPromise;
  }
  async loadImpl() {
    return true === this._parent.loaded ? (this._initialiseFeatureSet(), this) : (await this._parent.load(), this._initialiseFeatureSet(), this);
  }
  _initialiseFeatureSet() {
    null !== this._parent ? (this.fields = this._parent.fields.slice(0), this.geometryType = this._parent.geometryType, this.objectIdField = this._parent.objectIdField, this.globalIdField = this._parent.globalIdField, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = this._parent.typeIdField, this.types = this._parent.types) : (this.fields = [], this.typeIdField = "", this.objectIdField = "", this.globalIdField = "", this.spatialReference = new k2({ wkid: 4326 }), this.geometryType = S.point);
  }
  getField(e, t4) {
    let s3;
    return (t4 = t4 || this.fields) && (e = e.toLowerCase(), t4.some((t5) => (t5 && t5.name.toLowerCase() === e && (s3 = t5), !!s3))), s3;
  }
  getFieldsIndex() {
    return null === this._fieldsIndex && (this._fieldsIndex = new d2(this.fields)), this._fieldsIndex;
  }
  _maxProcessingRate() {
    return null !== this._parent ? Math.min(this._maxProcessing, this._parent._maxProcessingRate()) : Math.min(this._maxProcessing, this._maxQueryRate());
  }
  _maxQueryRate() {
    return null !== this._parent ? Math.max(this._maxQuery, this._parent._maxQueryRate()) : this._maxQuery;
  }
  _checkCancelled(e) {
    if (null !== e && e.aborted)
      throw new Error("Operation has been cancelled.");
  }
  nativeCapabilities() {
    return this._parent.nativeCapabilities();
  }
  async _canDoAggregates(e, t4, s3, r, a4) {
    return null !== this._parent && this._parent._canDoAggregates(e, t4, s3, r, a4);
  }
  async _getAggregatePagesDataSourceDefinition(e, t4, s3, r, a4, n2, i4) {
    if (null === this._parent)
      throw new Error("Should never be called");
    return this._parent._getAggregatePagesDataSourceDefinition(e, t4, s3, r, a4, n2, i4);
  }
  async _getAgregagtePhysicalPage(e, t4, s3) {
    if (null === this._parent)
      throw new Error("Should never be called");
    return this._parent._getAgregagtePhysicalPage(e, t4, s3);
  }
  async databaseType() {
    if (this._databaseType === t.NotEvaluated) {
      if (null !== a.applicationCache) {
        const t4 = a.applicationCache.getDatabaseType(this._cacheableFeatureSetSourceKey());
        if (null !== t4)
          return t4;
      }
      if (null !== this._databaseTypeProbed)
        return this._databaseTypeProbed;
      try {
        this._databaseTypeProbed = this._getDatabaseTypeImpl(), null !== a.applicationCache && a.applicationCache.setDatabaseType(this._cacheableFeatureSetSourceKey(), this._databaseTypeProbed);
      } catch (t4) {
        throw null !== a.applicationCache && a.applicationCache.clearDatabaseType(this._cacheableFeatureSetSourceKey()), t4;
      }
      return this._databaseTypeProbed;
    }
    return this._databaseType;
  }
  async _getDatabaseTypeImpl() {
    const e = [{ thetype: t.SqlServer, testwhere: "(CAST( '2015-01-01' as DATETIME) = CAST( '2015-01-01' as DATETIME)) AND OBJECTID<0" }, { thetype: t.Oracle, testwhere: "(TO_DATE('2003-11-18','YYYY-MM-DD') = TO_DATE('2003-11-18','YYYY-MM-DD')) AND OBJECTID<0" }, { thetype: t.StandardisedNoInterval, testwhere: "(date '2015-01-01 10:10:10' = date '2015-01-01 10:10:10') AND OBJECTID<0" }];
    for (const t4 of e) {
      if (true === await this._runDatabaseProbe(t4.testwhere))
        return t4.thetype;
    }
    return t.StandardisedNoInterval;
  }
  _cacheableFeatureSetSourceKey() {
    return "MUSTBESET";
  }
  async _runDatabaseProbe(e) {
    if (null !== this._parent)
      return this._parent._runDatabaseProbe(e);
    throw new Error("Not Implemented");
  }
  isTable() {
    return this._parent.isTable();
  }
  _featureFromCache(e) {
    if (void 0 !== this._featureCache[e])
      return this._featureCache[e];
  }
  _isInFeatureSet(e) {
    return i.Unknown;
  }
  _getSet(e) {
    throw new Error("Not implemented in abstract class");
  }
  async _getFeature(e, t4, s3) {
    if (this._checkCancelled(s3), void 0 !== this._featureFromCache(t4))
      return this._featureFromCache(t4);
    if (await this._getFeatures(e, t4, this._maxProcessingRate(), s3), this._checkCancelled(s3), void 0 !== this._featureFromCache(t4))
      return this._featureFromCache(t4);
    throw new Error("Feature Not Found");
  }
  async _getFeatureBatch(e, t4) {
    this._checkCancelled(t4);
    const r = new t3([], e, false, null), a4 = [];
    await this._getFeatures(r, -1, e.length, t4), this._checkCancelled(t4);
    for (const s3 of e)
      void 0 !== this._featureFromCache(s3) && a4.push(this._featureFromCache(s3));
    return a4;
  }
  async _getFeatures(e, t4, s3, r) {
    return "success";
  }
  _getFilteredSet(e, t4, s3, r, a4) {
    throw new Error("Not implemented in abstract class");
  }
  async _refineSetBlock(e, t4, s3) {
    if (true === this._checkIfNeedToExpandCandidatePage(e, this._maxQueryRate()))
      return await this._expandPagedSet(e, this._maxQueryRate(), 0, 0, s3), this._refineSetBlock(e, t4, s3);
    this._checkCancelled(s3);
    const r = e._candidates.length;
    this._refineKnowns(e, t4);
    let a4 = r - e._candidates.length;
    if (0 === e._candidates.length)
      return e;
    if (a4 >= t4)
      return e;
    if (await this._refineIfParentKnown(e, t4 - a4, s3), this._checkCancelled(s3), this._refineKnowns(e, t4 - a4), a4 = r - e._candidates.length, a4 < t4 && e._candidates.length > 0) {
      const r2 = t4 - a4, n2 = this._prepareFetchAndRefineSet(e._candidates);
      return await this._fetchAndRefineFeatures(n2, n2.length > r2 ? r2 : e._candidates.length, s3), this._checkCancelled(s3), this._refineKnowns(e, t4 - a4), e;
    }
    return e;
  }
  _fetchAndRefineFeatures(e, t4, s3) {
    return null;
  }
  _prepareFetchAndRefineSet(e) {
    const t4 = [];
    for (let s3 = 0; s3 < e.length; s3++)
      this._isPhysicalFeature(e[s3]) && t4.push(e[s3]);
    return t4;
  }
  _isPhysicalFeature(e) {
    return null === this._parent || this._parent._isPhysicalFeature(e);
  }
  _refineKnowns(e, t4) {
    let s3 = 0, r = null;
    const a4 = [];
    t4 = this._maxQueryRate();
    for (let i4 = 0; i4 < e._candidates.length && "GETPAGES" !== e._candidates[i4]; i4++) {
      let l4 = false;
      const u3 = this._candidateIdTransform(e._candidates[i4]);
      u3 !== e._candidates[i4] && (l4 = true);
      const h4 = this._isInFeatureSet(u3);
      if (h4 === i.InFeatureSet)
        true === l4 ? e._known.includes(u3) || (e._known.push(u3), s3 += 1) : (e._known.push(e._candidates[i4]), s3 += 1), null === r ? r = { start: i4, end: i4 } : r.end === i4 - 1 ? r.end = i4 : (a4.push(r), r = { start: i4, end: i4 });
      else if (h4 === i.NotInFeatureSet)
        null === r ? r = { start: i4, end: i4 } : r.end === i4 - 1 ? r.end = i4 : (a4.push(r), r = { start: i4, end: i4 }), s3 += 1;
      else if (h4 === i.Unknown && (s3 += 1, true === e._ordered))
        break;
      if (s3 >= t4)
        break;
    }
    null !== r && a4.push(r);
    for (let n2 = a4.length - 1; n2 >= 0; n2--)
      e._candidates.splice(a4[n2].start, a4[n2].end - a4[n2].start + 1);
  }
  _refineIfParentKnown(e, t4, r) {
    const a4 = new t3([], [], e._ordered, null);
    return a4._candidates = e._candidates.slice(0), this._parent._refineSetBlock(a4, t4, r);
  }
  _candidateIdTransform(e) {
    return this._parent._candidateIdTransform(e);
  }
  _checkIfNeedToExpandKnownPage(e, t4) {
    if (null === e.pagesDefinition)
      return false;
    let s3 = 0;
    for (let r = e._lastFetchedIndex; r < e._known.length; r++) {
      if ("GETPAGES" === e._known[r])
        return true;
      if (void 0 === this._featureCache[e._known[r]] && (s3 += 1, s3 >= t4))
        break;
    }
    return false;
  }
  _checkIfNeedToExpandCandidatePage(e, t4) {
    if (null === e.pagesDefinition)
      return false;
    let s3 = 0;
    for (let r = 0; r < e._candidates.length; r++) {
      if ("GETPAGES" === e._candidates[r])
        return true;
      if (s3 += 1, s3 >= t4)
        break;
    }
    return false;
  }
  async _expandPagedSet(e, t4, s3, r, a4) {
    if (null === this._parent)
      throw new Error("Parent Paging not implemented");
    return this._parent._expandPagedSet(e, t4, s3, r, a4);
  }
  async _expandPagedSetFeatureSet(e, t4, s3, r, a4) {
    if (e._known.length > 0 && "GETPAGES" === e._known[e._known.length - 1] && (r = 1), 0 === r && e._candidates.length > 0 && "GETPAGES" === e._candidates[e._candidates.length - 1] && (r = 2), 0 === r)
      return "finished";
    const n2 = await this._getPage(e, r, a4);
    return s3 + n2 < t4 ? this._expandPagedSet(e, t4, s3 + n2, 0, a4) : "success";
  }
  async _getPage(e, t4, s3) {
    const r = 1 === t4 ? e._known : e._candidates;
    if (e.pagesDefinition.internal.set.length > e.pagesDefinition.resultOffset || true === e.pagesDefinition.internal.fullyResolved) {
      r.length = r.length - 1;
      let t5 = 0;
      for (let a4 = 0; a4 < e.pagesDefinition.resultRecordCount && !(e.pagesDefinition.resultOffset + a4 >= e.pagesDefinition.internal.set.length); a4++)
        r[r.length] = e.pagesDefinition.internal.set[e.pagesDefinition.resultOffset + a4], t5++;
      e.pagesDefinition.resultOffset += t5;
      let s4 = false;
      return true === e.pagesDefinition.internal.fullyResolved && e.pagesDefinition.internal.set.length <= e.pagesDefinition.resultOffset && (s4 = true), false === s4 && r.push("GETPAGES"), t5;
    }
    return await this._getPhysicalPage(e, t4, s3), this._getPage(e, t4, s3);
  }
  _getPhysicalPage(e, t4, s3) {
    return null;
  }
  _clonePageDefinition(e) {
    return null === this._parent ? null : this._parent._clonePageDefinition(e);
  }
  _first(e) {
    return this.iterator(e).next();
  }
  first(e) {
    return this._first(e);
  }
  async calculateStatistic(e, t4, s3, r) {
    await this._ensureLoaded();
    let a4 = await this._stat(e, t4, "", null, null, s3, r);
    return false === a4.calculated && (a4 = await this._manualStat(e, t4, s3, r)), a4.result;
  }
  async _manualStat(e, t4, s3, r) {
    let a4 = null;
    switch (e.toLowerCase()) {
      case "count":
        return a4 = await y3(this, r), { calculated: true, result: a4 };
      case "distinct":
        return a4 = await M2(this, t4, s3), { calculated: true, result: a4 };
      case "avg":
      case "mean":
        return a4 = await w2(this, t4, r), { calculated: true, result: a4 };
      case "stdev":
        return a4 = await v2(this, t4, r), { calculated: true, result: a4 };
      case "variance":
        return a4 = await d4(this, t4, r), { calculated: true, result: a4 };
      case "sum":
        return a4 = await p3(this, t4, r), { calculated: true, result: a4 };
      case "min":
        return a4 = await g3(this, t4, r), { calculated: true, result: a4 };
      case "max":
        return a4 = await m4(this, t4, r), { calculated: true, result: a4 };
      default:
        return { calculated: true, result: 0 };
    }
  }
  async _stat(e, t4, s3, r, a4, n2, i4) {
    const l4 = await this._parent._stat(e, t4, s3, r, a4, n2, i4);
    return false === l4.calculated ? null === a4 && "" === s3 && null === r ? this._manualStat(e, t4, n2, i4) : { calculated: false } : l4;
  }
  _unionAllGeomSelf(e) {
    const t4 = this.iterator(this._defaultTracker(e)), s3 = [];
    return new Promise((e2, r) => {
      this._unionShapeInBatches(s3, t4, e2, r);
    });
  }
  _unionAllGeom(e) {
    return new Promise((t4, s3) => {
      const r = this.iterator(this._defaultTracker(e)), a4 = [];
      this._unionShapeInBatches(a4, r, t4, s3);
    });
  }
  _unionShapeInBatches(e, t4, s3, r) {
    t4.next().then((a4) => {
      try {
        null !== a4 && null !== a4.geometry && e.push(a4.geometry), e.length > 30 || null === a4 && e.length > 1 ? I(e).then((n2) => {
          try {
            null === a4 ? s3(n2) : (e = [n2], this._unionShapeInBatches(e, t4, s3, r));
          } catch (i4) {
            r(i4);
          }
        }, r) : null === a4 ? 1 === e.length ? s3(e[0]) : s3(null) : this._unionShapeInBatches(e, t4, s3, r);
      } catch (n2) {
        r(n2);
      }
    }, r);
  }
  iterator(e) {
    return new t2(this, e);
  }
  intersection(e, t4 = false) {
    return k3._featuresetFunctions.intersection.bind(this)(e, t4);
  }
  difference(e, t4 = false, s3 = true) {
    return k3._featuresetFunctions.difference.bind(this)(e, t4, s3);
  }
  symmetricDifference(e, t4 = false, s3 = true) {
    return k3._featuresetFunctions.symmetricDifference.bind(this)(e, t4, s3);
  }
  morphShape(e, t4, s3 = "unknown", r = null) {
    return k3._featuresetFunctions.morphShape.bind(this)(e, t4, s3, r);
  }
  morphShapeAndAttributes(e, t4, s3 = "unknown") {
    return k3._featuresetFunctions.morphShapeAndAttributes.bind(this)(e, t4, s3);
  }
  union(e, t4 = false) {
    return k3._featuresetFunctions.union.bind(this)(e, t4);
  }
  intersects(e) {
    return k3._featuresetFunctions.intersects.bind(this)(e);
  }
  envelopeIntersects(e) {
    return k3._featuresetFunctions.envelopeIntersects.bind(this)(e);
  }
  contains(e) {
    return k3._featuresetFunctions.contains.bind(this)(e);
  }
  overlaps(e) {
    return k3._featuresetFunctions.overlaps.bind(this)(e);
  }
  relate(e, t4) {
    return k3._featuresetFunctions.relate.bind(this)(e, t4);
  }
  within(e) {
    return k3._featuresetFunctions.within.bind(this)(e);
  }
  touches(e) {
    return k3._featuresetFunctions.touches.bind(this)(e);
  }
  top(e) {
    return k3._featuresetFunctions.top.bind(this)(e);
  }
  crosses(e) {
    return k3._featuresetFunctions.crosses.bind(this)(e);
  }
  buffer(e, t4, s3, r = true) {
    return k3._featuresetFunctions.buffer.bind(this)(e, t4, s3, r);
  }
  filter(e, t4 = null) {
    return k3._featuresetFunctions.filter.bind(this)(e, t4);
  }
  orderBy(e) {
    return k3._featuresetFunctions.orderBy.bind(this)(e);
  }
  dissolve(e, t4) {
    return k3._featuresetFunctions.dissolve.bind(this)(e, t4);
  }
  groupby(e, t4) {
    return k3._featuresetFunctions.groupby.bind(this)(e, t4);
  }
  reduce(e, t4 = null, s3) {
    return new Promise((r, a4) => {
      this._reduceImpl(this.iterator(this._defaultTracker(s3)), e, t4, 0, r, a4, 0);
    });
  }
  _reduceImpl(e, t4, s3, r, a4, n2, i4) {
    try {
      if (++i4 > 1e3)
        return void setTimeout(() => {
          i4 = 0, this._reduceImpl(e, t4, s3, r, a4, n2, i4);
        });
      e.next().then((l4) => {
        try {
          if (null === l4)
            a4(s3);
          else {
            const u3 = t4(s3, l4, r, this);
            k(u3) ? u3.then((s4) => {
              this._reduceImpl(e, t4, s4, r + 1, a4, n2, i4);
            }, n2) : this._reduceImpl(e, t4, u3, r + 1, a4, n2, i4);
          }
        } catch (u3) {
          n2(u3);
        }
      }, n2);
    } catch (l4) {
      n2(l4);
    }
  }
  removeField(e) {
    return k3._featuresetFunctions.removeField.bind(this)(e);
  }
  addField(e, t4, s3 = null) {
    return k3._featuresetFunctions.addField.bind(this)(e, t4, s3);
  }
  sumArea(e, t4 = false, s3) {
    const r = m(e);
    return this.reduce((e2, s4) => null === s4.geometry ? 0 : t4 ? K(s4.geometry, r).then((t5) => e2 + t5) : W(s4.geometry, r).then((t5) => e2 + t5), 0, s3);
  }
  sumLength(e, t4 = false, s3) {
    const r = f(e);
    return this.reduce((e2, s4) => null === s4.geometry ? 0 : t4 ? M(s4.geometry, r).then((t5) => e2 + t5) : F(s4.geometry, r).then((t5) => e2 + t5), 0, s3);
  }
  _substituteVars(e, t4) {
    if (null !== t4) {
      const s3 = {};
      for (const e2 in t4)
        s3[e2.toLowerCase()] = t4[e2];
      e.parameters = s3;
    }
  }
  async distinct(e, t4 = 1e3, s3 = null, r) {
    await this.load();
    const a4 = m2.create(e, this.getFieldsIndex());
    return this._substituteVars(a4, s3), this.calculateStatistic("distinct", a4, t4, this._defaultTracker(r));
  }
  async min(e, t4 = null, s3) {
    await this.load();
    const r = m2.create(e, this.getFieldsIndex());
    return this._substituteVars(r, t4), this.calculateStatistic("min", r, -1, this._defaultTracker(s3));
  }
  async max(e, t4 = null, s3) {
    await this.load();
    const r = m2.create(e, this.getFieldsIndex());
    return this._substituteVars(r, t4), this.calculateStatistic("max", r, -1, this._defaultTracker(s3));
  }
  async avg(e, t4 = null, s3) {
    await this.load();
    const r = m2.create(e, this.getFieldsIndex());
    return this._substituteVars(r, t4), this.calculateStatistic("avg", r, -1, this._defaultTracker(s3));
  }
  async sum(e, t4 = null, s3) {
    await this.load();
    const r = m2.create(e, this.getFieldsIndex());
    return this._substituteVars(r, t4), this.calculateStatistic("sum", r, -1, this._defaultTracker(s3));
  }
  async stdev(e, t4 = null, s3) {
    await this.load();
    const r = m2.create(e, this.getFieldsIndex());
    return this._substituteVars(r, t4), this.calculateStatistic("stdev", r, -1, this._defaultTracker(s3));
  }
  async variance(e, t4 = null, s3) {
    await this.load();
    const r = m2.create(e, this.getFieldsIndex());
    return this._substituteVars(r, t4), this.calculateStatistic("variance", r, -1, this._defaultTracker(s3));
  }
  async count(e) {
    return await this.load(), this.calculateStatistic("count", m2.create("1", this.getFieldsIndex()), -1, this._defaultTracker(e));
  }
  _defaultTracker(e) {
    return e || { aborted: false };
  }
  forEach(e, t4) {
    return new Promise((s3, r) => {
      this._forEachImpl(this.iterator(this._defaultTracker(t4)), e, this, s3, r, 0);
    });
  }
  _forEachImpl(e, t4, s3, r, a4, n2) {
    try {
      if (++n2 > 1e3)
        return void setTimeout(() => {
          n2 = 0, this._forEachImpl(e, t4, s3, r, a4, n2);
        }, 0);
      e.next().then((i4) => {
        try {
          if (null === i4)
            r(s3);
          else {
            const l4 = t4(i4);
            null == l4 ? this._forEachImpl(e, t4, s3, r, a4, n2) : k(l4) ? l4.then(() => {
              try {
                this._forEachImpl(e, t4, s3, r, a4, n2);
              } catch (i5) {
                a4(i5);
              }
            }, a4) : this._forEachImpl(e, t4, s3, r, a4, n2);
          }
        } catch (l4) {
          a4(l4);
        }
      }, a4);
    } catch (i4) {
      a4(i4);
    }
  }
  convertToJSON(e) {
    const t4 = { layerDefinition: { geometryType: this.geometryType, fields: [] }, featureSet: { features: [], geometryType: this.geometryType } };
    for (let s3 = 0; s3 < this.fields.length; s3++)
      t4.layerDefinition.fields.push(o(this.fields[s3]));
    return this.reduce((e2, s3) => {
      const r = { geometry: s3.geometry && s3.geometry.toJSON(), attributes: {} };
      for (const t5 in s3.attributes)
        r.attributes[t5] = s3.attributes[t5];
      return t4.featureSet.features.push(r), 1;
    }, 0, e).then(() => t4);
  }
  castToText() {
    return "object, FeatureSet";
  }
  queryAttachments(e, t4, s3, r, a4) {
    return this._parent.queryAttachments(e, t4, s3, r, a4);
  }
  serviceUrl() {
    return this._parent.serviceUrl();
  }
  subtypes() {
    return this.typeIdField ? { subtypeField: this.typeIdField, subtypes: this.types ? this.types.map((e) => ({ name: e.name, code: e.id })) : [] } : null;
  }
  relationshipMetaData() {
    return this._parent.relationshipMetaData();
  }
  get gdbVersion() {
    return this._parent ? this._parent.gdbVersion : "";
  }
  schema() {
    const e = [];
    for (const t4 of this.fields)
      e.push(o(t4));
    return { objectIdField: this.objectIdField, globalIdField: this.globalIdField, geometryType: void 0 === v[this.geometryType] ? "" : v[this.geometryType], fields: e };
  }
  async convertToText(e, t4) {
    if ("schema" === e)
      return await this._ensureLoaded(), JSON.stringify(this.schema());
    if ("featureset" === e) {
      await this._ensureLoaded();
      const e2 = [];
      await this.reduce((t5, s4) => {
        const r = { geometry: s4.geometry ? s4.geometry.toJSON() : null, attributes: s4.attributes };
        return null !== r.geometry && r.geometry.spatialReference && delete r.geometry.spatialReference, e2.push(r), 1;
      }, 0, t4);
      const s3 = this.schema();
      return s3.features = e2, s3.spatialReference = this.spatialReference.toJSON(), JSON.stringify(s3);
    }
    return this.castToText();
  }
  getFeatureByObjectId(e, t4) {
    return this._parent.getFeatureByObjectId(e, t4);
  }
  getOwningSystemUrl() {
    return this._parent.getOwningSystemUrl();
  }
  getIdentityUser() {
    return this._parent.getIdentityUser();
  }
  getRootFeatureSet() {
    return null !== this._parent ? this._parent.getRootFeatureSet() : this;
  }
  getDataSourceFeatureSet() {
    return null !== this._parent ? this._parent.getDataSourceFeatureSet() : this;
  }
  castAsJson(e = null) {
    return "keeptype" === (e == null ? void 0 : e.featureset) ? this : "none" === (e == null ? void 0 : e.featureset) ? null : { type: "FeatureSet" };
  }
  async castAsJsonAsync(e = null, t4 = null) {
    if ("keeptype" === (t4 == null ? void 0 : t4.featureset))
      return this;
    if ("schema" === (t4 == null ? void 0 : t4.featureset))
      return await this._ensureLoaded(), JSON.parse(JSON.stringify(this.schema()));
    if ("none" === (t4 == null ? void 0 : t4.featureset))
      return null;
    await this._ensureLoaded();
    const s3 = [];
    await this.reduce((e2, r2) => {
      const a4 = { geometry: r2.geometry ? true === (t4 == null ? void 0 : t4.keepGeometryType) ? r2.geometry : r2.geometry.toJSON() : null, attributes: r2.attributes };
      return null !== a4.geometry && a4.geometry.spatialReference && true !== (t4 == null ? void 0 : t4.keepGeometryType) && delete a4.geometry.spatialReference, s3.push(a4), 1;
    }, 0, e);
    const r = this.schema();
    return r.features = s3, r.spatialReference = true === (t4 == null ? void 0 : t4.keepGeometryType) ? this.spatialReference : this.spatialReference.toJSON(), r;
  }
};
k3._featuresetFunctions = {};

// node_modules/@arcgis/core/arcade/featureset/sources/Empty.js
var a3 = class extends k3 {
  constructor(e) {
    super(e), this.declaredClass = "esri.layers.featureset.sources.Empty", this._maxProcessing = 1e3, this._wset = new t3([], [], false, null), this._parent = e.parentfeatureset, this._databaseType = t.Standardised;
  }
  async _getSet() {
    return this._wset;
  }
  optimisePagingFeatureQueries() {
  }
  _isInFeatureSet() {
    return i.NotInFeatureSet;
  }
  async _getFeature() {
    throw new Error("No Feature Found in EmptySet");
  }
  async queryAttachments() {
    return [];
  }
  async _getFeatures() {
    return "success";
  }
  _featureFromCache() {
    return null;
  }
  async _fetchAndRefineFeatures() {
    throw new Error("Fetch and Refine should not be called in this featureset");
  }
  async _getFilteredSet() {
    return new t3([], [], false, null);
  }
  _stat(e, t4, r, s3, a4, n2, u3) {
    return this._manualStat(e, t4, n2, u3);
  }
  async _canDoAggregates() {
    return false;
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/SpatialFilter.js
var c4 = class extends k3 {
  constructor(e) {
    super(e), this._relation = "", this._relationGeom = null, this._relationString = "", this.declaredClass = "esri.arcade.featureset.actions.SpatialFilter", this._relationString = e.relationString, this._parent = e.parentfeatureset, this._maxProcessing = 40, this._relation = e.relation, this._relationGeom = e.relationGeom;
  }
  async _getSet(e) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._parent._getFilteredSet("esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, null, null, e);
      return this._checkCancelled(e), this._wset = new t3(t4._candidates.slice(0), t4._known.slice(0), t4._ordered, this._clonePageDefinition(t4.pagesDefinition)), this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet(e) {
    let t4 = this._parent._isInFeatureSet(e);
    return t4 === i.NotInFeatureSet ? t4 : (t4 = this._idstates[e], void 0 === t4 ? i.Unknown : t4);
  }
  _getFeature(e, t4, i4) {
    return this._parent._getFeature(e, t4, i4);
  }
  _getFeatures(e, t4, i4, n2) {
    return this._parent._getFeatures(e, t4, i4, n2);
  }
  _featureFromCache(e) {
    return this._parent._featureFromCache(e);
  }
  async executeSpatialRelationTest(e) {
    if (null === e.geometry)
      return false;
    switch (this._relation) {
      case "esriSpatialRelEnvelopeIntersects": {
        const t4 = d(this._relationGeom), i4 = d(e.geometry);
        return g(t4, i4);
      }
      case "esriSpatialRelIntersects":
        return g(this._relationGeom, e.geometry);
      case "esriSpatialRelContains":
        return p(this._relationGeom, e.geometry);
      case "esriSpatialRelOverlaps":
        return O(this._relationGeom, e.geometry);
      case "esriSpatialRelWithin":
        return x(this._relationGeom, e.geometry);
      case "esriSpatialRelTouches":
        return A(this._relationGeom, e.geometry);
      case "esriSpatialRelCrosses":
        return w(this._relationGeom, e.geometry);
      case "esriSpatialRelRelation":
        return h(this._relationGeom, e.geometry, this._relationString);
    }
  }
  async _fetchAndRefineFeatures(e, t4, r) {
    const a4 = new t3([], e, false, null), s3 = Math.min(t4, e.length);
    await this._parent._getFeatures(a4, -1, s3, r), this._checkCancelled(r);
    const l4 = [];
    for (let i4 = 0; i4 < s3; i4++) {
      const t5 = this._parent._featureFromCache(e[i4]);
      l4.push(await this.executeSpatialRelationTest(t5));
    }
    for (let i4 = 0; i4 < t4; i4++)
      true === l4[i4] ? this._idstates[e[i4]] = i.InFeatureSet : this._idstates[e[i4]] = i.NotInFeatureSet;
    return "success";
  }
  async _getFilteredSet(e, t4, n2, r, a4) {
    await this._ensureLoaded();
    const s3 = await this._parent._getFilteredSet("esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, n2, r, a4);
    let l4;
    return this._checkCancelled(a4), l4 = null !== t4 ? new t3(s3._candidates.slice(0).concat(s3._known.slice(0)), [], s3._ordered, this._clonePageDefinition(s3.pagesDefinition)) : new t3(s3._candidates.slice(0), s3._known.slice(0), s3._ordered, this._clonePageDefinition(s3.pagesDefinition)), l4;
  }
  async _stat(e, t4, i4, n2, r, a4, s3) {
    if ("" !== i4)
      return { calculated: false };
    const l4 = await this._parent._stat(e, t4, "esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, r, a4, s3);
    return false === l4.calculated ? null === r && "" === i4 && null === n2 ? this._manualStat(e, t4, a4, s3) : { calculated: false } : l4;
  }
  async _canDoAggregates(e, t4, i4, n2, r) {
    return "" === i4 && null === n2 && (null !== this._parent && this._parent._canDoAggregates(e, t4, "esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, r));
  }
  async _getAggregatePagesDataSourceDefinition(e, t4, i4, n2, r, a4, s3) {
    if (null === this._parent)
      throw new Error("Should never be called");
    return this._parent._getAggregatePagesDataSourceDefinition(e, t4, "esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, r, a4, s3);
  }
  static registerAction() {
    k3._featuresetFunctions.intersects = function(t4) {
      return null == t4 ? new a3({ parentfeatureset: this }) : new c4({ parentfeatureset: this, relation: "esriSpatialRelIntersects", relationGeom: t4 });
    }, k3._featuresetFunctions.envelopeIntersects = function(t4) {
      return null == t4 ? new a3({ parentfeatureset: this }) : new c4({ parentfeatureset: this, relation: "esriSpatialRelEnvelopeIntersects", relationGeom: t4 });
    }, k3._featuresetFunctions.contains = function(t4) {
      return null == t4 ? new a3({ parentfeatureset: this }) : new c4({ parentfeatureset: this, relation: "esriSpatialRelContains", relationGeom: t4 });
    }, k3._featuresetFunctions.overlaps = function(t4) {
      return null == t4 ? new a3({ parentfeatureset: this }) : new c4({ parentfeatureset: this, relation: "esriSpatialRelOverlaps", relationGeom: t4 });
    }, k3._featuresetFunctions.within = function(t4) {
      return null == t4 ? new a3({ parentfeatureset: this }) : new c4({ parentfeatureset: this, relation: "esriSpatialRelWithin", relationGeom: t4 });
    }, k3._featuresetFunctions.touches = function(t4) {
      return null == t4 ? new a3({ parentfeatureset: this }) : new c4({ parentfeatureset: this, relation: "esriSpatialRelTouches", relationGeom: t4 });
    }, k3._featuresetFunctions.crosses = function(t4) {
      return null == t4 ? new a3({ parentfeatureset: this }) : new c4({ parentfeatureset: this, relation: "esriSpatialRelCrosses", relationGeom: t4 });
    }, k3._featuresetFunctions.relate = function(t4, i4) {
      return null == t4 ? new a3({ parentfeatureset: this }) : new c4({ parentfeatureset: this, relation: "esriSpatialRelRelation", relationGeom: t4, relationString: i4 });
    };
  }
};

export {
  a,
  t3 as t,
  n,
  a2,
  s,
  o2 as o,
  l2 as l,
  i2 as i,
  u,
  f2 as f,
  h2 as h,
  E,
  T,
  h3 as h2,
  f3 as f2,
  k3 as k,
  a3,
  c4 as c
};
//# sourceMappingURL=chunk-CEJQPREK.js.map
