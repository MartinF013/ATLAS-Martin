import {
  l
} from "./chunk-6EODZIDR.js";
import {
  o
} from "./chunk-NWRK6QLX.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  a
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/rendererUtils.js
var l2 = 8;
var a2 = l2 - 2;
var n = s.getLogger("esri.views.2d.layers.features.support.rendererUtils");
var i = (e) => {
  if (!("visualVariables" in e) || !e.visualVariables || !e.visualVariables.length)
    return e;
  const r = e.clone(), t = r.visualVariables.map((e2) => p(e2) ? c(e2) : e2);
  return r.visualVariables = t, r;
};
function u(e) {
  return e.map((e2) => p(e2) ? c(e2.clone()) : e2);
}
function p(e) {
  return ("size" === e.type || "color" === e.type || "opacity" === e.type) && null != e.stops;
}
function c(e) {
  return e.stops = g(e.type, e.stops), e;
}
function f(e, r, t) {
  return (1 - t) * e + t * r;
}
function b(e, r) {
  const [t, ...s3] = r, l3 = s3.pop(), n2 = s3[0].value, i2 = s3[s3.length - 1].value, u2 = (i2 - n2) / a2, p2 = [];
  for (let a3 = n2; a3 < i2; a3 += u2) {
    let t2 = 0;
    for (; a3 >= s3[t2].value; )
      t2++;
    const l4 = s3[t2], n3 = r[t2 - 1], i3 = a3 - n3.value, u3 = l4.value === n3.value ? 1 : i3 / (l4.value - n3.value);
    if ("color" === e) {
      const e2 = s3[t2], o2 = r[t2 - 1], l5 = e2.color.clone();
      l5.r = f(o2.color.r, l5.r, u3), l5.g = f(o2.color.g, l5.g, u3), l5.b = f(o2.color.b, l5.b, u3), l5.a = f(o2.color.a, l5.a, u3), p2.push({ value: a3, color: l5, label: e2.label });
    } else if ("size" === e) {
      const e2 = s3[t2], l5 = r[t2 - 1], n4 = o(e2.size), i4 = f(o(l5.size), n4, u3);
      p2.push({ value: a3, size: i4, label: e2.label });
    } else {
      const e2 = s3[t2], o2 = f(r[t2 - 1].opacity, e2.opacity, u3);
      p2.push({ value: a3, opacity: o2, label: e2.label });
    }
  }
  return [t, ...p2, l3];
}
function m(e) {
  const [r, ...t] = e, o2 = t.pop();
  for (; t.length > a2; ) {
    let e2 = 0, r2 = 0;
    for (let o3 = 1; o3 < t.length; o3++) {
      const s3 = t[o3 - 1], l3 = t[o3], a3 = Math.abs(l3.value - s3.value);
      a3 > r2 && (r2 = a3, e2 = o3);
    }
    t.splice(e2, 1);
  }
  return [r, ...t, o2];
}
function g(e, r) {
  return r.length <= l2 ? r : (n.warn(`Found ${r.length} Visual Variable stops, but MapView only supports ${l2}. Displayed stops will be simplified.`), r.length > 2 * l2 ? b(e, r) : m(r));
}
function h() {
  if (a("heatmap-force-raster"))
    return "raster";
  const { supportsTextureFloat: e, supportsTextureHalfFloat: t, supportsColorBufferFloat: o2, supportsColorBufferFloatBlend: l3, supportsColorBufferHalfFloat: a3 } = l("2d");
  return e && o2 && l3 || t && a3 ? "symbol" : a("heatmap-allow-raster-fallback") ? "raster" : "none";
}
function v(t) {
  if (!t)
    return true;
  switch (t.type) {
    case "dot-density":
      if (!l("2d").supportsTextureFloat)
        return n.error(new s2("webgl-missing-extension", "Missing WebGL extension OES_Texture_Float which is required for DotDensity")), false;
      break;
    case "heatmap": {
      const t2 = h();
      if ("none" === t2 || "raster" === t2 && !a("heatmap-force-raster")) {
        const r = l("2d"), o2 = ["supportsTextureFloat", "supportsTextureHalfFloat", "supportsColorBufferFloat", "supportsColorBufferFloatBlend", "supportsColorBufferHalfFloat"].filter((e) => !r[e]).join(", ");
        if ("none" === t2)
          return n.errorOnce(new s2("webgl-missing-extension", `Missing WebGL${r.type} requirements for Heatmap: ${o2}`)), false;
        "raster" === t2 && n.warnOnce(`Missing WebGL${r.type} requirements for accelerated Heatmap: ${o2}. Feature support may be limited.`);
      }
      break;
    }
  }
  return true;
}

export {
  i,
  u,
  h,
  v
};
//# sourceMappingURL=chunk-WL7KJZAL.js.map
