import {
  cs
} from "./chunk-7GTYHKA3.js";
import {
  u as u3,
  y
} from "./chunk-MOXYEJRV.js";
import {
  u as u2
} from "./chunk-Y55TYMBP.js";
import {
  d,
  l as l2,
  p
} from "./chunk-W2HLA6I3.js";
import {
  e,
  o
} from "./chunk-YFBAFAZ2.js";
import {
  l
} from "./chunk-ZN2MGN4S.js";
import {
  n as n2
} from "./chunk-U7B2WKBH.js";
import {
  n as n3
} from "./chunk-ASC3X65B.js";
import {
  w
} from "./chunk-ZOKX6UGH.js";
import {
  A,
  L,
  q,
  r as r2,
  s,
  u,
  z
} from "./chunk-PKZEO23A.js";
import {
  b,
  n
} from "./chunk-AIRC226G.js";
import {
  c,
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/IntersectorInterfaces.js
var i;
var t;
!function(i3) {
  i3[i3.OBJECT = 0] = "OBJECT", i3[i3.HUD = 1] = "HUD", i3[i3.TERRAIN = 2] = "TERRAIN", i3[i3.OVERLAY = 3] = "OVERLAY", i3[i3.I3S = 4] = "I3S", i3[i3.PCL = 5] = "PCL", i3[i3.LOD = 6] = "LOD", i3[i3.VOXEL = 7] = "VOXEL";
}(i || (i = {}));
var s2 = class {
  constructor() {
    this.verticalOffset = 0, this.selectionMode = false, this.hud = true, this.selectOpaqueTerrainOnly = true, this.invisibleTerrain = false, this.backfacesTerrain = true, this.isFiltered = false, this.store = t.ALL;
  }
};
!function(i3) {
  i3[i3.MIN = 0] = "MIN", i3[i3.MINMAX = 1] = "MINMAX", i3[i3.ALL = 2] = "ALL";
}(t || (t = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/intersectorUtils.js
function c2(t2) {
  return r(t2) && r(t2.dist);
}
function s3(r3) {
  return (e2, o2, c3) => (A(f, e2, o2, c3), !cs(r3, f));
}
function i2(r3) {
  return c2(r3) && r3.intersector === i.OBJECT && !!r3.target;
}
function u4(t2) {
  return c2(t2) && t2.intersector === i.HUD && !!t2.target && r(t2.target.center);
}
var f = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Intersector.js
var A2 = 1e-5;
var T = class {
  constructor(t2) {
    this.options = new s2(), this._results = new I(), this.transform = new u3(), this.tolerance = A2, this.verticalOffset = null, this._ray = d(), this._rayEnd = n(), this._rayBeginTransformed = n(), this._rayEndTransformed = n(), this.viewingMode = null == t2 ? l.Global : t2;
  }
  get results() {
    return this._results;
  }
  get ray() {
    return this._ray;
  }
  get rayBegin() {
    return this._ray.origin;
  }
  get rayEnd() {
    return this._rayEnd;
  }
  reset(t2, r3, s4) {
    this.resetWithRay(p(t2, r3, this._ray), s4);
  }
  resetWithRay(t2, r3) {
    this.camera = r3, t2 !== this._ray && l2(t2, this._ray), 0 !== this.options.verticalOffset ? this.viewingMode === l.Local ? this._ray.origin[2] -= this.options.verticalOffset : this.verticalOffset = this.options.verticalOffset : this.verticalOffset = null, u(this._rayEnd, this._ray.origin, this._ray.direction), this._results.init(this._ray);
  }
  intersect(r3 = null, s4, i3, e2, a) {
    this.point = s4, this.filterPredicate = e2, this.tolerance = null == i3 ? A2 : i3;
    const n4 = y(this.verticalOffset);
    if (r(r3) && r3.length > 0) {
      const s5 = a ? (t2) => {
        a(t2) && this.intersectObject(t2);
      } : (t2) => {
        this.intersectObject(t2);
      };
      for (const i4 of r3) {
        const r4 = i4.getSpatialQueryAccelerator && i4.getSpatialQueryAccelerator();
        r(r4) ? (r(n4) ? r4.forEachAlongRayWithVerticalOffset(this._ray.origin, this._ray.direction, s5, n4) : r4.forEachAlongRay(this._ray.origin, this._ray.direction, s5), this.options.selectionMode && this.options.hud && r4.forEachDegenerateObject(s5)) : i4.objects.forAll((t2) => s5(t2));
      }
    }
    this.sortResults();
  }
  intersectObject(r3) {
    const s4 = r3.geometryRecords;
    if (!s4)
      return;
    const i3 = r3.transformation, a = y(this.verticalOffset);
    for (const o2 of s4) {
      const { geometry: s5, material: h, instanceParameters: d2 } = o2;
      if (u2(d2))
        continue;
      const c3 = s5.id;
      this.transform.setAndInvalidateLazyTransforms(i3, o2.getShaderTransformation()), L(this._rayBeginTransformed, this.rayBegin, this.transform.inverse), L(this._rayEndTransformed, this.rayEnd, this.transform.inverse);
      const l3 = this.transform.transform;
      r(a) && (a.objectTransform = this.transform), h.intersect(s5, d2, this.transform.transform, this, this._rayBeginTransformed, this._rayEndTransformed, (s6, i4, a2, n4, o3, h2) => {
        if (s6 >= 0) {
          if (r(this.filterPredicate) && !this.filterPredicate(this._ray.origin, this._rayEnd, s6))
            return;
          const d3 = n4 ? this._results.hud : this._results, m = n4 ? (n5) => {
            const d4 = { object: r3, geometryId: c3, triangleNr: a2, center: r(h2) ? [h2[0], h2[1], h2[2]] : null };
            n5.set(i.HUD, d4, s6, i4, o, o3);
          } : (t2) => t2.set(i.OBJECT, { object: r3, geometryId: c3, triangleNr: a2 }, s6, i4, l3, o3);
          if ((null == d3.min.drapedLayerOrder || o3 >= d3.min.drapedLayerOrder) && (null == d3.min.dist || s6 < d3.min.dist) && m(d3.min), this.options.store !== t.MIN && (null == d3.max.drapedLayerOrder || o3 < d3.max.drapedLayerOrder) && (null == d3.max.dist || s6 > d3.max.dist) && m(d3.max), this.options.store === t.ALL)
            if (n4) {
              const t2 = new M(this._ray);
              m(t2), this._results.hud.all.push(t2);
            } else {
              const t2 = new N(this._ray);
              m(t2), this._results.all.push(t2);
            }
        }
      }, o2.shaderTransformation);
    }
  }
  sortResults(t2 = this._results.all) {
    t2.sort((t3, s4) => t3.dist !== s4.dist ? c(t3.dist, 0) - c(s4.dist, 0) : t3.drapedLayerOrder !== s4.drapedLayerOrder ? c(t3.drapedLayerOrder, Number.MAX_VALUE) - c(s4.drapedLayerOrder, Number.MAX_VALUE) : c(s4.drapedLayerGraphicOrder, Number.MIN_VALUE) - c(t3.drapedLayerGraphicOrder, Number.MIN_VALUE));
  }
};
function x(t2) {
  return new T(t2);
}
var I = class {
  constructor() {
    this.min = new N(d()), this.max = new N(d()), this.hud = { min: new M(d()), max: new M(d()), all: new Array() }, this.ground = new N(d()), this.all = [];
  }
  init(t2) {
    this.min.init(t2), this.max.init(t2), this.ground.init(t2), this.all.length = 0, this.hud.min.init(t2), this.hud.max.init(t2), this.hud.all.length = 0;
  }
};
var N = class {
  constructor(t2) {
    this.intersector = i.OBJECT, this.normal = n(), this.transformation = e(), this._ray = d(), this.init(t2);
  }
  get ray() {
    return this._ray;
  }
  get distanceInRenderSpace() {
    return r(this.dist) ? (q(B, this.ray.direction, this.dist), s(B)) : null;
  }
  getIntersectionPoint(t2) {
    return !!c2(this) && (q(B, this.ray.direction, this.dist), u(t2, this.ray.origin, B), true);
  }
  getTransformedNormal(t2) {
    return r2(R, this.normal), R[3] = 0, w(R, R, this.transformation), r2(t2, R), z(t2, t2);
  }
  init(t2) {
    this.dist = null, this.target = null, this.drapedLayerOrder = null, this.drapedLayerGraphicOrder = null, this.intersector = i.OBJECT, l2(t2, this._ray);
  }
  set(t2, i3, a, n4, o2, h, c3) {
    this.intersector = t2, this.dist = a, r2(this.normal, c(n4, b)), n3(this.transformation, c(o2, o)), this.target = i3, this.drapedLayerOrder = h, this.drapedLayerGraphicOrder = c3;
  }
  copy(t2) {
    l2(t2.ray, this._ray), this.intersector = t2.intersector, this.dist = t2.dist, this.target = t2.target, this.drapedLayerOrder = t2.drapedLayerOrder, this.drapedLayerGraphicOrder = t2.drapedLayerGraphicOrder, r2(this.normal, t2.normal), n3(this.transformation, t2.transformation);
  }
};
var M = class extends N {
  constructor() {
    super(...arguments), this.intersector = i.HUD;
  }
};
function U(t2) {
  return new N(t2);
}
var B = n();
var R = n2();

export {
  i,
  t,
  c2 as c,
  s3 as s,
  i2,
  u4 as u,
  A2 as A,
  x,
  U
};
//# sourceMappingURL=chunk-WQLER7IU.js.map
