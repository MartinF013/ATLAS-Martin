import {
  d as d3,
  l as l3,
  s as s2
} from "./chunk-L6YDAPZR.js";
import {
  b as b3,
  je
} from "./chunk-3ITGQWSQ.js";
import {
  a2 as a,
  s
} from "./chunk-PUR7HIYZ.js";
import {
  r as r2
} from "./chunk-EHWEX2VK.js";
import {
  c,
  k
} from "./chunk-HPO2NV7P.js";
import {
  e as e2
} from "./chunk-AIONJO5O.js";
import {
  o,
  u
} from "./chunk-MDCKEJ7B.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import {
  m
} from "./chunk-EGR3VVZG.js";
import {
  b as b2
} from "./chunk-SIH2IMSA.js";
import {
  d as d2
} from "./chunk-JJRJ6TV3.js";
import {
  U,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import {
  g as g2
} from "./chunk-BLINZ65M.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  d,
  n2 as n,
  n8 as n2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  g
} from "./chunk-U3PSONS6.js";
import {
  l,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/GraphicsProcessor.js
var _ = class extends d2 {
  constructor(t2) {
    super(t2), this.type = "graphics-3d", this.graphicsCore = null, this.elevationAlignment = new l3(), this.drapeSourceType = e2.Features, this._suspendResumeExtent = null;
  }
  normalizeCtorArgs(t2) {
    const e3 = { ...t2, scaleVisibility: null, frustumVisibility: null };
    return delete e3.scaleVisibilityEnabled, delete e3.frustumVisibilityEnabled, t2.scaleVisibilityEnabled && (e3.scaleVisibility = new b3()), t2.frustumVisibilityEnabled && (e3.frustumVisibility = new d3()), e3;
  }
  initialize() {
    const t2 = new je({ owner: this, layer: this.owner.layer, preferredUpdatePolicy: o.SYNC, graphicSymbolSupported: true });
    this._set("graphicsCore", t2);
    const { layer: e3, scaleVisibility: i } = this;
    if (r(i) && "effectiveScaleRange" in e3) {
      const t3 = e3;
      this.updatingHandles.add(() => t3.effectiveScaleRange, () => i.layerMinMaxScaleChangeHandler());
    }
    if ("fullOpacity" in this.owner) {
      const t3 = this.owner;
      this.updatingHandles.add(() => t3.fullOpacity, () => this.graphicsCore.opacityChange());
    }
    if ("elevationInfo" in e3) {
      const t3 = e3;
      this.updatingHandles.add(() => t3.elevationInfo, (t4, e4) => {
        m(t4, e4) && this.updatingHandles.addPromise(this.graphicsCore.elevationInfoChange());
      });
    }
  }
  async setup() {
    const t2 = (t3, e3, i) => this.graphicsCore.spatialIndex.queryGraphicUIDsInExtent(t3, e3, i);
    if (this.elevationAlignment.setup(this, t2, this.graphicsCore, this.view.elevationProvider), r(this.scaleVisibility) && "effectiveScaleRange" in this.layer) {
      const e3 = this.owner.view.basemapTerrain;
      this.scaleVisibility.setup(this, this.layer, t2, this.graphicsCore, e3);
    }
    r(this.frustumVisibility) && this.frustumVisibility.setup(this), this._set("objectStates", new s2(this.graphicsCore));
    try {
      await this.graphicsCore.setup({ elevationAlignment: this.elevationAlignment, scaleVisibility: this.scaleVisibility, objectStates: this.objectStates });
    } catch (e3) {
      if (g(e3))
        return;
      throw e3;
    }
    this.destroyed || (this.handles.add(l2(() => this.view.clippingArea, () => this._updateClippingExtent(), U)), this._updateClippingExtent(), this._setupSuspendResumeExtent(), this.graphicsCore.startCreateGraphics());
  }
  destroy() {
    this.handles.removeAll(), this.updatingHandles.removeAll(), this._set("elevationAlignment", l(this.elevationAlignment)), this._set("scaleVisibility", l(this.scaleVisibility)), this._set("frustumVisibility", l(this.frustumVisibility)), this._set("objectStates", l(this.objectStates)), this._set("graphicsCore", l(this.graphicsCore));
  }
  get layer() {
    return this.owner.layer;
  }
  get view() {
    return this.owner.view;
  }
  get scaleVisibilitySuspended() {
    return !(!r(this.scaleVisibility) || !this.scaleVisibility.suspended);
  }
  get frustumVisibilitySuspended() {
    return !(!r(this.frustumVisibility) || !this.frustumVisibility.suspended);
  }
  get suspended() {
    return this.owner.suspended ?? false;
  }
  get updating() {
    var _a;
    return !!(((_a = this.graphicsCore) == null ? void 0 : _a.updating) || r(this.scaleVisibility) && this.scaleVisibility.updating || r(this.frustumVisibility) && this.frustumVisibility.updating || this.updatingHandles.updating);
  }
  get graphics3DGraphics() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphics;
  }
  get graphics3DGraphicsByObjectID() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphicsByObjectID;
  }
  get loadedGraphics() {
    return this.owner.loadedGraphics;
  }
  get fullOpacity() {
    return this.owner.fullOpacity ?? 1;
  }
  get slicePlaneEnabled() {
    return this.owner.slicePlaneEnabled;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  notifyGraphicGeometryChanged(t2) {
    this.graphicsCore.notifyGraphicGeometryChanged(t2);
  }
  notifyGraphicVisibilityChanged(t2) {
    this.graphicsCore.notifyGraphicVisibilityChanged(t2);
  }
  getRenderingInfo(t2, e3, i) {
    const s3 = a(t2, { renderer: e3, arcade: i });
    if (r(s3) && s3.color) {
      const t3 = s3.color;
      t3[0] = t3[0] / 255, t3[1] = t3[1] / 255, t3[2] = t3[2] / 255;
    }
    return s3;
  }
  getRenderingInfoAsync(t2, e3, i, s3) {
    return s(t2, { renderer: e3, arcade: i, ...s3 });
  }
  getHit(t2) {
    if (this.owner.loadedGraphics) {
      const e3 = this.owner.loadedGraphics.find((e4) => e4.uid === t2);
      if (e3) {
        const t3 = this.layer instanceof b2 ? this.layer : null, i = c(e3, t3);
        return { type: "graphic", graphic: i, layer: i.layer };
      }
    }
    return null;
  }
  whenGraphicBounds(t2, e3) {
    return this.graphicsCore ? this.graphicsCore.whenGraphicBounds(t2, e3) : Promise.reject();
  }
  computeAttachmentOrigin(t2, e3) {
    return this.graphicsCore ? this.graphicsCore.computeAttachmentOrigin(t2, e3) : null;
  }
  getSymbolLayerSize(t2, e3) {
    return this.graphicsCore ? this.graphicsCore.getSymbolLayerSize(t2, e3) : null;
  }
  maskOccludee(t2) {
    const { set: e3, handle: i } = this.objectStates.acquireSet(u.MaskOccludee, null);
    return this.objectStates.setUid(e3, t2.uid), i;
  }
  highlight(t2) {
    if (t2 instanceof b)
      return P;
    if ("number" == typeof t2)
      return this.highlight([t2]);
    if (t2 instanceof g2)
      return this.highlight([t2]);
    if (t2 instanceof j && (t2 = t2.toArray()), Array.isArray(t2) && t2.length > 0) {
      if (t2[0] instanceof g2) {
        const e3 = t2.map((t3) => t3.uid), { set: i, handle: s3 } = this.objectStates.acquireSet(u.Highlight, null);
        return this.objectStates.setUids(i, e3), s3;
      }
      if ("number" == typeof t2[0]) {
        const e3 = t2, { set: i, handle: s3 } = this.objectStates.acquireSet(u.Highlight, null);
        return this.objectStates.setObjectIds(i, e3), s3;
      }
    }
    return P;
  }
  _setupSuspendResumeExtent() {
    const { scaleVisibility: t2, frustumVisibility: e3 } = this;
    if (t(t2) && t(e3))
      return;
    const i = ({ computedExtent: i2, extentPadding: s3 }) => {
      this._suspendResumeExtent = k(i2, this._suspendResumeExtent, r2, s3), r(t2) && t2.setExtent(this._suspendResumeExtent), r(e3) && e3.setExtent(this._suspendResumeExtent);
    };
    this.handles.add(l2(() => {
      var _a, _b;
      return { computedExtent: (_a = this.graphicsCore) == null ? void 0 : _a.computedExtent, extentPadding: (_b = this.graphicsCore) == null ? void 0 : _b.extentPadding };
    }, (t3) => i(t3), w));
  }
  _updateClippingExtent() {
    const t2 = this.view.clippingArea;
    this.graphicsCore.setClippingExtent(t2, this.view.spatialReference) && this.graphicsCore.recreateAllGraphics();
  }
};
e([d()], _.prototype, "type", void 0), e([d({ constructOnly: true })], _.prototype, "owner", void 0), e([d()], _.prototype, "layer", null), e([d()], _.prototype, "view", null), e([d({ constructOnly: true })], _.prototype, "graphicsCore", void 0), e([d({ constructOnly: true })], _.prototype, "scaleVisibility", void 0), e([d({ constructOnly: true })], _.prototype, "frustumVisibility", void 0), e([d({ readOnly: true })], _.prototype, "elevationAlignment", void 0), e([d({ readOnly: true })], _.prototype, "objectStates", void 0), e([d({ readOnly: true })], _.prototype, "scaleVisibilitySuspended", null), e([d({ readOnly: true })], _.prototype, "frustumVisibilitySuspended", null), e([d()], _.prototype, "suspended", null), e([d({ readOnly: true })], _.prototype, "updating", null), e([d()], _.prototype, "loadedGraphics", null), e([d()], _.prototype, "fullOpacity", null), e([d()], _.prototype, "slicePlaneEnabled", null), e([d()], _.prototype, "drapeSourceType", void 0), e([d()], _.prototype, "updatePolicy", null), _ = e([n2("esri.views.3d.layers.graphics.GraphicsProcessor")], _);
var P = n();

export {
  _
};
//# sourceMappingURL=chunk-CLUQM55Y.js.map
