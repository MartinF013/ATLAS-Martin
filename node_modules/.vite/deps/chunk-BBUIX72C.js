import {
  K
} from "./chunk-5ZS6RUSM.js";
import {
  D as D2
} from "./chunk-Z7AZMEL6.js";
import {
  u as u4
} from "./chunk-T3KDRLPE.js";
import {
  u as u2
} from "./chunk-EJ7RFMRW.js";
import {
  D,
  G,
  L as L2,
  M,
  P,
  V,
  Y,
  _
} from "./chunk-FPMD6IB4.js";
import {
  e as e3,
  f,
  s as s4,
  u as u3
} from "./chunk-NAIF4GWX.js";
import {
  e as e2
} from "./chunk-YFBAFAZ2.js";
import {
  e
} from "./chunk-LUU3J646.js";
import {
  A,
  a,
  b,
  j as j2,
  l as l2,
  o as o3,
  r as r4,
  s as s3,
  v,
  x
} from "./chunk-YZNDHJDJ.js";
import {
  l as l3
} from "./chunk-ZN2MGN4S.js";
import {
  n as n3
} from "./chunk-RTHP2LNT.js";
import {
  n as n2
} from "./chunk-U7B2WKBH.js";
import {
  E,
  F as F2,
  c,
  h,
  u
} from "./chunk-ASC3X65B.js";
import {
  l,
  o as o2,
  s as s2
} from "./chunk-BPZGJQOB.js";
import {
  r as r3,
  w
} from "./chunk-ZOKX6UGH.js";
import {
  F,
  L,
  j,
  o,
  r as r2
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";
import {
  r,
  s
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ShadowMap.js
var J;
!function(t) {
  t[t.Highlight = 0] = "Highlight", t[t.Default = 1] = "Default";
}(J || (J = {}));
var K2 = class {
  constructor() {
    this.camera = new K(), this.lightMat = e2();
  }
};
var Q = class {
  constructor(t, e4, s5 = 0) {
    this.rctx = t, this.viewingMode = e4, this._enabled = false, this._snapshots = new Array(), this._textureSize = 0, this.maxTextureSize = 0, this.numCascades = 1, this.maxNumCascades = 4, this.splitSchemeLambda = 0, this.warp = true, this._cascadeDistances = [0, 0, 0, 0, 0], this._usedCascadeDistances = n2(), this._cascades = [new K2(), new K2(), new K2(), new K2()], this.maxTextureSize = this.rctx.parameters.maxTextureSize, this.snapshotCount = s5;
  }
  get depthTexture() {
    return this._depthTexture;
  }
  get textureSize() {
    return this._textureSize;
  }
  get cascadeDistances() {
    return r3(this._usedCascadeDistances, this._cascadeDistances[0], this.numCascades > 1 ? this._cascadeDistances[1] : 1 / 0, this.numCascades > 2 ? this._cascadeDistances[2] : 1 / 0, this.numCascades > 3 ? this._cascadeDistances[3] : 1 / 0);
  }
  dispose() {
    this._discardDepthTexture(), this._discardAllSnapshots();
  }
  set maxCascades(e4) {
    this.maxNumCascades = o2(Math.floor(e4), 1, 4);
  }
  get maxCascades() {
    return this.maxNumCascades;
  }
  set enabled(t) {
    this._enabled = t, t || (this._discardDepthTexture(), this._discardAllSnapshots());
  }
  get enabled() {
    return this._enabled;
  }
  get ready() {
    return this._enabled && r(this._depthTexture);
  }
  get snapshotCount() {
    return this._snapshots.length;
  }
  set snapshotCount(t) {
    const e4 = this._snapshots.length;
    if (t > e4) {
      const s5 = t - e4;
      this._snapshots.length = t;
      for (let t2 = 0; t2 < s5; ++t2)
        this._snapshots[e4 + t2] = null;
    } else if (t < this.snapshotCount) {
      const s5 = e4 - t;
      for (let e5 = 0; e5 < s5; ++e5)
        this._discardSnapshot(t + e5);
      this._snapshots.length = t;
    }
  }
  getSnapshot(t) {
    return this.enabled ? this._snapshots[t] : null;
  }
  getCascades() {
    for (let t = 0; t < this.numCascades; ++t)
      dt[t] = this._cascades[t];
    return dt.length = this.numCascades, dt;
  }
  start(t, e4, s5) {
    e3(this.enabled), this._textureSize = this._computeTextureSize(t.fullWidth, t.fullHeight), this._ensureDepthTexture();
    const { near: a2, far: i } = this._clampNearFar(s5);
    this._computeCascadeDistances(i, a2), this._setupMatrices(t, e4);
    const r5 = t.viewMatrix, h2 = t.projectionMatrix;
    for (let c2 = 0; c2 < this.numCascades; ++c2)
      this._constructCascade(c2, h2, r5, e4);
    this.lastOrigin = null, this.clear();
  }
  finish(t) {
    e3(this.enabled), this.rctx.bindFramebuffer(t);
  }
  getShadowMapMatrices(t) {
    if (!this.lastOrigin || !F(t, this.lastOrigin)) {
      this.lastOrigin = this.lastOrigin || n(), r2(this.lastOrigin, t);
      for (let e4 = 0; e4 < this.numCascades; ++e4) {
        c(pt, this._cascades[e4].lightMat, t);
        for (let t2 = 0; t2 < 16; ++t2)
          lt[16 * e4 + t2] = pt[t2];
      }
    }
    return lt;
  }
  takeCascadeSnapshotTo(t, e4) {
    e3(this.enabled);
    const s5 = this._ensureSnapshot(e4);
    this._bindFbo();
    const a2 = this.rctx, i = a2.bindTexture(s5, u2.TEXTURE_UNIT_FOR_UPDATES);
    a2.gl.copyTexSubImage2D(M.TEXTURE_2D, 0, t.camera.viewport[0], t.camera.viewport[1], t.camera.viewport[0], t.camera.viewport[1], t.camera.viewport[2], t.camera.viewport[3]), a2.bindTexture(i, u2.TEXTURE_UNIT_FOR_UPDATES);
  }
  clear() {
    const t = this.rctx;
    this._bindFbo(), t.setClearColor(1, 1, 1, 1), t.clearSafe(_.COLOR_BUFFER_BIT | _.DEPTH_BUFFER_BIT);
  }
  _computeTextureSize(t, e4) {
    const s5 = 0.5 * Math.log(t * t + e4 * e4) * Math.LOG2E, a2 = 0.35, i = 2 ** Math.round(s5 + a2);
    return Math.min(this.maxTextureSize, 2 * i);
  }
  _ensureDepthTexture() {
    if (r(this._depthTexture) && this._depthTexture.descriptor.width === this._textureSize)
      return;
    this._discardDepthTexture();
    const t = { target: M.TEXTURE_2D, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D.CLAMP_TO_EDGE, samplingMode: L2.NEAREST, flipped: true, width: this._textureSize, height: this._textureSize };
    this._depthTexture = new u2(this.rctx, t), this._fbo = new D2(this.rctx, { colorTarget: Y.TEXTURE, depthStencilTarget: V.DEPTH_RENDER_BUFFER, width: this._textureSize, height: this._textureSize }, this._depthTexture);
  }
  _ensureSnapshot(t) {
    let e4 = this._snapshots[t];
    if (r(e4) && e4.descriptor.width === this._textureSize)
      return e4;
    this._discardSnapshot(t);
    const s5 = { target: M.TEXTURE_2D, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D.CLAMP_TO_EDGE, samplingMode: L2.NEAREST, flipped: true, width: this._textureSize, height: this._textureSize };
    return e4 = new u2(this.rctx, s5), this._snapshots[t] = e4, e4;
  }
  _discardDepthTexture() {
    this._fbo = s(this._fbo), this._depthTexture = s(this._depthTexture);
  }
  _discardSnapshot(t) {
    this._snapshots[t] = s(this._snapshots[t]);
  }
  _discardAllSnapshots() {
    for (let t = 0; t < this.snapshotCount; ++t)
      this._discardSnapshot(t);
  }
  _bindFbo() {
    const t = this.rctx;
    t.unbindTexture(this._depthTexture), t.bindFramebuffer(this._fbo);
  }
  _constructCascade(t, e4, s5, a2) {
    const i = this._cascades[t], r5 = -this._cascadeDistances[t], o4 = -this._cascadeDistances[t + 1], n4 = (e4[10] * r5 + e4[14]) / Math.abs(e4[11] * r5 + e4[15]), u5 = (e4[10] * o4 + e4[14]) / Math.abs(e4[11] * o4 + e4[15]);
    e3(n4 < u5);
    for (let h2 = 0; h2 < 8; ++h2) {
      r3(et, h2 % 4 == 0 || h2 % 4 == 3 ? -1 : 1, h2 % 4 == 0 || h2 % 4 == 1 ? -1 : 1, h2 < 4 ? n4 : u5, 1), w(st[h2], et, tt);
      for (let t2 = 0; t2 < 3; ++t2)
        st[h2][t2] /= st[h2][3];
    }
    j(mt, st[0]), c(Z, ut, mt), i.camera.viewMatrix = Z;
    for (let h2 = 0; h2 < 8; ++h2)
      L(st[h2], st[h2], i.camera.viewMatrix);
    r2(at, st[0]), r2(it, st[0]);
    for (let h2 = 1; h2 < 8; ++h2)
      for (let t2 = 0; t2 < 3; ++t2)
        at[t2] = Math.min(at[t2], st[h2][t2]), it[t2] = Math.max(it[t2], st[h2][t2]);
    at[2] -= 200, it[2] += 200, i.camera.near = -it[2], i.camera.far = -at[2], this.warp ? this._constructTrapezoidalProjection(s5, a2, i) : this._constructOrthogonalProjection(i), u(i.lightMat, i.camera.projectionMatrix, i.camera.viewMatrix);
    const m = this._textureSize / 2;
    i.camera.viewport[0] = t % 2 == 0 ? 0 : m, i.camera.viewport[1] = 0 === Math.floor(t / 2) ? 0 : m, i.camera.viewport[2] = m, i.camera.viewport[3] = m;
  }
  _constructOrthogonalProjection(t) {
    E(t.camera.projectionMatrix, at[0], it[0], at[1], it[1], t.camera.near, t.camera.far);
  }
  _constructTrapezoidalProjection(t, s5, a2) {
    const i = 1 / st[0][3], r5 = 1 / st[4][3];
    e3(i < r5);
    let h2 = i + Math.sqrt(i * r5);
    const c2 = Math.sin(l(t[2] * s5[0] + t[6] * s5[1] + t[10] * s5[2]));
    h2 /= c2, Dt(st, h2, c2, rt, ht, ct, ot, nt), Ut(rt, ht, ot, nt, a2.camera.projectionMatrix), a2.camera.projectionMatrix[10] = 2 / (at[2] - it[2]), a2.camera.projectionMatrix[14] = -(at[2] + it[2]) / (at[2] - it[2]);
  }
  _setupMatrices(t, e4) {
    u($, t.projectionMatrix, t.viewMatrix), h(tt, $);
    const s5 = this.viewingMode === l3.Global ? t.eye : o(mt, 0, 0, 1);
    F2(ut, [0, 0, 0], [-e4[0], -e4[1], -e4[2]], s5);
  }
  _clampNearFar(t) {
    let { near: e4, far: s5 } = t;
    return e4 < 2 && (e4 = 2), s5 < 2 && (s5 = 2), e4 >= s5 && (e4 = 2, s5 = 4), { near: e4, far: s5 };
  }
  _computeCascadeDistances(t, e4) {
    this.numCascades = Math.min(1 + Math.floor(f(t / e4, 4)), this.maxNumCascades);
    const a2 = (t - e4) / this.numCascades, i = (t / e4) ** (1 / this.numCascades);
    let r5 = e4, h2 = e4;
    for (let c2 = 0; c2 < this.numCascades + 1; ++c2)
      this._cascadeDistances[c2] = s2(r5, h2, this.splitSchemeLambda), r5 *= i, h2 += a2;
  }
  get gpuMemoryUsage() {
    var _a;
    return this._snapshots.reduce((t, e4) => t + u4(e4), ((_a = this._fbo) == null ? void 0 : _a.gpuMemoryUsage) ?? 0);
  }
  get test() {
    const t = this;
    return { maxNumCascades: this.maxNumCascades, cascades: this._cascades, textureSize: this._textureSize, set splitSchemeLambda(e4) {
      t.splitSchemeLambda = e4;
    }, get splitSchemeLambda() {
      return t.splitSchemeLambda;
    }, set warp(e4) {
      t.warp = e4;
    }, get warp() {
      return t.warp;
    } };
  }
};
var Z = e2();
var $ = e2();
var tt = e2();
var et = n2();
var st = [];
for (let Ft = 0; Ft < 8; ++Ft)
  st.push(n2());
var at = n();
var it = n();
var rt = n3();
var ht = n3();
var ct = n3();
var ot = n3();
var nt = n3();
var ut = e2();
var mt = n();
var dt = [];
var pt = e2();
var lt = new Float32Array(64);
var _t = n3();
var ft = n3();
var xt = [n3(), n3(), n3(), n3()];
var gt = n3();
var Tt = n3();
var St = n3();
var bt = n3();
var wt = n3();
var Mt = n3();
var Ct = n3();
function Dt(t, e4, s5, a2, i, r5, h2, c2) {
  r4(_t, 0, 0);
  for (let d = 0; d < 4; ++d)
    s3(_t, _t, t[d]);
  l2(_t, _t, 0.25), r4(ft, 0, 0);
  for (let d = 4; d < 8; ++d)
    s3(ft, ft, t[d]);
  l2(ft, ft, 0.25), A(xt[0], t[4], t[5], 0.5), A(xt[1], t[5], t[6], 0.5), A(xt[2], t[6], t[7], 0.5), A(xt[3], t[7], t[4], 0.5);
  let o4 = 0, n4 = b(xt[0], _t);
  for (let d = 1; d < 4; ++d) {
    const t2 = b(xt[d], _t);
    t2 < n4 && (n4 = t2, o4 = d);
  }
  o3(gt, xt[o4], t[o4 + 4]);
  const u5 = gt[0];
  let m, w2;
  gt[0] = -gt[1], gt[1] = u5, o3(Tt, ft, _t), j2(Tt, gt) < 0 && x(gt, gt), A(gt, gt, Tt, s5), v(gt, gt), m = w2 = j2(o3(St, t[0], _t), gt);
  for (let d = 1; d < 8; ++d) {
    const e5 = j2(o3(St, t[d], _t), gt);
    e5 < m ? m = e5 : e5 > w2 && (w2 = e5);
  }
  a(a2, _t), l2(St, gt, m - e4), s3(a2, a2, St);
  let M2 = -1, C = 1, D3 = 0, E2 = 0;
  for (let d = 0; d < 8; ++d) {
    o3(bt, t[d], a2), v(bt, bt);
    const e5 = gt[0] * bt[1] - gt[1] * bt[0];
    e5 > 0 ? e5 > M2 && (M2 = e5, D3 = d) : e5 < C && (C = e5, E2 = d);
  }
  s4(M2 > 0, "leftArea"), s4(C < 0, "rightArea"), l2(wt, gt, m), s3(wt, wt, _t), l2(Mt, gt, w2), s3(Mt, Mt, _t), Ct[0] = -gt[1], Ct[1] = gt[0];
  const j3 = u3(a2, t[E2], Mt, s3(St, Mt, Ct), 1, i), v2 = u3(a2, t[D3], Mt, St, 1, r5), z = u3(a2, t[D3], wt, s3(St, wt, Ct), 1, h2), R = u3(a2, t[E2], wt, St, 1, c2);
  s4(j3, "rayRay"), s4(v2, "rayRay"), s4(z, "rayRay"), s4(R, "rayRay");
}
function Et(t, e4) {
  return 3 * e4 + t;
}
var jt = n3();
function vt(t, e4) {
  return r4(jt, t[e4], t[e4 + 3]), jt;
}
var zt = n3();
var Rt = e();
function Ut(t, e4, s5, a2, i) {
  o3(zt, s5, a2), l2(zt, zt, 0.5), Rt[0] = zt[0], Rt[1] = zt[1], Rt[2] = 0, Rt[3] = zt[1], Rt[4] = -zt[0], Rt[5] = 0, Rt[6] = zt[0] * zt[0] + zt[1] * zt[1], Rt[7] = zt[0] * zt[1] - zt[1] * zt[0], Rt[8] = 1, Rt[Et(0, 2)] = -j2(vt(Rt, 0), t), Rt[Et(1, 2)] = -j2(vt(Rt, 1), t);
  let r5 = j2(vt(Rt, 0), s5) + Rt[Et(0, 2)], h2 = j2(vt(Rt, 1), s5) + Rt[Et(1, 2)], c2 = j2(vt(Rt, 0), a2) + Rt[Et(0, 2)], o4 = j2(vt(Rt, 1), a2) + Rt[Et(1, 2)];
  r5 = -(r5 + c2) / (h2 + o4), Rt[Et(0, 0)] += Rt[Et(1, 0)] * r5, Rt[Et(0, 1)] += Rt[Et(1, 1)] * r5, Rt[Et(0, 2)] += Rt[Et(1, 2)] * r5, r5 = 1 / (j2(vt(Rt, 0), s5) + Rt[Et(0, 2)]), h2 = 1 / (j2(vt(Rt, 1), s5) + Rt[Et(1, 2)]), Rt[Et(0, 0)] *= r5, Rt[Et(0, 1)] *= r5, Rt[Et(0, 2)] *= r5, Rt[Et(1, 0)] *= h2, Rt[Et(1, 1)] *= h2, Rt[Et(1, 2)] *= h2, Rt[Et(2, 0)] = Rt[Et(1, 0)], Rt[Et(2, 1)] = Rt[Et(1, 1)], Rt[Et(2, 2)] = Rt[Et(1, 2)], Rt[Et(1, 2)] += 1, r5 = j2(vt(Rt, 1), e4) + Rt[Et(1, 2)], h2 = j2(vt(Rt, 2), e4) + Rt[Et(2, 2)], c2 = j2(vt(Rt, 1), s5) + Rt[Et(1, 2)], o4 = j2(vt(Rt, 2), s5) + Rt[Et(2, 2)], r5 = -0.5 * (r5 / h2 + c2 / o4), Rt[Et(1, 0)] += Rt[Et(2, 0)] * r5, Rt[Et(1, 1)] += Rt[Et(2, 1)] * r5, Rt[Et(1, 2)] += Rt[Et(2, 2)] * r5, r5 = j2(vt(Rt, 1), e4) + Rt[Et(1, 2)], h2 = j2(vt(Rt, 2), e4) + Rt[Et(2, 2)], c2 = -h2 / r5, Rt[Et(1, 0)] *= c2, Rt[Et(1, 1)] *= c2, Rt[Et(1, 2)] *= c2, i[0] = Rt[0], i[1] = Rt[1], i[2] = 0, i[3] = Rt[2], i[4] = Rt[3], i[5] = Rt[4], i[6] = 0, i[7] = Rt[5], i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = Rt[6], i[13] = Rt[7], i[14] = 0, i[15] = Rt[8];
}

export {
  J,
  Q
};
//# sourceMappingURL=chunk-BBUIX72C.js.map
