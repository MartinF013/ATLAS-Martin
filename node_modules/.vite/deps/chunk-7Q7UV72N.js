import {
  v
} from "./chunk-2ZFIKSC6.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  j,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  O,
  f,
  g,
  p
} from "./chunk-U3PSONS6.js";
import {
  h,
  l,
  o,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/widgets/support/InteractiveAnalysisViewModel.js
var m;
!function(s2) {
  s2[s2.PENDING = 0] = "PENDING", s2[s2.WAIT_FOR_VIEW_READY = 1] = "WAIT_FOR_VIEW_READY", s2[s2.RUNNING = 2] = "RUNNING";
}(m || (m = {}));
var v2 = class extends v {
  constructor(s2 = {}) {
    super(s2), this.analysisView = null, this._reconnectViewTask = null, this._analysisBaseHandles = new u(), this._parentChangeFromReconnect = false, this._startUserOperation = null;
    const t3 = s2 == null ? void 0 : s2.analysis;
    r(t3) ? this.analysis = t3 : (this._set("analysis", this.constructAnalysis()), this._set("isAnalysisOwner", true));
  }
  normalizeCtorArgs(s2) {
    const { analysis: e2, ...i } = s2;
    return i;
  }
  initialize() {
    this._analysisBaseHandles.add([l2(() => o(this.analysis, ({ parent: s2 }) => s2), (s2) => {
      this._parentChangeFromReconnect || s2 === this.view || this._set("isAnalysisOwner", false);
      const e2 = !this._parentChangeFromReconnect;
      this._parentChangeFromReconnect = false, e2 && this._scheduleViewReconnect();
    }, U), l2(() => ({ view: this.view, ready: r(this.view) && this.view.ready, supported: this.supported }), ({ view: s2 }, { view: e2 }) => {
      s2 !== e2 && (this._startUserOperation = h(this._startUserOperation), this._disconnectFromView(e2)), this._scheduleViewReconnect();
    }, w), l2(() => this.analysis.isEditable, (s2, e2) => {
      t(this.analysisView) || (s2 && !e2 && t(this.tool) ? this.createTool() : !s2 && e2 && r(this.tool) && !this.tool.active && this.removeTool());
    })]);
  }
  destroy() {
    this._analysisBaseHandles = l(this._analysisBaseHandles), this._reconnectViewTask = h(this._reconnectViewTask), this._startUserOperation = h(this._startUserOperation), r(this.analysisView) && (this.analysisView.visible = void 0), this._disconnectFromView(this.view), r(this.analysis) && this.isAnalysisOwner && (this.analysis.destroy(), this._set("analysis", null));
  }
  set analysis(s2) {
    s2 !== this._get("analysis") && (this._startUserOperation = h(this._startUserOperation), this._disconnectFromView(this.view), this._setExternalAnalysis(s2), this._scheduleViewReconnect());
  }
  get ready() {
    return r(this.analysisView) && !this.connectingToView;
  }
  get connectingToView() {
    return r(this._reconnectViewTask);
  }
  get isAnalysisOwner() {
    return this._get("isAnalysisOwner");
  }
  set visible(s2) {
    this._set("visible", s2), r(this.analysisView) && (this.analysisView.visible = s2);
  }
  async start() {
    this.clear();
    const s2 = { task: null, abort: null, state: m.PENDING }, e2 = O(async (e3) => {
      s2.state = m.WAIT_FOR_VIEW_READY, await j(() => this.ready, e3), s2.state = m.RUNNING, this.createTool({ interactive: true });
    });
    return s2.task = e2, s2.abort = () => e2.abort(), this._startUserOperation = s2, e2.promise;
  }
  clear() {
    this._startUserOperation = h(this._startUserOperation), this.removeTool(), this.analysis.clear();
  }
  onConnectToAnalysisView(s2) {
  }
  onDisconnectFromAnalysisView() {
  }
  _scheduleViewReconnect() {
    this._reconnectViewTask = h(this._reconnectViewTask);
    const s2 = O(async (e2) => {
      try {
        await this._reconnectView(e2);
      } catch (i) {
        if (f(e2), !g(i))
          return void this.logger.warn("Failed to use analysis in view model", i);
        throw i;
      } finally {
        s2 === this._reconnectViewTask && (this._reconnectViewTask = null);
      }
    });
    this._reconnectViewTask = s2;
  }
  async _reconnectView(s2) {
    const { view: e2 } = this, t3 = r(e2) && e2.ready && this.supported, n2 = this.analysis;
    if (this._startUserOperation = O2(this._startUserOperation), this._disconnectFromView(e2), t3 && !t(e2) && !t(n2)) {
      if (this.isAnalysisOwner) {
        if (r(n2.parent))
          return void this.logError("expected owned analysis to have null parent when connecting to view");
        this._parentChangeFromReconnect = true, e2.analyses.add(n2);
      }
      this.analysisView = await e2.whenAnalysisView(n2), p(s2) ? this._startUserOperation = O2(this._startUserOperation) : (this.analysisView.visible = this.visible, this.onConnectToAnalysisView(this.analysisView), this.createTool());
    }
  }
  _disconnectFromView(s2) {
    this.removeTool(), r(s2) && this.isAnalysisOwner && (this._parentChangeFromReconnect = true, s2.analyses.remove(this.analysis), this.analysis.clear()), this.analysisView = null, this.onDisconnectFromAnalysisView();
  }
  _setExternalAnalysis(s2) {
    if (r(this.analysisView) && !this.isAnalysisOwner && (this.analysisView.visible = true), this.analysisView = null, this._set("isAnalysisOwner", false), this._set("analysis", s2), this._parentChangeFromReconnect = false, !s2.isEditable) {
      const e2 = s2.nonEditableMessage;
      this.logger.warn(`The assigned ${s2.type} analysis object will not be editable in the view. ${e2}`);
    }
  }
  get testInfo() {
    return { analysisView: this.analysisView };
  }
};
function O2(s2) {
  return r(s2) && s2.state >= m.RUNNING ? (s2.abort(), null) : s2;
}
e([d({ nonNullable: true })], v2.prototype, "analysis", null), e([d()], v2.prototype, "analysisView", void 0), e([d()], v2.prototype, "ready", null), e([d()], v2.prototype, "connectingToView", null), e([d({ readOnly: true })], v2.prototype, "isAnalysisOwner", null), e([d({ type: Boolean, value: true })], v2.prototype, "visible", null), e([d()], v2.prototype, "_reconnectViewTask", void 0), v2 = e([n("esri.widgets.support.InteractiveAnalysisViewModel")], v2);

// node_modules/@arcgis/core/views/3d/interactive/measurementTools/support/PickRequest.js
var s = class {
  constructor(s2, t3 = null) {
    this.screenPoint = s2, this.result = t3;
  }
};
var t2 = class {
  constructor(s2, t3) {
    this.scenePoint = s2, this.mapPoint = t3;
  }
};

export {
  s,
  t2 as t,
  v2 as v
};
//# sourceMappingURL=chunk-7Q7UV72N.js.map
