import {
  g
} from "./chunk-UJS24K6P.js";
import {
  s,
  t
} from "./chunk-4V2P7IXX.js";
import {
  X,
  o
} from "./chunk-HH3D3A65.js";
import {
  e,
  n
} from "./chunk-YDPQRKY4.js";
import {
  a as a2
} from "./chunk-KVF4M6PZ.js";
import {
  a
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/geometry/libtess.js
var n2 = 128e3;
var e2 = null;
var i = null;
async function o2() {
  return e2 || (e2 = r()), e2;
}
async function r() {
  const n5 = a("esri-csp-restrictions") ? await import("./libtess-asm-6W57BRA7.js").then((t2) => t2.l) : await import("./libtess-BVTTNEEK.js").then((t2) => t2.l);
  i = await n5.load({ locateFile: (s3) => a2(`esri/core/libs/libtess/${s3}`) });
}
function a3(t2, s3) {
  const e4 = Math.max(t2.length, n2);
  return i.triangulate(t2, s3, e4);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TileClipper.js
var e3 = class {
  constructor(i2, t2, s3) {
    this.ratio = i2, this.x = t2, this.y = s3;
  }
};
var n3 = class {
  constructor(t2, s3, h2, e4 = 8, n5 = 8) {
    this.lines = [], this.starts = [], this.validateTessellation = true, this.pixelRatio = e4, this.pixelMargin = n5, this.tileSize = o * e4, this.dz = t2, this.yPos = s3, this.xPos = h2;
  }
  setPixelMargin(i2) {
    i2 !== this.pixelMargin && (this.pixelMargin = i2, this.setExtent(this._extent));
  }
  setExtent(i2) {
    this._extent = i2, this.finalRatio = this.tileSize / i2 * (1 << this.dz);
    let t2 = this.pixelRatio * this.pixelMargin;
    t2 /= this.finalRatio;
    const s3 = i2 >> this.dz;
    t2 > s3 && (t2 = s3), this.margin = t2, this.xmin = s3 * this.xPos - t2, this.ymin = s3 * this.yPos - t2, this.xmax = this.xmin + s3 + 2 * t2, this.ymax = this.ymin + s3 + 2 * t2;
  }
  reset(i2) {
    this.type = i2, this.lines = [], this.starts = [], this.line = null, this.start = 0;
  }
  moveTo(i2, s3) {
    this._pushLine(), this._prevIsIn = this._isIn(i2, s3), this._moveTo(i2, s3, this._prevIsIn), this._prevPt = new t(i2, s3), this._firstPt = new t(i2, s3), this._dist = 0;
  }
  lineTo(i2, s3) {
    const h2 = this._isIn(i2, s3), n5 = new t(i2, s3), l3 = t.distance(this._prevPt, n5);
    let x3, a6, y2, o4, r3, m, p, u;
    if (h2)
      this._prevIsIn ? this._lineTo(i2, s3, true) : (x3 = this._prevPt, a6 = n5, y2 = this._intersect(a6, x3), this.start = this._dist + l3 * (1 - this._r), this._lineTo(y2.x, y2.y, true), this._lineTo(a6.x, a6.y, true));
    else if (this._prevIsIn)
      a6 = this._prevPt, x3 = n5, y2 = this._intersect(a6, x3), this._lineTo(y2.x, y2.y, true), this._lineTo(x3.x, x3.y, false);
    else {
      const i3 = this._prevPt, t2 = n5;
      if (i3.x <= this.xmin && t2.x <= this.xmin || i3.x >= this.xmax && t2.x >= this.xmax || i3.y <= this.ymin && t2.y <= this.ymin || i3.y >= this.ymax && t2.y >= this.ymax)
        this._lineTo(t2.x, t2.y, false);
      else {
        const s4 = [];
        if ((i3.x < this.xmin && t2.x > this.xmin || i3.x > this.xmin && t2.x < this.xmin) && (o4 = (this.xmin - i3.x) / (t2.x - i3.x), u = i3.y + o4 * (t2.y - i3.y), u <= this.ymin ? m = false : u >= this.ymax ? m = true : s4.push(new e3(o4, this.xmin, u))), (i3.x < this.xmax && t2.x > this.xmax || i3.x > this.xmax && t2.x < this.xmax) && (o4 = (this.xmax - i3.x) / (t2.x - i3.x), u = i3.y + o4 * (t2.y - i3.y), u <= this.ymin ? m = false : u >= this.ymax ? m = true : s4.push(new e3(o4, this.xmax, u))), (i3.y < this.ymin && t2.y > this.ymin || i3.y > this.ymin && t2.y < this.ymin) && (o4 = (this.ymin - i3.y) / (t2.y - i3.y), p = i3.x + o4 * (t2.x - i3.x), p <= this.xmin ? r3 = false : p >= this.xmax ? r3 = true : s4.push(new e3(o4, p, this.ymin))), (i3.y < this.ymax && t2.y > this.ymax || i3.y > this.ymax && t2.y < this.ymax) && (o4 = (this.ymax - i3.y) / (t2.y - i3.y), p = i3.x + o4 * (t2.x - i3.x), p <= this.xmin ? r3 = false : p >= this.xmax ? r3 = true : s4.push(new e3(o4, p, this.ymax))), 0 === s4.length)
          r3 ? m ? this._lineTo(this.xmax, this.ymax, true) : this._lineTo(this.xmax, this.ymin, true) : m ? this._lineTo(this.xmin, this.ymax, true) : this._lineTo(this.xmin, this.ymin, true);
        else if (s4.length > 1 && s4[0].ratio > s4[1].ratio)
          this.start = this._dist + l3 * s4[1].ratio, this._lineTo(s4[1].x, s4[1].y, true), this._lineTo(s4[0].x, s4[0].y, true);
        else {
          this.start = this._dist + l3 * s4[0].ratio;
          for (let i4 = 0; i4 < s4.length; i4++)
            this._lineTo(s4[i4].x, s4[i4].y, true);
        }
        this._lineTo(t2.x, t2.y, false);
      }
    }
    this._dist += l3, this._prevIsIn = h2, this._prevPt = n5;
  }
  close() {
    if (this.line.length > 2) {
      const i2 = this._firstPt, t2 = this._prevPt;
      i2.x === t2.x && i2.y === t2.y || this.lineTo(i2.x, i2.y);
      const s3 = this.line;
      let h2 = s3.length;
      for (; h2 >= 4 && (s3[0].x === s3[1].x && s3[0].x === s3[h2 - 2].x || s3[0].y === s3[1].y && s3[0].y === s3[h2 - 2].y); )
        s3.pop(), s3[0].x = s3[h2 - 2].x, s3[0].y = s3[h2 - 2].y, --h2;
    }
  }
  result(i2 = true) {
    return this._pushLine(), 0 === this.lines.length ? null : (this.type === s.Polygon && i2 && a4.simplify(this.tileSize, this.margin * this.finalRatio, this.lines), this.lines);
  }
  resultWithStarts() {
    if (this.type !== s.LineString)
      throw new Error("Only valid for lines");
    this._pushLine();
    const i2 = this.lines, t2 = i2.length;
    if (0 === t2)
      return null;
    const h2 = [];
    for (let s3 = 0; s3 < t2; s3++)
      h2.push({ line: i2[s3], start: this.starts[s3] || 0 });
    return h2;
  }
  _isIn(i2, t2) {
    return i2 >= this.xmin && i2 <= this.xmax && t2 >= this.ymin && t2 <= this.ymax;
  }
  _intersect(i2, s3) {
    let h2, e4, n5;
    if (s3.x >= this.xmin && s3.x <= this.xmax)
      e4 = s3.y <= this.ymin ? this.ymin : this.ymax, n5 = (e4 - i2.y) / (s3.y - i2.y), h2 = i2.x + n5 * (s3.x - i2.x);
    else if (s3.y >= this.ymin && s3.y <= this.ymax)
      h2 = s3.x <= this.xmin ? this.xmin : this.xmax, n5 = (h2 - i2.x) / (s3.x - i2.x), e4 = i2.y + n5 * (s3.y - i2.y);
    else {
      e4 = s3.y <= this.ymin ? this.ymin : this.ymax, h2 = s3.x <= this.xmin ? this.xmin : this.xmax;
      const t2 = (h2 - i2.x) / (s3.x - i2.x), l3 = (e4 - i2.y) / (s3.y - i2.y);
      t2 < l3 ? (n5 = t2, e4 = i2.y + t2 * (s3.y - i2.y)) : (n5 = l3, h2 = i2.x + l3 * (s3.x - i2.x));
    }
    return this._r = n5, new t(h2, e4);
  }
  _pushLine() {
    this.line && (this.type === s.Point ? this.line.length > 0 && (this.lines.push(this.line), this.starts.push(this.start)) : this.type === s.LineString ? this.line.length > 1 && (this.lines.push(this.line), this.starts.push(this.start)) : this.type === s.Polygon && this.line.length > 3 && (this.lines.push(this.line), this.starts.push(this.start))), this.line = [], this.start = 0;
  }
  _moveTo(i2, h2, e4) {
    this.type !== s.Polygon ? e4 && (i2 = Math.round((i2 - (this.xmin + this.margin)) * this.finalRatio), h2 = Math.round((h2 - (this.ymin + this.margin)) * this.finalRatio), this.line.push(new t(i2, h2))) : (e4 || (i2 < this.xmin && (i2 = this.xmin), i2 > this.xmax && (i2 = this.xmax), h2 < this.ymin && (h2 = this.ymin), h2 > this.ymax && (h2 = this.ymax)), i2 = Math.round((i2 - (this.xmin + this.margin)) * this.finalRatio), h2 = Math.round((h2 - (this.ymin + this.margin)) * this.finalRatio), this.line.push(new t(i2, h2)), this._is_h = false, this._is_v = false);
  }
  _lineTo(i2, h2, e4) {
    let n5, l3;
    if (this.type !== s.Polygon)
      if (e4) {
        if (i2 = Math.round((i2 - (this.xmin + this.margin)) * this.finalRatio), h2 = Math.round((h2 - (this.ymin + this.margin)) * this.finalRatio), this.line.length > 0 && (n5 = this.line[this.line.length - 1], n5.equals(i2, h2)))
          return;
        this.line.push(new t(i2, h2));
      } else
        this.line && this.line.length > 0 && this._pushLine();
    else if (e4 || (i2 < this.xmin && (i2 = this.xmin), i2 > this.xmax && (i2 = this.xmax), h2 < this.ymin && (h2 = this.ymin), h2 > this.ymax && (h2 = this.ymax)), i2 = Math.round((i2 - (this.xmin + this.margin)) * this.finalRatio), h2 = Math.round((h2 - (this.ymin + this.margin)) * this.finalRatio), this.line && this.line.length > 0) {
      n5 = this.line[this.line.length - 1];
      const s3 = n5.x === i2, e5 = n5.y === h2;
      if (s3 && e5)
        return;
      this._is_h && s3 || this._is_v && e5 ? (n5.x = i2, n5.y = h2, l3 = this.line[this.line.length - 2], l3.x === i2 && l3.y === h2 ? (this.line.pop(), this.line.length <= 1 ? (this._is_h = false, this._is_v = false) : (l3 = this.line[this.line.length - 2], this._is_h = l3.x === i2, this._is_v = l3.y === h2)) : (this._is_h = l3.x === i2, this._is_v = l3.y === h2)) : (this.line.push(new t(i2, h2)), this._is_h = s3, this._is_v = e5);
    } else
      this.line.push(new t(i2, h2));
  }
};
var l = class {
  setExtent(i2) {
    this._ratio = 4096 === i2 ? 1 : 4096 / i2;
  }
  get validateTessellation() {
    return this._ratio < 1;
  }
  reset(i2) {
    this.lines = [], this.line = null;
  }
  moveTo(i2, s3) {
    this.line && this.lines.push(this.line), this.line = [];
    const h2 = this._ratio;
    this.line.push(new t(i2 * h2, s3 * h2));
  }
  lineTo(i2, s3) {
    const h2 = this._ratio;
    this.line.push(new t(i2 * h2, s3 * h2));
  }
  close() {
    const i2 = this.line;
    i2 && !i2[0].isEqual(i2[i2.length - 1]) && i2.push(i2[0]);
  }
  result() {
    return this.line && this.lines.push(this.line), 0 === this.lines.length ? null : this.lines;
  }
};
var x;
!function(i2) {
  i2[i2.sideLeft = 0] = "sideLeft", i2[i2.sideRight = 1] = "sideRight", i2[i2.sideTop = 2] = "sideTop", i2[i2.sideBottom = 3] = "sideBottom";
}(x || (x = {}));
var a4 = class {
  static simplify(i2, t2, s3) {
    if (!s3)
      return;
    const h2 = -t2, e4 = i2 + t2, n5 = -t2, l3 = i2 + t2, y2 = [], o4 = [], r3 = s3.length;
    for (let a6 = 0; a6 < r3; ++a6) {
      const i3 = s3[a6];
      if (!i3 || i3.length < 2)
        continue;
      let t3, r4 = i3[0];
      const m2 = i3.length;
      for (let s4 = 1; s4 < m2; ++s4)
        t3 = i3[s4], r4.x === t3.x && (r4.x <= h2 && (r4.y > t3.y ? (y2.push(a6), y2.push(s4), y2.push(x.sideLeft), y2.push(-1)) : (o4.push(a6), o4.push(s4), o4.push(x.sideLeft), o4.push(-1))), r4.x >= e4 && (r4.y < t3.y ? (y2.push(a6), y2.push(s4), y2.push(x.sideRight), y2.push(-1)) : (o4.push(a6), o4.push(s4), o4.push(x.sideRight), o4.push(-1)))), r4.y === t3.y && (r4.y <= n5 && (r4.x < t3.x ? (y2.push(a6), y2.push(s4), y2.push(x.sideTop), y2.push(-1)) : (o4.push(a6), o4.push(s4), o4.push(x.sideTop), o4.push(-1))), r4.y >= l3 && (r4.x > t3.x ? (y2.push(a6), y2.push(s4), y2.push(x.sideBottom), y2.push(-1)) : (o4.push(a6), o4.push(s4), o4.push(x.sideBottom), o4.push(-1)))), r4 = t3;
    }
    if (0 === y2.length || 0 === o4.length)
      return;
    a4.fillParent(s3, o4, y2), a4.fillParent(s3, y2, o4);
    const m = [];
    a4.calcDeltas(m, o4, y2), a4.calcDeltas(m, y2, o4), a4.addDeltas(m, s3);
  }
  static fillParent(i2, t2, s3) {
    const e4 = s3.length, n5 = t2.length;
    for (let l3 = 0; l3 < n5; l3 += 4) {
      const n6 = t2[l3], a6 = t2[l3 + 1], y2 = t2[l3 + 2], o4 = i2[n6][a6 - 1], r3 = i2[n6][a6];
      let m = 8092, p = -1;
      for (let t3 = 0; t3 < e4; t3 += 4) {
        if (s3[t3 + 2] !== y2)
          continue;
        const e5 = s3[t3], n7 = s3[t3 + 1], l4 = i2[e5][n7 - 1], a7 = i2[e5][n7];
        switch (y2) {
          case x.sideLeft:
          case x.sideRight:
            if (g(o4.y, l4.y, a7.y) && g(r3.y, l4.y, a7.y)) {
              const i3 = Math.abs(a7.y - l4.y);
              i3 < m && (m = i3, p = t3);
            }
            break;
          case x.sideTop:
          case x.sideBottom:
            if (g(o4.x, l4.x, a7.x) && g(r3.x, l4.x, a7.x)) {
              const i3 = Math.abs(a7.x - l4.x);
              i3 < m && (m = i3, p = t3);
            }
        }
      }
      t2[l3 + 3] = p;
    }
  }
  static calcDeltas(i2, t2, s3) {
    const h2 = t2.length;
    for (let e4 = 0; e4 < h2; e4 += 4) {
      const h3 = [], n5 = a4.calcDelta(e4, t2, s3, h3);
      i2.push(t2[e4]), i2.push(t2[e4 + 1]), i2.push(t2[e4 + 2]), i2.push(n5);
    }
  }
  static calcDelta(i2, t2, s3, h2) {
    const e4 = t2[i2 + 3];
    if (-1 === e4)
      return 0;
    const n5 = h2.length;
    return n5 > 1 && h2[n5 - 2] === e4 ? 0 : (h2.push(e4), a4.calcDelta(e4, s3, t2, h2) + 1);
  }
  static addDeltas(i2, t2) {
    const s3 = i2.length;
    let h2 = 0;
    for (let e4 = 0; e4 < s3; e4 += 4) {
      const t3 = i2[e4 + 3];
      t3 > h2 && (h2 = t3);
    }
    for (let e4 = 0; e4 < s3; e4 += 4) {
      const s4 = t2[i2[e4]], n5 = i2[e4 + 1], l3 = h2 - i2[e4 + 3];
      switch (i2[e4 + 2]) {
        case x.sideLeft:
          s4[n5 - 1].x -= l3, s4[n5].x -= l3, 1 === n5 && (s4[s4.length - 1].x -= l3), n5 === s4.length - 1 && (s4[0].x -= l3);
          break;
        case x.sideRight:
          s4[n5 - 1].x += l3, s4[n5].x += l3, 1 === n5 && (s4[s4.length - 1].x += l3), n5 === s4.length - 1 && (s4[0].x += l3);
          break;
        case x.sideTop:
          s4[n5 - 1].y -= l3, s4[n5].y -= l3, 1 === n5 && (s4[s4.length - 1].y -= l3), n5 === s4.length - 1 && (s4[0].y -= l3);
          break;
        case x.sideBottom:
          s4[n5 - 1].y += l3, s4[n5].y += l3, 1 === n5 && (s4[s4.length - 1].y += l3), n5 === s4.length - 1 && (s4[0].y += l3);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TurboLine.js
function x2(t2, e4) {
  return t2.x === e4.x && t2.y === e4.y;
}
function r2(t2) {
  if (!t2)
    return;
  const e4 = t2.length;
  if (e4 <= 1)
    return;
  let i2 = 0;
  for (let r3 = 1; r3 < e4; r3++)
    x2(t2[r3], t2[i2]) || ++i2 === r3 || (t2[i2] = t2[r3]);
  t2.length = i2 + 1;
}
function n4(t2, e4) {
  return t2.x = e4.y, t2.y = -e4.x, t2;
}
function s2(t2, e4) {
  return t2.x = -e4.y, t2.y = e4.x, t2;
}
function y(t2, e4) {
  return t2.x = e4.x, t2.y = e4.y, t2;
}
function o3(t2, e4) {
  return t2.x = -e4.x, t2.y = -e4.y, t2;
}
function h(t2) {
  return Math.sqrt(t2.x * t2.x + t2.y * t2.y);
}
function l2(t2, e4) {
  return t2.x * e4.y - t2.y * e4.x;
}
function a5(t2, e4) {
  return t2.x * e4.x + t2.y * e4.y;
}
function c(t2, e4, i2, x3) {
  return t2.x = e4.x * i2 + e4.y * x3, t2.y = e4.x * x3 - e4.y * i2, t2;
}
var d = class {
  constructor(t2, e4, i2) {
    this.writeVertex = t2, this.writeTriangle = e4, this.canUseThinTessellation = i2, this.prevNormal = { x: void 0, y: void 0 }, this.nextNormal = { x: void 0, y: void 0 }, this.textureNormalLeft = { x: 0, y: 1 }, this.textureNormalRight = { x: 0, y: -1 }, this.textureNormal = { x: void 0, y: void 0 }, this.joinNormal = { x: void 0, y: void 0 }, this.inner = { x: void 0, y: void 0 }, this.outer = { x: void 0, y: void 0 }, this.roundStart = { x: void 0, y: void 0 }, this.roundEnd = { x: void 0, y: void 0 }, this.startBreak = { x: void 0, y: void 0 }, this.endBreak = { x: void 0, y: void 0 }, this.innerPrev = { x: void 0, y: void 0 }, this.innerNext = { x: void 0, y: void 0 }, this.bevelStart = { x: void 0, y: void 0 }, this.bevelEnd = { x: void 0, y: void 0 }, this.bevelMiddle = { x: void 0, y: void 0 };
  }
  tessellate(t2, e4) {
    r2(t2), this.canUseThinTessellation && e4.halfWidth < X && !e4.offset ? this._tessellateThin(t2, e4) : this._tessellate(t2, e4);
  }
  _tessellateThin(t2, e4) {
    if (t2.length < 2)
      return;
    const i2 = e4.wrapDistance || 65535;
    let x3 = e4.initialDistance || 0, r3 = false, n5 = t2[0].x, s3 = t2[0].y;
    const y2 = t2.length;
    for (let o4 = 1; o4 < y2; ++o4) {
      r3 && (r3 = false, x3 = 0);
      let e5 = t2[o4].x, y3 = t2[o4].y, h2 = e5 - n5, l3 = y3 - s3, a6 = Math.sqrt(h2 * h2 + l3 * l3);
      if (h2 /= a6, l3 /= a6, x3 + a6 > i2) {
        r3 = true;
        const t3 = (i2 - x3) / a6;
        a6 = i2 - x3, e5 = (1 - t3) * n5 + t3 * e5, y3 = (1 - t3) * s3 + t3 * y3, --o4;
      }
      const c2 = this.writeVertex(n5, s3, 0, 0, h2, l3, l3, -h2, 0, -1, x3), d2 = this.writeVertex(n5, s3, 0, 0, h2, l3, -l3, h2, 0, 1, x3);
      x3 += a6;
      const u = this.writeVertex(e5, y3, 0, 0, h2, l3, l3, -h2, 0, -1, x3), v = this.writeVertex(e5, y3, 0, 0, h2, l3, -l3, h2, 0, 1, x3);
      this.writeTriangle(c2, d2, u), this.writeTriangle(d2, u, v), n5 = e5, s3 = y3;
    }
  }
  _tessellate(i2, r3) {
    const d2 = i2[0], u = i2[i2.length - 1], v = x2(d2, u), f = v ? 3 : 2;
    if (i2.length < f)
      return;
    const w = r3.pixelCoordRatio, T = null != r3.capType ? r3.capType : e.BUTT, g2 = null != r3.joinType ? r3.joinType : n.MITER, m = null != r3.miterLimit ? Math.min(r3.miterLimit, 4) : 2, V = null != r3.roundLimit ? Math.min(r3.roundLimit, 1.05) : 1.05, N = null != r3.halfWidth ? r3.halfWidth : 2, E = !!r3.textured;
    let b, R, U = null, k = null;
    const p = this.prevNormal, M = this.nextNormal;
    let B = -1, L = -1;
    const D = this.joinNormal;
    let S, j;
    const A = this.textureNormalLeft, O = this.textureNormalRight, _ = this.textureNormal;
    let I = -1, P = -1;
    const W = r3.wrapDistance || 65535;
    let q = r3.initialDistance || 0;
    const Q = this.writeVertex, X2 = this.writeTriangle, C = (t2, e4, i3, x3, r4, n5) => {
      const s3 = Q(b, R, S, j, i3, x3, t2, e4, r4, n5, q);
      return I >= 0 && P >= 0 && s3 >= 0 && X2(I, P, s3), I = P, P = s3, s3;
    };
    v && (U = i2[i2.length - 2], M.x = u.x - U.x, M.y = u.y - U.y, L = h(M), M.x /= L, M.y /= L);
    let z = false;
    for (let x3 = 0; x3 < i2.length; ++x3) {
      if (z && (z = false, q = 0), U && (p.x = -M.x, p.y = -M.y, B = L, q + B > W && (z = true)), z) {
        const t2 = (W - q) / B;
        B = W - q, U = { x: (1 - t2) * U.x + t2 * i2[x3].x, y: (1 - t2) * U.y + t2 * i2[x3].y }, --x3;
      } else
        U = i2[x3];
      b = U.x, R = U.y;
      const r4 = x3 <= 0 && !z, d3 = x3 === i2.length - 1;
      if (r4 || (q += B), k = d3 ? v ? i2[1] : null : i2[x3 + 1], k ? (M.x = k.x - b, M.y = k.y - R, L = h(M), M.x /= L, M.y /= L) : (M.x = void 0, M.y = void 0), !v) {
        if (r4) {
          s2(D, M), S = D.x, j = D.y, T === e.SQUARE && (C(-M.y - M.x, M.x - M.y, M.x, M.y, 0, -1), C(M.y - M.x, -M.x - M.y, M.x, M.y, 0, 1)), T === e.ROUND && (C(-M.y - M.x, M.x - M.y, M.x, M.y, -1, -1), C(M.y - M.x, -M.x - M.y, M.x, M.y, -1, 1)), T !== e.ROUND && T !== e.BUTT || (C(-M.y, M.x, M.x, M.y, 0, -1), C(M.y, -M.x, M.x, M.y, 0, 1));
          continue;
        }
        if (d3) {
          n4(D, p), S = D.x, j = D.y, T !== e.ROUND && T !== e.BUTT || (C(p.y, -p.x, -p.x, -p.y, 0, -1), C(-p.y, p.x, -p.x, -p.y, 0, 1)), T === e.SQUARE && (C(p.y - p.x, -p.x - p.y, -p.x, -p.y, 0, -1), C(-p.y - p.x, p.x - p.y, -p.x, -p.y, 0, 1)), T === e.ROUND && (C(p.y - p.x, -p.x - p.y, -p.x, -p.y, 1, -1), C(-p.y - p.x, p.x - p.y, -p.x, -p.y, 1, 1));
          continue;
        }
      }
      let u2, f2, Q2 = -l2(p, M);
      if (Math.abs(Q2) < 0.01)
        a5(p, M) > 0 ? (D.x = p.x, D.y = p.y, Q2 = 1, u2 = Number.MAX_VALUE, f2 = true) : (s2(D, M), Q2 = 1, u2 = 1, f2 = false);
      else {
        D.x = (p.x + M.x) / Q2, D.y = (p.y + M.y) / Q2, u2 = h(D);
        const t2 = (u2 - 1) * N * w;
        f2 = u2 > 4 || t2 > B && t2 > L;
      }
      S = D.x, j = D.y;
      let X3 = g2;
      switch (g2) {
        case n.BEVEL:
          u2 < 1.05 && (X3 = n.MITER);
          break;
        case n.ROUND:
          u2 < V && (X3 = n.MITER);
          break;
        case n.MITER:
          u2 > m && (X3 = n.BEVEL);
      }
      switch (X3) {
        case n.MITER:
          if (C(D.x, D.y, -p.x, -p.y, 0, -1), C(-D.x, -D.y, -p.x, -p.y, 0, 1), d3)
            break;
          if (E) {
            const t2 = z ? 0 : q;
            I = this.writeVertex(b, R, S, j, M.x, M.y, D.x, D.y, 0, -1, t2), P = this.writeVertex(b, R, S, j, M.x, M.y, -D.x, -D.y, 0, 1, t2);
          }
          break;
        case n.BEVEL: {
          const t2 = Q2 < 0;
          let e4, i3, x4, r5;
          if (t2) {
            const t3 = I;
            I = P, P = t3, e4 = A, i3 = O;
          } else
            e4 = O, i3 = A;
          if (f2)
            x4 = t2 ? s2(this.innerPrev, p) : n4(this.innerPrev, p), r5 = t2 ? n4(this.innerNext, M) : s2(this.innerNext, M);
          else {
            const e5 = t2 ? o3(this.inner, D) : y(this.inner, D);
            x4 = e5, r5 = e5;
          }
          const h2 = t2 ? n4(this.bevelStart, p) : s2(this.bevelStart, p);
          C(x4.x, x4.y, -p.x, -p.y, e4.x, e4.y);
          const l3 = C(h2.x, h2.y, -p.x, -p.y, i3.x, i3.y);
          if (d3)
            break;
          const a6 = t2 ? s2(this.bevelEnd, M) : n4(this.bevelEnd, M);
          if (f2) {
            const t3 = this.writeVertex(b, R, S, j, -p.x, -p.y, 0, 0, 0, 0, q);
            I = this.writeVertex(b, R, S, j, M.x, M.y, r5.x, r5.y, e4.x, e4.y, q), P = this.writeVertex(b, R, S, j, M.x, M.y, a6.x, a6.y, i3.x, i3.y, q), this.writeTriangle(l3, t3, P);
          } else {
            if (E) {
              const t3 = this.bevelMiddle;
              t3.x = (h2.x + a6.x) / 2, t3.y = (h2.y + a6.y) / 2, c(_, t3, -p.x, -p.y), C(t3.x, t3.y, -p.x, -p.y, _.x, _.y), c(_, t3, M.x, M.y), I = this.writeVertex(b, R, S, j, M.x, M.y, t3.x, t3.y, _.x, _.y, q), P = this.writeVertex(b, R, S, j, M.x, M.y, r5.x, r5.y, e4.x, e4.y, q);
            } else {
              const t3 = I;
              I = P, P = t3;
            }
            C(a6.x, a6.y, M.x, M.y, i3.x, i3.y);
          }
          if (t2) {
            const t3 = I;
            I = P, P = t3;
          }
          break;
        }
        case n.ROUND: {
          const t2 = Q2 < 0;
          let e4, i3;
          if (t2) {
            const t3 = I;
            I = P, P = t3, e4 = A, i3 = O;
          } else
            e4 = O, i3 = A;
          const x4 = t2 ? o3(this.inner, D) : y(this.inner, D);
          let r5, h2;
          f2 ? (r5 = t2 ? s2(this.innerPrev, p) : n4(this.innerPrev, p), h2 = t2 ? n4(this.innerNext, M) : s2(this.innerNext, M)) : (r5 = x4, h2 = x4);
          const l3 = t2 ? n4(this.roundStart, p) : s2(this.roundStart, p), v2 = t2 ? s2(this.roundEnd, M) : n4(this.roundEnd, M), w2 = C(r5.x, r5.y, -p.x, -p.y, e4.x, e4.y), T2 = C(l3.x, l3.y, -p.x, -p.y, i3.x, i3.y);
          if (d3)
            break;
          const g3 = this.writeVertex(b, R, S, j, -p.x, -p.y, 0, 0, 0, 0, q);
          f2 || this.writeTriangle(I, P, g3);
          const m2 = o3(this.outer, x4), V2 = this.writeVertex(b, R, S, j, M.x, M.y, v2.x, v2.y, i3.x, i3.y, q);
          let N2, U2;
          const k2 = u2 > 2;
          if (k2) {
            let e5;
            u2 !== Number.MAX_VALUE ? (m2.x /= u2, m2.y /= u2, e5 = a5(p, m2), e5 = (u2 * (e5 * e5 - 1) + 1) / e5) : e5 = -1, N2 = t2 ? n4(this.startBreak, p) : s2(this.startBreak, p), N2.x += p.x * e5, N2.y += p.y * e5, U2 = t2 ? s2(this.endBreak, M) : n4(this.endBreak, M), U2.x += M.x * e5, U2.y += M.y * e5;
          }
          c(_, m2, -p.x, -p.y);
          const B2 = this.writeVertex(b, R, S, j, -p.x, -p.y, m2.x, m2.y, _.x, _.y, q);
          c(_, m2, M.x, M.y);
          const L2 = E ? this.writeVertex(b, R, S, j, M.x, M.y, m2.x, m2.y, _.x, _.y, q) : B2, W2 = g3, X4 = E ? this.writeVertex(b, R, S, j, M.x, M.y, 0, 0, 0, 0, q) : g3;
          let z2 = -1, F = -1;
          if (k2 && (c(_, N2, -p.x, -p.y), z2 = this.writeVertex(b, R, S, j, -p.x, -p.y, N2.x, N2.y, _.x, _.y, q), c(_, U2, M.x, M.y), F = this.writeVertex(b, R, S, j, M.x, M.y, U2.x, U2.y, _.x, _.y, q)), E ? k2 ? (this.writeTriangle(W2, T2, z2), this.writeTriangle(W2, z2, B2), this.writeTriangle(X4, L2, F), this.writeTriangle(X4, F, V2)) : (this.writeTriangle(W2, T2, B2), this.writeTriangle(X4, L2, V2)) : k2 ? (this.writeTriangle(g3, T2, z2), this.writeTriangle(g3, z2, F), this.writeTriangle(g3, F, V2)) : (this.writeTriangle(g3, T2, B2), this.writeTriangle(g3, L2, V2)), f2 ? (I = this.writeVertex(b, R, S, j, M.x, M.y, h2.x, h2.y, e4.x, e4.y, q), P = V2) : (I = E ? this.writeVertex(b, R, S, j, M.x, M.y, h2.x, h2.y, e4.x, e4.y, q) : w2, this.writeTriangle(I, X4, V2), P = V2), t2) {
            const t3 = I;
            I = P, P = t3;
          }
          break;
        }
      }
    }
  }
};

export {
  o2 as o,
  a3 as a,
  n3 as n,
  l,
  d
};
//# sourceMappingURL=chunk-XP3NTQW6.js.map
