import {
  z
} from "./chunk-RN2KRYDN.js";
import {
  f,
  u,
  w
} from "./chunk-56RHM4A6.js";
import {
  M,
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  c,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/support/ElevationSampler.js
var m = s.getLogger("esri.layers.support.ElevationSampler");
var c2 = class {
  queryElevation(e) {
    return h(e.clone(), this);
  }
  on() {
    return g;
  }
  projectIfRequired(e, t2) {
    return f2(e, t2);
  }
};
var u2 = class extends c2 {
  constructor(e, t2, n) {
    super(), this.tile = e, this.noDataValue = n, this.extent = f(e.tile.extent, t2.spatialReference), this.extent.zmin = e.zmin, this.extent.zmax = e.zmax, this.aaExtent = e.tile.extent;
    const o = z(t2.spatialReference), a = t2.lodAt(e.tile.level).resolution * o;
    this.demResolution = { min: a, max: a };
  }
  get spatialReference() {
    return this.extent.spatialReference;
  }
  contains(e) {
    const n = this.projectIfRequired(e, this.spatialReference);
    return !t(n) && this.containsAt(n.x, n.y);
  }
  containsAt(e, t2) {
    return w(this.aaExtent, e, t2);
  }
  elevationAt(e, t2) {
    if (!this.containsAt(e, t2)) {
      const n = this.extent, s2 = `${n.xmin}, ${n.ymin}, ${n.xmax}, ${n.ymax}`;
      return m.warn("#elevationAt()", `Point used to sample elevation (${e}, ${t2}) is outside of the sampler extent (${s2})`), this.noDataValue;
    }
    return c(this.tile.sample(e, t2), this.noDataValue);
  }
};
var p = class extends c2 {
  constructor(e, t2, n) {
    let s2;
    super(), "number" == typeof t2 ? (this.noDataValue = t2, s2 = null) : (s2 = t2, this.noDataValue = n), this.samplers = s2 ? e.map((e2) => new u2(e2, s2, this.noDataValue)) : e;
    const o = this.samplers[0];
    if (o) {
      this.extent = o.extent.clone();
      const { min: e2, max: t3 } = o.demResolution;
      this.demResolution = { min: e2, max: t3 };
      for (let n2 = 1; n2 < this.samplers.length; n2++) {
        const e3 = this.samplers[n2];
        this.extent.union(e3.extent), this.demResolution.min = Math.min(this.demResolution.min, e3.demResolution.min), this.demResolution.max = Math.max(this.demResolution.max, e3.demResolution.max);
      }
    } else
      this.extent = f(u(), s2.spatialReference), this.demResolution = { min: 0, max: 0 };
  }
  get spatialReference() {
    return this.extent.spatialReference;
  }
  elevationAt(e, t2) {
    for (const n of this.samplers)
      if (n.containsAt(e, t2))
        return n.elevationAt(e, t2);
    return m.warn("#elevationAt()", `Point used to sample elevation (${e}, ${t2}) is outside of the sampler`), this.noDataValue;
  }
};
function h(e, t2) {
  const n = f2(e, t2.spatialReference);
  if (!n)
    return null;
  switch (e.type) {
    case "point":
      x(e, n, t2);
      break;
    case "polyline":
      R(e, n, t2);
      break;
    case "multipoint":
      d(e, n, t2);
  }
  return e;
}
function f2(e, n) {
  if (t(e))
    return null;
  const s2 = e.spatialReference;
  if (s2.equals(n))
    return e;
  const i = M(e, n);
  return i || m.error(`Cannot project geometry spatial reference (wkid:${s2.wkid}) to elevation sampler spatial reference (wkid:${n.wkid})`), i;
}
function x(e, t2, n) {
  e.z = n.elevationAt(t2.x, t2.y);
}
function R(e, t2, n) {
  y.spatialReference = t2.spatialReference;
  const s2 = e.hasM && !e.hasZ;
  for (let i = 0; i < e.paths.length; i++) {
    const o = e.paths[i], a = t2.paths[i];
    for (let e2 = 0; e2 < o.length; e2++) {
      const t3 = o[e2], i2 = a[e2];
      y.x = i2[0], y.y = i2[1], s2 && (t3[3] = t3[2]), t3[2] = n.elevationAt(y.x, y.y);
    }
  }
  e.hasZ = true;
}
function d(e, t2, n) {
  y.spatialReference = t2.spatialReference;
  const s2 = e.hasM && !e.hasZ;
  for (let i = 0; i < e.points.length; i++) {
    const o = e.points[i], a = t2.points[i];
    y.x = a[0], y.y = a[1], s2 && (o[3] = o[2]), o[2] = n.elevationAt(y.x, y.y);
  }
  e.hasZ = true;
}
var y = new j();
var g = { remove() {
} };

export {
  p,
  h
};
//# sourceMappingURL=chunk-T4FVDPUN.js.map
