import {
  C as C3,
  m as m4
} from "./chunk-KP6RIJS6.js";
import {
  C as C2,
  O as O3
} from "./chunk-SHAETJSZ.js";
import {
  o as o5
} from "./chunk-A3D26CKY.js";
import {
  t as t7
} from "./chunk-PMQUXI6L.js";
import {
  e as e7,
  t as t6
} from "./chunk-SV4VP57N.js";
import {
  m as m2
} from "./chunk-444THZYK.js";
import {
  i as i2
} from "./chunk-E3V32BOJ.js";
import {
  o as o4
} from "./chunk-XEIRRA3E.js";
import {
  e as e6,
  i as i3,
  t as t5
} from "./chunk-PZFKIJU3.js";
import {
  i,
  n as n4
} from "./chunk-B3IXFXV6.js";
import {
  m as m3
} from "./chunk-MQLLOFWM.js";
import {
  t as t4
} from "./chunk-I22L7HNU.js";
import {
  F
} from "./chunk-44UD36FH.js";
import {
  h
} from "./chunk-Y5AGUEHG.js";
import {
  a,
  d as d2,
  l,
  t as t2
} from "./chunk-DVE4HUBR.js";
import {
  m
} from "./chunk-RC6OMMF6.js";
import {
  d,
  o as o2
} from "./chunk-OYNEZ5VG.js";
import {
  e as e5
} from "./chunk-YSWURJZW.js";
import {
  e as e4
} from "./chunk-O7YSDCZE.js";
import {
  a as a3
} from "./chunk-767LZ6IM.js";
import {
  n as n5
} from "./chunk-DNPZNIDB.js";
import {
  o
} from "./chunk-TEJEYVH4.js";
import {
  t as t3
} from "./chunk-HEZ2ATGC.js";
import {
  a as a4
} from "./chunk-BOVIIQLB.js";
import {
  p
} from "./chunk-IJHFAZOW.js";
import {
  c
} from "./chunk-DMGVDNFD.js";
import {
  e as e3
} from "./chunk-4MKQUQD4.js";
import {
  o as o3
} from "./chunk-A3QLZKCF.js";
import {
  a as a2,
  i2 as i4
} from "./chunk-I5UNY2WQ.js";
import {
  H,
  T
} from "./chunk-PLLZPG4O.js";
import {
  n as n3
} from "./chunk-NAB3NF54.js";
import {
  C,
  O as O2,
  n as n2
} from "./chunk-MDCKEJ7B.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  n
} from "./chunk-P6G64ARX.js";
import {
  e as e2,
  s,
  t
} from "./chunk-SN4RUQ4N.js";
import {
  e
} from "./chunk-IVBXK6OP.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl.js
var a5;
function r(r2, c2) {
  const i5 = r2.vertex;
  switch (i5.code.add(n3`#define VERTEX_DISCARD_CUTOFF (1.0 - 1.0 / 255.0)`), c2.vertexDiscardMode) {
    case a5.None:
      i5.code.add(n3`#define vertexDiscardByOpacity(_opacity_) {}`);
      break;
    case a5.Opaque:
      i5.code.add(n3`#define vertexDiscardByOpacity(_opacity_) { if (_opacity_ >  VERTEX_DISCARD_CUTOFF) {  gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`);
      break;
    case a5.Transparent:
      i5.code.add(n3`#define vertexDiscardByOpacity(_opacity_) { if (_opacity_ <= VERTEX_DISCARD_CUTOFF) {  gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`);
  }
}
!function(e8) {
  e8[e8.None = 0] = "None", e8[e8.Transparent = 1] = "Transparent", e8[e8.Opaque = 2] = "Opaque", e8[e8.COUNT = 3] = "COUNT";
}(a5 || (a5 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/ComponentTechniqueConfiguration.js
var v;
var T2;
!function(o6) {
  o6[o6.None = 0] = "None", o6[o6.Transparent = 1] = "Transparent", o6[o6.Opaque = 2] = "Opaque", o6[o6.COUNT = 3] = "COUNT";
}(v || (v = {})), function(o6) {
  o6[o6.None = 0] = "None", o6[o6.NoOverlay = 1] = "NoOverlay", o6[o6.ColorOverlay = 2] = "ColorOverlay", o6[o6.ColorOverlayWithWater = 3] = "ColorOverlayWithWater", o6[o6.COUNT = 4] = "COUNT";
}(T2 || (T2 = {}));
var m5 = class extends t6 {
  constructor() {
    super(...arguments), this.output = o.Color, this.textureCoordinateType = o2.None, this.componentData = m4.Uniform, this.cullFace = n2.Back, this.vertexDiscardMode = a5.None, this.doubleSidedMode = i2.WindingOrder, this.alphaDiscardMode = C.Opaque, this.integratedMeshMode = T2.None, this.transparencyPassType = O2.NONE, this.ellipsoidMode = t7.Earth, this.pbrMode = l.Disabled, this.normalType = i.Attribute, this.spherical = false, this.doublePrecisionRequiresObfuscation = false, this.hasVertexColors = false, this.hasNormals = false, this.hasSlicePlane = false, this.hasBaseColorTexture = false, this.receiveAmbientOcclusion = true, this.receiveShadows = true, this.blendingEnabled = true, this.hasScreenSpaceReflections = false, this.hasPolygonOffset = false, this.hasMetalnessAndRoughnessTexture = false, this.hasEmissionTexture = false, this.hasOcclusionTexture = false, this.hasNormalTexture = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.cullAboveGround = false, this.isGround = false, this.hasCloudsReflections = true, this.snowCover = false;
  }
};
e([e7({ count: o.COUNT })], m5.prototype, "output", void 0), e([e7({ count: o2.COUNT })], m5.prototype, "textureCoordinateType", void 0), e([e7({ count: m4.COUNT })], m5.prototype, "componentData", void 0), e([e7({ count: n2.COUNT })], m5.prototype, "cullFace", void 0), e([e7({ count: a5.COUNT })], m5.prototype, "vertexDiscardMode", void 0), e([e7({ count: i2.COUNT })], m5.prototype, "doubleSidedMode", void 0), e([e7({ count: C.COUNT })], m5.prototype, "alphaDiscardMode", void 0), e([e7({ count: T2.COUNT })], m5.prototype, "integratedMeshMode", void 0), e([e7({ count: O2.COUNT })], m5.prototype, "transparencyPassType", void 0), e([e7({ count: t7.COUNT })], m5.prototype, "ellipsoidMode", void 0), e([e7({ count: l.COUNT })], m5.prototype, "pbrMode", void 0), e([e7({ count: i.COUNT })], m5.prototype, "normalType", void 0), e([e7()], m5.prototype, "spherical", void 0), e([e7()], m5.prototype, "doublePrecisionRequiresObfuscation", void 0), e([e7()], m5.prototype, "hasVertexColors", void 0), e([e7()], m5.prototype, "hasNormals", void 0), e([e7()], m5.prototype, "hasSlicePlane", void 0), e([e7()], m5.prototype, "hasBaseColorTexture", void 0), e([e7()], m5.prototype, "receiveAmbientOcclusion", void 0), e([e7()], m5.prototype, "receiveShadows", void 0), e([e7()], m5.prototype, "blendingEnabled", void 0), e([e7()], m5.prototype, "hasScreenSpaceReflections", void 0), e([e7()], m5.prototype, "hasPolygonOffset", void 0), e([e7()], m5.prototype, "hasMetalnessAndRoughnessTexture", void 0), e([e7()], m5.prototype, "hasEmissionTexture", void 0), e([e7()], m5.prototype, "hasOcclusionTexture", void 0), e([e7()], m5.prototype, "hasNormalTexture", void 0), e([e7()], m5.prototype, "hasOccludees", void 0), e([e7()], m5.prototype, "hasMultipassTerrain", void 0), e([e7()], m5.prototype, "cullAboveGround", void 0), e([e7()], m5.prototype, "isGround", void 0), e([e7()], m5.prototype, "hasCloudsReflections", void 0), e([e7()], m5.prototype, "snowCover", void 0), e([e7({ constValue: a2.Draw })], m5.prototype, "pbrTextureBindType", void 0), e([e7({ constValue: true })], m5.prototype, "hasSliceHighlight", void 0), e([e7({ constValue: false })], m5.prototype, "hasSliceInVertexProgram", void 0), e([e7({ constValue: false })], m5.prototype, "useCustomDTRExponentForWater", void 0), e([e7({ constValue: false })], m5.prototype, "hasVertexTangents", void 0), e([e7({ constValue: true })], m5.prototype, "supportsTextureAtlas", void 0), e([e7({ constValue: false })], m5.prototype, "highStepCount", void 0), e([e7({ constValue: false })], m5.prototype, "instancedDoublePrecision", void 0), e([e7({ constValue: true })], m5.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js
function l2(l3, s3) {
  l3.include(e4, s3), l3.fragment.include(i3);
  const i5 = l3.fragment;
  i5.uniforms.add(new o5("baseColor", (o6) => o6.baseColor)), i5.uniforms.add(new e6("objectOpacity", (o6) => o6.objectOpacity)), s3.hasVertexColors ? i5.code.add(n3`vec3 _baseColor() {
return baseColor.rgb * vColor.rgb;
}
float _baseOpacity() {
return baseColor.a * vColor.a;
}`) : i5.code.add(n3`vec3 _baseColor() {
return baseColor.rgb;
}
float _baseOpacity() {
return baseColor.a;
}`), i5.code.add(n3`vec4 computeMaterialColor(vec4 textureColor, vec4 externalColor, int externalColorMixMode) {
vec3 baseColor = _baseColor();
float baseOpacity = _baseOpacity();
vec3 color = mixExternalColor(
baseColor,
textureColor.rgb,
externalColor.rgb,
externalColorMixMode
);
float opacity = objectOpacity * mixExternalOpacity(
baseOpacity,
textureColor.a,
externalColor.a,
externalColorMixMode
);
return vec4(color, opacity);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl.js
function t8(t9, s3) {
  const l3 = t9.fragment;
  switch (s3.doubleSidedMode) {
    case i2.None:
      l3.code.add(n3`vec3 _adjustDoublesided(vec3 normal) {
return normal;
}`);
      break;
    case i2.View:
      t9.include(F, s3), l3.code.add(n3`vec3 _adjustDoublesided(vec3 normal) {
return dot(normal, vPositionWorldCameraRelative) > 0.0 ? -normal : normal;
}`);
      break;
    case i2.WindingOrder:
      l3.code.add(n3`vec3 _adjustDoublesided(vec3 normal) {
return gl_FrontFacing ? normal : -normal;
}`);
      break;
    default:
      n(s3.doubleSidedMode);
    case i2.COUNT:
  }
  switch (s3.normalType) {
    case i.Attribute:
    case i.CompressedAttribute:
      t9.include(n4, s3), l3.code.add(n3`vec3 shadingNormalWorld() {
return _adjustDoublesided(normalize(vNormalWorld));
}
vec3 shadingNormal_view() {
vec3 normal = normalize(vNormalView);
return gl_FrontFacing ? normal : -normal;
}`);
      break;
    case i.ScreenDerivative:
      t9.extensions.add("GL_OES_standard_derivatives"), t9.include(F, s3), l3.code.add(n3`vec3 shadingNormalWorld() {
return normalize(cross(
dFdx(vPositionWorldCameraRelative),
dFdy(vPositionWorldCameraRelative)
));
}
vec3 shadingNormal_view() {
return normalize(cross(dFdx(vPosition_view),dFdy(vPosition_view)));
}`);
      break;
    case i.Ground:
      s3.spherical ? (t9.include(F, s3), l3.code.add(n3`vec3 shadingNormalWorld() {
return normalize(positionWorld());
}`)) : l3.code.add(n3`vec3 shadingNormalWorld() {
return vec3(0.0, 0.0, 1.0);
}`), t9.extensions.add("GL_OES_standard_derivatives"), l3.code.add(n3`vec3 shadingNormal_view() {
return normalize(cross(dFdx(vPosition_view),dFdy(vPosition_view))).xyz;
}`);
      break;
    default:
      n(s3.normalType);
    case i.COUNT:
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js
function s2(s3, a6) {
  const d3 = s3.fragment;
  if (a6.hasBaseColorTexture) {
    s3.include(a, a6);
    const l3 = a6.textureCoordinateType === o2.Atlas;
    d3.uniforms.add(m("baseColorTexture", (e8) => e8.texture, l3)), l3 ? (s3.include(t2), d3.code.add(n3`vec4 readBaseColorTexture() {
return textureAtlasLookup(baseColorTexture, baseColorTextureSize, vuv0, vuvRegion);
}`)) : d3.code.add(n3`vec4 readBaseColorTexture() {
return texture2D(baseColorTexture, vuv0);
}`);
  } else
    d3.code.add(n3`vec4 readBaseColorTexture() { return vec4(1.0); }`);
}

// node_modules/@arcgis/core/chunks/ComponentShader.glsl.js
var I = /* @__PURE__ */ new Map([[O.POSITION, 0], [O.NORMAL, 1], [O.NORMALCOMPRESSED, 1], [O.COLOR, 2], [O.UV0, 3], [O.UVREGION, 4], [O.COMPONENTINDEX, 5]]);
function G(a6) {
  const i5 = new i4();
  i5.include(F, a6), i5.include(n4, a6), i5.include(e4, a6), i5.include(d, a6), i5.include(t4, a6), i5.include(C3, a6), i5.include(t5, a6), i5.include(p, a6), i5.include(s2, a6), i5.include(r, a6);
  const { vertex: V, fragment: I2 } = i5;
  I2.uniforms.add(new o4("view")), a6.pbrMode !== l.Normal && a6.pbrMode !== l.Schematic || (i5.include(d2, a6), a6.hasNormalTexture && i5.include(m2, a6)), a6.output === o.Shadow && a6.componentData === m4.Varying ? V.code.add(n3`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`) : V.code.add(n3`#define discardShadows(castShadows) {}`);
  const G2 = a6.integratedMeshMode === T2.ColorOverlay || a6.integratedMeshMode === T2.ColorOverlayWithWater, k2 = G2 && a6.output === o.Color && a6.pbrMode === l.WaterOnIntegratedMesh;
  return G2 && (i5.include(m3, a6), i5.include(C2, a6), a6.spherical ? V.code.add(n3`
      const float invEllipsoidRadius = ${n3.float(1 / (a6.ellipsoidMode === t7.Earth ? s.radius : a6.ellipsoidMode === t7.Mars ? t.radius : e2.radius))};
      vec2 projectOverlay(vec3 pos) {
        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);
      }
      `) : V.code.add(n3`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)), k2 && (i5.varyings.add("tbnTangent", "vec3"), i5.varyings.add("tbnBiTangent", "vec3"), i5.varyings.add("groundNormal", "vec3")), V.code.add(n3`
    void main() {
      bool castShadows;
      vec4 externalColor = forwardExternalColor(castShadows);
      discardShadows(castShadows);

      vertexDiscardByOpacity(externalColor.a);

      if (externalColor.a < ${n3.float(t3)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }

      forwardPosition(readElevationOffset());
      forwardNormal();
      forwardTextureCoordinates();
      forwardVertexColor();
      forwardLinearDepth();
      ${k2 ? a6.spherical ? n3`
                groundNormal = normalize(positionWorld());
                tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
                tbnBiTangent = normalize(cross(groundNormal, tbnTangent));` : n3`
                groundNormal = vec3(0.0, 0.0, 1.0);
                tbnTangent = vec3(1.0, 0.0, 0.0);
                tbnBiTangent = vec3(0.0, 1.0, 0.0);` : ""}
      ${G2 ? n3`setOverlayVTC(projectOverlay(position));` : ""}
    }
  `), a6.output === o.Alpha && (I2.include(a4), i5.include(n5, a6), i5.include(l2, a6), G2 && I2.uniforms.add(new c("ovColorTex", (e8, o6) => O3(e8, o6))), I2.code.add(n3`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${a6.hasMultipassTerrain ? n3`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : ""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${G2 ? n3`
                vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);
                materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : ""}

        gl_FragColor = vec4(materialColor.a);
      }
    `)), a6.output === o.Color && (I2.include(a4), i5.include(n5, a6), i5.include(l2, a6), i5.include(t8, a6), i5.include(m3, a6), a6.receiveShadows ? (i5.include(h, a6), I2.code.add(n3`float evaluateShadow() {
return readShadowMap(vPositionWorldCameraRelative, linearDepth);
}`)) : I2.code.add(n3`float evaluateShadow() { return 0.0; }`), G2 && I2.uniforms.add(new c("ovColorTex", (e8, o6) => O3(e8, o6))), I2.code.add(n3`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${a6.hasMultipassTerrain ? n3`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : ""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${G2 ? n3`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);` : ""}
    `), a6.pbrMode === l.Normal || a6.pbrMode === l.Schematic ? (I2.uniforms.add(new e3("lightingMainIntensity", (e8, o6) => o6.lighting.mainLight.intensity)), I2.code.add(n3`
        ${a6.pbrMode === l.Normal ? n3`
                applyPBRFactors();
                if (int(externalColorMixMode) == 3) {
                  mrr = vec3(0.0, 0.6, 0.2);
                }` : ""}
        vec3 normalVertex = shadingNormalWorld();
        float additionalIrradiance = 0.02 * lightingMainIntensity[2];
      `), a6.hasNormalTexture ? I2.code.add(n3`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);
vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`) : I2.code.add(n3`vec3 shadingNormal = normalVertex;`), I2.code.add(n3`${a6.spherical ? n3`vec3 normalGround = normalize(positionWorld());` : n3`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}
      `), I2.code.add(n3`
        vec3 viewDir = normalize(vPositionWorldCameraRelative);
        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());

        ${a6.snowCover ? n3`
                vec3 surfaceNormal = normalize(shadingNormalWorld());
                float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));
                materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);

                shadingNormal = mix(shadingNormal, surfaceNormal, snow);
                ssao = mix(ssao, 0.0, snow);
                mrr = mix(mrr, vec3(0.0, 1.0, 0.04), snow);
                emission = mix(emission, vec3(0.0), snow);` : ""}

        ${G2 ? n3` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : ""}

        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);
        `)) : (a6.receiveShadows ? I2.code.add(n3`float shadow = evaluateShadow();`) : a6.spherical ? (I2.uniforms.add(new o3("lightingGlobalFactor", (e8, o6) => o6.lighting.globalFactor)), I2.code.add(n3`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());
float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`)) : I2.code.add(n3`float shadow = 0.0;`), k2 && I2.uniforms.add(new c("ovNormalTex", (e8, o6) => U(o6))), a6.snowCover && (i5.extensions.add("GL_OES_standard_derivatives"), I2.code.add(n3`vec3 surfaceNormal = normalize(cross(dFdx(vPositionWorldCameraRelative), dFdy(vPositionWorldCameraRelative)));
float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));
materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`)), I2.code.add(n3`
        float ambientOcclusion = evaluateAmbientOcclusion();
        vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());

        ${G2 ? n3` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : ""}

        vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);
      ${k2 ? n3`
              vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
              float waterNormalLength = length(overlayWaterMask);
              if (waterNormalLength > 0.95) {
                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());
                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                // un-gamma the ground color to mix in linear space
                shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
              }` : ""}
      `)), I2.code.add(n3`
        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);
        ${a6.transparencyPassType === O2.Color ? "gl_FragColor = premultiplyAlpha(gl_FragColor);" : ""}
      }
    `)), a6.output !== o.Depth && a6.output !== o.Shadow || (i5.include(e5, a6), I2.code.add(n3`void main() {
discardBySlice(vPositionWorldCameraRelative);
vec4 textureColor = readBaseColorTexture();
discardOrAdjustAlpha(textureColor);
outputDepth(linearDepth);
}`)), a6.output === o.Normal && (i5.include(t8, a6), I2.code.add(n3`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        // note: the alpha component needs to be 1.0 in order for this material
        // to influence ambient occlusion, see the ssao fragment shader
        float alpha = ${a6.normalType === i.Ground ? "0.0" : "1.0"};
        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);
      }
    `)), a6.output === o.Highlight && (i5.include(a3), I2.code.add(n3`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${G2 ? n3`
                vec4 overlayColor = getCombinedOverlayColor();
                if (overlayColor.a == 0.0) {
                  gl_FragColor = vec4(0.0);
                  return;
                }` : ""}

        outputHighlight();
      }
    `)), i5;
}
function U(e8) {
  return 0 === e8.overlays.length ? null : e8.overlays[T.INNER].getValidTexture(H.Water);
}
var k = Object.freeze(Object.defineProperty({ __proto__: null, attributeLocations: I, build: G, getOverlayNormalTexture: U }, Symbol.toStringTag, { value: "Module" }));

export {
  a5 as a,
  T2 as T,
  m5 as m,
  I,
  G,
  U,
  k
};
//# sourceMappingURL=chunk-SOPSFYTX.js.map
