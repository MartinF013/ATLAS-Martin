import {
  o
} from "./chunk-AJRWXVO4.js";
import "./chunk-UJ2QT226.js";
import {
  f
} from "./chunk-LCW6FHIL.js";
import {
  u
} from "./chunk-4QVQG5LC.js";
import "./chunk-UQFAHV7T.js";
import {
  Y
} from "./chunk-COK4R22F.js";
import "./chunk-T6XN76GI.js";
import "./chunk-EZ4QR7V3.js";
import "./chunk-25Y2OKSP.js";
import "./chunk-73VW7LOZ.js";
import "./chunk-EMETVH63.js";
import "./chunk-V56SVRSV.js";
import "./chunk-XZHFGTRH.js";
import "./chunk-2I27THZD.js";
import "./chunk-X64NQ2GK.js";
import "./chunk-NVOCHKIH.js";
import "./chunk-DGELARKE.js";
import "./chunk-WN3KE5M2.js";
import "./chunk-PJI2LYU5.js";
import {
  r as r2
} from "./chunk-3HMF3PNP.js";
import "./chunk-N5C77AAH.js";
import "./chunk-KBCUY3VB.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-CC32E45Q.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import "./chunk-RTHP2LNT.js";
import {
  te
} from "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import {
  s
} from "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import {
  An,
  fn,
  rn
} from "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-FU5UMT3R.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-GRILTTJT.js";
import {
  a
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import {
  i
} from "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  C,
  O
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  A2 as A,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var w = class extends a(y) {
  constructor(e2) {
    super(e2), this.availability = 1, this.sources = { multipoint: null, point: null, polygon: null, polyline: null }, this.loadedWkids = /* @__PURE__ */ new Set(), this.loadedWkts = /* @__PURE__ */ new Set(), this.pendingAdds = [];
  }
  get updating() {
    return this.updatingHandles.updating;
  }
  get layer() {
    return this.layerSource.layer;
  }
  destroy() {
    const e2 = this.pendingAdds;
    this.pendingAdds.length = 0;
    for (const t2 of e2)
      t2.task.abort();
    this._mapSources((e3) => this._destroySource(e3));
  }
  initialize() {
    this.handles.add([this.layer.on("graphic-update", (e2) => this._onGraphicUpdate(e2)), this.updatingHandles.addOnCollectionChange(() => this.layer.graphics, (e2) => this._onGraphicsChanged(e2))]), this._addMany(this.layer.graphics.toArray());
  }
  async fetchCandidates(e2, t2) {
    const r3 = await C(this._mapSources((r4) => r4.queryEngine.executeQueryForSnapping({ point: e2.coordinateHelper.vectorToPoint(e2.point).toJSON(), distance: e2.distance, types: e2.types, query: r(e2.filter) ? e2.filter.createQuery().toJSON() : { where: "1=1" } }, t2).then(({ candidates: e3 }) => e3))), s2 = r3.flat().map((t3) => o(t3, e2.coordinateHelper, e2.elevationInfo));
    return r2(e2.point, s2), s2;
  }
  refresh() {
  }
  _onGraphicUpdate(e2) {
    switch (e2.property) {
      case "geometry":
      case "visible":
        this._remove(e2.graphic), this._addMany([e2.graphic]);
    }
  }
  _onGraphicsChanged(e2) {
    for (const t2 of e2.removed)
      this._remove(t2);
    this._addMany(e2.added);
  }
  _addMany(e2) {
    const t2 = [], r3 = /* @__PURE__ */ new Map();
    for (const s2 of e2)
      t(s2.geometry) || (this._needsInitializeProjection(s2.geometry.spatialReference) ? (t2.push(s2.geometry.spatialReference), r3.set(s2.uid, s2)) : this._add(s2));
    this._createPendingAdd(t2, r3);
  }
  _createPendingAdd(e2, t2) {
    if (!e2.length)
      return;
    const s2 = O(async (r3) => {
      await fn(e2.map((e3) => ({ source: e3, dest: this.spatialReference })), { signal: r3 }), this._markLoadedSpatialReferences(e2);
      for (const [, e3] of t2)
        this._add(e3);
    });
    this.updatingHandles.addPromise(s2.promise);
    const o2 = { task: s2, graphics: t2 }, i2 = () => A(this.pendingAdds, o2);
    s2.promise.then(i2, i2), this.pendingAdds.push(o2);
  }
  _markLoadedSpatialReferences(e2) {
    for (const t2 of e2)
      null != t2.wkid && this.loadedWkids.add(t2.wkid), null != t2.wkt && this.loadedWkts.add(t2.wkt);
  }
  _add(e2) {
    if (t(e2.geometry) || !e2.visible)
      return;
    let t2 = e2.geometry;
    if ("mesh" === t2.type)
      return;
    "extent" === t2.type && (t2 = v.fromExtent(t2));
    const r3 = this._ensureSource(t2.type);
    if (t(r3))
      return;
    const s2 = this._createOptimizedFeature(e2.uid, t2);
    r(s2) && r3.featureStore.add(s2);
  }
  _needsInitializeProjection(e2) {
    return (null == e2.wkid || !this.loadedWkids.has(e2.wkid)) && ((null == e2.wkt || !this.loadedWkts.has(e2.wkt)) && !An(e2, this.spatialReference));
  }
  _createOptimizedFeature(e2, t2) {
    const r3 = rn(f(t2), this.spatialReference);
    return r3 ? new s(te(r3, false, false), { [k]: e2 }, null, e2) : null;
  }
  _ensureSource(e2) {
    const t2 = this.sources[e2];
    if (r(t2))
      return t2;
    const r3 = this._createSource(e2);
    return this.sources[e2] = r3, r3;
  }
  _createSource(e2) {
    const t2 = i.toJSON(e2), r3 = new u({ geometryType: t2, hasZ: false, hasM: false });
    return { featureStore: r3, queryEngine: new Y({ featureStore: r3, fields: [{ name: k, type: "esriFieldTypeOID", alias: k }], geometryType: t2, hasM: false, hasZ: false, objectIdField: k, spatialReference: this.spatialReference, scheduler: r(this.view) && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e2 };
  }
  _remove(e2) {
    this._mapSources((t2) => this._removeFromSource(t2, e2));
    for (const t2 of this.pendingAdds)
      t2.graphics.delete(e2.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e2, t2) {
    const r3 = t2.uid;
    e2.featureStore.has(r3) && e2.featureStore.removeById(t2.uid);
  }
  _destroySource(e2) {
    e2.queryEngine.destroy(), this.sources[e2.type] = null;
  }
  _mapSources(e2) {
    const { point: t2, polygon: r3, polyline: s2, multipoint: i2 } = this.sources, a2 = [];
    return r(t2) && a2.push(e2(t2)), r(r3) && a2.push(e2(r3)), r(s2) && a2.push(e2(s2)), r(i2) && a2.push(e2(i2)), a2;
  }
};
e([d({ constructOnly: true })], w.prototype, "spatialReference", void 0), e([d({ constructOnly: true })], w.prototype, "layerSource", void 0), e([d({ constructOnly: true })], w.prototype, "view", void 0), e([d({ readOnly: true })], w.prototype, "updating", null), e([d({ readOnly: true })], w.prototype, "availability", void 0), w = e([n("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], w);
var k = "OBJECTID";
export {
  w as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-GVCMVEN3.js.map
