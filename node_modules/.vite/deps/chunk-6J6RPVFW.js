import {
  v as v2
} from "./chunk-DYETG5YB.js";
import {
  G2 as G,
  N,
  p
} from "./chunk-RN2KRYDN.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  R,
  j,
  j2
} from "./chunk-YPZEGNLG.js";
import {
  r
} from "./chunk-3NMRL5CR.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";

// node_modules/@arcgis/core/geometry/Circle.js
var d2;
var h = d2 = class extends v {
  constructor(...e2) {
    super(...e2), this.center = null, this.geodesic = false, this.numberOfPoints = 60, this.radius = 1e3, this.radiusUnit = "meters";
  }
  normalizeCtorArgs(e2, r2) {
    let t;
    if (e2 && e2.center)
      t = e2;
    else {
      if (e2 && e2.rings)
        return super.normalizeCtorArgs(e2, r2);
      t = { center: e2 };
    }
    return { ...super.normalizeCtorArgs(), ...t, ...r2 };
  }
  initialize() {
    const e2 = this.center, s = this.numberOfPoints;
    if (this.hasZ = e2 && e2.hasZ, 0 !== this.rings.length || !e2)
      return;
    const i = N(this.radius, this.radiusUnit, "meters"), o = e2.spatialReference;
    let c, a = "geographic";
    if (o.isWebMercator ? a = "webMercator" : (null != r[o.wkid] || o.wkt && 0 === o.wkt.indexOf("PROJCS")) && (a = "projected"), this.geodesic) {
      let r2;
      switch (a) {
        case "webMercator":
          r2 = j(e2);
          break;
        case "projected":
          console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");
          break;
        case "geographic":
          r2 = e2;
      }
      c = this._createGeodesicCircle(r2, i, s), "webMercator" === a && (c = R(c));
    } else {
      let r2;
      "webMercator" === a || "projected" === a ? r2 = i / this._convert2Meters(1, e2.spatialReference) : "geographic" === a && (r2 = G(i, "meters", p(e2.spatialReference).radius)), c = this._createPlanarCircle(e2, r2, s);
    }
    this.spatialReference = c.spatialReference, this.addRing(c.rings[0]);
  }
  clone() {
    const { center: e2, numberOfPoints: r2, radius: t, radiusUnit: s, geodesic: i } = this;
    return new d2({ center: e2.clone(), numberOfPoints: r2, radius: t, radiusUnit: s, geodesic: i });
  }
  _createGeodesicCircle(e2, r2, t) {
    let s = 0;
    const i = [];
    for (; s < 360; ) {
      const o = [0, 0], c = [e2.x, e2.y];
      v2(o, c, s, r2), this.hasZ && o.push(e2.z), i.push(o), s += 360 / t;
    }
    return i.push(i[0]), new v(i);
  }
  _createPlanarCircle(e2, r2, t) {
    const s = [], i = 2 * Math.PI / t;
    for (let o = 0; o < t; ++o) {
      const t2 = i * o, c = [e2.x + Math.cos(-t2) * r2, e2.y + Math.sin(-t2) * r2];
      this.hasZ && c.push(e2.z), s.push(c);
    }
    return s.push(s[0]), new v({ spatialReference: e2.spatialReference, rings: [s] });
  }
  _convert2Meters(e2, r2) {
    let t;
    if (null != r[r2.wkid])
      t = r.values[r[r2.wkid]];
    else {
      const e3 = r2.wkt, s = e3.lastIndexOf(",") + 1, i = e3.lastIndexOf("]]");
      t = parseFloat(e3.substring(s, i));
    }
    return e2 * t;
  }
};
e([d({ type: j2 })], h.prototype, "center", void 0), e([d()], h.prototype, "geodesic", void 0), e([d()], h.prototype, "numberOfPoints", void 0), e([d()], h.prototype, "radius", void 0), e([d()], h.prototype, "radiusUnit", void 0), h = d2 = e([n("esri.geometry.Circle")], h);
var m = h;

export {
  m
};
//# sourceMappingURL=chunk-6J6RPVFW.js.map
