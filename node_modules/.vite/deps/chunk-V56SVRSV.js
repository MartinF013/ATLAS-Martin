import {
  f,
  g
} from "./chunk-XZHFGTRH.js";
import {
  C,
  G,
  L,
  _,
  fe,
  ie,
  ye
} from "./chunk-6SWQ7R36.js";
import {
  t as t2
} from "./chunk-OZT6RDST.js";
import {
  L as L2
} from "./chunk-4I3W4KD5.js";
import {
  Z
} from "./chunk-RN2KRYDN.js";
import {
  d
} from "./chunk-4PRVTUEZ.js";
import {
  s
} from "./chunk-DMJWTK32.js";
import {
  l3 as l
} from "./chunk-VLCG72SW.js";
import {
  c,
  k,
  o
} from "./chunk-3NMRL5CR.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/graphics/data/utils.js
var j = new s({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
var U = Object.freeze({});
var M = new t2();
var F = new t2();
var G2 = new t2();
var N = { esriGeometryPoint: G, esriGeometryPolyline: L, esriGeometryPolygon: C, esriGeometryMultipoint: _ };
function O(e2, r2, i, o2 = e2.hasZ, n = e2.hasM) {
  if (t(r2))
    return null;
  const s2 = e2.hasZ && o2, l2 = e2.hasM && n;
  if (i) {
    const t3 = ie(G2, r2, e2.hasZ, e2.hasM, "esriGeometryPoint", i, o2, n);
    return G(t3, s2, l2);
  }
  return G(r2, s2, l2);
}
function J(e2, i, o2, n, s2, l2, a = i, m = o2) {
  const c2 = i && a, f2 = o2 && m, g2 = r(n) ? "coords" in n ? n : n.geometry : null;
  if (t(g2))
    return null;
  if (s2) {
    let t3 = fe(F, g2, i, o2, e2, s2, a, m);
    return l2 && (t3 = ie(G2, t3, c2, f2, e2, l2)), N[e2](t3, c2, f2);
  }
  if (l2) {
    const t3 = ie(G2, g2, i, o2, e2, l2, a, m);
    return N[e2](t3, c2, f2);
  }
  return ye(M, g2, i, o2, a, m), N[e2](M, c2, f2);
}
async function P(e2, t3, r2) {
  const { outFields: i, orderByFields: o2, groupByFieldsForStatistics: n, outStatistics: s2 } = e2;
  if (i)
    for (let l2 = 0; l2 < i.length; l2++)
      i[l2] = i[l2].trim();
  if (o2)
    for (let l2 = 0; l2 < o2.length; l2++)
      o2[l2] = o2[l2].trim();
  if (n)
    for (let l2 = 0; l2 < n.length; l2++)
      n[l2] = n[l2].trim();
  if (s2)
    for (let l2 = 0; l2 < s2.length; l2++)
      s2[l2].onStatisticField && (s2[l2].onStatisticField = s2[l2].onStatisticField.trim());
  return e2.geometry && !e2.outSR && (e2.outSR = e2.geometry.spatialReference), v(e2, t3, r2);
}
async function v(e2, r2, i) {
  if (!e2)
    return null;
  let { where: l2 } = e2;
  if (e2.where = l2 = l2 && l2.trim(), (!l2 || /^1 *= *1$/.test(l2) || r2 && r2 === l2) && (e2.where = null), !e2.geometry)
    return e2;
  let a = await Z2(e2);
  if (e2.distance = 0, e2.units = null, "esriSpatialRelEnvelopeIntersects" === e2.spatialRel) {
    const { spatialReference: t3 } = e2.geometry;
    a = l(a), a.spatialReference = t3;
  }
  e2.geometry = a, await f(a.spatialReference, i);
  const m = (await L2(d(a)))[0];
  if (t(m))
    throw U;
  const c2 = m.toJSON(), u = await g(c2, c2.spatialReference, i);
  if (!u)
    throw U;
  return u.spatialReference = i, e2.geometry = u, e2;
}
async function Z2(e2) {
  const { geometry: t3, distance: r2, units: o2 } = e2;
  if (null == r2 || "vertexAttributes" in t3)
    return t3;
  const n = t3.spatialReference, s2 = o2 ? j.fromJSON(o2) : Z(n), c2 = n && (o(n) || k(n)) ? t3 : await f(n, c).then(() => g(t3, c));
  return (await b())(c2.spatialReference, c2, r2, s2);
}
async function b() {
  return (await import("./geometryEngineJSON-Y4CNF4IY.js")).geodesicBuffer;
}
function x(e2) {
  return e2 && z in e2 ? JSON.parse(JSON.stringify(e2, B)) : e2;
}
var z = "_geVersion";
var B = (e2, t3) => e2 !== z ? t3 : void 0;

export {
  U,
  O,
  J,
  P,
  v,
  x
};
//# sourceMappingURL=chunk-V56SVRSV.js.map
