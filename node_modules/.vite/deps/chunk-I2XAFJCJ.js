import {
  i,
  u
} from "./chunk-YRAX326I.js";
import {
  s
} from "./chunk-DMJWTK32.js";
import {
  M as M2
} from "./chunk-BPZGJQOB.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  R
} from "./chunk-3NMRL5CR.js";
import {
  f
} from "./chunk-U3PSONS6.js";
import {
  s as s2
} from "./chunk-CVWDM4C7.js";
import {
  a,
  e,
  r,
  t,
  t2
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/vectorFieldUtils.js
var a2 = /* @__PURE__ */ new Map();
a2.set("meter-per-second", 1), a2.set("kilometer-per-hour", 0.277778), a2.set("knots", 0.514444), a2.set("feet-per-second", 0.3048), a2.set("mile-per-hour", 0.44704);
var s3 = 180 / Math.PI;
var i2 = 5;
var h = new s({ esriMetersPerSecond: "meter-per-second", esriKilometersPerHour: "kilometer-per-hour", esriKnots: "knots", esriFeetPerSecond: "feet-per-second", esriMilesPerHour: "mile-per-hour" });
function l(t3, e2) {
  return a2.get(t3) / a2.get(e2) || 1;
}
function c(t3) {
  return (450 - t3) % 360;
}
function u2(t3, e2 = "geographic") {
  const [n, r2] = t3, o = Math.sqrt(n * n + r2 * r2);
  let a3 = Math.atan2(r2, n) * s3;
  return a3 = (360 + a3) % 360, "geographic" === e2 && (a3 = c(a3)), [o, a3];
}
function f2(t3, e2 = "geographic") {
  let n = t3[1];
  "geographic" === e2 && (n = c(n)), n %= 360;
  const r2 = t3[0];
  return [r2 * Math.cos(n / s3), r2 * Math.sin(n / s3)];
}
function p(t3, r2, a3, s4 = "geographic") {
  if (!i(t3) || t(a3))
    return t3;
  const i3 = "vector-magdir" === r2 ? t3.clone() : e(m(t3, r2)), h3 = i3.pixels[1];
  for (let e2 = 0; e2 < h3.length; e2++)
    h3[e2] = "geographic" === s4 ? (h3[e2] + a3[e2] + 270) % 360 : (h3[e2] + 360 - a3[e2]) % 360;
  return "vector-magdir" === r2 ? i3 : m(i3, "vector-magdir");
}
function m(t3, e2, n = "geographic", a3 = 1) {
  if (!i(t3))
    return t3;
  const { pixels: s4, width: i3, height: h3 } = t3, l2 = i3 * h3, c3 = s4[0], p3 = s4[1], m3 = t3.pixelType.startsWith("f") ? t3.pixelType : "f32", d3 = u.createEmptyBand(m3, l2), M5 = u.createEmptyBand(m3, l2);
  let g3 = 0;
  for (let r2 = 0; r2 < h3; r2++)
    for (let t4 = 0; t4 < i3; t4++)
      "vector-uv" === e2 ? ([d3[g3], M5[g3]] = u2([c3[g3], p3[g3]], n), d3[g3] *= a3) : ([d3[g3], M5[g3]] = f2([c3[g3], p3[g3]], n), d3[g3] *= a3, M5[g3] *= a3), g3++;
  const x3 = new u({ pixelType: m3, width: t3.width, height: t3.height, mask: t3.mask, validPixelCount: t3.validPixelCount, maskIsAlpha: t3.maskIsAlpha, pixels: [d3, M5] });
  return x3.updateStatistics(), x3;
}
function d(t3, e2, n = 1) {
  if (1 === n || !i(t3))
    return t3;
  const r2 = t3.clone(), { pixels: a3, width: s4, height: i3 } = r2, h3 = a3[0], l2 = a3[1];
  let c3 = 0;
  for (let o = 0; o < i3; o++)
    for (let t4 = 0; t4 < s4; t4++)
      "vector-uv" === e2 ? (h3[c3] *= n, l2[c3] *= n) : h3[c3] *= n, c3++;
  return r2.updateStatistics(), r2;
}
function M3(t3, n, r2, o, a3) {
  if (t(a3) || !a3.spatialReference.equals(t3.spatialReference))
    return { extent: t3, width: Math.round(n / o), height: Math.round(r2 / o), resolution: t3.width / n };
  const s4 = a3.xmin, i3 = a3.ymax, h3 = (t3.xmax - t3.xmin) / n * o, l2 = (t3.ymax - t3.ymin) / r2 * o, c3 = (h3 + l2) / 2;
  return t3.xmin = s4 + Math.floor((t3.xmin - s4) / h3) * h3, t3.xmax = s4 + Math.ceil((t3.xmax - s4) / h3) * h3, t3.ymin = i3 + Math.floor((t3.ymin - i3) / l2) * l2, t3.ymax = i3 + Math.ceil((t3.ymax - i3) / l2) * l2, { extent: t3, width: Math.round(t3.width / h3), height: Math.round(t3.height / l2), resolution: c3 };
}
var g = x(0, 0, 0);
function x(t3 = 0, e2 = 0, n = Math.PI, r2 = true) {
  r2 && (n = (2 * Math.PI - n) % (2 * Math.PI));
  const o = r2 ? -1 : 1, a3 = 13 * o, s4 = -7 * o, i3 = -2 * o, h3 = -16 * o, l2 = 21.75, [c3, u4] = w(0, e2 + a3, n, l2), [f4, p3] = w(t3 - 5.5, e2 + s4, n, l2), [m3, d3] = w(t3 + 5.5, e2 + s4, n, l2), [M5, g3] = w(t3 - 1.5, e2 + i3, n, l2), [x3, k2] = w(t3 + 1.5, e2 + i3, n, l2), [y3, P2] = w(t3 - 1.5, e2 + h3, n, l2), [b2, I2] = w(t3 + 1.5, e2 + h3, n, l2);
  return [c3, u4, f4, p3, M5, g3, x3, k2, m3, d3, y3, P2, b2, I2];
}
function k(t3 = 0, e2 = Math.PI, n = true) {
  n && (e2 = (2 * Math.PI - e2) % (2 * Math.PI));
  const r2 = 10, o = n ? -1 : 1, a3 = 5 * o, s4 = 20 * o, h3 = 25 * o, l2 = 45, c3 = 0, u4 = 0, f4 = 2, p3 = 0, m3 = f4 * o;
  let [d3, M5] = [c3 + r2 / 2, u4 - s4], [g3, x3] = [d3 + f4, M5], [k2, y3] = [g3 - p3, x3 + m3], [P2, b2] = [c3 - r2 / 2, u4 - h3], [I2, v2] = [P2 + p3, b2 - m3], A3 = Math.ceil(t3 / i2), _2 = Math.floor(A3 / 10);
  A3 -= 8 * _2;
  const U2 = [], S2 = [];
  for (let i3 = 0; i3 < A3 / 2; i3++, _2--) {
    _2 <= 0 && A3 % 2 == 1 && i3 === (A3 - 1) / 2 && (P2 = c3, I2 = P2 + p3, b2 = (b2 + M5) / 2, v2 = b2 - m3);
    const [t4, n2] = w(P2, b2, e2, l2);
    if (_2 > 0) {
      const [r3, o2] = w(g3, b2, e2, l2), [a4, s5] = w(d3, M5, e2, l2);
      U2.push(r3), U2.push(o2), U2.push(t4), U2.push(n2), U2.push(a4), U2.push(s5);
    } else {
      const [r3, o2] = w(g3, x3, e2, l2), [a4, s5] = w(k2, y3, e2, l2), [i4, h4] = w(I2, v2, e2, l2);
      S2.push(t4), S2.push(n2), S2.push(i4), S2.push(h4), S2.push(a4), S2.push(s5), S2.push(r3), S2.push(o2);
    }
    b2 += a3, M5 += a3, x3 += a3, y3 += a3, v2 += a3;
  }
  const [D2, F2] = w(c3 + r2 / 2, u4 + s4, e2, l2), j = r2 / 2 + f4, [N, J] = w(c3 + j, u4 + s4, e2, l2), [O, q] = w(c3 + r2 / 2, u4 - h3, e2, l2), [B, E] = w(c3 + j, u4 - h3, e2, l2);
  return { pennants: U2, barbs: S2, shaft: [D2, F2, N, J, O, q, B, E] };
}
function w(t3, e2, n, r2 = 1) {
  const o = Math.sqrt(t3 * t3 + e2 * e2) / r2, a3 = (2 * Math.PI + Math.atan2(e2, t3)) % (2 * Math.PI);
  return [o, (2 * Math.PI + a3 - n) % (2 * Math.PI)];
}
var y = [0, 1, 3, 6, 10, 16, 21, 27, 33, 40, 47, 55, 63];
var P = [0, 0.5, 1, 1.5, 2];
var b = [0, 0.25, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4];
function I(t3, e2, n, r2) {
  const o = l(r2 || "knots", n);
  let a3;
  for (a3 = 1; a3 < e2.length; a3++)
    if (a3 === e2.length - 1) {
      if (t3 < e2[a3] * o)
        break;
    } else if (t3 <= e2[a3] * o)
      break;
  return Math.min(a3 - 1, e2.length - 2);
}
function v(t3, e2, n, r2, o) {
  let a3 = 0;
  switch (e2) {
    case "beaufort_kn":
      a3 = I(t3, y, "knots", n);
      break;
    case "beaufort_km":
      a3 = I(t3, y, "kilometer-per-hour", n);
      break;
    case "beaufort_ft":
      a3 = I(t3, y, "feet-per-second", n);
      break;
    case "beaufort_m":
      a3 = I(t3, y, "meter-per-second", n);
      break;
    case "classified_arrow":
      a3 = I(t3, o, r2, n);
      break;
    case "ocean_current_m":
      a3 = I(t3, P, "meter-per-second", n);
      break;
    case "ocean_current_kn":
      a3 = I(t3, b, "knots", n);
  }
  return a3;
}
function A(t3, e2) {
  const { style: n, inputUnit: r2, outputUnit: o, breakValues: a3 } = e2, s4 = h.fromJSON(r2), i3 = h.fromJSON(o), l2 = 7 * 6, c3 = 15;
  let u4 = 0, f4 = 0;
  const { width: p3, height: m3, mask: d3 } = t3, M5 = t3.pixels[0], x3 = t3.pixels[1], k2 = d3 ? d3.filter((t4) => t4 > 0).length : p3 * m3, w3 = new Float32Array(k2 * l2), y3 = new Uint32Array(c3 * k2);
  for (let h3 = 0; h3 < m3; h3++)
    for (let t4 = 0; t4 < p3; t4++) {
      const e3 = h3 * p3 + t4;
      if (!d3 || d3[h3 * p3 + t4]) {
        const r3 = (x3[e3] + 360) % 360 / 180 * Math.PI, o2 = v(M5[e3], n, s4, i3, a3);
        for (let n2 = 0; n2 < g.length; n2 += 2)
          w3[u4++] = (t4 + 0.5) / p3, w3[u4++] = (h3 + 0.5) / m3, w3[u4++] = g[n2], w3[u4++] = g[n2 + 1] + r3, w3[u4++] = o2, w3[u4++] = M5[e3];
        const c4 = 7 * (u4 / l2 - 1);
        y3[f4++] = c4, y3[f4++] = c4 + 1, y3[f4++] = c4 + 2, y3[f4++] = c4 + 0, y3[f4++] = c4 + 4, y3[f4++] = c4 + 3, y3[f4++] = c4 + 0, y3[f4++] = c4 + 2, y3[f4++] = c4 + 3, y3[f4++] = c4 + 2, y3[f4++] = c4 + 5, y3[f4++] = c4 + 3, y3[f4++] = c4 + 5, y3[f4++] = c4 + 6, y3[f4++] = c4 + 3;
      }
    }
  return { vertexData: w3, indexData: y3 };
}
var _ = [];
function U(t3, e2) {
  if (0 === _.length)
    for (let i3 = 0; i3 < 30; i3++)
      _.push(k(5 * i3, 0));
  const n = l(h.fromJSON(e2.inputUnit), "knots"), { width: r2, height: o, mask: a3 } = t3, s4 = t3.pixels[0], c3 = t3.pixels[1], u4 = 6, f4 = [], p3 = [];
  let m3 = 0, d3 = 0;
  for (let h3 = 0; h3 < o; h3++)
    for (let t4 = 0; t4 < r2; t4++) {
      const e3 = h3 * r2 + t4, l2 = s4[e3] * n;
      if ((!a3 || a3[h3 * r2 + t4]) && l2 >= i2) {
        const n2 = (c3[e3] + 360) % 360 / 180 * Math.PI, { pennants: a4, barbs: s5, shaft: i3 } = _[Math.min(Math.floor(l2 / 5), 29)];
        if (a4.length + s5.length === 0)
          continue;
        let M5 = f4.length / u4;
        const g3 = (t4 + 0.5) / r2, x3 = (h3 + 0.5) / o;
        for (let t5 = 0; t5 < a4.length; t5 += 2)
          f4[m3++] = g3, f4[m3++] = x3, f4[m3++] = a4[t5], f4[m3++] = a4[t5 + 1] + n2, f4[m3++] = 0, f4[m3++] = l2;
        for (let t5 = 0; t5 < s5.length; t5 += 2)
          f4[m3++] = g3, f4[m3++] = x3, f4[m3++] = s5[t5], f4[m3++] = s5[t5 + 1] + n2, f4[m3++] = 0, f4[m3++] = l2;
        for (let t5 = 0; t5 < i3.length; t5 += 2)
          f4[m3++] = g3, f4[m3++] = x3, f4[m3++] = i3[t5], f4[m3++] = i3[t5 + 1] + n2, f4[m3++] = 0, f4[m3++] = l2;
        for (let t5 = 0; t5 < a4.length / 6; t5++)
          p3[d3++] = M5, p3[d3++] = M5 + 1, p3[d3++] = M5 + 2, M5 += 3;
        for (let t5 = 0; t5 < s5.length / 8; t5++)
          p3[d3++] = M5, p3[d3++] = M5 + 1, p3[d3++] = M5 + 2, p3[d3++] = M5 + 1, p3[d3++] = M5 + 2, p3[d3++] = M5 + 3, M5 += 4;
        p3[d3++] = M5 + 0, p3[d3++] = M5 + 1, p3[d3++] = M5 + 2, p3[d3++] = M5 + 1, p3[d3++] = M5 + 3, p3[d3++] = M5 + 2, M5 += 4;
      }
    }
  return { vertexData: new Float32Array(f4), indexData: new Uint32Array(p3) };
}
function S(t3, e2) {
  const n = 4 * 6;
  let r2 = 0, o = 0;
  const { width: a3, height: s4, mask: c3 } = t3, u4 = t3.pixels[0], f4 = [], p3 = [], m3 = l(h.fromJSON(e2.inputUnit), "knots"), d3 = "wind_speed" === e2.style ? i2 : Number.MAX_VALUE;
  for (let i3 = 0; i3 < s4; i3++)
    for (let t4 = 0; t4 < a3; t4++) {
      const e3 = u4[i3 * a3 + t4] * m3;
      if ((!c3 || c3[i3 * a3 + t4]) && e3 < d3) {
        for (let n2 = 0; n2 < 4; n2++)
          f4[r2++] = (t4 + 0.5) / a3, f4[r2++] = (i3 + 0.5) / s4, f4[r2++] = n2 < 2 ? -0.5 : 0.5, f4[r2++] = n2 % 2 == 0 ? -0.5 : 0.5, f4[r2++] = 0, f4[r2++] = e3;
        const h3 = 4 * (r2 / n - 1);
        p3[o++] = h3, p3[o++] = h3 + 1, p3[o++] = h3 + 2, p3[o++] = h3 + 1, p3[o++] = h3 + 2, p3[o++] = h3 + 3;
      }
    }
  return { vertexData: new Float32Array(f4), indexData: new Uint32Array(p3) };
}
function D(t3, e2) {
  return "simple_scalar" === e2.style ? S(t3, e2) : "wind_speed" === e2.style ? U(t3, e2) : A(t3, e2);
}
function F(t3, e2, n, o = [0, 0], a3 = 0.5) {
  const { width: s4, height: i3, mask: h3 } = t3, [l2, c3] = t3.pixels, [p3, m3] = o, d3 = Math.round((s4 - p3) / n), M5 = Math.round((i3 - m3) / n), g3 = d3 * M5, x3 = new Float32Array(g3), k2 = new Float32Array(g3), w3 = new Uint8Array(g3), y3 = "vector-uv" === e2;
  for (let r2 = 0; r2 < M5; r2++)
    for (let t4 = 0; t4 < d3; t4++) {
      let e3 = 0;
      const o2 = r2 * d3 + t4, M6 = Math.max(0, r2 * n + m3), g4 = Math.max(0, t4 * n + p3), P3 = Math.min(i3, M6 + n), b2 = Math.min(s4, g4 + n);
      for (let t5 = M6; t5 < P3; t5++)
        for (let n2 = g4; n2 < b2; n2++) {
          const r3 = t5 * s4 + n2;
          if (!h3 || h3[r3]) {
            e3++;
            const t6 = y3 ? [l2[r3], c3[r3]] : [l2[r3], (360 + c3[r3]) % 360], [n3, a4] = y3 ? t6 : f2(t6);
            x3[o2] += n3, k2[o2] += a4;
          }
        }
      if (e3 >= (P3 - M6) * (b2 - g4) * (1 - a3)) {
        w3[o2] = 1;
        const [t5, n2] = u2([x3[o2] / e3, k2[o2] / e3]);
        x3[o2] = t5, k2[o2] = n2;
      } else
        w3[o2] = 0, x3[o2] = 0, k2[o2] = 0;
    }
  const P2 = new u({ width: d3, height: M5, pixels: [x3, k2], mask: w3 });
  return P2.updateStatistics(), P2;
}

// node_modules/@arcgis/core/views/2d/engine/flow/dataUtils.js
var c2 = s2.getLogger("esri.views.2d.engine.flow.dataUtils");
var f3 = 10;
async function u3(e2, n, r2, o) {
  const l2 = performance.now(), a3 = h2(n, r2), s4 = performance.now(), u4 = d2(n, a3, r2.width, r2.height), m3 = performance.now(), w3 = p2(u4, true), x3 = performance.now(), M5 = "Streamlines" === e2 ? g2(w3, f3) : y2(w3), A3 = performance.now();
  return a("esri-2d-profiler") && (c2.info("I.1", "_createFlowFieldFromData (ms)", Math.round(s4 - l2)), c2.info("I.2", "_getStreamlines (ms)", Math.round(m3 - s4)), c2.info("I.3", "createAnimatedLinesData (ms)", Math.round(x3 - m3)), c2.info("I.4", "create{Streamlines|Particles}Mesh (ms)", Math.round(A3 - x3)), c2.info("I.5", "createFlowMesh (ms)", Math.round(A3 - l2)), c2.info("I.6", "Mesh size (bytes)", M5.vertexData.buffer.byteLength + M5.indexData.buffer.byteLength)), await Promise.resolve(), f(o), M5;
}
function h2(t3, e2) {
  const n = w2(e2.data, e2.width, e2.height, t3.smoothing);
  if (t3.interpolate) {
    return (t4, r2) => {
      const o = Math.floor(t4), i3 = Math.floor(r2);
      if (o < 0 || o >= e2.width)
        return [0, 0];
      if (i3 < 0 || i3 >= e2.height)
        return [0, 0];
      const l2 = t4 - o, a3 = r2 - i3, s4 = o, c3 = i3, f4 = o < e2.width - 1 ? o + 1 : o, u4 = i3 < e2.height - 1 ? i3 + 1 : i3, h3 = n[2 * (c3 * e2.width + s4)], m3 = n[2 * (c3 * e2.width + f4)], d3 = n[2 * (u4 * e2.width + s4)], w3 = n[2 * (u4 * e2.width + f4)], p3 = n[2 * (c3 * e2.width + s4) + 1], g3 = n[2 * (c3 * e2.width + f4) + 1];
      return [(h3 * (1 - a3) + d3 * a3) * (1 - l2) + (m3 * (1 - a3) + w3 * a3) * l2, (p3 * (1 - a3) + n[2 * (u4 * e2.width + s4) + 1] * a3) * (1 - l2) + (g3 * (1 - a3) + n[2 * (u4 * e2.width + f4) + 1] * a3) * l2];
    };
  }
  return (t4, r2) => {
    const o = Math.round(t4), i3 = Math.round(r2);
    return o < 0 || o >= e2.width || i3 < 0 || i3 >= e2.height ? [0, 0] : [n[2 * (i3 * e2.width + o) + 0], n[2 * (i3 * e2.width + o) + 1]];
  };
}
function m2(t3, e2, n, r2, o, i3, l2, a3, s4) {
  const c3 = [];
  let f4 = n, u4 = r2, h3 = 0, [m3, d3] = e2(f4, u4);
  m3 *= t3.velocityScale, d3 *= t3.velocityScale;
  const w3 = Math.sqrt(m3 * m3 + d3 * d3);
  let p3, g3;
  c3.push({ x: f4, y: u4, t: h3, speed: w3 });
  for (let y3 = 0; y3 < t3.verticesPerLine; y3++) {
    let [n2, r3] = e2(f4, u4);
    n2 *= t3.velocityScale, r3 *= t3.velocityScale;
    const m4 = Math.sqrt(n2 * n2 + r3 * r3);
    if (m4 < t3.minSpeedThreshold)
      return c3;
    const d4 = n2 / m4, w4 = r3 / m4;
    f4 += d4 * t3.segmentLength, u4 += w4 * t3.segmentLength;
    if (h3 += t3.segmentLength / m4, Math.acos(d4 * p3 + w4 * g3) > t3.maxTurnAngle)
      return c3;
    if (t3.collisions) {
      const t4 = Math.round(f4 * s4), e3 = Math.round(u4 * s4);
      if (t4 < 0 || t4 > l2 - 1 || e3 < 0 || e3 > a3 - 1)
        return c3;
      const n3 = i3[e3 * l2 + t4];
      if (-1 !== n3 && n3 !== o)
        return c3;
      i3[e3 * l2 + t4] = o;
    }
    c3.push({ x: f4, y: u4, t: h3, speed: m4 }), p3 = d4, g3 = w4;
  }
  return c3;
}
function d2(t3, e2, n, r2) {
  const o = [], i3 = new t2(), a3 = 1 / Math.max(t3.lineCollisionWidth, 1), s4 = Math.round(n * a3), c3 = Math.round(r2 * a3), f4 = new Int32Array(s4 * c3);
  for (let l2 = 0; l2 < f4.length; l2++)
    f4[l2] = -1;
  const u4 = [];
  for (let l2 = 0; l2 < r2; l2 += t3.lineSpacing)
    for (let e3 = 0; e3 < n; e3 += t3.lineSpacing)
      u4.push({ x: e3, y: l2, sort: i3.getFloat() });
  u4.sort((t4, e3) => t4.sort - e3.sort);
  for (const { x: l2, y: h3 } of u4)
    if (i3.getFloat() < t3.density) {
      const n2 = m2(t3, e2, l2, h3, o.length, f4, s4, c3, a3);
      if (n2.length < 2)
        continue;
      o.push(n2);
    }
  return o;
}
function w2(t3, e2, n, r2) {
  if (0 === r2)
    return t3;
  const o = Math.round(3 * r2), i3 = new Array(2 * o + 1);
  let l2 = 0;
  for (let c3 = -o; c3 <= o; c3++) {
    const t4 = Math.exp(-c3 * c3 / (r2 * r2));
    i3[c3 + o] = t4, l2 += t4;
  }
  for (let c3 = -o; c3 <= o; c3++)
    i3[c3 + o] /= l2;
  const a3 = new Float32Array(t3.length);
  for (let c3 = 0; c3 < n; c3++)
    for (let n2 = 0; n2 < e2; n2++) {
      let r3 = 0, l3 = 0;
      for (let a4 = -o; a4 <= o; a4++) {
        if (n2 + a4 < 0 || n2 + a4 >= e2)
          continue;
        const s5 = i3[a4 + o];
        r3 += s5 * t3[2 * (c3 * e2 + (n2 + a4)) + 0], l3 += s5 * t3[2 * (c3 * e2 + (n2 + a4)) + 1];
      }
      a3[2 * (c3 * e2 + n2) + 0] = r3, a3[2 * (c3 * e2 + n2) + 1] = l3;
    }
  const s4 = new Float32Array(t3.length);
  for (let c3 = 0; c3 < e2; c3++)
    for (let t4 = 0; t4 < n; t4++) {
      let r3 = 0, l3 = 0;
      for (let s5 = -o; s5 <= o; s5++) {
        if (t4 + s5 < 0 || t4 + s5 >= n)
          continue;
        const f4 = i3[s5 + o];
        r3 += f4 * a3[2 * ((t4 + s5) * e2 + c3) + 0], l3 += f4 * a3[2 * ((t4 + s5) * e2 + c3) + 1];
      }
      s4[2 * (t4 * e2 + c3) + 0] = r3, s4[2 * (t4 * e2 + c3) + 1] = l3;
    }
  return s4;
}
function p2(t3, e2) {
  const n = new t2(), r2 = t3.reduce((t4, e3) => t4 + e3.length, 0), o = new Float32Array(4 * r2), i3 = new Array(t3.length);
  let a3 = 0, s4 = 0;
  for (const l2 of t3) {
    const t4 = a3;
    for (const e3 of l2)
      o[4 * a3 + 0] = e3.x, o[4 * a3 + 1] = e3.y, o[4 * a3 + 2] = e3.t, o[4 * a3 + 3] = e3.speed, a3++;
    i3[s4++] = { startVertex: t4, numberOfVertices: l2.length, totalTime: l2[l2.length - 1].t, timeSeed: e2 ? n.getFloat() : 0 };
  }
  return { lineVertices: o, lineDescriptors: i3 };
}
function g2(t3, e2) {
  const n = 9, { lineVertices: r2, lineDescriptors: o } = t3;
  let i3 = 0, l2 = 0;
  for (const m3 of o) {
    i3 += 2 * m3.numberOfVertices;
    l2 += 6 * (m3.numberOfVertices - 1);
  }
  const a3 = new Float32Array(i3 * n), s4 = new Uint32Array(l2);
  let c3 = 0, f4 = 0;
  function u4() {
    s4[f4++] = c3 - 2, s4[f4++] = c3, s4[f4++] = c3 - 1, s4[f4++] = c3, s4[f4++] = c3 + 1, s4[f4++] = c3 - 1;
  }
  function h3(t4, e3, r3, o2, i4, l3, s5, f5) {
    const u5 = c3 * n;
    let h4 = 0;
    a3[u5 + h4++] = t4, a3[u5 + h4++] = e3, a3[u5 + h4++] = 1, a3[u5 + h4++] = r3, a3[u5 + h4++] = l3, a3[u5 + h4++] = s5, a3[u5 + h4++] = o2 / 2, a3[u5 + h4++] = i4 / 2, a3[u5 + h4++] = f5, c3++, a3[u5 + h4++] = t4, a3[u5 + h4++] = e3, a3[u5 + h4++] = -1, a3[u5 + h4++] = r3, a3[u5 + h4++] = l3, a3[u5 + h4++] = s5, a3[u5 + h4++] = -o2 / 2, a3[u5 + h4++] = -i4 / 2, a3[u5 + h4++] = f5, c3++;
  }
  for (const m3 of o) {
    const { totalTime: t4, timeSeed: n2 } = m3;
    let o2 = null, i4 = null, l3 = null, a4 = null, s5 = null, c4 = null;
    for (let f5 = 0; f5 < m3.numberOfVertices; f5++) {
      const d3 = r2[4 * (m3.startVertex + f5) + 0], w3 = r2[4 * (m3.startVertex + f5) + 1], p3 = r2[4 * (m3.startVertex + f5) + 2], g3 = r2[4 * (m3.startVertex + f5) + 3];
      let y3 = null, x3 = null, M5 = null, A3 = null;
      if (f5 > 0) {
        y3 = d3 - o2, x3 = w3 - i4;
        const r3 = Math.sqrt(y3 * y3 + x3 * x3);
        if (y3 /= r3, x3 /= r3, f5 > 1) {
          let t5 = y3 + s5, n3 = x3 + c4;
          const r4 = Math.sqrt(t5 * t5 + n3 * n3);
          t5 /= r4, n3 /= r4;
          const o3 = Math.min(1 / (t5 * y3 + n3 * x3), e2);
          t5 *= o3, n3 *= o3, M5 = -n3, A3 = t5;
        } else
          M5 = -x3, A3 = y3;
        null !== M5 && null !== A3 && (h3(o2, i4, l3, M5, A3, t4, n2, g3), u4());
      }
      o2 = d3, i4 = w3, l3 = p3, s5 = y3, c4 = x3, a4 = g3;
    }
    h3(o2, i4, l3, -c4, s5, t4, n2, a4);
  }
  return { vertexData: a3, indexData: s4 };
}
function y2(t3) {
  const e2 = 16, n = 1, r2 = 2, { lineVertices: o, lineDescriptors: i3 } = t3;
  let l2 = 0, a3 = 0;
  for (const j of i3) {
    const t4 = j.numberOfVertices - 1;
    l2 += 4 * t4 * 2, a3 += 6 * t4 * 2;
  }
  const s4 = new Float32Array(l2 * e2), c3 = new Uint32Array(a3);
  let f4, u4, h3, m3, d3, w3, p3, g3, y3, x3, M5, A3, I2, V, F2 = 0, D2 = 0;
  function b2() {
    c3[D2++] = F2 - 8, c3[D2++] = F2 - 7, c3[D2++] = F2 - 6, c3[D2++] = F2 - 7, c3[D2++] = F2 - 5, c3[D2++] = F2 - 6, c3[D2++] = F2 - 4, c3[D2++] = F2 - 3, c3[D2++] = F2 - 2, c3[D2++] = F2 - 3, c3[D2++] = F2 - 1, c3[D2++] = F2 - 2;
  }
  function v2(t4, o2, i4, l3, a4, c4, f5, u5, h4, m4, d4, w4, p4, g4) {
    const y4 = F2 * e2;
    let x4 = 0;
    for (const e3 of [n, r2])
      for (const n2 of [1, 2, 3, 4])
        s4[y4 + x4++] = t4, s4[y4 + x4++] = o2, s4[y4 + x4++] = i4, s4[y4 + x4++] = l3, s4[y4 + x4++] = f5, s4[y4 + x4++] = u5, s4[y4 + x4++] = h4, s4[y4 + x4++] = m4, s4[y4 + x4++] = e3, s4[y4 + x4++] = n2, s4[y4 + x4++] = p4, s4[y4 + x4++] = g4, s4[y4 + x4++] = a4 / 2, s4[y4 + x4++] = c4 / 2, s4[y4 + x4++] = d4 / 2, s4[y4 + x4++] = w4 / 2, F2++;
  }
  function S2(t4, e3) {
    let n2 = y3 + M5, r3 = x3 + A3;
    const o2 = Math.sqrt(n2 * n2 + r3 * r3);
    n2 /= o2, r3 /= o2;
    const i4 = y3 * n2 + x3 * r3;
    n2 /= i4, r3 /= i4;
    let l3 = M5 + I2, a4 = A3 + V;
    const s5 = Math.sqrt(l3 * l3 + a4 * a4);
    l3 /= s5, a4 /= s5;
    const c4 = M5 * l3 + A3 * a4;
    l3 /= c4, a4 /= c4, v2(f4, u4, h3, m3, -r3, n2, d3, w3, p3, g3, -a4, l3, t4, e3), b2();
  }
  function k2(t4, e3, n2, r3, o2, i4) {
    if (y3 = M5, x3 = A3, M5 = I2, A3 = V, null == y3 && null == x3 && (y3 = M5, x3 = A3), null != d3 && null != w3) {
      I2 = t4 - d3, V = e3 - w3;
      const n3 = Math.sqrt(I2 * I2 + V * V);
      I2 /= n3, V /= n3;
    }
    null != y3 && null != x3 && S2(o2, i4), f4 = d3, u4 = w3, h3 = p3, m3 = g3, d3 = t4, w3 = e3, p3 = n2, g3 = r3;
  }
  function L(t4, e3) {
    y3 = M5, x3 = A3, M5 = I2, A3 = V, null == y3 && null == x3 && (y3 = M5, x3 = A3), null != y3 && null != x3 && S2(t4, e3);
  }
  for (const j of i3) {
    f4 = null, u4 = null, h3 = null, m3 = null, d3 = null, w3 = null, p3 = null, g3 = null, y3 = null, x3 = null, M5 = null, A3 = null, I2 = null, V = null;
    const { totalTime: t4, timeSeed: e3 } = j;
    for (let n2 = 0; n2 < j.numberOfVertices; n2++) {
      k2(o[4 * (j.startVertex + n2) + 0], o[4 * (j.startVertex + n2) + 1], o[4 * (j.startVertex + n2) + 2], o[4 * (j.startVertex + n2) + 3], t4, e3);
    }
    L(t4, e3);
  }
  return { vertexData: s4, indexData: c3 };
}
function x2(t3, e2) {
  const r2 = e2.pixels, { width: o, height: i3 } = e2, l2 = new Float32Array(o * i3 * 2), a3 = e2.mask || new Uint8Array(o * i3 * 2);
  if (e2.mask || a3.fill(255), "vector-uv" === t3)
    for (let n = 0; n < o * i3; n++)
      l2[2 * n + 0] = r2[0][n], l2[2 * n + 1] = -r2[1][n];
  else if ("vector-magdir" === t3)
    for (let s4 = 0; s4 < o * i3; s4++) {
      const t4 = r2[0][s4], e3 = M2(r2[1][s4]), o2 = Math.cos(e3 - Math.PI / 2), i4 = Math.sin(e3 - Math.PI / 2);
      l2[2 * s4 + 0] = o2 * t4, l2[2 * s4 + 1] = i4 * t4;
    }
  return { data: l2, mask: a3, width: o, height: i3 };
}
async function M4(e2, n, r2, o, i3, l2) {
  const f4 = performance.now(), u4 = R(n.spatialReference);
  if (!u4) {
    const a3 = await A2(e2, n, r2, o, i3, l2);
    return a("esri-2d-profiler") && c2.info("I.7", "loadImagery, early exit (ms)", Math.round(performance.now() - f4)), a("esri-2d-profiler") && c2.info("I.9", "Number of parts", 1), a3;
  }
  const [h3, m3] = u4.valid, d3 = m3 - h3, w3 = Math.ceil(n.width / d3), p3 = n.width / w3, g3 = Math.round(r2 / w3);
  let y3 = n.xmin;
  const x3 = [], M5 = performance.now();
  for (let t3 = 0; t3 < w3; t3++) {
    const t4 = new M({ xmin: y3, xmax: y3 + p3, ymin: n.ymin, ymax: n.ymax, spatialReference: n.spatialReference });
    x3.push(A2(e2, t4, g3, o, i3, l2)), y3 += p3;
  }
  const I2 = await Promise.all(x3);
  a("esri-2d-profiler") && c2.info("I.8", "All calls to _fetchPart (ms)", Math.round(performance.now() - M5)), a("esri-2d-profiler") && c2.info("I.9", "Number of parts", I2.length);
  const V = { data: new Float32Array(r2 * o * 2), mask: new Uint8Array(r2 * o), width: r2, height: o };
  let F2 = 0;
  for (const t3 of I2) {
    for (let e3 = 0; e3 < t3.height; e3++)
      for (let n2 = 0; n2 < t3.width; n2++)
        F2 + n2 >= r2 || (V.data[2 * (e3 * r2 + F2 + n2) + 0] = t3.data[2 * (e3 * t3.width + n2) + 0], V.data[2 * (e3 * r2 + F2 + n2) + 1] = t3.data[2 * (e3 * t3.width + n2) + 1], V.mask[e3 * r2 + F2 + n2] = t3.mask[e3 * t3.width + n2]);
    F2 += t3.width;
  }
  return a("esri-2d-profiler") && c2.info("I.10", "loadImagery, general exit (ms)", Math.round(performance.now() - f4)), V;
}
async function A2(t3, e2, n, i3, l2, a3) {
  const s4 = { requestProjectedLocalDirections: true, signal: a3 };
  if (r(l2) && (s4.timeExtent = l2), "imagery" === t3.type) {
    await t3.load({ signal: a3 });
    const o = t3.rasterInfo.dataType, l3 = await t3.fetchImage(e2, n, i3, s4);
    return !l3 || t(l3.pixelData) || t(l3.pixelData.pixelBlock) ? { data: new Float32Array(n * i3 * 2), mask: new Uint8Array(n * i3), width: n, height: i3 } : x2(o, l3.pixelData.pixelBlock);
  }
  await t3.load({ signal: a3 });
  const c3 = t3.rasterInfo.dataType, f4 = await t3.fetchPixels(e2, n, i3, s4);
  return !f4 || t(f4.pixelBlock) ? { data: new Float32Array(n * i3 * 2), mask: new Uint8Array(n * i3), width: n, height: i3 } : x2(c3, f4.pixelBlock);
}

export {
  h,
  l,
  u2 as u,
  p,
  m,
  d,
  M3 as M,
  S,
  D,
  F,
  u3 as u2,
  M4 as M2
};
//# sourceMappingURL=chunk-I2XAFJCJ.js.map
