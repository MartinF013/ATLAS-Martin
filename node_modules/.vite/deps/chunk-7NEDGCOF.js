import {
  n as n6,
  x as x2
} from "./chunk-Z34NAJDO.js";
import {
  E,
  T,
  a as a2,
  a2 as a3,
  c as c2,
  f,
  f2,
  h,
  h2,
  i as i2,
  k as k3,
  l,
  n as n5,
  o,
  s as s3,
  t as t2,
  u
} from "./chunk-CEJQPREK.js";
import {
  e
} from "./chunk-U7LREOA7.js";
import {
  d as d2
} from "./chunk-3BCNCVBY.js";
import {
  c
} from "./chunk-7DMYZG6H.js";
import {
  m
} from "./chunk-X64NQ2GK.js";
import {
  n as n4,
  s as s2
} from "./chunk-MR6FXIW4.js";
import {
  D,
  F,
  S,
  Te,
  b,
  i2 as i,
  n,
  t3 as t
} from "./chunk-LBBA3SFR.js";
import {
  s
} from "./chunk-22YODLVL.js";
import {
  d as d4
} from "./chunk-TB42IUV7.js";
import {
  a
} from "./chunk-ZWMYDR2G.js";
import {
  se
} from "./chunk-6SWQ7R36.js";
import {
  Ke
} from "./chunk-7LOJJ46D.js";
import {
  d as d5
} from "./chunk-L2YBXQTH.js";
import {
  x
} from "./chunk-4XBERLPX.js";
import {
  n as n3
} from "./chunk-OXEYQYNR.js";
import {
  d as d3
} from "./chunk-FU5UMT3R.js";
import {
  b as b2,
  m as m2
} from "./chunk-GSFXXEAM.js";
import {
  y
} from "./chunk-WODSLTZT.js";
import {
  b as b3
} from "./chunk-P3QN5DXX.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import {
  B
} from "./chunk-Q3R7XFM5.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  n as n2
} from "./chunk-GVELBHGI.js";
import {
  d
} from "./chunk-4PRVTUEZ.js";
import {
  p
} from "./chunk-YPZEGNLG.js";
import {
  k2
} from "./chunk-3NMRL5CR.js";
import {
  k
} from "./chunk-U3PSONS6.js";

// node_modules/@arcgis/core/arcade/featureSetCollection.js
var e2 = class {
  constructor() {
    this.declaredRootClass = "esri.arcade.featureSetCollection", this._layerById = {}, this._layerByName = {};
  }
  add(e4, t4, a5) {
    this._layerById[t4] = a5, this._layerByName[e4] = a5;
  }
  async featureSetByName(e4, t4 = true, a5 = ["*"]) {
    return void 0 === this._layerByName[e4] ? null : this._layerByName[e4];
  }
  async featureSetById(e4, t4 = true, a5 = ["*"]) {
    return void 0 === this._layerById[e4] ? null : this._layerById[e4];
  }
  castToText() {
    return "object, FeatureSetCollection";
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/AttributeFilter.js
var h3 = class extends k3 {
  constructor(e4) {
    super(e4), this.declaredClass = "esri.arcade.featureset.actions.AttributeFilter", this._maxProcessing = 1e3, this._parent = e4.parentfeatureset, e4.whereclause instanceof m ? (this._whereclause = e4.whereclause, this._whereClauseFunction = null) : (this._whereClauseFunction = e4.whereclause, this._whereclause = null);
  }
  _initialiseFeatureSet() {
    null !== this._parent ? (this.fields = this._parent.fields.slice(0), this.geometryType = this._parent.geometryType, this.objectIdField = this._parent.objectIdField, this.globalIdField = this._parent.globalIdField, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = this._parent.typeIdField, this.types = this._parent.types) : (this.fields = [], this.typeIdField = "", this.objectIdField = "", this.globalIdField = "", this.spatialReference = new k2({ wkid: 4326 }), this.geometryType = S.point);
  }
  async _getSet(e4) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const s6 = await this._parent._getFilteredSet("", null, this._whereclause, null, e4);
      return this._checkCancelled(e4), null !== this._whereClauseFunction ? this._wset = new t2(s6._candidates.slice(0).concat(s6._known.slice(0)), [], s6._ordered, this._clonePageDefinition(s6.pagesDefinition)) : this._wset = new t2(s6._candidates.slice(0), s6._known.slice(0), s6._ordered, this._clonePageDefinition(s6.pagesDefinition)), this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet(e4) {
    let t4 = this._parent._isInFeatureSet(e4);
    return t4 === i.NotInFeatureSet ? t4 : (t4 = this._idstates[e4], void 0 === t4 ? i.Unknown : t4);
  }
  _getFeature(e4, t4, s6) {
    return this._parent._getFeature(e4, t4, s6);
  }
  _getFeatures(e4, t4, s6, i3) {
    return this._parent._getFeatures(e4, t4, s6, i3);
  }
  _featureFromCache(e4) {
    return this._parent._featureFromCache(e4);
  }
  executeWhereClause(e4) {
    return this._whereclause.testFeature(e4);
  }
  async executeWhereClauseDeferred(e4) {
    if (null !== this._whereClauseFunction) {
      const t4 = this._whereClauseFunction(e4);
      return k(t4), t4;
    }
    return this.executeWhereClause(e4);
  }
  async _fetchAndRefineFeatures(e4, s6, r) {
    const n9 = new t2([], e4, false, null), a5 = Math.min(s6, e4.length);
    if (await this._parent._getFeatures(n9, -1, a5, r), this._checkCancelled(r), null == this._whereClauseFunction) {
      for (let t4 = 0; t4 < a5; t4++) {
        const s7 = this._parent._featureFromCache(e4[t4]);
        true === this.executeWhereClause(s7) ? this._idstates[e4[t4]] = i.InFeatureSet : this._idstates[e4[t4]] = i.NotInFeatureSet;
      }
      return "success";
    }
    const l2 = [];
    for (let t4 = 0; t4 < a5; t4++) {
      const s7 = this._parent._featureFromCache(e4[t4]);
      l2.push(await this.executeWhereClauseDeferred(s7));
    }
    for (let t4 = 0; t4 < s6; t4++)
      true === l2[t4] ? this._idstates[e4[t4]] = i.InFeatureSet : this._idstates[e4[t4]] = i.NotInFeatureSet;
    return "success";
  }
  async _getFilteredSet(e4, s6, i3, n9, a5) {
    null !== this._whereClauseFunction || (null !== i3 ? null !== this._whereclause && (i3 = o(this._whereclause, i3)) : i3 = this._whereclause), await this._ensureLoaded();
    const l2 = await this._parent._getFilteredSet(e4, s6, i3, n9, a5);
    let h4;
    return this._checkCancelled(a5), h4 = null !== this._whereClauseFunction ? new t2(l2._candidates.slice(0).concat(l2._known.slice(0)), [], l2._ordered, this._clonePageDefinition(l2.pagesDefinition)) : new t2(l2._candidates.slice(0), l2._known.slice(0), l2._ordered, this._clonePageDefinition(l2.pagesDefinition)), h4;
  }
  async _stat(e4, t4, s6, i3, n9, a5, l2) {
    if (null !== this._whereClauseFunction)
      return null === n9 && "" === s6 && null === i3 ? this._manualStat(e4, t4, a5, l2) : { calculated: false };
    let h4 = this._whereclause;
    null !== n9 && null !== this._whereclause && (h4 = o(this._whereclause, n9));
    const u2 = await this._parent._stat(e4, t4, s6, i3, h4, a5, l2);
    return false === u2.calculated ? null === n9 && "" === s6 && null === i3 ? this._manualStat(e4, t4, a5, l2) : { calculated: false } : u2;
  }
  async _canDoAggregates(e4, t4, s6, i3, n9) {
    return null === this._whereClauseFunction && (null !== n9 ? null !== this._whereclause && (n9 = o(this._whereclause, n9)) : n9 = this._whereclause, null !== this._parent && this._parent._canDoAggregates(e4, t4, s6, i3, n9));
  }
  async _getAggregatePagesDataSourceDefinition(e4, t4, s6, i3, n9, a5, l2) {
    if (null === this._parent)
      throw new Error("Should never be called");
    return null !== n9 ? null !== this._whereclause && (n9 = o(this._whereclause, n9)) : n9 = this._whereclause, this._parent._getAggregatePagesDataSourceDefinition(e4, t4, s6, i3, n9, a5, l2);
  }
  static registerAction() {
    k3._featuresetFunctions.filter = function(e4) {
      if ("function" == typeof e4)
        return new h3({ parentfeatureset: this, whereclause: e4 });
      let t4 = null;
      return e4 instanceof m && (t4 = e4), new h3({ parentfeatureset: this, whereclause: t4 });
    };
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/Adapted.js
var N = class {
  constructor(e4) {
    this.field = e4, this.sqlRewritable = false;
  }
  postInitialization(e4, t4) {
  }
};
var S2 = class extends N {
  constructor(e4) {
    super(e4), this.sqlRewritable = true;
  }
  extractValue(e4) {
    return e4.attributes[this.field.name];
  }
  rewriteSql(e4) {
    return { rewritten: this.sqlRewritable, where: e4 };
  }
};
var w = class extends N {
  constructor(e4, t4, r) {
    super(n(e4)), this.originalField = e4, this.sqlRewritable = true, this.field.name = t4, this.field.alias = r;
  }
  rewriteSql(e4, t4) {
    return { rewritten: this.sqlRewritable, where: s3(e4, this.field.name, this.originalField.name, t4.getFieldsIndex()) };
  }
  extractValue(e4) {
    return e4.attributes[this.originalField.name];
  }
};
var m3 = class extends N {
  constructor(e4, t4, r) {
    super(e4), this.codefield = t4, this.lkp = r, this.reverseLkp = {};
    for (const s6 in r)
      this.reverseLkp[r[s6]] = s6;
    this.sqlRewritable = true;
  }
  rewriteSql(e4, t4) {
    const r = this.evaluateNodeToWhereClause(e4.parseTree, t.Standardised, this.field.name, this.codefield instanceof m ? n5(this.codefield, t.Standardised) : this.codefield, e4.parameters);
    return r.includes(m3.BADNESS) ? { rewritten: false, where: e4 } : { rewritten: this.sqlRewritable, where: m.create(r, t4._parent.getFieldsIndex()) };
  }
  evaluateNodeToWhereClause(e4, t4, r = null, s6 = null, a5) {
    let i3, l2, n9, o2;
    switch (e4.type) {
      case "interval":
        return T(this.evaluateNodeToWhereClause(e4.value, t4, r, s6, a5), e4.qualifier, e4.op);
      case "case-expression": {
        let s7 = " CASE ";
        "simple" === e4.format && (s7 += this.evaluateNodeToWhereClause(e4.operand, t4, r, m3.BADNESS, a5));
        for (let i4 = 0; i4 < e4.clauses.length; i4++)
          s7 += " WHEN " + this.evaluateNodeToWhereClause(e4.clauses[i4].operand, t4, r, m3.BADNESS, a5) + " THEN " + this.evaluateNodeToWhereClause(e4.clauses[i4].value, t4, r, m3.BADNESS, a5);
        return null !== e4.else && (s7 += " ELSE " + this.evaluateNodeToWhereClause(e4.else, t4, r, m3.BADNESS, a5)), s7 += " END ", s7;
      }
      case "parameter": {
        const r2 = a5[e4.value.toLowerCase()];
        if ("string" == typeof r2) {
          return "'" + a5[e4.value.toLowerCase()].toString().replace(/'/g, "''") + "'";
        }
        if (r2 instanceof Date)
          return i2(r2, t4);
        if (r2 instanceof Array) {
          const e5 = [];
          for (let s7 = 0; s7 < r2.length; s7++)
            "string" == typeof r2[s7] ? e5.push("'" + r2[s7].toString().replace(/'/g, "''") + "'") : r2[s7] instanceof Date ? e5.push(i2(r2[s7], t4)) : e5.push(r2[s7].toString());
          return e5;
        }
        return r2.toString();
      }
      case "expression-list":
        l2 = [];
        for (const i4 of e4.value)
          l2.push(this.evaluateNodeToWhereClause(i4, t4, r, s6, a5));
        return l2;
      case "unary-expression":
        return " ( NOT " + this.evaluateNodeToWhereClause(e4.expr, t4, r, m3.BADNESS, a5) + " ) ";
      case "binary-expression":
        switch (e4.operator) {
          case "AND":
            return " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " AND " + this.evaluateNodeToWhereClause(e4.right, t4, r, s6, a5) + ") ";
          case "OR":
            return " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " OR " + this.evaluateNodeToWhereClause(e4.right, t4, r, s6, a5) + ") ";
          case "IS":
            if ("null" !== e4.right.type)
              throw new Error("Unsupported RHS for IS");
            return " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " IS NULL )";
          case "ISNOT":
            if ("null" !== e4.right.type)
              throw new Error("Unsupported RHS for IS");
            return " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " IS NOT NULL )";
          case "IN":
            if (i3 = [], "expression-list" === e4.right.type) {
              if ("column-reference" === e4.left.type && e4.left.column.toUpperCase() === this.field.name.toUpperCase()) {
                const i4 = [];
                let l3 = true;
                for (const t5 of e4.right.value) {
                  if ("string" !== t5.type) {
                    l3 = false;
                    break;
                  }
                  if (void 0 === this.lkp[t5.value]) {
                    l3 = false;
                    break;
                  }
                  i4.push(this.lkp[t5.value].toString());
                }
                if (l3)
                  return " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " IN (" + i4.join(",") + ")) ";
              }
              return i3 = this.evaluateNodeToWhereClause(e4.right, t4, r, s6, a5), " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " IN (" + i3.join(",") + ")) ";
            }
            return o2 = this.evaluateNodeToWhereClause(e4.right, t4, r, s6, a5), o2 instanceof Array ? " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " IN (" + o2.join(",") + ")) " : " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " IN (" + o2 + ")) ";
          case "NOT IN":
            if (i3 = [], "expression-list" === e4.right.type) {
              if ("column-reference" === e4.left.type && e4.left.column.toUpperCase() === this.field.name.toUpperCase()) {
                const i4 = [];
                let l3 = true;
                for (const t5 of e4.right.value) {
                  if ("string" !== t5.type) {
                    l3 = false;
                    break;
                  }
                  if (void 0 === this.lkp[t5.value]) {
                    l3 = false;
                    break;
                  }
                  i4.push(this.lkp[t5.value].toString());
                }
                if (l3)
                  return " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " NOT IN (" + i4.join(",") + ")) ";
              }
              return i3 = this.evaluateNodeToWhereClause(e4.right, t4, r, s6, a5), " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " NOT IN (" + i3.join(",") + ")) ";
            }
            return o2 = this.evaluateNodeToWhereClause(e4.right, t4, r, s6, a5), o2 instanceof Array ? " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " NOT IN (" + o2.join(",") + ")) " : " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, s6, a5) + " NOT IN (" + o2 + ")) ";
          case "BETWEEN":
            return n9 = this.evaluateNodeToWhereClause(e4.right, t4, r, m3.BADNESS, a5), " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, m3.BADNESS, a5) + " BETWEEN " + n9[0] + " AND " + n9[1] + " ) ";
          case "NOTBETWEEN":
            return n9 = this.evaluateNodeToWhereClause(e4.right, t4, r, m3.BADNESS, a5), " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, m3.BADNESS, a5) + " NOT BETWEEN " + n9[0] + " AND " + n9[1] + " ) ";
          case "LIKE":
            return "" !== e4.escape ? " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, m3.BADNESS, a5) + " LIKE " + this.evaluateNodeToWhereClause(e4.right, t4, r, m3.BADNESS, a5) + " ESCAPE '" + e4.escape + "') " : " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, m3.BADNESS, a5) + " LIKE " + this.evaluateNodeToWhereClause(e4.right, t4, r, m3.BADNESS, a5) + ") ";
          case "NOT LIKE":
            return "" !== e4.escape ? " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, m3.BADNESS, a5) + " NOT LIKE " + this.evaluateNodeToWhereClause(e4.right, t4, r, m3.BADNESS, a5) + " ESCAPE '" + e4.escape + "') " : " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, m3.BADNESS, a5) + " NOT LIKE " + this.evaluateNodeToWhereClause(e4.right, t4, r, m3.BADNESS, a5) + ") ";
          case "<>":
          case "=":
            if ("column-reference" === e4.left.type && "string" === e4.right.type) {
              if (e4.left.column.toUpperCase() === this.field.name.toUpperCase() && void 0 !== this.lkp[e4.right.value.toString()])
                return " (" + s6 + " " + e4.operator + " " + this.lkp[e4.right.value.toString()].toString() + ") ";
            } else if ("column-reference" === e4.right.type && "string" === e4.left.type && e4.right.column.toUpperCase() === this.field.name.toUpperCase())
              return " (" + this.lkp[e4.right.value.toString()].toString() + " " + e4.operator + " " + s6 + ") ";
            return " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, m3.BADNESS, a5) + " " + e4.operator + " " + this.evaluateNodeToWhereClause(e4.right, t4, r, m3.BADNESS, a5) + ") ";
          case "<":
          case ">":
          case ">=":
          case "<=":
          case "*":
          case "-":
          case "+":
          case "/":
            return " (" + this.evaluateNodeToWhereClause(e4.left, t4, r, m3.BADNESS, a5) + " " + e4.operator + " " + this.evaluateNodeToWhereClause(e4.right, t4, r, m3.BADNESS, a5) + ") ";
        }
      case "null":
        return "null";
      case "boolean":
        return true === e4.value ? "1" : "0";
      case "string":
        return "'" + e4.value.toString().replace(/'/g, "''") + "'";
      case "timestamp":
      case "date":
        return i2(e4.value, t4);
      case "number":
        return e4.value.toString();
      case "current-time":
        return u("date" === e4.mode, t4);
      case "column-reference":
        return r && r.toLowerCase() === e4.column.toLowerCase() ? "(" + s6 + ")" : e4.column;
      case "function": {
        const s7 = this.evaluateNodeToWhereClause(e4.args, t4, r, m3.BADNESS, a5);
        return l(e4.name, s7, t4);
      }
    }
    throw new Error("Unsupported sql syntax " + e4.type);
  }
  extractValue(e4) {
    return this.codefield instanceof m ? this.reverseLkp[this.codefield.calculateValueCompiled(e4)] : this.reverseLkp[e4.attributes[this.codefield]];
  }
};
m3.BADNESS = "_!!!_BAD_LKP_!!!!";
var v = class extends N {
  constructor(e4, t4) {
    super(e4), this.sql = t4;
  }
  rewriteSql(e4, t4) {
    return { rewritten: true, where: s3(e4, this.field.name, n5(this.sql, t.Standardised), t4.getFieldsIndex()) };
  }
  extractValue(e4) {
    return this.sql.calculateValueCompiled(e4);
  }
};
var C = class extends k3 {
  constructor(e4) {
    super(e4), this._calcFunc = null, this.declaredClass = "esri.arcade.featureset.actions.Adapted", this.adaptedFields = null, this._extraFilter = null, this._extraFilter = e4.extraFilter, this._parent = e4.parentfeatureset, this._maxProcessing = 30, this.adaptedFields = e4.adaptedFields;
  }
  static findField(e4, t4) {
    for (const r of e4)
      if (r.name.toLowerCase() === t4.toString().toLowerCase())
        return r;
    return null;
  }
  _initialiseFeatureSet() {
    null !== this._parent ? (this.geometryType = this._parent.geometryType, this.objectIdField = this._parent.objectIdField, this.globalIdField = this._parent.globalIdField, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = this._parent.typeIdField, this.types = this._parent.types) : (this.spatialReference = new k2({ wkid: 4326 }), this.objectIdField = "", this.globalIdField = "", this.geometryType = S.point, this.typeIdField = "", this.types = null), this.fields = [];
    for (const e4 of this.adaptedFields)
      e4.postInitialization(this, this._parent), this.fields.push(e4.field);
  }
  async _getSet(e4) {
    if (null === this._wset) {
      await this._ensureLoaded();
      let t4 = null;
      return t4 = this._extraFilter ? await this._getFilteredSet("", null, null, null, e4) : await this._parent._getSet(e4), this._checkCancelled(e4), this._wset = new t2(t4._candidates.slice(0), t4._known.slice(0), t4._ordered, this._clonePageDefinition(t4.pagesDefinition)), this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet(e4) {
    return this._parent._isInFeatureSet(e4);
  }
  async _getFeatures(r, a5, i3, l2) {
    const n9 = [];
    -1 !== a5 && void 0 === this._featureCache[a5] && n9.push(a5);
    const o2 = this._maxQueryRate();
    if (true === this._checkIfNeedToExpandKnownPage(r, o2))
      return await this._expandPagedSet(r, o2, 0, 0, l2), this._getFeatures(r, a5, i3, l2);
    let h4 = 0;
    for (let e4 = r._lastFetchedIndex; e4 < r._known.length && (h4++, h4 <= i3 && (r._lastFetchedIndex += 1), !(void 0 === this._featureCache[r._known[e4]] && (r._known[e4] !== a5 && n9.push(r._known[e4]), n9.length >= o2))); e4++)
      ;
    if (0 === n9.length)
      return "success";
    r = new t2([], n9, r._ordered, null);
    const u2 = Math.min(n9.length, i3);
    await this._parent._getFeatures(r, -1, u2, l2), this._checkCancelled(l2);
    const c3 = [];
    for (let e4 = 0; e4 < u2; e4++) {
      const t4 = this._parent._featureFromCache(n9[e4]);
      void 0 !== t4 && c3.push({ geometry: t4.geometry, attributes: t4.attributes, id: n9[e4] });
    }
    for (const s6 of c3) {
      const r2 = [];
      for (const e4 of this.adaptedFields)
        r2[e4.field.name] = e4.extractValue(s6);
      this._featureCache[s6.id] = new g({ attributes: r2, geometry: c(s6.geometry) });
    }
    return "success";
  }
  async _fetchAndRefineFeatures() {
    throw new Error("Fetch and Refine should not be called in this featureset");
  }
  async _getFilteredSet(e4, t4, r, a5, i3) {
    let l2 = false;
    const n9 = this._reformulateWithoutAdaptions(r);
    l2 = n9.cannot, r = n9.where;
    let o2 = false;
    if (null !== a5) {
      o2 = true;
      const e5 = [];
      for (const t5 of this.adaptedFields)
        if (!(t5 instanceof S2) && true === a5.scanForField(t5.field.name)) {
          if (!(t5 instanceof w)) {
            a5 = null, o2 = false;
            break;
          }
          e5.push({ field: t5.field.name, newfield: t5.originalField.name });
        }
      a5 && e5.length > 0 && (a5 = a5.replaceFields(e5));
    }
    null !== r ? null !== this._extraFilter && (r = o(this._extraFilter, r)) : r = this._extraFilter, await this._ensureLoaded();
    const h4 = await this._parent._getFilteredSet(e4, t4, r, a5, i3);
    let u2;
    return this._checkCancelled(i3), u2 = true === l2 ? new t2(h4._candidates.slice(0).concat(h4._known.slice(0)), [], true === o2 && h4._ordered, this._clonePageDefinition(h4.pagesDefinition)) : new t2(h4._candidates.slice(0), h4._known.slice(0), true === o2 && h4._ordered, this._clonePageDefinition(h4.pagesDefinition)), u2;
  }
  _reformulateWithoutAdaptions(e4) {
    const t4 = { cannot: false, where: e4 };
    if (null !== e4) {
      for (const r of this.adaptedFields)
        if (true === h(e4, r.field.name)) {
          const s6 = r.rewriteSql(e4, this);
          if (true !== s6.rewritten) {
            t4.cannot = true, t4.where = null;
            break;
          }
          t4.where = s6.where;
        }
    }
    return t4;
  }
  async _stat(e4, t4, r, s6, a5, i3, l2) {
    let n9 = false, o2 = this._reformulateWithoutAdaptions(t4);
    if (n9 = o2.cannot, t4 = o2.where, o2 = this._reformulateWithoutAdaptions(a5), n9 = n9 || o2.cannot, null !== (a5 = o2.where) ? null !== this._extraFilter && (a5 = o(this._extraFilter, a5)) : a5 = this._extraFilter, true === n9)
      return null === a5 && "" === r && null === s6 ? this._manualStat(e4, t4, i3, l2) : { calculated: false };
    const h4 = await this._parent._stat(e4, t4, r, s6, a5, i3, l2);
    return false === h4.calculated ? null === a5 && "" === r && null === s6 ? this._manualStat(e4, t4, i3, l2) : { calculated: false } : h4;
  }
  async _canDoAggregates(e4, t4, r, s6, a5) {
    if (null === this._parent)
      return false;
    for (let n9 = 0; n9 < e4.length; n9++)
      for (const t5 of this.adaptedFields)
        if (e4[n9].toLowerCase() === t5.field.name.toLowerCase() && !(t5 instanceof S2))
          return false;
    const i3 = [];
    for (let n9 = 0; n9 < t4.length; n9++) {
      const e5 = t4[n9];
      if (null !== e5.workingexpr) {
        const t5 = this._reformulateWithoutAdaptions(e5.workingexpr);
        if (t5.cannot)
          return false;
        const r2 = e5.clone();
        r2.workingexpr = t5.where, i3.push(r2);
      } else
        i3.push(e5);
    }
    const l2 = this._reformulateWithoutAdaptions(a5);
    return !l2.cannot && (null !== (a5 = l2.where) ? null !== this._extraFilter && (a5 = o(this._extraFilter, a5)) : a5 = this._extraFilter, this._parent._canDoAggregates(e4, i3, r, s6, a5));
  }
  async _getAggregatePagesDataSourceDefinition(e4, t4, r, s6, a5, i3, l2) {
    if (null === this._parent)
      throw new Error("Should never be called");
    const n9 = [];
    for (let h4 = 0; h4 < t4.length; h4++) {
      const e5 = t4[h4];
      if (null !== e5.workingexpr) {
        const t5 = this._reformulateWithoutAdaptions(e5.workingexpr);
        if (t5.cannot)
          throw new Error("Should never be called");
        const r2 = e5.clone();
        r2.workingexpr = t5.where, n9.push(r2);
      } else
        n9.push(e5);
    }
    const o2 = this._reformulateWithoutAdaptions(a5);
    if (o2.cannot)
      throw new Error("Should never be called");
    return null !== (a5 = o2.where) ? null !== this._extraFilter && (a5 = o(this._extraFilter, a5)) : a5 = this._extraFilter, this._parent._getAggregatePagesDataSourceDefinition(e4, n9, r, s6, a5, i3, l2);
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/OrderbyClause.js
function t3(t4, e4) {
  return t4 === e4 ? 0 : null === t4 ? -1 : null === e4 ? 1 : t4 < e4 ? -1 : 1;
}
var e3 = class {
  constructor(t4) {
    const e4 = t4.split(",");
    this._fields = [], this._directions = [];
    for (let s6 = 0; s6 < e4.length; s6++) {
      const t5 = e4[s6].match(/\S+/g);
      this._fields.push(t5[0]), 2 === t5.length ? "asc" === t5[1].toLowerCase() ? this._directions.push(1) : this._directions.push(0) : this._directions.push(1);
    }
  }
  constructClause() {
    let t4 = "";
    for (let e4 = 0; e4 < this._fields.length; e4++)
      0 !== e4 && (t4 += ","), t4 += this._fields[e4], 1 === this._directions[e4] ? t4 += " ASC" : t4 += " DESC";
    return t4;
  }
  order(e4) {
    e4.sort((e5, s6) => {
      for (let i3 = 0; i3 < this._fields.length; i3++) {
        const r = this.featureValue(e5.feature, this._fields[i3], i3), l2 = this.featureValue(s6.feature, this._fields[i3], i3);
        let o2 = 0;
        if (o2 = 1 === this._directions[i3] ? t3(r, l2) : -1 * t3(r, l2), 0 !== o2)
          return o2;
      }
      return 0;
    });
  }
  scanForField(t4) {
    for (let e4 = 0; e4 < this._fields.length; e4++)
      if (this._fields[e4].toLowerCase().trim() === t4.toLowerCase().trim())
        return true;
    return false;
  }
  replaceFields(t4) {
    let s6 = "";
    for (let e4 = 0; e4 < this._fields.length; e4++) {
      0 !== e4 && (s6 += ",");
      let i3 = this._fields[e4];
      for (const e5 of t4)
        if (i3.toLowerCase() === e5.field.toLowerCase()) {
          i3 = e5.newfield;
          break;
        }
      s6 += i3, 1 === this._directions[e4] ? s6 += " ASC" : s6 += " DESC";
    }
    return new e3(s6);
  }
  featureValue(t4, e4, s6) {
    const i3 = t4.attributes[e4];
    if (void 0 !== i3)
      return i3;
    for (const r in t4.attributes)
      if (e4.toLowerCase() === r.toLowerCase())
        return this._fields[s6] = r, t4.attributes[r];
    return null;
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/OrderBy.js
var s4 = class extends k3 {
  constructor(e4) {
    super(e4), this._orderbyclause = null, this.declaredClass = "esri.arcade.featureset.actions.OrderBy", this._maxProcessing = 100, this._orderbyclause = e4.orderbyclause, this._parent = e4.parentfeatureset;
  }
  async _getSet(e4) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._getFilteredSet("", null, null, this._orderbyclause, e4);
      return this._checkCancelled(e4), this._wset = t4, this._wset;
    }
    return this._wset;
  }
  async manualOrderSet(e4, t4) {
    const r = await this.getIdColumnDictionary(e4, [], -1, t4);
    this._orderbyclause.order(r);
    const s6 = new t2([], [], true, null);
    for (let n9 = 0; n9 < r.length; n9++)
      s6._known.push(r[n9].id);
    return s6;
  }
  async getIdColumnDictionary(t4, n9, r, s6) {
    if (r < t4._known.length - 1) {
      const i3 = this._maxQueryRate();
      if ("GETPAGES" === t4._known[r + 1])
        return await Te(this._parent._expandPagedSet(t4, i3, 0, 0, s6)), this.getIdColumnDictionary(t4, n9, r, s6);
      let a5 = r + 1;
      const o2 = [];
      for (; a5 < t4._known.length && "GETPAGES" !== t4._known[a5]; )
        o2.push(t4._known[a5]), a5++;
      r += o2.length;
      const c3 = await Te(this._parent._getFeatureBatch(o2, s6));
      this._checkCancelled(s6);
      for (const e4 of c3)
        n9.push({ id: e4.attributes[this.objectIdField], feature: e4 });
      return this.getIdColumnDictionary(t4, n9, r, s6);
    }
    return t4._candidates.length > 0 ? (await Te(this._refineSetBlock(t4, this._maxProcessingRate(), s6)), this._checkCancelled(s6), this.getIdColumnDictionary(t4, n9, r, s6)) : n9;
  }
  _isInFeatureSet(e4) {
    return this._parent._isInFeatureSet(e4);
  }
  _getFeatures(e4, t4, n9, r) {
    return this._parent._getFeatures(e4, t4, n9, r);
  }
  _featureFromCache(e4) {
    if (void 0 === this._featureCache[e4]) {
      const t4 = this._parent._featureFromCache(e4);
      if (void 0 === t4)
        return;
      return null === t4 ? null : (this._featureCache[e4] = t4, t4);
    }
    return this._featureCache[e4];
  }
  async _fetchAndRefineFeatures() {
    throw new Error("Fetch and Refine should not be called in this featureset");
  }
  async _getFilteredSet(e4, t4, r, s6, i3) {
    await this._ensureLoaded();
    const a5 = await this._parent._getFilteredSet(e4, t4, r, null === s6 ? this._orderbyclause : s6, i3);
    this._checkCancelled(i3);
    const o2 = new t2(a5._candidates.slice(0), a5._known.slice(0), a5._ordered, this._clonePageDefinition(a5.pagesDefinition));
    let c3 = true;
    if (a5._candidates.length > 0 && (c3 = false), false === o2._ordered) {
      let e5 = await this.manualOrderSet(o2, i3);
      return false === c3 && (null === t4 && null === r || (e5 = new t2(e5._candidates.slice(0).concat(e5._known.slice(0)), [], e5._ordered, this._clonePageDefinition(e5.pagesDefinition)))), e5;
    }
    return o2;
  }
  static registerAction() {
    k3._featuresetFunctions.orderBy = function(e4) {
      return "" === e4 ? this : new s4({ parentfeatureset: this, orderbyclause: new e3(e4) });
    };
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/StatsField.js
function a4(a5) {
  if ("function" === a5.parseTree.type) {
    if (0 === a5.parseTree.args.value.length)
      return { name: a5.parseTree.name, expr: null };
    if (a5.parseTree.args.value.length > 1)
      throw new Error("Statistic does not have 1 or 0 Parameters");
    const n9 = m.create(a3(a5.parseTree.args.value[0], t.Standardised, a5.parameters), a5.fieldsIndex);
    return { name: a5.parseTree.name, expr: n9 };
  }
  return null;
}
var n7 = class {
  clone() {
    const e4 = new n7();
    return e4.field = this.field, e4.tofieldname = this.tofieldname, e4.typeofstat = this.typeofstat, e4.workingexpr = this.workingexpr, e4;
  }
  static parseStatField(e4, r, i3) {
    const s6 = new n7();
    s6.field = e4;
    const o2 = m.create(r, i3), l2 = a4(o2);
    if (null === l2)
      throw new Error("Invalid Statistic Function");
    const p2 = l2.name.toUpperCase().trim();
    if ("MIN" === p2) {
      if (s6.typeofstat = "MIN", s6.workingexpr = l2.expr, null === o2)
        throw new Error("Invalid Statistic Function Parameters");
    } else if ("MAX" === p2) {
      if (s6.typeofstat = "MAX", s6.workingexpr = l2.expr, null === o2)
        throw new Error("Invalid Statistic Function Parameters");
    } else if ("COUNT" === p2)
      s6.typeofstat = "COUNT", s6.workingexpr = l2.expr;
    else if ("STDEV" === p2) {
      if (s6.typeofstat = "STDDEV", s6.workingexpr = l2.expr, null === o2)
        throw new Error("Invalid Statistic Function Parameters");
    } else if ("SUM" === p2) {
      if (s6.typeofstat = "SUM", s6.workingexpr = l2.expr, null === o2)
        throw new Error("Invalid Statistic Function Parameters");
    } else if ("MEAN" === p2) {
      if (s6.typeofstat = "AVG", s6.workingexpr = l2.expr, null === o2)
        throw new Error("Invalid Statistic Function Parameters");
    } else if ("AVG" === p2) {
      if (s6.typeofstat = "AVG", s6.workingexpr = l2.expr, null === o2)
        throw new Error("Invalid Statistic Function Parameters");
    } else {
      if ("VAR" !== p2)
        throw new Error("Invalid Statistic Function");
      if (s6.typeofstat = "VAR", s6.workingexpr = l2.expr, null === o2)
        throw new Error("Invalid Statistic Function Parameters");
    }
    return s6;
  }
  toStatisticsName() {
    switch (this.typeofstat.toUpperCase()) {
      case "MIN":
        return "min";
      case "MAX":
        return "max";
      case "SUM":
        return "sum";
      case "COUNT":
      default:
        return "count";
      case "VAR":
        return "var";
      case "STDDEV":
        return "stddev";
      case "AVG":
        return "avg";
    }
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/GroupBy.js
function D2(e4) {
  if (!e4)
    return "COUNT";
  switch (e4.toLowerCase()) {
    case "max":
      return "MAX";
    case "var":
    case "variance":
      return "VAR";
    case "avg":
    case "average":
    case "mean":
      return "AVG";
    case "min":
      return "MIN";
    case "sum":
      return "SUM";
    case "stdev":
    case "stddev":
      return "STDDEV";
    case "count":
      return "COUNT";
  }
  return "COUNT";
}
var A = class extends k3 {
  constructor(e4) {
    super(e4), this._decodedStatsfield = [], this._decodedGroupbyfield = [], this._candosimplegroupby = true, this.phsyicalgroupbyfields = [], this.objectIdField = "ROW__ID", this._internalObjectIdField = "ROW__ID", this._adaptedFields = [], this.declaredClass = "esri.arcade.featureset.actions.Aggregate", this._uniqueIds = 1, this._maxQuery = 10, this._maxProcessing = 10, this._parent = e4.parentfeatureset, this._config = e4;
  }
  isTable() {
    return true;
  }
  async _getSet(e4) {
    if (null === this._wset) {
      const t4 = await this._getFilteredSet("", null, null, null, e4);
      return this._wset = t4, this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet() {
    return i.InFeatureSet;
  }
  _nextUniqueName(e4) {
    for (; 1 === e4["T" + this._uniqueIds.toString()]; )
      this._uniqueIds++;
    const t4 = "T" + this._uniqueIds.toString();
    return e4[t4] = 1, t4;
  }
  _convertToEsriFieldType(e4) {
    return e4;
  }
  _initialiseFeatureSet() {
    const e4 = {};
    let t4 = false, n9 = 1;
    const r = this._parent ? this._parent.getFieldsIndex() : new d3([]);
    for (this.objectIdField = "ROW__ID", this.globalIdField = ""; false === t4; ) {
      let e5 = false;
      for (let t5 = 0; t5 < this._config.groupbyfields.length; t5++)
        if (this._config.groupbyfields[t5].name.toLowerCase() === this.objectIdField.toLowerCase()) {
          e5 = true;
          break;
        }
      if (false === e5) {
        for (let t5 = 0; t5 < this._config.statsfields.length; t5++)
          if (this._config.statsfields[t5].name.toLowerCase() === this.objectIdField.toLowerCase()) {
            e5 = true;
            break;
          }
      }
      false === e5 ? t4 = true : (this.objectIdField = "ROW__ID" + n9.toString(), n9++);
    }
    for (const i3 of this._config.statsfields) {
      const e5 = new n7();
      e5.field = i3.name, e5.tofieldname = i3.name, e5.workingexpr = i3.expression instanceof m ? i3.expression : m.create(i3.expression, r), e5.typeofstat = D2(i3.statistic), this._decodedStatsfield.push(e5);
    }
    this._decodedGroupbyfield = [];
    for (const i3 of this._config.groupbyfields) {
      const e5 = { name: i3.name, singlefield: null, tofieldname: i3.name, expression: i3.expression instanceof m ? i3.expression : m.create(i3.expression, r) };
      this._decodedGroupbyfield.push(e5);
    }
    if (null !== this._parent) {
      this.geometryType = this._parent.geometryType, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = "";
      for (const t5 of this._parent.fields)
        e4[t5.name.toUpperCase()] = 1;
      this.types = null;
    } else
      this.geometryType = S.point, this.typeIdField = "", this.types = null, this.spatialReference = new k2({ wkid: 4326 });
    this.fields = [];
    const a5 = new n7();
    a5.field = this._nextUniqueName(e4), a5.tofieldname = this.objectIdField, a5.workingexpr = m.create(this._parent.objectIdField, this._parent.getFieldsIndex()), a5.typeofstat = "MIN", this._decodedStatsfield.push(a5);
    for (const s6 of this._decodedGroupbyfield) {
      const t5 = new y();
      if (s6.name = this._nextUniqueName(e4), t5.name = s6.tofieldname, t5.alias = t5.name, E(s6.expression)) {
        const e5 = this._parent.getField(n5(s6.expression, t.Standardised));
        if (!e5)
          throw new Error("Field is not present for Aggregation");
        s6.name = e5.name, s6.singlefield = e5.name, this.phsyicalgroupbyfields.push(e5.name), t5.type = e5.type;
      } else {
        t5.type = this._convertToEsriFieldType(f(s6.expression, this._parent.fields));
        const e5 = new y();
        e5.name = s6.name, e5.alias = e5.name, this.phsyicalgroupbyfields.push(s6.name), this._adaptedFields.push(new v(e5, s6.expression)), this._candosimplegroupby = false;
      }
      this.fields.push(t5);
    }
    if (this._adaptedFields.length > 0)
      for (const i3 of this._parent.fields)
        this._adaptedFields.push(new S2(i3));
    for (let i3 = 0; i3 < this._decodedStatsfield.length; i3++) {
      const t5 = new y();
      let s6 = null;
      const n10 = this._decodedStatsfield[i3];
      n10.field = this._nextUniqueName(e4), n10.tofieldname === this.objectIdField && (this._internalObjectIdField = n10.field), t5.name = n10.tofieldname, t5.alias = t5.name;
      const r2 = null !== n10.workingexpr && E(n10.workingexpr) ? n5(n10.workingexpr, t.Standardised) : "";
      switch (this._decodedStatsfield[i3].typeofstat) {
        case "SUM":
          if ("" !== r2) {
            if (s6 = this._parent.getField(r2), !s6)
              throw new Error("Field is not present for Aggregation");
            t5.type = s6.type;
          } else
            t5.type = "double";
          break;
        case "MIN":
        case "MAX":
          if ("" !== r2) {
            if (s6 = this._parent.getField(r2), !s6)
              throw new Error("Field is not present for Aggregation");
            t5.type = s6.type;
          } else
            t5.type = "double";
          break;
        case "COUNT":
          t5.type = "integer";
          break;
        case "STDDEV":
        case "VAR":
        case "AVG":
          if ("" !== r2 && (s6 = this._parent.getField(r2), !s6))
            throw new Error("Field is not present for Aggregation");
          t5.type = "double";
      }
      this.fields.push(t5);
    }
  }
  async _canDoAggregates() {
    return false;
  }
  async _getFeatures(e4, t4, i3, s6) {
    -1 !== t4 && this._featureCache[t4];
    const n9 = this._maxQuery;
    return true === this._checkIfNeedToExpandKnownPage(e4, n9) ? (await this._expandPagedSet(e4, n9, 0, 0, s6), this._getFeatures(e4, t4, i3, s6)) : "success";
  }
  async _getFilteredSet(e4, t4, i3, s6, l2) {
    if ("" !== e4)
      return new t2([], [], true, null);
    let u2 = null;
    const f3 = { ordered: false, nowhereclause: false };
    if (await this._ensureLoaded(), null !== i3) {
      for (let n9 = 0; n9 < this._decodedStatsfield.length; n9++)
        if (true === h(i3, this._decodedStatsfield[n9].tofieldname)) {
          f3.nowhereclause = true, i3 = null;
          break;
        }
    }
    if (null !== s6) {
      f3.ordered = true;
      for (let e5 = 0; e5 < this._decodedStatsfield.length; e5++)
        if (true === s6.scanForField(this._decodedStatsfield[e5].tofieldname)) {
          s6 = null, f3.ordered = false;
          break;
        }
      if (null !== s6) {
        for (const e5 of this._decodedGroupbyfield)
          if (null === e5.singlefield && true === s6.scanForField(e5.tofieldname)) {
            s6 = null, f3.ordered = false;
            break;
          }
      }
    }
    if (false !== this._candosimplegroupby && await this._parent._canDoAggregates(this.phsyicalgroupbyfields, this._decodedStatsfield, "", null, null)) {
      let e5 = null;
      i3 && (e5 = this._reformulateWhereClauseWithoutGroupByFields(i3));
      let t5 = null;
      s6 && (t5 = this._reformulateOrderClauseWithoutGroupByFields(s6));
      const n9 = await this._parent._getAggregatePagesDataSourceDefinition(this.phsyicalgroupbyfields, this._decodedStatsfield, "", null, e5, t5, this._internalObjectIdField);
      return this._checkCancelled(l2), u2 = true === f3.nowhereclause ? new t2(n9._candidates.slice(0).concat(n9._known.slice(0)), [], true === f3.ordered && n9._ordered, this._clonePageDefinition(n9.pagesDefinition)) : new t2(n9._candidates.slice(0), n9._known.slice(0), true === f3.ordered && n9._ordered, this._clonePageDefinition(n9.pagesDefinition)), u2;
    }
    let c3 = this._parent;
    if (this._adaptedFields.length > 0 && (c3 = new C({ parentfeatureset: this._parent, adaptedFields: this._adaptedFields, extraFilter: null })), true === f3.nowhereclause)
      u2 = new t2(["GETPAGES"], [], false, { aggregatefeaturesetpagedefinition: true, resultOffset: 0, resultRecordCount: this._maxQuery, internal: { fullyResolved: false, workingItem: null, type: "manual", iterator: null, set: [], subfeatureset: new s4({ parentfeatureset: c3, orderbyclause: new e3(this.phsyicalgroupbyfields.join(",") + "," + this._parent.objectIdField + " ASC") }) } });
    else {
      let e5 = c3;
      if (null !== i3) {
        let t5 = null;
        i3 && (t5 = this._reformulateWhereClauseWithoutGroupByFields(i3)), e5 = new h3({ parentfeatureset: e5, whereclause: t5 });
      }
      u2 = new t2(["GETPAGES"], [], false, { aggregatefeaturesetpagedefinition: true, resultOffset: 0, resultRecordCount: this._maxQuery, internal: { fullyResolved: false, workingItem: null, type: "manual", iterator: null, set: [], subfeatureset: new s4({ parentfeatureset: e5, orderbyclause: new e3(this.phsyicalgroupbyfields.join(",") + "," + this._parent.objectIdField + " ASC") }) } });
    }
    return u2;
  }
  _reformulateWhereClauseWithoutStatsFields(e4) {
    for (const t4 of this._decodedStatsfield)
      e4 = s3(e4, t4.tofieldname, n5(t4.workingexpr, t.Standardised), this._parent.getFieldsIndex());
    return e4;
  }
  _reformulateWhereClauseWithoutGroupByFields(e4) {
    for (const t4 of this._decodedGroupbyfield)
      t4.tofieldname !== t4.name && (e4 = s3(e4, t4.tofieldname, n5(t4.expression, t.Standardised), this._parent.getFieldsIndex()));
    return e4;
  }
  _reformulateOrderClauseWithoutGroupByFields(e4) {
    const t4 = [];
    for (const i3 of this._decodedGroupbyfield)
      i3.tofieldname !== i3.name && t4.push({ field: i3.tofieldname, newfield: i3.name });
    return t4.length > 0 ? e4.replaceFields(t4) : e4;
  }
  _clonePageDefinition(e4) {
    return null === e4 ? null : true === e4.aggregatefeaturesetpagedefinition ? { aggregatefeaturesetpagedefinition: true, resultRecordCount: e4.resultRecordCount, resultOffset: e4.resultOffset, internal: e4.internal } : this._parent._clonePageDefinition(e4);
  }
  async _refineSetBlock(e4, t4, i3) {
    if (true === this._checkIfNeedToExpandCandidatePage(e4, this._maxQuery))
      return await this._expandPagedSet(e4, this._maxQuery, 0, 0, i3), this._refineSetBlock(e4, t4, i3);
    this._checkCancelled(i3);
    const s6 = e4._candidates.length;
    this._refineKnowns(e4, t4);
    e4._candidates.length;
    return e4._candidates.length, e4;
  }
  _expandPagedSet(e4, t4, i3, s6, n9) {
    return this._expandPagedSetFeatureSet(e4, t4, i3, s6, n9);
  }
  async _getPhysicalPage(t4, i3, s6) {
    if (true === t4.pagesDefinition.aggregatefeaturesetpagedefinition)
      return this._sequentialGetPhysicalItem(t4, t4.pagesDefinition.resultRecordCount, s6, []);
    const n9 = await this._getAgregagtePhysicalPage(t4, i3, s6);
    for (const r of n9) {
      const t5 = { geometry: r.geometry, attributes: {} };
      for (const e4 of this._decodedGroupbyfield)
        t5.attributes[e4.tofieldname] = r.attributes[e4.name];
      for (const e4 of this._decodedStatsfield)
        t5.attributes[e4.tofieldname] = r.attributes[e4.field];
      this._featureCache[t5.attributes[this.objectIdField]] = new g(t5);
    }
    return n9.length;
  }
  _sequentialGetPhysicalItem(e4, t4, i3, s6) {
    return new Promise((n9, r) => {
      null === e4.pagesDefinition.internal.iterator && (e4.pagesDefinition.internal.iterator = e4.pagesDefinition.internal.subfeatureset.iterator(i3)), true === e4.pagesDefinition.internal.fullyResolved || 0 === t4 ? n9(s6.length) : this._nextAggregateItem(e4, t4, i3, s6, (r2) => {
        null === r2 ? n9(s6.length) : (t4 -= 1, n9(this._sequentialGetPhysicalItem(e4, t4, i3, s6)));
      }, r);
    });
  }
  _nextAggregateItem(e4, i3, s6, n9, r, a5) {
    try {
      Te(e4.pagesDefinition.internal.iterator.next()).then((t4) => {
        if (null === t4)
          if (null !== e4.pagesDefinition.internal.workingItem) {
            const t5 = this._calculateAndAppendAggregateItem(e4.pagesDefinition.internal.workingItem);
            n9.push(t5), e4.pagesDefinition.internal.workingItem = null, e4.pagesDefinition.internal.set.push(t5.attributes[this.objectIdField]), e4.pagesDefinition.internal.fullyResolved = true, r(null);
          } else
            e4.pagesDefinition.internal.fullyResolved = true, r(null);
        else {
          const l2 = this._generateAggregateHash(t4);
          if (null === e4.pagesDefinition.internal.workingItem)
            e4.pagesDefinition.internal.workingItem = { features: [t4], id: l2 };
          else {
            if (l2 !== e4.pagesDefinition.internal.workingItem.id) {
              const s7 = this._calculateAndAppendAggregateItem(e4.pagesDefinition.internal.workingItem);
              return n9.push(s7), e4.pagesDefinition.internal.workingItem = null, e4.pagesDefinition.internal.set.push(s7.attributes[this.objectIdField]), i3 -= 1, e4.pagesDefinition.internal.workingItem = { features: [t4], id: l2 }, void r(s7);
            }
            e4.pagesDefinition.internal.workingItem.features.push(t4);
          }
          this._nextAggregateItem(e4, i3, s6, n9, r, a5);
        }
      }, a5);
    } catch (l2) {
      a5(l2);
    }
  }
  _calculateFieldStat(e4, t4, i3) {
    const s6 = [];
    for (let n9 = 0; n9 < e4.features.length; n9++)
      if (null !== t4.workingexpr) {
        const i4 = t4.workingexpr.calculateValue(e4.features[n9]);
        null !== i4 && s6.push(i4);
      } else
        s6.push(null);
    switch (t4.typeofstat) {
      case "MIN":
        i3.attributes[t4.tofieldname] = f2("min", s6, -1);
        break;
      case "MAX":
        i3.attributes[t4.tofieldname] = f2("max", s6, -1);
        break;
      case "SUM":
        i3.attributes[t4.tofieldname] = f2("sum", s6, -1);
        break;
      case "COUNT":
        i3.attributes[t4.tofieldname] = s6.length;
        break;
      case "VAR":
        i3.attributes[t4.tofieldname] = f2("var", s6, -1);
        break;
      case "STDDEV":
        i3.attributes[t4.tofieldname] = f2("stddev", s6, -1);
        break;
      case "AVG":
        i3.attributes[t4.tofieldname] = f2("avg", s6, -1);
    }
    return true;
  }
  _calculateAndAppendAggregateItem(t4) {
    const i3 = { attributes: {}, geometry: null };
    for (const e4 of this._decodedGroupbyfield) {
      const s7 = e4.singlefield ? t4.features[0].attributes[e4.singlefield] : e4.expression.calculateValue(t4.features[0]);
      i3.attributes[e4.tofieldname] = s7;
    }
    for (const e4 of this._decodedStatsfield)
      this._calculateFieldStat(t4, e4, i3);
    const s6 = [];
    for (let e4 = 0; e4 < this._decodedStatsfield.length; e4++)
      s6.push(this._calculateFieldStat(t4, this._decodedStatsfield[e4], i3));
    return this._featureCache[i3.attributes[this.objectIdField]] = new g({ attributes: i3.attributes, geometry: i3.geometry }), i3;
  }
  _generateAggregateHash(e4) {
    let t4 = "";
    for (const i3 of this._decodedGroupbyfield) {
      const s6 = i3.singlefield ? e4.attributes[i3.singlefield] : i3.expression.calculateValue(e4);
      t4 += null == s6 ? ":" : ":" + s6.toString();
    }
    return x2(t4, n6.String);
  }
  async _stat() {
    return { calculated: false };
  }
  async getFeatureByObjectId() {
    return null;
  }
  static registerAction() {
    k3._featuresetFunctions.groupby = function(e4, t4) {
      return new A({ parentfeatureset: this, groupbyfields: e4, statsfields: t4 });
    };
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/Top.js
var s5 = class extends k3 {
  constructor(t4) {
    super(t4), this._topnum = 0, this.declaredClass = "esri.arcade.featureset.actions.Top", this._countedin = 0, this._maxProcessing = 100, this._topnum = t4.topnum, this._parent = t4.parentfeatureset;
  }
  async _getSet(t4) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const n9 = await this._parent._getSet(t4);
      return this._wset = new t2(n9._candidates.slice(0), n9._known.slice(0), false, this._clonePageDefinition(n9.pagesDefinition)), this._setKnownLength(this._wset) > this._topnum && (this._wset._known = this._wset._known.slice(0, this._topnum)), this._setKnownLength(this._wset) >= this._topnum && (this._wset._candidates = []), this._wset;
    }
    return this._wset;
  }
  _setKnownLength(t4) {
    return t4._known.length > 0 && "GETPAGES" === t4._known[t4._known.length - 1] ? t4._known.length - 1 : t4._known.length;
  }
  _isInFeatureSet(t4) {
    const e4 = this._parent._isInFeatureSet(t4);
    if (e4 === i.NotInFeatureSet)
      return e4;
    const s6 = this._idstates[t4];
    return s6 === i.InFeatureSet || s6 === i.NotInFeatureSet ? s6 : e4 === i.InFeatureSet && void 0 === s6 ? this._countedin < this._topnum ? (this._idstates[t4] = i.InFeatureSet, this._countedin++, i.InFeatureSet) : (this._idstates[t4] = i.NotInFeatureSet, i.NotInFeatureSet) : i.Unknown;
  }
  async _expandPagedSet(t4, e4, n9, s6, i3) {
    if (null === this._parent)
      throw new Error("Parent Paging not implemented");
    if (e4 > this._topnum && (e4 = this._topnum), this._countedin >= this._topnum && t4.pagesDefinition.internal.set.length <= t4.pagesDefinition.resultOffset) {
      let e5 = t4._known.length;
      return e5 > 0 && "GETPAGES" === t4._known[e5 - 1] && (t4._known.length = e5 - 1), e5 = t4._candidates.length, e5 > 0 && "GETPAGES" === t4._candidates[e5 - 1] && (t4._candidates.length = e5 - 1), "success";
    }
    const a5 = await this._parent._expandPagedSet(t4, e4, n9, s6, i3);
    return this._setKnownLength(t4) > this._topnum && (t4._known.length = this._topnum), this._setKnownLength(t4) >= this._topnum && (t4._candidates.length = 0), a5;
  }
  async _getFeatures(t4, n9, s6, i3) {
    const a5 = [], o2 = this._maxQueryRate();
    if (true === this._checkIfNeedToExpandKnownPage(t4, o2))
      return await this._expandPagedSet(t4, o2, 0, 0, i3), this._getFeatures(t4, n9, s6, i3);
    -1 !== n9 && void 0 === this._featureCache[n9] && a5.push(n9);
    let r = 0;
    for (let e4 = t4._lastFetchedIndex; e4 < t4._known.length && (r++, r <= s6 && (t4._lastFetchedIndex += 1), !(void 0 === this._featureCache[t4._known[e4]] && (t4._known[e4] !== n9 && a5.push(t4._known[e4]), a5.length > o2))); e4++)
      ;
    if (0 === a5.length)
      return "success";
    const _2 = new t2([], a5, false, null), h4 = Math.min(a5.length, s6);
    await this._parent._getFeatures(_2, -1, h4, i3);
    for (let e4 = 0; e4 < h4; e4++) {
      const t5 = this._parent._featureFromCache(a5[e4]);
      void 0 !== t5 && (this._featureCache[a5[e4]] = t5);
    }
    return "success";
  }
  async _getFilteredSet(t4, n9, s6, i3, a5) {
    await this._ensureLoaded();
    const o2 = await this._getSet(a5);
    return new t2(o2._candidates.slice(0).concat(o2._known.slice(0)), [], false, this._clonePageDefinition(o2.pagesDefinition));
  }
  _refineKnowns(t4, e4) {
    let s6 = 0, i3 = null;
    const a5 = [];
    for (let o2 = 0; o2 < t4._candidates.length; o2++) {
      const r = this._isInFeatureSet(t4._candidates[o2]);
      if (r === i.InFeatureSet) {
        if (t4._known.push(t4._candidates[o2]), s6 += 1, null === i3 ? i3 = { start: o2, end: o2 } : i3.end === o2 - 1 ? i3.end = o2 : (a5.push(i3), i3 = { start: o2, end: o2 }), t4._known.length >= this._topnum)
          break;
      } else if (r === i.NotInFeatureSet)
        null === i3 ? i3 = { start: o2, end: o2 } : i3.end === o2 - 1 ? i3.end = o2 : (a5.push(i3), i3 = { start: o2, end: o2 }), s6 += 1;
      else if (r === i.Unknown)
        break;
      if (s6 >= e4)
        break;
    }
    null !== i3 && a5.push(i3);
    for (let n9 = a5.length - 1; n9 >= 0; n9--)
      t4._candidates.splice(a5[n9].start, a5[n9].end - a5[n9].start + 1);
    this._setKnownLength(t4) > this._topnum && (t4._known = t4._known.slice(0, this._topnum)), this._setKnownLength(t4) >= this._topnum && (t4._candidates = []);
  }
  async _stat() {
    return { calculated: false };
  }
  async _canDoAggregates() {
    return false;
  }
  static registerAction() {
    k3._featuresetFunctions.top = function(t4) {
      return new s5({ parentfeatureset: this, topnum: t4 });
    };
  }
};

// node_modules/@arcgis/core/arcade/featureset/sources/FeatureLayerDynamic.js
var P = class extends k3 {
  constructor(e4) {
    super(e4), this.declaredClass = "esri.arcade.featureset.sources.FeatureLayerDynamic", this._removeGeometry = false, this._overrideFields = null, this.formulaCredential = null, this._pageJustIds = false, this._requestStandardised = false, this._useDefinitionExpression = true, e4.spatialReference && (this.spatialReference = e4.spatialReference), this._transparent = true, this._maxProcessing = 1e3, this._layer = e4.layer, this._wset = null, void 0 !== e4.outFields && (this._overrideFields = e4.outFields), void 0 !== e4.includeGeometry && (this._removeGeometry = false === e4.includeGeometry);
  }
  _maxQueryRate() {
    return F;
  }
  end() {
    return this._layer;
  }
  optimisePagingFeatureQueries(e4) {
    this._pageJustIds = e4;
  }
  convertQueryToLruCacheKey(e4) {
    const t4 = D(e4.toJSON());
    return x2(t4, n6.String);
  }
  async loadImpl() {
    return true === this._layer.loaded ? (this._initialiseFeatureSet(), this) : (await this._layer.load(), this._initialiseFeatureSet(), this);
  }
  _initialiseFeatureSet() {
    if (null == this.spatialReference && (this.spatialReference = this._layer.spatialReference), this.geometryType = this._layer.geometryType, this.fields = this._layer.fields.slice(0), this._layer.outFields)
      if (1 === this._layer.outFields.length && "*" === this._layer.outFields[0])
        ;
      else {
        const e4 = [];
        for (const t4 of this.fields)
          if ("oid" === t4.type)
            e4.push(t4);
          else
            for (const i3 of this._layer.outFields)
              if (i3.toLowerCase() === t4.name.toLowerCase()) {
                e4.push(t4);
                break;
              }
        this.fields = e4;
      }
    else
      ;
    if (null !== this._overrideFields)
      if (1 === this._overrideFields.length && "*" === this._overrideFields[0])
        this._overrideFields = null;
      else {
        const e4 = [], t4 = [];
        for (const i3 of this.fields)
          if ("oid" === i3.type)
            e4.push(i3), t4.push(i3.name);
          else
            for (const r of this._overrideFields)
              if (r.toLowerCase() === i3.name.toLowerCase()) {
                e4.push(i3), t4.push(i3.name);
                break;
              }
        this.fields = e4, this._overrideFields = t4;
      }
    if (this._layer.source && this._layer.source.sourceJSON) {
      const e4 = this._layer.source.sourceJSON.currentVersion;
      true === this._layer.source.sourceJSON.useStandardizedQueries ? (this._databaseType = t.StandardisedNoInterval, null != e4 && e4 >= 10.61 && (this._databaseType = t.Standardised)) : null != e4 && (e4 >= 10.5 && (this._databaseType = t.StandardisedNoInterval, this._requestStandardised = true), e4 >= 10.61 && (this._databaseType = t.Standardised));
    }
    this.objectIdField = this._layer.objectIdField;
    for (const e4 of this.fields)
      "global-id" === e4.type && (this.globalIdField = e4.name);
    this.hasM = this._layer.supportsM, this.hasZ = this._layer.supportsZ, this.typeIdField = this._layer.typeIdField, this.types = this._layer.types;
  }
  _isInFeatureSet() {
    return i.InFeatureSet;
  }
  async _refineSetBlock(e4) {
    return e4;
  }
  _candidateIdTransform(e4) {
    return e4;
  }
  async _getSet(e4) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._getFilteredSet("", null, null, null, e4);
      return this._wset = t4, t4;
    }
    return this._wset;
  }
  async _runDatabaseProbe(e4) {
    await this._ensureLoaded();
    const t4 = new b2();
    t4.where = e4.replace("OBJECTID", this._layer.objectIdField);
    try {
      return await this._layer.queryObjectIds(t4), true;
    } catch (i3) {
      return false;
    }
  }
  _canUsePagination() {
    return !(!this._layer.capabilities || !this._layer.capabilities.query || true !== this._layer.capabilities.query.supportsPagination);
  }
  _cacheableFeatureSetSourceKey() {
    return this._layer.url;
  }
  pbfSupportedForQuery(e4) {
    return !e4.outStatistics && this._layer && this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsFormatPBF && true === this._layer.capabilities.query.supportsQuantizationEditMode;
  }
  async queryPBF(e4) {
    e4.quantizationParameters = { mode: "edit" };
    const t4 = await d4(this._layer.parsedUrl, e4, new a({}));
    return x.fromJSON(se(t4.data)).unquantize();
  }
  get gdbVersion() {
    return this._layer && this._layer.capabilities && this._layer.capabilities.data && this._layer.capabilities.data.isVersioned ? this._layer.gdbVersion ? this._layer.gdbVersion : "SDE.DEFAULT" : "";
  }
  nativeCapabilities() {
    return { title: this._layer.title, source: this, canQueryRelated: true, capabilities: this._layer.capabilities, databaseType: this._databaseType, requestStandardised: this._requestStandardised };
  }
  executeQuery(e4, t4) {
    const i3 = "execute" === t4 ? s : "executeForCount" === t4 ? n4 : s2, r = "execute" === t4 && this.pbfSupportedForQuery(e4);
    let s6 = null;
    if (this.recentlyUsedQueries) {
      const t5 = this.convertQueryToLruCacheKey(e4);
      s6 = this.recentlyUsedQueries.getFromCache(t5), null === s6 && (s6 = true !== r ? i3(this._layer.parsedUrl.path, e4) : this.queryPBF(e4), this.recentlyUsedQueries.addToCache(t5, s6), s6 = s6.catch((e5) => {
        throw this.recentlyUsedQueries.removeFromCache(t5), e5;
      }));
    }
    return this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preLayerQueryCallback({ layer: this._layer, query: e4, method: t4 }), null === s6 && (s6 = true !== r ? i3(this._layer.parsedUrl.path, e4) : this.queryPBF(e4)), s6;
  }
  async _getFilteredSet(e4, t4, i3, r, a5) {
    const n9 = await this.databaseType();
    if (this.isTable() && t4 && null !== e4 && "" !== e4) {
      return new t2([], [], true, null);
    }
    if (this._canUsePagination())
      return this._getFilteredSetUsingPaging(e4, t4, i3, r, a5);
    let l2 = "", o2 = false;
    null !== r && this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsOrderBy && (l2 = r.constructClause(), o2 = true);
    const u2 = new b2();
    u2.where = null === i3 ? null === t4 ? "1=1" : "" : n5(i3, n9), this._requestStandardised && (u2.sqlFormat = "standard"), u2.spatialRelationship = this._makeRelationshipEnum(e4), u2.outSpatialReference = this.spatialReference, u2.orderByFields = "" !== l2 ? l2.split(",") : null, u2.geometry = null === t4 ? null : t4, u2.relationParameter = this._makeRelationshipParam(e4);
    let h4 = await this.executeQuery(u2, "executeForIds");
    null === h4 && (h4 = []), this._checkCancelled(a5);
    return new t2([], h4, o2, null);
  }
  _expandPagedSet(e4, t4, i3, r, s6) {
    return this._expandPagedSetFeatureSet(e4, t4, i3, r, s6);
  }
  async _getFilteredSetUsingPaging(e4, t4, i3, r, a5) {
    let n9 = "", l2 = false;
    null !== r && this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsOrderBy && (n9 = r.constructClause(), l2 = true);
    const o2 = await this.databaseType();
    let u2 = null === i3 ? null === t4 ? "1=1" : "" : n5(i3, o2);
    this._layer.definitionExpression && this._useDefinitionExpression && (u2 = "" !== u2 ? "((" + this._layer.definitionExpression + ") AND (" + u2 + "))" : this._layer.definitionExpression);
    let h4 = this._maxQueryRate();
    const c3 = this._layer.capabilities.query.maxRecordCount;
    void 0 !== c3 && c3 < h4 && (h4 = c3);
    let p2 = null;
    if (true === this._pageJustIds)
      p2 = new t2([], ["GETPAGES"], l2, { spatialRel: this._makeRelationshipEnum(e4), relationParam: this._makeRelationshipParam(e4), outFields: this._layer.objectIdField, resultRecordCount: h4, resultOffset: 0, geometry: null === t4 ? null : t4, where: u2, orderByFields: n9, returnGeometry: false, returnIdsOnly: "false", internal: { set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } });
    else {
      let i4 = true;
      true === this._removeGeometry && (i4 = false);
      const r2 = null !== this._overrideFields ? this._overrideFields : this._fieldsIncludingObjectId(this._layer.outFields ? this._layer.outFields : ["*"]);
      p2 = new t2([], ["GETPAGES"], l2, { spatialRel: this._makeRelationshipEnum(e4), relationParam: this._makeRelationshipParam(e4), outFields: r2.join(","), resultRecordCount: h4, resultOffset: 0, geometry: null === t4 ? null : t4, where: u2, orderByFields: n9, returnGeometry: i4, returnIdsOnly: "false", internal: { set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } });
    }
    return await this._expandPagedSet(p2, h4, 0, 1, a5), p2;
  }
  _clonePageDefinition(e4) {
    return null === e4 ? null : true !== e4.groupbypage ? { groupbypage: false, spatialRel: e4.spatialRel, relationParam: e4.relationParam, outFields: e4.outFields, resultRecordCount: e4.resultRecordCount, resultOffset: e4.resultOffset, geometry: e4.geometry, where: e4.where, orderByFields: e4.orderByFields, returnGeometry: e4.returnGeometry, returnIdsOnly: e4.returnIdsOnly, internal: e4.internal } : { groupbypage: true, spatialRel: e4.spatialRel, relationParam: e4.relationParam, outFields: e4.outFields, resultRecordCount: e4.resultRecordCount, useOIDpagination: e4.useOIDpagination, generatedOid: e4.generatedOid, groupByFieldsForStatistics: e4.groupByFieldsForStatistics, resultOffset: e4.resultOffset, outStatistics: e4.outStatistics, geometry: e4.geometry, where: e4.where, orderByFields: e4.orderByFields, returnGeometry: e4.returnGeometry, returnIdsOnly: e4.returnIdsOnly, internal: e4.internal };
  }
  async _getPhysicalPage(e4, t4, i3) {
    const r = e4.pagesDefinition.internal.lastRetrieved, s6 = r, a5 = e4.pagesDefinition.internal.lastPage, n9 = new b2();
    this._requestStandardised && (n9.sqlFormat = "standard"), n9.spatialRelationship = e4.pagesDefinition.spatialRel, n9.relationParameter = e4.pagesDefinition.relationParam, n9.outFields = e4.pagesDefinition.outFields.split(","), n9.num = e4.pagesDefinition.resultRecordCount, n9.start = e4.pagesDefinition.internal.lastPage, n9.geometry = e4.pagesDefinition.geometry, n9.where = e4.pagesDefinition.where, n9.orderByFields = "" !== e4.pagesDefinition.orderByFields ? e4.pagesDefinition.orderByFields.split(",") : null, n9.returnGeometry = e4.pagesDefinition.returnGeometry, n9.outSpatialReference = this.spatialReference;
    const l2 = await this.executeQuery(n9, "execute");
    if (this._checkCancelled(i3), e4.pagesDefinition.internal.lastPage !== a5)
      return "done";
    for (let o2 = 0; o2 < l2.features.length; o2++)
      e4.pagesDefinition.internal.set[s6 + o2] = l2.features[o2].attributes[this._layer.objectIdField];
    if (false === this._pageJustIds)
      for (let o2 = 0; o2 < l2.features.length; o2++)
        this._featureCache[l2.features[o2].attributes[this._layer.objectIdField]] = l2.features[o2];
    return (void 0 === l2.exceededTransferLimit && l2.features.length !== e4.pagesDefinition.resultRecordCount || false === l2.exceededTransferLimit) && (e4.pagesDefinition.internal.fullyResolved = true), e4.pagesDefinition.internal.lastRetrieved = r + l2.features.length, e4.pagesDefinition.internal.lastPage += e4.pagesDefinition.resultRecordCount, "done";
  }
  _fieldsIncludingObjectId(e4) {
    if (null === e4)
      return [this.objectIdField];
    const t4 = e4.slice(0);
    if (t4.includes("*"))
      return t4;
    let i3 = false;
    for (const r of t4)
      if (r.toUpperCase() === this.objectIdField.toUpperCase()) {
        i3 = true;
        break;
      }
    return false === i3 && t4.push(this.objectIdField), t4;
  }
  async _getFeatures(e4, t4, i3, r) {
    const s6 = [];
    if (-1 !== t4 && void 0 === this._featureCache[t4] && s6.push(t4), true === this._checkIfNeedToExpandKnownPage(e4, this._maxProcessingRate()))
      return await this._expandPagedSet(e4, this._maxProcessingRate(), 0, 0, r), this._getFeatures(e4, t4, i3, r);
    let a5 = 0;
    for (let o2 = e4._lastFetchedIndex; o2 < e4._known.length; o2++) {
      if (e4._lastFetchedIndex += 1, a5++, void 0 === this._featureCache[e4._known[o2]]) {
        let i4 = false;
        if (null !== this._layer._mode && void 0 !== this._layer._mode) {
          const t5 = this._layer._mode;
          if (void 0 !== t5._featureMap[e4._known[o2]]) {
            const r2 = t5._featureMap[e4._known[o2]];
            null !== r2 && (i4 = true, this._featureCache[e4._known[o2]] = r2);
          }
        }
        if (false === i4 && (e4._known[o2] !== t4 && s6.push(e4._known[o2]), s6.length >= this._maxProcessingRate() - 1))
          break;
      }
      if (a5 >= i3 && 0 === s6.length)
        break;
    }
    if (0 === s6.length)
      return "success";
    const n9 = new b2();
    this._requestStandardised && (n9.sqlFormat = "standard"), n9.objectIds = s6, n9.outFields = null !== this._overrideFields ? this._overrideFields : this._fieldsIncludingObjectId(this._layer.outFields ? this._layer.outFields : ["*"]), n9.returnGeometry = true, true === this._removeGeometry && (n9.returnGeometry = false), n9.outSpatialReference = this.spatialReference;
    const l2 = await this.executeQuery(n9, "execute");
    if (this._checkCancelled(r), void 0 !== l2.error)
      throw new Error(l2.error);
    for (let o2 = 0; o2 < l2.features.length; o2++)
      this._featureCache[l2.features[o2].attributes[this._layer.objectIdField]] = l2.features[o2];
    return "success";
  }
  async _getDistinctPages(e4, t4, i3, r, s6, a5, n9, l2, o2) {
    await this._ensureLoaded();
    const u2 = await this.databaseType();
    let h4 = i3.parseTree.column;
    for (let d6 = 0; d6 < this._layer.fields.length; d6++)
      if (this._layer.fields[d6].name.toLowerCase() === h4.toLowerCase()) {
        h4 = this._layer.fields[d6].name;
        break;
      }
    const c3 = new b2();
    this._requestStandardised && (c3.sqlFormat = "standard");
    let p2 = null === a5 ? null === s6 ? "1=1" : "" : n5(a5, u2);
    this._layer.definitionExpression && this._useDefinitionExpression && (p2 = "" !== p2 ? "((" + this._layer.definitionExpression + ") AND (" + p2 + "))" : this._layer.definitionExpression), c3.where = p2, c3.spatialRelationship = this._makeRelationshipEnum(r), c3.relationParameter = this._makeRelationshipParam(r), c3.geometry = null === s6 ? null : s6, c3.returnDistinctValues = true, c3.returnGeometry = false, c3.outFields = [h4];
    const y3 = await this.executeQuery(c3, "execute");
    if (this._checkCancelled(o2), !y3.hasOwnProperty("features"))
      throw new Error("Unnexected Result querying statistics from layer");
    let f3 = false;
    for (let d6 = 0; d6 < this._layer.fields.length; d6++)
      if (this._layer.fields[d6].name === h4) {
        "date" === this._layer.fields[d6].type && (f3 = true);
        break;
      }
    for (let d6 = 0; d6 < y3.features.length; d6++) {
      if (f3) {
        const e5 = y3.features[d6].attributes[h4];
        null !== e5 ? l2.push(new Date(e5)) : l2.push(e5);
      } else
        l2.push(y3.features[d6].attributes[h4]);
      if (l2.length >= n9)
        break;
    }
    if (0 === y3.features.length)
      return l2;
    if (y3.features.length === this._layer.capabilities.query.maxRecordCount && l2.length < n9) {
      return { calculated: true, result: await this._getDistinctPages(e4 + y3.features.length, t4, i3, r, s6, a5, n9, l2, o2) };
    }
    return l2;
  }
  async _distinctStat(e4, t4, i3, r, s6, a5, n9) {
    return { calculated: true, result: await this._getDistinctPages(0, e4, t4, i3, r, s6, a5, [], n9) };
  }
  isTable() {
    return this._layer.isTable || null === this._layer.geometryType || "table" === this._layer.type || "" === this._layer.geometryType;
  }
  async _countstat(e4, t4, i3, r) {
    const s6 = await this.databaseType(), a5 = new b2();
    if (this._requestStandardised && (a5.sqlFormat = "standard"), this.isTable() && i3 && null !== t4 && "" !== t4)
      return { calculated: true, result: 0 };
    let n9 = null === r ? null === i3 ? "1=1" : "" : n5(r, s6);
    this._layer.definitionExpression && this._useDefinitionExpression && (n9 = "" !== n9 ? "((" + this._layer.definitionExpression + ") AND (" + n9 + "))" : this._layer.definitionExpression), a5.where = n9, a5.where = n9, a5.spatialRelationship = this._makeRelationshipEnum(t4), a5.relationParameter = this._makeRelationshipParam(t4), a5.geometry = null === i3 ? null : i3, a5.returnGeometry = false;
    return { calculated: true, result: await this.executeQuery(a5, "executeForCount") };
  }
  async _stats(e4, t4, i3, r, s6, a5, n9) {
    await this._ensureLoaded();
    const l2 = this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsSqlExpression, o2 = this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsStatistics, u2 = this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsDistinct;
    if ("count" === e4)
      return u2 ? this._countstat(e4, i3, r, s6) : { calculated: false };
    if (false === o2 || false === E(t4) && false === l2 || false === t4.isStandardized)
      return "" !== i3 || null !== s6 ? { calculated: false } : this._manualStat(e4, t4, a5, n9);
    if ("distinct" === e4)
      return false === u2 ? "" !== i3 || null !== s6 ? { calculated: false } : this._manualStat(e4, t4, a5, n9) : this._distinctStat(e4, t4, i3, r, s6, a5, n9);
    const p2 = await this.databaseType();
    if (this.isTable() && r && null !== i3 && "" !== i3)
      return { calculated: true, result: null };
    const y3 = new b2();
    this._requestStandardised && (y3.sqlFormat = "standard");
    let f3 = null === s6 ? null === r ? "1=1" : "" : n5(s6, p2);
    this._layer.definitionExpression && this._useDefinitionExpression && (f3 = "" !== f3 ? "((" + this._layer.definitionExpression + ") AND (" + f3 + "))" : this._layer.definitionExpression), y3.where = f3, y3.spatialRelationship = this._makeRelationshipEnum(i3), y3.relationParameter = this._makeRelationshipParam(i3), y3.geometry = null === r ? null : r;
    const _2 = new m2();
    _2.statisticType = h2(e4), _2.onStatisticField = n5(t4, p2), _2.outStatisticFieldName = "ARCADE_STAT_RESULT", y3.returnGeometry = false;
    let m4 = "ARCADE_STAT_RESULT";
    y3.outStatistics = [_2];
    const g3 = await this.executeQuery(y3, "execute");
    if (!g3.hasOwnProperty("features") || 0 === g3.features.length)
      throw new Error("Unnexected Result querying statistics from layer");
    let F3 = false;
    for (let d6 = 0; d6 < g3.fields.length; d6++)
      if ("ARCADE_STAT_RESULT" === g3.fields[d6].name.toUpperCase()) {
        m4 = g3.fields[d6].name, "date" === g3.fields[d6].type && (F3 = true);
        break;
      }
    if (F3) {
      let e5 = g3.features[0].attributes[m4];
      return null !== e5 && (e5 = new Date(g3.features[0].attributes[m4])), { calculated: true, result: e5 };
    }
    return { calculated: true, result: g3.features[0].attributes[m4] };
  }
  _stat(e4, t4, i3, r, s6, a5, n9) {
    return this._stats(e4, t4, i3, r, s6, a5, n9);
  }
  async _canDoAggregates(e4, t4) {
    await this._ensureLoaded();
    let i3 = false;
    const r = this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsSqlExpression;
    if (void 0 !== this._layer.capabilities && null !== this._layer.capabilities.query && true === this._layer.capabilities.query.supportsStatistics && true === this._layer.capabilities.query.supportsOrderBy && (i3 = true), i3)
      for (let s6 = 0; s6 < t4.length - 1; s6++)
        null !== t4[s6].workingexpr && (false === t4[s6].workingexpr.isStandardized || false === E(t4[s6].workingexpr) && false === r) && (i3 = false);
    return false !== i3;
  }
  _makeRelationshipEnum(e4) {
    if (e4.includes("esriSpatialRelRelation"))
      return "relation";
    switch (e4) {
      case "esriSpatialRelRelation":
        return "relation";
      case "esriSpatialRelIntersects":
        return "intersects";
      case "esriSpatialRelContains":
        return "contains";
      case "esriSpatialRelOverlaps":
        return "overlaps";
      case "esriSpatialRelWithin":
        return "within";
      case "esriSpatialRelTouches":
        return "touches";
      case "esriSpatialRelCrosses":
        return "crosses";
      case "esriSpatialRelEnvelopeIntersects":
        return "envelope-intersects";
    }
    return e4;
  }
  _makeRelationshipParam(e4) {
    return e4.includes("esriSpatialRelRelation") ? e4.split(":")[1] : "";
  }
  async _getAggregatePagesDataSourceDefinition(e4, t4, i3, r, a5, n9, l2) {
    await this._ensureLoaded();
    const o2 = await this.databaseType();
    let u2 = "", h4 = false, c3 = false;
    null !== n9 && this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsOrderBy && (u2 = n9.constructClause(), c3 = true), this._layer.capabilities && this._layer.capabilities.query && false === this._layer.capabilities.query.supportsPagination && (c3 = false, h4 = true, u2 = this._layer.objectIdField);
    const p2 = [];
    for (let s6 = 0; s6 < t4.length; s6++) {
      const e5 = new m2();
      e5.onStatisticField = null !== t4[s6].workingexpr ? n5(t4[s6].workingexpr, o2) : "", e5.outStatisticFieldName = t4[s6].field, e5.statisticType = t4[s6].toStatisticsName(), p2.push(e5);
    }
    "" === u2 && (u2 = e4.join(","));
    let y3 = this._maxQueryRate();
    const f3 = this._layer.capabilities.query.maxRecordCount;
    void 0 !== f3 && f3 < y3 && (y3 = f3);
    let _2 = null === a5 ? null === r ? "1=1" : "" : n5(a5, o2);
    this._layer.definitionExpression && this._useDefinitionExpression && (_2 = "" !== _2 ? "((" + this._layer.definitionExpression + ") AND (" + _2 + "))" : this._layer.definitionExpression);
    return new t2([], ["GETPAGES"], c3, { groupbypage: true, spatialRel: this._makeRelationshipEnum(i3), relationParam: this._makeRelationshipParam(i3), outFields: ["*"], useOIDpagination: h4, generatedOid: l2, resultRecordCount: y3, resultOffset: 0, groupByFieldsForStatistics: e4, outStatistics: p2, geometry: null === r ? null : r, where: _2, orderByFields: u2, returnGeometry: false, returnIdsOnly: false, internal: { lastMaxId: -1, set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } });
  }
  async _getAgregagtePhysicalPage(t4, i3, r) {
    let s6 = t4.pagesDefinition.where;
    true === t4.pagesDefinition.useOIDpagination && (s6 = "" !== s6 ? "(" + s6 + ") AND (" + t4.pagesDefinition.generatedOid + ">" + t4.pagesDefinition.internal.lastMaxId.toString() + ")" : t4.pagesDefinition.generatedOid + ">" + t4.pagesDefinition.internal.lastMaxId.toString());
    const a5 = t4.pagesDefinition.internal.lastRetrieved, n9 = a5, l2 = t4.pagesDefinition.internal.lastPage, o2 = new b2();
    if (this._requestStandardised && (o2.sqlFormat = "standard"), o2.where = s6, o2.spatialRelationship = t4.pagesDefinition.spatialRel, o2.relationParameter = t4.pagesDefinition.relationParam, o2.outFields = t4.pagesDefinition.outFields, o2.outStatistics = t4.pagesDefinition.outStatistics, o2.geometry = t4.pagesDefinition.geometry, o2.groupByFieldsForStatistics = t4.pagesDefinition.groupByFieldsForStatistics, o2.num = t4.pagesDefinition.resultRecordCount, o2.start = t4.pagesDefinition.internal.lastPage, o2.returnGeometry = t4.pagesDefinition.returnGeometry, o2.orderByFields = "" !== t4.pagesDefinition.orderByFields ? t4.pagesDefinition.orderByFields.split(",") : null, this.isTable() && o2.geometry && o2.spatialRelationship)
      return [];
    const u2 = await this.executeQuery(o2, "execute");
    if (this._checkCancelled(r), !u2.hasOwnProperty("features"))
      throw new Error("Unnexected Result querying aggregates from layer");
    const d6 = [];
    if (t4.pagesDefinition.internal.lastPage !== l2)
      return [];
    for (let e4 = 0; e4 < u2.features.length; e4++)
      t4.pagesDefinition.internal.set[n9 + e4] = u2.features[e4].attributes[t4.pagesDefinition.generatedOid];
    for (let h4 = 0; h4 < u2.features.length; h4++)
      d6.push(new g({ attributes: u2.features[h4].attributes, geometry: null }));
    return true === t4.pagesDefinition.useOIDpagination ? 0 === u2.features.length ? t4.pagesDefinition.internal.fullyResolved = true : t4.pagesDefinition.internal.lastMaxId = u2.features[u2.features.length - 1].attributes[t4.pagesDefinition.generatedOid] : (void 0 === u2.exceededTransferLimit && u2.features.length !== t4.pagesDefinition.resultRecordCount || false === u2.exceededTransferLimit) && (t4.pagesDefinition.internal.fullyResolved = true), t4.pagesDefinition.internal.lastRetrieved = a5 + u2.features.length, t4.pagesDefinition.internal.lastPage += t4.pagesDefinition.resultRecordCount, d6;
  }
  static create(e4, t4, i3, r, s6) {
    const a5 = new Ke({ url: e4, outFields: null === t4 ? ["*"] : t4 });
    return new P({ layer: a5, spatialReference: i3, lrucache: r, interceptor: s6 });
  }
  relationshipMetaData() {
    return this._layer && this._layer.source && this._layer.source.sourceJSON && this._layer.source.sourceJSON.relationships ? this._layer.source.sourceJSON.relationships : [];
  }
  serviceUrl() {
    return b(this._layer.parsedUrl.path);
  }
  async queryAttachments(e4, t4, r, s6, a5) {
    if (this._layer.capabilities.data.supportsAttachment && this._layer.capabilities.operations.supportsQueryAttachments) {
      const n9 = { objectIds: [e4], returnMetadata: a5 };
      (t4 && t4 > 0 || r && r > 0) && (n9.size = [t4 && t4 > 0 ? t4 : 0, r && r > 0 ? r : t4 + 1]), s6 && s6.length > 0 && (n9.attachmentTypes = s6), this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preLayerQueryCallback({ layer: this._layer, query: n9, method: "attachments" });
      const l2 = await this._layer.queryAttachments(n9), o2 = [];
      return l2 && l2[e4] && l2[e4].forEach((t5) => {
        const r2 = this._layer.parsedUrl.path + "/" + e4.toString() + "/attachments/" + t5.id.toString();
        let s7 = null;
        a5 && t5.exifInfo && (s7 = d2.convertJsonToArcade(t5.exifInfo, true)), o2.push(new e(t5.id, t5.name, t5.contentType, t5.size, r2, s7));
      }), o2;
    }
    return [];
  }
  async queryRelatedFeatures(i3) {
    const r = { f: "json", relationshipId: i3.relationshipId.toString(), definitionExpression: i3.where, outFields: i3.outFields.join(","), returnGeometry: i3.returnGeometry.toString() };
    void 0 !== i3.resultOffset && null !== i3.resultOffset && (r.resultOffset = i3.resultOffset.toString()), void 0 !== i3.resultRecordCount && null !== i3.resultRecordCount && (r.resultRecordCount = i3.resultRecordCount.toString()), i3.orderByFields && (r.orderByFields = i3.orderByFields.join(",")), i3.objectIds.length > 0 && (r.objectIds = i3.objectIds.join(",")), i3.outSpatialReference && (r.outSR = JSON.stringify(i3.outSpatialReference.toJSON())), this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preRequestCallback({ layer: this._layer, queryPayload: r, method: "relatedrecords", url: this._layer.parsedUrl.path + "/queryRelatedRecords" });
    const s6 = await U(this._layer.parsedUrl.path + "/queryRelatedRecords", { responseType: "json", query: r });
    if (s6.data) {
      const t4 = {}, i4 = s6.data;
      if (i4 && i4.relatedRecordGroups) {
        const r2 = i4.spatialReference;
        for (const s7 of i4.relatedRecordGroups) {
          const a5 = s7.objectId, n9 = [];
          for (const t5 of s7.relatedRecords) {
            t5.geometry && (t5.geometry.spatialReference = r2);
            const i5 = new g({ geometry: t5.geometry ? d(t5.geometry) : null, attributes: t5.attributes });
            n9.push(i5);
          }
          t4[a5] = { features: n9, exceededTransferLimit: true === i4.exceededTransferLimit };
        }
      }
      return t4;
    }
    throw new Error("Invalid Request");
  }
  async getFeatureByObjectId(e4, t4) {
    const i3 = new b2();
    i3.outFields = t4, i3.returnGeometry = false, i3.outSpatialReference = this.spatialReference, i3.where = this.objectIdField + "=" + e4.toString(), this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preLayerQueryCallback({ layer: this._layer, query: i3, method: "execute" });
    const r = await s(this._layer.parsedUrl.path, i3);
    return 1 === r.features.length ? r.features[0] : null;
  }
  async getIdentityUser() {
    var _a;
    await this.load();
    const e4 = (_a = n2) == null ? void 0 : _a.findCredential(this._layer.url);
    return e4 ? e4.userId : null;
  }
  async getOwningSystemUrl() {
    var _a;
    await this.load();
    const e4 = (_a = n2) == null ? void 0 : _a.findServerInfo(this._layer.url);
    if (e4)
      return e4.owningSystemUrl;
    let i3 = this._layer.url;
    const r = i3.toLowerCase().indexOf("/rest/services");
    if (i3 = r > -1 ? i3.substring(0, r) : i3, i3) {
      i3 += "/rest/info";
      try {
        const e5 = await U(i3, { query: { f: "json" } });
        let r2 = "";
        return e5.data && e5.data.owningSystemUrl && (r2 = e5.data.owningSystemUrl), r2;
      } catch (s6) {
        return "";
      }
    }
    return "";
  }
  getDataSourceFeatureSet() {
    const e4 = new P({ layer: this._layer, spatialReference: this.spatialReference, outFields: this._overrideFields, includeGeometry: !this._removeGeometry, lrucache: this.recentlyUsedQueries, interceptor: this.featureSetQueryInterceptor });
    return e4._useDefinitionExpression = false, e4;
  }
};

// node_modules/@arcgis/core/arcade/featureset/sources/FeatureLayerMemory.js
var y2 = class extends k3 {
  constructor(e4) {
    super(e4), this.declaredClass = "esri.arcade.featureset.sources.FeatureLayerMemory", this._removeGeometry = false, this._overrideFields = null, this._forceIsTable = false, e4.spatialReference && (this.spatialReference = e4.spatialReference), this._transparent = true, this._maxProcessing = 1e3, this._layer = e4.layer, this._wset = null, true === e4.isTable && (this._forceIsTable = true), void 0 !== e4.outFields && (this._overrideFields = e4.outFields), void 0 !== e4.includeGeometry && (this._removeGeometry = false === e4.includeGeometry);
  }
  _maxQueryRate() {
    return F;
  }
  end() {
    return this._layer;
  }
  optimisePagingFeatureQueries() {
  }
  async loadImpl() {
    return true === this._layer.loaded ? (this._initialiseFeatureSet(), this) : (await this._layer.load(), this._initialiseFeatureSet(), this);
  }
  get gdbVersion() {
    return "";
  }
  _initialiseFeatureSet() {
    if (null == this.spatialReference && (this.spatialReference = this._layer.spatialReference), this.geometryType = this._layer.geometryType, this.fields = this._layer.fields.slice(0), this._layer.outFields)
      if (1 === this._layer.outFields.length && "*" === this._layer.outFields[0])
        ;
      else {
        const e4 = [];
        for (const t4 of this.fields)
          if ("oid" === t4.type)
            e4.push(t4);
          else
            for (const s6 of this._layer.outFields)
              if (s6.toLowerCase() === t4.name.toLowerCase()) {
                e4.push(t4);
                break;
              }
        this.fields = e4;
      }
    else
      ;
    if (null !== this._overrideFields)
      if (1 === this._overrideFields.length && "*" === this._overrideFields[0])
        this._overrideFields = null;
      else {
        const e4 = [], t4 = [];
        for (const s6 of this.fields)
          if ("oid" === s6.type)
            e4.push(s6), t4.push(s6.name);
          else
            for (const r of this._overrideFields)
              if (r.toLowerCase() === s6.name.toLowerCase()) {
                e4.push(s6), t4.push(s6.name);
                break;
              }
        this.fields = e4, this._overrideFields = t4;
      }
    this.objectIdField = this._layer.objectIdField;
    for (const e4 of this.fields)
      "global-id" === e4.type && (this.globalIdField = e4.name);
    this.hasM = this._layer.supportsM, this.hasZ = this._layer.supportsZ, this._databaseType = t.Standardised, this.typeIdField = this._layer.typeIdField, this.types = this._layer.types;
  }
  isTable() {
    return this._forceIsTable || this._layer.isTable || "table" === this._layer.type || !this._layer.geometryType;
  }
  _isInFeatureSet() {
    return i.InFeatureSet;
  }
  _candidateIdTransform(e4) {
    return e4;
  }
  async _getSet(e4) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._getFilteredSet("", null, null, null, e4);
      return this._wset = t4, t4;
    }
    return this._wset;
  }
  _changeFeature(t4) {
    const s6 = {};
    for (const e4 of this.fields)
      s6[e4.name] = t4.attributes[e4.name];
    return new g({ geometry: true === this._removeGeometry ? null : t4.geometry, attributes: s6 });
  }
  async _getFilteredSet(e4, t4, r, a5, n9) {
    let o2 = "", u2 = false;
    if (null !== a5 && (o2 = a5.constructClause(), u2 = true), this.isTable() && t4 && null !== e4 && "" !== e4) {
      return new t2([], [], true, null);
    }
    const h4 = new b2();
    h4.where = null === r ? null === t4 ? "1=1" : "" : n5(r, t.Standardised), h4.spatialRelationship = this._makeRelationshipEnum(e4), h4.outSpatialReference = this.spatialReference, h4.orderByFields = "" !== o2 ? o2.split(",") : null, h4.geometry = null === t4 ? null : t4, h4.returnGeometry = true, h4.relationParameter = this._makeRelationshipParam(e4);
    const y3 = await this._layer.queryFeatures(h4);
    if (null === y3)
      return new t2([], [], u2, null);
    this._checkCancelled(n9);
    const d6 = [];
    y3.features.forEach((e5) => {
      const t5 = e5.attributes[this._layer.objectIdField];
      d6.push(t5), this._featureCache[t5] = this._changeFeature(e5);
    });
    return new t2([], d6, u2, null);
  }
  _makeRelationshipEnum(e4) {
    if (e4.includes("esriSpatialRelRelation"))
      return "relation";
    switch (e4) {
      case "esriSpatialRelRelation":
        return "relation";
      case "esriSpatialRelIntersects":
        return "intersects";
      case "esriSpatialRelContains":
        return "contains";
      case "esriSpatialRelOverlaps":
        return "overlaps";
      case "esriSpatialRelWithin":
        return "within";
      case "esriSpatialRelTouches":
        return "touches";
      case "esriSpatialRelCrosses":
        return "crosses";
      case "esriSpatialRelEnvelopeIntersects":
        return "envelope-intersects";
    }
    return e4;
  }
  _makeRelationshipParam(e4) {
    return e4.includes("esriSpatialRelRelation") ? e4.split(":")[1] : "";
  }
  async _queryAllFeatures() {
    if (this._wset)
      return this._wset;
    const e4 = new b2();
    if (e4.where = "1=1", await this._ensureLoaded(), this._layer.source && this._layer.source.items) {
      const e5 = [];
      return this._layer.source.items.forEach((t5) => {
        const s6 = t5.attributes[this._layer.objectIdField];
        e5.push(s6), this._featureCache[s6] = this._changeFeature(t5);
      }), this._wset = new t2([], e5, false, null), this._wset;
    }
    const t4 = await this._layer.queryFeatures(e4), r = [];
    return t4.features.forEach((e5) => {
      const t5 = e5.attributes[this._layer.objectIdField];
      r.push(t5), this._featureCache[t5] = this._changeFeature(e5);
    }), this._wset = new t2([], r, false, null), this._wset;
  }
  async _getFeatures(e4, t4, s6) {
    const r = [];
    -1 !== t4 && void 0 === this._featureCache[t4] && r.push(t4);
    for (let i3 = e4._lastFetchedIndex; i3 < e4._known.length && (e4._lastFetchedIndex += 1, !(void 0 === this._featureCache[e4._known[i3]] && (e4._known[i3] !== t4 && r.push(e4._known[i3]), r.length > s6))); i3++)
      ;
    if (0 === r.length)
      return "success";
    throw new Error("Unaccounted for Features. Not in Feature Collection");
  }
  async _refineSetBlock(e4) {
    return e4;
  }
  async _stat() {
    return { calculated: false };
  }
  async _canDoAggregates() {
    return false;
  }
  relationshipMetaData() {
    return [];
  }
  static _cloneAttr(e4) {
    const t4 = {};
    for (const s6 in e4)
      t4[s6] = e4[s6];
    return t4;
  }
  nativeCapabilities() {
    return { title: this._layer.title, canQueryRelated: false, source: this, capabilities: this._layer.capabilities, databaseType: this._databaseType, requestStandardised: true };
  }
  static create(e4, t4) {
    let s6 = e4.layerDefinition.objectIdField;
    const r = e4.layerDefinition.typeIdField ? e4.layerDefinition.typeIdField : "", i3 = [];
    if (e4.layerDefinition.types)
      for (const n9 of e4.layerDefinition.types)
        i3.push(n3.fromJSON(n9));
    let a5 = e4.layerDefinition.geometryType;
    void 0 === a5 && (a5 = e4.featureSet.geometryType || "");
    let l2 = e4.featureSet.features;
    const c3 = t4.toJSON();
    if ("" === s6 || void 0 === s6) {
      let t5 = false;
      for (const r2 of e4.layerDefinition.fields)
        if ("oid" === r2.type || "esriFieldTypeOID" === r2.type) {
          s6 = r2.name, t5 = true;
          break;
        }
      if (false === t5) {
        let t6 = "FID", r2 = true, i4 = 0;
        for (; r2; ) {
          let s7 = true;
          for (const r3 of e4.layerDefinition.fields)
            if (r3.name === t6) {
              s7 = false;
              break;
            }
          true === s7 ? r2 = false : (i4++, t6 = "FID" + i4.toString());
        }
        e4.layerDefinition.fields.push({ type: "esriFieldTypeOID", name: t6, alias: t6 });
        const a6 = [];
        for (let s7 = 0; s7 < l2.length; s7++)
          a6.push({ geometry: e4.featureSet.features[s7].geometry, attributes: e4.featureSet.features[s7].attributes ? this._cloneAttr(e4.featureSet.features[s7].attributes) : {} }), a6[s7].attributes[t6] = s7;
        l2 = a6, s6 = t6;
      }
    }
    const d6 = [];
    for (const n9 of e4.layerDefinition.fields)
      n9 instanceof y ? d6.push(n9) : d6.push(y.fromJSON(n9));
    let f3 = a5;
    switch (f3) {
      case "esriGeometryPoint":
        f3 = "point";
        break;
      case "esriGeometryPolyline":
        f3 = "polyline";
        break;
      case "esriGeometryPolygon":
        f3 = "polygon";
        break;
      case "esriGeometryExtent":
        f3 = "extent";
        break;
      case "esriGeometryMultipoint":
        f3 = "multipoint";
    }
    for (const o2 of l2)
      o2.geometry && o2.geometry instanceof p == false && (o2.geometry.type = f3, void 0 === o2.geometry.spatialReference && (o2.geometry.spatialReference = c3));
    const p2 = { outFields: ["*"], source: l2, fields: d6, types: i3, typeIdField: r, objectIdField: s6, spatialReference: t4 };
    p2.geometryType = f3 || "point";
    const _2 = new Ke(p2);
    return new y2({ layer: _2, spatialReference: t4, isTable: null === f3 || "" === f3 });
  }
  async queryAttachments() {
    return [];
  }
  async getFeatureByObjectId(e4) {
    const t4 = new b2();
    t4.where = this.objectIdField + "=" + e4.toString();
    const s6 = await this._layer.queryFeatures(t4);
    return 1 === s6.features.length ? s6.features[0] : null;
  }
  async getOwningSystemUrl() {
    return "";
  }
  async getIdentityUser() {
    return "";
  }
};

// node_modules/@arcgis/core/arcade/featureset/sources/FeatureLayerRelated.js
var n8 = class extends k3 {
  constructor(e4) {
    super(e4), this.declaredClass = "esri.arcade.featureset.sources.FeatureLayerRelated", this._findObjectId = -1, this._requestStandardised = false, this._removeGeometry = false, this._overrideFields = null, this.featureObjectId = null, this.relatedLayer = null, this.relationship = null, e4.spatialReference && (this.spatialReference = e4.spatialReference), this._transparent = true, this._maxProcessing = 1e3, this._layer = e4.layer, this._wset = null, this._findObjectId = e4.objectId, this.featureObjectId = e4.objectId, this.relationship = e4.relationship, this.relatedLayer = e4.relatedLayer, void 0 !== e4.outFields && (this._overrideFields = e4.outFields), void 0 !== e4.includeGeometry && (this._removeGeometry = false === e4.includeGeometry);
  }
  _maxQueryRate() {
    return F;
  }
  end() {
    return this._layer;
  }
  optimisePagingFeatureQueries() {
  }
  async loadImpl() {
    return await Promise.all([this._layer.load(), this.relatedLayer.load()]), this._initialiseFeatureSet(), this;
  }
  nativeCapabilities() {
    return this.relatedLayer.nativeCapabilities();
  }
  _initialiseFeatureSet() {
    if (null == this.spatialReference && (this.spatialReference = this._layer.spatialReference), this.geometryType = this.relatedLayer.geometryType, this.fields = this.relatedLayer.fields.slice(0), null !== this._overrideFields)
      if (1 === this._overrideFields.length && "*" === this._overrideFields[0])
        this._overrideFields = null;
      else {
        const e5 = [], t4 = [];
        for (const i3 of this.fields)
          if ("oid" === i3.type)
            e5.push(i3), t4.push(i3.name);
          else
            for (const r of this._overrideFields)
              if (r.toLowerCase() === i3.name.toLowerCase()) {
                e5.push(i3), t4.push(i3.name);
                break;
              }
        this.fields = e5, this._overrideFields = t4;
      }
    const e4 = this._layer.nativeCapabilities();
    e4 && (this._databaseType = e4.databaseType, this._requestStandardised = e4.requestStandardised), this.objectIdField = this.relatedLayer.objectIdField, this.globalIdField = this.relatedLayer.globalIdField, this.hasM = this.relatedLayer.supportsM, this.hasZ = this.relatedLayer.supportsZ, this.typeIdField = this.relatedLayer.typeIdField, this.types = this.relatedLayer.types;
  }
  async databaseType() {
    return await this.relatedLayer.databaseType(), this._databaseType = this.relatedLayer._databaseType, this._databaseType;
  }
  isTable() {
    return this.relatedLayer.isTable();
  }
  _isInFeatureSet() {
    return i.InFeatureSet;
  }
  _candidateIdTransform(e4) {
    return e4;
  }
  async _getSet(e4) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._getFilteredSet("", null, null, null, e4);
      return this._wset = t4, t4;
    }
    return this._wset;
  }
  _changeFeature(t4) {
    const i3 = {};
    for (const e4 of this.fields)
      i3[e4.name] = t4.attributes[e4.name];
    return new g({ geometry: true === this._removeGeometry ? null : t4.geometry, attributes: i3 });
  }
  async _getFilteredSet(e4, t4, r, s6, n9) {
    if (await this.databaseType(), this.isTable() && t4 && null !== e4 && "" !== e4) {
      return new t2([], [], true, null);
    }
    const l2 = this._layer.nativeCapabilities();
    if (false === l2.canQueryRelated) {
      return new t2([], [], true, null);
    }
    if (l2.capabilities.queryRelated && l2.capabilities.queryRelated.supportsPagination)
      return this._getFilteredSetUsingPaging(e4, t4, r, s6, n9);
    let d6 = "", o2 = false;
    null !== s6 && l2.capabilities && l2.capabilities.queryRelated && true === l2.capabilities.queryRelated.supportsOrderBy && (d6 = s6.constructClause(), o2 = true);
    const u2 = new d5();
    u2.objectIds = [this._findObjectId];
    const h4 = null !== this._overrideFields ? this._overrideFields : this._fieldsIncludingObjectId(this.relatedLayer.fields ? this.relatedLayer.fields.map((e5) => e5.name) : ["*"]);
    u2.outFields = h4, u2.relationshipId = this.relationship.id, u2.where = "1=1";
    let c3 = true;
    true === this._removeGeometry && (c3 = false), u2.returnGeometry = c3, this._requestStandardised && (u2.sqlFormat = "standard"), u2.outSpatialReference = this.spatialReference, u2.orderByFields = "" !== d6 ? d6.split(",") : null;
    const y3 = await l2.source.queryRelatedFeatures(u2);
    this._checkCancelled(n9);
    const p2 = y3[this._findObjectId] ? y3[this._findObjectId].features : [], f3 = [];
    for (let i3 = 0; i3 < p2.length; i3++)
      this._featureCache[p2[i3].attributes[this.relatedLayer.objectIdField]] = p2[i3], f3.push(p2[i3].attributes[this.relatedLayer.objectIdField]);
    const g3 = t4 && null !== e4 && "" !== e4, _2 = null != r;
    return new t2(g3 || _2 ? f3 : [], g3 || _2 ? [] : f3, o2, null);
  }
  _fieldsIncludingObjectId(e4) {
    if (null === e4)
      return [this.objectIdField];
    const t4 = e4.slice(0);
    if (t4.includes("*"))
      return t4;
    let i3 = false;
    for (const r of t4)
      if (r.toUpperCase() === this.objectIdField.toUpperCase()) {
        i3 = true;
        break;
      }
    return false === i3 && t4.push(this.objectIdField), t4;
  }
  async _getFilteredSetUsingPaging(e4, t4, r, s6, a5) {
    let n9 = "", l2 = false;
    const d6 = this._layer.nativeCapabilities();
    null !== s6 && d6 && d6.capabilities.queryRelated && true === d6.capabilities.queryRelated.supportsOrderBy && (n9 = s6.constructClause(), l2 = true), await this.databaseType();
    const o2 = "1=1";
    let u2 = this._maxQueryRate();
    const h4 = d6.capabilities.query.maxRecordCount;
    void 0 !== h4 && h4 < u2 && (u2 = h4);
    const c3 = t4 && null !== e4 && "" !== e4, y3 = null != r;
    let p2 = null, f3 = true;
    true === this._removeGeometry && (f3 = false);
    const g3 = null !== this._overrideFields ? this._overrideFields : this._fieldsIncludingObjectId(this.relatedLayer.fields ? this.relatedLayer.fields.map((e5) => e5.name) : ["*"]);
    return p2 = new t2(c3 || y3 ? ["GETPAGES"] : [], c3 || y3 ? [] : ["GETPAGES"], l2, { outFields: g3.join(","), resultRecordCount: u2, resultOffset: 0, objectIds: [this._findObjectId], where: o2, orderByFields: n9, returnGeometry: f3, returnIdsOnly: "false", internal: { set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } }), await this._expandPagedSet(p2, u2, 0, 0, a5), p2;
  }
  _expandPagedSet(e4, t4, i3, r, s6) {
    return this._expandPagedSetFeatureSet(e4, t4, i3, r, s6);
  }
  _clonePageDefinition(e4) {
    return null === e4 ? null : true !== e4.groupbypage ? { groupbypage: false, outFields: e4.outFields, resultRecordCount: e4.resultRecordCount, resultOffset: e4.resultOffset, where: e4.where, objectIds: e4.objectIds, orderByFields: e4.orderByFields, returnGeometry: e4.returnGeometry, returnIdsOnly: e4.returnIdsOnly, internal: e4.internal } : { groupbypage: true, outFields: e4.outFields, resultRecordCount: e4.resultRecordCount, useOIDpagination: e4.useOIDpagination, generatedOid: e4.generatedOid, groupByFieldsForStatistics: e4.groupByFieldsForStatistics, resultOffset: e4.resultOffset, outStatistics: e4.outStatistics, geometry: e4.geometry, where: e4.where, objectIds: e4.objectIds, orderByFields: e4.orderByFields, returnGeometry: e4.returnGeometry, returnIdsOnly: e4.returnIdsOnly, internal: e4.internal };
  }
  async _getPhysicalPage(e4, t4, i3) {
    const r = e4.pagesDefinition.internal.lastRetrieved, s6 = r, n9 = e4.pagesDefinition.internal.lastPage, l2 = this._layer.nativeCapabilities(), d6 = new d5();
    true === this._requestStandardised && (d6.sqlFormat = "standard"), d6.relationshipId = this.relationship.id, d6.objectIds = e4.pagesDefinition.objectIds, d6.resultOffset = e4.pagesDefinition.internal.lastPage, d6.resultRecordCount = e4.pagesDefinition.resultRecordCount, d6.outFields = e4.pagesDefinition.outFields.split(","), d6.where = e4.pagesDefinition.where, d6.orderByFields = "" !== e4.pagesDefinition.orderByFields ? e4.pagesDefinition.orderByFields.split(",") : null, d6.returnGeometry = e4.pagesDefinition.returnGeometry, d6.outSpatialReference = this.spatialReference;
    const o2 = await l2.source.queryRelatedFeatures(d6);
    if (this._checkCancelled(i3), e4.pagesDefinition.internal.lastPage !== n9)
      return 0;
    const u2 = o2[this._findObjectId] ? o2[this._findObjectId].features : [];
    for (let a5 = 0; a5 < u2.length; a5++)
      e4.pagesDefinition.internal.set[s6 + a5] = u2[a5].attributes[this.relatedLayer.objectIdField];
    for (let a5 = 0; a5 < u2.length; a5++)
      this._featureCache[u2[a5].attributes[this.relatedLayer.objectIdField]] = u2[a5];
    const h4 = !o2[this._findObjectId] || false === o2[this._findObjectId].exceededTransferLimit;
    return u2.length !== e4.pagesDefinition.resultRecordCount && h4 && (e4.pagesDefinition.internal.fullyResolved = true), e4.pagesDefinition.internal.lastRetrieved = r + u2.length, e4.pagesDefinition.internal.lastPage += e4.pagesDefinition.resultRecordCount, u2.length;
  }
  async _getFeatures(e4, t4, i3, r) {
    const s6 = [];
    -1 !== t4 && void 0 === this._featureCache[t4] && s6.push(t4);
    const a5 = this._maxQueryRate();
    if (true === this._checkIfNeedToExpandKnownPage(e4, a5))
      return await this._expandPagedSet(e4, a5, 0, 0, r), this._getFeatures(e4, t4, i3, r);
    let n9 = 0;
    for (let l2 = e4._lastFetchedIndex; l2 < e4._known.length && (n9++, n9 <= i3 && (e4._lastFetchedIndex += 1), !("GETPAGES" !== e4._known[l2] && void 0 === this._featureCache[e4._known[l2]] && (e4._known[l2] !== t4 && s6.push(e4._known[l2]), s6.length > i3))) && !(n9 >= i3 && 0 === s6.length); l2++)
      ;
    if (0 === s6.length)
      return "success";
    throw new Error("Unaccounted for Features. Not in Feature Collection");
  }
  async _refineSetBlock(e4, t4, i3) {
    return e4;
  }
  async _stat(e4, t4, i3, r, s6, a5, n9) {
    return { calculated: false };
  }
  get gdbVersion() {
    return this.relatedLayer.gdbVersion;
  }
  async _canDoAggregates(e4, t4, i3, r, s6) {
    return false;
  }
  relationshipMetaData() {
    return this.relatedLayer.relationshipMetaData();
  }
  serviceUrl() {
    return this.relatedLayer.serviceUrl();
  }
  queryAttachments(e4, t4, i3, r, s6) {
    return this.relatedLayer.queryAttachments(e4, t4, i3, r, s6);
  }
  getFeatureByObjectId(e4, t4) {
    return this.relatedLayer.getFeatureByObjectId(e4, t4);
  }
  getOwningSystemUrl() {
    return this.relatedLayer.getOwningSystemUrl();
  }
  getIdentityUser() {
    return this.relatedLayer.getIdentityUser();
  }
  getDataSourceFeatureSet() {
    return this.relatedLayer;
  }
};

// node_modules/@arcgis/core/arcade/featureSetUtils.js
function _() {
  null === a2.applicationCache && (a2.applicationCache = new a2());
}
async function w2(e4, t4) {
  if (a2.applicationCache) {
    const r = a2.applicationCache.getLayerInfo(e4);
    if (r) {
      const a5 = await r;
      return new Ke({ url: e4, outFields: t4, sourceJSON: a5 });
    }
    const n9 = new Ke({ url: e4, outFields: t4 }), i3 = (async () => (await n9.load(), n9.sourceJSON))();
    if (a2.applicationCache) {
      a2.applicationCache.setLayerInfo(e4, i3);
      try {
        return await i3, n9;
      } catch (a5) {
        throw a2.applicationCache.clearLayerInfo(e4), a5;
      }
    }
    return await i3, n9;
  }
  return new Ke({ url: e4, outFields: t4 });
}
async function I(e4, t4, a5, r, n9, i3 = null) {
  return S3(await w2(e4, ["*"]), t4, a5, r, n9, i3);
}
function S3(e4, t4 = null, a5 = null, r = true, n9 = null, i3 = null) {
  return true === e4._hasMemorySource() ? new y2({ layer: e4, spatialReference: t4, outFields: a5, includeGeometry: r, lrucache: n9, interceptor: i3 }) : new P({ layer: e4, spatialReference: t4, outFields: a5, includeGeometry: r, lrucache: n9, interceptor: i3 });
}
async function N2(e4) {
  if (null !== a2.applicationCache) {
    const t4 = a2.applicationCache.getLayerInfo(e4);
    if (null !== t4)
      return t4;
  }
  const a5 = (async () => {
    const a6 = await U(e4, { responseType: "json", query: { f: "json" } });
    return a6.data ? a6.data : null;
  })();
  if (null !== a2.applicationCache) {
    a2.applicationCache.setLayerInfo(e4, a5);
    try {
      return await a5;
    } catch (r) {
      throw a2.applicationCache.clearLayerInfo(e4), r;
    }
  }
  return a5;
}
async function F2(e4, a5) {
  const r = "QUERYDATAELEMTS:" + a5.toString() + ":" + e4;
  if (null !== a2.applicationCache) {
    const e5 = a2.applicationCache.getLayerInfo(r);
    if (null !== e5)
      return e5;
  }
  const n9 = (async () => {
    const r2 = await U(e4 + "/queryDataElements", { method: "post", responseType: "json", query: { layers: JSON.stringify([a5.toString()]), f: "json" } });
    if (r2.data) {
      const e5 = r2.data;
      if (e5.layerDataElements && e5.layerDataElements[0])
        return e5.layerDataElements[0];
    }
    throw new Error("Not Found");
  })();
  if (null !== a2.applicationCache) {
    a2.applicationCache.setLayerInfo(r, n9);
    try {
      return await n9;
    } catch (i3) {
      throw a2.applicationCache.clearLayerInfo(r), i3;
    }
  }
  return n9;
}
async function T2(e4) {
  if (null !== a2.applicationCache) {
    const t4 = a2.applicationCache.getLayerInfo(e4);
    if (null !== t4)
      return t4;
  }
  const a5 = (async () => {
    const a6 = await U(e4, { responseType: "json", query: { f: "json" } });
    if (a6.data) {
      const e5 = a6.data;
      return e5.layers || (e5.layers = []), e5.tables || (e5.tables = []), e5;
    }
    return { layers: [], tables: [] };
  })();
  if (null !== a2.applicationCache) {
    a2.applicationCache.setLayerInfo(e4, a5);
    try {
      return await a5;
    } catch (r) {
      throw a2.applicationCache.clearLayerInfo(e4), r;
    }
  }
  return a5;
}
async function g2(e4, t4) {
  const a5 = { metadata: null, networkId: -1, unVersion: 3, terminals: [], queryelem: null, layerNameLkp: {}, lkp: null }, r = await T2(e4);
  if (a5.metadata = r, r.controllerDatasetLayers && void 0 !== r.controllerDatasetLayers.utilityNetworkLayerId && null !== r.controllerDatasetLayers.utilityNetworkLayerId) {
    if (r.layers)
      for (const e5 of r.layers)
        a5.layerNameLkp[e5.id] = e5.name;
    if (r.tables)
      for (const e5 of r.tables)
        a5.layerNameLkp[e5.id] = e5.name;
    const n9 = r.controllerDatasetLayers.utilityNetworkLayerId;
    a5.networkId = n9;
    const i3 = await F2(e4, n9);
    if (i3) {
      a5.queryelem = i3, a5.queryelem && a5.queryelem.dataElement && void 0 !== a5.queryelem.dataElement.schemaGeneration && (a5.unVersion = a5.queryelem.dataElement.schemaGeneration), a5.lkp = {}, a5.queryelem.dataElement.domainNetworks || (a5.queryelem.dataElement.domainNetworks = []);
      for (const e5 of a5.queryelem.dataElement.domainNetworks) {
        for (const t5 of e5.edgeSources ? e5.edgeSources : []) {
          const e6 = { layerId: t5.layerId, sourceId: t5.sourceId, className: a5.layerNameLkp[t5.layerId] ? a5.layerNameLkp[t5.layerId] : null };
          e6.className && (a5.lkp[e6.className] = e6);
        }
        for (const t5 of e5.junctionSources ? e5.junctionSources : []) {
          const e6 = { layerId: t5.layerId, sourceId: t5.sourceId, className: a5.layerNameLkp[t5.layerId] ? a5.layerNameLkp[t5.layerId] : null };
          e6.className && (a5.lkp[e6.className] = e6);
        }
      }
      if (a5.queryelem.dataElement.terminalConfigurations)
        for (const e5 of a5.queryelem.dataElement.terminalConfigurations)
          for (const t5 of e5.terminals)
            a5.terminals.push({ terminalId: t5.terminalId, terminalName: t5.terminalName });
      const r2 = await N2(e4 + "/" + n9);
      if (r2.systemLayers && void 0 !== r2.systemLayers.associationsTableId && null !== r2.systemLayers.associationsTableId) {
        const n10 = [];
        a5.unVersion >= 4 && (n10.push("STATUS"), n10.push("PERCENTALONG"));
        let i4 = await I(e4 + "/" + r2.systemLayers.associationsTableId.toString(), t4, ["OBJECTID", "FROMNETWORKSOURCEID", "TONETWORKSOURCEID", "FROMGLOBALID", "TOGLOBALID", "TOTERMINALID", "FROMTERMINALID", "ASSOCIATIONTYPE", "ISCONTENTVISIBLE", "GLOBALID", ...n10], false, null, null);
        return await i4.load(), a5.unVersion >= 4 && (i4 = i4.filter(m.create("STATUS NOT IN (1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 47, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62,63)", i4.getFieldsIndex())), await i4.load()), { lkp: a5.lkp, associations: i4, unVersion: a5.unVersion, terminals: a5.terminals };
      }
      return { associations: null, unVersion: a5.unVersion, lkp: null, terminals: [] };
    }
    return { associations: null, unVersion: a5.unVersion, lkp: null, terminals: [] };
  }
  return { associations: null, unVersion: a5.unVersion, lkp: null, terminals: [] };
}
async function A2(e4, t4, a5, r = null, n9 = null, i3 = true, s6 = null, l2 = null) {
  let o2 = e4.serviceUrl();
  if (!o2)
    return null;
  o2 = "/" === o2.charAt(o2.length - 1) ? o2 + t4.relatedTableId.toString() : o2 + "/" + t4.relatedTableId.toString();
  const u2 = await I(o2, r, n9, i3, s6, l2);
  return new n8({ layer: e4, relatedLayer: u2, relationship: t4, objectId: a5, spatialReference: r, outFields: n9, includeGeometry: i3, lrucache: s6, interceptor: l2 });
}
h3.registerAction(), A.registerAction(), s4.registerAction(), c2.registerAction(), s5.registerAction();
var C2 = class extends e2 {
  constructor(e4, t4 = null, a5 = null, r = null) {
    super(), this._map = e4, this._overridespref = t4, this.lrucache = a5, this.interceptor = r, this._instantLayers = [];
  }
  _makeAndAddFeatureSet(e4, t4 = true, a5 = null) {
    const r = S3(e4, this._overridespref, null === a5 ? ["*"] : a5, t4, this.lrucache, this.interceptor);
    return this._instantLayers.push({ featureset: r, opitem: e4, includeGeometry: t4, outFields: JSON.stringify(a5) }), r;
  }
  async featureSetByName(e4, t4 = true, a5 = null) {
    if (void 0 !== this._map.loaded && void 0 !== this._map.load && false === this._map.loaded)
      return await this._map.load(), this.featureSetByName(e4, t4, a5);
    null === a5 && (a5 = ["*"]), a5 = (a5 = a5.slice(0)).sort();
    const r = JSON.stringify(a5);
    for (let i3 = 0; i3 < this._instantLayers.length; i3++) {
      const a6 = this._instantLayers[i3];
      if (a6.opitem.title === e4 && a6.includeGeometry === t4 && a6.outFields === r)
        return this._instantLayers[i3].featureset;
    }
    const n9 = this._map.allLayers.find((t5) => t5 instanceof Ke && t5.title === e4);
    if (n9)
      return this._makeAndAddFeatureSet(n9, t4, a5);
    if (this._map.tables) {
      const r2 = this._map.tables.find((t5) => !!(t5.title && t5.title === e4 || t5.title && t5.title === e4));
      if (r2) {
        if (r2 instanceof Ke)
          return this._makeAndAddFeatureSet(r2, t4, a5);
        if (r2._materializedTable)
          ;
        else {
          const e5 = r2.outFields ? r2 : { ...r2, outFields: ["*"] };
          r2._materializedTable = new Ke(e5);
        }
        return await r2._materializedTable.load(), this._makeAndAddFeatureSet(r2._materializedTable, t4, a5);
      }
    }
    return null;
  }
  async featureSetById(e4, t4 = true, a5 = ["*"]) {
    if (void 0 !== this._map.loaded && void 0 !== this._map.load && false === this._map.loaded)
      return await this._map.load(), this.featureSetById(e4, t4, a5);
    null === a5 && (a5 = ["*"]), a5 = (a5 = a5.slice(0)).sort();
    const r = JSON.stringify(a5);
    for (let i3 = 0; i3 < this._instantLayers.length; i3++) {
      const a6 = this._instantLayers[i3];
      if (a6.opitem.id === e4 && a6.includeGeometry === t4 && a6.outFields === r)
        return this._instantLayers[i3].featureset;
    }
    const n9 = this._map.allLayers.find((t5) => t5 instanceof Ke && t5.id === e4);
    if (n9)
      return this._makeAndAddFeatureSet(n9, t4, a5);
    if (this._map.tables) {
      const r2 = this._map.tables.find((t5) => t5.id === e4);
      if (r2) {
        if (r2 instanceof Ke)
          return this._makeAndAddFeatureSet(r2, t4, a5);
        if (r2._materializedTable)
          ;
        else {
          const e5 = { ...r2, outFields: ["*"] };
          r2._materializedTable = new Ke(e5);
        }
        return await r2._materializedTable.load(), this._makeAndAddFeatureSet(r2._materializedTable, t4, a5);
      }
    }
    return null;
  }
};
var k4 = class extends e2 {
  constructor(e4, t4 = null, a5 = null, r = null) {
    super(), this._url = e4, this._overridespref = t4, this.lrucache = a5, this.interceptor = r, this.metadata = null, this._instantLayers = [];
  }
  get url() {
    return this._url;
  }
  _makeAndAddFeatureSet(e4, t4 = true, a5 = null) {
    const r = S3(e4, this._overridespref, null === a5 ? ["*"] : a5, t4, this.lrucache);
    return this._instantLayers.push({ featureset: r, opitem: e4, includeGeometry: t4, outFields: JSON.stringify(a5) }), r;
  }
  async _loadMetaData() {
    const e4 = await T2(this._url);
    return this.metadata = e4, e4;
  }
  load() {
    return this._loadMetaData();
  }
  clone() {
    return new k4(this._url, this._overridespref, this.lrucache, this.interceptor);
  }
  async featureSetByName(e4, t4 = true, a5 = null) {
    null === a5 && (a5 = ["*"]), a5 = (a5 = a5.slice(0)).sort();
    const r = JSON.stringify(a5);
    for (let s6 = 0; s6 < this._instantLayers.length; s6++) {
      const a6 = this._instantLayers[s6];
      if (a6.opitem.title === e4 && a6.includeGeometry === t4 && a6.outFields === r)
        return this._instantLayers[s6].featureset;
    }
    const n9 = await this._loadMetaData();
    let i3 = null;
    for (const s6 of n9.layers ? n9.layers : [])
      s6.name === e4 && (i3 = s6);
    if (!i3)
      for (const s6 of n9.tables ? n9.tables : [])
        s6.name === e4 && (i3 = s6);
    if (i3) {
      const e5 = await w2(this._url + "/" + i3.id, ["*"]);
      return this._makeAndAddFeatureSet(e5, t4, a5);
    }
    return null;
  }
  async featureSetById(e4, t4 = true, a5 = ["*"]) {
    null === a5 && (a5 = ["*"]), a5 = (a5 = a5.slice(0)).sort();
    const r = JSON.stringify(a5);
    e4 = null != e4 ? e4.toString() : "";
    for (let s6 = 0; s6 < this._instantLayers.length; s6++) {
      const a6 = this._instantLayers[s6];
      if (a6.opitem.id === e4 && a6.includeGeometry === t4 && a6.outFields === r)
        return this._instantLayers[s6].featureset;
    }
    const n9 = await this._loadMetaData();
    let i3 = null;
    for (const s6 of n9.layers ? n9.layers : [])
      null !== s6.id && void 0 !== s6.id && s6.id.toString() === e4 && (i3 = s6);
    if (!i3)
      for (const s6 of n9.tables ? n9.tables : [])
        null !== s6.id && void 0 !== s6.id && s6.id.toString() === e4 && (i3 = s6);
    if (i3) {
      const e5 = await w2(this._url + "/" + i3.id, ["*"]);
      return this._makeAndAddFeatureSet(e5, t4, a5);
    }
    return null;
  }
};
function j(e4, t4, a5 = null, r = null) {
  return new C2(e4, t4, a5, r);
}
function O(e4, t4, a5 = null, r = null) {
  return new k4(e4, t4, a5, r);
}
function E2(e4, t4) {
  if (null === e4)
    return t4;
  return new B({ url: e4.field("url") });
}
async function b4(a5, r, n9) {
  if (!n2.findCredential(a5.restUrl))
    return null;
  if ("loaded" === a5.loadStatus && "" === r && a5.user && a5.user.sourceJSON && false === n9)
    return a5.user.sourceJSON;
  if ("" === r) {
    const e4 = await U(a5.restUrl + "/community/self", { responseType: "json", query: { f: "json", ...false === n9 ? {} : { returnUserLicenseTypeExtensions: true } } });
    if (e4.data) {
      const t4 = e4.data;
      if (t4 && t4.username)
        return t4;
    }
    return null;
  }
  const i3 = await U(a5.restUrl + "/community/users/" + r, { responseType: "json", query: { f: "json" } });
  if (i3.data) {
    const e4 = i3.data;
    return e4.error ? null : e4;
  }
  return null;
}
function D3(e4, t4, a5, r, n9) {
  if (null === e4)
    return null;
  if (e4 instanceof Ke) {
    switch (t4) {
      case "datasource":
        return S3(e4, n9, e4.outFields, true, a5, r).getDataSourceFeatureSet();
      case "parent":
      case "root":
        return S3(e4, n9, e4.outFields, true, a5, r);
    }
    return null;
  }
  if (e4 instanceof k3)
    switch (t4) {
      case "datasource":
        return e4.getDataSourceFeatureSet();
      case "parent":
        return e4;
      case "root":
        return e4.getRootFeatureSet();
    }
  return null;
}
async function q(e4, t4, a5, r, n9, i3, s6, l2 = null) {
  if (a2.applicationCache) {
    const o3 = a2.applicationCache.getLayerInfo(e4 + ":" + i3.url);
    if (o3) {
      const e5 = await o3;
      return S3(new Ke({ url: b(e5.url) + "/" + t4, outFields: ["*"] }), a5, r, n9, s6, l2);
    }
  }
  const o2 = new b3({ id: e4, portal: i3 }).load();
  a2.applicationCache && a2.applicationCache.setLayerInfo(e4 + ":" + i3.url, o2);
  try {
    const e5 = await o2;
    return S3(new Ke({ url: b(e5.url) + "/" + t4, outFields: ["*"] }), a5, r, n9, s6, l2);
  } catch (u2) {
    throw a2.applicationCache && a2.applicationCache.clearLayerInfo(e4 + ":" + i3.url), u2;
  }
}

export {
  e2 as e,
  h3 as h,
  S2 as S,
  w,
  m3 as m,
  v,
  C,
  e3 as e2,
  s4 as s,
  s5 as s2,
  y2 as y,
  _,
  I,
  S3 as S2,
  g2 as g,
  A2 as A,
  j,
  O,
  E2 as E,
  b4 as b,
  D3 as D,
  q
};
//# sourceMappingURL=chunk-7NEDGCOF.js.map
