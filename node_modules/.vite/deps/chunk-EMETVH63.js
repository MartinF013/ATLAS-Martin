import {
  J,
  O,
  x
} from "./chunk-V56SVRSV.js";
import {
  g as g2
} from "./chunk-XZHFGTRH.js";
import {
  m as m2
} from "./chunk-X64NQ2GK.js";
import {
  D,
  T,
  V,
  c,
  d,
  f,
  g,
  h,
  m,
  s as s3,
  y,
  z
} from "./chunk-NVOCHKIH.js";
import {
  s as s2
} from "./chunk-Z7BSDVJ3.js";
import {
  e as e2
} from "./chunk-CC32E45Q.js";
import {
  H
} from "./chunk-5Z5455ZY.js";
import {
  a
} from "./chunk-D7DLEBS2.js";
import {
  e,
  l2 as l,
  l3 as l2,
  v
} from "./chunk-VLCG72SW.js";
import {
  E,
  I
} from "./chunk-3NMRL5CR.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/core/sql/WhereClauseCache.js
var c2 = class {
  constructor(e3, c4) {
    this._cache = new e2(e3), this._invalidCache = new e2(c4);
  }
  get(t3, c4) {
    const i = `${c4.uid}:${t3}`, r4 = this._cache.get(i);
    if (r4)
      return r4;
    if (void 0 !== this._invalidCache.get(i))
      return null;
    try {
      const r5 = m2.create(t3, c4);
      return this._cache.put(i, r5), r5;
    } catch {
      return this._invalidCache.put(i, null), null;
    }
  }
};

// node_modules/@arcgis/core/layers/graphics/data/attributeSupport.js
var s4 = new c2(50, 500);
var n = "feature-store:unsupported-query";
var t2 = " as ";
var r2 = /* @__PURE__ */ new Set(["esriFieldTypeOID", "esriFieldTypeSmallInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeLong", "esriFieldTypeDate"]);
function o(i, t3) {
  if (!t3)
    return true;
  const r4 = s4.get(t3, i);
  if (!r4)
    throw new s(n, "invalid SQL expression", { where: t3 });
  if (!r4.isStandardized)
    throw new s(n, "where clause is not standard", { where: t3 });
  return c3(i, r4.fieldNames, "where clause contains missing fields"), true;
}
function a2(i, t3, r4) {
  if (!t3)
    return true;
  const o2 = s4.get(t3, i);
  if (!o2)
    throw new s(n, "invalid SQL expression", { having: t3 });
  if (!o2.isAggregate)
    throw new s(n, "having does not contain a valid aggregate function", { having: t3 });
  const a3 = o2.fieldNames;
  c3(i, a3, "having contains missing fields");
  if (!o2.getExpressions().every((e3) => {
    const { aggregateType: s5, field: n2 } = e3, t4 = i.has(n2) && i.get(n2).name;
    return r4.some((e4) => {
      const { onStatisticField: n3, statisticType: r5 } = e4;
      return (i.has(n3) && i.get(n3).name) === t4 && r5.toLowerCase().trim() === s5;
    });
  }))
    throw new s(n, "expressions in having should also exist in outStatistics", { having: t3 });
  return true;
}
function l3(e3, i) {
  return e3 ? s4.get(e3, i) : null;
}
function c3(i, s5, t3, r4 = true) {
  const o2 = [];
  for (const u2 of s5)
    if ("*" !== u2 && !i.has(u2))
      if (r4) {
        const s6 = d2(u2);
        try {
          const t4 = l3(s6, i);
          if (!t4)
            throw new s(n, "invalid SQL expression", { where: s6 });
          if (!t4.isStandardized)
            throw new s(n, "expression is not standard", { clause: t4 });
          c3(i, t4.fieldNames, "expression contains missing fields");
        } catch (a3) {
          const e3 = a3 && a3.details;
          if (e3 && (e3.clause || e3.where))
            throw a3;
          e3 && e3.missingFields ? o2.push(...e3.missingFields) : o2.push(u2);
        }
      } else
        o2.push(u2);
  if (o2.length)
    throw new s(n, t3, { missingFields: o2 });
}
function d2(e3) {
  return e3.split(t2)[0];
}
function u(e3) {
  return e3.split(t2)[1];
}
function f2(e3, i) {
  const s5 = i.get(e3);
  return !!s5 && !r2.has(s5.type);
}

// node_modules/@arcgis/core/layers/graphics/data/AttributesBuilder.js
var r3 = class {
  constructor(t3, a3, r4) {
    this._fieldDataCache = /* @__PURE__ */ new Map(), this._returnDistinctMap = /* @__PURE__ */ new Map(), this.returnDistinctValues = t3.returnDistinctValues, this.fieldsIndex = r4, this.featureAdapter = a3;
    const l4 = t3.outFields;
    if (l4 && !l4.includes("*")) {
      this.outFields = l4;
      let t4 = 0;
      for (const a4 of l4) {
        const l5 = d2(a4), u2 = this.fieldsIndex.get(l5), n2 = u2 ? null : l3(l5, r4), c4 = u2 ? u2.name : u(a4) || "FIELD_EXP_" + t4++;
        this._fieldDataCache.set(a4, { alias: c4, clause: n2 });
      }
    }
  }
  countDistinctValues(t3) {
    return this.returnDistinctValues ? (t3.forEach((t4) => this.getAttributes(t4)), this._returnDistinctMap.size) : t3.length;
  }
  getAttributes(t3) {
    const e3 = this._processAttributesForOutFields(t3);
    return this._processAttributesForDistinctValues(e3);
  }
  getFieldValue(t3, e3, i) {
    const a3 = i ? i.name : e3;
    let r4 = null;
    return this._fieldDataCache.has(a3) ? r4 = this._fieldDataCache.get(a3).clause : i || (r4 = l3(e3, this.fieldsIndex), this._fieldDataCache.set(a3, { alias: a3, clause: r4 })), i ? this.featureAdapter.getAttribute(t3, a3) : r4.calculateValue(t3, this.featureAdapter);
  }
  getNormalizedValue(t3, e3) {
    const s5 = e3.normalizationType, i = e3.normalizationTotal;
    let r4 = this.getFieldValue(t3, e3.field, e3.fieldInfo);
    if (s5 && Number.isFinite(r4)) {
      const l4 = this.getFieldValue(t3, e3.normalizationField, e3.normalizationFieldInfo);
      r4 = T(r4, s5, l4, i);
    }
    return r4;
  }
  getExpressionValue(t3, e3, s5, i) {
    const a3 = { attributes: this.featureAdapter.getAttributes(t3), layer: { fields: this.fieldsIndex.fields } }, r4 = i.createExecContext(a3, s5);
    return i.executeFunction(e3, r4);
  }
  getExpressionValues(t3, e3, s5, i) {
    const a3 = { fields: this.fieldsIndex.fields };
    return t3.map((t4) => {
      const r4 = { attributes: this.featureAdapter.getAttributes(t4), layer: a3 }, l4 = i.createExecContext(r4, s5);
      return i.executeFunction(e3, l4);
    });
  }
  validateItem(t3, e3) {
    return this._fieldDataCache.has(e3) || this._fieldDataCache.set(e3, { alias: e3, clause: l3(e3, this.fieldsIndex) }), this._fieldDataCache.get(e3).clause.testFeature(t3, this.featureAdapter);
  }
  validateItems(t3, e3) {
    return this._fieldDataCache.has(e3) || this._fieldDataCache.set(e3, { alias: e3, clause: l3(e3, this.fieldsIndex) }), this._fieldDataCache.get(e3).clause.testSet(t3, this.featureAdapter);
  }
  _processAttributesForOutFields(t3) {
    const e3 = this.outFields;
    if (!e3 || !e3.length)
      return this.featureAdapter.getAttributes(t3);
    const s5 = {};
    for (const i of e3) {
      const { alias: e4, clause: a3 } = this._fieldDataCache.get(i);
      s5[e4] = a3 ? a3.calculateValue(t3, this.featureAdapter) : this.featureAdapter.getAttribute(t3, e4);
    }
    return s5;
  }
  _processAttributesForDistinctValues(e3) {
    if (t(e3) || !this.returnDistinctValues)
      return e3;
    const s5 = this.outFields, i = [];
    if (s5)
      for (const t3 of s5) {
        const { alias: s6 } = this._fieldDataCache.get(t3);
        i.push(e3[s6]);
      }
    else
      for (const t3 in e3)
        i.push(e3[t3]);
    const a3 = `${(s5 || ["*"]).join(",")}=${i.join(",")}`;
    let r4 = this._returnDistinctMap.get(a3) || 0;
    return this._returnDistinctMap.set(a3, ++r4), r4 > 1 ? null : e3;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/QueryEngineResult.js
var v2 = class {
  constructor(e3, t3, i) {
    this.items = e3, this.query = t3, this.geometryType = i.geometryType, this.hasM = i.hasM, this.hasZ = i.hasZ, this.fieldsIndex = i.fieldsIndex, this.objectIdField = i.objectIdField, this.spatialReference = i.spatialReference, this.featureAdapter = i.featureAdapter;
  }
  get size() {
    return this.items.length;
  }
  createQueryResponseForCount() {
    const e3 = new r3(this.query, this.featureAdapter, this.fieldsIndex);
    if (!this.query.outStatistics)
      return e3.countDistinctValues(this.items);
    const { groupByFieldsForStatistics: t3, having: i, outStatistics: s5 } = this.query, a3 = t3 == null ? void 0 : t3.length;
    if (!!!a3)
      return 1;
    const r4 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Set();
    for (const l4 of s5) {
      const { statisticType: s6 } = l4, a4 = "exceedslimit" !== s6 ? l4.onStatisticField : void 0;
      if (!n2.has(a4)) {
        const i2 = [];
        for (const s7 of t3) {
          const t4 = this._getAttributeValues(e3, s7, r4);
          i2.push(t4);
        }
        n2.set(a4, this._calculateUniqueValues(i2, e3.returnDistinctValues));
      }
      const u2 = n2.get(a4);
      for (const t4 in u2) {
        const { data: s7, items: a5 } = u2[t4], r5 = s7.join(",");
        i && !e3.validateItems(a5, i) || o2.add(r5);
      }
    }
    return o2.size;
  }
  async createQueryResponse() {
    let e3;
    if (this.query.outStatistics) {
      e3 = this.query.outStatistics.some((e4) => "exceedslimit" === e4.statisticType) ? this._createExceedsLimitQueryResponse(this.query) : await this._createStatisticsQueryResponse(this.query);
    } else
      e3 = this._createFeatureQueryResponse(this.query);
    return this.query.returnQueryGeometry && (I(this.query.outSR) && !E(this.query.geometry.spatialReference, this.query.outSR) ? e3.queryGeometry = x({ spatialReference: this.query.outSR, ...g2(this.query.geometry, this.query.geometry.spatialReference, this.query.outSR) }) : e3.queryGeometry = x({ spatialReference: this.query.outSR, ...this.query.geometry })), e3;
  }
  createSnappingResponse(t3, i) {
    const s5 = this.featureAdapter, a3 = A(this.hasZ, this.hasM), { x: r4, y: n2 } = t3.point, o2 = "number" == typeof t3.distance ? t3.distance : t3.distance.x, l4 = "number" == typeof t3.distance ? t3.distance : t3.distance.y, u2 = { candidates: [] }, c4 = "esriGeometryPolygon" === this.geometryType, m3 = this._getPointCreator(t3.point, this.spatialReference, i);
    for (const d3 of this.items) {
      const i2 = s5.getGeometry(d3);
      if (t(i2))
        continue;
      const { coords: h2, lengths: g3 } = i2;
      if (t3.types & E2.EDGE) {
        let e3 = 0;
        for (let t4 = 0; t4 < g3.length; t4++) {
          const i3 = g3[t4];
          for (let t5 = 0; t5 < i3; t5++, e3 += a3) {
            const c5 = h2[e3], g4 = h2[e3 + 1];
            if (t5 !== i3 - 1) {
              const t6 = h2[e3 + a3], i4 = h2[e3 + a3 + 1], { x: p, y: f3 } = R(r4, n2, c5, g4, t6, i4), y2 = (r4 - p) / o2, x2 = (n2 - f3) / l4, I2 = y2 * y2 + x2 * x2;
              I2 <= 1 && u2.candidates.push({ type: "edge", objectId: s5.getObjectId(d3), distance: Math.sqrt(I2), target: m3(p, f3), start: m3(c5, g4), end: m3(t6, i4) });
            }
          }
        }
      }
      if (t3.types & E2.VERTEX) {
        const e3 = c4 ? h2.length - a3 : h2.length;
        for (let t4 = 0; t4 < e3; t4 += a3) {
          const e4 = h2[t4], i3 = h2[t4 + 1], a4 = (r4 - e4) / o2, c5 = (n2 - i3) / l4, g4 = a4 * a4 + c5 * c5;
          g4 <= 1 && u2.candidates.push({ type: "vertex", objectId: s5.getObjectId(d3), distance: Math.sqrt(g4), target: m3(e4, i3) });
        }
      }
    }
    return u2.candidates.sort((e3, t4) => e3.distance - t4.distance), u2;
  }
  _getPointCreator(e3, i, s5) {
    const a3 = r(s5) && !E(i, s5) ? (e4) => g2(e4, i, s5) : (e4) => e4;
    return null != e3.z && null != e3.m ? (t3, i2) => a3({ x: t3, y: i2, z: e3.z, m: e3.m }) : null != e3.z ? (t3, i2) => a3({ x: t3, y: i2, z: e3.z }) : null != e3.m ? (t3, i2) => a3({ x: t3, y: i2, m: e3.m }) : (e4, t3) => a3({ x: e4, y: t3 });
  }
  async createSummaryStatisticsResponse(e3) {
    const { field: t3, valueExpression: i, normalizationField: s5, normalizationType: a3, normalizationTotal: r4, minValue: n2, maxValue: o2, scale: l4 } = e3, u2 = this.fieldsIndex.isDateField(t3), c4 = await this._getDataValues({ field: t3, valueExpression: i, normalizationField: s5, normalizationType: a3, normalizationTotal: r4, scale: l4 }), m3 = s3({ normalizationType: a3, normalizationField: s5, minValue: n2, maxValue: o2 }), d3 = this.fieldsIndex.get(t3), h2 = { value: 0.5, fieldType: d3 == null ? void 0 : d3.type }, I2 = H(d3) ? m({ values: c4, supportsNullCount: m3, percentileParams: h2 }) : c({ values: c4, minValue: n2, maxValue: o2, useSampleStdDev: !a3, supportsNullCount: m3, percentileParams: h2 });
    return V(I2, u2);
  }
  async createUniqueValuesResponse(e3) {
    const { field: t3, valueExpression: i, domain: s5, returnAllCodedValues: a3, scale: r4 } = e3, n2 = await this._getDataValues({ field: t3, valueExpression: i, scale: r4 }), o2 = g(n2);
    return h(o2, s5, a3);
  }
  async createClassBreaksResponse(e3) {
    const { field: t3, valueExpression: i, normalizationField: s5, normalizationType: a3, normalizationTotal: r4, classificationMethod: n2, standardDeviationInterval: o2, minValue: l4, maxValue: u2, numClasses: c4, scale: m3 } = e3, d3 = await this._getDataValues({ field: t3, valueExpression: i, normalizationField: s5, normalizationType: a3, normalizationTotal: r4, scale: m3 }), h2 = y(d3, { field: t3, normalizationField: s5, normalizationType: a3, normalizationTotal: r4, classificationMethod: n2, standardDeviationInterval: o2, minValue: l4, maxValue: u2, numClasses: c4 });
    return D(h2, n2);
  }
  async createHistogramResponse(e3) {
    const { field: t3, valueExpression: i, normalizationField: s5, normalizationType: a3, normalizationTotal: r4, classificationMethod: n2, standardDeviationInterval: o2, minValue: l4, maxValue: u2, numBins: c4, scale: m3 } = e3, d3 = await this._getDataValues({ field: t3, valueExpression: i, normalizationField: s5, normalizationType: a3, normalizationTotal: r4, scale: m3 });
    return z(d3, { field: t3, normalizationField: s5, normalizationType: a3, normalizationTotal: r4, classificationMethod: n2, standardDeviationInterval: o2, minValue: l4, maxValue: u2, numBins: c4 });
  }
  _sortFeatures(e3, t3, i) {
    if (e3.length > 1 && t3 && t3.length)
      for (const s5 of t3.reverse()) {
        const t4 = s5.split(" "), a3 = t4[0], r4 = this.fieldsIndex.get(a3), n2 = t4[1] && "desc" === t4[1].toLowerCase(), o2 = f(r4 == null ? void 0 : r4.type, n2);
        e3.sort((e4, t5) => {
          const s6 = i(e4, a3, r4), n3 = i(t5, a3, r4);
          return o2(s6, n3);
        });
      }
  }
  _createFeatureQueryResponse(e3) {
    const t3 = this.items, { geometryType: i, hasM: s5, hasZ: a3, objectIdField: r4, spatialReference: o2 } = this, { outFields: l4, outSR: u2, quantizationParameters: c4, resultRecordCount: d3, resultOffset: h2, returnZ: g3, returnM: p } = e3, f3 = null != d3 && t3.length > (h2 || 0) + d3, y2 = l4 && (l4.includes("*") ? [...this.fieldsIndex.fields] : l4.map((e4) => this.fieldsIndex.get(e4)));
    return { exceededTransferLimit: f3, features: this._createFeatures(e3, t3), fields: y2, geometryType: i, hasM: s5 && p, hasZ: a3 && g3, objectIdFieldName: r4, spatialReference: x(u2 || o2), transform: c4 && s2(c4) || null };
  }
  _createFeatures(e3, t3) {
    const i = new r3(e3, this.featureAdapter, this.fieldsIndex), { hasM: s5, hasZ: a3 } = this, { orderByFields: r4, quantizationParameters: o2, returnGeometry: l4, returnCentroid: c4, maxAllowableOffset: m3, resultOffset: g3, resultRecordCount: p, returnZ: f3 = false, returnM: y2 = false } = e3, x2 = a3 && f3, I2 = s5 && y2;
    let T2 = [], V2 = 0;
    const F = [...t3];
    if (this._sortFeatures(F, r4, (e4, t4, s6) => i.getFieldValue(e4, t4, s6)), l4 || c4) {
      const e4 = s2(o2);
      if (l4 && !c4)
        for (const t4 of F)
          T2[V2++] = { attributes: i.getAttributes(t4), geometry: J(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(t4), m3, e4, x2, I2) };
      else if (!l4 && c4)
        for (const t4 of F)
          T2[V2++] = { attributes: i.getAttributes(t4), centroid: O(this, this.featureAdapter.getCentroid(t4, this), e4) };
      else
        for (const t4 of F)
          T2[V2++] = { attributes: i.getAttributes(t4), centroid: O(this, this.featureAdapter.getCentroid(t4, this), e4), geometry: J(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(t4), m3, e4, x2, I2) };
    } else
      for (const n2 of F) {
        const e4 = i.getAttributes(n2);
        e4 && (T2[V2++] = { attributes: e4 });
      }
    const z2 = g3 || 0;
    if (null != p) {
      const e4 = z2 + p;
      T2 = T2.slice(z2, Math.min(T2.length, e4));
    }
    return T2;
  }
  _createExceedsLimitQueryResponse(e3) {
    let i = false, s5 = Number.POSITIVE_INFINITY, a3 = Number.POSITIVE_INFINITY, r4 = Number.POSITIVE_INFINITY;
    for (const t3 of e3.outStatistics)
      if ("exceedslimit" === t3.statisticType) {
        s5 = null != t3.maxPointCount ? t3.maxPointCount : Number.POSITIVE_INFINITY, a3 = null != t3.maxRecordCount ? t3.maxRecordCount : Number.POSITIVE_INFINITY, r4 = null != t3.maxVertexCount ? t3.maxVertexCount : Number.POSITIVE_INFINITY;
        break;
      }
    if ("esriGeometryPoint" === this.geometryType)
      i = this.items.length > s5;
    else if (this.items.length > a3)
      i = true;
    else {
      const e4 = this.hasZ ? this.hasM ? 4 : 3 : this.hasM ? 3 : 2, s6 = this.featureAdapter;
      i = this.items.reduce((e5, i2) => {
        const a4 = s6.getGeometry(i2);
        return e5 + (r(a4) && a4.coords.length || 0);
      }, 0) / e4 > r4;
    }
    return { fields: [{ name: "exceedslimit", type: "esriFieldTypeInteger", alias: "exceedslimit", sqlType: "sqlTypeInteger", domain: null, defaultValue: null }], features: [{ attributes: { exceedslimit: Number(i) } }] };
  }
  async _createStatisticsQueryResponse(e3) {
    const t3 = { attributes: {} }, i = [], s5 = /* @__PURE__ */ new Map(), a3 = /* @__PURE__ */ new Map(), r4 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Map(), o2 = new r3(e3, this.featureAdapter, this.fieldsIndex), l4 = e3.outStatistics, { groupByFieldsForStatistics: c4, having: m3, orderByFields: d3 } = e3, h2 = c4 && c4.length, g3 = !!h2, p = g3 && c4[0], f3 = g3 && !this.fieldsIndex.get(p);
    for (const u2 of l4) {
      const { outStatisticFieldName: e4, statisticType: l5 } = u2, d4 = u2, y3 = "exceedslimit" !== l5 ? u2.onStatisticField : void 0, x2 = "percentile_disc" === l5 || "percentile_cont" === l5, I2 = "EnvelopeAggregate" === l5 || "CentroidAggregate" === l5 || "ConvexHullAggregate" === l5, T2 = g3 && 1 === h2 && (y3 === p || f3) && "count" === l5;
      if (g3) {
        if (!r4.has(y3)) {
          const e5 = [];
          for (const t5 of c4) {
            const i2 = this._getAttributeValues(o2, t5, s5);
            e5.push(i2);
          }
          r4.set(y3, this._calculateUniqueValues(e5, o2.returnDistinctValues));
        }
        const t4 = r4.get(y3);
        for (const i2 in t4) {
          const { count: a4, data: r5, items: l6, itemPositions: u3 } = t4[i2], h3 = r5.join(",");
          if (!m3 || o2.validateItems(l6, m3)) {
            const t5 = n2.get(h3) || { attributes: {} };
            if (I2) {
              t5.aggregateGeometries || (t5.aggregateGeometries = {});
              const { aggregateGeometries: e5, outStatisticFieldName: i3 } = await this._getAggregateGeometry(d4, l6);
              t5.aggregateGeometries[i3] = e5;
            } else {
              let i3 = null;
              if (T2)
                i3 = a4;
              else {
                const e5 = this._getAttributeValues(o2, y3, s5), t6 = u3.map((t7) => e5[t7]);
                i3 = x2 && "statisticParameters" in d4 ? this._getPercentileValue(d4, t6) : this._getStatisticValue(d4, t6, null, o2.returnDistinctValues);
              }
              t5.attributes[e4] = i3;
            }
            c4.forEach((e5, i3) => t5.attributes[this.fieldsIndex.get(e5) ? e5 : `EXPR_${i3 + 1}`] = r5[i3]), n2.set(h3, t5);
          }
        }
      } else if (I2) {
        t3.aggregateGeometries || (t3.aggregateGeometries = {});
        const { aggregateGeometries: e5, outStatisticFieldName: i2 } = await this._getAggregateGeometry(d4, this.items);
        t3.aggregateGeometries[i2] = e5;
      } else {
        const i2 = this._getAttributeValues(o2, y3, s5);
        t3.attributes[e4] = x2 && "statisticParameters" in d4 ? this._getPercentileValue(d4, i2) : this._getStatisticValue(d4, i2, a3, o2.returnDistinctValues);
      }
      i.push({ name: e4, alias: e4, type: "esriFieldTypeDouble" });
    }
    const y2 = g3 ? Array.from(n2.values()) : [t3];
    return this._sortFeatures(y2, d3, (e4, t4) => e4.attributes[t4]), { fields: i, features: y2 };
  }
  async _getAggregateGeometry(e3, t3) {
    const n2 = await import("./geometryEngineJSON-Y4CNF4IY.js"), { statisticType: o2, outStatisticFieldName: l4 } = e3, { featureAdapter: u2, spatialReference: c4, geometryType: m3, hasZ: h2, hasM: g3 } = this, p = t3.map((e4) => J(m3, h2, g3, u2.getGeometry(e4))), f3 = n2.convexHull(c4, p, true)[0], y2 = { aggregateGeometries: null, outStatisticFieldName: null };
    if ("EnvelopeAggregate" === o2) {
      const e4 = f3 ? v(f3) : l2(n2.union(c4, p));
      y2.aggregateGeometries = { ...e4, spatialReference: c4 }, y2.outStatisticFieldName = l4 || "extent";
    } else if ("CentroidAggregate" === o2) {
      const e4 = f3 ? e(f3) : l(l2(n2.union(c4, p)));
      y2.aggregateGeometries = { x: e4[0], y: e4[1], spatialReference: c4 }, y2.outStatisticFieldName = l4 || "centroid";
    } else
      "ConvexHullAggregate" === o2 && (y2.aggregateGeometries = f3, y2.outStatisticFieldName = l4 || "convexHull");
    return y2;
  }
  _getStatisticValue(e3, t3, i, s5) {
    const { onStatisticField: a3, statisticType: r4 } = e3;
    let n2 = null;
    n2 = (i == null ? void 0 : i.has(a3)) ? i.get(a3) : H(this.fieldsIndex.get(a3)) ? m({ values: t3, returnDistinct: s5 }) : c({ values: t3, minValue: null, maxValue: null, useSampleStdDev: true }), i && i.set(a3, n2);
    return n2["var" === r4 ? "variance" : r4];
  }
  _getPercentileValue(e3, t3) {
    const { onStatisticField: i, statisticParameters: s5, statisticType: a3 } = e3, { value: r4, orderBy: n2 } = s5, o2 = this.fieldsIndex.get(i);
    return d(t3, { value: r4, orderBy: n2, fieldType: o2 == null ? void 0 : o2.type, isDiscrete: "percentile_disc" === a3 });
  }
  _getAttributeValues(e3, t3, i) {
    if (i.has(t3))
      return i.get(t3);
    const s5 = this.fieldsIndex.get(t3), a3 = this.items.map((i2) => e3.getFieldValue(i2, t3, s5));
    return i.set(t3, a3), a3;
  }
  _getAttributeNormalizedValues(e3, t3) {
    return this.items.map((i) => e3.getNormalizedValue(i, { field: t3.field, fieldInfo: this.fieldsIndex.get(t3.field), normalizationField: t3.normalizationField, normalizationFieldInfo: this.fieldsIndex.get(t3.normalizationField), normalizationType: t3.normalizationType, normalizationTotal: t3.normalizationTotal }));
  }
  async _getAttributeExpressionValues(e3, t3, i) {
    const { arcadeUtils: s5 } = await a(), a3 = s5.createFunction(t3), r4 = i && s5.getViewInfo(i);
    return e3.getExpressionValues(this.items, a3, r4, s5);
  }
  _calculateUniqueValues(e3, t3) {
    const i = {}, s5 = this.items, a3 = s5.length;
    for (let r4 = 0; r4 < a3; r4++) {
      const a4 = s5[r4], n2 = [];
      for (const t4 of e3)
        n2.push(t4[r4]);
      const o2 = n2.join(",");
      t3 ? null == i[o2] && (i[o2] = { count: 1, data: n2, items: [a4], itemPositions: [r4] }) : null == i[o2] ? i[o2] = { count: 1, data: n2, items: [a4], itemPositions: [r4] } : (i[o2].count++, i[o2].items.push(a4), i[o2].itemPositions.push(r4));
    }
    return i;
  }
  async _getDataValues(e3) {
    const t3 = new r3(this.query, this.featureAdapter, this.fieldsIndex), { valueExpression: i, field: s5, normalizationField: a3, normalizationType: r4, normalizationTotal: n2, scale: o2 } = e3, l4 = i ? { viewingMode: "map", scale: o2, spatialReference: this.query.outSR || this.spatialReference } : null;
    return i ? this._getAttributeExpressionValues(t3, i, l4) : this._getAttributeNormalizedValues(t3, { field: s5, normalizationField: a3, normalizationType: r4, normalizationTotal: n2 });
  }
};
function R(e3, t3, i, s5, a3, r4) {
  const n2 = a3 - i, o2 = r4 - s5, l4 = n2 * n2 + o2 * o2, u2 = (e3 - i) * n2 + (t3 - s5) * o2, c4 = Math.min(1, Math.max(0, u2 / l4));
  return { x: i + n2 * c4, y: s5 + o2 * c4 };
}
function A(e3, t3) {
  return e3 ? t3 ? 4 : 3 : t3 ? 3 : 2;
}
var E2;
!function(e3) {
  e3[e3.NONE = 0] = "NONE", e3[e3.EDGE = 1] = "EDGE", e3[e3.VERTEX = 2] = "VERTEX";
}(E2 || (E2 = {}));

export {
  o,
  a2 as a,
  l3 as l,
  c3 as c,
  f2 as f,
  v2 as v,
  E2 as E
};
//# sourceMappingURL=chunk-EMETVH63.js.map
