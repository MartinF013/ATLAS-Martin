import {
  D,
  O as O2,
  R,
  T,
  U as U2,
  b as b3,
  b2 as b4,
  g as g2,
  h,
  h2,
  h3,
  h4,
  i as i4,
  k as k2,
  l as l3,
  n as n3,
  o as o4,
  r as r5,
  s as s4,
  t as t4,
  u,
  w,
  y as y2
} from "./chunk-ZO3EM3I6.js";
import {
  t as t5
} from "./chunk-OSJOW7C6.js";
import {
  i as i3
} from "./chunk-WRJQ7542.js";
import "./chunk-QFYBIFWB.js";
import {
  f
} from "./chunk-7USXBUJ4.js";
import {
  L
} from "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import {
  e as e3,
  n as n2
} from "./chunk-6FKG7JUE.js";
import {
  fn,
  rn
} from "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import {
  x
} from "./chunk-4XBERLPX.js";
import {
  S
} from "./chunk-6GPADSSO.js";
import {
  o as o3
} from "./chunk-C7S44TP4.js";
import "./chunk-KUWW4YJ7.js";
import "./chunk-P6I5J7W6.js";
import "./chunk-ORGMKDYR.js";
import "./chunk-F2DXUUYL.js";
import "./chunk-EGR3VVZG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-T7SYNS2R.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  v as v2
} from "./chunk-OG6CQEZJ.js";
import {
  c as c2
} from "./chunk-X5Z3DJQ4.js";
import {
  O
} from "./chunk-BUWXVMJU.js";
import "./chunk-JT3LXQ47.js";
import {
  b
} from "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import {
  a as a3
} from "./chunk-D3XXPCBB.js";
import {
  t as t3
} from "./chunk-OWBMOIIV.js";
import {
  b as b2
} from "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import {
  a as a2
} from "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  a
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-IZCP5QP4.js";
import "./chunk-QFTOW2ST.js";
import "./chunk-I4USSDLI.js";
import "./chunk-VI3TTBSC.js";
import "./chunk-B42HXLDM.js";
import "./chunk-TVXPO7T5.js";
import "./chunk-2EZYA7VW.js";
import "./chunk-OEQ3EDRD.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import {
  N
} from "./chunk-RN2KRYDN.js";
import {
  g as g3
} from "./chunk-BLINZ65M.js";
import {
  j3 as j4,
  y
} from "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import {
  B as B2
} from "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import {
  l as l2
} from "./chunk-CF56UYH2.js";
import {
  S as S2,
  m as m3
} from "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import {
  r as r4
} from "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import {
  B
} from "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import {
  j as j2
} from "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  Ct,
  j as j3
} from "./chunk-5N3FSR63.js";
import {
  i as i2
} from "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import {
  d as d2
} from "./chunk-4PRVTUEZ.js";
import {
  s
} from "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import {
  m,
  m2
} from "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  c,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import {
  r as r3
} from "./chunk-ZIHDQYKE.js";
import {
  o as o2
} from "./chunk-GSRNZQFV.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  g
} from "./chunk-U3PSONS6.js";
import {
  s2 as s3
} from "./chunk-HFTNOKM2.js";
import {
  v
} from "./chunk-23NWA6WL.js";
import {
  r as r2,
  s as s2
} from "./chunk-CVWDM4C7.js";
import {
  o,
  t as t2
} from "./chunk-G5JBUC5N.js";
import {
  e as e2,
  i,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p = class extends l {
  constructor(o5) {
    super(o5), this.break = new y({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new y({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new y({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new y({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new y({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new y({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
e([d({ types: j4 })], p.prototype, "break", void 0), e([d({ types: j4 })], p.prototype, "first", void 0), e([d({ types: j4 })], p.prototype, "unlocated", void 0), e([d({ types: j4 })], p.prototype, "last", void 0), e([d({ types: j4 })], p.prototype, "middle", void 0), e([d({ types: j4 })], p.prototype, "waypoint", void 0), p = e([n("esri.layers.support.RouteStopSymbols")], p);
var l4 = p;

// node_modules/@arcgis/core/layers/support/RouteSymbols.js
var c3 = class extends l {
  constructor(o5) {
    super(o5), this.directionLines = new m3({ color: [0, 122, 194], width: 6 }), this.directionPoints = new y({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new y({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new S2({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new m3({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new m3({ width: 8, color: [20, 89, 127] }), this.stops = new l4();
  }
};
e([d({ types: j4 })], c3.prototype, "directionLines", void 0), e([d({ types: j4 })], c3.prototype, "directionPoints", void 0), e([d({ types: j4 })], c3.prototype, "pointBarriers", void 0), e([d({ types: j4 })], c3.prototype, "polygonBarriers", void 0), e([d({ types: j4 })], c3.prototype, "polylineBarriers", void 0), e([d({ types: j4 })], c3.prototype, "routeInfo", void 0), e([d({ type: l4 })], c3.prototype, "stops", void 0), c3 = e([n("esri.layers.support.RouteSymbols")], c3);
var n4 = c3;

// node_modules/@arcgis/core/rest/support/NetworkAttribute.js
var n5 = class extends l {
  constructor(t6) {
    super(t6), this.dataType = null, this.name = null, this.parameterNames = null, this.restrictionUsageParameterName = null, this.timeNeutralAttributeName = null, this.trafficSupport = null, this.units = null, this.usageType = null;
  }
};
e([d({ type: String })], n5.prototype, "dataType", void 0), e([r4(T, { ignoreUnknown: false })], n5.prototype, "name", void 0), e([d({ type: [String] })], n5.prototype, "parameterNames", void 0), e([d({ type: String })], n5.prototype, "restrictionUsageParameterName", void 0), e([r4(y2, { ignoreUnknown: false })], n5.prototype, "timeNeutralAttributeName", void 0), e([d({ type: String })], n5.prototype, "trafficSupport", void 0), e([d({ type: String })], n5.prototype, "units", void 0), e([r4(b3)], n5.prototype, "usageType", void 0), n5 = e([n("esri.rest.support.NetworkAttribute")], n5);
var u2 = n5;

// node_modules/@arcgis/core/rest/support/NetworkDataset.js
var p2 = class extends l {
  constructor(t6) {
    super(t6), this.buildTime = null, this.name = null, this.networkAttributes = null, this.networkSources = null, this.state = null;
  }
};
e([d({ type: Number })], p2.prototype, "buildTime", void 0), e([d({ type: String })], p2.prototype, "name", void 0), e([d({ type: [u2] })], p2.prototype, "networkAttributes", void 0), e([d()], p2.prototype, "networkSources", void 0), e([d({ type: String })], p2.prototype, "state", void 0), p2 = e([n("esri.rest.support.NetworkDataset")], p2);
var i5 = p2;

// node_modules/@arcgis/core/rest/support/NetworkServiceDescription.js
var d3 = class extends l {
  constructor(t6) {
    super(t6), this.accumulateAttributeNames = null, this.currentVersion = null, this.defaultTravelMode = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsSupportedLanguages = null, this.directionsTimeAttribute = null, this.hasZ = null, this.impedance = null, this.networkDataset = null, this.supportedTravelModes = null;
  }
  readAccumulateAttributes(t6) {
    return t(t6) ? null : t6.map((t7) => T.fromJSON(t7));
  }
  writeAccumulateAttributes(t6, r6, o5) {
    !t(t6) && t6.length && (r6[o5] = t6.map((t7) => T.toJSON(t7)));
  }
};
e([d()], d3.prototype, "accumulateAttributeNames", void 0), e([o2("accumulateAttributeNames")], d3.prototype, "readAccumulateAttributes", null), e([r3("accumulateAttributeNames")], d3.prototype, "writeAccumulateAttributes", null), e([d()], d3.prototype, "currentVersion", void 0), e([d()], d3.prototype, "defaultTravelMode", void 0), e([d()], d3.prototype, "directionsLanguage", void 0), e([r4(r5)], d3.prototype, "directionsLengthUnits", void 0), e([d()], d3.prototype, "directionsSupportedLanguages", void 0), e([r4(y2, { ignoreUnknown: false })], d3.prototype, "directionsTimeAttribute", void 0), e([d()], d3.prototype, "hasZ", void 0), e([r4(T, { ignoreUnknown: false })], d3.prototype, "impedance", void 0), e([d({ type: i5 })], d3.prototype, "networkDataset", void 0), e([d({ type: [h] })], d3.prototype, "supportedTravelModes", void 0), d3 = e([n("esri.rest.support.NetworkServiceDescription")], d3);
var y3 = d3;

// node_modules/@arcgis/core/rest/networkService.js
function i6(e5, r6, t6, o5) {
  o5[t6] = [r6.length, r6.length + e5.length], e5.forEach((e6) => {
    r6.push(e6.geometry);
  });
}
function d4(e5, r6) {
  for (let t6 = 0; t6 < r6.length; t6++) {
    const o5 = e5[r6[t6]];
    if (o5 && o5.length)
      for (const e6 of o5)
        e6.z = void 0;
  }
  console.log("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.");
}
function u3(e5, r6) {
  for (let o5 = 0; o5 < r6.length; o5++) {
    const s6 = e5[r6[o5]];
    if (s6 && s6.length) {
      for (const e6 of s6)
        if (r(e6) && e6.hasZ)
          return true;
    }
  }
  return false;
}
async function f2(t6, o5, s6) {
  if (!t6)
    throw new s3("network-service:missing-url", "Url to Network service is missing");
  const l7 = e3({ f: "json", token: o5 }, s6), { data: i8 } = await U(t6, l7);
  i8.supportedTravelModes || (i8.supportedTravelModes = []);
  for (let e5 = 0; e5 < i8.supportedTravelModes.length; e5++)
    i8.supportedTravelModes[e5].id || (i8.supportedTravelModes[e5].id = i8.supportedTravelModes[e5].itemId);
  const d5 = i8.currentVersion >= 10.4 ? c4(t6, o5, s6) : p3(t6, s6), { defaultTravelMode: u7, supportedTravelModes: f3 } = await d5;
  return i8.defaultTravelMode = u7, i8.supportedTravelModes = f3, y3.fromJSON(i8);
}
async function p3(r6, t6) {
  var _a, _b, _c;
  const n8 = e3({ f: "json" }, t6), { data: i8 } = await U(r6.replace(/\/rest\/.*$/i, "/info"), n8);
  if (!i8 || !i8.owningSystemUrl)
    return { supportedTravelModes: [], defaultTravelMode: null };
  const { owningSystemUrl: d5 } = i8, u7 = Ct(d5) + "/sharing/rest/portals/self", { data: f3 } = await U(u7, n8), p9 = t2("helperServices.routingUtilities.url", f3);
  if (!p9)
    return { supportedTravelModes: [], defaultTravelMode: null };
  const c12 = n2(d5), v3 = /\/solve$/i.test(c12.path) ? "Route" : /\/solveclosestfacility$/i.test(c12.path) ? "ClosestFacility" : "ServiceAreas", m5 = e3({ f: "json", serviceName: v3 }, t6), T2 = Ct(p9) + "/GetTravelModes/execute", M2 = await U(T2, m5), h5 = [];
  let w2 = null;
  if ((_b = (_a = M2 == null ? void 0 : M2.data) == null ? void 0 : _a.results) == null ? void 0 : _b.length) {
    const e5 = M2.data.results;
    for (const r7 of e5)
      if ("supportedTravelModes" === r7.paramName) {
        if ((_c = r7.value) == null ? void 0 : _c.features) {
          for (const { attributes: e6 } of r7.value.features)
            if (e6) {
              const r8 = JSON.parse(e6.TravelMode);
              h5.push(r8);
            }
        }
      } else
        "defaultTravelMode" === r7.paramName && (w2 = r7.value);
  }
  return { supportedTravelModes: h5, defaultTravelMode: w2 };
}
async function c4(t6, o5, l7) {
  try {
    const r6 = e3({ f: "json", token: o5 }, l7), n8 = Ct(t6) + "/retrieveTravelModes", { data: { supportedTravelModes: i8, defaultTravelMode: d5 } } = await U(n8, r6);
    return { supportedTravelModes: i8, defaultTravelMode: d5 };
  } catch (n8) {
    throw new s3("network-service:retrieveTravelModes", "Could not get to the NAServer's retrieveTravelModes.", { error: n8 });
  }
}

// node_modules/@arcgis/core/rest/support/GPMessage.js
var p4 = new s({ esriJobMessageTypeInformative: "informative", esriJobMessageTypeProcessDefinition: "process-definition", esriJobMessageTypeProcessStart: "process-start", esriJobMessageTypeProcessStop: "process-stop", esriJobMessageTypeWarning: "warning", esriJobMessageTypeError: "error", esriJobMessageTypeEmpty: "empty", esriJobMessageTypeAbort: "abort" });
var i7 = class extends l {
  constructor(e5) {
    super(e5), this.description = null, this.type = null;
  }
};
e([d({ type: String, json: { write: true } })], i7.prototype, "description", void 0), e([d({ type: String, json: { read: p4.read, write: p4.write } })], i7.prototype, "type", void 0), i7 = e([n("esri.rest.support.GPMessage")], i7);
var a4 = i7;

// node_modules/@arcgis/core/rest/support/NAMessage.js
var p5 = new s({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c5 = class extends a4 {
  constructor(r6) {
    super(r6), this.type = null;
  }
};
e([d({ type: String, json: { read: p5.read, write: p5.write } })], c5.prototype, "type", void 0), c5 = e([n("esri.rest.support.NAMessage")], c5);
var a5 = c5;

// node_modules/@arcgis/core/rest/support/DirectionsFeature.js
var e4 = class extends g3 {
};
e([d()], e4.prototype, "events", void 0), e([d()], e4.prototype, "strings", void 0), e4 = e([n("esri.rest.support.DirectionsFeature")], e4);
var p6 = e4;

// node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
var u4 = class extends x {
  constructor(e5) {
    super(e5), this.extent = null, this.features = null, this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e5, t6) {
    if (!e5)
      return [];
    const r6 = t6.summary.envelope.spatialReference ?? t6.spatialReference, s6 = r6 && k.fromJSON(r6);
    return e5.map((e6) => {
      var _a;
      const t7 = this._decompressGeometry(e6.compressedGeometry), r7 = new m2({ ...t7, spatialReference: s6 }), o5 = ((_a = e6.events) == null ? void 0 : _a.map((e7) => {
        const { arriveTimeUTC: t8, ETA: r8, point: { x: o6, y: n8, z: p9 }, strings: i8 } = e7;
        return new p6({ geometry: new j({ x: o6, y: n8, z: p9, hasZ: void 0 !== p9, spatialReference: s6 }), attributes: { ETA: r8, arriveTimeUTC: t8 }, strings: i8 });
      })) ?? [];
      return new p6({ attributes: e6.attributes, events: o5, geometry: r7, strings: e6.strings });
    });
  }
  get mergedGeometry() {
    if (!this.features)
      return null;
    const e5 = this.features.map(({ geometry: e6 }) => e2(e6)), r6 = this.get("extent.spatialReference");
    return this._mergePolylinesToSinglePath(e5, r6);
  }
  get strings() {
    return this.features.map(({ strings: e5 }) => e5);
  }
  _decompressGeometry(e5) {
    let t6 = 0, r6 = 0, s6 = 0, o5 = 0;
    const a6 = [];
    let n8, p9, i8, m5, l7, u7, c12, y4, h5 = 0, f3 = 0, d5 = 0;
    if (l7 = e5.match(/((\+|\-)[^\+\-\|]+|\|)/g), l7 || (l7 = []), 0 === parseInt(l7[h5], 32)) {
      h5 = 2;
      const e6 = parseInt(l7[h5], 32);
      h5++, u7 = parseInt(l7[h5], 32), h5++, 1 & e6 && (f3 = l7.indexOf("|") + 1, c12 = parseInt(l7[f3], 32), f3++), 2 & e6 && (d5 = l7.indexOf("|", f3) + 1, y4 = parseInt(l7[d5], 32), d5++);
    } else
      u7 = parseInt(l7[h5], 32), h5++;
    for (; h5 < l7.length && "|" !== l7[h5]; ) {
      n8 = parseInt(l7[h5], 32) + t6, h5++, t6 = n8, p9 = parseInt(l7[h5], 32) + r6, h5++, r6 = p9;
      const e6 = [n8 / u7, p9 / u7];
      f3 && (m5 = parseInt(l7[f3], 32) + s6, f3++, s6 = m5, e6.push(m5 / c12)), d5 && (i8 = parseInt(l7[d5], 32) + o5, d5++, o5 = i8, e6.push(i8 / y4)), a6.push(e6);
    }
    return { paths: [a6], hasZ: f3 > 0, hasM: d5 > 0 };
  }
  _mergePolylinesToSinglePath(e5, t6) {
    if (0 === e5.length)
      return new m2({ spatialReference: t6 });
    const r6 = [];
    for (const n8 of e5)
      for (const e6 of n8.paths)
        r6.push(...e6);
    const s6 = [];
    r6.forEach((e6, t7) => {
      0 !== t7 && e6[0] === r6[t7 - 1][0] && e6[1] === r6[t7 - 1][1] || s6.push(e6);
    });
    const { hasM: o5, hasZ: a6 } = e5[0];
    return new m2({ hasM: o5, hasZ: a6, paths: [s6], spatialReference: t6 });
  }
};
e([d({ type: M, json: { read: { source: "summary.envelope" } } })], u4.prototype, "extent", void 0), e([d()], u4.prototype, "features", void 0), e([o2("features")], u4.prototype, "readFeatures", null), e([d()], u4.prototype, "geometryType", void 0), e([d({ readOnly: true })], u4.prototype, "mergedGeometry", null), e([d()], u4.prototype, "routeId", void 0), e([d()], u4.prototype, "routeName", void 0), e([d({ value: null, readOnly: true })], u4.prototype, "strings", null), e([d({ json: { read: { source: "summary.totalDriveTime" } } })], u4.prototype, "totalDriveTime", void 0), e([d({ json: { read: { source: "summary.totalLength" } } })], u4.prototype, "totalLength", void 0), e([d({ json: { read: { source: "summary.totalTime" } } })], u4.prototype, "totalTime", void 0), u4 = e([n("esri.rest.support.DirectionsFeatureSet")], u4);
var c6 = u4;

// node_modules/@arcgis/core/rest/support/RouteResult.js
var n6 = class extends l {
  constructor(t6) {
    super(t6), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
e([d({ type: x, json: { write: true } })], n6.prototype, "directionLines", void 0), e([d({ type: x, json: { write: true } })], n6.prototype, "directionPoints", void 0), e([d({ type: c6, json: { write: true } })], n6.prototype, "directions", void 0), e([d({ type: g3, json: { write: true } })], n6.prototype, "route", void 0), e([d({ type: String, json: { write: true } })], n6.prototype, "routeName", void 0), e([d({ type: [g3], json: { write: true } })], n6.prototype, "stops", void 0), e([d({ type: x, json: { write: true } })], n6.prototype, "traversedEdges", void 0), e([d({ type: x, json: { write: true } })], n6.prototype, "traversedJunctions", void 0), e([d({ type: x, json: { write: true } })], n6.prototype, "traversedTurns", void 0), n6 = e([n("esri.rest.support.RouteResult")], n6);
var u5 = n6;

// node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function u6(r6) {
  return r6 && x.fromJSON(r6).features.map((r7) => r7);
}
var n7 = class extends l {
  constructor(r6) {
    super(r6), this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r6, o5) {
    return u6(o5.barriers);
  }
  readPolylineBarriers(r6) {
    return u6(r6);
  }
  readPolygonBarriers(r6) {
    return u6(r6);
  }
};
e([d({ type: [a5] })], n7.prototype, "messages", void 0), e([d({ type: [g3] })], n7.prototype, "pointBarriers", void 0), e([o2("pointBarriers", ["barriers"])], n7.prototype, "readPointBarriers", null), e([d({ type: [g3] })], n7.prototype, "polylineBarriers", void 0), e([o2("polylineBarriers")], n7.prototype, "readPolylineBarriers", null), e([d({ type: [g3] })], n7.prototype, "polygonBarriers", void 0), e([o2("polygonBarriers")], n7.prototype, "readPolygonBarriers", null), e([d({ type: [u5] })], n7.prototype, "routeResults", void 0), n7 = e([n("esri.rest.support.RouteSolveResult")], n7);
var c7 = n7;

// node_modules/@arcgis/core/rest/route.js
function c8(e5) {
  return "esri.rest.support.FeatureSet" === (e5 == null ? void 0 : e5.declaredClass);
}
async function l5(r6, t6, p9) {
  const l7 = [], y4 = [], d5 = {}, g4 = {}, h5 = n2(r6), { path: R3 } = h5;
  c8(t6.stops) && i6(t6.stops.features, y4, "stops.features", d5), c8(t6.pointBarriers) && i6(t6.pointBarriers.features, y4, "pointBarriers.features", d5), c8(t6.polylineBarriers) && i6(t6.polylineBarriers.features, y4, "polylineBarriers.features", d5), c8(t6.polygonBarriers) && i6(t6.polygonBarriers.features, y4, "polygonBarriers.features", d5);
  const v3 = await L(y4);
  for (const e5 in d5) {
    const r7 = d5[e5];
    l7.push(e5), g4[e5] = v3.slice(r7[0], r7[1]);
  }
  if (u3(g4, l7)) {
    let e5 = null;
    try {
      e5 = await f2(R3, t6.apiKey, p9);
    } catch {
    }
    e5 && !e5.hasZ && d4(g4, l7);
  }
  for (const e5 in g4)
    g4[e5].forEach((r7, s6) => {
      t6.get(e5)[s6].geometry = r7;
    });
  const B3 = { ...p9, query: { ...h5.query, ...u(t6), f: "json" } }, E = R3.endsWith("/solve") ? R3 : `${R3}/solve`, { data: T2 } = await U(E, B3);
  return m4(T2);
}
function m4(e5) {
  const { barriers: s6, directionLines: o5, directionPoints: a6, directions: i8, messages: n8, polygonBarriers: u7, polylineBarriers: f3, routes: c12, stops: l7, traversedEdges: m5, traversedJunctions: y4, traversedTurns: d5 } = e5, g4 = (e6) => {
    const r6 = R3.find((r7) => r7.routeName === e6);
    if (r(r6))
      return r6;
    const s7 = { routeId: R3.length + 1, routeName: e6 };
    return R3.push(s7), s7;
  }, h5 = (e6) => {
    const r6 = R3.find((r7) => r7.routeId === e6);
    if (r(r6))
      return r6;
    const s7 = { routeId: e6, routeName: null };
    return R3.push(s7), s7;
  }, R3 = [];
  c12 == null ? void 0 : c12.features.forEach((e6, r6) => {
    e6.geometry.spatialReference = c12.spatialReference;
    const t6 = e6.attributes.Name, s7 = r6 + 1;
    R3.push({ routeId: s7, routeName: t6, route: e6 });
  }), i8 == null ? void 0 : i8.forEach((e6) => {
    const { routeName: r6 } = e6;
    g4(r6).directions = e6;
  });
  const v3 = ((l7 == null ? void 0 : l7.features.every((e6) => t(e6.attributes.RouteName))) ?? false) && R3.length > 0 ? R3[0].routeName : null;
  return l7 == null ? void 0 : l7.features.forEach((e6) => {
    var r6;
    e6.geometry && ((r6 = e6.geometry).spatialReference ?? (r6.spatialReference = l7.spatialReference));
    const t6 = v3 ?? e6.attributes.RouteName, s7 = g4(t6);
    s7.stops ?? (s7.stops = []), s7.stops.push(e6);
  }), o5 == null ? void 0 : o5.features.forEach((e6) => {
    const r6 = e6.attributes.RouteID, t6 = h5(r6), { geometryType: s7, spatialReference: a7 } = o5;
    t6.directionLines ?? (t6.directionLines = { features: [], geometryType: s7, spatialReference: a7 }), t6.directionLines.features.push(e6);
  }), a6 == null ? void 0 : a6.features.forEach((e6) => {
    const r6 = e6.attributes.RouteID, t6 = h5(r6), { geometryType: s7, spatialReference: o6 } = a6;
    t6.directionPoints ?? (t6.directionPoints = { features: [], geometryType: s7, spatialReference: o6 }), t6.directionPoints.features.push(e6);
  }), m5 == null ? void 0 : m5.features.forEach((e6) => {
    const r6 = e6.attributes.RouteID, t6 = h5(r6), { geometryType: s7, spatialReference: o6 } = m5;
    t6.traversedEdges ?? (t6.traversedEdges = { features: [], geometryType: s7, spatialReference: o6 }), t6.traversedEdges.features.push(e6);
  }), y4 == null ? void 0 : y4.features.forEach((e6) => {
    const r6 = e6.attributes.RouteID, t6 = h5(r6), { geometryType: s7, spatialReference: o6 } = y4;
    t6.traversedJunctions ?? (t6.traversedJunctions = { features: [], geometryType: s7, spatialReference: o6 }), t6.traversedJunctions.features.push(e6);
  }), d5 == null ? void 0 : d5.features.forEach((e6) => {
    const r6 = e6.attributes.RouteID, t6 = h5(r6);
    t6.traversedTurns ?? (t6.traversedTurns = { features: [] }), t6.traversedTurns.features.push(e6);
  }), c7.fromJSON({ routeResults: R3, barriers: s6, polygonBarriers: u7, polylineBarriers: f3, messages: n8 });
}

// node_modules/@arcgis/core/rest/support/DataLayer.js
var l6 = class extends l2(l) {
  constructor(o5) {
    super(o5), this.doNotLocateOnRestrictedElements = null, this.geometry = null, this.geometryType = null, this.name = null, this.spatialRelationship = null, this.type = "layer", this.where = null;
  }
};
e([d({ type: Boolean, json: { write: true } })], l6.prototype, "doNotLocateOnRestrictedElements", void 0), e([d({ types: i2, json: { read: d2, write: true } })], l6.prototype, "geometry", void 0), e([r4(w)], l6.prototype, "geometryType", void 0), e([d({ type: String, json: { name: "layerName", write: true } })], l6.prototype, "name", void 0), e([r4(R, { name: "spatialRel" })], l6.prototype, "spatialRelationship", void 0), e([d({ type: String, json: { write: true } })], l6.prototype, "type", void 0), e([d({ type: String, json: { write: true } })], l6.prototype, "where", void 0), l6 = e([n("esri.rest.support.DataLayer")], l6);
var c9 = l6;

// node_modules/@arcgis/core/rest/support/NetworkFeatureSet.js
var s5;
var c10 = s5 = class extends x {
  constructor(e5) {
    super(e5), this.doNotLocateOnRestrictedElements = null;
  }
  clone() {
    return new s5({ doNotLocateOnRestrictedElements: this.doNotLocateOnRestrictedElements, ...this.cloneProperties() });
  }
};
e([d({ type: Boolean, json: { write: true } })], c10.prototype, "doNotLocateOnRestrictedElements", void 0), c10 = s5 = e([n("esri.rest.support.NetworkFeatureSet")], c10);
var p7 = c10;

// node_modules/@arcgis/core/rest/support/NetworkUrl.js
var p8 = class extends l2(l) {
  constructor(o5) {
    super(o5), this.doNotLocateOnRestrictedElements = null, this.url = null;
  }
};
e([d({ type: Boolean, json: { write: true } })], p8.prototype, "doNotLocateOnRestrictedElements", void 0), e([d({ type: String, json: { write: true } })], p8.prototype, "url", void 0), p8 = e([n("esri.rest.support.NetworkUrl")], p8);
var c11 = p8;

// node_modules/@arcgis/core/rest/support/RouteParameters.js
var O3;
function U3(t6) {
  return t6 && "type" in t6;
}
function J(t6) {
  return t6 && "features" in t6 && "doNotLocateOnRestrictedElements" in t6;
}
function L2(t6) {
  return t6 && "url" in t6;
}
function R2(t6) {
  return t6 && "features" in t6;
}
function C(t6) {
  return U3(t6) ? c9.fromJSON(t6) : L2(t6) ? c11.fromJSON(t6) : J(t6) ? p7.fromJSON(t6) : R2(t6) ? x.fromJSON(t6) : null;
}
function D2(t6, e5, o5) {
  r(t6) && (e5[o5] = j2.isCollection(t6) ? { features: t6.toArray().map((t7) => t7.toJSON()) } : t6.toJSON());
}
var k3 = O3 = class extends l2(l) {
  constructor(t6) {
    super(t6), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = "true-shape", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = false, this.returnDirections = false, this.returnPolygonBarriers = false, this.returnPolylineBarriers = false, this.returnRoutes = true, this.returnStops = false, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = true, this.startTime = null, this.startTimeIsUTC = true, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;
  }
  static from(t6) {
    return v(O3, t6);
  }
  readAccumulateAttributes(t6) {
    return t(t6) ? null : t6.map((t7) => T.fromJSON(t7));
  }
  writeAccumulateAttributes(t6, e5, r6) {
    !t(t6) && t6.length && (e5[r6] = t6.map((t7) => T.toJSON(t7)));
  }
  writePointBarriers(t6, e5, r6) {
    D2(t6, e5, r6);
  }
  writePolygonBarrier(t6, e5, r6) {
    D2(t6, e5, r6);
  }
  writePolylineBarrier(t6, e5, r6) {
    D2(t6, e5, r6);
  }
  readRestrictionAttributes(t6) {
    return t(t6) ? null : t6.map((t7) => U2.fromJSON(t7));
  }
  writeRestrictionAttributes(t6, e5, r6) {
    !t(t6) && t6.length && (e5[r6] = t6.map((t7) => U2.toJSON(t7)));
  }
  readStartTime(t6, e5) {
    const { startTime: r6 } = e5;
    return t(r6) ? null : "now" === r6 ? "now" : new Date(r6);
  }
  writeStartTime(t6, e5) {
    t(t6) || (e5.startTime = "now" === t6 ? "now" : t6.getTime());
  }
  readStops(t6, e5) {
    return C(e5.stops);
  }
  writeStops(t6, e5, r6) {
    D2(t6, e5, r6);
  }
};
e([d({ type: [String], json: { name: "accumulateAttributeNames", write: true } })], k3.prototype, "accumulateAttributes", void 0), e([o2("accumulateAttributes")], k3.prototype, "readAccumulateAttributes", null), e([r3("accumulateAttributes")], k3.prototype, "writeAccumulateAttributes", null), e([d(t5)], k3.prototype, "apiKey", void 0), e([d({ json: { write: true } })], k3.prototype, "attributeParameterValues", void 0), e([d({ type: String, json: { write: true } })], k3.prototype, "directionsLanguage", void 0), e([r4(r5)], k3.prototype, "directionsLengthUnits", void 0), e([r4(s4)], k3.prototype, "directionsOutputType", void 0), e([r4(k2)], k3.prototype, "directionsStyleName", void 0), e([r4(y2, { name: "directionsTimeAttributeName", ignoreUnknown: false })], k3.prototype, "directionsTimeAttribute", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "findBestSequence", void 0), e([d({ type: Number, json: { write: true } })], k3.prototype, "geometryPrecision", void 0), e([d({ type: Number, json: { write: true } })], k3.prototype, "geometryPrecisionM", void 0), e([d({ type: Number, json: { write: true } })], k3.prototype, "geometryPrecisionZ", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "ignoreInvalidLocations", void 0), e([r4(T, { name: "impedanceAttributeName", ignoreUnknown: false })], k3.prototype, "impedanceAttribute", void 0), e([d({ type: Number, json: { write: true } })], k3.prototype, "outputGeometryPrecision", void 0), e([r4(i4)], k3.prototype, "outputGeometryPrecisionUnits", void 0), e([r4(o4)], k3.prototype, "outputLines", void 0), e([d({ type: k, json: { name: "outSR", write: true } })], k3.prototype, "outSpatialReference", void 0), e([d({ json: { write: true } })], k3.prototype, "overrides", void 0), e([d({ json: { name: "barriers", write: true } })], k3.prototype, "pointBarriers", void 0), e([r3("pointBarriers")], k3.prototype, "writePointBarriers", null), e([d({ json: { write: true } })], k3.prototype, "polygonBarriers", void 0), e([r3("polygonBarriers")], k3.prototype, "writePolygonBarrier", null), e([d({ json: { write: true } })], k3.prototype, "polylineBarriers", void 0), e([r3("polylineBarriers")], k3.prototype, "writePolylineBarrier", null), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "preserveFirstStop", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "preserveLastStop", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "preserveObjectID", void 0), e([d({ type: [String], json: { name: "restrictionAttributeNames", write: true } })], k3.prototype, "restrictionAttributes", void 0), e([o2("restrictionAttributes")], k3.prototype, "readRestrictionAttributes", null), e([r3("restrictionAttributes")], k3.prototype, "writeRestrictionAttributes", null), e([r4(n3)], k3.prototype, "restrictUTurns", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnBarriers", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnDirections", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnPolygonBarriers", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnPolylineBarriers", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnRoutes", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnStops", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnTraversedEdges", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnTraversedJunctions", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnTraversedTurns", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "returnZ", void 0), e([d({ type: Date, json: { type: Number, write: true } })], k3.prototype, "startTime", void 0), e([o2("startTime")], k3.prototype, "readStartTime", null), e([r3("startTime")], k3.prototype, "writeStartTime", null), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "startTimeIsUTC", void 0), e([d({ json: { write: true } })], k3.prototype, "stops", void 0), e([o2("stops")], k3.prototype, "readStops", null), e([r3("stops")], k3.prototype, "writeStops", null), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "timeWindowsAreUTC", void 0), e([d({ type: h, json: { write: true } })], k3.prototype, "travelMode", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "useHierarchy", void 0), e([d({ type: Boolean, json: { write: true } })], k3.prototype, "useTimeWindows", void 0), k3 = O3 = e([n("esri.rest.support.RouteParameters")], k3);
var I = k3;

// node_modules/@arcgis/core/layers/RouteLayer.js
function X(e5) {
  return e5.length ? e5 : null;
}
function ee(e5) {
  const { defaultTravelMode: t6, supportedTravelModes: r6 } = e5;
  return r6.find((e6) => e6.id === t6);
}
function te(e5) {
  switch (e5) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: te("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: te("esriGeometryPolyline") };
  }
}
function re(e5) {
  return "layers" in e5;
}
function oe(e5) {
  return "esri.rest.support.FeatureSet" === e5.declaredClass;
}
function ie(e5) {
  return "esri.rest.support.NetworkFeatureSet" === e5.declaredClass;
}
function se(e5, t6, r6) {
  var _a;
  const o5 = t6.networkDataset.networkAttributes.filter((e6) => "cost" === e6.usageType), i8 = ee(t6), s6 = r6.travelMode ?? i8;
  if (t(s6))
    return void he.warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
  const { timeAttributeName: a6, distanceAttributeName: l7 } = s6, m5 = o5.find((e6) => e6.name === a6), y4 = o5.find((e6) => e6.name === l7), f3 = ((_a = e2(r6.travelMode)) == null ? void 0 : _a.impedanceAttributeName) ?? e2(r6.impedanceAttribute) ?? t6.impedance, d5 = t4.fromJSON(m5 == null ? void 0 : m5.units), h5 = r5.fromJSON(y4 == null ? void 0 : y4.units);
  if (!d5 || !h5)
    throw new s3("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
  const w2 = r6.directionsLanguage ?? t6.directionsLanguage, S3 = e2(r6.accumulateAttributes) ?? t6.accumulateAttributeNames ?? [], g4 = new Set(o5.filter(({ name: e6 }) => e6 === a6 || e6 === l7 || e6 === f3 || S3.includes(e6)).map(({ name: e6 }) => e6)), b5 = (e6) => {
    for (const t7 in e6)
      g4.has(t7) || delete e6[t7];
  };
  for (const n8 of e5.pointBarriers)
    r(n8.costs) && (n8.addedCost = n8.costs[f3] ?? 0, b5(n8.costs));
  for (const n8 of e5.polygonBarriers)
    r(n8.costs) && (n8.scaleFactor = n8.costs[f3] ?? 1, b5(n8.costs));
  for (const n8 of e5.polylineBarriers)
    r(n8.costs) && (n8.scaleFactor = n8.costs[f3] ?? 1, b5(n8.costs));
  const { routeInfo: v3 } = e5, { findBestSequence: B3, preserveFirstStop: P, preserveLastStop: j5, startTimeIsUTC: I2, timeWindowsAreUTC: _ } = r6;
  v3.analysisSettings = new l3({ accumulateAttributes: S3, directionsLanguage: w2, findBestSequence: B3, preserveFirstStop: P, preserveLastStop: j5, startTimeIsUTC: I2, timeWindowsAreUTC: _, travelMode: s6 }), v3.totalDuration = ae(v3.totalCosts[a6] ?? 0, d5), v3.totalDistance = le(v3.totalCosts[l7] ?? 0, h5), v3.totalLateDuration = ae(v3.totalViolations[a6] ?? 0, d5), v3.totalWaitDuration = ae(v3.totalWait[a6] ?? 0, d5), r(v3.totalCosts) && b5(v3.totalCosts), r(v3.totalViolations) && b5(v3.totalViolations), r(v3.totalWait) && b5(v3.totalWait);
  for (const n8 of e5.stops)
    r(n8.serviceCosts) && (n8.serviceDuration = ae(n8.serviceCosts[a6] ?? 0, d5), n8.serviceDistance = le(n8.serviceCosts[l7] ?? 0, h5), b5(n8.serviceCosts)), r(n8.cumulativeCosts) && (n8.cumulativeDuration = ae(n8.cumulativeCosts[a6] ?? 0, d5), n8.cumulativeDistance = le(n8.cumulativeCosts[l7] ?? 0, h5), b5(n8.cumulativeCosts)), r(n8.violations) && (n8.lateDuration = ae(n8.violations[a6] ?? 0, d5), b5(n8.violations)), r(n8.wait) && (n8.waitDuration = ae(n8.wait[a6] ?? 0, d5), b5(n8.wait));
}
async function ne(e5) {
  const t6 = k.WGS84;
  return await fn(e5.spatialReference, t6), rn(e5, t6);
}
function ae(e5, t6) {
  switch (t6) {
    case "seconds":
      return e5 / 60;
    case "hours":
      return 60 * e5;
    case "days":
      return 60 * e5 * 24;
    default:
      return e5;
  }
}
function le(e5, t6) {
  return "decimal-degrees" === t6 || "points" === t6 || "unknown" === t6 ? e5 : N(e5, t6, "meters");
}
function pe(e5) {
  const { attributes: t6, geometry: r6, popupTemplate: o5, symbol: i8 } = e5.toGraphic().toJSON();
  return { attributes: t6, geometry: r6, popupInfo: o5, symbol: i8 };
}
var ue = j2.ofType(b4);
var me = j2.ofType(h2);
var ce = j2.ofType(O2);
var ye = j2.ofType(g2);
var fe = j2.ofType(h3);
var de = j2.ofType(D);
var he = s2.getLogger("esri.layers.RouteLayer");
var we = class extends a3(t3(c2(v2(O(a2(b2)))))) {
  constructor(e5) {
    super(e5), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.defaultSymbols = new n4(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new ce(), this.polygonBarriers = new ye(), this.polylineBarriers = new fe(), this.routeInfo = null, this.spatialReference = k.WGS84, this.stops = new de(), this.type = "route";
    const t6 = () => {
      this._setStopSymbol(this.stops);
    };
    this.own([a(() => this.stops, "change", t6, { sync: true, onListenerAdd: t6 })]);
  }
  writeFeatureCollectionWebmap(e5, t6, r6, o5) {
    const i8 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e6) => !!e6), s6 = i8.map((e6, t7) => t7), n8 = "web-map" === o5.origin ? "featureCollection.layers" : "layers";
    o(n8, i8, t6), t6.opacity = this.opacity, t6.visibility = this.visible, t6.visibleLayers = s6;
  }
  readDirectionLines(e5, t6) {
    return this._getNetworkFeatures(t6, "DirectionLines", (e6) => b4.fromGraphic(e6));
  }
  readDirectionPoints(e5, t6) {
    return this._getNetworkFeatures(t6, "DirectionPoints", (e6) => h2.fromGraphic(e6));
  }
  get fullExtent() {
    const e5 = new M({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: k.WGS84 });
    if (r(this.routeInfo) && r(this.routeInfo.geometry))
      return this.routeInfo.geometry.extent ?? e5;
    if (t(this.stops))
      return e5;
    const t6 = this.stops.filter((e6) => r(e6.geometry));
    if (t6.length < 2)
      return e5;
    const { spatialReference: r6 } = t6.getItemAt(0).geometry;
    if (t(r6))
      return e5;
    const o5 = t6.toArray().map((e6) => {
      const t7 = e6.geometry;
      return [t7.x, t7.y];
    });
    return new m({ points: o5, spatialReference: r6 }).extent;
  }
  readMaxScale(e5, t6) {
    var _a;
    return ((_a = (re(t6) ? t6.layers : t6.featureCollection.layers).find((e6) => r(e6.layerDefinition.maxScale))) == null ? void 0 : _a.layerDefinition.maxScale) ?? 0;
  }
  readMinScale(e5, t6) {
    var _a;
    return ((_a = (re(t6) ? t6.layers : t6.featureCollection.layers).find((e6) => r(e6.layerDefinition.minScale))) == null ? void 0 : _a.layerDefinition.minScale) ?? 0;
  }
  readPointBarriers(e5, t6) {
    return this._getNetworkFeatures(t6, "Barriers", (e6) => O2.fromGraphic(e6));
  }
  readPolygonBarriers(e5, t6) {
    return this._getNetworkFeatures(t6, "PolygonBarriers", (e6) => g2.fromGraphic(e6));
  }
  readPolylineBarriers(e5, t6) {
    return this._getNetworkFeatures(t6, "PolylineBarriers", (e6) => h3.fromGraphic(e6));
  }
  readRouteInfo(e5, t6) {
    const r6 = this._getNetworkFeatures(t6, "RouteInfo", (e6) => h4.fromGraphic(e6));
    return r6.length > 0 ? r6.getItemAt(0) : null;
  }
  readSpatialReference(e5, t6) {
    const r6 = re(t6) ? t6.layers : t6.featureCollection.layers;
    if (!r6.length)
      return k.WGS84;
    const { layerDefinition: o5 } = r6[0], i8 = o5.spatialReference ?? o5.extent.spatialReference ?? c;
    return k.fromJSON(i8);
  }
  readStops(e5, t6) {
    return this._getNetworkFeatures(t6, "Stops", (e6) => D.fromGraphic(e6), (e6) => this._setStopSymbol(e6));
  }
  get title() {
    return r(this.routeInfo) && r(this.routeInfo.name) ? this.routeInfo.name : "Route";
  }
  set title(e5) {
    e5 ? this._override("title", e5) : this._clearOverride("title");
  }
  get url() {
    return r2.routeServiceUrl;
  }
  set url(e5) {
    null != e5 ? this._set("url", S(e5, he)) : this._set("url", r2.routeServiceUrl);
  }
  load(e5) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e5)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    r(this.directionLines) && (this.directionLines.removeAll(), this._set("directionLines", null)), r(this.directionPoints) && (this.directionPoints.removeAll(), this._set("directionPoints", null)), r(this.routeInfo) && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e5, portalItem: t6 } = this;
    if (!t6)
      throw new s3("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t6.id)
      throw new s3("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t6.type)
      throw new s3("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (t(this.routeInfo))
      throw new s3("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r6 } = t6;
    await r6._signIn(), r6.user || await t6.reload();
    const { itemUrl: o5, itemControl: i8 } = t6;
    if ("admin" !== i8 && "update" !== i8)
      throw new s3("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const s6 = { messages: [], origin: "portal-item", portal: r6, url: o5 && j3(o5), writtenProperties: [] }, a6 = this.write(null, s6);
    return t6.extent = await ne(e5), t6.title = this.title, await t6.update({ data: a6 }), t6;
  }
  async saveAs(e5, t6 = {}) {
    if (await this.load(), t(this.routeInfo))
      throw new s3("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r6 = b.from(e5).clone();
    r6.extent ?? (r6.extent = await ne(this.fullExtent)), r6.id = null, r6.portal ?? (r6.portal = B.getDefault()), r6.title ?? (r6.title = this.title), r6.type = "Feature Collection", r6.typeKeywords = ["Data", "Feature Collection", f.MULTI_LAYER, "Route Layer"];
    const { portal: o5 } = r6, i8 = { messages: [], origin: "portal-item", portal: o5, url: null, writtenProperties: [] };
    await o5._signIn();
    const s6 = t6 == null ? void 0 : t6.folder, a6 = this.write(null, i8);
    return await o5.user.addItem({ item: r6, folder: s6, data: a6 }), this.portalItem = r6, i3(i8), i8.portalItem = r6, r6;
  }
  async solve(e5, t6) {
    const r6 = (e5 == null ? void 0 : e5.stops) ?? this.stops, o5 = (e5 == null ? void 0 : e5.pointBarriers) ?? X(this.pointBarriers), i8 = (e5 == null ? void 0 : e5.polylineBarriers) ?? X(this.polylineBarriers), a6 = (e5 == null ? void 0 : e5.polygonBarriers) ?? X(this.polygonBarriers);
    if (t(r6))
      throw new s3("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((oe(r6) || ie(r6)) && r6.features.length < 2 || j2.isCollection(r6) && r6.length < 2)
      throw new s3("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (j2.isCollection(r6))
      for (const s6 of r6)
        s6.routeName = null;
    const l7 = e5 == null ? void 0 : e5.apiKey, c12 = this.url, y4 = await this._getServiceDescription(c12, l7, t6), f3 = ee(y4), h5 = (e5 == null ? void 0 : e5.travelMode) ?? f3, w2 = i(e5 == null ? void 0 : e5.accumulateAttributes, []);
    r(h5) && (w2.push(h5.distanceAttributeName), h5.timeAttributeName && w2.push(h5.timeAttributeName));
    const S3 = { startTime: /* @__PURE__ */ new Date() }, g4 = { accumulateAttributes: w2, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o5, polylineBarriers: i8, polygonBarriers: a6, preserveFirstStop: true, preserveLastStop: true, returnBarriers: !!o5, returnDirections: true, returnPolygonBarriers: !!a6, returnPolylineBarriers: !!i8, returnRoutes: true, returnStops: true, stops: r6 }, b5 = e5 ? I.from(e5) : new I();
    for (const s6 in S3)
      null == b5[s6] && (b5[s6] = S3[s6]);
    let v3;
    b5.set(g4);
    try {
      v3 = await l5(c12, b5, t6);
    } catch (P) {
      throw g(P) ? P : new s3("routelayer:failed-route-request", "the routing request failed", { error: P });
    }
    const B3 = this._toRouteLayerSolution(v3);
    return this._isOverridden("title") || (this.title = i(B3.routeInfo.name, "Route")), se(B3, y4, b5), B3;
  }
  update(e5) {
    const { stops: t6, directionLines: r6, directionPoints: o5, pointBarriers: i8, polylineBarriers: s6, polygonBarriers: n8, routeInfo: a6 } = e5;
    this.set({ stops: t6, pointBarriers: i8, polylineBarriers: s6, polygonBarriers: n8 }), this._set("directionLines", r6), this._set("directionPoints", o5), this._set("routeInfo", a6);
  }
  _getNetworkFeatures(e5, t6, n8, a6) {
    const l7 = (re(e5) ? e5.layers : e5.featureCollection.layers).find((e6) => e6.layerDefinition.name === t6);
    if (t(l7))
      return new j2();
    const { layerDefinition: p9, popupInfo: m5, featureSet: c12 } = l7, y4 = p9.drawingInfo.renderer, { features: f3 } = c12, d5 = y4 && o3(y4), h5 = f3.map((e6) => {
      const i8 = g3.fromJSON(e6), s6 = n8(i8);
      return s6.symbol ?? (s6.symbol = (d5 == null ? void 0 : d5.getSymbol(i8)) ?? this._getNetworkSymbol(t6)), s6.popupTemplate ?? (s6.popupTemplate = m5 && B2.fromJSON(m5)), s6;
    });
    return a6 && h5.some((e6) => !e6.symbol) && a6(h5), new j2(h5);
  }
  _getNetworkSymbol(e5) {
    switch (e5) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e5, t6, r6) {
    if (r(this._cachedServiceDescription) && this._cachedServiceDescription.url === e5)
      return this._cachedServiceDescription.serviceDescription;
    const o5 = await f2(e5, t6, r6);
    return this._cachedServiceDescription = { serviceDescription: o5, url: e5 }, o5;
  }
  _setStopSymbol(e5) {
    if (!e5 || 0 === e5.length)
      return;
    if (t(this.defaultSymbols.stops))
      return;
    if (e5.every((e6) => r(e6.symbol)))
      return;
    const { first: t6, last: r6, middle: o5, unlocated: i8, waypoint: s6, break: n8 } = this.defaultSymbols.stops;
    if (t(this.routeInfo) || 1 === e5.length)
      return void e5.forEach((i9, s7) => {
        switch (s7) {
          case 0:
            i9.symbol = t6;
            break;
          case e5.length - 1:
            i9.symbol = r6;
            break;
          default:
            i9.symbol = o5;
        }
      });
    const a6 = e5.map((e6) => e6.sequence).filter((e6) => r(e6)), l7 = Math.min(...a6), m5 = Math.max(...a6);
    for (const p9 of e5)
      p9.sequence !== l7 ? p9.sequence !== m5 ? "ok" === p9.status || "not-located-on-closest" === p9.status ? "waypoint" !== p9.locationType ? "break" !== p9.locationType ? p9.symbol = o5 : p9.symbol = n8 : p9.symbol = s6 : p9.symbol = i8 : p9.symbol = r6 : p9.symbol = t6;
  }
  _toRouteLayerSolution(e5) {
    var _a, _b, _c, _d, _e;
    const t6 = e5.routeResults[0].stops.map((e6) => D.fromJSON(e6.toJSON()));
    this._setStopSymbol(t6);
    const r6 = new de(t6), o5 = new ye((_a = e5.polygonBarriers) == null ? void 0 : _a.map((e6) => {
      const t7 = g2.fromJSON(e6.toJSON());
      return t7.symbol = this.defaultSymbols.polygonBarriers, t7;
    })), i8 = new fe((_b = e5.polylineBarriers) == null ? void 0 : _b.map((e6) => {
      const t7 = h3.fromJSON(e6.toJSON());
      return t7.symbol = this.defaultSymbols.polylineBarriers, t7;
    })), s6 = new ce((_c = e5.pointBarriers) == null ? void 0 : _c.map((e6) => {
      const t7 = O2.fromJSON(e6.toJSON());
      return t7.symbol = this.defaultSymbols.pointBarriers, t7;
    })), n8 = h4.fromJSON(e5.routeResults[0].route.toJSON());
    n8.symbol = this.defaultSymbols.routeInfo;
    const a6 = new me((_d = e5.routeResults[0].directionPoints) == null ? void 0 : _d.features.map((e6) => {
      const t7 = h2.fromJSON(e6.toJSON());
      return t7.symbol = this.defaultSymbols.directionPoints, t7;
    }));
    return { directionLines: new ue((_e = e5.routeResults[0].directionLines) == null ? void 0 : _e.features.map((e6) => {
      const t7 = b4.fromJSON(e6.toJSON());
      return t7.symbol = this.defaultSymbols.directionLines, t7;
    })), directionPoints: a6, pointBarriers: s6, polygonBarriers: o5, polylineBarriers: i8, routeInfo: n8, stops: r6 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", b4.fields, b4.popupInfo, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", h2.fields, h2.popupInfo, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e5, t6, r6, o5, i8, s6, n8) {
    return t(e5) || !e5.length ? null : { featureSet: { features: e5.toArray().map((e6) => pe(e6)), geometryType: r6 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: r(t6) ? t6.toJSON() : te(r6) } }, extent: this.fullExtent.toJSON(), fields: o5, geometryType: r6, hasM: false, hasZ: false, maxScale: this.maxScale, minScale: this.minScale, name: s6, objectIdField: "__OBJECTID", spatialReference: this.spatialReference.toJSON(), title: n8, type: "Feature Layer", typeIdField: "" }, popupInfo: i8 };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", O2.fields, O2.popupInfo, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", g2.fields, g2.popupInfo, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", h3.fields, h3.popupInfo, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(r(this.routeInfo) ? new j2([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", h4.fields, h4.popupInfo, "RouteInfo", "Route Details");
  }
  _writeStops() {
    const e5 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", D.fields, D.popupInfo, "Stops", "Stops");
    if (t(e5))
      return null;
    const { stops: t6 } = this.defaultSymbols, r6 = r(t6) && r(t6.first) && t6.first.toJSON(), o5 = r(t6) && r(t6.middle) && t6.middle.toJSON(), i8 = r(t6) && r(t6.last) && t6.last.toJSON();
    return e5.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o5, uniqueValueInfos: [{ value: "1", symbol: r6, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i8, label: "Last Stop" }] }, e5;
  }
};
e([d({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], we.prototype, "_featureCollection", void 0), e([r3(["web-map", "portal-item"], "_featureCollection")], we.prototype, "writeFeatureCollectionWebmap", null), e([d({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], we.prototype, "_type", void 0), e([d({ nonNullable: true, type: n4 })], we.prototype, "defaultSymbols", void 0), e([d({ readOnly: true })], we.prototype, "directionLines", void 0), e([o2(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], we.prototype, "readDirectionLines", null), e([d({ readOnly: true })], we.prototype, "directionPoints", void 0), e([o2(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], we.prototype, "readDirectionPoints", null), e([d({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], we.prototype, "featureCollectionType", void 0), e([d({ readOnly: true })], we.prototype, "fullExtent", null), e([d({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], we.prototype, "legendEnabled", void 0), e([d({ type: ["show", "hide"] })], we.prototype, "listMode", void 0), e([d({ type: Number, nonNullable: true, json: { write: false } })], we.prototype, "maxScale", void 0), e([o2(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], we.prototype, "readMaxScale", null), e([d({ type: Number, nonNullable: true, json: { write: false } })], we.prototype, "minScale", void 0), e([o2(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], we.prototype, "readMinScale", null), e([d({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], we.prototype, "operationalLayerType", void 0), e([d({ nonNullable: true, type: j2.ofType(O2) })], we.prototype, "pointBarriers", void 0), e([o2(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], we.prototype, "readPointBarriers", null), e([d({ nonNullable: true, type: j2.ofType(g2) })], we.prototype, "polygonBarriers", void 0), e([o2(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], we.prototype, "readPolygonBarriers", null), e([d({ nonNullable: true, type: j2.ofType(h3) })], we.prototype, "polylineBarriers", void 0), e([o2(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], we.prototype, "readPolylineBarriers", null), e([d({ readOnly: true })], we.prototype, "routeInfo", void 0), e([o2(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], we.prototype, "readRouteInfo", null), e([d({ type: k })], we.prototype, "spatialReference", void 0), e([o2(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], we.prototype, "readSpatialReference", null), e([d({ nonNullable: true, type: j2.ofType(D) })], we.prototype, "stops", void 0), e([o2(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], we.prototype, "readStops", null), e([d()], we.prototype, "title", null), e([d({ readOnly: true, json: { read: false } })], we.prototype, "type", void 0), e([d()], we.prototype, "url", null), we = e([n("esri.layers.RouteLayer")], we);
var Se = we;
export {
  Se as default
};
//# sourceMappingURL=RouteLayer-K677QJND.js.map
