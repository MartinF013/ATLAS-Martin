import {
  k
} from "./chunk-ZEDAE7EU.js";
import {
  A,
  O,
  P as P2,
  W,
  Z,
  p2 as p3
} from "./chunk-53KI6WDE.js";
import {
  j
} from "./chunk-W2HLA6I3.js";
import {
  l,
  v
} from "./chunk-Q6AASANP.js";
import {
  e as e2
} from "./chunk-YFBAFAZ2.js";
import {
  l as l2
} from "./chunk-ZN2MGN4S.js";
import {
  n as n3
} from "./chunk-RTHP2LNT.js";
import {
  Bn,
  qn,
  zn
} from "./chunk-PZWU5EHT.js";
import {
  h
} from "./chunk-ASC3X65B.js";
import {
  n as n2
} from "./chunk-P6G64ARX.js";
import {
  p
} from "./chunk-RN2KRYDN.js";
import {
  B,
  a,
  h as h2
} from "./chunk-TMBOFNWA.js";
import {
  p as p2,
  u as u2
} from "./chunk-56RHM4A6.js";
import {
  s
} from "./chunk-BPZGJQOB.js";
import {
  H,
  L,
  P,
  e,
  o,
  q,
  r,
  u,
  x,
  z
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";

// node_modules/@arcgis/core/views/3d/support/intersectionUtils.js
function h3(r2, n4, t, i) {
  return b(r2, n4, t, k2(i, n4, t, true));
}
function j2(r2, c, u3, o2) {
  const s2 = P(u3, e(r2, o2, c));
  return u(r2, c, q(r2, u3, s2));
}
var g = { dir: n(), len: 0, clip: n3() };
function k2(r2, n4, i, s2) {
  const f = g;
  return r2 ? (i && s2 && (f.len = x(n4, i)), r(f.dir, r2)) : s2 ? (f.len = x(n4, i), e(f.dir, i, n4), q(f.dir, f.dir, 1 / f.len)) : (e(f.dir, i, n4), z(f.dir, f.dir)), f;
}
function v2(r2, t, i) {
  const e3 = P(Z(r2), i.dir), c = -W(r2, t);
  if (c < 0 && e3 >= 0)
    return false;
  if (e3 > -1e-6 && e3 < 1e-6)
    return c > 0;
  if ((c < 0 || e3 < 0) && !(c < 0 && e3 < 0))
    return true;
  const u3 = c / e3;
  return e3 > 0 ? u3 < i.clip[1] && (i.clip[1] = u3) : u3 > i.clip[0] && (i.clip[0] = u3), i.clip[0] <= i.clip[1];
}
function b(r2, n4, t, i) {
  i.clip[0] = 0, i.clip[1] = t ? i.len : Number.MAX_VALUE;
  for (let e3 = 0; e3 < r2.length; e3++)
    if (!v2(r2[e3], n4, i))
      return false;
  return true;
}

// node_modules/@arcgis/core/views/3d/support/FrustumExtentIntersection.js
var F = 0.5 * Math.PI;
var N = F / Math.PI * 180;
var _ = class {
  constructor(t) {
    this.renderCoordsHelper = t.renderCoordsHelper, this.extent = new Array(4), this.planes = new Array(6), this.maxSpan = 0, this.center = { origin: n(), direction: n() };
    for (let e3 = 0; e3 < 4; e3++)
      this.extent[e3] = { origin: n(), direction: n(), cap: { next: null, direction: n() } }, this.planes[e3] = p3();
    this.planes[k.NEAR] = p3(), this.planes[k.FAR] = p3(), this.planesWithoutFar = this.planes.slice(0, 5);
  }
  update(t, e3, i, r2 = true) {
    const a2 = this.extent;
    this._toRenderBoundingExtent(t, e3, i), u(this.center.origin, a2[0].origin, a2[2].origin), q(this.center.origin, this.center.origin, 0.5), this.renderCoordsHelper.worldUpAtPosition(this.center.origin, this.center.direction), r2 || q(this.center.direction, this.center.direction, -1);
    for (let n4 = 0; n4 < 4; n4++) {
      const t2 = a2[n4];
      this.renderCoordsHelper.worldUpAtPosition(t2.origin, t2.direction);
      const e4 = a2[3 === n4 ? 0 : n4 + 1];
      t2.cap.next = e4.origin, H(t2.cap.direction, t2.origin, e4.origin), O(t2.direction, t2.cap.direction, t2.origin, this.planes[n4]), r2 || q(t2.direction, t2.direction, -1);
    }
    O(a2[0].cap.direction, a2[1].cap.direction, a2[0].origin, this.planes[k.NEAR]), r2 ? P2(this.planes[k.NEAR], this.planes[k.FAR]) : (A(this.planes[k.FAR], this.planes[k.NEAR]), P2(this.planes[k.NEAR], this.planes[k.NEAR])), this.maxSpan = Math.max(Math.abs(t[0] - t[2]), Math.abs(t[1] - t[3])), this.maxSpanSpatialReference = e3, this.minGlobalAltitude = 0.9 * p(this.maxSpanSpatialReference).radius;
  }
  isVisibleInFrustum(t, e3, i = false) {
    if (null == t)
      return false;
    if (this.renderCoordsHelper.viewingMode === l2.Global) {
      const i2 = this.maxSpanSpatialReference.isGeographic ? N : F * e3;
      if (this.maxSpan > i2)
        return true;
      if (t.altitude >= this.minGlobalAltitude)
        return this._isVisibleInFrustumGlobal(t);
    }
    if (0 === this.maxSpan) {
      const e4 = this.extent[0];
      return !(i || !t.intersectsRay(j(e4.origin, e4.direction)));
    }
    for (let n4 = 0; n4 < this.extent.length; n4++) {
      const e4 = this.extent[n4];
      if (!i && t.intersectsRay(j(e4.origin, e4.direction)))
        return true;
      if (t.intersectsLineSegment(l(e4.origin, e4.cap.next, V), e4.cap.direction))
        return true;
    }
    const r2 = i ? this.planes : this.planesWithoutFar;
    for (let n4 = 0; n4 < t.lines.length; n4++) {
      const e4 = t.lines[n4];
      if (h3(r2, e4.origin, e4.endpoint, e4.direction))
        return true;
    }
    return false;
  }
  _toRenderBoundingExtentGlobal(t, r2, n4) {
    const o2 = 5;
    p2(t, v3), v3[2] = n4, qn(r2, v3, I, this.renderCoordsHelper.spatialReference), h(U, I), B(L2);
    for (const { x0: i, x1: s2, y0: c, y1: p4 } of k3)
      for (let l3 = 0; l3 < o2; l3++) {
        const h4 = l3 / (o2 - 1);
        v3[0] = s(t[i], t[s2], h4), v3[1] = s(t[c], t[p4], h4), v3[2] = n4, Bn(v3, r2, v3, this.renderCoordsHelper.spatialReference), L(v3, v3, U), h2(L2, v3);
      }
    o(this.extent[0].origin, L2[0], L2[1], L2[2]), o(this.extent[1].origin, L2[3], L2[1], L2[2]), o(this.extent[2].origin, L2[3], L2[4], L2[2]), o(this.extent[3].origin, L2[0], L2[4], L2[2]);
    for (let e3 = 0; e3 < 4; ++e3)
      L(this.extent[e3].origin, this.extent[e3].origin, I);
  }
  _toRenderBoundingExtentLocal(t, e3, i) {
    zn(t, e3, P3, this.renderCoordsHelper.spatialReference), o(this.extent[0].origin, P3[0], P3[1], i), o(this.extent[1].origin, P3[2], P3[1], i), o(this.extent[2].origin, P3[2], P3[3], i), o(this.extent[3].origin, P3[0], P3[3], i);
  }
  _toRenderBoundingExtent(e3, i, r2) {
    switch (this.renderCoordsHelper.viewingMode) {
      case l2.Global:
        this._toRenderBoundingExtentGlobal(e3, i, r2);
        break;
      case l2.Local:
        this._toRenderBoundingExtentLocal(e3, i, r2);
        break;
      default:
        n2(this.renderCoordsHelper.viewingMode);
    }
  }
  _isVisibleInFrustumGlobal(t) {
    if (W(t.planes[k.NEAR], this.center.origin) < 0 && P(this.center.direction, t.direction) < 0)
      return true;
    for (let e3 = 0; e3 < 4; e3++) {
      const i = this.extent[e3];
      if (W(t.planes[k.NEAR], i.origin) < 0 && P(i.direction, t.direction) < 0)
        return true;
    }
    return false;
  }
};
var k3 = [{ x0: 0, y0: 1, x1: 2, y1: 1 }, { x0: 0, y0: 3, x1: 2, y1: 3 }, { x0: 0, y0: 1, x1: 0, y1: 3 }, { x0: 2, y0: 1, x1: 2, y1: 3 }];
var v3 = n();
var I = e2();
var U = e2();
var L2 = a();
var P3 = u2();
var V = v();

export {
  j2 as j,
  _
};
//# sourceMappingURL=chunk-HU4BCST4.js.map
