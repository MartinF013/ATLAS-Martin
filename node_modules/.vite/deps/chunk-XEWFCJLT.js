import {
  P
} from "./chunk-ZEDAE7EU.js";
import {
  c
} from "./chunk-NAIF4GWX.js";
import {
  E,
  X,
  _,
  j,
  k2 as k,
  q as q2
} from "./chunk-W2HLA6I3.js";
import {
  A,
  p,
  q,
  r as r3,
  u
} from "./chunk-PKZEO23A.js";
import {
  n as n2,
  r as r2
} from "./chunk-AIRC226G.js";
import {
  n4 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-5EQKHR4M.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Octree.js
var g = class {
  constructor(e2, t) {
    this._objectToBoundingSphere = e2, this._maximumObjectsPerNode = 10, this._maximumDepth = 20, this._degenerateObjects = /* @__PURE__ */ new Set(), this._root = new O(), this._objectCount = 0, t && (void 0 !== t.maximumObjectsPerNode && (this._maximumObjectsPerNode = t.maximumObjectsPerNode), void 0 !== t.maximumDepth && (this._maximumDepth = t.maximumDepth));
  }
  get bounds() {
    return this._root.bounds;
  }
  get halfSize() {
    return this._root.halfSize;
  }
  get root() {
    return this._root.node;
  }
  get maximumObjectsPerNode() {
    return this._maximumObjectsPerNode;
  }
  get maximumDepth() {
    return this._maximumDepth;
  }
  get objectCount() {
    return this._objectCount;
  }
  destroy() {
    this._degenerateObjects.clear(), O.clearPool(), B[0] = null, w.prune(), W.prune();
  }
  add(e2, t = e2.length) {
    this._objectCount += t, this._grow(e2, t);
    const n3 = O.acquire();
    for (let o = 0; o < t; o++) {
      const t2 = e2[o];
      this._isDegenerate(t2) ? this._degenerateObjects.add(t2) : (n3.init(this._root), this._add(t2, n3));
    }
    O.release(n3);
  }
  remove(t, n3 = null) {
    this._objectCount -= t.length;
    const o = O.acquire();
    for (const s of t) {
      const t2 = r(n3) ? n3 : q2(this._objectToBoundingSphere(s), C);
      z(t2[3]) ? (o.init(this._root), this._remove(s, t2, o)) : this._degenerateObjects.delete(s);
    }
    O.release(o), this._shrink();
  }
  update(e2, t) {
    if (!z(t[3]) && this._isDegenerate(e2))
      return;
    const n3 = R(e2);
    this.remove(n3, t), this.add(n3);
  }
  forEachAlongRay(e2, t, n3) {
    const o = j(e2, t);
    this._forEachNode(this._root, (e3) => {
      if (!this._intersectsNode(o, e3))
        return false;
      const t2 = e3.node;
      return t2.terminals.forAll((e4) => {
        this._intersectsObject(o, e4) && n3(e4);
      }), null !== t2.residents && t2.residents.forAll((e4) => {
        this._intersectsObject(o, e4) && n3(e4);
      }), true;
    });
  }
  forEachAlongRayWithVerticalOffset(e2, t, n3, o) {
    const s = j(e2, t);
    this._forEachNode(this._root, (e3) => {
      if (!this._intersectsNodeWithOffset(s, e3, o))
        return false;
      const t2 = e3.node;
      return t2.terminals.forAll((e4) => {
        this._intersectsObjectWithOffset(s, e4, o) && n3(e4);
      }), null !== t2.residents && t2.residents.forAll((e4) => {
        this._intersectsObjectWithOffset(s, e4, o) && n3(e4);
      }), true;
    });
  }
  forEach(e2) {
    this._forEachNode(this._root, (t) => {
      const n3 = t.node;
      return n3.terminals.forAll(e2), null !== n3.residents && n3.residents.forAll(e2), true;
    }), this._degenerateObjects.forEach(e2);
  }
  forEachDegenerateObject(e2) {
    this._degenerateObjects.forEach(e2);
  }
  findClosest(e2, t, n3, r4 = () => true, i = 1 / 0) {
    let h = 1 / 0, a = 1 / 0, d = null;
    const c2 = E2(e2, t), u2 = (o) => {
      if (--i, !r4(o))
        return;
      const s = this._objectToBoundingSphere(o);
      if (!P(n3, s))
        return;
      const c3 = M(e2, t, E(s)), u3 = c3 - s[3], f = c3 + s[3];
      u3 < h && (h = u3, a = f, d = o);
    };
    return this._forEachNodeDepthOrdered(this._root, (r5) => {
      if (i <= 0 || !P(n3, r5.bounds))
        return false;
      q(F, c2, r5.halfSize), u(F, F, r5.bounds);
      if (M(e2, t, F) > a)
        return false;
      const h2 = r5.node;
      return h2.terminals.forAll((e3) => u2(e3)), null !== h2.residents && h2.residents.forAll((e3) => u2(e3)), true;
    }, e2, t), d;
  }
  forEachInDepthRange(e2, t, n3, r4, i, h, a) {
    let d = -1 / 0, c2 = 1 / 0;
    const u2 = { setRange: (e3) => {
      n3 === g.DepthOrder.FRONT_TO_BACK ? (d = Math.max(d, e3.near), c2 = Math.min(c2, e3.far)) : (d = Math.max(d, -e3.far), c2 = Math.min(c2, -e3.near));
    } };
    u2.setRange(r4);
    const f = M(t, n3, e2), m = E2(t, n3), p2 = E2(t, -n3), b = (e3) => {
      if (!a(e3))
        return;
      const o = this._objectToBoundingSphere(e3), s = E(o), r5 = M(t, n3, s) - f, m2 = r5 - o[3], p3 = r5 + o[3];
      m2 > c2 || p3 < d || !P(h, o) || i(e3, u2);
    };
    this._forEachNodeDepthOrdered(this._root, (e3) => {
      if (!P(h, e3.bounds))
        return false;
      q(F, m, e3.halfSize), u(F, F, e3.bounds);
      if (M(t, n3, F) - f > c2)
        return false;
      q(F, p2, e3.halfSize), u(F, F, e3.bounds);
      if (M(t, n3, F) - f < d)
        return false;
      const r5 = e3.node;
      return r5.terminals.forAll((e4) => b(e4)), null !== r5.residents && r5.residents.forAll((e4) => b(e4)), true;
    }, t, n3);
  }
  forEachNode(e2) {
    this._forEachNode(this._root, (t) => e2(t.node, t.bounds, t.halfSize));
  }
  forEachNeighbor(e2, t) {
    const n3 = k(t), o = E(t), s = (t2) => {
      const s2 = this._objectToBoundingSphere(t2), i = k(s2), h = n3 + i;
      p(E(s2), o) - h * h <= 0 && e2(t2);
    };
    this._forEachNode(this._root, (e3) => {
      const t2 = k(e3.bounds), i = n3 + t2;
      if (p(E(e3.bounds), o) - i * i > 0)
        return false;
      const h = e3.node;
      return h.terminals.forAll((e4) => s(e4)), null !== h.residents && h.residents.forAll((e4) => s(e4)), true;
    }), this.forEachDegenerateObject(s);
  }
  _intersectsNode(e2, t) {
    return x(t.bounds, 2 * -t.halfSize, k2), x(t.bounds, 2 * t.halfSize, q3), c(e2.origin, e2.direction, k2, q3);
  }
  _intersectsNodeWithOffset(e2, t, n3) {
    return x(t.bounds, 2 * -t.halfSize, k2), x(t.bounds, 2 * t.halfSize, q3), n3.applyToMinMax(k2, q3), c(e2.origin, e2.direction, k2, q3);
  }
  _intersectsObject(e2, t) {
    const n3 = this._objectToBoundingSphere(t);
    return !(n3[3] > 0) || X(n3, e2);
  }
  _intersectsObjectWithOffset(e2, t, n3) {
    const o = this._objectToBoundingSphere(t);
    return !(o[3] > 0) || X(n3.applyToBoundingSphere(o), e2);
  }
  _forEachNode(e2, t) {
    let n3 = O.acquire().init(e2);
    const o = [n3];
    for (; 0 !== o.length; ) {
      if (n3 = o.pop(), t(n3) && !n3.isLeaf())
        for (let e3 = 0; e3 < n3.node.children.length; e3++) {
          n3.node.children[e3] && o.push(O.acquire().init(n3).advance(e3));
        }
      O.release(n3);
    }
  }
  _forEachNodeDepthOrdered(e2, t, n3, o = g.DepthOrder.FRONT_TO_BACK) {
    let s = O.acquire().init(e2);
    const r4 = [s];
    for (T(n3, o, V); 0 !== r4.length; ) {
      if (s = r4.pop(), t(s) && !s.isLeaf())
        for (let e3 = 7; e3 >= 0; --e3) {
          const t2 = V[e3];
          s.node.children[t2] && r4.push(O.acquire().init(s).advance(t2));
        }
      O.release(s);
    }
  }
  _remove(e2, t, n3) {
    w.clear();
    const o = n3.advanceTo(t, (e3, t2) => {
      w.push(e3.node), w.push(t2);
    }) ? n3.node.terminals : n3.node.residents;
    if (o.removeUnordered(e2), 0 === o.length)
      for (let s = w.length - 2; s >= 0; s -= 2) {
        const e3 = w.data[s], t2 = w.data[s + 1];
        if (!this._purge(e3, t2))
          break;
      }
  }
  _nodeIsEmpty(e2) {
    if (0 !== e2.terminals.length)
      return false;
    if (null !== e2.residents)
      return 0 === e2.residents.length;
    for (let t = 0; t < e2.children.length; t++)
      if (e2.children[t])
        return false;
    return true;
  }
  _purge(e2, t) {
    return t >= 0 && (e2.children[t] = null), !!this._nodeIsEmpty(e2) && (null === e2.residents && (e2.residents = new n({ shrink: true })), true);
  }
  _add(e2, t) {
    t.advanceTo(this._objectToBoundingSphere(e2)) ? t.node.terminals.push(e2) : (t.node.residents.push(e2), t.node.residents.length > this._maximumObjectsPerNode && t.depth < this._maximumDepth && this._split(t));
  }
  _split(e2) {
    const t = e2.node.residents;
    e2.node.residents = null;
    for (let n3 = 0; n3 < t.length; n3++) {
      const o = O.acquire().init(e2);
      this._add(t.getItemAt(n3), o), O.release(o);
    }
  }
  _grow(e2, t) {
    if (0 !== t && (N(e2, t, (e3) => this._objectToBoundingSphere(e3), I), z(I[3]) && !this._fitsInsideTree(I)))
      if (this._nodeIsEmpty(this._root.node))
        q2(I, this._root.bounds), this._root.halfSize = 1.25 * I[3];
      else {
        const e3 = this._rootBoundsForRootAsSubNode(I);
        this._placingRootViolatesMaxDepth(e3) ? this._rebuildTree(I, e3) : this._growRootAsSubNode(e3), O.release(e3);
      }
  }
  _rebuildTree(e2, t) {
    r3(P2, t.bounds), P2[3] = t.halfSize, N([e2, P2], 2, (e3) => e3, L);
    const n3 = O.acquire().init(this._root);
    this._root.initFrom(null, L, 1.25 * L[3]), this._forEachNode(n3, (e3) => (this.add(e3.node.terminals.data, e3.node.terminals.length), null !== e3.node.residents && this.add(e3.node.residents.data, e3.node.residents.length), true)), O.release(n3);
  }
  _placingRootViolatesMaxDepth(e2) {
    const t = Math.log(e2.halfSize / this._root.halfSize) * Math.LOG2E;
    let n3 = 0;
    return this._forEachNode(this._root, (e3) => (n3 = Math.max(n3, e3.depth), n3 + t <= this._maximumDepth)), n3 + t > this._maximumDepth;
  }
  _rootBoundsForRootAsSubNode(e2) {
    const t = e2[3], n3 = e2;
    let o = -1 / 0;
    const s = this._root.bounds, r4 = this._root.halfSize;
    for (let i = 0; i < 3; i++) {
      const e3 = s[i] - r4 - (n3[i] - t), h = n3[i] + t - (s[i] + r4), a = Math.max(0, Math.ceil(e3 / (2 * r4))), d = Math.max(0, Math.ceil(h / (2 * r4))) + 1, l = 2 ** Math.ceil(Math.log(a + d) * Math.LOG2E);
      o = Math.max(o, l), K[i].min = a, K[i].max = d;
    }
    for (let i = 0; i < 3; i++) {
      let e3 = K[i].min, t2 = K[i].max;
      const n4 = (o - (e3 + t2)) / 2;
      e3 += Math.ceil(n4), t2 += Math.floor(n4);
      const h = s[i] - r4 - e3 * r4 * 2;
      y[i] = h + (t2 + e3) * r4;
    }
    return y[3] = o * r4 * v, O.acquire().initFrom(null, y, o * r4, 0);
  }
  _growRootAsSubNode(e2) {
    const t = this._root.node;
    r3(I, this._root.bounds), I[3] = this._root.halfSize, this._root.init(e2), e2.advanceTo(I, null, true), e2.node.children = t.children, e2.node.residents = t.residents, e2.node.terminals = t.terminals;
  }
  _shrink() {
    for (; ; ) {
      const e2 = this._findShrinkIndex();
      if (-1 === e2)
        break;
      this._root.advance(e2), this._root.depth = 0;
    }
  }
  _findShrinkIndex() {
    if (0 !== this._root.node.terminals.length || this._root.isLeaf())
      return -1;
    let e2 = null;
    const t = this._root.node.children;
    let n3 = 0, o = 0;
    for (; o < t.length && null == e2; )
      n3 = o++, e2 = t[n3];
    for (; o < t.length; )
      if (t[o++])
        return -1;
    return n3;
  }
  _isDegenerate(e2) {
    return !z(this._objectToBoundingSphere(e2)[3]);
  }
  _fitsInsideTree(e2) {
    const t = this._root.bounds, n3 = this._root.halfSize;
    return e2[3] <= n3 && e2[0] >= t[0] - n3 && e2[0] <= t[0] + n3 && e2[1] >= t[1] - n3 && e2[1] <= t[1] + n3 && e2[2] >= t[2] - n3 && e2[2] <= t[2] + n3;
  }
};
var O = class {
  constructor() {
    this.bounds = _(), this.halfSize = 0, this.initFrom(null, null, 0, 0);
  }
  init(e2) {
    return this.initFrom(e2.node, e2.bounds, e2.halfSize, e2.depth);
  }
  initFrom(t, n3, o, s = this.depth) {
    return this.node = r(t) ? t : O.createEmptyNode(), r(n3) && q2(n3, this.bounds), this.halfSize = o, this.depth = s, this;
  }
  advance(e2) {
    let t = this.node.children[e2];
    t || (t = O.createEmptyNode(), this.node.children[e2] = t), this.node = t, this.halfSize /= 2, this.depth++;
    const n3 = A2[e2];
    return this.bounds[0] += n3[0] * this.halfSize, this.bounds[1] += n3[1] * this.halfSize, this.bounds[2] += n3[2] * this.halfSize, this.bounds[3] = this.halfSize * v, this;
  }
  advanceTo(e2, t, n3 = false) {
    for (; ; ) {
      if (this.isTerminalFor(e2))
        return t && t(this, -1), true;
      if (this.isLeaf()) {
        if (!n3)
          return t && t(this, -1), false;
        this.node.residents = null;
      }
      const o = this._childIndex(e2);
      t && t(this, o), this.advance(o);
    }
  }
  isLeaf() {
    return null != this.node.residents;
  }
  isTerminalFor(e2) {
    return e2[3] > this.halfSize / 2;
  }
  _childIndex(e2) {
    const t = this.bounds;
    return (t[0] < e2[0] ? 1 : 0) + (t[1] < e2[1] ? 2 : 0) + (t[2] < e2[2] ? 4 : 0);
  }
  static createEmptyNode() {
    return { children: [null, null, null, null, null, null, null, null], terminals: new n({ shrink: true }), residents: new n({ shrink: true }) };
  }
  static acquire() {
    return O._pool.acquire();
  }
  static release(e2) {
    O._pool.release(e2);
  }
  static clearPool() {
    O._pool.prune();
  }
};
function j2(e2, t) {
  e2[0] = Math.min(e2[0], t[0] - t[3]), e2[1] = Math.min(e2[1], t[1] - t[3]), e2[2] = Math.min(e2[2], t[2] - t[3]);
}
function S(e2, t) {
  e2[0] = Math.max(e2[0], t[0] + t[3]), e2[1] = Math.max(e2[1], t[1] + t[3]), e2[2] = Math.max(e2[2], t[2] + t[3]);
}
function x(e2, t, n3) {
  n3[0] = e2[0] + t, n3[1] = e2[1] + t, n3[2] = e2[2] + t;
}
function N(e2, t, n3, o) {
  if (1 === t) {
    const t2 = n3(e2[0]);
    q2(t2, o);
  } else {
    k2[0] = 1 / 0, k2[1] = 1 / 0, k2[2] = 1 / 0, q3[0] = -1 / 0, q3[1] = -1 / 0, q3[2] = -1 / 0;
    for (let o2 = 0; o2 < t; o2++) {
      const t2 = n3(e2[o2]);
      z(t2[3]) && (j2(k2, t2), S(q3, t2));
    }
    A(o, k2, q3, 0.5), o[3] = Math.max(q3[0] - k2[0], q3[1] - k2[1], q3[2] - k2[2]) / 2;
  }
}
function T(e2, t, n3) {
  if (!W.length)
    for (let o = 0; o < 8; ++o)
      W.push({ index: 0, distance: 0 });
  for (let o = 0; o < 8; ++o) {
    const n4 = A2[o];
    W.data[o].index = o, W.data[o].distance = M(e2, t, n4);
  }
  W.sort((e3, t2) => e3.distance - t2.distance);
  for (let o = 0; o < 8; ++o)
    n3[o] = W.data[o].index;
}
function E2(e2, t) {
  let n3 = 1 / 0, o = null;
  for (let s = 0; s < 8; ++s) {
    const r4 = M(e2, t, D[s]);
    r4 < n3 && (n3 = r4, o = D[s]);
  }
  return o;
}
function M(e2, t, n3) {
  return t * (e2[0] * n3[0] + e2[1] * n3[1] + e2[2] * n3[2]);
}
function z(e2) {
  return !isNaN(e2) && e2 !== -1 / 0 && e2 !== 1 / 0 && e2 > 0;
}
O._pool = new e(O), function(e2) {
  var t;
  (t = e2.DepthOrder || (e2.DepthOrder = {}))[t.FRONT_TO_BACK = 1] = "FRONT_TO_BACK", t[t.BACK_TO_FRONT = -1] = "BACK_TO_FRONT";
}(g || (g = {}));
var A2 = [r2(-1, -1, -1), r2(1, -1, -1), r2(-1, 1, -1), r2(1, 1, -1), r2(-1, -1, 1), r2(1, -1, 1), r2(-1, 1, 1), r2(1, 1, 1)];
var D = [r2(-1, -1, -1), r2(-1, -1, 1), r2(-1, 1, -1), r2(-1, 1, 1), r2(1, -1, -1), r2(1, -1, 1), r2(1, 1, -1), r2(1, 1, 1)];
var v = Math.sqrt(3);
var B = [null];
function R(e2) {
  return B[0] = e2, B;
}
var y = _();
var F = n2();
var k2 = n2();
var q3 = n2();
var w = new n();
var C = _();
var I = _();
var P2 = _();
var L = _();
var K = [{ min: 0, max: 0 }, { min: 0, max: 0 }, { min: 0, max: 0 }];
var W = new n();
var V = [0, 0, 0, 0, 0, 0, 0, 0];
var G = g;

export {
  G
};
//# sourceMappingURL=chunk-XEWFCJLT.js.map
