import {
  f
} from "./chunk-DYRM6FXE.js";
import {
  w as w2
} from "./chunk-7Y6VVOP3.js";
import {
  l,
  m as m2,
  s as s2,
  u as u3
} from "./chunk-3DTDACBY.js";
import {
  A,
  K
} from "./chunk-G4NYIT2C.js";
import "./chunk-ZG7SHSSS.js";
import "./chunk-CNBLQ5VM.js";
import "./chunk-WRJQ7542.js";
import "./chunk-QFYBIFWB.js";
import "./chunk-PNUWGOXY.js";
import "./chunk-PZWU5EHT.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-YG6VFATO.js";
import {
  i as i2
} from "./chunk-Y6YGVGFR.js";
import {
  p
} from "./chunk-GKRQ3NBT.js";
import "./chunk-6GPADSSO.js";
import {
  v
} from "./chunk-OG6CQEZJ.js";
import {
  c
} from "./chunk-X5Z3DJQ4.js";
import {
  O
} from "./chunk-BUWXVMJU.js";
import {
  d as d2
} from "./chunk-JT3LXQ47.js";
import "./chunk-P3QN5DXX.js";
import "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import {
  t as t2
} from "./chunk-OWBMOIIV.js";
import {
  b
} from "./chunk-SIH2IMSA.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  a
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import {
  i
} from "./chunk-OO2JXX7L.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-Y7FSCP47.js";
import {
  U as U2
} from "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  j as j2
} from "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import {
  u2 as u
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  w
} from "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  m,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/support/SceneModifications.js
var a2;
var n2 = a2 = class extends u(j.ofType(f)) {
  constructor(r2) {
    super(r2), this.url = null;
  }
  clone() {
    return new a2({ url: this.url, items: this.items.map((r2) => r2.clone()) });
  }
  toJSON(r2) {
    return this.toArray().map((o2) => o2.toJSON(r2)).filter((r3) => !!r3.geometry);
  }
  static fromJSON(r2, o2) {
    const t3 = new a2();
    for (const e2 of r2)
      t3.add(f.fromJSON(e2, o2));
    return t3;
  }
  static async fromUrl(r2, t3, e2) {
    const c2 = { url: j2(r2), origin: "service" }, p2 = await U2(r2, { responseType: "json", signal: m(e2, "signal") }), n3 = t3.toJSON(), l3 = [];
    for (const o2 of p2.data)
      l3.push(f.fromJSON({ ...o2, geometry: { ...o2.geometry, spatialReference: n3 } }, c2));
    return new a2({ url: r2, items: l3 });
  }
};
e([d({ type: String })], n2.prototype, "url", void 0), n2 = a2 = e([n("esri.layers.support.SceneModifications")], n2);
var l2 = n2;

// node_modules/@arcgis/core/layers/IntegratedMeshLayer.js
var b2 = class extends A(p(c(v(t2(O(i2(b))))))) {
  constructor(...e2) {
    super(...e2), this._handles = new u2(), this.geometryType = "mesh", this.operationalLayerType = "IntegratedMeshLayer", this.type = "integrated-mesh", this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.profile = "mesh-pyramids", this.modifications = null, this._modificationsSource = null, this.elevationInfo = null, this.path = null;
  }
  destroy() {
    this._handles.destroy();
  }
  initialize() {
    this._handles.add(a(() => this.modifications, "after-changes", () => this.modifications = this.modifications, U));
  }
  normalizeCtorArgs(e2, t3) {
    return "string" == typeof e2 ? { url: e2, ...t3 } : e2;
  }
  readModifications(e2, t3, r2) {
    this._modificationsSource = { url: i(e2, r2), context: r2 };
  }
  async load(e2) {
    return this.addResolvingPromise(this._doLoad(e2)), this;
  }
  async _doLoad(e2) {
    const t3 = m(e2, "signal");
    try {
      await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e2);
    } catch (r2) {
      w(r2);
    }
    if (await this._fetchService(t3), r(this._modificationsSource)) {
      const t4 = await l2.fromUrl(this._modificationsSource.url, this.spatialReference, e2);
      this.setAtOrigin("modifications", t4, this._modificationsSource.context.origin), this._modificationsSource = null;
    }
    await this._fetchIndexAndUpdateExtent(this.nodePages, t3);
  }
  beforeSave() {
    if (!t(this._modificationsSource))
      return this.load().then(() => {
      }, () => {
      });
  }
  async saveAs(e2, t3) {
    return this._debouncedSaveOperations(K.SAVE_AS, { ...t3, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" }, e2);
  }
  async save() {
    const e2 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" };
    return this._debouncedSaveOperations(K.SAVE, e2);
  }
  validateLayer(e2) {
    if (e2.layerType && "IntegratedMesh" !== e2.layerType)
      throw new s("integrated-mesh-layer:layer-type-not-supported", "IntegratedMeshLayer does not support this layer type", { layerType: e2.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor))
      throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
    if (this.version.major > 1)
      throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
  }
  _getTypeKeywords() {
    return ["IntegratedMeshLayer"];
  }
};
e([d({ type: String, readOnly: true })], b2.prototype, "geometryType", void 0), e([d({ type: ["show", "hide"] })], b2.prototype, "listMode", void 0), e([d({ type: ["IntegratedMeshLayer"] })], b2.prototype, "operationalLayerType", void 0), e([d({ json: { read: false }, readOnly: true })], b2.prototype, "type", void 0), e([d({ type: s2, readOnly: true })], b2.prototype, "nodePages", void 0), e([d({ type: [l], readOnly: true })], b2.prototype, "materialDefinitions", void 0), e([d({ type: [u3], readOnly: true })], b2.prototype, "textureSetDefinitions", void 0), e([d({ type: [m2], readOnly: true })], b2.prototype, "geometryDefinitions", void 0), e([d({ readOnly: true })], b2.prototype, "serviceUpdateTimeStamp", void 0), e([d({ type: l2 }), w2({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "modifications" })], b2.prototype, "modifications", void 0), e([o(["web-scene", "portal-item"], "modifications")], b2.prototype, "readModifications", null), e([d(d2)], b2.prototype, "elevationInfo", void 0), e([d({ type: String, json: { origins: { "web-scene": { read: true, write: true }, "portal-item": { read: true, write: true } }, read: false } })], b2.prototype, "path", void 0), b2 = e([n("esri.layers.IntegratedMeshLayer")], b2);
var A2 = b2;
export {
  A2 as default
};
//# sourceMappingURL=IntegratedMeshLayer-LI7MXSGS.js.map
