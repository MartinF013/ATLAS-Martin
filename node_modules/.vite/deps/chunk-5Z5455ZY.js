import {
  a
} from "./chunk-D7DLEBS2.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  o,
  t as t2
} from "./chunk-G5JBUC5N.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/support/domainUtils.js
var e;
function a2(n, a3) {
  switch (n.type) {
    case "range": {
      const r3 = "range" in n ? n.range[0] : n.minValue, u2 = "range" in n ? n.range[1] : n.maxValue;
      if (+a3 < r3 || +a3 > u2)
        return e.VALUE_OUT_OF_RANGE;
      break;
    }
    case "coded-value":
    case "codedValue":
      if (null == n.codedValues || n.codedValues.every((e2) => null == e2 || e2.code !== a3))
        return e.INVALID_CODED_VALUE;
  }
  return null;
}
!function(e2) {
  e2.VALUE_OUT_OF_RANGE = "domain-validation-error::value-out-of-range", e2.INVALID_CODED_VALUE = "domain-validation-error::invalid-coded-value";
}(e || (e = {}));

// node_modules/@arcgis/core/layers/support/fieldUtils.js
var u = ["field", "field2", "field3", "normalizationField", "rotationInfo.field", "proportionalSymbolInfo.field", "proportionalSymbolInfo.normalizationField", "colorInfo.field", "colorInfo.normalizationField"];
var f = ["field", "normalizationField"];
function c(e2, n) {
  if (null != e2 && null != n) {
    for (const i of Array.isArray(e2) ? e2 : [e2])
      if (d(u, i, n), "visualVariables" in i && i.visualVariables)
        for (const e3 of i.visualVariables)
          d(f, e3, n);
  }
}
function d(e2, n, i) {
  if (e2)
    for (const o2 of e2) {
      const e3 = t2(o2, n), l = e3 && "function" != typeof e3 && i.get(e3);
      l && o(o2, l.name, n);
    }
}
function m(e2, n) {
  if (null != e2 && (n == null ? void 0 : n.fields.length))
    if ("startField" in e2) {
      const i = n.get(e2.startField), t3 = n.get(e2.endField);
      e2.startField = i && i.name || null, e2.endField = t3 && t3.name || null;
    } else {
      const i = n.get(e2.startTimeField), t3 = n.get(e2.endTimeField);
      e2.startTimeField = i && i.name || null, e2.endTimeField = t3 && t3.name || null;
    }
}
var p = /* @__PURE__ */ new Set();
function y(e2, n) {
  return e2 && n ? (p.clear(), g(p, e2, n), Array.from(p).sort()) : [];
}
function g(e2, n, i) {
  var _a;
  if (i)
    if ((_a = n == null ? void 0 : n.fields) == null ? void 0 : _a.length)
      if (i.includes("*"))
        for (const { name: t3 } of n.fields)
          e2.add(t3);
      else
        for (const t3 of i)
          F(e2, n, t3);
    else {
      if (i.includes("*"))
        return e2.clear(), void e2.add("*");
      for (const n2 of i)
        e2.add(n2);
    }
}
function F(e2, n, i) {
  if ("string" == typeof i)
    if (n) {
      const t3 = n.get(i);
      t3 && e2.add(t3.name);
    } else
      e2.add(i);
}
function I(e2, i) {
  return t(i) || t(e2) ? [] : i.includes("*") ? e2.fields.map((e3) => e3.name) : i;
}
async function b(e2, n, i) {
  var _a;
  if (!i)
    return;
  const { arcadeUtils: t3 } = await a(), r3 = t3.extractFieldNames(i, (_a = n == null ? void 0 : n.fields) == null ? void 0 : _a.map((e3) => e3.name));
  for (const o2 of r3)
    F(e2, n, o2);
}
async function T(n, i, t3) {
  if (t3 && "1=1" !== t3) {
    const r3 = (await import("./WhereClause-XG56H2W3.js")).WhereClause.create(t3, i);
    if (!r3.isStandardized)
      throw new s("fieldUtils:collectFilterFields", "Where clause is not standardized", { where: t3 });
    g(n, i, r3.fieldNames);
  }
}
function h({ displayField: e2, fields: n }) {
  return e2 || (n && n.length ? S(n, "name-or-title") || S(n, "unique-identifier") || S(n, "type-or-category") || w(n) : null);
}
function w(e2) {
  for (const n of e2) {
    if (!n || !n.name)
      continue;
    const e3 = n.name.toLowerCase();
    if (e3.includes("name") || e3.includes("title"))
      return n.name;
  }
  return null;
}
function S(e2, n) {
  for (const i of e2)
    if (i && i.valueType && i.valueType === n)
      return i.name;
  return null;
}
async function A(e2, n) {
  if (!n)
    return;
  const i = t2("elevationInfo.featureExpressionInfo", n);
  return i ? i.collectRequiredFields(e2, n.fieldsIndex) : void 0;
}
async function E(e2, n, i) {
  i.outStatistic.onStatisticValueExpression ? b(e2, n, i.outStatistic.onStatisticValueExpression) : e2.add(i.outStatistic.onStatisticField);
}
async function N(e2, n, i) {
  var _a, _b;
  if (!n || !i || !("fields" in i))
    return;
  const t3 = [];
  if (((_a = i.popupTemplate) == null ? void 0 : _a.expressionInfos) && t3.push(...i.popupTemplate.expressionInfos.map((i2) => b(e2, n.fieldsIndex, i2.expression))), Array.isArray((_b = i.popupTemplate) == null ? void 0 : _b.content)) {
    const r3 = i.popupTemplate.content;
    for (const i2 of r3)
      "expression" === i2.type && i2.expressionInfo && t3.push(b(e2, n.fieldsIndex, i2.expressionInfo.expression));
  }
  i.fields && t3.push(...i.fields.map((i2) => E(e2, n.fieldsIndex, i2))), await Promise.all(t3);
}
async function V(e2, n, t3) {
  n && (n.timeInfo && r(t3) && t3.timeExtent && g(e2, n.fieldsIndex, [n.timeInfo.startField, n.timeInfo.endField]), n.floorInfo && g(e2, n.fieldsIndex, [n.floorInfo.floorField]), r(t3) && r(t3.where) && await T(e2, n.fieldsIndex, t3.where));
}
async function _(e2, n, i) {
  n && i && await Promise.all(i.map((i2) => D(e2, n, i2)));
}
async function D(e2, n, i) {
  n && i && (i.valueExpression ? await b(e2, n.fieldsIndex, i.valueExpression) : i.field && F(e2, n.fieldsIndex, i.field));
}
function L(e2) {
  if (!e2)
    return [];
  const n = "editFieldsInfo" in e2 && e2.editFieldsInfo;
  return n ? y(e2.fieldsIndex, [n && n.creatorField, n && n.creationDateField, n && n.editorField, n && n.editDateField]) : [];
}
async function j(e2, n) {
  const { labelingInfo: i, fieldsIndex: t3 } = n;
  i && i.length && await Promise.all(i.map((n2) => z(e2, t3, n2)));
}
async function z(e2, n, i) {
  if (!i)
    return;
  const t3 = i.getLabelExpression(), r3 = i.where;
  if ("arcade" === t3.type)
    await b(e2, n, t3.expression);
  else {
    const i2 = t3.expression.match(/{[^}]*}/g);
    i2 && i2.forEach((i3) => {
      F(e2, n, i3.slice(1, -1));
    });
  }
  await T(e2, n, r3);
}
function P(e2) {
  const n = e2.defaultValue;
  return void 0 !== n && Y(e2, n) ? n : e2.nullable ? null : void 0;
}
function k(e2) {
  return "number" == typeof e2 && !isNaN(e2) && isFinite(e2);
}
function C(e2) {
  return null === e2 || k(e2);
}
var R = "isInteger" in Number ? Number.isInteger : (e2) => "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
function G(e2) {
  return null === e2 || R(e2);
}
function W(e2) {
  return null != e2 && "string" == typeof e2;
}
function q(e2) {
  return null === e2 || W(e2);
}
function M() {
  return true;
}
function Y(e2, n) {
  let i;
  switch (e2.type) {
    case "date":
    case "integer":
    case "long":
    case "small-integer":
    case "esriFieldTypeDate":
    case "esriFieldTypeInteger":
    case "esriFieldTypeLong":
    case "esriFieldTypeSmallInteger":
      i = e2.nullable ? G : R;
      break;
    case "double":
    case "single":
    case "esriFieldTypeSingle":
    case "esriFieldTypeDouble":
      i = e2.nullable ? C : k;
      break;
    case "string":
    case "esriFieldTypeString":
      i = e2.nullable ? q : W;
      break;
    default:
      i = M;
  }
  return 1 === arguments.length ? i : i(n);
}
var J = ["integer", "small-integer", "single", "double"];
var X = /* @__PURE__ */ new Set([...J, "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeSingle", "esriFieldTypeDouble"]);
function B(e2) {
  return null != e2 && X.has(e2.type);
}
function H(e2) {
  return null != e2 && ("string" === e2.type || "esriFieldTypeString" === e2.type);
}
function K(e2) {
  return null != e2 && ("date" === e2.type || "esriFieldTypeDate" === e2.type);
}
var Z;
var ee;
function ne(e2) {
  return null == e2 || "number" == typeof e2 && isNaN(e2) ? null : e2;
}
function ie(e2, n) {
  return e2.nullable && null === n ? null : B(e2) && !te(e2.type, Number(n)) ? Z.OUT_OF_RANGE : Y(e2, n) ? e2.domain ? a2(e2.domain, n) : null : ee.INVALID_TYPE;
}
function te(e2, n) {
  const i = "string" == typeof e2 ? oe(e2) : e2;
  return !!i && (i.isInteger ? R(n) && n >= i.min && n <= i.max : n >= i.min && n <= i.max);
}
function oe(e2) {
  switch (e2) {
    case "esriFieldTypeSmallInteger":
    case "small-integer":
      return se;
    case "esriFieldTypeInteger":
    case "integer":
      return ae;
    case "esriFieldTypeSingle":
    case "single":
      return ue;
    case "esriFieldTypeDouble":
    case "double":
      return fe;
  }
}
!function(e2) {
  e2.OUT_OF_RANGE = "numeric-range-validation-error::out-of-range";
}(Z || (Z = {})), function(e2) {
  e2.INVALID_TYPE = "type-validation-error::invalid-type";
}(ee || (ee = {}));
var se = { min: -32768, max: 32767, isInteger: true };
var ae = { min: -2147483648, max: 2147483647, isInteger: true };
var ue = { min: -34e37, max: 12e37, isInteger: false };
var fe = { min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInteger: false };
function ce(e2, n, i) {
  switch (e2) {
    case e.INVALID_CODED_VALUE:
      return `Value ${i} is not in the coded domain - field: ${n.name}, domain: ${JSON.stringify(n.domain)}`;
    case e.VALUE_OUT_OF_RANGE:
      return `Value ${i} is out of the range of valid values - field: ${n.name}, domain: ${JSON.stringify(n.domain)}`;
    case ee.INVALID_TYPE:
      return `Value ${i} is not a valid value for the field type - field: ${n.name}, type: ${n.type}, nullable: ${n.nullable}`;
    case Z.OUT_OF_RANGE: {
      const { min: e3, max: t3 } = oe(n.type);
      return `Value ${i} is out of range for the number type - field: ${n.name}, type: ${n.type}, value range is ${e3} to ${t3}`;
    }
  }
}
function de(e2, n) {
  return !me(e2, n, null);
}
function me(e2, n, t3) {
  if (!n || !n.attributes || !e2) {
    if (r(t3))
      for (const n2 of e2)
        t3.add(n2);
    return true;
  }
  const r3 = n.attributes;
  let o2 = false;
  for (const l of e2)
    if (!(l in r3)) {
      if (o2 = true, !r(t3))
        break;
      t3.add(l);
    }
  return o2;
}
function ye(e2) {
  return ["raster.itempixelvalue", "raster.servicepixelvalue"].some((n) => e2.toLowerCase().startsWith(n));
}

export {
  c,
  m,
  y,
  g,
  F,
  I,
  b,
  h,
  A,
  N,
  V,
  _,
  L,
  j,
  P,
  B,
  H,
  K,
  ne,
  ie,
  ce,
  de,
  me,
  ye
};
//# sourceMappingURL=chunk-5Z5455ZY.js.map
