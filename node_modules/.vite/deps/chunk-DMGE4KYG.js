import {
  s as s2
} from "./chunk-7S6G3GM7.js";
import {
  F,
  T
} from "./chunk-B5VZTE6L.js";
import {
  g
} from "./chunk-JT3LXQ47.js";
import {
  g as g2
} from "./chunk-BLINZ65M.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  e as e2,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/layers/ImageryTileLayerView.js
var m = (m2) => {
  let f = class extends m2 {
    constructor() {
      super(...arguments), this._rasterFieldPrefix = "Raster.", this.layer = null, this.view = null, this.tileInfo = null;
    }
    get fullExtent() {
      return this._getfullExtent();
    }
    _getfullExtent() {
      return this.projectFullExtent(this.view.spatialReference);
    }
    get hasTilingEffects() {
      return this.layer.renderer && "dynamicRangeAdjustment" in this.layer.renderer && this.layer.renderer.dynamicRangeAdjustment;
    }
    get datumTransformation() {
      return T(e2(this.layer.fullExtent), this.view.spatialReference, true);
    }
    supportsSpatialReference(t2) {
      return !!this.projectFullExtent(t2);
    }
    projectFullExtent(t2) {
      const e3 = e2(this.layer.fullExtent), r = T(e3, t2, false);
      return F(e3, t2, r);
    }
    async fetchPopupFeatures(t2, i) {
      var _a, _b;
      const { layer: s3 } = this;
      if (!t2)
        throw new s("imageryTileLayerView:fetchPopupFeatures", "Nothing to fetch without area", { layer: s3 });
      const { popupEnabled: a } = s3, n2 = s2(s3, i);
      if (!a || t(n2))
        throw new s("imageryTileLayerView:fetchPopupFeatures", "Missing required popupTemplate or popupEnabled", { popupEnabled: a, popupTemplate: n2 });
      const l = [], { value: u, magdirValue: m3 } = await s3.identify(t2, { timeExtent: this.timeExtent });
      let f2 = "";
      if (u && u.length) {
        f2 = "imagery-tile" === s3.type && s3.hasStandardTime() && null != u[0] ? u.map((t4) => s3.getStandardTimeValue(t4)).join(", ") : u.join(", ");
        const t3 = { ObjectId: 0 }, r = "Raster.ServicePixelValue";
        t3[r] = this._formatAttributeValue(f2, r);
        const i2 = (_b = (_a = s3.rasterInfo) == null ? void 0 : _a.attributeTable) == null ? void 0 : _b.features;
        if (i2 && i2.length > 0) {
          const e3 = i2.filter((t4) => {
            const e4 = t4.attributes.value || t4.attributes.Value || t4.attributes.VALUE;
            return String(e4) === f2;
          });
          if (e3.length > 0) {
            const r2 = e3[0];
            if (r2) {
              for (const e4 in r2.attributes)
                if (r2.attributes.hasOwnProperty(e4)) {
                  const i3 = this._rasterFieldPrefix + e4;
                  t3[i3] = this._formatAttributeValue(r2.attributes[e4], i3);
                }
            }
          }
        }
        const o = s3.rasterInfo.dataType;
        "vector-magdir" !== o && "vector-uv" !== o || (t3["Raster.Magnitude"] = m3 == null ? void 0 : m3[0], t3["Raster.Direction"] = m3 == null ? void 0 : m3[1]);
        const a2 = new g2(this.fullExtent.clone(), null, t3);
        a2.layer = s3, a2.sourceLayer = a2.layer, l.push(a2);
      }
      return l;
    }
    _formatAttributeValue(t2, e3) {
      if ("string" == typeof t2) {
        const r = this.layer.popupTemplate && this.layer.popupTemplate.fieldInfos, i = this._getFieldInfo(r, e3), o = i && i.format;
        if (o) {
          let e4, r2;
          return t2.trim().includes(",") ? (e4 = ",", r2 = e4 + " ", this._formatDelimitedString(t2, e4, r2, o)) : t2.trim().includes(" ") ? (e4 = r2 = " ", this._formatDelimitedString(t2, e4, r2, o)) : this._formatNumberFromString(t2, o);
        }
      }
      return t2;
    }
    _getFieldInfo(t2, e3) {
      if (!t2 || !t2.length || !e3)
        return;
      const r = e3.toLowerCase();
      let i;
      return t2.some((t3) => !(!t3.fieldName || t3.fieldName.toLowerCase() !== r && t3.fieldName.toLowerCase() !== r.replace(/ /g, "_")) && (i = t3, true)), i;
    }
    _formatDelimitedString(t2, e3, r, i) {
      return t2 && e3 && r && i ? t2.trim().split(e3).map((t3) => this._formatNumberFromString(t3, i)).join(r) : t2;
    }
    _formatNumberFromString(t2, e3) {
      if (!t2 || !e3)
        return t2;
      const r = Number(t2);
      return isNaN(r) ? t2 : e3.format(r);
    }
  };
  return e([d()], f.prototype, "layer", void 0), e([d(g)], f.prototype, "timeExtent", void 0), e([d()], f.prototype, "view", void 0), e([d()], f.prototype, "fullExtent", null), e([d()], f.prototype, "tileInfo", void 0), e([d({ readOnly: true })], f.prototype, "hasTilingEffects", null), f = e([n("esri.views.layers.ImageryTileLayerView")], f), f;
};

export {
  m
};
//# sourceMappingURL=chunk-DMGE4KYG.js.map
