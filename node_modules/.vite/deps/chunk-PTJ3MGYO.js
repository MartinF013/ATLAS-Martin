import {
  u
} from "./chunk-56RHM4A6.js";
import {
  m
} from "./chunk-BPZGJQOB.js";
import {
  h2 as h,
  t
} from "./chunk-VLCG72SW.js";

// node_modules/@arcgis/core/views/draw/support/drawUtils.js
function r(t2, n, e, r2) {
  if (null == r2 || t2.hasZ || (r2 = void 0), "point" === t2.type)
    return t2.x += n, t2.y += e, t2.hasZ && null != r2 && (t2.z += r2), t2;
  if ("multipoint" === t2.type) {
    const o = t2.points;
    for (let t3 = 0; t3 < o.length; t3++)
      o[t3] = l(o[t3], n, e, r2);
    return t2;
  }
  if ("extent" === t2.type)
    return t2.xmin += n, t2.xmax += n, t2.ymin += e, t2.ymax += e, null != r2 && (t2.zmin += r2, t2.zmax += r2), t2;
  const s2 = t(t2), i2 = "polyline" === t2.type ? t2.paths : t2.rings;
  for (let o = 0; o < s2.length; o++) {
    const t3 = s2[o];
    for (let o2 = 0; o2 < t3.length; o2++)
      t3[o2] = l(t3[o2], n, e, r2);
  }
  return "paths" in t2 ? t2.paths = i2 : t2.rings = i2, t2;
}
function s(t2, n, e, s2, i2) {
  const a2 = t2.clone(), m3 = s2.resolution;
  if ("point" === a2.type) {
    if (i2)
      r(a2, n * m3, -e * m3);
    else {
      const t3 = s2.state.transform, o = s2.state.inverseTransform, r2 = t3[0] * a2.x + t3[2] * a2.y + t3[4], i3 = t3[1] * a2.x + t3[3] * a2.y + t3[5];
      a2.x = o[0] * (r2 + n) + o[2] * (i3 + e) + o[4], a2.y = o[1] * (r2 + n) + o[3] * (i3 + e) + o[5];
    }
    return a2;
  }
  if ("multipoint" === a2.type) {
    if (i2)
      r(a2, n * m3, -e * m3);
    else {
      const t3 = a2.points, o = s2.state.transform, r2 = s2.state.inverseTransform;
      for (let s3 = 0; s3 < t3.length; s3++) {
        const i3 = t3[s3], a3 = o[0] * i3[0] + o[2] * i3[1] + o[4], m4 = o[1] * i3[0] + o[3] * i3[1] + o[5], l2 = r2[0] * (a3 + n) + r2[2] * (m4 + e) + r2[4], p = r2[1] * (a3 + n) + r2[3] * (m4 + e) + r2[5];
        t3[s3] = x(i3, l2, p, void 0);
      }
    }
    return a2;
  }
  if ("extent" === a2.type) {
    if (i2)
      r(a2, n * m3, -e * m3);
    else {
      const t3 = s2.state.transform, o = s2.state.inverseTransform, r2 = t3[0] * a2.xmin + t3[2] * a2.ymin + t3[4], i3 = t3[1] * a2.xmin + t3[3] * a2.ymin + t3[5], m4 = t3[0] * a2.xmax + t3[2] * a2.ymax + t3[4], l2 = t3[1] * a2.xmax + t3[3] * a2.ymax + t3[5];
      a2.xmin = o[0] * (r2 + n) + o[2] * (i3 + e) + o[4], a2.ymin = o[1] * (r2 + n) + o[3] * (i3 + e) + o[5], a2.xmax = o[0] * (m4 + n) + o[2] * (l2 + e) + o[4], a2.ymax = o[1] * (m4 + n) + o[3] * (l2 + e) + o[5];
    }
    return a2;
  }
  if (i2)
    r(a2, n * m3, -e * m3);
  else {
    const t3 = t(a2), r2 = "polyline" === a2.type ? a2.paths : a2.rings, i3 = s2.state.transform, m4 = s2.state.inverseTransform;
    for (let o = 0; o < t3.length; o++) {
      const r3 = t3[o];
      for (let t4 = 0; t4 < r3.length; t4++) {
        const o2 = r3[t4], s3 = i3[0] * o2[0] + i3[2] * o2[1] + i3[4], a3 = i3[1] * o2[0] + i3[3] * o2[1] + i3[5], l2 = m4[0] * (s3 + n) + m4[2] * (a3 + e) + m4[4], p = m4[1] * (s3 + n) + m4[3] * (a3 + e) + m4[5];
        r3[t4] = x(o2, l2, p, void 0);
      }
    }
    "paths" in a2 ? a2.paths = r2 : a2.rings = r2;
  }
  return a2;
}
function i(t2, r2, s2, i2) {
  if ("point" === t2.type) {
    const { x: n, y: e } = t2, o = i2 ? i2[0] : n, a3 = i2 ? i2[1] : e, m4 = t2.clone(), l3 = (n - o) * r2 + o, x2 = (e - a3) * s2 + a3;
    return m4.x = l3, m4.y = x2, m4;
  }
  if ("multipoint" === t2.type) {
    const a3 = t(t2), m4 = u(), [l3, p2, y2, f2] = h(m4, [a3]), u3 = i2 ? i2[0] : (l3 + y2) / 2, c2 = i2 ? i2[1] : (f2 + p2) / 2, h3 = t2.clone(), g2 = h3.points;
    for (let t3 = 0; t3 < g2.length; t3++) {
      const n = g2[t3], [e, o] = n, i3 = (e - u3) * r2 + u3, a4 = (o - c2) * s2 + c2;
      g2[t3] = x(n, i3, a4, void 0);
    }
    return h3;
  }
  if ("extent" === t2.type) {
    const { xmin: n, xmax: e, ymin: o, ymax: a3 } = t2, m4 = i2 ? i2[0] : (n + e) / 2, l3 = i2 ? i2[1] : (a3 + o) / 2, x2 = t2.clone();
    if (x2.xmin = (n - m4) * r2 + m4, x2.ymax = (a3 - l3) * s2 + l3, x2.xmax = (e - m4) * r2 + m4, x2.ymin = (o - l3) * s2 + l3, x2.xmin > x2.xmax) {
      const t3 = x2.xmin, n2 = x2.xmax;
      x2.xmin = n2, x2.xmax = t3;
    }
    if (x2.ymin > x2.ymax) {
      const t3 = x2.ymin, n2 = x2.ymax;
      x2.ymin = n2, x2.ymax = t3;
    }
    return x2;
  }
  const a2 = t(t2), m3 = u(), [l2, p, y, f] = h(m3, a2), u2 = i2 ? i2[0] : (l2 + y) / 2, c = i2 ? i2[1] : (f + p) / 2, h2 = t2.clone(), g = "polyline" === h2.type ? h2.paths : h2.rings;
  for (let n = 0; n < a2.length; n++) {
    const t3 = a2[n];
    for (let e = 0; e < t3.length; e++) {
      const o = t3[e], [i3, a3] = o, m4 = (i3 - u2) * r2 + u2, l3 = (a3 - c) * s2 + c;
      g[n][e] = x(o, m4, l3, void 0);
    }
  }
  return "paths" in h2 ? h2.paths = g : h2.rings = g, h2;
}
function a(t2, n, e, o, r2, s2) {
  const i2 = Math.sqrt((e - t2) * (e - t2) + (o - n) * (o - n));
  return Math.sqrt((r2 - t2) * (r2 - t2) + (s2 - n) * (s2 - n)) / i2;
}
function m2(n, e, o) {
  const r2 = Math.atan2(e.y - o.y, e.x - o.x) - Math.atan2(n.y - o.y, n.x - o.x), s2 = Math.atan2(Math.sin(r2), Math.cos(r2));
  return m(s2);
}
function l(t2, n, e, o) {
  return x(t2, t2[0] + n, t2[1] + e, null != t2[2] && null != o ? t2[2] + o : void 0);
}
function x(t2, n, e, o) {
  const r2 = [n, e];
  return t2.length > 2 && r2.push(null != o ? o : t2[2]), t2.length > 3 && r2.push(t2[3]), r2;
}

export {
  r,
  s,
  i,
  a,
  m2 as m
};
//# sourceMappingURL=chunk-PTJ3MGYO.js.map
