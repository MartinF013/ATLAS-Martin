import {
  c,
  f,
  i,
  l as l2,
  s,
  u
} from "./chunk-IG4CY4XM.js";
import {
  l
} from "./chunk-FVPTCNCX.js";

// node_modules/@arcgis/core/symbols/support/cimSymbolUtils.js
function i2(e) {
  const s2 = c(e);
  if ("CIMTextSymbol" === s2.type)
    return s2.height;
  let n = 0;
  if (s2.symbolLayers)
    for (const t of s2.symbolLayers)
      l2(t) && t.size > n ? n = t.size : u(t) && t.width > n ? n = t.width : s(t);
  return n;
}
function c2(e, o, a) {
  const r = c(e), s2 = i2(e);
  if (0 === s2)
    return void f2(r, o);
  l3(r, o / s2, false, a);
}
function f2(e, t) {
  if ("CIMTextSymbol" !== e.type) {
    if (e.symbolLayers)
      for (const o of e.symbolLayers)
        switch (o.type) {
          case "CIMPictureMarker":
          case "CIMVectorMarker":
            o.size = t;
            break;
          case "CIMPictureStroke":
          case "CIMSolidStroke":
            o.width = t;
        }
  } else
    e.height = t;
}
function l3(e, t, o, a) {
  if ("CIMTextSymbol" !== e.type) {
    if (o && e.effects)
      for (const o2 of e.effects)
        C(o2, t);
    if (e.symbolLayers)
      for (const o2 of e.symbolLayers)
        switch (o2.type) {
          case "CIMPictureMarker":
          case "CIMVectorMarker":
            m(o2, t, a);
            break;
          case "CIMPictureStroke":
          case "CIMSolidStroke":
            !(a == null ? void 0 : a.preserveOutlineWidth) && o2.width && (o2.width *= t);
            break;
          case "CIMPictureFill":
            o2.height && (o2.height *= t), o2.offsetX && (o2.offsetX *= t), o2.offsetY && (o2.offsetY *= t);
            break;
          case "CIMHatchFill":
            l3(o2.lineSymbol, t, true, { ...a, preserveOutlineWidth: false }), o2.offsetX && (o2.offsetX *= t), o2.offsetY && (o2.offsetY *= t), o2.separation && (o2.separation *= t);
        }
  } else
    e.height *= t;
}
function m(e, t, o) {
  if (e.markerPlacement && M(e.markerPlacement, t), e.offsetX && (e.offsetX *= t), e.offsetY && (e.offsetY *= t), e.anchorPoint && "Absolute" === e.anchorPointUnits && (e.anchorPoint = { x: e.anchorPoint.x * t, y: e.anchorPoint.y * t }), e.size *= t, "CIMVectorMarker" === e.type && e.markerGraphics)
    for (const a of e.markerGraphics)
      e.scaleSymbolsProportionally || l3(a.symbol, t, true, o);
}
function M(e, t) {
  switch (f(e) && e.offset && (e.offset *= t), e.type) {
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAlongLineSameSize":
      if (e.customEndingOffset && (e.customEndingOffset *= t), e.offsetAlongLine && (e.offsetAlongLine *= t), e.placementTemplate && e.placementTemplate.length) {
        const o = e.placementTemplate.map((e2) => e2 * t);
        e.placementTemplate = o;
      }
      break;
    case "CIMMarkerPlacementAlongLineVariableSize":
      if (e.maxRandomOffset && (e.maxRandomOffset *= t), e.placementTemplate && e.placementTemplate.length) {
        const o = e.placementTemplate.map((e2) => e2 * t);
        e.placementTemplate = o;
      }
      break;
    case "CIMMarkerPlacementOnLine":
      e.startPointOffset && (e.startPointOffset *= t);
      break;
    case "CIMMarkerPlacementAtExtremities":
      e.offsetAlongLine && (e.offsetAlongLine *= t);
      break;
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementOnVertices":
      break;
    case "CIMMarkerPlacementAtRatioPositions":
      e.beginPosition && (e.beginPosition *= t), e.endPosition && (e.endPosition *= t);
      break;
    case "CIMMarkerPlacementPolygonCenter":
      e.offsetX && (e.offsetX *= t), e.offsetY && (e.offsetY *= t);
      break;
    case "CIMMarkerPlacementInsidePolygon":
      e.offsetX && (e.offsetX *= t), e.offsetY && (e.offsetY *= t), e.stepX && (e.stepX *= t), e.stepY && (e.stepY *= t);
  }
}
function C(e, t) {
  switch (e.type) {
    case "CIMGeometricEffectArrow":
    case "CIMGeometricEffectDonut":
      e.width && (e.width *= t);
      break;
    case "CIMGeometricEffectBuffer":
      e.size && (e.size *= t);
      break;
    case "CIMGeometricEffectCut":
      e.beginCut && (e.beginCut *= t), e.endCut && (e.endCut *= t), e.middleCut && (e.middleCut *= t);
      break;
    case "CIMGeometricEffectDashes":
      if (e.customEndingOffset && (e.customEndingOffset *= t), e.offsetAlongLine && (e.offsetAlongLine *= t), e.dashTemplate && e.dashTemplate.length) {
        const o = e.dashTemplate.map((e2) => e2 * t);
        e.dashTemplate = o;
      }
      break;
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectJog":
    case "CIMGeometricEffectRadial":
      e.length && (e.length *= t);
      break;
    case "CIMGeometricEffectMove":
      e.offsetX && (e.offsetX *= t), e.offsetY && (e.offsetY *= t);
      break;
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      e.offset && (e.offset *= t);
      break;
    case "CIMGeometricEffectRegularPolygon":
      e.radius && (e.radius *= t);
      break;
    case "CIMGeometricEffectTaperedPolygon":
      e.fromWidth && (e.fromWidth *= t), e.length && (e.length *= t), e.toWidth && (e.toWidth *= t);
      break;
    case "CIMGeometricEffectWave":
      e.amplitude && (e.amplitude *= t), e.period && (e.period *= t);
  }
}
function y(o) {
  const a = [];
  return k(c(o), a), a.length ? new l(i(a[0])) : null;
}
function k(e, t) {
  let r;
  r = "CIMTextSymbol" === e.type ? e.symbol : e;
  const n = "CIMPolygonSymbol" === e.type;
  if (r.symbolLayers) {
    for (const i3 of r.symbolLayers)
      if (!(i3.colorLocked || n && (u(i3) || l2(i3) && i3.markerPlacement && f(i3.markerPlacement))))
        switch (i3.type) {
          case "CIMPictureMarker":
          case "CIMPictureStroke":
          case "CIMPictureFill":
            i3.tintColor && b(t, i3.tintColor);
            break;
          case "CIMVectorMarker":
            i3.markerGraphics.forEach((e2) => {
              k(e2.symbol, t);
            });
            break;
          case "CIMSolidStroke":
          case "CIMSolidFill":
            b(t, i3.color);
            break;
          case "CIMHatchFill":
            k(i3.lineSymbol, t);
        }
  }
}
function b(e, t) {
  for (const o of e)
    if (o.join(".") === t.join("."))
      return;
  e.push(t);
}
function p(o, a, r) {
  a instanceof l || (a = new l(a));
  const s2 = c(o);
  s2 && I(s2, a, r);
}
function I(e, t, n) {
  let i3;
  i3 = "CIMTextSymbol" === e.type ? e.symbol : e;
  const c3 = "CIMPolygonSymbol" === i3.type;
  if (i3.symbolLayers)
    for (const f3 of i3.symbolLayers) {
      if (f3.colorLocked)
        continue;
      if (c3) {
        if (n) {
          const { layersToColor: e3 } = n;
          if ((u(f3) || l2(f3) && f3.markerPlacement && f(f3.markerPlacement)) && "fill" === e3 || s(f3) && "outline" === e3)
            continue;
        } else if (u(f3) || l2(f3) && f3.markerPlacement && f(f3.markerPlacement))
          continue;
      }
      const e2 = t.toArray();
      switch (f3.type) {
        case "CIMPictureMarker":
        case "CIMPictureStroke":
        case "CIMPictureFill":
          f3.tintColor = e2;
          break;
        case "CIMVectorMarker":
          f3.markerGraphics.forEach((e3) => {
            I(e3.symbol, t, n);
          });
          break;
        case "CIMSolidStroke":
        case "CIMSolidFill":
          f3.color = e2;
          break;
        case "CIMHatchFill":
          I(f3.lineSymbol, t, n);
      }
    }
}

export {
  i2 as i,
  c2 as c,
  m,
  y,
  p
};
//# sourceMappingURL=chunk-JYR7GBAU.js.map
