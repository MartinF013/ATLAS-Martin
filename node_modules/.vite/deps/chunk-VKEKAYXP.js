import {
  s as s2
} from "./chunk-ATJYWC6C.js";
import {
  a,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import {
  n as n2
} from "./chunk-6DWU2ZQF.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  d as d2
} from "./chunk-4PRVTUEZ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  p
} from "./chunk-YPZEGNLG.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";

// node_modules/@arcgis/core/views/layers/support/ClipArea.js
var e2 = class extends l {
};
e2 = e([n("esri.views.layers.support.ClipArea")], e2);
var t = e2;

// node_modules/@arcgis/core/views/layers/support/ClipRect.js
var s3;
var i = s3 = class extends t {
  constructor() {
    super(...arguments), this.type = "rect", this.left = null, this.right = null, this.top = null, this.bottom = null;
  }
  clone() {
    return new s3({ left: this.left, right: this.right, top: this.top, bottom: this.bottom });
  }
  get version() {
    return (this._get("version") || 0) + 1;
  }
};
e([d({ type: [Number, String], json: { write: true } })], i.prototype, "left", void 0), e([d({ type: [Number, String], json: { write: true } })], i.prototype, "right", void 0), e([d({ type: [Number, String], json: { write: true } })], i.prototype, "top", void 0), e([d({ type: [Number, String], json: { write: true } })], i.prototype, "bottom", void 0), e([d({ readOnly: true })], i.prototype, "version", null), i = s3 = e([n("esri.views.layers.support.ClipRect")], i);
var p2 = i;

// node_modules/@arcgis/core/views/layers/support/Geometry.js
var y;
var n3 = { base: p, key: "type", typeMap: { extent: M, polygon: v } };
var c = y = class extends t {
  constructor() {
    super(...arguments), this.type = "geometry", this.geometry = null;
  }
  get version() {
    return (this._get("version") || 0) + 1;
  }
  clone() {
    return new y({ geometry: this.geometry.clone() });
  }
};
e([d({ types: n3, json: { read: d2, write: true } })], c.prototype, "geometry", void 0), e([d({ readOnly: true })], c.prototype, "version", null), c = y = e([n("esri.views.layers.support.Geometry")], c);
var a2 = c;

// node_modules/@arcgis/core/views/layers/support/Path.js
var e3 = class extends t {
  constructor() {
    super(...arguments), this.type = "path", this.path = [];
  }
  get version() {
    return (this._get("version") || 0) + 1;
  }
};
e([d({ type: [[[Number]]], json: { write: true } })], e3.prototype, "path", void 0), e([d({ readOnly: true })], e3.prototype, "version", null), e3 = e([n("esri.views.layers.support.Path")], e3);
var p3 = e3;

// node_modules/@arcgis/core/views/2d/layers/LayerView2D.js
var y2 = j.ofType({ key: "type", base: t, typeMap: { rect: p2, path: p3, geometry: a2 } });
var f = (t2) => {
  let c2 = class extends t2 {
    constructor() {
      super(...arguments), this.attached = false, this.clips = new y2(), this.lastUpdateId = -1, this.moving = false, this.updateRequested = false;
    }
    initialize() {
      var _a, _b, _c;
      const e4 = ((_a = this.view) == null ? void 0 : _a.spatialReferenceLocked) ?? true, t3 = (_b = this.view) == null ? void 0 : _b.spatialReference;
      t3 && e4 && !this.spatialReferenceSupported ? this.addResolvingPromise(Promise.reject(new s("layerview:spatial-reference-incompatible", "The spatial reference of this layer does not meet the requirements of the view", { layer: this.layer }))) : (this.container || (this.container = new s2()), this.container.fadeTransitionEnabled = true, this.container.opacity = 0, this.container.clips = this.clips, this.handles.add([l2(() => this.suspended, (e5) => {
        this.container && (this.container.visible = !e5), this.view && !e5 && this.updateRequested && this.view.requestUpdate();
      }, w), l2(() => {
        var _a2;
        return ((_a2 = this.layer) == null ? void 0 : _a2.opacity) ?? 1;
      }, (e5) => {
        this.container && (this.container.opacity = e5);
      }, w), l2(() => this.layer && "blendMode" in this.layer ? this.layer.blendMode : "normal", (e5) => {
        this.container && (this.container.blendMode = e5);
      }, w), l2(() => this.layer && "effect" in this.layer ? this.layer.effect : null, (e5) => {
        this.container && (this.container.effect = e5);
      }, w), a(() => this.clips, "change", () => {
        this.container && (this.container.clips = this.clips);
      })]), ((_c = this.view) == null ? void 0 : _c.whenLayerView) ? this.view.whenLayerView(this.layer).then((e5) => {
        e5 === this && this.processAttach();
      }, () => {
      }) : this.when().then(() => {
        this.processAttach();
      }, () => {
      }));
    }
    destroy() {
      this.processDetach(), this.updateRequested = false;
    }
    get spatialReferenceSupported() {
      var _a;
      const e4 = (_a = this.view) == null ? void 0 : _a.spatialReference;
      return null == e4 || this.supportsSpatialReference(e4);
    }
    get updating() {
      var _a;
      return this.spatialReferenceSupported && (!this.attached || !this.suspended && (this.updateRequested || this.isUpdating()) || !!((_a = this.updatingHandles) == null ? void 0 : _a.updating));
    }
    get visibleAtCurrentScale() {
      return this.isVisibleAtScale(this.view.scale);
    }
    processAttach() {
      this.isResolved() && !this.attached && !this.destroyed && this.spatialReferenceSupported && (this.attach(), this.attached = true, this.requestUpdate());
    }
    processDetach() {
      this.attached && (this.attached = false, this.detach(), this.updateRequested = false);
    }
    isVisibleAtScale(e4) {
      const t3 = this.layer && "effectiveScaleRange" in this.layer ? this.layer.effectiveScaleRange : null;
      if (!t3)
        return true;
      const { minScale: s4, maxScale: i2 } = t3;
      return (0 === s4 || e4 <= s4) && (0 === i2 || e4 >= i2);
    }
    requestUpdate() {
      this.destroyed || this.updateRequested || (this.updateRequested = true, this.suspended || this.view.requestUpdate());
    }
    processUpdate(e4) {
      !this.isFulfilled() || this.isResolved() ? (this._set("updateParameters", e4), this.updateRequested && !this.suspended && (this.updateRequested = false, this.update(e4))) : this.updateRequested = false;
    }
    hitTest(e4, t3) {
      return Promise.resolve(null);
    }
    supportsSpatialReference(e4) {
      return true;
    }
    canResume() {
      return !!this.spatialReferenceSupported && (!!super.canResume() && this.visibleAtCurrentScale);
    }
    getSuspendInfo() {
      const e4 = super.getSuspendInfo(), t3 = !this.spatialReferenceSupported, s4 = this.visibleAtCurrentScale;
      return t3 && (e4.spatialReferenceNotSupported = t3), s4 && (e4.outsideScaleRange = s4), e4;
    }
  };
  return e([d()], c2.prototype, "attached", void 0), e([d({ type: y2, set(e4) {
    const t3 = n2(e4, this._get("clips"), y2);
    this._set("clips", t3);
  } })], c2.prototype, "clips", void 0), e([d()], c2.prototype, "container", void 0), e([d()], c2.prototype, "moving", void 0), e([d({ readOnly: true })], c2.prototype, "spatialReferenceSupported", null), e([d({ readOnly: true })], c2.prototype, "updateParameters", void 0), e([d()], c2.prototype, "updateRequested", void 0), e([d()], c2.prototype, "updating", null), e([d()], c2.prototype, "view", void 0), e([d({ readOnly: true })], c2.prototype, "visibleAtCurrentScale", null), c2 = e([n("esri.views.2d.layers.LayerView2D")], c2), c2;
};

export {
  f
};
//# sourceMappingURL=chunk-VKEKAYXP.js.map
