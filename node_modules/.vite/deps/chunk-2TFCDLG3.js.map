{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/PointRenderer.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{ShaderOutput as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js\";import{SliceDraw as i}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{OutputHighlight as o}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{RgbaFloatEncoding as r}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{Float2PassUniform as t}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float2Uniform as n}from\"../views/3d/webgl-engine/core/shaderModules/Float2Uniform.js\";import{Float3Uniform as a}from\"../views/3d/webgl-engine/core/shaderModules/Float3Uniform.js\";import{glsl as s}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{Matrix4Uniform as l}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4Uniform.js\";import{ShaderBuilder as c}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{VertexAttribute as p}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function m(m){const f=new c,g=m.output===e.Color,u=m.output===e.Depth,v=m.output===e.Highlight,{vertex:w,fragment:S}=f;return f.extensions.add(\"GL_OES_standard_derivatives\"),f.include(i,m),f.attributes.add(p.POSITION,\"vec3\"),f.attributes.add(p.COLOR,\"vec3\"),w.uniforms.add(new l(\"modelView\")),w.uniforms.add(new d(\"proj\",((e,i)=>i.camera.projectionMatrix))),w.uniforms.add(new n(\"screenMinMaxSize\")),w.uniforms.add(new n(\"pointScale\")),w.uniforms.add(new a(\"clipMin\")),w.uniforms.add(new a(\"clipMax\")),u?(w.uniforms.add(new t(\"nearFar\",((e,i)=>i.camera.nearFar))),f.varyings.add(\"depth\",\"float\")):m.output!==e.Highlight&&f.varyings.add(\"vColor\",\"vec3\"),w.code.add(s`\n    void main(void) {\n      // Move clipped points outside of clipspace\n      if (position.x < clipMin.x || position.y < clipMin.y || position.z < clipMin.z ||\n        position.x > clipMax.x || position.y > clipMax.y || position.z > clipMax.z) {\n        gl_Position = vec4(0.0,0.0,0.0,2.0);\n        gl_PointSize = 0.0;\n        return;\n      }\n\n      if (rejectBySlice(position)) {\n        gl_Position = vec4(0.0,0.0,0.0,2.0);\n        gl_PointSize = 0.0;\n        return;\n      }\n\n      // Position in camera space\n      vec4 camera = modelView * vec4(position, 1.0);\n\n      float pointSize = pointScale.x;\n      vec4 position = proj * camera;\n     ${m.drawScreenSize?s`\n      float clampedScreenSize = pointSize;`:s`\n      float pointRadius = 0.5 * pointSize;\n      vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);\n      vec4 positionOffset = proj * cameraOffset;\n      float radius = abs(positionOffset.y - position.y);\n      float viewHeight = pointScale.y;\n      // screen diameter = (2 * r / w) * (h / 2)\n      float screenPointSize = (radius / position.w) * viewHeight;\n      float clampedScreenSize = clamp(screenPointSize, screenMinMaxSize.x, screenMinMaxSize.y);\n      // Shift towards camera, to move rendered point out of terrain i.e. to\n      // the camera-facing end of the virtual point when considering it as a\n      // 3D sphere.\n      camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;\n      position = proj * camera;`}\n\n     gl_PointSize = clampedScreenSize;\n     gl_Position = position;\n\n     ${u?s`depth = (-camera.z - nearFar[0]) / (nearFar[1] - nearFar[0]);`:\"\"}\n     ${g?s`vColor = color;`:\"\"}\n    }\n  `),S.include(r,m),v&&f.include(o),S.code.add(s`\n    void main(void) {\n      vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);\n      float r2 = dot(vOffset, vOffset);\n\n      if (r2 > 0.25) {\n        discard;\n      }\n      ${u?s`gl_FragColor = float2rgba(depth);`:\"\"}\n      ${v?s`outputHighlight();`:\"\"}\n      ${g?s`gl_FragColor = vec4(vColor, 1.0);`:\"\"}\n    }\n  `),f}const f=Object.freeze(Object.defineProperty({__proto__:null,build:m},Symbol.toStringTag,{value:\"Module\"}));export{f as P,m as b};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIynC,SAAS,EAAEA,IAAE;AAAC,QAAMC,KAAE,IAAI,KAAE,IAAED,GAAE,WAAS,EAAE,OAAME,KAAEF,GAAE,WAAS,EAAE,OAAM,IAAEA,GAAE,WAAS,EAAE,WAAU,EAAC,QAAO,GAAE,UAAS,EAAC,IAAEC;AAAE,SAAOA,GAAE,WAAW,IAAI,6BAA6B,GAAEA,GAAE,QAAQ,GAAED,EAAC,GAAEC,GAAE,WAAW,IAAI,EAAE,UAAS,MAAM,GAAEA,GAAE,WAAW,IAAI,EAAE,OAAM,MAAM,GAAE,EAAE,SAAS,IAAI,IAAIE,GAAE,WAAW,CAAC,GAAE,EAAE,SAAS,IAAI,IAAIC,GAAE,QAAQ,CAACA,IAAEC,OAAIA,GAAE,OAAO,gBAAiB,CAAC,GAAE,EAAE,SAAS,IAAI,IAAIF,GAAE,kBAAkB,CAAC,GAAE,EAAE,SAAS,IAAI,IAAIA,GAAE,YAAY,CAAC,GAAE,EAAE,SAAS,IAAI,IAAIA,GAAE,SAAS,CAAC,GAAE,EAAE,SAAS,IAAI,IAAIA,GAAE,SAAS,CAAC,GAAED,MAAG,EAAE,SAAS,IAAI,IAAI,EAAE,WAAW,CAACE,IAAEC,OAAIA,GAAE,OAAO,OAAQ,CAAC,GAAEJ,GAAE,SAAS,IAAI,SAAQ,OAAO,KAAGD,GAAE,WAAS,EAAE,aAAWC,GAAE,SAAS,IAAI,UAAS,MAAM,GAAE,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAqB1wDD,GAAE,iBAAe;AAAA,8CACoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAkBrCE,KAAE,mEAAiE;AAAA,OACnE,IAAE,qBAAmB;AAAA;AAAA,GAEzB,GAAE,EAAE,QAAQ,GAAEF,EAAC,GAAE,KAAGC,GAAE,QAAQK,EAAC,GAAE,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAQvCJ,KAAE,uCAAqC;AAAA,QACvC,IAAE,wBAAsB;AAAA,QACxB,IAAE,uCAAqC;AAAA;AAAA,GAE5C,GAAED;AAAC;AAAC,IAAM,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["m", "f", "u", "o", "e", "i", "a"]
}
