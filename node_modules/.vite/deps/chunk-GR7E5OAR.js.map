{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/ShadowCastAccumulate.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{a as e,j as a}from\"./mat4.js\";import{c as r}from\"./mat4f64.js\";import{ScreenSpacePass as o}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.js\";import{ReadLinearDepth as s}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{ReadShadowMapBindParameters as i,ReadShadowMapPass as t}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{CameraSpace as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js\";import{RgbaFloatEncoding as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{Float2PassUniform as n}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{glsl as c}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as h}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";class w extends i{}const u=255,g=1/u;function v(){const r=new h,i=r.fragment;return i.include(l),i.include(s),r.include(d),r.include(o),r.include(t,{receiveShadows:!0}),i.uniforms.add([new m(\"depthMap\",(e=>e.linearDepthTexture)),new p(\"inverseViewMatrix\",((r,o)=>e(f,a(f,o.camera.viewMatrix,o.camera.center)))),new n(\"nearFar\",((e,a)=>a.camera.nearFar))]),i.constants.add(\"sampleValue\",\"float\",g),i.code.add(c`void main(void) {\nfloat depth = rgba2float(texture2D(depthMap, uv));\nif (depth == 0.0) {\ndiscard;\n}\nfloat currentPixelDepth = linearDepthFromFloat(depth, nearFar);\nif (-currentPixelDepth > nearFar.y || -currentPixelDepth < nearFar.x) {\ndiscard;\n}\nvec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);\nvec4 worldSpacePos = inverseViewMatrix * currentPixelPos;\nmat4 shadowMatrix;\nfloat linearDepth = -currentPixelDepth;\nint i = chooseCascade(linearDepth, shadowMatrix);\nif (i >= numCascades) {\ndiscard;\n}\nvec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);\nif (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {\ndiscard;\n}\nvec2 uvShadow = cascadeCoordinates(i, lvpos);\nfloat depthShadow = readShadowMapDepth(uvShadow, shadowMapTex);\nbool shadow = depthShadow < lvpos.z;\nif (!shadow) {\ndiscard;\n}\ngl_FragColor = vec4(sampleValue);\n}`),r}const f=r(),x=Object.freeze(Object.defineProperty({__proto__:null,ShadowCastAccumulatePassParameters:w,shadowCastMaxSamples:u,build:v},Symbol.toStringTag,{value:\"Module\"}));export{w as S,x as a,v as b,u as s};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAI0lC,IAAM,IAAN,cAAgBA,GAAC;AAAC;AAAC,IAAM,IAAE;AAAR,IAAY,IAAE,IAAE;AAAE,SAAS,IAAG;AAAC,QAAM,IAAE,IAAI,KAAEC,KAAE,EAAE;AAAS,SAAOA,GAAE,QAAQ,CAAC,GAAEA,GAAE,QAAQC,EAAC,GAAE,EAAE,QAAQF,EAAC,GAAE,EAAE,QAAQ,CAAC,GAAE,EAAE,QAAQG,IAAE,EAAC,gBAAe,KAAE,CAAC,GAAEF,GAAE,SAAS,IAAI,CAAC,IAAIG,GAAE,YAAY,CAAAC,OAAGA,GAAE,kBAAmB,GAAE,IAAIA,GAAE,qBAAqB,CAACC,IAAEC,OAAI,EAAE,GAAE,EAAE,GAAEA,GAAE,OAAO,YAAWA,GAAE,OAAO,MAAM,CAAC,CAAE,GAAE,IAAIF,GAAE,WAAW,CAACA,IAAEH,OAAIA,GAAE,OAAO,OAAQ,CAAC,CAAC,GAAED,GAAE,UAAU,IAAI,eAAc,SAAQ,CAAC,GAAEA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4Bh/C,GAAE;AAAC;AAAC,IAAM,IAAE,EAAE;AAAV,IAAY,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,oCAAmC,GAAE,sBAAqB,GAAE,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["n", "i", "a", "h", "c", "e", "r", "o"]
}
