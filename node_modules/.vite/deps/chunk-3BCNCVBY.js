import {
  C,
  L,
  Me,
  O,
  X,
  _,
  ee,
  ke,
  ne,
  oe,
  re,
  t,
  w,
  z
} from "./chunk-LBBA3SFR.js";
import {
  p
} from "./chunk-YPZEGNLG.js";

// node_modules/@arcgis/core/arcade/Dictionary.js
function m(t2, r = false) {
  if (null == t2)
    return null;
  if (O(t2))
    return ne(t2);
  if (_(t2))
    return oe(t2);
  if (w(t2))
    return X(t2);
  if (z(t2))
    return re(t2);
  if (L(t2)) {
    const s = [];
    for (const i of t2)
      s.push(m(i, r));
    return s;
  }
  const n = new d();
  n.immutable = false;
  for (const s of Object.keys(t2)) {
    const i = t2[s];
    void 0 !== i && n.setField(s, m(i, r));
  }
  return n.immutable = r, n;
}
var d = class {
  constructor(t2) {
    this.declaredClass = "esri.arcade.Dictionary", this.attributes = null, this.plain = false, this.immutable = true, this.attributes = t2 instanceof d ? t2.attributes : null == t2 ? {} : t2;
  }
  field(t2) {
    const s = t2.toLowerCase(), i = this.attributes[t2];
    if (void 0 !== i)
      return i;
    for (const e in this.attributes)
      if (e.toLowerCase() === s)
        return this.attributes[e];
    throw new Error("Field not Found : " + t2);
  }
  setField(t2, s) {
    if (this.immutable)
      throw new Error("Dictionary is Immutable");
    const i = t2.toLowerCase();
    if (void 0 === this.attributes[t2]) {
      for (const t3 in this.attributes)
        if (t3.toLowerCase() === i)
          return void (this.attributes[t3] = s);
      this.attributes[t2] = s;
    } else
      this.attributes[t2] = s;
  }
  hasField(t2) {
    const s = t2.toLowerCase();
    if (void 0 !== this.attributes[t2])
      return true;
    for (const i in this.attributes)
      if (i.toLowerCase() === s)
        return true;
    return false;
  }
  keys() {
    let t2 = [];
    for (const s in this.attributes)
      t2.push(s);
    return t2 = t2.sort(), t2;
  }
  castToText() {
    let n = "";
    for (const a in this.attributes) {
      "" !== n && (n += ",");
      const o = this.attributes[a];
      null == o ? n += JSON.stringify(a) + ":null" : _(o) || O(o) || w(o) ? n += JSON.stringify(a) + ":" + JSON.stringify(o) : o instanceof p || o instanceof t || o instanceof Array ? n += JSON.stringify(a) + ":" + ee(o) : o instanceof Date ? n += JSON.stringify(a) + ":" + JSON.stringify(o) : null !== o && "object" == typeof o && void 0 !== o.castToText && (n += JSON.stringify(a) + ":" + o.castToText());
    }
    return "{" + n + "}";
  }
  static convertObjectToArcadeDictionary(t2, s = true) {
    const i = new d();
    i.immutable = false;
    for (const e in t2) {
      const s2 = t2[e];
      void 0 !== s2 && i.setField(e.toString(), m(s2));
    }
    return i.immutable = s, i;
  }
  static convertJsonToArcade(t2, s = false) {
    return m(t2, s);
  }
  castAsJson(t2 = null) {
    const s = {};
    for (let i in this.attributes) {
      const e = this.attributes[i];
      void 0 !== e && ((t2 == null ? void 0 : t2.keyTranslate) && (i = t2.keyTranslate(i)), s[i] = ke(e, t2));
    }
    return s;
  }
  async castDictionaryValueAsJsonAsync(t2, s, i, e = null, r) {
    const n = await Me(i, e, r);
    return t2[s] = n, n;
  }
  async castAsJsonAsync(t2 = null, s = null) {
    const i = {}, e = [];
    for (let r in this.attributes) {
      const a = this.attributes[r];
      (s == null ? void 0 : s.keyTranslate) && (r = s.keyTranslate(r)), void 0 !== a && (C(a) || a instanceof p || a instanceof Date ? i[r] = ke(a, s) : e.push(this.castDictionaryValueAsJsonAsync(i, r, a, t2, s)));
    }
    return e.length > 0 && await Promise.all(e), i;
  }
};

export {
  d
};
//# sourceMappingURL=chunk-3BCNCVBY.js.map
