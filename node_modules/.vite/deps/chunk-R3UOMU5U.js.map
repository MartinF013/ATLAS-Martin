{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/ChapmanAtmosphere.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{a as e}from\"./mat4.js\";import{c as t}from\"./mat4f64.js\";import{TextureCoordinateAttribute as a,TextureCoordinateAttributeType as r}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";import{ReadLinearDepth as i}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{Gamma as o}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js\";import{Float2PassUniform as n}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float2Uniform as s}from\"../views/3d/webgl-engine/core/shaderModules/Float2Uniform.js\";import{Float3PassUniform as l}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{Float3Uniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float3Uniform.js\";import{Float4Uniform as h}from\"../views/3d/webgl-engine/core/shaderModules/Float4Uniform.js\";import{FloatUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/FloatUniform.js\";import{glsl as m}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as g}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DUniform.js\";import{VertexAttribute as u}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function v(t){const v=new g;v.attributes.add(u.POSITION,\"vec2\"),v.include(a,{textureCoordinateType:r.Default}),v.varyings.add(\"worldRay\",\"vec3\"),v.varyings.add(\"eyeDir\",\"vec3\");const{vertex:x,fragment:D}=v;return x.uniforms.add([new p(\"inverseProjectionMatrix\",((e,t)=>t.camera.inverseProjectionMatrix)),new p(\"inverseViewMatrix\",((t,a)=>e(y,a.camera.viewMatrix)))]),x.code.add(m`void main(void) {\nvec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1, 1)).xyz;\neyeDir = posViewNear;\nworldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;\nforwardTextureCoordinates();\ngl_Position = vec4(position, 1, 1);\n}`),D.uniforms.add([new l(\"lightingMainDirection\",((e,t)=>t.lighting.lightingMainDirection)),new s(\"radii\"),new d(\"scaleHeight\"),new c(\"cameraPosition\"),new h(\"heightParameters\"),new d(\"innerFadeDistance\"),new d(\"altitudeFade\"),new f(\"depthTex\"),new c(\"betaRayleigh\"),new c(\"betaCombined\"),new d(\"betaMie\"),new d(\"hazeStrength\")]),v.include(o),t.haze&&(D.include(i),D.uniforms.add(new n(\"nearFar\",((e,t)=>t.camera.nearFar)))),D.code.add(m`vec2 sphereIntersect(vec3 start, vec3 dir, float radius, bool planet) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = planet ? heightParameters[1] - radius * radius : heightParameters[2];\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}`),D.code.add(m`float chapmanApproximation(float X, float h, float cosZenith) {\nfloat c = sqrt(X + h);\nfloat cExpH = c * exp(-h);\nif (cosZenith >= 0.0) {\nreturn cExpH / (c * cosZenith + 1.0);\n} else {\nfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\nfloat c0 = sqrt(x0);\nreturn 2.0 * c0 * exp(X - x0) - cExpH / (1.0 - c * cosZenith);\n}\n}`),D.code.add(m`float getOpticalDepth(vec3 position, vec3 dir, float h) {\nreturn scaleHeight * chapmanApproximation(radii[0] / scaleHeight, h, dot(normalize(position), dir));\n}`),D.code.add(m`\n    const int STEPS = 6;\n\n    float getGlow(float dist, float radius, float intensity) {\n      return pow(radius / max(dist, 1e-6), intensity);\n    }\n\n    vec3 getAtmosphereColour(vec3 cameraPos, vec3 rayDir, vec3 lightDir, float terrainDepth) {\n      float reducedPlanetRadius = radii[0] - 20000.0;\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, reducedPlanetRadius, true);\n      vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, radii[1], false);\n      bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;\n      bool insideAtmosphere = heightParameters[0] < radii[1];\n\n      if (!(hitsAtmosphere || insideAtmosphere)) {\n        return vec3(0);\n      }\n\n      bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;\n\n      float start = insideAtmosphere ? 0.0 : rayAtmosphereIntersect.x;\n\n      if (heightParameters[0] < reducedPlanetRadius) {\n        // Long light rays from the night side of the planet lead to numerical instability\n        // Do not render the atmosphere in such cases\n        if (dot(rayDir, normalize(cameraPos)) < -0.025) {\n          return vec3(0);\n        }\n        start = rayPlanetIntersect.y;\n      }\n\n      float end = hitsPlanet ? rayPlanetIntersect.x : rayAtmosphereIntersect.y;\n      float maxEnd = end;\n\n      ${t.haze?m`if (terrainDepth != -1.0) { end = terrainDepth; }`:\"\"}\n\n      vec3 samplePoint = cameraPos + rayDir * end;\n      float multiplier = hitsPlanet ? -1.0 : 1.0;\n\n      vec3 scattering = vec3(0);\n      float scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n      float lastOpticalDepth = getOpticalDepth(samplePoint, rayDir, scaleFract);\n      float stepSize = (end - start) / float(STEPS);\n      for (int i = 0; i < STEPS; i++) {\n        samplePoint -= stepSize * rayDir;\n        scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n        float opticalDepth = multiplier * getOpticalDepth(samplePoint, rayDir * multiplier, scaleFract);\n\n        if (i > 0) {\n          scattering *= ${t.haze?m``:\" mix(2.5, 1.0, clamp((length(cameraPos) - radii[0]) / 50e3, 0.0, 1.0)) * \"} exp(-(mix(betaCombined, betaRayleigh, 0.5) + betaMie) * max(0.0, (opticalDepth - lastOpticalDepth)));\n        }\n\n        if (dot(normalize(samplePoint), lightDir) > -0.3) {\n\n          float scale = exp(-scaleFract);\n          float lightDepth = getOpticalDepth(samplePoint, lightDir, scaleFract);\n\n          scattering += scale * exp(-(betaCombined + betaMie) * lightDepth);\n          ${t.haze?\"\":m`scattering += scale * exp(-(0.25 * betaCombined ) * lightDepth);`}\n        }\n\n        lastOpticalDepth = opticalDepth;\n\n      }\n\n      float mu = dot(rayDir, lightDir);\n      float mumu = 1.0 + mu * mu;\n\n      float phaseRayleigh = 0.05968310365 * mumu;\n\n      ${t.haze?m`return 3.0 * scattering * stepSize * phaseRayleigh * betaRayleigh;`:m`\n            const float g = 0.8;\n            const float gg = g * g;\n            float phaseMie = end == maxEnd ? 0.11936620731 * ((1.0 - gg) * mumu) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n            phaseMie += getGlow(1.0 - mu, 5e-5, 3.0) * smoothstep(0.01, 0.1, length(scattering));\n            phaseMie = clamp(phaseMie, 0.0, 128.0);\n            return 3.0 * scattering * stepSize * (phaseRayleigh * betaRayleigh + 0.025 * phaseMie * betaMie);`}\n    }\n\n    vec3 tonemapACES(vec3 x) {\n      return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n\n    vec4 applyUndergroundAtmosphere(vec3 rayDir, vec3 lightDirection, vec4 fragColor) {\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPosition, rayDir, radii[0], true);\n      if (!((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.y > 0.0)) {\n        return fragColor;\n      }\n\n      float lightAngle = dot(lightDirection, normalize(cameraPosition + rayDir * max(0.0, rayPlanetIntersect.x)));\n      vec4 surfaceColor = vec4(vec3(max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)))), 1.0 - altitudeFade);\n      float relDist = (rayPlanetIntersect.y - max(0.0, rayPlanetIntersect.x)) / innerFadeDistance;\n      if (relDist > 1.0) {\n        return surfaceColor;\n      }\n\n      return mix(gl_FragColor, surfaceColor, smoothstep(0.0, 1.0, relDist * relDist));\n    }\n\n    void main() {\n      vec3 rayDir = normalize(worldRay);\n      float terrainDepth = -1.0;\n      ${t.haze?m`\n          vec4 depthSample = texture2D(depthTex, vuv0).rgba;\n          if (depthSample != vec4(0)) {\n            vec3 cameraSpaceRay = normalize(eyeDir);\n            cameraSpaceRay /= cameraSpaceRay.z;\n            cameraSpaceRay *= -linearDepthFromTexture(depthTex, vuv0, nearFar);\n            terrainDepth = max(0.0, length(cameraSpaceRay));\n          }`:m`\n          float depthSample = texture2D(depthTex, vuv0).r;\n          if (depthSample != 1.0) {\n            gl_FragColor = vec4(0);\n            return;\n          }`}\n\n      ${t.haze?m`\n            vec3 col = vec3(0);\n            float fadeOut = smoothstep(-10000.0, -15000.0, heightParameters[0] - radii[0]);\n            if(depthSample != vec4(0)){\n              col = (1.0 - fadeOut) * hazeStrength * getAtmosphereColour(cameraPosition, rayDir, lightingMainDirection, terrainDepth);\n            }\n            float alpha = 1.0 - fadeOut;`:m`\n            vec3 col = getAtmosphereColour(cameraPosition, rayDir, lightingMainDirection, terrainDepth);;\n            float alpha = smoothstep(0.0, mix(0.15, 0.01, heightParameters[3]), length(col));`}\n      col = tonemapACES(col);\n      gl_FragColor = delinearizeGamma(vec4(col, alpha));\n      ${t.haze?\"\":m`\n          if (depthSample == 1.0) {\n            gl_FragColor = applyUndergroundAtmosphere(rayDir, lightingMainDirection, gl_FragColor);\n          }`}\n    }\n  `),v}const y=t(),x=Object.freeze(Object.defineProperty({__proto__:null,build:v},Symbol.toStringTag,{value:\"Module\"}));export{x as C,v as b};\n"],
  "mappings": "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",
  "names": ["v", "x", "e", "t", "a", "o"]
}
