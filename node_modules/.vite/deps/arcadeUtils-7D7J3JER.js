import {
  A as A2,
  E as E2,
  I,
  N as N2,
  O as O2,
  P as P2,
  S,
  b,
  d as d3,
  f,
  h as h2,
  m as m4,
  o,
  p as p2,
  r,
  u,
  y
} from "./chunk-LKISLLXN.js";
import {
  d as d2,
  s
} from "./chunk-WC3LL63J.js";
import {
  e
} from "./chunk-U7LREOA7.js";
import "./chunk-Q3ZGS5K7.js";
import {
  d
} from "./chunk-3BCNCVBY.js";
import {
  z as z2
} from "./chunk-3TW5VFUG.js";
import "./chunk-RO2QI6Y3.js";
import "./chunk-7DMYZG6H.js";
import {
  A,
  Ce,
  D2 as D,
  E,
  G,
  J,
  L,
  M as M2,
  N,
  Ne,
  O,
  P2 as P,
  Q,
  R,
  W,
  X,
  Y,
  _,
  h,
  i,
  j as j2,
  k as k3,
  ne,
  t2 as t,
  v2,
  w,
  z
} from "./chunk-LBBA3SFR.js";
import "./chunk-2KZBVPWA.js";
import "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  e as e2
} from "./chunk-OEQ3EDRD.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import {
  m as m2,
  m2 as m3
} from "./chunk-CHNDTVQJ.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j,
  p
} from "./chunk-YPZEGNLG.js";
import {
  k2
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  k
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  a
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/arcade/arcadeCompiler.js
function ee(e8, t2, n3) {
  try {
    return n3(e8, null, t2.arguments);
  } catch (r7) {
    throw r7;
  }
}
function te(e8, t2) {
  try {
    switch (t2.type) {
      case "EmptyStatement":
        return "lc.voidOperation";
      case "VariableDeclarator":
        return ge(e8, t2);
      case "VariableDeclaration":
        return he(e8, t2);
      case "BlockStatement":
        return pe(e8, t2);
      case "FunctionDeclaration":
        return me(e8, t2);
      case "ReturnStatement":
        return fe(e8, t2);
      case "IfStatement":
        return ue(e8, t2);
      case "ExpressionStatement":
        return ie(e8, t2);
      case "AssignmentExpression":
        return se2(e8, t2);
      case "UpdateExpression":
        return le(e8, t2);
      case "BreakStatement":
        return "break";
      case "ContinueStatement":
        return "continue";
      case "TemplateLiteral":
        return Ee(e8, t2);
      case "TemplateElement":
        return JSON.stringify(t2.value ? t2.value.cooked : "");
      case "ForStatement":
        return ae(e8, t2);
      case "ForInStatement":
        return oe(e8, t2);
      case "Identifier":
        return Me(e8, t2);
      case "MemberExpression":
        return Se(e8, t2);
      case "Literal":
        return null === t2.value || void 0 === t2.value ? "null" : JSON.stringify(t2.value);
      case "ThisExpression":
      case "ConditionalExpression":
      case "Array":
        throw new Error(b(t2, "RUNTIME", "NOTSUPPORTED"));
      case "CallExpression":
        return Ie(e8, t2);
      case "UnaryExpression":
        return we(e8, t2);
      case "BinaryExpression":
        return ve(e8, t2);
      case "LogicalExpression":
        return Ne2(e8, t2);
      case "ArrayExpression":
        return be(e8, t2);
      case "ObjectExpression":
        return ne2(e8, t2);
      case "Property":
        return re(e8, t2);
      default:
        throw new Error(b(t2, "RUNTIME", "UNREOGNISED"));
    }
  } catch (n3) {
    throw n3;
  }
}
function ne2(e8, t2) {
  let n3 = "lang.dictionary([";
  for (let r7 = 0; r7 < t2.properties.length; r7++) {
    const o4 = t2.properties[r7];
    r7 > 0 && (n3 += ","), n3 += "lang.strCheck(" + ("Identifier" === o4.key.type ? "'" + o4.key.name + "'" : te(e8, o4.key)) + ",'ObjectExpression'),lang.aCheck(" + te(e8, o4.value) + ", 'ObjectExpression')";
  }
  return n3 += "])", n3;
}
function re(e8, t2) {
  throw new Error("Should not get here");
}
function oe(e8, t2) {
  const n3 = Pe(e8), r7 = Pe(e8), o4 = Pe(e8);
  let a4 = "var " + n3 + " = " + te(e8, t2.right) + ";\n";
  "VariableDeclaration" === t2.left.type && (a4 += te(e8, t2.left));
  let l3 = "VariableDeclaration" === t2.left.type ? t2.left.declarations[0].id.name : t2.left.name;
  l3 = l3.toLowerCase();
  let s4 = "";
  return null !== e8.localScope && (void 0 !== e8.localScope[l3] ? s4 = "lscope['" + l3 + "']" : void 0 !== e8.localScope._SymbolsMap[l3] && (s4 = "lscope['" + e8.localScope._SymbolsMap[l3] + "']")), "" === s4 && (void 0 !== e8.globalScope[l3] ? s4 = "gscope['" + l3 + "']" : void 0 !== e8.globalScope._SymbolsMap[l3] && (s4 = "gscope['" + e8.globalScope._SymbolsMap[l3] + "']")), a4 += "if (" + n3 + "===null) {  lastStatement = lc.voidOperation; }\n ", a4 += "else if (lc.isArray(" + n3 + ") || lc.isString(" + n3 + ")) {", a4 += "var " + r7 + "=" + n3 + ".length; \n", a4 += "for(var " + o4 + "=0; " + o4 + "<" + r7 + "; " + o4 + "++) {\n", a4 += s4 + "=" + o4 + ";\n", a4 += te(e8, t2.body), a4 += "\n}\n", a4 += " lastStatement = lc.voidOperation; \n", a4 += " \n}\n", a4 += "else if (lc.isImmutableArray(" + n3 + ")) {", a4 += "var " + r7 + "=" + n3 + ".length(); \n", a4 += "for(var " + o4 + "=0; " + o4 + "<" + r7 + "; " + o4 + "++) {\n", a4 += s4 + "=" + o4 + ";\n", a4 += te(e8, t2.body), a4 += "\n}\n", a4 += " lastStatement = lc.voidOperation; \n", a4 += " \n}\n", a4 += "else if (( " + n3 + " instanceof lang.Dictionary) || ( " + n3 + " instanceof lang.Feature)) {", a4 += "var " + r7 + "=" + n3 + ".keys(); \n", a4 += "for(var " + o4 + "=0; " + o4 + "<" + r7 + ".length; " + o4 + "++) {\n", a4 += s4 + "=" + r7 + "[" + o4 + "];\n", a4 += te(e8, t2.body), a4 += "\n}\n", a4 += " lastStatement = lc.voidOperation; \n", a4 += " \n}\n", e8.isAsync && (a4 += "else if (lc.isFeatureSet(" + n3 + ")) {", a4 += "var " + r7 + "=" + n3 + ".iterator(runtimeCtx.abortSignal); \n", a4 += "for(var " + o4 + "=lang. graphicToFeature( yield " + r7 + ".next()," + n3 + "); " + o4 + "!=null; " + o4 + "=lang. graphicToFeature( yield " + r7 + ".next()," + n3 + ")) {\n", a4 += s4 + "=" + o4 + ";\n", a4 += te(e8, t2.body), a4 += "\n}\n", a4 += " lastStatement = lc.voidOperation; \n", a4 += " \n}\n"), a4 += "else { lastStatement = lc.voidOperation; } \n", a4;
}
function ae(e8, t2) {
  let n3 = "lastStatement = lc.voidOperation; \n";
  null !== t2.init && (n3 += te(e8, t2.init) + "; ");
  const r7 = Pe(e8), o4 = Pe(e8);
  return n3 += "var " + r7 + " = true; ", n3 += "\n do { ", null !== t2.update && (n3 += " if (" + r7 + "===false) {\n " + te(e8, t2.update) + "  \n}\n " + r7 + "=false; \n"), null !== t2.test && (n3 += "var " + o4 + " = " + te(e8, t2.test) + "; ", n3 += "if (" + o4 + "===false) { break; } else if (" + o4 + "!==true) { lang.error({type: '" + t2.type + "'},'RUNTIME','CANNOT_USE_NONBOOLEAN_IN_CONDITION');   }\n"), n3 += te(e8, t2.body), null !== t2.update && (n3 += "\n " + te(e8, t2.update)), n3 += "\n" + r7 + " = true; \n} while(true);  lastStatement = lc.voidOperation; ", n3;
}
function le(e8, t2) {
  let n3 = null, r7 = "";
  if ("MemberExpression" === t2.argument.type)
    return n3 = te(e8, t2.argument.object), r7 = true === t2.argument.computed ? te(e8, t2.argument.property) : "'" + t2.argument.property.name + "'", "lang.memberupdate(" + n3 + "," + r7 + ",'" + t2.operator + "'," + t2.prefix + ")";
  if (n3 = t2.argument.name.toLowerCase(), null !== e8.localScope) {
    if (void 0 !== e8.localScope[n3])
      return "lang.update(lscope, '" + n3 + "','" + t2.operator + "'," + t2.prefix + ")";
    if (void 0 !== e8.localScope._SymbolsMap[n3])
      return "lang.update(lscope, '" + e8.localScope._SymbolsMap[n3] + "','" + t2.operator + "'," + t2.prefix + ")";
  }
  if (void 0 !== e8.globalScope[n3])
    return "lang.update(gscope, '" + n3 + "','" + t2.operator + "'," + t2.prefix + ")";
  if (void 0 !== e8.globalScope._SymbolsMap[n3])
    return "lang.update(gscope, '" + e8.globalScope._SymbolsMap[n3] + "','" + t2.operator + "'," + t2.prefix + ")";
  throw new Error("Variable not recognised");
}
function se2(e8, t2) {
  const n3 = te(e8, t2.right);
  let r7 = null, o4 = "";
  if ("MemberExpression" === t2.left.type)
    return r7 = te(e8, t2.left.object), o4 = true === t2.left.computed ? te(e8, t2.left.property) : "'" + t2.left.property.name + "'", "lang.assignmember(" + r7 + "," + o4 + ",'" + t2.operator + "'," + n3 + ")";
  if (r7 = t2.left.name.toLowerCase(), null !== e8.localScope) {
    if (void 0 !== e8.localScope[r7])
      return "lscope['" + r7 + "']=lang.assign(" + n3 + ",'" + t2.operator + "', lscope['" + r7 + "'])";
    if (void 0 !== e8.localScope._SymbolsMap[r7])
      return "lscope['" + e8.localScope._SymbolsMap[r7] + "']=lang.assign(" + n3 + ",'" + t2.operator + "', lscope['" + e8.localScope._SymbolsMap[r7] + "'])";
  }
  if (void 0 !== e8.globalScope[r7])
    return "gscope['" + r7 + "']=lang.assign(" + n3 + ",'" + t2.operator + "', gscope['" + r7 + "'])";
  if (void 0 !== e8.globalScope._SymbolsMap[r7])
    return "gscope['" + e8.globalScope._SymbolsMap[r7] + "']=lang.assign(" + n3 + ",'" + t2.operator + "', gscope['" + e8.globalScope._SymbolsMap[r7] + "'])";
  throw new Error("Variable not recognised");
}
function ie(e8, t2) {
  return "AssignmentExpression" === t2.expression.type ? "lastStatement = lc.voidOperation; " + te(e8, t2.expression) + "; \n " : (t2.expression.type, "lastStatement = " + te(e8, t2.expression) + "; ");
}
function ce(e8, t2) {
  return "BlockStatement" === t2.type ? te(e8, t2) : "ReturnStatement" === t2.type || "BreakStatement" === t2.type || "ContinueStatement" === t2.type ? te(e8, t2) + "; " : "UpdateExpression" === t2.type ? "lastStatement = " + te(e8, t2) + "; " : "ExpressionStatement" === t2.type ? te(e8, t2) : "ObjectExpression" === t2.type ? "lastStatement = " + te(e8, t2) + "; " : te(e8, t2) + "; ";
}
function ue(e8, t2) {
  if ("AssignmentExpression" === t2.test.type || "UpdateExpression" === t2.test.type)
    throw new Error(b(t2.test, "RUNTIME", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"));
  const n3 = te(e8, t2.test), r7 = Pe(e8);
  let o4 = "var " + r7 + " = " + n3 + ";\n if (" + r7 + " === true) {\n" + ce(e8, t2.consequent) + "\n }\n";
  return null !== t2.alternate ? o4 += "else if (" + r7 + "===false)   { \n" + ce(e8, t2.alternate) + "}\n" : o4 += "else if (" + r7 + "===false) { \n lastStatement = lc.voidOperation;\n }\n", o4 += "else { lang.error({type: '" + t2.type + "'},'RUNTIME','CANNOT_USE_NONBOOLEAN_IN_CONDITION'); \n}\n", o4;
}
function pe(e8, t2) {
  let n3 = "";
  for (let r7 = 0; r7 < t2.body.length; r7++)
    "ReturnStatement" === t2.body[r7].type || "BreakStatement" === t2.body[r7].type || "ContinueStatement" === t2.body[r7].type ? n3 += te(e8, t2.body[r7]) + "; \n" : "UpdateExpression" === t2.body[r7].type || "ObjectExpression" === t2.body[r7].type ? n3 += "lastStatement = " + te(e8, t2.body[r7]) + "; \n" : n3 += te(e8, t2.body[r7]) + " \n";
  return n3;
}
function fe(e8, t2) {
  if (null === t2.argument)
    return "return lc.voidOperation";
  return "return " + te(e8, t2.argument);
}
function me(e8, t2) {
  const n3 = t2.id.name.toLowerCase(), r7 = { isAsync: e8.isAsync, spatialReference: e8.spatialReference, console: e8.console, lrucache: e8.lrucache, interceptor: e8.interceptor, services: e8.services, symbols: e8.symbols, mangleMap: e8.mangleMap, localScope: { _SymbolsMap: {} }, depthCounter: e8.depthCounter + 1, globalScope: e8.globalScope };
  if (r7.depthCounter > 64)
    throw new Error("Exceeded maximum function depth");
  let o4 = "new lc.SizzleFunction( lang.functionDepthchecker(function() { var lastStatement = lc.voidOperation; \n   var lscope = runtimeCtx.localStack[runtimeCtx.localStack.length-1];\n";
  for (let a4 = 0; a4 < t2.params.length; a4++) {
    const n4 = t2.params[a4].name.toLowerCase(), l3 = Fe(e8);
    r7.localScope._SymbolsMap[n4] = l3, r7.mangleMap[n4] = l3, o4 += "lscope['" + l3 + "']=arguments[" + a4.toString() + "];\n";
  }
  if (true === e8.isAsync ? (o4 += "return lang.__awaiter(this, void 0, void 0, function* () {\n", o4 += pe(r7, t2.body) + "\n return lastStatement; ", o4 += "});  }", o4 += ", runtimeCtx)," + t2.params.length + ")", o4 += "\n lastStatement = lc.voidOperation; \n") : (o4 += pe(r7, t2.body) + "\n return lastStatement; }, runtimeCtx)," + t2.params.length + ")", o4 += "\n lastStatement = lc.voidOperation; \n"), void 0 !== e8.globalScope[n3])
    return "gscope['" + n3 + "']=" + o4;
  if (void 0 !== e8.globalScope._SymbolsMap[n3])
    return "gscope['" + e8.globalScope._SymbolsMap[n3] + "']=" + o4;
  {
    const t3 = Fe(e8);
    return e8.globalScope._SymbolsMap[n3] = t3, e8.mangleMap[n3] = t3, "gscope['" + t3 + "']=" + o4;
  }
}
function he(e8, t2) {
  const n3 = [];
  for (let r7 = 0; r7 < t2.declarations.length; r7++)
    n3.push(te(e8, t2.declarations[r7]));
  return n3.join("\n") + " \n lastStatement=  lc.voidOperation; \n";
}
function ge(e8, t2) {
  let n3 = null === t2.init ? null : te(e8, t2.init);
  n3 === j2 && (n3 = null);
  const r7 = t2.id.name.toLowerCase();
  if (null !== e8.localScope) {
    if (void 0 !== e8.localScope[r7])
      return "lscope['" + r7 + "']=" + n3 + "; ";
    if (void 0 !== e8.localScope._SymbolsMap[r7])
      return "lscope['" + e8.localScope._SymbolsMap[r7] + "']=" + n3 + "; ";
    {
      const t3 = Fe(e8);
      return e8.localScope._SymbolsMap[r7] = t3, e8.mangleMap[r7] = t3, "lscope['" + t3 + "']=" + n3 + "; ";
    }
  }
  if (void 0 !== e8.globalScope[r7])
    return "gscope['" + r7 + "']=" + n3 + "; ";
  if (void 0 !== e8.globalScope._SymbolsMap[r7])
    return "gscope['" + e8.globalScope._SymbolsMap[r7] + "']=" + n3 + "; ";
  {
    const t3 = Fe(e8);
    return e8.globalScope._SymbolsMap[r7] = t3, e8.mangleMap[r7] = t3, "gscope['" + t3 + "']=" + n3 + "; ";
  }
}
var ye = 0;
function de(e8, t2, r7) {
  let l3;
  switch (t2 = t2.toLowerCase()) {
    case "hasz": {
      const t3 = e8.hasZ;
      return void 0 !== t3 && t3;
    }
    case "hasm": {
      const t3 = e8.hasM;
      return void 0 !== t3 && t3;
    }
    case "spatialreference": {
      let t3 = e8.spatialReference._arcadeCacheId;
      if (void 0 === t3) {
        let n3 = true;
        Object.freeze && Object.isFrozen(e8.spatialReference) && (n3 = false), n3 && (ye++, e8.spatialReference._arcadeCacheId = ye, t3 = ye);
      }
      const r8 = new d({ wkt: e8.spatialReference.wkt, wkid: e8.spatialReference.wkid });
      return void 0 !== t3 && (r8._arcadeCacheId = "SPREF" + t3.toString()), r8;
    }
  }
  switch (e8.type) {
    case "extent":
      switch (t2) {
        case "xmin":
        case "xmax":
        case "ymin":
        case "ymax":
        case "zmin":
        case "zmax":
        case "mmin":
        case "mmax": {
          const n3 = e8[t2];
          return void 0 !== n3 ? n3 : null;
        }
        case "type":
          return "Extent";
      }
      break;
    case "polygon":
      switch (t2) {
        case "rings":
          l3 = e8.cache._arcadeCacheId, void 0 === l3 && (ye++, l3 = ye, e8.cache._arcadeCacheId = l3);
          return new h(e8.rings, e8.spatialReference, true === e8.hasZ, true === e8.hasM, l3);
        case "type":
          return "Polygon";
      }
      break;
    case "point":
      switch (t2) {
        case "x":
        case "y":
        case "z":
        case "m":
          return void 0 !== e8[t2] ? e8[t2] : null;
        case "type":
          return "Point";
      }
      break;
    case "polyline":
      switch (t2) {
        case "paths":
          l3 = e8.cache._arcadeCacheId, void 0 === l3 && (ye++, l3 = ye, e8.cache._arcadeCacheId = l3);
          return new h(e8.paths, e8.spatialReference, true === e8.hasZ, true === e8.hasM, l3);
        case "type":
          return "Polyline";
      }
      break;
    case "multipoint":
      switch (t2) {
        case "points":
          l3 = e8.cache._arcadeCacheId, void 0 === l3 && (ye++, l3 = ye, e8.cache._arcadeCacheId = l3);
          return new i(e8.points, e8.spatialReference, true === e8.hasZ, true === e8.hasM, l3, 1);
        case "type":
          return "Multipoint";
      }
  }
  throw new Error(b(r7, "RUNTIME", "PROPERTYNOTFOUND"));
}
function Se(e8, t2) {
  try {
    let n3;
    return n3 = true === t2.computed ? te(e8, t2.property) : "'" + t2.property.name + "'", "lang.member(" + te(e8, t2.object) + "," + n3 + ")";
  } catch (n3) {
    throw n3;
  }
}
function we(e8, t2) {
  try {
    return "lang.unary(" + te(e8, t2.argument) + ",'" + t2.operator + "')";
  } catch (n3) {
    throw n3;
  }
}
function be(e8, t2) {
  try {
    const n3 = [];
    for (let r7 = 0; r7 < t2.elements.length; r7++)
      "Literal" === t2.elements[r7].type ? n3.push(te(e8, t2.elements[r7])) : n3.push("lang.aCheck(" + te(e8, t2.elements[r7]) + ",'ArrayExpression')");
    return "[" + n3.join(",") + "]";
  } catch (n3) {
    throw n3;
  }
}
function Ee(e8, t2) {
  try {
    const n3 = [];
    let r7 = 0;
    for (const o4 of t2.quasis)
      n3.push(o4.value ? JSON.stringify(o4.value.cooked) : JSON.stringify("")), false === o4.tail && (n3.push(t2.expressions[r7] ? "lang.castString(lang.aCheck(" + te(e8, t2.expressions[r7]) + ", 'TemplateLiteral'))" : ""), r7++);
    return "([" + n3.join(",") + "]).join('')";
  } catch (n3) {
    throw n3;
  }
}
function ve(e8, t2) {
  try {
    return "lang.binary(" + te(e8, t2.left) + "," + te(e8, t2.right) + ",'" + t2.operator + "')";
  } catch (n3) {
    throw n3;
  }
}
function Ne2(e8, t2) {
  try {
    if ("AssignmentExpression" === t2.left.type || "UpdateExpression" === t2.left.type)
      throw new Error(b(t2.left, "RUNTIME", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"));
    if ("AssignmentExpression" === t2.right.type || "UpdateExpression" === t2.right.type)
      throw new Error(b(t2.right, "RUNTIME", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"));
    if ("&&" === t2.operator || "||" === t2.operator)
      return "(lang.logicalCheck(" + te(e8, t2.left) + ") " + t2.operator + " lang.logicalCheck(" + te(e8, t2.right) + "))";
    throw new Error(b(t2, "RUNTIME", "ONLYORORAND"));
  } catch (n3) {
    throw n3;
  }
}
function Me(e8, t2) {
  try {
    const n3 = t2.name.toLowerCase();
    if (null !== e8.localScope) {
      if (void 0 !== e8.localScope[n3])
        return "lscope['" + n3 + "']";
      if (void 0 !== e8.localScope._SymbolsMap[n3])
        return "lscope['" + e8.localScope._SymbolsMap[n3] + "']";
    }
    if (void 0 !== e8.globalScope[n3])
      return "gscope['" + n3 + "']";
    if (void 0 !== e8.globalScope._SymbolsMap[n3])
      return "gscope['" + e8.globalScope._SymbolsMap[n3] + "']";
    throw new Error(b(t2, "RUNTIME", "VARIABLENOTFOUND"));
  } catch (n3) {
    throw n3;
  }
}
function Ie(e8, t2) {
  try {
    if ("Identifier" !== t2.callee.type)
      throw new Error(b(t2, "RUNTIME", "ONLYNODESSUPPORTED"));
    const n3 = t2.callee.name.toLowerCase();
    let r7 = "";
    if (null !== e8.localScope && (void 0 !== e8.localScope[n3] ? r7 = "lscope['" + n3 + "']" : void 0 !== e8.localScope._SymbolsMap[n3] && (r7 = "lscope['" + e8.localScope._SymbolsMap[n3] + "']")), "" === r7 && (void 0 !== e8.globalScope[n3] ? r7 = "gscope['" + n3 + "']" : void 0 !== e8.globalScope._SymbolsMap[n3] && (r7 = "gscope['" + e8.globalScope._SymbolsMap[n3] + "']")), "" !== r7) {
      let n4 = "[";
      for (let r8 = 0; r8 < t2.arguments.length; r8++)
        r8 > 0 && (n4 += ", "), n4 += te(e8, t2.arguments[r8]);
      return n4 += "]", e8.isAsync ? "(yield lang.callfunc(" + r7 + "," + n4 + ",runtimeCtx) )" : "lang.callfunc(" + r7 + "," + n4 + ",runtimeCtx)";
    }
    throw new Error(b(t2, "RUNTIME", "NOTFOUND"));
  } catch (n3) {
    throw n3;
  }
}
var Oe = {};
function xe(r7) {
  return null === r7 ? "" : L(r7) || E(r7) ? "Array" : z(r7) ? "Date" : w(r7) ? "String" : _(r7) ? "Boolean" : O(r7) ? "Number" : r7 instanceof e ? "Attachment" : r7 instanceof s ? "Portal" : r7 instanceof d ? "Dictionary" : Y(r7) ? "Feature" : r7 instanceof j ? "Point" : r7 instanceof v ? "Polygon" : r7 instanceof m3 ? "Polyline" : r7 instanceof m2 ? "Multipoint" : r7 instanceof M ? "Extent" : v2(r7) ? "Function" : J(r7) ? "FeatureSet" : P(r7) ? "FeatureSetCollection" : r7 === j2 ? "" : "number" == typeof r7 && isNaN(r7) ? "Number" : "Unrecognised Type";
}
function Te(e8, t2, n3, r7) {
  try {
    const o4 = t2[n3];
    if (Q(o4, r7))
      return t2[n3 + 1];
    {
      const o5 = t2.length - n3;
      return 1 === o5 ? t2[n3] : 2 === o5 ? null : 3 === o5 ? t2[n3 + 2] : Te(e8, t2, n3 + 2, r7);
    }
  } catch (o4) {
    throw o4;
  }
}
function _e(e8, t2, n3, r7) {
  try {
    if (true === r7)
      return t2[n3 + 1];
    if (3 === t2.length - n3)
      return t2[n3 + 2];
    {
      const r8 = t2[n3 + 2];
      if (false === _(r8))
        throw new Error("WHEN needs boolean test conditions");
      return _e(e8, t2, n3 + 2, r8);
    }
  } catch (o4) {
    throw o4;
  }
}
function Ce2(e8, t2) {
  const n3 = e8.length, r7 = Math.floor(n3 / 2);
  return 0 === n3 ? [] : 1 === n3 ? [e8[0]] : Re(Ce2(e8.slice(0, r7), t2), Ce2(e8.slice(r7, n3), t2), t2);
}
function Re(e8, t2, n3) {
  const r7 = [];
  for (; e8.length > 0 || t2.length > 0; )
    if (e8.length > 0 && t2.length > 0) {
      let o4 = n3(e8[0], t2[0]);
      isNaN(o4) && (o4 = 0), o4 <= 0 ? (r7.push(e8[0]), e8 = e8.slice(1)) : (r7.push(t2[0]), t2 = t2.slice(1));
    } else
      e8.length > 0 ? (r7.push(e8[0]), e8 = e8.slice(1)) : t2.length > 0 && (r7.push(t2[0]), t2 = t2.slice(1));
  return r7;
}
async function Ae(e8, t2) {
  const n3 = e8.length, r7 = Math.floor(n3 / 2);
  if (0 === n3)
    return [];
  if (1 === n3)
    return [e8[0]];
  const o4 = [Ae(e8.slice(0, r7), t2), Ae(e8.slice(r7, n3), t2)], a4 = await Promise.all(o4);
  return Ue(a4[0], a4[1], t2, []);
}
async function Ue(e8, t2, n3, r7) {
  const o4 = r7;
  if (!(e8.length > 0 || t2.length > 0))
    return r7;
  if (e8.length > 0 && t2.length > 0) {
    let a4 = await n3(e8[0], t2[0]);
    return isNaN(a4) && (a4 = 1), a4 <= 0 ? (o4.push(e8[0]), e8 = e8.slice(1)) : (o4.push(t2[0]), t2 = t2.slice(1)), Ue(e8, t2, n3, r7);
  }
  return e8.length > 0 ? (o4.push(e8[0]), Ue(e8 = e8.slice(1), t2, n3, r7)) : t2.length > 0 ? (o4.push(t2[0]), Ue(e8, t2 = t2.slice(1), n3, r7)) : void 0;
}
function Fe(e8) {
  return e8.symbols.symbolCounter++, "_T" + e8.symbols.symbolCounter.toString();
}
function Pe(e8) {
  return e8.symbols.symbolCounter++, "_Tvar" + e8.symbols.symbolCounter.toString();
}
y(Oe, ee), O2(Oe, ee), N2(Oe, ee), P2(Oe, ee), o(Oe, ee), Oe.typeof = function(e8, t2) {
  return ee(e8, t2, function(e9, t3, n3) {
    G(n3, 1, 1);
    const r7 = xe(n3[0]);
    if ("Unrecognised Type" === r7)
      throw new Error("Unrecognised Type");
    return r7;
  });
}, Oe.iif = function(e8, t2) {
  try {
    return ee(e8, t2, function(e9, t3, n3) {
      if (G(n3, 3, 3), false === _(n3[0]))
        throw new Error("IF Function must have a boolean test condition");
      return n3[0] ? n3[1] : n3[2];
    });
  } catch (n3) {
    throw n3;
  }
}, Oe.decode = function(e8, t2) {
  try {
    return ee(e8, t2, function(t3, n3, r7) {
      if (r7.length < 2)
        throw new Error("Missing Parameters");
      if (2 === r7.length)
        return r7[1];
      {
        if ((r7.length - 1) % 2 == 0)
          throw new Error("Must have a default value result.");
        const t4 = r7[0];
        return Te(e8, r7, 1, t4);
      }
    });
  } catch (n3) {
    throw n3;
  }
}, Oe.when = function(e8, t2) {
  try {
    return ee(e8, t2, function(t3, n3, r7) {
      if (r7.length < 3)
        throw new Error("Missing Parameters");
      if (r7.length % 2 == 0)
        throw new Error("Must have a default value result.");
      const o4 = r7[0];
      if (false === _(o4))
        throw new Error("WHEN needs boolean test conditions");
      return _e(e8, r7, 0, o4);
    });
  } catch (n3) {
    throw n3;
  }
}, Oe.top = function(e8, t2) {
  return ee(e8, t2, function(e9, t3, n3) {
    if (G(n3, 2, 2), L(n3[0]))
      return ne(n3[1]) >= n3[0].length ? n3[0].slice(0) : n3[0].slice(0, ne(n3[1]));
    if (E(n3[0]))
      return ne(n3[1]) >= n3[0].length() ? n3[0].slice(0) : n3[0].slice(0, ne(n3[1]));
    throw new Error("Top cannot accept this parameter type");
  });
}, Oe.first = function(e8, t2) {
  return ee(e8, t2, function(e9, t3, n3) {
    return G(n3, 1, 1), L(n3[0]) ? 0 === n3[0].length ? null : n3[0][0] : E(n3[0]) ? 0 === n3[0].length() ? null : n3[0].get(0) : null;
  });
}, Oe.sort = function(e8, t2) {
  return ee(e8, t2, function(t3, n3, r7) {
    G(r7, 1, 2);
    let o4 = r7[0];
    if (E(o4) && (o4 = o4.toArray()), false === L(o4))
      throw new Error("Illegal Argument");
    if (r7.length > 1) {
      if (false === v2(r7[1]))
        throw new Error("Illegal Argument");
      let n4 = o4;
      const a4 = function(e9, n5) {
        return Xe.callfunc(r7[1], [e9, n5], t3);
      };
      return e8.isAsync ? Ae(n4, a4) : (n4 = Ce2(n4, function(e9, t4) {
        return a4(e9, t4);
      }), n4);
    }
    {
      let e9 = o4;
      if (0 === e9.length)
        return [];
      const t4 = {};
      for (let o5 = 0; o5 < e9.length; o5++) {
        const n5 = xe(e9[o5]);
        "" !== n5 && (t4[n5] = true);
      }
      if (true === t4.Array || true === t4.Dictionary || true === t4.Feature || true === t4.Point || true === t4.Polygon || true === t4.Polyline || true === t4.Multipoint || true === t4.Extent || true === t4.Function)
        return e9.slice(0);
      let n4 = 0, r8 = "";
      for (const o5 in t4)
        n4++, r8 = o5;
      return e9 = n4 > 1 || "String" === r8 ? Ce2(e9, function(e10, t5) {
        if (null == e10 || e10 === j2)
          return null == t5 || t5 === j2 ? 0 : 1;
        if (null == t5 || t5 === j2)
          return -1;
        const n5 = X(e10), r9 = X(t5);
        return n5 < r9 ? -1 : n5 === r9 ? 0 : 1;
      }) : "Number" === r8 ? Ce2(e9, function(e10, t5) {
        return e10 - t5;
      }) : "Boolean" === r8 ? Ce2(e9, function(e10, t5) {
        return e10 === t5 ? 0 : t5 ? -1 : 1;
      }) : "Date" === r8 ? Ce2(e9, function(e10, t5) {
        return t5 - e10;
      }) : e9.slice(0), e9;
    }
  });
};
var ke = {};
for (const tt in Oe)
  ke[tt] = new N(Oe[tt]);
z2(Oe, ee);
for (const tt in Oe)
  Oe[tt] = new N(Oe[tt]);
var je = function() {
};
je.prototype = Oe;
var De = function() {
};
function Le(e8, t2, n3) {
  const r7 = {};
  e8 || (e8 = {}), n3 || (n3 = {}), r7._SymbolsMap = {}, r7.textformatting = 1, r7.infinity = 1, r7.pi = 1;
  for (const o4 in t2)
    r7[o4] = 1;
  for (const o4 in n3)
    r7[o4] = 1;
  for (const o4 in e8)
    r7[o4] = 1;
  return r7;
}
function Be(e8, t2, o4) {
  const a4 = o4 ? new De() : new je();
  e8 || (e8 = {}), t2 || (t2 = {});
  const l3 = new d({ newline: "\n", tab: "	", singlequote: "'", doublequote: '"', forwardslash: "/", backwardslash: "\\" });
  l3.immutable = false, a4._SymbolsMap = { textformatting: 1, infinity: 1, pi: 1 }, a4.textformatting = l3, a4.infinity = Number.POSITIVE_INFINITY, a4.pi = Math.PI;
  for (const n3 in t2)
    a4[n3] = t2[n3], a4._SymbolsMap[n3] = 1;
  for (const n3 in e8)
    a4._SymbolsMap[n3] = 1, e8[n3] && "esri.Graphic" === e8[n3].declaredClass ? a4[n3] = d2.createFromGraphic(e8[n3]) : a4[n3] = e8[n3];
  return a4;
}
De.prototype = ke;
function Ve(e8, t2) {
  const n3 = { mode: t2, compiled: true, functions: {}, signatures: [], standardFunction: ee, standardFunctionAsync: ee, evaluateIdentifier: We };
  for (let r7 = 0; r7 < e8.length; r7++)
    e8[r7].registerFunctions(n3);
  if ("sync" === t2) {
    for (const e9 in n3.functions)
      Oe[e9] = new N(n3.functions[e9]), je.prototype[e9] = Oe[e9];
    for (let e9 = 0; e9 < n3.signatures.length; e9++)
      r(n3.signatures[e9], "sync");
  } else {
    for (const e9 in n3.functions)
      ke[e9] = new N(n3.functions[e9]), De.prototype[e9] = ke[e9];
    for (let e9 = 0; e9 < n3.signatures.length; e9++)
      r(n3.signatures[e9], "async");
  }
}
function We(e8, t2) {
  const n3 = t2.name;
  if ("_SymbolsMap" === n3)
    throw new Error("Illegal");
  if (e8.localStack.length > 0) {
    if ("_t" !== n3.substr(0, 2).toLowerCase() && void 0 !== e8.localStack[e8.localStack.length - 1][n3])
      return e8.localStack[e8.localStack.length - 1][n3];
    const t3 = e8.mangleMap[n3];
    if (void 0 !== t3 && void 0 !== e8.localStack[e8.localStack.length - 1][t3])
      return e8.localStack[e8.localStack.length - 1][t3];
  }
  if ("_t" !== n3.substr(0, 2).toLowerCase() && void 0 !== e8.globalScope[n3])
    return e8.globalScope[n3];
  if (1 === e8.globalScope._SymbolsMap[n3])
    return e8.globalScope[n3];
  const r7 = e8.mangleMap[n3];
  return void 0 !== r7 ? e8.globalScope[r7] : void 0;
}
Ve([m4], "sync"), Ve([m4], "async");
var Ke = 0;
var Xe = { error(e8, t2, n3) {
  throw new Error(b(e8, t2, n3));
}, __awaiter: (e8, t2, n3, r7) => new Promise((n4, o4) => {
  function a4(e9) {
    try {
      s4(r7.next(e9));
    } catch (t3) {
      o4(t3);
    }
  }
  function l3(e9) {
    try {
      s4(r7.throw(e9));
    } catch (t3) {
      o4(t3);
    }
  }
  function s4(e9) {
    e9.done ? n4(e9.value) : e9.value && e9.value.then ? e9.value.then(a4, l3) : (Ke++, Ke % 100 == 0 ? setTimeout(() => {
      Ke = 0, a4(e9.value);
    }, 0) : a4(e9.value));
  }
  s4((r7 = r7.apply(e8, t2 || [])).next());
}), functionDepthchecker: (e8, t2) => function() {
  if (t2.depthCounter++, t2.localStack.push([]), t2.depthCounter > 64)
    throw new Error("Exceeded maximum function depth");
  const n3 = e8.apply(this, arguments);
  return k(n3) ? n3.then((e9) => (t2.depthCounter--, t2.localStack.length = t2.localStack.length - 1, e9)) : (t2.depthCounter--, t2.localStack.length = t2.localStack.length - 1, n3);
}, castString: (e8) => X(e8), aCheck(e8, t2) {
  if (v2(e8))
    throw new Error(b({ type: t2 }, "RUNTIME", "FUNCTIONCONTEXTILLEGAL"));
  return e8 === j2 ? null : e8;
}, Dictionary: d, Feature: d2, dictionary(e8) {
  const t2 = {};
  for (let n3 = 0; n3 < e8.length; n3 += 2) {
    if (v2(e8[n3 + 1]))
      throw new Error("Illegal Argument");
    if (false === w(e8[n3]))
      throw new Error("Illegal Argument");
    e8[n3 + 1] === j2 ? t2[e8[n3].toString()] = null : t2[e8[n3].toString()] = e8[n3 + 1];
  }
  const r7 = new d(t2);
  return r7.immutable = false, r7;
}, strCheck(e8) {
  if (false === w(e8))
    throw new Error("Illegal Argument");
  return e8;
}, unary(e8, t2) {
  if (_(e8)) {
    if ("!" === t2)
      return !e8;
    if ("-" === t2)
      return -1 * ne(e8);
    if ("+" === t2)
      return 1 * ne(e8);
    if ("~" === t2)
      return ~ne(e8);
    throw new Error(b({ type: "UnaryExpression", operator: t2, prefix: null, argument: null }, "RUNTIME", "NOTSUPPORTEDUNARYOPERATOR"));
  }
  if ("-" === t2)
    return -1 * ne(e8);
  if ("+" === t2)
    return 1 * ne(e8);
  if ("~" === t2)
    return ~ne(e8);
  throw new Error(b({ type: "UnaryExpression", operator: t2, prefix: null, argument: null }, "RUNTIME", "NOTSUPPORTEDUNARYOPERATOR"));
}, logicalCheck(e8) {
  if (false === _(e8)) {
    throw new Error(b({ type: "LogicalExpression", operator: null, left: null, right: null }, "RUNTIME", "ONLYORORAND"));
  }
  return e8;
}, logical(e8, t2, n3) {
  if (_(e8) && _(t2))
    switch (n3) {
      case "||":
        return e8 || t2;
      case "&&":
        return e8 && t2;
      default:
        throw new Error(b({ type: "LogicalExpression", operator: null, left: null, right: null }, "RUNTIME", "ONLYORORAND"));
    }
  throw new Error(b({ type: "LogicalExpression", operator: null, left: null, right: null }, "RUNTIME", "ONLYORORAND"));
}, binary(e8, t2, n3) {
  switch (n3) {
    case "|":
    case "<<":
    case ">>":
    case ">>>":
    case "^":
    case "&":
      return Ne(ne(e8), ne(t2), n3);
    case "==":
    case "=":
      return Q(e8, t2);
    case "!=":
      return !Q(e8, t2);
    case "<":
    case ">":
    case "<=":
    case ">=":
      return W(e8, t2, n3);
    case "+":
      return w(e8) || w(t2) ? X(e8) + X(t2) : ne(e8) + ne(t2);
    case "-":
      return ne(e8) - ne(t2);
    case "*":
      return ne(e8) * ne(t2);
    case "/":
      return ne(e8) / ne(t2);
    case "%":
      return ne(e8) % ne(t2);
    default:
      throw new Error(b({ type: "BinaryExpression", operator: n3, left: e8, right: t2 }, "RUNTIME", "OPERATORNOTRECOGNISED"));
  }
}, assign(e8, t2, n3) {
  switch (t2) {
    case "=":
      return e8 === j2 ? null : e8;
    case "/=":
      return ne(n3) / ne(e8);
    case "*=":
      return ne(n3) * ne(e8);
    case "-=":
      return ne(n3) - ne(e8);
    case "+=":
      return w(n3) || w(e8) ? X(n3) + X(e8) : ne(n3) + ne(e8);
    case "%=":
      return ne(n3) % ne(e8);
    default:
      throw new Error(b({ type: "AssignmentExpression", operator: t2, left: null, right: null }, "RUNTIME", "OPERATORNOTRECOGNISED"));
  }
}, update(e8, t2, n3, r7) {
  const o4 = ne(e8[t2]);
  return e8[t2] = "++" === n3 ? o4 + 1 : o4 - 1, false === r7 ? o4 : "++" === n3 ? o4 + 1 : o4 - 1;
}, graphicToFeature: (e8, t2) => null === e8 ? null : d2.createFromGraphicLikeObject(e8.geometry, e8.attributes, t2), memberupdate(e8, t2, r7, o4) {
  let a4;
  if (L(e8)) {
    if (!O(t2))
      throw new Error("Invalid Parameter");
    if (t2 < 0 && (t2 = e8.length + t2), t2 < 0 || t2 >= e8.length)
      throw new Error("Assignment outside of array bounds");
    a4 = ne(e8[t2]), e8[t2] = "++" === r7 ? a4 + 1 : a4 - 1;
  } else if (e8 instanceof d) {
    if (false === w(t2))
      throw new Error("Dictionary accessor must be a string");
    if (true !== e8.hasField(t2))
      throw new Error("Invalid Parameter");
    a4 = ne(e8.field(t2)), e8.setField(t2, "++" === r7 ? a4 + 1 : a4 - 1);
  } else {
    if (!Y(e8))
      throw E(e8) ? new Error("Array is Immutable") : new Error("Invalid Parameter");
    if (false === w(t2))
      throw new Error("Feature accessor must be a string");
    if (true !== e8.hasField(t2))
      throw new Error("Invalid Parameter");
    a4 = ne(e8.field(t2)), e8.setField(t2, "++" === r7 ? a4 + 1 : a4 - 1);
  }
  return false === o4 ? a4 : "++" === r7 ? a4 + 1 : a4 - 1;
}, assignmember(e8, t2, r7, o4) {
  if (L(e8)) {
    if (!O(t2))
      throw new Error("Invalid Parameter");
    if (t2 < 0 && (t2 = e8.length + t2), t2 < 0 || t2 > e8.length)
      throw new Error("Assignment outside of array bounds");
    if (t2 === e8.length) {
      if ("=" !== r7)
        throw new Error("Invalid Parameter");
      e8[t2] = this.assign(o4, r7, e8[t2]);
    } else
      e8[t2] = this.assign(o4, r7, e8[t2]);
  } else if (e8 instanceof d) {
    if (false === w(t2))
      throw new Error("Dictionary accessor must be a string");
    if (true === e8.hasField(t2))
      e8.setField(t2, this.assign(o4, r7, e8.field(t2)));
    else {
      if ("=" !== r7)
        throw new Error("Invalid Parameter");
      e8.setField(t2, this.assign(o4, r7, null));
    }
  } else {
    if (!Y(e8))
      throw E(e8) ? new Error("Array is Immutable") : new Error("Invalid Parameter");
    if (false === w(t2))
      throw new Error("Feature accessor must be a string");
    if (true === e8.hasField(t2))
      e8.setField(t2, this.assign(o4, r7, e8.field(t2)));
    else {
      if ("=" !== r7)
        throw new Error("Invalid Parameter");
      e8.setField(t2, this.assign(o4, r7, null));
    }
  }
}, member(e8, t2) {
  if (null === e8) {
    throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "NOTFOUND"));
  }
  if (e8 instanceof d || Y(e8)) {
    if (w(t2))
      return e8.field(t2);
    throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "INVALIDTYPE"));
  }
  if (e8 instanceof p) {
    if (w(t2))
      return de(e8, t2, "MemberExpression");
    throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "INVALIDTYPE"));
  }
  if (L(e8)) {
    if (O(t2) && isFinite(t2) && Math.floor(t2) === t2) {
      if (t2 < 0 && (t2 = e8.length + t2), t2 >= e8.length || t2 < 0) {
        throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "OUTOFBOUNDS"));
      }
      return e8[t2];
    }
    throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "INVALIDTYPE"));
  }
  if (w(e8)) {
    if (O(t2) && isFinite(t2) && Math.floor(t2) === t2) {
      if (t2 < 0 && (t2 = e8.length + t2), t2 >= e8.length || t2 < 0) {
        throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "OUTOFBOUNDS"));
      }
      return e8[t2];
    }
    throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "INVALIDTYPE"));
  }
  if (E(e8)) {
    if (O(t2) && isFinite(t2) && Math.floor(t2) === t2) {
      if (t2 < 0 && (t2 = e8.length() + t2), t2 >= e8.length() || t2 < 0) {
        throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "OUTOFBOUNDS"));
      }
      return e8.get(t2);
    }
    throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "INVALIDTYPE"));
  }
  throw new Error(b({ type: "MemberExpression", object: null, property: null, computed: null }, "RUNTIME", "INVALIDTYPE"));
}, callfunc(e8, t2, n3) {
  return e8 instanceof N ? e8.fn(n3, { arguments: t2, preparsed: true }) : e8 instanceof M2 ? e8.fn.apply(this, t2) : e8.apply(this, t2);
} };
function Qe(e8) {
  console.log(e8);
}
function $e(e8, t2 = null, n3 = false) {
  null === t2 && (t2 = { vars: {}, customfunctions: {} });
  const r7 = { isAsync: n3, globalScope: Le(t2.vars, n3 ? ke : Oe, t2.customfunctions), localScope: null, mangleMap: {}, console: Qe, lrucache: t2.lrucache, interceptor: t2.interceptor, services: t2.services, symbols: { symbolCounter: 0 } };
  let o4 = te(r7, e8.body[0].body);
  "" === o4 && (o4 = "lc.voidOperation; ");
  let a4 = "";
  a4 = n3 ? "var runtimeCtx=this.prepare(context, true);\n var lc = this.lc;  var lang = this.lang; var gscope=runtimeCtx.globalScope; \nreturn lang.__awaiter(this, void 0, void 0, function* () {\n\n function mainBody() {\n var lastStatement=lc.voidOperation;\n return lang.__awaiter(this, void 0, void 0, function* () {\n" + o4 + "\n return lastStatement; }); } \n return this.postProcess(yield mainBody()); }); " : "var runtimeCtx=this.prepare(context, false);\n var lc = this.lc;  var lang = this.lang; var gscope=runtimeCtx.globalScope; \n function mainBody() {\n var lastStatement=lc.voidOperation;\n " + o4 + "\n return lastStatement; } \n return this.postProcess(mainBody()); ";
  const l3 = { lc: Ce, lang: Xe, mangles: r7.mangleMap, postProcess(e9) {
    if (e9 instanceof D && (e9 = e9.value), e9 instanceof k3 && (e9 = e9.value), e9 === j2 && (e9 = null), e9 === A)
      throw new Error("Cannot return BREAK");
    if (e9 === R)
      throw new Error("Cannot return CONTINUE");
    if (v2(e9))
      throw new Error("Cannot return FUNCTION");
    return e9;
  }, prepare(e9, t3) {
    let n4 = e9.spatialReference;
    null == n4 && (n4 = new k2({ wkid: 102100 }));
    const r8 = Be(e9.vars, e9.customfunctions, t3);
    return { localStack: [], isAsync: t3, mangleMap: this.mangles, spatialReference: n4, globalScope: r8, abortSignal: void 0 === e9.abortSignal || null === e9.abortSignal ? { aborted: false } : e9.abortSignal, localScope: null, services: e9.services, console: e9.console ? e9.console : Qe, lrucache: e9.lrucache, interceptor: e9.interceptor, symbols: { symbolCounter: 0 }, depthCounter: 1 };
  } };
  return new Function("context", "spatialReference", a4).bind(l3);
}
async function et() {
  return Ve([await import("./geomasync-5MKYMKZX.js")], "async"), true;
}

// node_modules/@arcgis/core/arcade/arcadeRuntime.js
function Q2(e8, r7) {
  const t2 = [];
  for (let n3 = 0; n3 < r7.arguments.length; n3++)
    t2.push(ee2(e8, r7.arguments[n3]));
  return t2;
}
function $(e8, r7, t2) {
  try {
    return true === r7.preparsed ? t2(e8, null, r7.arguments) : t2(e8, r7, Q2(e8, r7));
  } catch (n3) {
    throw n3;
  }
}
function ee2(e8, r7) {
  try {
    switch (r7.type) {
      case "EmptyStatement":
        return j2;
      case "VariableDeclarator":
        return me2(e8, r7);
      case "VariableDeclaration":
        return we2(e8, r7);
      case "BlockStatement":
        return fe2(e8, r7);
      case "FunctionDeclaration":
        return he2(e8, r7);
      case "ReturnStatement":
        return pe2(e8, r7);
      case "IfStatement":
        return ue2(e8, r7);
      case "ExpressionStatement":
        return ce2(e8, r7);
      case "AssignmentExpression":
        return le2(e8, r7);
      case "UpdateExpression":
        return ie2(e8, r7);
      case "BreakStatement":
        return A;
      case "ContinueStatement":
        return R;
      case "TemplateElement":
        return Te2(e8, r7);
      case "TemplateLiteral":
        return Re2(e8, r7);
      case "ForStatement":
        return oe2(e8, r7);
      case "ForInStatement":
        return ne3(e8, r7);
      case "Identifier":
        return Oe2(e8, r7);
      case "MemberExpression":
        return ge2(e8, r7);
      case "Literal":
        return r7.value;
      case "CallExpression":
        return Se2(e8, r7);
      case "UnaryExpression":
        return Ne3(e8, r7);
      case "BinaryExpression":
        return Ie2(e8, r7);
      case "LogicalExpression":
        return ve2(e8, r7);
      case "ArrayExpression":
        return ye2(e8, r7);
      case "ObjectExpression":
        return re2(e8, r7);
      case "Property":
        return te2(e8, r7);
      default:
        throw new Error(b(r7, "RUNTIME", "UNREOGNISED"));
    }
  } catch (t2) {
    throw t2;
  }
}
function re2(e8, r7) {
  const n3 = {};
  for (let t2 = 0; t2 < r7.properties.length; t2++) {
    const o5 = ee2(e8, r7.properties[t2]);
    if (v2(o5.value))
      throw new Error("Illegal Argument");
    if (false === w(o5.key))
      throw new Error("Illegal Argument");
    o5.value === j2 ? n3[o5.key.toString()] = null : n3[o5.key.toString()] = o5.value;
  }
  const o4 = new d(n3);
  return o4.immutable = false, o4;
}
function te2(e8, r7) {
  return { key: "Identifier" === r7.key.type ? r7.key.name : ee2(e8, r7.key), value: ee2(e8, r7.value) };
}
function ne3(e8, r7) {
  const n3 = ee2(e8, r7.right);
  "VariableDeclaration" === r7.left.type && ee2(e8, r7.left);
  let o4 = null, a4 = "";
  if ("VariableDeclaration" === r7.left.type) {
    const e9 = r7.left.declarations[0].id;
    "Identifier" === e9.type && (a4 = e9.name);
  } else
    "Identifier" === r7.left.type && (a4 = r7.left.name);
  if (!a4)
    throw new Error(b(r7, "RUNTIME", "INVALIDVARIABLE"));
  if (a4 = a4.toLowerCase(), null !== e8.localScope && void 0 !== e8.localScope[a4] && (o4 = e8.localScope[a4]), null === o4 && void 0 !== e8.globalScope[a4] && (o4 = e8.globalScope[a4]), null === o4)
    throw new Error(b(r7, "RUNTIME", "VARIABLENOTDECLARED"));
  if (L(n3) || w(n3)) {
    const t2 = n3.length;
    for (let n4 = 0; n4 < t2; n4++) {
      o4.value = n4;
      const t3 = ee2(e8, r7.body);
      if (t3 === A)
        break;
      if (t3 instanceof D)
        return t3;
    }
    return j2;
  }
  if (E(n3)) {
    for (let t2 = 0; t2 < n3.length(); t2++) {
      o4.value = t2;
      const n4 = ee2(e8, r7.body);
      if (n4 === A)
        break;
      if (n4 instanceof D)
        return n4;
    }
    return j2;
  }
  if (!(n3 instanceof d || Y(n3)))
    return j2;
  {
    const t2 = n3.keys();
    for (let n4 = 0; n4 < t2.length; n4++) {
      o4.value = t2[n4];
      const a5 = ee2(e8, r7.body);
      if (a5 === A)
        break;
      if (a5 instanceof D)
        return a5;
    }
  }
}
function oe2(e8, r7) {
  null !== r7.init && ee2(e8, r7.init);
  const t2 = { testResult: true, lastAction: j2 };
  do {
    ae2(e8, r7, t2);
  } while (true === t2.testResult);
  return t2.lastAction instanceof D ? t2.lastAction : j2;
}
function ae2(e8, r7, t2) {
  if (null !== r7.test) {
    if (t2.testResult = ee2(e8, r7.test), false === t2.testResult)
      return;
    if (true !== t2.testResult)
      throw new Error(b(r7, "RUNTIME", "CANNOT_USE_NONBOOLEAN_IN_CONDITION"));
  }
  t2.lastAction = ee2(e8, r7.body), t2.lastAction !== A ? t2.lastAction instanceof D ? t2.testResult = false : null !== r7.update && ee2(e8, r7.update) : t2.testResult = false;
}
function ie2(e8, r7) {
  let n3, o4 = null, a4 = "";
  if ("MemberExpression" === r7.argument.type) {
    if (o4 = ee2(e8, r7.argument.object), true === r7.argument.computed ? a4 = ee2(e8, r7.argument.property) : "Identifier" === r7.argument.property.type && (a4 = r7.argument.property.name), L(o4)) {
      if (!O(a4))
        throw new Error("Invalid Parameter");
      if (a4 < 0 && (a4 = o4.length + a4), a4 < 0 || a4 >= o4.length)
        throw new Error("Assignment outside of array bounds");
      n3 = ne(o4[a4]), o4[a4] = "++" === r7.operator ? n3 + 1 : n3 - 1;
    } else if (o4 instanceof d) {
      if (false === w(a4))
        throw new Error("Dictionary accessor must be a string");
      if (true !== o4.hasField(a4))
        throw new Error("Invalid Parameter");
      n3 = ne(o4.field(a4)), o4.setField(a4, "++" === r7.operator ? n3 + 1 : n3 - 1);
    } else {
      if (!Y(o4))
        throw E(o4) ? new Error("Array is Immutable") : new Error("Invalid Parameter");
      if (false === w(a4))
        throw new Error("Feature accessor must be a string");
      if (true !== o4.hasField(a4))
        throw new Error("Invalid Parameter");
      n3 = ne(o4.field(a4)), o4.setField(a4, "++" === r7.operator ? n3 + 1 : n3 - 1);
    }
    return false === r7.prefix ? n3 : "++" === r7.operator ? n3 + 1 : n3 - 1;
  }
  if (o4 = "Identifier" === r7.argument.type ? r7.argument.name.toLowerCase() : "", !o4)
    throw new Error("Invalid identifier");
  if (null !== e8.localScope && void 0 !== e8.localScope[o4])
    return n3 = ne(e8.localScope[o4].value), e8.localScope[o4] = { value: "++" === r7.operator ? n3 + 1 : n3 - 1, valueset: true, node: r7 }, false === r7.prefix ? n3 : "++" === r7.operator ? n3 + 1 : n3 - 1;
  if (void 0 !== e8.globalScope[o4])
    return n3 = ne(e8.globalScope[o4].value), e8.globalScope[o4] = { value: "++" === r7.operator ? n3 + 1 : n3 - 1, valueset: true, node: r7 }, false === r7.prefix ? n3 : "++" === r7.operator ? n3 + 1 : n3 - 1;
  throw new Error("Variable not recognised");
}
function se3(e8, r7, t2, n3) {
  switch (r7) {
    case "=":
      return e8 === j2 ? null : e8;
    case "/=":
      return ne(t2) / ne(e8);
    case "*=":
      return ne(t2) * ne(e8);
    case "-=":
      return ne(t2) - ne(e8);
    case "+=":
      return w(t2) || w(e8) ? X(t2) + X(e8) : ne(t2) + ne(e8);
    case "%=":
      return ne(t2) % ne(e8);
    default:
      throw new Error(b(n3, "RUNTIME", "OPERATORNOTRECOGNISED"));
  }
}
function le2(e8, r7) {
  const n3 = ee2(e8, r7.right);
  let o4 = null, a4 = "";
  if ("MemberExpression" === r7.left.type) {
    if (o4 = ee2(e8, r7.left.object), true === r7.left.computed ? a4 = ee2(e8, r7.left.property) : "Identifier" === r7.left.property.type && (a4 = r7.left.property.name), L(o4)) {
      if (!O(a4))
        throw new Error("Invalid Parameter");
      if (a4 < 0 && (a4 = o4.length + a4), a4 < 0 || a4 > o4.length)
        throw new Error("Assignment outside of array bounds");
      if (a4 === o4.length) {
        if ("=" !== r7.operator)
          throw new Error("Invalid Parameter");
        o4[a4] = se3(n3, r7.operator, o4[a4], r7);
      } else
        o4[a4] = se3(n3, r7.operator, o4[a4], r7);
    } else if (o4 instanceof d) {
      if (false === w(a4))
        throw new Error("Dictionary accessor must be a string");
      if (true === o4.hasField(a4))
        o4.setField(a4, se3(n3, r7.operator, o4.field(a4), r7));
      else {
        if ("=" !== r7.operator)
          throw new Error("Invalid Parameter");
        o4.setField(a4, se3(n3, r7.operator, null, r7));
      }
    } else {
      if (!Y(o4))
        throw E(o4) ? new Error("Array is Immutable") : new Error("Invalid Parameter");
      if (false === w(a4))
        throw new Error("Feature accessor must be a string");
      if (true === o4.hasField(a4))
        o4.setField(a4, se3(n3, r7.operator, o4.field(a4), r7));
      else {
        if ("=" !== r7.operator)
          throw new Error("Invalid Parameter");
        o4.setField(a4, se3(n3, r7.operator, null, r7));
      }
    }
    return j2;
  }
  if (o4 = r7.left.name.toLowerCase(), null !== e8.localScope && void 0 !== e8.localScope[o4])
    return e8.localScope[o4] = { value: se3(n3, r7.operator, e8.localScope[o4].value, r7), valueset: true, node: r7.right }, j2;
  if (void 0 !== e8.globalScope[o4])
    return e8.globalScope[o4] = { value: se3(n3, r7.operator, e8.globalScope[o4].value, r7), valueset: true, node: r7.right }, j2;
  throw new Error("Variable not recognised");
}
function ce2(e8, r7) {
  if ("AssignmentExpression" === r7.expression.type || "UpdateExpression" === r7.expression.type)
    return ee2(e8, r7.expression);
  if ("CallExpression" === r7.expression.type) {
    const t2 = ee2(e8, r7.expression);
    return t2 === j2 ? j2 : new k3(t2);
  }
  {
    const t2 = ee2(e8, r7.expression);
    return t2 === j2 ? j2 : new k3(t2);
  }
}
function ue2(e8, r7) {
  if ("AssignmentExpression" === r7.test.type || "UpdateExpression" === r7.test.type)
    throw new Error(b(r7.test, "RUNTIME", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"));
  const t2 = ee2(e8, r7.test);
  if (true === t2)
    return ee2(e8, r7.consequent);
  if (false === t2)
    return null !== r7.alternate ? ee2(e8, r7.alternate) : j2;
  throw new Error(b(r7, "RUNTIME", "CANNOT_USE_NONBOOLEAN_IN_CONDITION"));
}
function fe2(e8, r7) {
  let t2 = j2;
  for (let n3 = 0; n3 < r7.body.length; n3++)
    if (t2 = ee2(e8, r7.body[n3]), t2 instanceof D || t2 === A || t2 === R)
      return t2;
  return t2;
}
function pe2(e8, r7) {
  if (null === r7.argument)
    return new D(j2);
  const t2 = ee2(e8, r7.argument);
  return new D(t2);
}
function he2(e8, r7) {
  const t2 = r7.id.name.toLowerCase();
  return e8.globalScope[t2] = { valueset: true, node: null, value: new t(r7, e8) }, j2;
}
function we2(e8, r7) {
  for (let t2 = 0; t2 < r7.declarations.length; t2++)
    ee2(e8, r7.declarations[t2]);
  return j2;
}
function me2(e8, r7) {
  let t2 = null === r7.init ? null : ee2(e8, r7.init);
  if (t2 === j2 && (t2 = null), "Identifier" !== r7.id.type)
    throw new Error("Can only assign a regular variable");
  const n3 = r7.id.name.toLowerCase();
  return null !== e8.localScope ? e8.localScope[n3] = { value: t2, valueset: true, node: r7.init } : e8.globalScope[n3] = { value: t2, valueset: true, node: r7.init }, j2;
}
var Ee2 = 0;
function de2(e8, r7, n3) {
  let o4;
  switch (r7 = r7.toLowerCase()) {
    case "hasz": {
      const r8 = e8.hasZ;
      return void 0 !== r8 && r8;
    }
    case "hasm": {
      const r8 = e8.hasM;
      return void 0 !== r8 && r8;
    }
    case "spatialreference": {
      let r8 = e8.spatialReference._arcadeCacheId;
      if (void 0 === r8) {
        let t2 = true;
        Object.freeze && Object.isFrozen(e8.spatialReference) && (t2 = false), t2 && (Ee2++, e8.spatialReference._arcadeCacheId = Ee2, r8 = Ee2);
      }
      const n4 = new d({ wkt: e8.spatialReference.wkt, wkid: e8.spatialReference.wkid });
      return void 0 !== r8 && (n4._arcadeCacheId = "SPREF" + r8.toString()), n4;
    }
  }
  switch (e8.type) {
    case "extent":
      switch (r7) {
        case "xmin":
        case "xmax":
        case "ymin":
        case "ymax":
        case "zmin":
        case "zmax":
        case "mmin":
        case "mmax": {
          const t2 = e8[r7];
          return void 0 !== t2 ? t2 : null;
        }
        case "type":
          return "Extent";
      }
      break;
    case "polygon":
      switch (r7) {
        case "rings":
          o4 = e8.cache._arcadeCacheId, void 0 === o4 && (Ee2++, o4 = Ee2, e8.cache._arcadeCacheId = o4);
          return new h(e8.rings, e8.spatialReference, true === e8.hasZ, true === e8.hasM, o4);
        case "type":
          return "Polygon";
      }
      break;
    case "point":
      switch (r7) {
        case "x":
        case "y":
        case "z":
        case "m":
          return void 0 !== e8[r7] ? e8[r7] : null;
        case "type":
          return "Point";
      }
      break;
    case "polyline":
      switch (r7) {
        case "paths":
          o4 = e8.cache._arcadeCacheId, void 0 === o4 && (Ee2++, o4 = Ee2, e8.cache._arcadeCacheId = o4);
          return new h(e8.paths, e8.spatialReference, true === e8.hasZ, true === e8.hasM, o4);
        case "type":
          return "Polyline";
      }
      break;
    case "multipoint":
      switch (r7) {
        case "points":
          o4 = e8.cache._arcadeCacheId, void 0 === o4 && (Ee2++, o4 = Ee2, e8.cache._arcadeCacheId = o4);
          return new i(e8.points, e8.spatialReference, true === e8.hasZ, true === e8.hasM, o4, 1);
        case "type":
          return "Multipoint";
      }
  }
  throw new Error(b(n3, "RUNTIME", "PROPERTYNOTFOUND"));
}
function ge2(e8, r7) {
  try {
    const n3 = ee2(e8, r7.object);
    if (null === n3)
      throw new Error(b(r7, "RUNTIME", "NOTFOUND"));
    if (false === r7.computed) {
      if ("Identifier" === r7.property.type) {
        if (n3 instanceof d || Y(n3))
          return n3.field(r7.property.name);
        if (n3 instanceof p)
          return de2(n3, r7.property.name, r7);
      }
      throw new Error(b(r7, "RUNTIME", "INVALIDTYPE"));
    }
    {
      let o4 = ee2(e8, r7.property);
      if (n3 instanceof d || Y(n3)) {
        if (w(o4))
          return n3.field(o4);
        throw new Error(b(r7, "RUNTIME", "INVALIDTYPE"));
      }
      if (n3 instanceof p) {
        if (w(o4))
          return de2(n3, o4, r7);
        throw new Error(b(r7, "RUNTIME", "INVALIDTYPE"));
      }
      if (L(n3)) {
        if (O(o4) && isFinite(o4) && Math.floor(o4) === o4) {
          if (o4 < 0 && (o4 = n3.length + o4), o4 >= n3.length || o4 < 0)
            throw new Error(b(r7, "RUNTIME", "OUTOFBOUNDS"));
          return n3[o4];
        }
        throw new Error(b(r7, "RUNTIME", "INVALIDTYPE"));
      }
      if (w(n3)) {
        if (O(o4) && isFinite(o4) && Math.floor(o4) === o4) {
          if (o4 < 0 && (o4 = n3.length + o4), o4 >= n3.length || o4 < 0)
            throw new Error(b(r7, "RUNTIME", "OUTOFBOUNDS"));
          return n3[o4];
        }
        throw new Error(b(r7, "RUNTIME", "INVALIDTYPE"));
      }
      if (E(n3)) {
        if (O(o4) && isFinite(o4) && Math.floor(o4) === o4) {
          if (o4 < 0 && (o4 = n3.length() + o4), o4 >= n3.length() || o4 < 0)
            throw new Error(b(r7, "RUNTIME", "OUTOFBOUNDS"));
          return n3.get(o4);
        }
        throw new Error(b(r7, "RUNTIME", "INVALIDTYPE"));
      }
      throw new Error(b(r7, "RUNTIME", "INVALIDTYPE"));
    }
  } catch (n3) {
    throw n3;
  }
}
function Ne3(e8, r7) {
  try {
    const t2 = ee2(e8, r7.argument);
    if (_(t2)) {
      if ("!" === r7.operator)
        return !t2;
      if ("-" === r7.operator)
        return -1 * ne(t2);
      if ("+" === r7.operator)
        return 1 * ne(t2);
      if ("~" === r7.operator)
        return ~ne(t2);
      throw new Error(b(r7, "RUNTIME", "NOTSUPPORTEDUNARYOPERATOR"));
    }
    if ("~" === r7.operator)
      return ~ne(t2);
    if ("-" === r7.operator)
      return -1 * ne(t2);
    if ("+" === r7.operator)
      return 1 * ne(t2);
    throw new Error(b(r7, "RUNTIME", "NOTSUPPORTEDUNARYOPERATOR"));
  } catch (t2) {
    throw t2;
  }
}
function ye2(e8, r7) {
  try {
    const t2 = [];
    for (let n3 = 0; n3 < r7.elements.length; n3++) {
      const o4 = ee2(e8, r7.elements[n3]);
      if (v2(o4))
        throw new Error(b(r7, "RUNTIME", "FUNCTIONCONTEXTILLEGAL"));
      o4 === j2 ? t2.push(null) : t2.push(o4);
    }
    return t2;
  } catch (t2) {
    throw t2;
  }
}
function Ie2(e8, r7) {
  try {
    const t2 = [ee2(e8, r7.left), ee2(e8, r7.right)], n3 = t2[0], o4 = t2[1];
    switch (r7.operator) {
      case "|":
      case "<<":
      case ">>":
      case ">>>":
      case "^":
      case "&":
        return Ne(ne(n3), ne(o4), r7.operator);
      case "==":
        return Q(n3, o4);
      case "!=":
        return !Q(n3, o4);
      case "<":
      case ">":
      case "<=":
      case ">=":
        return W(n3, o4, r7.operator);
      case "+":
        return w(n3) || w(o4) ? X(n3) + X(o4) : ne(n3) + ne(o4);
      case "-":
        return ne(n3) - ne(o4);
      case "*":
        return ne(n3) * ne(o4);
      case "/":
        return ne(n3) / ne(o4);
      case "%":
        return ne(n3) % ne(o4);
      default:
        throw new Error(b(r7, "RUNTIME", "OPERATORNOTRECOGNISED"));
    }
  } catch (t2) {
    throw t2;
  }
}
function ve2(e8, r7) {
  try {
    if ("AssignmentExpression" === r7.left.type || "UpdateExpression" === r7.left.type)
      throw new Error(b(r7.left, "RUNTIME", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"));
    if ("AssignmentExpression" === r7.right.type || "UpdateExpression" === r7.right.type)
      throw new Error(b(r7.right, "RUNTIME", "CANNOT_USE_ASSIGNMENT_IN_CONDITION"));
    const t2 = ee2(e8, r7.left);
    if (_(t2))
      switch (r7.operator) {
        case "||":
          if (true === t2)
            return t2;
          {
            const t3 = ee2(e8, r7.right);
            if (_(t3))
              return t3;
            throw new Error(b(r7, "RUNTIME", "ONLYORORAND"));
          }
        case "&&":
          if (false === t2)
            return t2;
          {
            const t3 = ee2(e8, r7.right);
            if (_(t3))
              return t3;
            throw new Error(b(r7, "RUNTIME", "ONLYORORAND"));
          }
        default:
          throw new Error(b(r7, "RUNTIME", "ONLYORORAND"));
      }
    throw new Error(b(r7, "RUNTIME", "ONLYBOOLEAN"));
  } catch (t2) {
    throw t2;
  }
}
function Te2(e8, r7) {
  return r7.value ? r7.value.cooked : "";
}
function Re2(e8, r7) {
  let t2 = "", n3 = 0;
  for (const o4 of r7.quasis)
    if (t2 += o4.value ? o4.value.cooked : "", false === o4.tail) {
      t2 += r7.expressions[n3] ? X(ee2(e8, r7.expressions[n3])) : "", n3++;
    }
  return t2;
}
function Oe2(e8, r7) {
  let t2;
  try {
    const n3 = r7.name.toLowerCase();
    if (null !== e8.localScope && void 0 !== e8.localScope[n3])
      return t2 = e8.localScope[n3], true === t2.valueset || (t2.value = ee2(e8, t2.node), t2.valueset = true), t2.value;
    if (void 0 !== e8.globalScope[n3])
      return t2 = e8.globalScope[n3], true === t2.valueset || (t2.value = ee2(e8, t2.node), t2.valueset = true), t2.value;
    throw new Error(b(r7, "RUNTIME", "VARIABLENOTFOUND"));
  } catch (n3) {
    throw n3;
  }
}
function Se2(e8, r7) {
  try {
    if ("Identifier" !== r7.callee.type)
      throw new Error(b(r7, "RUNTIME", "ONLYNODESSUPPORTED"));
    if (null !== e8.localScope && void 0 !== e8.localScope[r7.callee.name.toLowerCase()]) {
      const t2 = e8.localScope[r7.callee.name.toLowerCase()];
      if (t2.value instanceof N)
        return t2.value.fn(e8, r7);
      if (t2.value instanceof t)
        return Pe2(e8, r7, t2.value.definition);
      throw new Error(b(r7, "RUNTIME", "NOTAFUNCTION"));
    }
    if (void 0 !== e8.globalScope[r7.callee.name.toLowerCase()]) {
      const t2 = e8.globalScope[r7.callee.name.toLowerCase()];
      if (t2.value instanceof N)
        return t2.value.fn(e8, r7);
      if (t2.value instanceof t)
        return Pe2(e8, r7, t2.value.definition);
      throw new Error(b(r7, "RUNTIME", "NOTAFUNCTION"));
    }
    throw new Error(b(r7, "RUNTIME", "NOTFOUND"));
  } catch (t2) {
    throw t2;
  }
}
var be2 = {};
function Ae2(n3) {
  return null == n3 ? "" : L(n3) || E(n3) ? "Array" : z(n3) ? "Date" : w(n3) ? "String" : _(n3) ? "Boolean" : O(n3) ? "Number" : n3 instanceof e ? "Attachment" : n3 instanceof s ? "Portal" : n3 instanceof d ? "Dictionary" : Y(n3) ? "Feature" : n3 instanceof j ? "Point" : n3 instanceof v ? "Polygon" : n3 instanceof m3 ? "Polyline" : n3 instanceof m2 ? "Multipoint" : n3 instanceof M ? "Extent" : v2(n3) ? "Function" : J(n3) ? "FeatureSet" : P(n3) ? "FeatureSetCollection" : n3 === j2 ? "" : "number" == typeof n3 && isNaN(n3) ? "Number" : "Unrecognised Type";
}
function Ue2(e8, r7, t2, n3) {
  try {
    const o4 = ee2(e8, r7.arguments[t2]);
    if (Q(o4, n3))
      return ee2(e8, r7.arguments[t2 + 1]);
    {
      const o5 = r7.arguments.length - t2;
      return 1 === o5 ? ee2(e8, r7.arguments[t2]) : 2 === o5 ? null : 3 === o5 ? ee2(e8, r7.arguments[t2 + 2]) : Ue2(e8, r7, t2 + 2, n3);
    }
  } catch (o4) {
    throw o4;
  }
}
function Ce3(e8, r7, t2, n3) {
  try {
    if (true === n3)
      return ee2(e8, r7.arguments[t2 + 1]);
    if (3 === r7.arguments.length - t2)
      return ee2(e8, r7.arguments[t2 + 2]);
    {
      const n4 = ee2(e8, r7.arguments[t2 + 2]);
      if (false === _(n4))
        throw new Error("WHEN needs boolean test conditions");
      return Ce3(e8, r7, t2 + 2, n4);
    }
  } catch (o4) {
    throw o4;
  }
}
function xe2(e8, r7) {
  const t2 = e8.length, n3 = Math.floor(t2 / 2);
  return 0 === t2 ? [] : 1 === t2 ? [e8[0]] : Me2(xe2(e8.slice(0, n3), r7), xe2(e8.slice(n3, t2), r7), r7);
}
function Me2(e8, r7, t2) {
  const n3 = [];
  for (; e8.length > 0 || r7.length > 0; )
    if (e8.length > 0 && r7.length > 0) {
      let o4 = t2(e8[0], r7[0]);
      isNaN(o4) && (o4 = 0), o4 <= 0 ? (n3.push(e8[0]), e8 = e8.slice(1)) : (n3.push(r7[0]), r7 = r7.slice(1));
    } else
      e8.length > 0 ? (n3.push(e8[0]), e8 = e8.slice(1)) : r7.length > 0 && (n3.push(r7[0]), r7 = r7.slice(1));
  return n3;
}
function Fe2(e8, r7, t2) {
  try {
    const n3 = e8.body;
    if (t2.length !== e8.params.length)
      throw new Error("Invalid Parameter calls to function.");
    for (let a4 = 0; a4 < t2.length; a4++)
      r7.localScope[e8.params[a4].name.toLowerCase()] = { value: t2[a4], valueset: true, node: null };
    const o4 = ee2(r7, n3);
    if (o4 instanceof D)
      return o4.value;
    if (o4 === A)
      throw new Error("Cannot Break from a Function");
    if (o4 === R)
      throw new Error("Cannot Continue from a Function");
    return o4 instanceof k3 ? o4.value : o4;
  } catch (n3) {
    throw n3;
  }
}
function Pe2(e8, r7, t2) {
  return $(e8, r7, function(r8, n3, o4) {
    const a4 = { spatialReference: e8.spatialReference, globalScope: e8.globalScope, depthCounter: e8.depthCounter + 1, console: e8.console, lrucache: e8.lrucache, interceptor: e8.interceptor, localScope: {} };
    if (a4.depthCounter > 64)
      throw new Error("Exceeded maximum function depth");
    return Fe2(t2, a4, o4);
  });
}
function De2(e8) {
  const r7 = function() {
    const r8 = { spatialReference: e8.context.spatialReference, console: e8.context.console, lrucache: e8.context.lrucache, interceptor: e8.context.interceptor, localScope: {}, depthCounter: e8.context.depthCounter + 1, globalScope: e8.context.globalScope };
    if (r8.depthCounter > 64)
      throw new Error("Exceeded maximum function depth");
    return Fe2(e8.definition, r8, arguments);
  };
  return r7;
}
y(be2, $), O2(be2, $), N2(be2, $), P2(be2, $), o(be2, $), z2(be2, $), be2.typeof = function(e8, r7) {
  return $(e8, r7, function(e9, r8, t2) {
    G(t2, 1, 1);
    const n3 = Ae2(t2[0]);
    if ("Unrecognised Type" === n3)
      throw new Error("Unrecognised Type");
    return n3;
  });
}, be2.iif = function(e8, r7) {
  try {
    G(null === r7.arguments ? [] : r7.arguments, 3, 3);
    const t2 = ee2(e8, r7.arguments[0]);
    if (false === _(t2))
      throw new Error("IF Function must have a boolean test condition");
    const n3 = ee2(e8, r7.arguments[1]), o4 = ee2(e8, r7.arguments[2]);
    return true === t2 ? n3 : o4;
  } catch (t2) {
    throw t2;
  }
}, be2.decode = function(e8, r7) {
  try {
    if (r7.arguments.length < 2)
      throw new Error("Missing Parameters");
    if (2 === r7.arguments.length)
      return ee2(e8, r7.arguments[1]);
    {
      if ((r7.arguments.length - 1) % 2 == 0)
        throw new Error("Must have a default value result.");
      const t2 = ee2(e8, r7.arguments[0]);
      return Ue2(e8, r7, 1, t2);
    }
  } catch (t2) {
    throw t2;
  }
}, be2.when = function(e8, r7) {
  try {
    if (r7.arguments.length < 3)
      throw new Error("Missing Parameters");
    if (r7.arguments.length % 2 == 0)
      throw new Error("Must have a default value result.");
    const t2 = ee2(e8, r7.arguments[0]);
    if (false === _(t2))
      throw new Error("WHEN needs boolean test conditions");
    return Ce3(e8, r7, 0, t2);
  } catch (t2) {
    throw t2;
  }
}, be2.top = function(e8, r7) {
  return $(e8, r7, function(e9, r8, t2) {
    if (G(t2, 2, 2), L(t2[0]))
      return ne(t2[1]) >= t2[0].length ? t2[0].slice(0) : t2[0].slice(0, ne(t2[1]));
    if (E(t2[0]))
      return ne(t2[1]) >= t2[0].length() ? t2[0].slice(0) : t2[0].slice(0, ne(t2[1]));
    throw new Error("Top cannot accept this parameter type");
  });
}, be2.first = function(e8, r7) {
  return $(e8, r7, function(e9, r8, t2) {
    return G(t2, 1, 1), L(t2[0]) ? 0 === t2[0].length ? null : t2[0][0] : E(t2[0]) ? 0 === t2[0].length() ? null : t2[0].get(0) : null;
  });
}, be2.sort = function(e8, r7) {
  return $(e8, r7, function(e9, r8, t2) {
    G(t2, 1, 2);
    let n3 = t2[0];
    if (E(n3) && (n3 = n3.toArray()), false === L(n3))
      throw new Error("Illegal Argument");
    if (t2.length > 1) {
      if (false === v2(t2[1]))
        throw new Error("Illegal Argument");
      let e10 = n3;
      const r9 = De2(t2[1]);
      return e10 = xe2(e10, function(e11, t3) {
        return r9(e11, t3);
      }), e10;
    }
    {
      let e10 = n3;
      if (0 === e10.length)
        return [];
      const r9 = {};
      for (let n4 = 0; n4 < e10.length; n4++) {
        const t4 = Ae2(e10[n4]);
        "" !== t4 && (r9[t4] = true);
      }
      if (true === r9.Array || true === r9.Dictionary || true === r9.Feature || true === r9.Point || true === r9.Polygon || true === r9.Polyline || true === r9.Multipoint || true === r9.Extent || true === r9.Function)
        return e10.slice(0);
      let t3 = 0, o4 = "";
      for (const n4 in r9)
        t3++, o4 = n4;
      return e10 = t3 > 1 || "String" === o4 ? xe2(e10, function(e11, r10) {
        if (null == e11 || e11 === j2)
          return null == r10 || r10 === j2 ? 0 : 1;
        if (null == r10 || r10 === j2)
          return -1;
        const t4 = X(e11), n4 = X(r10);
        return t4 < n4 ? -1 : t4 === n4 ? 0 : 1;
      }) : "Number" === o4 ? xe2(e10, function(e11, r10) {
        return e11 - r10;
      }) : "Boolean" === o4 ? xe2(e10, function(e11, r10) {
        return e11 === r10 ? 0 : r10 ? -1 : 1;
      }) : "Date" === o4 ? xe2(e10, function(e11, r10) {
        return r10 - e11;
      }) : e10.slice(0), e10;
    }
  });
};
for (const We2 in be2)
  be2[We2] = { value: new N(be2[We2]), valueset: true, node: null };
var Le2 = function() {
};
function je2(e8, r7) {
  const o4 = new Le2();
  e8 || (e8 = {}), r7 || (r7 = {});
  const a4 = new d({ newline: "\n", tab: "	", singlequote: "'", doublequote: '"', forwardslash: "/", backwardslash: "\\" });
  a4.immutable = false, o4.textformatting = { value: a4, valueset: true, node: null };
  for (const t2 in r7)
    o4[t2] = { value: new N(r7[t2]), native: true, valueset: true, node: null };
  for (const t2 in e8)
    e8[t2] && "esri.Graphic" === e8[t2].declaredClass ? o4[t2] = { value: d2.createFromGraphic(e8[t2]), valueset: true, node: null } : o4[t2] = { value: e8[t2], valueset: true, node: null };
  return o4;
}
Le2.prototype = be2, Le2.prototype.infinity = { value: Number.POSITIVE_INFINITY, valueset: true, node: null }, Le2.prototype.pi = { value: Math.PI, valueset: true, node: null };
function ke2(e8) {
  console.log(e8);
}
function Ve2(e8) {
  const r7 = { mode: "sync", compiled: false, functions: {}, signatures: [], standardFunction: $, evaluateIdentifier: Oe2, arcadeCustomFunctionHandler: De2 };
  for (let t2 = 0; t2 < e8.length; t2++)
    e8[t2].registerFunctions(r7);
  for (const t2 in r7.functions)
    be2[t2] = { value: new N(r7.functions[t2]), valueset: true, node: null }, Le2.prototype[t2] = be2[t2];
  for (let t2 = 0; t2 < r7.signatures.length; t2++)
    r(r7.signatures[t2], "async");
}
function Be2(e8, r7) {
  let t2 = r7.spatialReference;
  null == t2 && (t2 = new k2({ wkid: 102100 }));
  let n3 = ee2({ spatialReference: t2, globalScope: je2(r7.vars, r7.customfunctions), localScope: null, console: r7.console ? r7.console : ke2, lrucache: r7.lrucache, interceptor: r7.interceptor, depthCounter: 1 }, e8.body[0].body);
  if (n3 instanceof D && (n3 = n3.value), n3 instanceof k3 && (n3 = n3.value), n3 === j2 && (n3 = null), n3 === A)
    throw new Error("Cannot return BREAK");
  if (n3 === R)
    throw new Error("Cannot return CONTINUE");
  if (n3 instanceof t)
    throw new Error("Cannot return FUNCTION");
  if (n3 instanceof N)
    throw new Error("Cannot return FUNCTION");
  return n3;
}
function qe(e8, r7) {
  return p2(e8, r7);
}
function Ze(e8, r7) {
  return u(e8, r7);
}
Ve2([m4]);

// node_modules/@arcgis/core/arcade/lib/syntax.js
var e3 = { AssignmentExpression: "AssignmentExpression", ArrayExpression: "ArrayExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", ContinueStatement: "ContinueStatement", EmptyStatement: "EmptyStatement", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForInStatement: "ForInStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", Identifier: "Identifier", IfStatement: "IfStatement", Literal: "Literal", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", ObjectExpression: "ObjectExpression", Program: "Program", Property: "Property", ReturnStatement: "ReturnStatement", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator" };

// node_modules/@arcgis/core/arcade/lib/comment-handler.js
var e4 = class {
  constructor() {
    this.attach = false, this.comments = [], this.stack = [], this.leading = [], this.trailing = [];
  }
  insertInnerComments(e8, n3) {
    if (e8.type === e3.BlockStatement && 0 === e8.body.length) {
      const t2 = [];
      for (let e9 = this.leading.length - 1; e9 >= 0; --e9) {
        const s4 = this.leading[e9];
        n3.end.offset >= s4.start && (t2.unshift(s4.comment), this.leading.splice(e9, 1), this.trailing.splice(e9, 1));
      }
      t2.length && (e8.innerComments = t2);
    }
  }
  findTrailingComments(t2) {
    let e8 = [];
    if (this.trailing.length > 0) {
      for (let n4 = this.trailing.length - 1; n4 >= 0; --n4) {
        const s4 = this.trailing[n4];
        s4.start >= t2.end.offset && e8.unshift(s4.comment);
      }
      return this.trailing.length = 0, e8;
    }
    const n3 = this.stack[this.stack.length - 1];
    if (n3 && n3.node.trailingComments) {
      const s4 = n3.node.trailingComments[0];
      s4 && s4.range[0] >= t2.end.offset && (e8 = n3.node.trailingComments, delete n3.node.trailingComments);
    }
    return e8;
  }
  findLeadingComments(t2) {
    const e8 = [];
    let n3;
    for (; this.stack.length > 0; ) {
      const e9 = this.stack[this.stack.length - 1];
      if (!(e9 && e9.start >= t2.start.offset))
        break;
      n3 = e9.node, this.stack.pop();
    }
    if (n3) {
      for (let s4 = (n3.leadingComments ? n3.leadingComments.length : 0) - 1; s4 >= 0; --s4) {
        const i3 = n3.leadingComments[s4];
        i3.range[1] <= t2.start.offset && (e8.unshift(i3), n3.leadingComments.splice(s4, 1));
      }
      return n3.leadingComments && 0 === n3.leadingComments.length && delete n3.leadingComments, e8;
    }
    for (let s4 = this.leading.length - 1; s4 >= 0; --s4) {
      const n4 = this.leading[s4];
      n4.start <= t2.start.offset && (e8.unshift(n4.comment), this.leading.splice(s4, 1));
    }
    return e8;
  }
  visitNode(e8, n3) {
    if (e8.type === e3.Program && e8.body.length > 0)
      return;
    this.insertInnerComments(e8, n3);
    const s4 = this.findTrailingComments(n3), i3 = this.findLeadingComments(n3);
    i3.length > 0 && (e8.leadingComments = i3), s4.length > 0 && (e8.trailingComments = s4), this.stack.push({ node: e8, start: n3.start.offset });
  }
  visitComment(t2, e8) {
    if (this.comments.push(t2), this.attach) {
      const n3 = { comment: { type: t2.type, value: t2.value, range: [e8.start.offset, e8.end.offset] }, start: e8.start.offset };
      t2.loc && (n3.comment.loc = t2.loc), this.leading.push(n3), this.trailing.push(n3);
    }
  }
  visit(t2, e8) {
    "Line" === t2.type || "Block" === t2.type ? this.visitComment(t2, e8) : this.attach && this.visitNode(t2, e8);
  }
};

// node_modules/@arcgis/core/arcade/lib/assert.js
function r2(r7, o4) {
  if (!r7)
    throw new Error("ASSERT: " + o4);
}

// node_modules/@arcgis/core/arcade/lib/error-handler.js
var r3 = class {
  constructor() {
    this.errors = [], this.tolerant = false;
  }
  recordError(r7) {
    this.errors.push(r7);
  }
  tolerate(r7) {
    if (!this.tolerant)
      throw r7;
    this.recordError(r7);
  }
  constructError(r7, t2) {
    let e8 = new Error(r7);
    try {
      throw e8;
    } catch (o4) {
      Object.create && Object.defineProperty && (e8 = Object.create(o4), Object.defineProperty(e8, "column", { value: t2 }));
    }
    return e8;
  }
  createError(r7, t2, e8, o4) {
    const c2 = "Line " + t2 + ": " + o4, s4 = this.constructError(c2, e8);
    return s4.index = r7, s4.lineNumber = t2, s4.description = o4, s4;
  }
  throwError(r7, t2, e8, o4) {
    throw this.createError(r7, t2, e8, o4);
  }
  tolerateError(r7, t2, e8, o4) {
    const c2 = this.createError(r7, t2, e8, o4);
    if (!this.tolerant)
      throw c2;
    this.recordError(c2);
  }
};

// node_modules/@arcgis/core/arcade/lib/messages.js
var e5 = { ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer", GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts", IllegalBreak: "Illegal break statement", IllegalContinue: "Illegal continue statement", IllegalExportDeclaration: "Unexpected token", IllegalImportDeclaration: "Unexpected token", IllegalReturn: "Illegal return statement", InvalidEscapedReservedWord: "Keyword must not contain escaped characters", InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence", InvalidLHSInAssignment: "Invalid left-hand side in assignment", InvalidLHSInForIn: "Invalid left-hand side in for-in", InvalidRegExp: "Invalid regular expression", Redeclaration: "%0 '%1' has already been declared", StaticPrototype: "Classes may not have static property named prototype", StrictParamDupe: "Strict mode function may not have duplicate parameter names", TemplateOctalLiteral: "Octal literals are not allowed in template strings.", UnexpectedEOS: "Unexpected end of input", UnexpectedIdentifier: "Unexpected identifier", UnexpectedNumber: "Unexpected number", UnexpectedString: "Unexpected string", UnexpectedTemplate: "Unexpected quasi %0", UnexpectedToken: "Unexpected token %0", UnexpectedTokenIllegal: "Unexpected token ILLEGAL", UnterminatedRegExp: "Invalid regular expression: missing /", IdentiferExpected: "Identifier expected" };

// node_modules/@arcgis/core/arcade/lib/nodes.js
var s2 = class {
};
var e6 = class extends s2 {
  constructor(t2, s4) {
    super(), this.type = t2, this.value = s4;
  }
};
var r4 = class extends s2 {
  constructor(s4) {
    super(), this.elements = s4, this.type = e3.ArrayExpression;
  }
};
var i2 = ["=", "/=", "*=", "%=", "+=", "-="];
var n = class extends s2 {
  constructor(s4, e8, r7) {
    super(), this.operator = s4, this.left = e8, this.right = r7, this.type = e3.AssignmentExpression;
  }
};
var o2 = ["||", "&&"];
var h3 = class extends s2 {
  constructor(s4, e8, r7) {
    super(), this.operator = s4, this.left = e8, this.right = r7, this.type = o2.includes(s4) ? e3.LogicalExpression : e3.BinaryExpression;
  }
};
var p3 = class extends s2 {
  constructor(s4) {
    super(), this.body = s4, this.type = e3.BlockStatement;
  }
};
var a2 = class extends s2 {
  constructor() {
    super(...arguments), this.type = e3.BreakStatement;
  }
};
var u2 = class extends s2 {
  constructor(s4, e8) {
    super(), this.callee = s4, this.args = e8, this.type = e3.CallExpression, this.arguments = e8;
  }
};
var l = class extends s2 {
  constructor(s4, e8) {
    super(), this.object = s4, this.property = e8, this.type = e3.MemberExpression, this.computed = true;
  }
};
var d4 = class extends s2 {
  constructor(s4, e8) {
    super(), this.object = s4, this.property = e8, this.type = e3.MemberExpression, this.computed = false;
  }
};
var x = class extends s2 {
  constructor() {
    super(...arguments), this.type = e3.ContinueStatement;
  }
};
var y2 = class extends s2 {
  constructor() {
    super(...arguments), this.type = e3.EmptyStatement;
  }
};
var m5 = class extends s2 {
  constructor(s4) {
    super(), this.expression = s4, this.type = e3.ExpressionStatement;
  }
};
var E3 = class extends s2 {
  constructor(s4, e8, r7) {
    super(), this.left = s4, this.right = e8, this.body = r7, this.type = e3.ForInStatement, this.each = false;
  }
};
var b2 = class extends s2 {
  constructor(s4, e8, r7, i3) {
    super(), this.init = s4, this.test = e8, this.update = r7, this.body = i3, this.type = e3.ForStatement;
  }
};
var g = class extends s2 {
  constructor(s4, e8, r7) {
    super(), this.id = s4, this.params = e8, this.body = r7, this.type = e3.FunctionDeclaration, this.generator = false, this.expression = false, this.async = false;
  }
};
var S2 = class extends s2 {
  constructor(s4) {
    super(), this.name = s4, this.type = e3.Identifier;
  }
};
var f2 = class extends s2 {
  constructor(s4, e8, r7) {
    super(), this.test = s4, this.consequent = e8, this.alternate = r7, this.type = e3.IfStatement;
  }
};
var k4 = class extends s2 {
  constructor(s4, e8) {
    super(), this.value = s4, this.raw = e8, this.type = e3.Literal;
  }
};
var j3 = class extends s2 {
  constructor(s4) {
    super(), this.properties = s4, this.type = e3.ObjectExpression;
  }
};
var v3 = class extends s2 {
  constructor(s4, e8, r7, i3, n3, o4) {
    super(), this.kind = s4, this.key = e8, this.computed = r7, this.value = i3, this.method = n3, this.shorthand = o4, this.type = e3.Property;
  }
};
var B = class extends s2 {
  constructor(s4) {
    super(), this.argument = s4, this.type = e3.ReturnStatement;
  }
};
var D2 = class extends s2 {
  constructor(s4) {
    super(), this.body = s4, this.type = e3.Program;
  }
};
var F = class extends s2 {
  constructor(s4, e8) {
    super(), this.value = s4, this.tail = e8, this.type = e3.TemplateElement;
  }
};
var I2 = class extends s2 {
  constructor(s4, e8) {
    super(), this.quasis = s4, this.expressions = e8, this.type = e3.TemplateLiteral;
  }
};
var q = class extends s2 {
  constructor(s4, e8) {
    super(), this.operator = s4, this.argument = e8, this.type = e3.UnaryExpression, this.prefix = true;
  }
};
var C = class extends s2 {
  constructor(s4, e8, r7) {
    super(), this.operator = s4, this.argument = e8, this.prefix = r7, this.type = e3.UpdateExpression;
  }
};
var M3 = class extends s2 {
  constructor(s4, e8) {
    super(), this.declarations = s4, this.kind = e8, this.type = e3.VariableDeclaration;
  }
};
var P3 = class extends s2 {
  constructor(s4, e8) {
    super(), this.id = s4, this.init = e8, this.type = e3.VariableDeclarator;
  }
};

// node_modules/@arcgis/core/arcade/lib/character.js
var u3 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDF00-\uDF1C\uDF27\uDF30-\uDF50\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
var D3 = { fromCodePoint: (u4) => u4 < 65536 ? String.fromCharCode(u4) : String.fromCharCode(55296 + (u4 - 65536 >> 10)) + String.fromCharCode(56320 + (u4 - 65536 & 1023)), isWhiteSpace: (u4) => 32 === u4 || 9 === u4 || 11 === u4 || 12 === u4 || 160 === u4 || u4 >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].includes(u4), isLineTerminator: (u4) => 10 === u4 || 13 === u4 || 8232 === u4 || 8233 === u4, isIdentifierStart: (F3) => 36 === F3 || 95 === F3 || F3 >= 65 && F3 <= 90 || F3 >= 97 && F3 <= 122 || 92 === F3 || F3 >= 128 && u3.NonAsciiIdentifierStart.test(D3.fromCodePoint(F3)), isIdentifierPart: (F3) => 36 === F3 || 95 === F3 || F3 >= 65 && F3 <= 90 || F3 >= 97 && F3 <= 122 || F3 >= 48 && F3 <= 57 || 92 === F3 || F3 >= 128 && u3.NonAsciiIdentifierPart.test(D3.fromCodePoint(F3)), isDecimalDigit: (u4) => u4 >= 48 && u4 <= 57, isHexDigit: (u4) => u4 >= 48 && u4 <= 57 || u4 >= 65 && u4 <= 70 || u4 >= 97 && u4 <= 102, isOctalDigit: (u4) => u4 >= 48 && u4 <= 55 };

// node_modules/@arcgis/core/arcade/lib/token.js
var e7;
!function(e8) {
  e8[e8.BooleanLiteral = 1] = "BooleanLiteral", e8[e8.EOF = 2] = "EOF", e8[e8.Identifier = 3] = "Identifier", e8[e8.Keyword = 4] = "Keyword", e8[e8.NullLiteral = 5] = "NullLiteral", e8[e8.NumericLiteral = 6] = "NumericLiteral", e8[e8.Punctuator = 7] = "Punctuator", e8[e8.StringLiteral = 8] = "StringLiteral", e8[e8.RegularExpression = 9] = "RegularExpression", e8[e8.Template = 10] = "Template";
}(e7 || (e7 = {}));
var r5 = {};
r5[e7.BooleanLiteral] = "Boolean", r5[e7.EOF] = "<end>", r5[e7.Identifier] = "Identifier", r5[e7.Keyword] = "Keyword", r5[e7.NullLiteral] = "Null", r5[e7.NumericLiteral] = "Numeric", r5[e7.Punctuator] = "Punctuator", r5[e7.StringLiteral] = "String", r5[e7.RegularExpression] = "RegularExpression", r5[e7.Template] = "Template";

// node_modules/@arcgis/core/arcade/lib/scanner.js
function n2(e8) {
  return "0123456789abcdef".indexOf(e8.toLowerCase());
}
function r6(e8) {
  return "01234567".indexOf(e8);
}
var h4 = class {
  constructor(e8, t2) {
    this.source = e8, this.errorHandler = t2, this.trackComment = false, this.isModule = false, this.length = e8.length, this.index = 0, this.lineNumber = e8.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [];
  }
  saveState() {
    return { index: this.index, lineNumber: this.lineNumber, lineStart: this.lineStart, curlyStack: this.curlyStack.slice() };
  }
  restoreState(e8) {
    this.index = e8.index, this.lineNumber = e8.lineNumber, this.lineStart = e8.lineStart, this.curlyStack = e8.curlyStack;
  }
  eof() {
    return this.index >= this.length;
  }
  throwUnexpectedToken(e8 = e5.UnexpectedTokenIllegal) {
    return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, e8);
  }
  _tolerateUnexpectedToken(e8 = e5.UnexpectedTokenIllegal) {
    this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, e8);
  }
  _skipSingleLineComment(e8) {
    let i3 = [], s4 = 0, n3 = null;
    for (this.trackComment && (i3 = [], s4 = this.index - e8, n3 = { start: { line: this.lineNumber, column: this.index - this.lineStart - e8 }, end: { line: 0, column: 0 } }); !this.eof(); ) {
      const r7 = this.source.charCodeAt(this.index);
      if (++this.index, D3.isLineTerminator(r7)) {
        if (n3) {
          n3.end = { line: this.lineNumber, column: this.index - this.lineStart - 1 };
          const t2 = { multiLine: false, slice: [s4 + e8, this.index - 1], range: [s4, this.index - 1], loc: n3 };
          i3.push(t2);
        }
        return 13 === r7 && 10 === this.source.charCodeAt(this.index) && ++this.index, ++this.lineNumber, this.lineStart = this.index, i3;
      }
    }
    if (n3) {
      n3.end = { line: this.lineNumber, column: this.index - this.lineStart };
      const t2 = { multiLine: false, slice: [s4 + e8, this.index], range: [s4, this.index], loc: n3 };
      i3.push(t2);
    }
    return i3;
  }
  _skipMultiLineComment() {
    const e8 = [];
    let i3 = 0, s4 = null;
    for (this.trackComment && (i3 = this.index - 2, s4 = { start: { line: this.lineNumber, column: this.index - this.lineStart - 2 }, end: { line: 0, column: 0 } }); !this.eof(); ) {
      const n3 = this.source.charCodeAt(this.index);
      if (D3.isLineTerminator(n3))
        13 === n3 && 10 === this.source.charCodeAt(this.index + 1) && ++this.index, ++this.lineNumber, ++this.index, this.lineStart = this.index;
      else if (42 === n3) {
        if (47 === this.source.charCodeAt(this.index + 1)) {
          if (this.index += 2, s4) {
            s4.end = { line: this.lineNumber, column: this.index - this.lineStart };
            const t2 = { multiLine: true, slice: [i3 + 2, this.index - 2], range: [i3, this.index], loc: s4 };
            e8.push(t2);
          }
          return e8;
        }
        ++this.index;
      } else
        ++this.index;
    }
    if (s4) {
      s4.end = { line: this.lineNumber, column: this.index - this.lineStart };
      const t2 = { multiLine: true, slice: [i3 + 2, this.index], range: [i3, this.index], loc: s4 };
      e8.push(t2);
    }
    return this._tolerateUnexpectedToken(), e8;
  }
  scanComments() {
    let e8 = null;
    this.trackComment && (e8 = []);
    let i3 = 0 === this.index;
    for (; !this.eof(); ) {
      let s4 = this.source.charCodeAt(this.index);
      if (D3.isWhiteSpace(s4))
        ++this.index;
      else if (D3.isLineTerminator(s4))
        ++this.index, 13 === s4 && 10 === this.source.charCodeAt(this.index) && ++this.index, ++this.lineNumber, this.lineStart = this.index, i3 = true;
      else if (47 === s4)
        if (s4 = this.source.charCodeAt(this.index + 1), 47 === s4) {
          this.index += 2;
          const t2 = this._skipSingleLineComment(2);
          e8 && (e8 = e8.concat(t2)), i3 = true;
        } else {
          if (42 !== s4)
            break;
          {
            this.index += 2;
            const t2 = this._skipMultiLineComment();
            e8 && (e8 = e8.concat(t2));
          }
        }
      else if (i3 && 45 === s4) {
        if (45 !== this.source.charCodeAt(this.index + 1) || 62 !== this.source.charCodeAt(this.index + 2))
          break;
        {
          this.index += 3;
          const t2 = this._skipSingleLineComment(3);
          e8 && (e8 = e8.concat(t2));
        }
      } else {
        if (60 !== s4 || this.isModule)
          break;
        if ("!--" !== this.source.slice(this.index + 1, this.index + 4))
          break;
        {
          this.index += 4;
          const t2 = this._skipSingleLineComment(4);
          e8 && (e8 = e8.concat(t2));
        }
      }
    }
    return e8;
  }
  _isKeyword(e8) {
    switch ((e8 = e8.toLowerCase()).length) {
      case 2:
        return "if" === e8 || "in" === e8;
      case 3:
        return "var" === e8 || "for" === e8;
      case 4:
        return "else" === e8;
      case 5:
        return "break" === e8;
      case 6:
        return "return" === e8;
      case 8:
        return "function" === e8 || "continue" === e8;
      default:
        return false;
    }
  }
  _codePointAt(e8) {
    let t2 = this.source.charCodeAt(e8);
    if (t2 >= 55296 && t2 <= 56319) {
      const i3 = this.source.charCodeAt(e8 + 1);
      if (i3 >= 56320 && i3 <= 57343) {
        t2 = 1024 * (t2 - 55296) + i3 - 56320 + 65536;
      }
    }
    return t2;
  }
  _scanHexEscape(e8) {
    const i3 = "u" === e8 ? 4 : 2;
    let s4 = 0;
    for (let r7 = 0; r7 < i3; ++r7) {
      if (this.eof() || !D3.isHexDigit(this.source.charCodeAt(this.index)))
        return null;
      s4 = 16 * s4 + n2(this.source[this.index++]);
    }
    return String.fromCharCode(s4);
  }
  _scanUnicodeCodePointEscape() {
    let e8 = this.source[this.index], i3 = 0;
    for ("}" === e8 && this.throwUnexpectedToken(); !this.eof() && (e8 = this.source[this.index++], D3.isHexDigit(e8.charCodeAt(0))); )
      i3 = 16 * i3 + n2(e8);
    return (i3 > 1114111 || "}" !== e8) && this.throwUnexpectedToken(), D3.fromCodePoint(i3);
  }
  _getIdentifier() {
    const e8 = this.index++;
    for (; !this.eof(); ) {
      const i3 = this.source.charCodeAt(this.index);
      if (92 === i3)
        return this.index = e8, this._getComplexIdentifier();
      if (i3 >= 55296 && i3 < 57343)
        return this.index = e8, this._getComplexIdentifier();
      if (!D3.isIdentifierPart(i3))
        break;
      ++this.index;
    }
    return this.source.slice(e8, this.index);
  }
  _getComplexIdentifier() {
    let e8, i3 = this._codePointAt(this.index), s4 = D3.fromCodePoint(i3);
    for (this.index += s4.length, 92 === i3 && (117 !== this.source.charCodeAt(this.index) && this.throwUnexpectedToken(), ++this.index, "{" === this.source[this.index] ? (++this.index, e8 = this._scanUnicodeCodePointEscape()) : (e8 = this._scanHexEscape("u"), null !== e8 && "\\" !== e8 && D3.isIdentifierStart(e8.charCodeAt(0)) || this.throwUnexpectedToken()), s4 = e8); !this.eof() && (i3 = this._codePointAt(this.index), D3.isIdentifierPart(i3)); )
      e8 = D3.fromCodePoint(i3), s4 += e8, this.index += e8.length, 92 === i3 && (s4 = s4.substr(0, s4.length - 1), 117 !== this.source.charCodeAt(this.index) && this.throwUnexpectedToken(), ++this.index, "{" === this.source[this.index] ? (++this.index, e8 = this._scanUnicodeCodePointEscape()) : (e8 = this._scanHexEscape("u"), null !== e8 && "\\" !== e8 && D3.isIdentifierPart(e8.charCodeAt(0)) || this.throwUnexpectedToken()), s4 += e8);
    return s4;
  }
  _octalToDecimal(e8) {
    let i3 = "0" !== e8, s4 = r6(e8);
    return !this.eof() && D3.isOctalDigit(this.source.charCodeAt(this.index)) && (i3 = true, s4 = 8 * s4 + r6(this.source[this.index++]), "0123".includes(e8) && !this.eof() && D3.isOctalDigit(this.source.charCodeAt(this.index)) && (s4 = 8 * s4 + r6(this.source[this.index++]))), { code: s4, octal: i3 };
  }
  _scanIdentifier() {
    let e8;
    const t2 = this.index, n3 = 92 === this.source.charCodeAt(t2) ? this._getComplexIdentifier() : this._getIdentifier();
    if (e8 = 1 === n3.length ? e7.Identifier : this._isKeyword(n3) ? e7.Keyword : "null" === n3.toLowerCase() ? e7.NullLiteral : "true" === n3.toLowerCase() || "false" === n3.toLowerCase() ? e7.BooleanLiteral : e7.Identifier, e8 !== e7.Identifier && t2 + n3.length !== this.index) {
      const e9 = this.index;
      this.index = t2, this._tolerateUnexpectedToken(e5.InvalidEscapedReservedWord), this.index = e9;
    }
    return { type: e8, value: n3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: t2, end: this.index };
  }
  _scanPunctuator() {
    const e8 = this.index;
    let t2 = this.source[this.index];
    switch (t2) {
      case "(":
      case "{":
        "{" === t2 && this.curlyStack.push("{"), ++this.index;
        break;
      case ".":
      case ")":
      case ";":
      case ",":
      case "[":
      case "]":
      case ":":
      case "?":
      case "~":
        ++this.index;
        break;
      case "}":
        ++this.index, this.curlyStack.pop();
        break;
      default:
        t2 = this.source.substr(this.index, 4), ">>>=" === t2 ? this.index += 4 : (t2 = t2.substr(0, 3), "===" === t2 || "!==" === t2 || ">>>" === t2 || "<<=" === t2 || ">>=" === t2 || "**=" === t2 ? this.index += 3 : (t2 = t2.substr(0, 2), "&&" === t2 || "||" === t2 || "==" === t2 || "!=" === t2 || "+=" === t2 || "-=" === t2 || "*=" === t2 || "/=" === t2 || "++" === t2 || "--" === t2 || "<<" === t2 || ">>" === t2 || "&=" === t2 || "|=" === t2 || "^=" === t2 || "%=" === t2 || "<=" === t2 || ">=" === t2 || "=>" === t2 || "**" === t2 ? this.index += 2 : (t2 = this.source[this.index], "<>=!+-*%&|^/".includes(t2) && ++this.index)));
    }
    return this.index === e8 && this.throwUnexpectedToken(), { type: e7.Punctuator, value: t2, lineNumber: this.lineNumber, lineStart: this.lineStart, start: e8, end: this.index };
  }
  _scanHexLiteral(e8) {
    let i3 = "";
    for (; !this.eof() && D3.isHexDigit(this.source.charCodeAt(this.index)); )
      i3 += this.source[this.index++];
    return 0 === i3.length && this.throwUnexpectedToken(), D3.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), { type: e7.NumericLiteral, value: parseInt("0x" + i3, 16), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e8, end: this.index };
  }
  _scanBinaryLiteral(e8) {
    let i3 = "";
    for (; !this.eof(); ) {
      const e9 = this.source[this.index];
      if ("0" !== e9 && "1" !== e9)
        break;
      i3 += this.source[this.index++];
    }
    if (0 === i3.length && this.throwUnexpectedToken(), !this.eof()) {
      const e9 = this.source.charCodeAt(this.index);
      (D3.isIdentifierStart(e9) || D3.isDecimalDigit(e9)) && this.throwUnexpectedToken();
    }
    return { type: e7.NumericLiteral, value: parseInt(i3, 2), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e8, end: this.index };
  }
  _scanOctalLiteral(e8, i3) {
    let n3 = "", r7 = false;
    for (D3.isOctalDigit(e8.charCodeAt(0)) ? (r7 = true, n3 = "0" + this.source[this.index++]) : ++this.index; !this.eof() && D3.isOctalDigit(this.source.charCodeAt(this.index)); )
      n3 += this.source[this.index++];
    return r7 || 0 !== n3.length || this.throwUnexpectedToken(), (D3.isIdentifierStart(this.source.charCodeAt(this.index)) || D3.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), { type: e7.NumericLiteral, value: parseInt(n3, 8), octal: r7, lineNumber: this.lineNumber, lineStart: this.lineStart, start: i3, end: this.index };
  }
  _scanNumericLiteral() {
    const i3 = this.index;
    let n3 = this.source[i3];
    r2(D3.isDecimalDigit(n3.charCodeAt(0)) || "." === n3, "Numeric literal must start with a decimal digit or a decimal point");
    let r7 = "";
    if ("." !== n3) {
      if (r7 = this.source[this.index++], n3 = this.source[this.index], "0" === r7) {
        if ("x" === n3 || "X" === n3)
          return ++this.index, this._scanHexLiteral(i3);
        if ("b" === n3 || "B" === n3)
          return ++this.index, this._scanBinaryLiteral(i3);
        if ("o" === n3 || "O" === n3)
          return this._scanOctalLiteral(n3, i3);
      }
      for (; D3.isDecimalDigit(this.source.charCodeAt(this.index)); )
        r7 += this.source[this.index++];
      n3 = this.source[this.index];
    }
    if ("." === n3) {
      for (r7 += this.source[this.index++]; D3.isDecimalDigit(this.source.charCodeAt(this.index)); )
        r7 += this.source[this.index++];
      n3 = this.source[this.index];
    }
    if ("e" === n3 || "E" === n3)
      if (r7 += this.source[this.index++], n3 = this.source[this.index], "+" !== n3 && "-" !== n3 || (r7 += this.source[this.index++]), D3.isDecimalDigit(this.source.charCodeAt(this.index)))
        for (; D3.isDecimalDigit(this.source.charCodeAt(this.index)); )
          r7 += this.source[this.index++];
      else
        this.throwUnexpectedToken();
    return D3.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), { type: e7.NumericLiteral, value: parseFloat(r7), lineNumber: this.lineNumber, lineStart: this.lineStart, start: i3, end: this.index };
  }
  _scanStringLiteral() {
    const n3 = this.index;
    let r7 = this.source[n3];
    r2("'" === r7 || '"' === r7, "String literal must starts with a quote"), ++this.index;
    let h7 = false, c2 = "";
    for (; !this.eof(); ) {
      let e8 = this.source[this.index++];
      if (e8 === r7) {
        r7 = "";
        break;
      }
      if ("\\" === e8)
        if (e8 = this.source[this.index++], e8 && D3.isLineTerminator(e8.charCodeAt(0)))
          ++this.lineNumber, "\r" === e8 && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index;
        else
          switch (e8) {
            case "u":
              if ("{" === this.source[this.index])
                ++this.index, c2 += this._scanUnicodeCodePointEscape();
              else {
                const t2 = this._scanHexEscape(e8);
                null === t2 && this.throwUnexpectedToken(), c2 += t2;
              }
              break;
            case "x": {
              const t2 = this._scanHexEscape(e8);
              null === t2 && this.throwUnexpectedToken(e5.InvalidHexEscapeSequence), c2 += t2;
              break;
            }
            case "n":
              c2 += "\n";
              break;
            case "r":
              c2 += "\r";
              break;
            case "t":
              c2 += "	";
              break;
            case "b":
              c2 += "\b";
              break;
            case "f":
              c2 += "\f";
              break;
            case "v":
              c2 += "\v";
              break;
            case "8":
            case "9":
              c2 += e8, this._tolerateUnexpectedToken();
              break;
            default:
              if (e8 && D3.isOctalDigit(e8.charCodeAt(0))) {
                const t2 = this._octalToDecimal(e8);
                h7 = t2.octal || h7, c2 += String.fromCharCode(t2.code);
              } else
                c2 += e8;
          }
      else {
        if (D3.isLineTerminator(e8.charCodeAt(0)))
          break;
        c2 += e8;
      }
    }
    return "" !== r7 && (this.index = n3, this.throwUnexpectedToken()), { type: e7.StringLiteral, value: c2, octal: h7, lineNumber: this.lineNumber, lineStart: this.lineStart, start: n3, end: this.index };
  }
  _scanTemplate() {
    let e8 = "", n3 = false;
    const r7 = this.index, h7 = "`" === this.source[r7];
    let c2 = false, o4 = 2;
    for (++this.index; !this.eof(); ) {
      let s4 = this.source[this.index++];
      if ("`" === s4) {
        o4 = 1, c2 = true, n3 = true;
        break;
      }
      if ("$" === s4) {
        if ("{" === this.source[this.index]) {
          this.curlyStack.push("${"), ++this.index, n3 = true;
          break;
        }
        e8 += s4;
      } else if ("\\" === s4)
        if (s4 = this.source[this.index++], D3.isLineTerminator(s4.charCodeAt(0)))
          ++this.lineNumber, "\r" === s4 && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index;
        else
          switch (s4) {
            case "n":
              e8 += "\n";
              break;
            case "r":
              e8 += "\r";
              break;
            case "t":
              e8 += "	";
              break;
            case "u":
              if ("{" === this.source[this.index])
                ++this.index, e8 += this._scanUnicodeCodePointEscape();
              else {
                const t2 = this.index, i3 = this._scanHexEscape(s4);
                null !== i3 ? e8 += i3 : (this.index = t2, e8 += s4);
              }
              break;
            case "x": {
              const t2 = this._scanHexEscape(s4);
              null === t2 && this.throwUnexpectedToken(e5.InvalidHexEscapeSequence), e8 += t2;
              break;
            }
            case "b":
              e8 += "\b";
              break;
            case "f":
              e8 += "\f";
              break;
            case "v":
              e8 += "\v";
              break;
            default:
              "0" === s4 ? (D3.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(e5.TemplateOctalLiteral), e8 += "\0") : D3.isOctalDigit(s4.charCodeAt(0)) ? this.throwUnexpectedToken(e5.TemplateOctalLiteral) : e8 += s4;
          }
      else
        D3.isLineTerminator(s4.charCodeAt(0)) ? (++this.lineNumber, "\r" === s4 && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index, e8 += "\n") : e8 += s4;
    }
    return n3 || this.throwUnexpectedToken(), h7 || this.curlyStack.pop(), { type: e7.Template, value: this.source.slice(r7 + 1, this.index - o4), cooked: e8, head: h7, tail: c2, lineNumber: this.lineNumber, lineStart: this.lineStart, start: r7, end: this.index };
  }
  _testRegExp(e8, t2) {
    const s4 = "";
    let n3 = e8;
    t2.includes("u") && (n3 = n3.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, (e9, t3, n4) => {
      const r7 = parseInt(t3 || n4, 16);
      return r7 > 1114111 && this.throwUnexpectedToken(e5.InvalidRegExp), r7 <= 65535 ? String.fromCharCode(r7) : s4;
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, s4));
    try {
      RegExp(n3);
    } catch (r7) {
      this.throwUnexpectedToken(e5.InvalidRegExp);
    }
    try {
      return new RegExp(e8, t2);
    } catch (h7) {
      return null;
    }
  }
  _scanRegExpBody() {
    let s4 = this.source[this.index];
    r2("/" === s4, "Regular expression literal must start with a slash");
    let n3 = this.source[this.index++], r7 = false, h7 = false;
    for (; !this.eof(); )
      if (s4 = this.source[this.index++], n3 += s4, "\\" === s4)
        s4 = this.source[this.index++], D3.isLineTerminator(s4.charCodeAt(0)) && this.throwUnexpectedToken(e5.UnterminatedRegExp), n3 += s4;
      else if (D3.isLineTerminator(s4.charCodeAt(0)))
        this.throwUnexpectedToken(e5.UnterminatedRegExp);
      else if (r7)
        "]" === s4 && (r7 = false);
      else {
        if ("/" === s4) {
          h7 = true;
          break;
        }
        "[" === s4 && (r7 = true);
      }
    return h7 || this.throwUnexpectedToken(e5.UnterminatedRegExp), n3.substr(1, n3.length - 2);
  }
  _scanRegExpFlags() {
    let e8 = "", i3 = "";
    for (; !this.eof(); ) {
      let s4 = this.source[this.index];
      if (!D3.isIdentifierPart(s4.charCodeAt(0)))
        break;
      if (++this.index, "\\" !== s4 || this.eof())
        i3 += s4, e8 += s4;
      else if (s4 = this.source[this.index], "u" === s4) {
        ++this.index;
        let t2 = this.index;
        const s5 = this._scanHexEscape("u");
        if (null !== s5)
          for (i3 += s5, e8 += "\\u"; t2 < this.index; ++t2)
            e8 += this.source[t2];
        else
          this.index = t2, i3 += "u", e8 += "\\u";
        this._tolerateUnexpectedToken();
      } else
        e8 += "\\", this._tolerateUnexpectedToken();
    }
    return i3;
  }
  scanRegExp() {
    const e8 = this.index, t2 = this._scanRegExpBody(), i3 = this._scanRegExpFlags(), n3 = this._testRegExp(t2, i3);
    return { type: e7.RegularExpression, value: "", pattern: t2, flags: i3, regex: n3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: e8, end: this.index };
  }
  lex() {
    if (this.eof())
      return { type: e7.EOF, value: "", lineNumber: this.lineNumber, lineStart: this.lineStart, start: this.index, end: this.index };
    const e8 = this.source.charCodeAt(this.index);
    return D3.isIdentifierStart(e8) ? this._scanIdentifier() : 40 === e8 || 41 === e8 || 59 === e8 ? this._scanPunctuator() : 39 === e8 || 34 === e8 ? this._scanStringLiteral() : 46 === e8 ? D3.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this._scanNumericLiteral() : this._scanPunctuator() : D3.isDecimalDigit(e8) ? this._scanNumericLiteral() : 96 === e8 || 125 === e8 && "${" === this.curlyStack[this.curlyStack.length - 1] ? this._scanTemplate() : e8 >= 55296 && e8 < 57343 && D3.isIdentifierStart(this._codePointAt(this.index)) ? this._scanIdentifier() : this._scanPunctuator();
  }
};

// node_modules/@arcgis/core/arcade/lib/parser.js
var O3 = class {
  constructor(e8, i3 = {}, s4) {
    this.config = { range: "boolean" == typeof i3.range && i3.range, loc: "boolean" == typeof i3.loc && i3.loc, source: null, tokens: "boolean" == typeof i3.tokens && i3.tokens, comment: "boolean" == typeof i3.comment && i3.comment, tolerant: "boolean" == typeof i3.tolerant && i3.tolerant, globalReturn: !!i3.globalReturn }, this.config.loc && i3.source && null !== i3.source && (this.config.source = String(i3.source)), this.delegate = s4, this.errorHandler = new r3(), this.errorHandler.tolerant = this.config.tolerant, this.scanner = new h4(e8, this.errorHandler), this.scanner.trackComment = this.config.comment, this.operatorPrecedence = { ")": 0, ";": 0, ",": 0, "=": 0, "]": 0, "||": 1, "&&": 2, "|": 3, "^": 4, "&": 5, "==": 6, "!=": 6, "===": 6, "!==": 6, "<": 7, ">": 7, "<=": 7, ">=": 7, "<<": 8, ">>": 8, ">>>": 8, "+": 9, "-": 9, "*": 11, "/": 11, "%": 11 }, this.lookahead = { type: e7.EOF, value: "", lineNumber: this.scanner.lineNumber, lineStart: 0, start: 0, end: 0 }, this.hasLineTerminator = false, this.context = { allowIn: true, firstCoverInitializedNameError: null, isAssignmentTarget: false, isBindingElement: false, inFunctionBody: false, inIteration: false, curlyParsing: "asObject" }, this.tokens = [], this.startMarker = { index: 0, line: this.scanner.lineNumber, column: 0 }, this.lastMarker = { index: 0, line: this.scanner.lineNumber, column: 0 }, this.nextToken(), this.lastMarker = { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart };
  }
  tolerateError(t2, ...i3) {
    const s4 = i3.slice(), n3 = t2.replace(/%(\d)/g, (t3, i4) => (r2(i4 < s4.length, "Message reference must be in range"), s4[i4])), r7 = this.lastMarker.index, a4 = this.scanner.lineNumber, o4 = this.lastMarker.column + 1;
    this.errorHandler.tolerateError(r7, a4, o4, n3);
  }
  unexpectedTokenError(e8, t2) {
    let s4, n3 = t2 || e5.UnexpectedToken;
    if (e8 ? (t2 || (n3 = e8.type === e7.EOF ? e5.UnexpectedEOS : e8.type === e7.Identifier ? e5.UnexpectedIdentifier : e8.type === e7.NumericLiteral ? e5.UnexpectedNumber : e8.type === e7.StringLiteral ? e5.UnexpectedString : e8.type === e7.Template ? e5.UnexpectedTemplate : e5.UnexpectedToken), s4 = e8.value.toString()) : s4 = "ILLEGAL", n3 = n3.replace("%0", s4), e8 && "number" == typeof e8.lineNumber) {
      const t3 = e8.start, i3 = e8.lineNumber, s5 = this.lastMarker.index - this.lastMarker.column, r8 = e8.start - s5 + 1;
      return this.errorHandler.createError(t3, i3, r8, n3);
    }
    const r7 = this.lastMarker.index, a4 = this.lastMarker.line, o4 = this.lastMarker.column + 1;
    return this.errorHandler.createError(r7, a4, o4, n3);
  }
  throwUnexpectedToken(e8, t2) {
    throw this.unexpectedTokenError(e8, t2);
  }
  tolerateUnexpectedToken(e8, t2) {
    this.errorHandler.tolerate(this.unexpectedTokenError(e8, t2));
  }
  collectComments() {
    if (this.config.comment) {
      const e8 = this.scanner.scanComments();
      if (e8 && e8.length > 0 && this.delegate)
        for (let t2 = 0; t2 < e8.length; ++t2) {
          const i3 = e8[t2], n3 = new e6(i3.multiLine ? "Block" : "Line", this.scanner.source.slice(i3.slice[0], i3.slice[1]));
          this.config.range && (n3.range = i3.range), this.config.loc && (n3.loc = i3.loc);
          const r7 = { start: { line: i3.loc.start.line, column: i3.loc.start.column, offset: i3.range[0] }, end: { line: i3.loc.end.line, column: i3.loc.end.column, offset: i3.range[1] } };
          this.delegate(n3, r7);
        }
    } else
      this.scanner.scanComments();
  }
  peekAhead(e8) {
    const t2 = () => (this.scanner.scanComments(), this.scanner.lex()), i3 = this.scanner.saveState();
    e8.call(this, t2), this.scanner.restoreState(i3);
  }
  getTokenRaw(e8) {
    return this.scanner.source.slice(e8.start, e8.end);
  }
  convertToken(e8) {
    const t2 = { type: r5[e8.type], value: this.getTokenRaw(e8) };
    if (this.config.range && (t2.range = [e8.start, e8.end]), this.config.loc && (t2.loc = { start: { line: this.startMarker.line, column: this.startMarker.column }, end: { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart } }), e8.type === e7.RegularExpression) {
      const i3 = e8.pattern, s4 = e8.flags;
      t2.regex = { pattern: i3, flags: s4 };
    }
    return t2;
  }
  nextToken() {
    const e8 = this.lookahead;
    this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.collectComments(), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart);
    const t2 = this.scanner.lex();
    return this.hasLineTerminator = e8.lineNumber !== t2.lineNumber, this.lookahead = t2, this.config.tokens && t2.type !== e7.EOF && this.tokens.push(this.convertToken(t2)), e8;
  }
  createNode() {
    return { index: this.startMarker.index, line: this.startMarker.line, column: this.startMarker.column };
  }
  startNode(e8, t2 = 0) {
    let i3 = e8.start - e8.lineStart, s4 = e8.lineNumber;
    return i3 < 0 && (i3 += t2, s4--), { index: e8.start, line: s4, column: i3 };
  }
  finalize(e8, t2) {
    if (this.config.range && (t2.range = [e8.index, this.lastMarker.index]), this.config.loc && (t2.loc = { start: { line: e8.line, column: e8.column }, end: { line: this.lastMarker.line, column: this.lastMarker.column } }, this.config.source && (t2.loc.source = this.config.source)), this.delegate) {
      const i3 = { start: { line: e8.line, column: e8.column, offset: e8.index }, end: { line: this.lastMarker.line, column: this.lastMarker.column, offset: this.lastMarker.index } };
      this.delegate(t2, i3);
    }
    return t2;
  }
  expect(e8) {
    const t2 = this.nextToken();
    t2.type === e7.Punctuator && t2.value === e8 || this.throwUnexpectedToken(t2);
  }
  expectCommaSeparator() {
    if (this.config.tolerant) {
      const e8 = this.lookahead;
      e8.type === e7.Punctuator && "," === e8.value ? this.nextToken() : e8.type === e7.Punctuator && ";" === e8.value ? (this.nextToken(), this.tolerateUnexpectedToken(e8)) : this.tolerateUnexpectedToken(e8, e5.UnexpectedToken);
    } else
      this.expect(",");
  }
  expectKeyword(e8) {
    const t2 = this.nextToken();
    t2.type === e7.Keyword && t2.value.toString().toLowerCase() === e8.toLowerCase() || this.throwUnexpectedToken(t2);
  }
  match(e8) {
    return this.lookahead.type === e7.Punctuator && this.lookahead.value === e8;
  }
  matchKeyword(e8) {
    return this.lookahead.type === e7.Keyword && this.lookahead.value.toLowerCase() === e8.toLowerCase();
  }
  matchContextualKeyword(e8) {
    return this.lookahead.type === e7.Identifier && this.lookahead.value === e8;
  }
  matchAssign() {
    if (this.lookahead.type !== e7.Punctuator)
      return false;
    const e8 = this.lookahead.value;
    return i2.includes(e8);
  }
  isolateCoverGrammar(e8) {
    const t2 = this.context.isBindingElement, i3 = this.context.isAssignmentTarget, s4 = this.context.firstCoverInitializedNameError;
    this.context.isBindingElement = true, this.context.isAssignmentTarget = true, this.context.firstCoverInitializedNameError = null;
    const n3 = e8.call(this);
    return null !== this.context.firstCoverInitializedNameError && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError), this.context.isBindingElement = t2, this.context.isAssignmentTarget = i3, this.context.firstCoverInitializedNameError = s4, n3;
  }
  inheritCoverGrammar(e8) {
    const t2 = this.context.isBindingElement, i3 = this.context.isAssignmentTarget, s4 = this.context.firstCoverInitializedNameError;
    this.context.isBindingElement = true, this.context.isAssignmentTarget = true, this.context.firstCoverInitializedNameError = null;
    const n3 = e8.call(this);
    return this.context.isBindingElement = this.context.isBindingElement && t2, this.context.isAssignmentTarget = this.context.isAssignmentTarget && i3, this.context.firstCoverInitializedNameError = s4 || this.context.firstCoverInitializedNameError, n3;
  }
  consumeSemicolon() {
    this.match(";") ? this.nextToken() : this.hasLineTerminator || (this.lookahead.type === e7.EOF || this.match("}") || this.throwUnexpectedToken(this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.line = this.startMarker.line, this.lastMarker.column = this.startMarker.column);
  }
  parsePrimaryExpression() {
    const e8 = this.createNode();
    let t2, i3, s4;
    switch (this.lookahead.type) {
      case e7.Identifier:
        t2 = this.finalize(e8, new S2(this.nextToken().value));
        break;
      case e7.NumericLiteral:
      case e7.StringLiteral:
        this.context.isAssignmentTarget = false, this.context.isBindingElement = false, i3 = this.nextToken(), s4 = this.getTokenRaw(i3), t2 = this.finalize(e8, new k4(i3.value, s4));
        break;
      case e7.BooleanLiteral:
        this.context.isAssignmentTarget = false, this.context.isBindingElement = false, i3 = this.nextToken(), s4 = this.getTokenRaw(i3), t2 = this.finalize(e8, new k4("true" === i3.value.toString().toLowerCase(), s4));
        break;
      case e7.NullLiteral:
        this.context.isAssignmentTarget = false, this.context.isBindingElement = false, i3 = this.nextToken(), s4 = this.getTokenRaw(i3), t2 = this.finalize(e8, new k4(null, s4));
        break;
      case e7.Template:
        t2 = this.parseTemplateLiteral();
        break;
      case e7.Punctuator:
        switch (this.lookahead.value) {
          case "(":
            this.context.isBindingElement = false, t2 = this.inheritCoverGrammar(this.parseGroupExpression);
            break;
          case "[":
            t2 = this.inheritCoverGrammar(this.parseArrayInitializer);
            break;
          case "{":
            t2 = this.inheritCoverGrammar(this.parseObjectInitializer);
            break;
          default:
            t2 = this.throwUnexpectedToken(this.nextToken());
        }
        break;
      case e7.Keyword:
        this.context.isAssignmentTarget = false, this.context.isBindingElement = false, t2 = this.throwUnexpectedToken(this.nextToken());
        break;
      default:
        t2 = this.throwUnexpectedToken(this.nextToken());
    }
    return t2;
  }
  parseArrayInitializer() {
    const e8 = this.createNode(), t2 = [];
    for (this.expect("["); !this.match("]"); )
      this.match(",") ? (this.nextToken(), t2.push(null)) : (t2.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match("]") || this.expect(","));
    return this.expect("]"), this.finalize(e8, new r4(t2));
  }
  parseObjectPropertyKey() {
    const e8 = this.createNode(), t2 = this.nextToken();
    let i3;
    switch (t2.type) {
      case e7.StringLiteral:
      case e7.NumericLiteral:
        i3 = this.finalize(e8, new k4(t2.value, this.getTokenRaw(t2)));
        break;
      case e7.Identifier:
      case e7.BooleanLiteral:
      case e7.NullLiteral:
      case e7.Keyword:
        i3 = this.finalize(e8, new S2(t2.value));
        break;
      default:
        i3 = this.throwUnexpectedToken(t2);
    }
    return i3;
  }
  parseObjectProperty() {
    const e8 = this.createNode(), t2 = this.lookahead;
    let i3 = false;
    const s4 = false;
    let n3 = false, r7 = null;
    if (t2.type === e7.Identifier) {
      const s5 = t2.value;
      this.nextToken(), i3 = this.match("["), r7 = this.finalize(e8, new S2(s5));
    } else
      this.match("*") ? this.nextToken() : (i3 = this.match("["), r7 = this.parseObjectPropertyKey());
    r7 || this.throwUnexpectedToken(this.lookahead);
    let o4 = null;
    const c2 = "init";
    if (this.match(":"))
      this.nextToken(), o4 = this.inheritCoverGrammar(this.parseAssignmentExpression);
    else if (t2.type === e7.Identifier) {
      n3 = true, o4 = this.finalize(e8, new S2(t2.value));
    } else
      this.throwUnexpectedToken(this.nextToken());
    return this.finalize(e8, new v3(c2, r7, i3, o4, s4, n3));
  }
  parseObjectInitializer() {
    const e8 = this.createNode();
    this.expect("{");
    const t2 = [];
    for (; !this.match("}"); )
      t2.push(this.parseObjectProperty()), this.match("}") || this.expectCommaSeparator();
    return this.expect("}"), this.finalize(e8, new j3(t2));
  }
  parseTemplateHead() {
    r2(this.lookahead.head, "Template literal must start with a template head");
    const t2 = this.createNode(), i3 = this.nextToken(), s4 = i3.value, n3 = i3.cooked;
    return this.finalize(t2, new F({ raw: s4, cooked: n3 }, i3.tail));
  }
  parseTemplateElement() {
    this.lookahead.type !== e7.Template && this.throwUnexpectedToken();
    const e8 = this.createNode(), t2 = this.nextToken(), i3 = t2.value, s4 = t2.cooked;
    return this.finalize(e8, new F({ raw: i3, cooked: s4 }, t2.tail));
  }
  parseTemplateLiteral() {
    const e8 = this.createNode(), t2 = [], i3 = [];
    let s4 = this.parseTemplateHead();
    for (i3.push(s4); !s4.tail; )
      t2.push(this.parseExpression()), s4 = this.parseTemplateElement(), i3.push(s4);
    return this.finalize(e8, new I2(i3, t2));
  }
  parseGroupExpression() {
    this.expect("("), this.context.isBindingElement = true;
    const e8 = this.inheritCoverGrammar(this.parseAssignmentExpression);
    return this.expect(")"), this.context.isBindingElement = false, e8;
  }
  parseArguments() {
    this.expect("(");
    const e8 = [];
    if (!this.match(")"))
      for (; ; ) {
        const t2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
        if (e8.push(t2), this.match(")"))
          break;
        if (this.expectCommaSeparator(), this.match(")"))
          break;
      }
    return this.expect(")"), e8;
  }
  isIdentifierName(e8) {
    return e8.type === e7.Identifier || e8.type === e7.Keyword || e8.type === e7.BooleanLiteral || e8.type === e7.NullLiteral;
  }
  parseIdentifierName() {
    const e8 = this.createNode(), t2 = this.nextToken();
    return this.isIdentifierName(t2) || this.throwUnexpectedToken(t2), this.finalize(e8, new S2(t2.value));
  }
  parseLeftHandSideExpressionAllowCall() {
    const e8 = this.lookahead, t2 = this.context.allowIn;
    this.context.allowIn = true;
    let i3 = this.inheritCoverGrammar(this.parsePrimaryExpression);
    for (; ; )
      if (this.match("(")) {
        this.context.isBindingElement = false, this.context.isAssignmentTarget = false;
        const t3 = this.parseArguments();
        i3 = this.finalize(this.startNode(e8), new u2(i3, t3));
      } else if (this.match("[")) {
        this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect("[");
        const t3 = this.isolateCoverGrammar(this.parseExpression);
        this.expect("]"), i3 = this.finalize(this.startNode(e8), new l(i3, t3));
      } else {
        if (!this.match("."))
          break;
        {
          this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect(".");
          const t3 = this.parseIdentifierName();
          i3 = this.finalize(this.startNode(e8), new d4(i3, t3));
        }
      }
    return this.context.allowIn = t2, i3;
  }
  parseLeftHandSideExpression() {
    r2(this.context.allowIn, "callee of new expression always allow in keyword.");
    const t2 = this.startNode(this.lookahead);
    let i3 = this.inheritCoverGrammar(this.parsePrimaryExpression);
    for (; ; )
      if (this.match("[")) {
        this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect("[");
        const e8 = this.isolateCoverGrammar(this.parseExpression);
        this.expect("]"), i3 = this.finalize(t2, new l(i3, e8));
      } else {
        if (!this.match("."))
          break;
        {
          this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect(".");
          const e8 = this.parseIdentifierName();
          i3 = this.finalize(t2, new d4(i3, e8));
        }
      }
    return i3;
  }
  parseUpdateExpression() {
    let e8;
    const t2 = this.lookahead;
    if (this.match("++") || this.match("--")) {
      const s4 = this.startNode(t2), n3 = this.nextToken();
      e8 = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.isAssignmentTarget || this.tolerateError(e5.InvalidLHSInAssignment);
      const r7 = true;
      e8 = this.finalize(s4, new C(n3.value, e8, r7)), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
    } else if (e8 = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && this.lookahead.type === e7.Punctuator && (this.match("++") || this.match("--"))) {
      this.context.isAssignmentTarget || this.tolerateError(e5.InvalidLHSInAssignment), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
      const s4 = this.nextToken().value, n3 = false;
      e8 = this.finalize(this.startNode(t2), new C(s4, e8, n3));
    }
    return e8;
  }
  parseUnaryExpression() {
    let e8;
    if (this.match("+") || this.match("-") || this.match("~") || this.match("!")) {
      const t2 = this.startNode(this.lookahead), i3 = this.nextToken();
      e8 = this.inheritCoverGrammar(this.parseUnaryExpression), e8 = this.finalize(t2, new q(i3.value, e8)), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
    } else
      e8 = this.parseUpdateExpression();
    return e8;
  }
  binaryPrecedence(e8) {
    const t2 = e8.value;
    let i3;
    return i3 = e8.type === e7.Punctuator ? this.operatorPrecedence[t2] || 0 : e8.type === e7.Keyword && this.context.allowIn && "in" === t2 ? 12 : 0, i3;
  }
  parseBinaryExpression() {
    const e8 = this.lookahead;
    let t2 = this.inheritCoverGrammar(this.parseUnaryExpression);
    const i3 = this.lookahead;
    let s4 = this.binaryPrecedence(i3);
    if (s4 > 0) {
      this.nextToken(), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
      const n3 = [e8, this.lookahead];
      let r7 = t2, a4 = this.inheritCoverGrammar(this.parseUnaryExpression);
      const o4 = [r7, i3.value, a4], h7 = [s4];
      for (; s4 = this.binaryPrecedence(this.lookahead), !(s4 <= 0); ) {
        for (; o4.length > 2 && s4 <= h7[h7.length - 1]; ) {
          a4 = o4.pop();
          const e9 = o4.pop();
          h7.pop(), r7 = o4.pop(), n3.pop();
          const t3 = n3[n3.length - 1], i4 = this.startNode(t3, t3.lineStart);
          o4.push(this.finalize(i4, new h3(e9, r7, a4)));
        }
        o4.push(this.nextToken().value), h7.push(s4), n3.push(this.lookahead), o4.push(this.inheritCoverGrammar(this.parseUnaryExpression));
      }
      let c2 = o4.length - 1;
      t2 = o4[c2];
      let l3 = n3.pop();
      for (; c2 > 1; ) {
        const e9 = n3.pop();
        if (!e9)
          break;
        const i4 = l3 && l3.lineStart, s5 = this.startNode(e9, i4), r8 = o4[c2 - 1];
        t2 = this.finalize(s5, new h3(r8, o4[c2 - 2], t2)), c2 -= 2, l3 = e9;
      }
    }
    return t2;
  }
  parseAssignmentExpression() {
    const e8 = this.lookahead;
    let t2 = e8, s4 = this.inheritCoverGrammar(this.parseBinaryExpression);
    if (this.matchAssign()) {
      this.context.isAssignmentTarget || this.tolerateError(e5.InvalidLHSInAssignment), this.match("=") || (this.context.isAssignmentTarget = false, this.context.isBindingElement = false), t2 = this.nextToken();
      const n3 = t2.value, r7 = this.isolateCoverGrammar(this.parseAssignmentExpression);
      s4 = this.finalize(this.startNode(e8), new n(n3, s4, r7)), this.context.firstCoverInitializedNameError = null;
    }
    return s4;
  }
  parseExpression() {
    return this.isolateCoverGrammar(this.parseAssignmentExpression);
  }
  parseStatementListItem() {
    let e8;
    if (this.context.isAssignmentTarget = true, this.context.isBindingElement = true, this.lookahead.type === e7.Keyword)
      if ("function" === this.lookahead.value)
        e8 = this.parseFunctionDeclaration();
      else
        e8 = this.parseStatement();
    else
      e8 = this.parseStatement();
    return e8;
  }
  parseBlock() {
    const e8 = this.createNode();
    this.expect("{");
    const t2 = [];
    for (; !this.match("}"); )
      t2.push(this.parseStatementListItem());
    return this.expect("}"), this.finalize(e8, new p3(t2));
  }
  parseObjectStatement() {
    const e8 = this.createNode(), t2 = this.parseObjectInitializer();
    return this.finalize(e8, new m5(t2));
  }
  parseBlockOrObjectStatement() {
    let e8 = "asObject" === this.context.curlyParsing;
    return "asObjectOrBlock" === this.context.curlyParsing && this.peekAhead((t2) => {
      let i3 = t2();
      i3.type !== e7.Identifier && i3.type !== e7.StringLiteral || (i3 = t2(), i3.type === e7.Punctuator && ":" === i3.value && (e8 = true));
    }), e8 ? this.parseObjectStatement() : this.parseBlock();
  }
  parseVariableIdentifier() {
    const e8 = this.createNode(), t2 = this.nextToken();
    return t2.type !== e7.Identifier && this.throwUnexpectedToken(t2, e5.IdentiferExpected), this.finalize(e8, new S2(t2.value));
  }
  parseVariableDeclaration(e8) {
    const t2 = this.createNode(), i3 = this.parseVariableIdentifier();
    let s4 = null;
    return this.match("=") ? (this.nextToken(), s4 = this.isolateCoverGrammar(this.parseAssignmentExpression)) : i3.type === e3.Identifier || e8.inFor || this.expect("="), this.finalize(t2, new P3(i3, s4));
  }
  parseVariableDeclarationList(e8) {
    const t2 = [this.parseVariableDeclaration(e8)];
    for (; this.match(","); )
      this.nextToken(), t2.push(this.parseVariableDeclaration(e8));
    return t2;
  }
  parseVariableStatement() {
    const e8 = this.createNode();
    this.expectKeyword("var");
    const t2 = this.parseVariableDeclarationList({ inFor: false });
    return this.consumeSemicolon(), this.finalize(e8, new M3(t2, "var"));
  }
  parseEmptyStatement() {
    const e8 = this.createNode();
    return this.expect(";"), this.finalize(e8, new y2());
  }
  parseExpressionStatement() {
    const e8 = this.createNode(), t2 = this.parseExpression();
    return this.consumeSemicolon(), this.finalize(e8, new m5(t2));
  }
  parseIfClause() {
    const e8 = this.context.curlyParsing;
    this.context.curlyParsing = "asObjectOrBlock";
    const t2 = this.parseStatement();
    return this.context.curlyParsing = e8, t2;
  }
  parseIfStatement() {
    const e8 = this.createNode();
    let t2, i3 = null;
    this.expectKeyword("if"), this.expect("(");
    const s4 = this.parseExpression();
    return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), t2 = this.finalize(this.createNode(), new y2())) : (this.expect(")"), t2 = this.parseIfClause(), this.matchKeyword("else") && (this.nextToken(), i3 = this.parseIfClause())), this.finalize(e8, new f2(s4, t2, i3));
  }
  parseForStatement() {
    let e8 = null, t2 = null, s4 = null, n3 = null, r7 = null;
    const a4 = this.createNode();
    if (this.expectKeyword("for"), this.expect("("), this.match(";"))
      this.nextToken();
    else if (this.matchKeyword("var")) {
      const t3 = this.createNode();
      this.nextToken();
      const s5 = this.context.allowIn;
      this.context.allowIn = false;
      const a5 = this.parseVariableDeclarationList({ inFor: true });
      if (this.context.allowIn = s5, 1 === a5.length && this.matchKeyword("in")) {
        a5[0].init && this.tolerateError(e5.ForInOfLoopInitializer, "for-in"), n3 = this.finalize(t3, new M3(a5, "var")), this.nextToken(), r7 = this.parseExpression();
      } else
        e8 = this.finalize(t3, new M3(a5, "var")), this.expect(";");
    } else {
      const t3 = this.context.isBindingElement, s5 = this.context.isAssignmentTarget, a5 = this.context.firstCoverInitializedNameError, o5 = this.context.allowIn;
      this.context.allowIn = false, e8 = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = o5, this.matchKeyword("in") ? (this.context.isAssignmentTarget && e8.type !== e3.AssignmentExpression || this.tolerateError(e5.InvalidLHSInForIn), this.nextToken(), n3 = e8, r7 = this.parseExpression(), e8 = null) : (this.context.isBindingElement = t3, this.context.isAssignmentTarget = s5, this.context.firstCoverInitializedNameError = a5, this.expect(";"));
    }
    let o4;
    if (n3 || (this.match(";") || (t2 = this.isolateCoverGrammar(this.parseExpression)), this.expect(";"), this.match(")") || (s4 = this.isolateCoverGrammar(this.parseExpression))), !this.match(")") && this.config.tolerant)
      this.tolerateUnexpectedToken(this.nextToken()), o4 = this.finalize(this.createNode(), new y2());
    else {
      this.expect(")");
      const e9 = this.context.inIteration, t3 = this.context.curlyParsing;
      this.context.inIteration = true, this.context.curlyParsing = "asObjectOrBlock", o4 = this.isolateCoverGrammar(this.parseStatement), this.context.curlyParsing = t3, this.context.inIteration = e9;
    }
    return n3 && r7 ? this.finalize(a4, new E3(n3, r7, o4)) : this.finalize(a4, new b2(e8, t2, s4, o4));
  }
  parseContinueStatement() {
    const e8 = this.createNode();
    return this.expectKeyword("continue"), this.consumeSemicolon(), this.finalize(e8, new x());
  }
  parseBreakStatement() {
    const e8 = this.createNode();
    return this.expectKeyword("break"), this.consumeSemicolon(), this.finalize(e8, new a2());
  }
  parseReturnStatement() {
    this.config.globalReturn || this.context.inFunctionBody || this.tolerateError(e5.IllegalReturn);
    const e8 = this.createNode();
    this.expectKeyword("return");
    const t2 = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== e7.EOF || this.lookahead.type === e7.StringLiteral || this.lookahead.type === e7.Template ? this.parseExpression() : null;
    return this.consumeSemicolon(), this.finalize(e8, new B(t2));
  }
  parseStatement() {
    let e8;
    switch (this.lookahead.type) {
      case e7.BooleanLiteral:
      case e7.NullLiteral:
      case e7.NumericLiteral:
      case e7.StringLiteral:
      case e7.Template:
      case e7.Identifier:
        e8 = this.parseExpressionStatement();
        break;
      case e7.Punctuator: {
        const t2 = this.lookahead.value;
        e8 = "{" === t2 ? this.parseBlockOrObjectStatement() : "(" === t2 ? this.parseExpressionStatement() : ";" === t2 ? this.parseEmptyStatement() : this.parseExpressionStatement();
        break;
      }
      case e7.Keyword:
        switch (this.lookahead.value.toLowerCase()) {
          case "break":
            e8 = this.parseBreakStatement();
            break;
          case "continue":
            e8 = this.parseContinueStatement();
            break;
          case "for":
            e8 = this.parseForStatement();
            break;
          case "function":
            e8 = this.parseFunctionDeclaration();
            break;
          case "if":
            e8 = this.parseIfStatement();
            break;
          case "return":
            e8 = this.parseReturnStatement();
            break;
          case "var":
            e8 = this.parseVariableStatement();
            break;
          default:
            e8 = this.parseExpressionStatement();
        }
        break;
      default:
        e8 = this.throwUnexpectedToken(this.lookahead);
    }
    return e8;
  }
  parseFunctionSourceElements() {
    const e8 = this.createNode();
    this.expect("{");
    const t2 = this.context.inIteration, i3 = this.context.inFunctionBody;
    this.context.inIteration = false, this.context.inFunctionBody = true;
    const s4 = [];
    for (; this.lookahead.type !== e7.EOF && !this.match("}"); )
      s4.push(this.parseStatementListItem());
    return this.expect("}"), this.context.inIteration = t2, this.context.inFunctionBody = i3, this.finalize(e8, new p3(s4));
  }
  parseFormalParameters() {
    const e8 = [];
    if (this.expect("("), !this.match(")"))
      for (; this.lookahead.type !== e7.EOF && (e8.push(this.parseVariableIdentifier()), !this.match(")")) && (this.expect(","), !this.match(")")); )
        ;
    return this.expect(")"), e8;
  }
  parseFunctionDeclaration() {
    const e8 = this.createNode();
    this.expectKeyword("function");
    const t2 = this.parseVariableIdentifier(), i3 = this.parseFormalParameters(), s4 = this.parseFunctionSourceElements();
    return this.finalize(e8, new g(t2, i3, s4));
  }
  parseScript() {
    const e8 = this.createNode(), t2 = [];
    for (; this.lookahead.type !== e7.EOF; )
      t2.push(this.parseStatementListItem());
    return this.finalize(e8, new D2(t2));
  }
};

// node_modules/@arcgis/core/arcade/lib/arcade-parser.js
function o3(r7, o4, n3) {
  let a4 = null;
  const s4 = (e8, t2) => {
    n3 && n3(e8, t2), a4 && a4.visit(e8, t2);
  };
  let m6 = "function" == typeof n3 ? s4 : void 0, i3 = false;
  if (o4) {
    i3 = "boolean" == typeof o4.comment && o4.comment;
    const t2 = "boolean" == typeof o4.attachComment && o4.attachComment;
    (i3 || t2) && (a4 = new e4(), a4.attach = t2, o4.comment = true, m6 = s4);
  }
  const p4 = new O3(r7, o4, m6), c2 = p4.parseScript();
  return i3 && a4 && (c2.comments = a4.comments), p4.config.tokens && (c2.tokens = p4.tokens), p4.config.tolerant && (c2.errors = p4.errorHandler.errors), c2;
}

// node_modules/@arcgis/core/arcade/parser.js
function a3(r7, t2 = []) {
  const o4 = o3("function _() { " + r7 + "\n}");
  if (null === o4.body || void 0 === o4.body)
    throw new Error("No formula provided.");
  if (0 === o4.body.length)
    throw new Error("No formula provided.");
  if (0 === o4.body.length)
    throw new Error("No formula provided.");
  if ("BlockStatement" !== o4.body[0].body.type)
    throw new Error("Invalid formula content.");
  const i3 = E2(o4);
  if ("" !== i3)
    throw new Error(i3);
  return h2(o4, t2), o4;
}
function s3(n3, e8, t2, o4, i3) {
  const c2 = [], l3 = "function _() { \n".length - 1, a4 = "function _() { \n" + n3 + "\n}";
  try {
    const n4 = o3(a4, { tolerant: true, loc: true, range: true }), s4 = n4.errors;
    if (s4.length > 0)
      for (let e9 = 0; e9 < s4.length; e9++)
        c2.push({ line: s4[e9].lineNumber - 2, character: s4[e9].column, reason: s4[e9].description });
    const f4 = A2(n4, e8, t2, o4, i3);
    for (let e9 = 0; e9 < f4.length; e9++)
      f4[e9].line = f4[e9].line - 2, f4[e9].range && (f4[e9].range = [f4[e9][0] - l3, f4[e9][1] - l3]), f4[e9].loc && (f4[e9].loc.start.line = f4[e9].loc.start.line - 2, f4[e9].loc.end.line = f4[e9].loc.end.line - 2), c2.push(f4[e9]);
  } catch (s4) {
    try {
      if ("Unexpected token }" === s4.description) {
        const n4 = a4.split("\n").length;
        s4.lineNumber === n4 ? (s4.index = a4.length - 1, c2.push({ line: s4.lineNumber - 4, character: s4.column, reason: "Unexpected end of script" })) : (s4.index = a4.length - 1, c2.push({ line: s4.lineNumber - 2, character: s4.column, reason: "Unexpected end of script" }));
      } else
        c2.push({ line: s4.lineNumber - 2, character: s4.column, reason: s4.description });
    } catch (f4) {
    }
  }
  return c2;
}
function f3(n3, e8) {
  return f(n3);
}
function d5(n3, e8, r7) {
  return S(n3, e8, r7);
}
function h5(n3) {
  return d3(n3);
}

// node_modules/@arcgis/core/chunks/arcade.js
var y3 = ["feature", "angle", "bearing", "centroid", "envelopeintersects", "extent", "geometry", "isselfintersecting", "ringisclockwise"];
function S3() {
  return true;
}
var b3 = S3();
var x2 = false;
var A4 = false;
var g2 = null;
var j4 = [];
function h6(t2, r7) {
  if (true === r7.useAsync || true === t2.isAsync)
    return w2(t2, r7);
  if (a("esri-csp-restrictions")) {
    return function(e8) {
      return Be2(t2, e8);
    };
  }
  return $e(t2, r7);
}
function w2(t2, r7) {
  if (null === g2)
    throw new Error("Async Arcade must be enabled for this script");
  if (a("esri-csp-restrictions") || false === b3) {
    return function(e8) {
      return g2.executeScript(t2, e8);
    };
  }
  return $e(t2, r7, true);
}
function F2(e8) {
  Ve2(e8), Ve(e8, "sync"), null === g2 ? j4.push(e8) : (Ve(e8, "async"), g2.extend(e8));
}
function E4(e8, t2 = []) {
  return a3(e8, t2);
}
function v4(e8, t2, r7 = "") {
  return d5(e8, t2, r7);
}
function G2(e8, t2, r7, n3 = "") {
  return s3(e8, t2, r7, n3);
}
function k5(e8, t2, r7 = []) {
  return I3(a3(e8, r7), t2);
}
function I3(e8, t2) {
  if (true === t2.useAsync || true === e8.isAsync) {
    if (null === g2)
      throw new Error("Async Arcade must be enabled for this script");
    return g2.executeScript(e8, t2);
  }
  return Be2(e8, t2);
}
function L3(e8, t2) {
  return qe(e8, t2);
}
function P4(e8, t2) {
  return Ze(e8, t2);
}
function U(e8, t2 = false) {
  return f3(e8);
}
function _2(e8) {
  return h5(e8);
}
function C2(e8, t2 = []) {
  return void 0 === e8.usesGeometry && h2(e8, t2), true === e8.usesGeometry;
}
var M4 = null;
function z3() {
  return M4 || (M4 = O4(), M4);
}
async function O4() {
  const [e8, t2] = await Promise.all([import("./@arcgis_core_geometry_geometryEngine.js"), import("./geomsync-W2NLIZSX.js")]);
  return A4 = true, t2.setGeometryEngine(e8), true;
}
var R2 = null;
function T() {
  return null !== R2 || (R2 = q2()), R2;
}
async function q2() {
  await et(), g2 = await import("./arcadeAsyncRuntime-SWU57VX7.js");
  for (const e8 of j4)
    g2.extend(e8), Ve(e8, "async");
  return j4 = null, true;
}
function D4() {
  return x2;
}
function B2() {
  return !!g2;
}
function H() {
  return A4;
}
var J2 = null;
function K() {
  return J2 || (J2 = N3(), J2);
}
async function N3() {
  await T();
  const [e8, r7, n3, s4, i3] = await Promise.all([import("./featureSetUtils-2VZKJJVA.js"), import("./featuresetbase-NXE2GIFE.js"), import("./featuresetgeom-6Y7AJXZ2.js"), import("./featuresetstats-LXQWWQBQ.js"), import("./featuresetstring-5ZU6QDKX.js")]);
  return Z = e8, g2.extend([r7, n3, s4, i3]), Ve([r7, n3, s4, i3], "async"), x2 = true, true;
}
function Q3(e8, t2 = []) {
  return void 0 === e8.usesFeatureSet && h2(e8, t2), true === e8.usesFeatureSet;
}
function V(e8, t2 = []) {
  return void 0 === e8.isAsync && h2(e8, t2), true === e8.isAsync;
}
function W2(e8, t2) {
  if (t2) {
    for (const r7 of t2)
      if (L3(e8, r7))
        return true;
    return false;
  }
  return false;
}
async function X2(e8, t2, r7 = [], n3 = false) {
  const s4 = "string" == typeof e8 ? E4(e8) : e8, i3 = [];
  return s4 && (false === H() && (C2(s4) || n3) && i3.push(z3()), false === B2() && (true === s4.isAsync || t2) && i3.push(T()), false === D4() && (Q3(s4) || W2(s4, r7)) && i3.push(K())), !i3.length || (await Promise.all(i3), true);
}
function Y2(e8) {
  if (C2(e8))
    return true;
  const t2 = I(e8);
  let r7 = false;
  for (let n3 = 0; n3 < t2.length; n3++)
    if (y3.includes(t2[n3])) {
      r7 = true;
      break;
    }
  return r7;
}
var Z = null;
function $2() {
  return Z;
}
var ee3 = Object.freeze(Object.defineProperty({ __proto__: null, compileScript: h6, extend: F2, parseScript: E4, validateScript: v4, scriptCheck: G2, parseAndExecuteScript: k5, executeScript: I3, referencesMember: L3, referencesFunction: P4, extractFieldLiterals: U, extractExpectedFieldLiterals: _2, scriptUsesGeometryEngine: C2, enableGeometrySupport: z3, enableGeometrySupportImpl: O4, enableAsyncSupport: T, enableAsyncSupportImpl: q2, isFeatureSetSupportEnabled: D4, isAsyncEnabled: B2, isGeometryEnabled: H, enableFeatureSetSupport: K, enableFeatureSetSupportImpl: N3, scriptUsesFeatureSet: Q3, scriptIsAsync: V, loadScriptDependencies: X2, scriptTouchesGeometry: Y2, featureSetUtils: $2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/support/arcadeUtils.js
var M5 = /^\$(feature|aggregatedFeatures)\./i;
var P5 = { vars: { $feature: "any", $view: "any" }, spatialReference: null };
function k6(e8) {
  return e8.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
}
function I4(e8) {
  return null == e8 ? null : L(e8) || E(e8) ? "array" : z(e8) ? "date" : w(e8) ? "text" : _(e8) ? "boolean" : O(e8) ? "number" : e8 instanceof d ? "dictionary" : Y(e8) ? "feature" : e8 instanceof j ? "point" : e8 instanceof v ? "polygon" : e8 instanceof m3 ? "polyline" : e8 instanceof m2 ? "multipoint" : e8 instanceof M ? "extent" : J(e8) ? "featureSet" : P(e8) ? "featureSetCollection" : null;
}
function A5(r7) {
  if (!r7)
    return null;
  try {
    return E4(r7);
  } catch (n3) {
  }
  return null;
}
function D5(e8, n3) {
  const t2 = "string" == typeof e8 ? A5(e8) : e8;
  if (!t2)
    return null;
  try {
    return n3 = n3 || m(P5), h6(t2, n3);
  } catch (o4) {
  }
  return null;
}
function G3(e8, r7) {
  return { vars: { $feature: null == e8 ? new d2() : d2.createFromGraphic(e8), $view: r7 && r7.view }, spatialReference: r7 && r7.sr };
}
function V2(e8, r7, n3) {
  return d2.createFromGraphicLikeObject(r7, e8, n3);
}
function L4(e8, r7) {
  e8.vars.$feature = r7;
}
function U2(e8, r7) {
  let t2;
  try {
    t2 = I3(e8, r7);
  } catch (o4) {
    t2 = null;
  }
  return t2;
}
function q3(e8, r7) {
  let n3;
  try {
    n3 = e8 ? e8(r7) : null;
  } catch (t2) {
    n3 = null;
  }
  return n3;
}
function O5(e8, r7) {
  try {
    return e8 ? e8(r7) : Promise.resolve(null);
  } catch (n3) {
    return Promise.resolve(null);
  }
}
function T2(e8, r7) {
  if (!e8)
    return [];
  const n3 = "string" == typeof e8 ? A5(e8) : e8;
  if (!n3)
    return [];
  const o4 = _2(n3);
  let i3 = new Array();
  o4.forEach((e9) => {
    M5.test(e9) && (e9 = e9.replace(M5, ""), i3.push(e9));
  });
  const s4 = i3.filter((e9) => e9.includes("*"));
  return i3 = i3.filter((e9) => !s4.includes(e9)), r7 && s4.forEach((e9) => {
    const n4 = new RegExp(`^${e9.split(/\*+/).map(k6).join(".*")}$`, "i");
    r7.forEach((e10) => n4.test(e10) ? i3.push(e10) : null);
  }), [...new Set(i3.sort())];
}
function B3(e8) {
  return L3(e8, "$view");
}
function H2(e8, r7) {
  return !!e8 && L3(e8, r7);
}
function J3(e8) {
  if (!e8 || null == e8.spatialReference && (null == e8.scale || null == e8.viewingMode))
    return;
  return { view: e8.viewingMode && null != e8.scale ? new d({ viewingMode: e8.viewingMode, scale: e8.scale }) : null, sr: e8.spatialReference };
}
function K2({ url: e8, spatialReference: r7, lrucache: n3, interceptor: t2 }) {
  const o4 = $2();
  return o4 ? o4.createFeatureSetCollectionFromService(e8, r7, n3, t2) : null;
}
function N4({ layer: e8, spatialReference: r7, outFields: n3, returnGeometry: t2, lrucache: o4, interceptor: i3 }) {
  if (null === e8)
    return null;
  const s4 = $2();
  return s4 ? s4.constructFeatureSet(e8, r7, n3, t2 ?? true, o4, i3) : null;
}
function Q4(e8) {
  if (null === (e8 == null ? void 0 : e8.map))
    return null;
  const r7 = $2();
  return r7 ? r7.createFeatureSetCollectionFromMap(e8.map, e8.spatialReference, e8.lrucache, e8.interceptor) : null;
}
function W3(e8, r7, n3 = []) {
  return X2(e8, r7, n3);
}
function X3() {
  return z3();
}
function Y3() {
  return K();
}
function Z2(e8) {
  return "simple" === e8.type || "class-breaks" === e8.type || "unique-value" === e8.type || "dot-density" === e8.type || "dictionary" === e8.type || "pie-chart" === e8.type;
}
function _3(e8) {
  return "esri.layers.support.LabelClass" === e8.declaredClass;
}
function ee4(e8) {
  return "esri.PopupTemplate" === e8.declaredClass;
}
function re3(e8, r7) {
  if (!e8)
    return false;
  if ("string" == typeof e8)
    return r7(e8);
  const n3 = e8;
  if (Z2(n3)) {
    if ("dot-density" === n3.type) {
      const e10 = n3.attributes.some((e11) => r7(e11.valueExpression));
      if (e10)
        return e10;
    }
    const e9 = n3.visualVariables, t2 = !!e9 && e9.some((e10) => {
      let n4 = r7(e10.valueExpression);
      return "size" === e10.type && (e2(e10.minSize) && (n4 = n4 || r7(e10.minSize.valueExpression)), e2(e10.maxSize) && (n4 = n4 || r7(e10.maxSize.valueExpression))), n4;
    });
    return !(!("valueExpression" in n3) || !r7(n3.valueExpression)) || t2;
  }
  if (_3(n3)) {
    const e9 = n3.labelExpressionInfo && n3.labelExpressionInfo.expression;
    return !(!e9 || !r7(e9)) || false;
  }
  return !!ee4(n3) && (!!n3.expressionInfos && n3.expressionInfos.some((e9) => r7(e9.expression)) || Array.isArray(n3.content) && n3.content.some((e9) => {
    var _a;
    return "expression" === e9.type && r7((_a = e9.expressionInfo) == null ? void 0 : _a.expression);
  }));
}
function ne4(e8) {
  const r7 = A5(e8);
  return !!r7 && Y2(r7);
}
function te3(e8) {
  return re3(e8, ne4);
}
function oe3(e8) {
  const r7 = A5(e8);
  return !!r7 && C2(r7);
}
function ie3(e8) {
  return re3(e8, oe3);
}
export {
  d as Dictionary,
  ee3 as arcade,
  d2 as arcadeFeature,
  N4 as convertFeatureLayerToFeatureSet,
  Q4 as convertMapToFeatureSetCollection,
  K2 as convertServiceUrlToWorkspace,
  G3 as createExecContext,
  V2 as createFeature,
  D5 as createFunction,
  A5 as createSyntaxTree,
  B3 as dependsOnView,
  Y3 as enableFeatureSetOperations,
  X3 as enableGeometryOperations,
  U2 as evalSyntaxTree,
  O5 as executeAsyncFunction,
  q3 as executeFunction,
  T2 as extractFieldNames,
  I4 as getArcadeType,
  J3 as getViewInfo,
  te3 as hasGeometryFunctions,
  ie3 as hasGeometryOperations,
  H2 as hasVariable,
  W3 as loadScriptDependencies,
  L4 as updateExecContext
};
//# sourceMappingURL=arcadeUtils-7D7J3JER.js.map
