import {
  e as e2
} from "./chunk-YL26MZEL.js";
import {
  a as a3,
  e,
  s as s3
} from "./chunk-GVELBHGI.js";
import {
  r as r2
} from "./chunk-2QOWZFCU.js";
import {
  T,
  f,
  g,
  k,
  m,
  p,
  r2 as r3,
  v
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  a,
  a2,
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/core/workers/utils.js
var e3;
!function(t) {
  t[t.HANDSHAKE = 0] = "HANDSHAKE", t[t.OPEN = 1] = "OPEN", t[t.OPENED = 2] = "OPENED", t[t.RESPONSE = 3] = "RESPONSE", t[t.INVOKE = 4] = "INVOKE", t[t.ABORT = 5] = "ABORT", t[t.CLOSE = 6] = "CLOSE", t[t.OPEN_PORT = 7] = "OPEN_PORT", t[t.ON = 8] = "ON";
}(e3 || (e3 = {}));
var r4 = 0;
function n() {
  return r4++;
}
function s4(t) {
  return t && "object" == typeof t && ("result" in t || "transferList" in t);
}
function a4(t) {
  return t ? "string" == typeof t ? JSON.stringify({ name: "message", message: t }) : t.toJSON ? JSON.stringify(t) : JSON.stringify({ name: t.name, message: t.message, details: t.details || { stack: t.stack } }) : null;
}
function i(t, r5, n2, a5) {
  if (r5.type === e3.OPEN_PORT)
    return void t.postMessage(r5, [r5.port]);
  if (r5.type !== e3.INVOKE && r5.type !== e3.RESPONSE)
    return void t.postMessage(r5);
  let i2;
  s4(n2) ? (i2 = o(n2.transferList), r5.data = n2.result) : (i2 = o(a5), r5.data = n2), i2 ? t.postMessage(r5, i2) : t.postMessage(r5);
}
function f2(t) {
  if (!t)
    return null;
  const e4 = t.data;
  return e4 ? "string" == typeof e4 ? JSON.parse(e4) : e4 : null;
}
function o(e4) {
  if (!e4 || !e4.length)
    return null;
  if (a("esri-workers-arraybuffer-transfer"))
    return e4;
  const r5 = e4.filter((t) => !u(t));
  return r5.length ? r5 : null;
}
function u(t) {
  return t instanceof ArrayBuffer || t && t.constructor && "ArrayBuffer" === t.constructor.name;
}

// node_modules/@arcgis/core/core/workers/RemoteClient.js
var k2 = { statsWorker: () => import("./statsWorker-7L6GTKSV.js"), geometryEngineWorker: () => import("./geometryEngineWorker-2PSD3HXB.js"), CSVSourceWorker: () => import("./CSVSourceWorker-KVPMELT7.js"), EdgeProcessingWorker: () => import("./EdgeProcessingWorker-IVVVSALQ.js"), ElevationSamplerWorker: () => import("./ElevationSamplerWorker-XX2HYHFX.js"), FeatureServiceSnappingSourceWorker: () => import("./FeatureServiceSnappingSourceWorker-EDREYCPC.js"), GeoJSONSourceWorker: () => import("./GeoJSONSourceWorker-OZBX3OMN.js"), LercWorker: () => import("./LercWorker-GNU7RR67.js"), MemorySourceWorker: () => import("./MemorySourceWorker-PZND2NTI.js"), PBFDecoderWorker: () => import("./PBFDecoderWorker-BN2KIL57.js"), Pipeline: () => import("./Pipeline-JZK3BDGV.js"), PointCloudWorker: () => import("./PointCloudWorker-MMQR3G7R.js"), RasterWorker: () => import("./RasterWorker-GXHNZJWN.js"), SceneLayerSnappingSourceWorker: () => import("./SceneLayerSnappingSourceWorker-DLNSID4I.js"), SceneLayerWorker: () => import("./SceneLayerWorker-PJUMIC65.js"), WFSSourceWorker: () => import("./WFSSourceWorker-FWR36XXO.js"), WorkerTileHandler: () => import("./WorkerTileHandler-55UNHDN7.js") };
var { CLOSE: b, ABORT: v2, INVOKE: y, RESPONSE: j, OPEN_PORT: S, ON: f3 } = e3;
var W = 2;
var M = class {
  constructor(e4) {
    this._timer = null, this._cancelledJobIds = /* @__PURE__ */ new Set(), this._invokeMessages = [], this._invoke = e4, this._timer = null, this._process = this._process.bind(this);
  }
  push(e4) {
    e4.type === e3.ABORT ? this._cancelledJobIds.add(e4.jobId) : (this._invokeMessages.push(e4), null === this._timer && (this._timer = setTimeout(this._process, 0)));
  }
  clear() {
    this._invokeMessages.length = 0, this._cancelledJobIds.clear(), this._timer = null;
  }
  _process() {
    this._timer = null;
    for (const e4 of this._invokeMessages)
      this._cancelledJobIds.has(e4.jobId) || this._invoke(e4);
    this._cancelledJobIds.clear(), this._invokeMessages.length = 0;
  }
};
var w = class {
  constructor(e4, s5, t) {
    this._port = e4, this._getNextJob = t, this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this._invokeQueue = new M((e5) => this._onInvokeMessage(e5)), this._client = s5.client, this._onMessage = this._onMessage.bind(this), this._channel = s5.channel, this._schedule = s5.schedule, this._port.addEventListener("message", this._onMessage), this._port.start();
  }
  static connect(e4) {
    const s5 = new MessageChannel();
    let t;
    t = "function" == typeof e4 ? new e4() : "default" in e4 && "function" == typeof e4.default ? new e4.default() : e4;
    const o2 = new w(s5.port1, { channel: s5, client: t }, () => null);
    return "object" == typeof t && "remoteClient" in t && (t.remoteClient = o2), w.clients.set(o2, t), s5.port2;
  }
  static loadWorker(e4) {
    const s5 = k2[e4];
    return s5 ? s5() : Promise.resolve(null);
  }
  close() {
    this._post({ type: b }), this._close();
  }
  isBusy() {
    return this._outJobs.size > 0;
  }
  invoke(e4, t, r5) {
    const c2 = r5 && r5.signal, l = r5 && r5.transferList;
    if (!this._port)
      return Promise.reject(new s2("worker:port-closed", `Cannot call invoke('${e4}'), port is closed`, { methodName: e4, data: t }));
    const h2 = n();
    return new Promise((s5, r6) => {
      if (p(c2))
        return this._processWork(), void r6(m());
      const p2 = v(c2, () => {
        const e5 = this._outJobs.get(h2);
        e5 && (this._outJobs.delete(h2), this._processWork(), a2(e5.abortHandle), this._post({ type: v2, jobId: h2 }), r6(m()));
      }), u2 = { resolve: s5, reject: r6, abortHandle: p2, debugInfo: e4 };
      this._outJobs.set(h2, u2), this._post({ type: y, jobId: h2, methodName: e4, abortable: null != c2 }, t, l);
    });
  }
  on(e4, s5) {
    const t = new MessageChannel();
    function o2(e5) {
      s5(e5.data);
    }
    return this._port.postMessage({ type: e3.ON, eventType: e4, port: t.port2 }, [t.port2]), t.port1.addEventListener("message", o2), t.port1.start(), { remove() {
      t.port1.postMessage({ type: e3.CLOSE }), t.port1.close(), t.port1.removeEventListener("message", o2);
    } };
  }
  jobAdded() {
    this._processWork();
  }
  openPort() {
    const e4 = new MessageChannel();
    return this._post({ type: S, port: e4.port2 }), e4.port1;
  }
  _processWork() {
    if (this._outJobs.size >= W)
      return;
    const e4 = this._getNextJob();
    if (!e4)
      return;
    const { methodName: s5, data: t, invokeOptions: o2, deferred: r5 } = e4;
    this.invoke(s5, t, o2).then((e5) => r5.resolve(e5)).catch((e5) => r5.reject(e5));
  }
  _close() {
    this._channel && (this._channel = null), this._port.removeEventListener("message", this._onMessage), this._port.close(), this._outJobs.forEach((e4) => {
      a2(e4.abortHandle), e4.reject(m(`Worker closing, aborting job calling '${e4.debugInfo}'`));
    }), this._inJobs.clear(), this._outJobs.clear(), this._invokeQueue.clear(), this._port = this._client = this._schedule = null;
  }
  _onMessage(e4) {
    r(this._schedule) ? this._schedule(() => this._processMessage(e4)) : this._processMessage(e4);
  }
  _processMessage(e4) {
    const s5 = f2(e4);
    if (s5)
      switch (s5.type) {
        case j:
          this._onResponseMessage(s5);
          break;
        case y:
          this._invokeQueue.push(s5);
          break;
        case v2:
          this._onAbortMessage(s5);
          break;
        case b:
          this._onCloseMessage();
          break;
        case S:
          this._onOpenPortMessage(s5);
          break;
        case f3:
          this._onOnMessage(s5);
      }
  }
  _onAbortMessage(e4) {
    const s5 = this._inJobs, t = e4.jobId, o2 = s5.get(t);
    this._invokeQueue.push(e4), o2 && (o2.controller && o2.controller.abort(), s5.delete(t));
  }
  _onCloseMessage() {
    const e4 = this._client;
    this._close(), e4 && "destroy" in e4 && w.clients.get(this) === e4 && e4.destroy(), w.clients.delete(this), e4 && e4.remoteClient && (e4.remoteClient = null);
  }
  _onInvokeMessage(e4) {
    const { methodName: s5, jobId: t, data: o2, abortable: r5 } = e4, i2 = r5 ? new AbortController() : null, n2 = this._inJobs;
    let a5, p2 = this._client, h2 = p2[s5];
    try {
      if (!h2 && s5 && s5.includes(".")) {
        const e5 = s5.split(".");
        for (let s6 = 0; s6 < e5.length - 1; s6++)
          p2 = p2[e5[s6]], h2 = p2[e5[s6 + 1]];
      }
      if ("function" != typeof h2)
        throw new TypeError(`${s5} is not a function`);
      a5 = h2.call(p2, o2, { client: this, signal: i2 ? i2.signal : null });
    } catch (u2) {
      return void this._post({ type: j, jobId: t, error: a4(u2) });
    }
    k(a5) ? (n2.set(t, { controller: i2, promise: a5 }), a5.then((e5) => {
      n2.has(t) && (n2.delete(t), this._post({ type: j, jobId: t }, e5));
    }, (e5) => {
      n2.has(t) && (n2.delete(t), g(e5) || this._post({ type: j, jobId: t, error: a4(e5 || { message: `Error encountered at method ${s5}` }) }));
    })) : this._post({ type: j, jobId: t }, a5);
  }
  _onOpenPortMessage(e4) {
    new w(e4.port, { client: this._client }, () => null);
  }
  _onOnMessage(e4) {
    const { port: s5 } = e4, o2 = this._client.on(e4.eventType, (e5) => {
      s5.postMessage(e5);
    }), r5 = r3(e4.port, "message", (e5) => {
      f2(e5).type === e3.CLOSE && (r5.remove(), o2.remove(), s5.close());
    });
  }
  _onResponseMessage(e4) {
    const { jobId: t, error: r5, data: i2 } = e4, n2 = this._outJobs;
    if (!n2.has(t))
      return;
    const a5 = n2.get(t);
    this._processWork(), n2.delete(t), a2(a5.abortHandle), r5 ? a5.reject(s2.fromJSON(JSON.parse(r5))) : a5.resolve(i2);
  }
  _post(e4, s5, t) {
    return i(this._port, e4, s5, t);
  }
};
w.kernelInfo = { revision: a3, version: s3, buildDate: e }, w.clients = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/core/workers/Connection.js
var h = s.getLogger("esri.core.workers.Connection");
var c = class {
  constructor() {
    this._inUseClients = new Array(), this._clients = new Array(), this._clientPromises = new Array(), this._ongoingJobsQueue = new e2();
  }
  destroy() {
    this.close();
  }
  get closed() {
    return !this._clients || !this._clients.length;
  }
  open(e4, t) {
    return new Promise((n2, i2) => {
      let r5 = true;
      const h2 = (e5) => {
        f(t.signal), r5 && (r5 = false, e5());
      };
      this._clients.length = e4.length, this._clientPromises.length = e4.length, this._inUseClients.length = e4.length;
      for (let o2 = 0; o2 < e4.length; ++o2) {
        const r6 = e4[o2];
        k(r6) ? this._clientPromises[o2] = r6.then((e5) => (this._clients[o2] = new w(e5, t, () => this._ongoingJobsQueue.pop()), h2(n2), this._clients[o2]), () => (h2(i2), null)) : (this._clients[o2] = new w(r6, t, () => this._ongoingJobsQueue.pop()), this._clientPromises[o2] = Promise.resolve(this._clients[o2]), h2(n2));
      }
    });
  }
  broadcast(e4, t, s5) {
    const n2 = new Array(this._clientPromises.length);
    for (let i2 = 0; i2 < this._clientPromises.length; ++i2) {
      const o2 = this._clientPromises[i2];
      n2[i2] = o2.then((n3) => n3.invoke(e4, t, s5));
    }
    return n2;
  }
  close() {
    let e4;
    for (; e4 = this._ongoingJobsQueue.pop(); )
      e4.deferred.reject(m(`Worker closing, aborting job calling '${e4.methodName}'`));
    for (const t of this._clientPromises)
      t.then((e5) => e5.close());
    this._clients.length = 0, this._clientPromises.length = 0;
  }
  invoke(e4, t, s5) {
    let n2 = null;
    Array.isArray(s5) ? (h.warn("invoke()", "The transferList parameter is deprecated, use the options object instead"), n2 = { transferList: s5 }) : n2 = s5;
    const o2 = T();
    this._ongoingJobsQueue.push({ methodName: e4, data: t, invokeOptions: n2, deferred: o2 });
    for (let i2 = 0; i2 < this._clientPromises.length; i2++) {
      const e5 = this._clients[i2];
      e5 ? e5.jobAdded() : this._clientPromises[i2].then((e6) => e6.jobAdded());
    }
    return o2.promise;
  }
  on(t, s5) {
    return Promise.all(this._clientPromises).then(() => r2(this._clients.map((e4) => e4.on(t, s5))));
  }
  openPorts() {
    return new Promise((e4) => {
      const t = new Array(this._clientPromises.length);
      let s5 = t.length;
      for (let n2 = 0; n2 < this._clientPromises.length; ++n2) {
        this._clientPromises[n2].then((i2) => {
          t[n2] = i2.openPort(), 0 == --s5 && e4(t);
        });
      }
    });
  }
  get test() {
    return { numClients: this._clients.length };
  }
};

export {
  e3 as e,
  n,
  a4 as a,
  i,
  f2 as f,
  w,
  c
};
//# sourceMappingURL=chunk-UQDLDM54.js.map
