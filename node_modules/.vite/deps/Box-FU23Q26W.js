import {
  D,
  h as h3
} from "./chunk-WK7SHMYW.js";
import "./chunk-GL3DI4QI.js";
import "./chunk-4OFLHC3C.js";
import {
  e as e2
} from "./chunk-KXA3AZ4N.js";
import {
  h as h2
} from "./chunk-CRCA6KDA.js";
import {
  a,
  i,
  m as m4,
  s
} from "./chunk-PTJ3MGYO.js";
import "./chunk-DSCM4HDL.js";
import "./chunk-RBVTRJPJ.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-Z3S5X75I.js";
import "./chunk-NMRWU44S.js";
import "./chunk-V7M26XZ7.js";
import "./chunk-PZWU5EHT.js";
import "./chunk-BS7TS6UC.js";
import "./chunk-37ZVELW7.js";
import "./chunk-YL26MZEL.js";
import "./chunk-YG6VFATO.js";
import "./chunk-6O2ARNGD.js";
import "./chunk-CQ47VEUP.js";
import "./chunk-D3XXPCBB.js";
import "./chunk-OWBMOIIV.js";
import "./chunk-SIH2IMSA.js";
import "./chunk-2AGPHSDM.js";
import "./chunk-JGSSQ5FR.js";
import "./chunk-5OEHY3VV.js";
import "./chunk-LJLQIETB.js";
import "./chunk-WKRVG5MO.js";
import "./chunk-GRILTTJT.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  f,
  l
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-GD6ALUPQ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import {
  y
} from "./chunk-TADZYUVR.js";
import "./chunk-C5ULLWJ7.js";
import "./chunk-HFDYAQZS.js";
import "./chunk-HJHWUUQQ.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-ZNEGSJWK.js";
import "./chunk-EI4MOLML.js";
import "./chunk-4SBWV5M2.js";
import "./chunk-CF56UYH2.js";
import {
  S,
  m as m3
} from "./chunk-5TRUGQDM.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  u
} from "./chunk-56RHM4A6.js";
import "./chunk-ACJD5XFJ.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-6DWU2ZQF.js";
import "./chunk-Q3R7XFM5.js";
import "./chunk-JCPK2OXG.js";
import "./chunk-HVM5D6S5.js";
import "./chunk-JYHTO6QC.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import {
  n as n2
} from "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import {
  m,
  m2
} from "./chunk-CHNDTVQJ.js";
import {
  h2 as h,
  t,
  v2 as v
} from "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/geometry/support/rotate.js
function i2(n3) {
  let e3 = 0, t2 = 0;
  const r2 = n3.length;
  let i3, o2 = n3[t2];
  for (t2 = 0; t2 < r2 - 1; t2++)
    i3 = n3[t2 + 1], e3 += (i3[0] - o2[0]) * (i3[1] + o2[1]), o2 = i3;
  return e3 >= 0;
}
function o(n3, e3, t2, r2) {
  const i3 = [];
  for (const o2 of n3) {
    const n4 = o2.slice(0);
    i3.push(n4);
    const s3 = e3 * (o2[0] - r2.x) - t2 * (o2[1] - r2.y) + r2.x, c = t2 * (o2[0] - r2.x) + e3 * (o2[1] - r2.y) + r2.y;
    n4[0] = s3, n4[1] = c;
  }
  return i3;
}
function s2(s3, c, a2) {
  const f2 = s3.spatialReference, m5 = c * Math.PI / 180, x = Math.cos(m5), p = Math.sin(m5);
  if ("xmin" in s3 && (a2 = a2 ?? s3.center, s3 = new v({ spatialReference: f2, rings: [[[s3.xmin, s3.ymin], [s3.xmin, s3.ymax], [s3.xmax, s3.ymax], [s3.xmax, s3.ymin], [s3.xmin, s3.ymin]]] })), "paths" in s3) {
    a2 = a2 ?? s3.extent.center;
    const n3 = [];
    for (const e3 of s3.paths)
      n3.push(o(e3, x, p, a2));
    return new m2({ spatialReference: f2, paths: n3 });
  }
  if ("rings" in s3) {
    a2 = a2 ?? s3.extent.center;
    const e3 = [];
    for (const n3 of s3.rings) {
      const t2 = i2(n3), r2 = o(n3, x, p, a2);
      i2(r2) !== t2 && r2.reverse(), e3.push(r2);
    }
    return new v({ spatialReference: f2, rings: e3 });
  }
  if ("x" in s3) {
    a2 = a2 ?? s3;
    const n3 = new j({ x: x * (s3.x - a2.x) - p * (s3.y - a2.y) + a2.x, y: p * (s3.x - a2.x) + x * (s3.y - a2.y) + a2.y, spatialReference: f2 });
    return null != s3.z && (n3.z = s3.z), null != s3.m && (n3.m = s3.m), n3;
  }
  return "points" in s3 ? (a2 = a2 ?? s3.extent.center, new m({ points: o(s3.points, x, p, a2), spatialReference: f2 })) : null;
}

// node_modules/@arcgis/core/views/draw/support/Box.js
var R = class {
  constructor(t2, e3, i3, s3) {
    this.graphics = t2, this.mover = e3, this.dx = i3, this.dy = s3, this.type = "move-start";
  }
};
var I = class {
  constructor(t2, e3, i3, s3) {
    this.graphics = t2, this.mover = e3, this.dx = i3, this.dy = s3, this.type = "move";
  }
};
var C = class {
  constructor(t2, e3, i3, s3) {
    this.graphics = t2, this.mover = e3, this.dx = i3, this.dy = s3, this.type = "move-stop";
  }
};
var H = class {
  constructor(t2, e3, i3) {
    this.graphics = t2, this.mover = e3, this.angle = i3, this.type = "rotate-start";
  }
};
var M = class {
  constructor(t2, e3, i3) {
    this.graphics = t2, this.mover = e3, this.angle = i3, this.type = "rotate";
  }
};
var j2 = class {
  constructor(t2, e3, i3) {
    this.graphics = t2, this.mover = e3, this.angle = i3, this.type = "rotate-stop";
  }
};
var O = class {
  constructor(t2, e3, i3, s3) {
    this.graphics = t2, this.mover = e3, this.xScale = i3, this.yScale = s3, this.type = "scale-start";
  }
};
var E = class {
  constructor(t2, e3, i3, s3) {
    this.graphics = t2, this.mover = e3, this.xScale = i3, this.yScale = s3, this.type = "scale";
  }
};
var B = class {
  constructor(t2, e3, i3, s3) {
    this.graphics = t2, this.mover = e3, this.xScale = i3, this.yScale = s3, this.type = "scale-stop";
  }
};
var L = h2.transformGraphics;
var Y = { centerIndicator: new y({ style: "cross", size: L.center.size, color: L.center.color }), fill: { default: new S({ color: L.fill.color, outline: { color: L.fill.outlineColor, join: "round", width: 1 } }), active: new S({ color: L.fill.stagedColor, outline: { color: L.fill.outlineColor, join: "round", style: "dash", width: 1 } }) }, handles: { default: new y({ style: "square", size: L.vertex.size, color: L.vertex.color, outline: { color: L.vertex.outlineColor, width: 1 } }), hover: new y({ style: "square", size: L.vertex.hoverSize, color: L.vertex.hoverColor, outline: { color: L.vertex.hoverOutlineColor, width: 1 } }) }, rotator: { default: new y({ style: "circle", size: L.vertex.size, color: L.vertex.color, outline: { color: L.vertex.outlineColor, width: 1 } }), hover: new y({ style: "circle", size: L.vertex.hoverSize, color: L.vertex.hoverColor, outline: { color: L.vertex.hoverOutlineColor, width: 1 } }) }, rotatorLine: new m3({ color: L.line.color, width: 1 }) };
var z = class extends n2.EventedAccessor {
  constructor(t2) {
    super(t2), this._activeHandleGraphic = null, this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._centerGraphic = null, this._backgroundGraphic = null, this._vertexGraphics = [], this._rotateHandleGraphic = null, this._rotateGraphicOffset = 20, this._angleOfRotation = 0, this._rotateLineGraphic = null, this._startInfo = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this.type = "box", this.callbacks = { onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onScaleStart() {
    }, onScale() {
    }, onScaleStop() {
    }, onRotateStart() {
    }, onRotate() {
    }, onRotateStop() {
    }, onGraphicClick() {
    } }, this.enableMovement = true, this.enableRotation = true, this.enableScaling = true, this.graphics = [], this.highlightsEnabled = true, this.layer = null, this.preserveAspectRatio = false, this.showCenterGraphic = true, this.symbols = Y, this.view = null, this._getBounds = (() => {
      const t3 = u();
      return (e3, i3) => {
        e3[0] = Number.POSITIVE_INFINITY, e3[1] = Number.POSITIVE_INFINITY, e3[2] = Number.NEGATIVE_INFINITY, e3[3] = Number.NEGATIVE_INFINITY;
        for (const s3 of i3) {
          if (!s3)
            continue;
          let i4, r2, o2, a2;
          if ("point" === s3.type)
            i4 = o2 = s3.x, r2 = a2 = s3.y;
          else if ("multipoint" === s3.type) {
            const e4 = t(s3);
            [i4, r2, o2, a2] = h(t3, [e4]);
          } else if ("extent" === s3.type)
            [i4, r2, o2, a2] = [s3.xmin, s3.ymin, s3.xmax, s3.ymax];
          else {
            const e4 = t(s3);
            [i4, r2, o2, a2] = h(t3, e4);
          }
          e3[0] = Math.min(i4, e3[0]), e3[1] = Math.min(r2, e3[1]), e3[2] = Math.max(o2, e3[2]), e3[3] = Math.max(a2, e3[3]);
        }
        return e3;
      };
    })();
  }
  initialize() {
    this._highlightHelper = new h3({ view: this.view }), this._setup(), this.own([f(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.ready;
    }, () => {
      const { layer: t2, view: e3 } = this;
      e2(e3, t2);
    }, { once: true, initial: true }), l(() => this.preserveAspectRatio, () => {
      this._activeHandleGraphic && (this._scaleGraphic(this._activeHandleGraphic), this._updateGraphics());
    }), l(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.scale;
    }, () => {
      this._updateRotateGraphic(), this._updateRotateLineGraphic();
    }), l(() => this.graphics, () => this.refresh()), l(() => this.layer, (t2, e3) => {
      e3 && this._resetGraphics(e3), this.refresh();
    }), l(() => this.highlightsEnabled, () => {
      var _a;
      (_a = this._highlightHelper) == null ? void 0 : _a.removeAll(), this._setUpHighlights();
    }), this.on("move-start", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onMoveStart) == null ? void 0 : _b.call(_a, t2);
    }), this.on("move", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onMove) == null ? void 0 : _b.call(_a, t2);
    }), this.on("move-stop", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onMoveStop) == null ? void 0 : _b.call(_a, t2);
    }), this.on("rotate-start", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onRotateStart) == null ? void 0 : _b.call(_a, t2);
    }), this.on("rotate", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onRotate) == null ? void 0 : _b.call(_a, t2);
    }), this.on("rotate-stop", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onRotateStop) == null ? void 0 : _b.call(_a, t2);
    }), this.on("scale-start", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onScaleStart) == null ? void 0 : _b.call(_a, t2);
    }), this.on("scale", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onScale) == null ? void 0 : _b.call(_a, t2);
    }), this.on("scale-stop", (t2) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onScaleStop) == null ? void 0 : _b.call(_a, t2);
    })]);
  }
  destroy() {
    this._reset();
  }
  get state() {
    var _a;
    const t2 = ((_a = this.view) == null ? void 0 : _a.ready) ?? false, e3 = this.graphics.length && this.layer;
    return t2 && e3 ? "active" : t2 ? "ready" : "disabled";
  }
  isUIGraphic(t2) {
    return this._vertexGraphics.includes(t2) || t2 === this._backgroundGraphic || t2 === this._centerGraphic || t2 === this._rotateHandleGraphic || t2 === this._rotateLineGraphic;
  }
  move(t2, e3) {
    if (this._mover && this.graphics.length) {
      for (const i3 of this.graphics) {
        const s3 = i3.geometry, r2 = s(s3, t2, e3, this.view);
        i3.geometry = r2;
      }
      this.refresh(), this.emit("move-stop", new C(this.graphics, null, t2, e3));
    }
  }
  scale(t2, e3) {
    if (this._mover && this.graphics.length) {
      for (const i3 of this.graphics) {
        const s3 = i3.geometry, r2 = i(s3, t2, e3);
        i3.geometry = r2;
      }
      this.refresh(), this.emit("scale-stop", new B(this.graphics, null, t2, e3));
    }
  }
  rotate(t2, e3) {
    if (this._mover && this.graphics.length) {
      if (!e3) {
        const t3 = this._vertexGraphics[1].geometry.x, i3 = this._vertexGraphics[3].geometry.y;
        e3 = new j(t3, i3, this.view.spatialReference);
      }
      for (const i3 of this.graphics) {
        const s3 = i3.geometry, r2 = s2(s3, t2, e3);
        i3.geometry = r2;
      }
      this.refresh(), this.emit("rotate-stop", new j2(this.graphics, null, t2));
    }
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphics = [];
  }
  _setup() {
    "active" === this.state && (this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._updateGraphics());
  }
  _reset() {
    this._highlightHelper.removeAll(), this._resetGraphicStateVars(), this._resetGraphics(), this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetGraphicStateVars() {
    this._startInfo = null, this._activeHandleGraphic = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this._angleOfRotation = 0;
  }
  _resetGraphics(t2) {
    (t2 = t2 || this.layer) && (t2.removeMany(this._vertexGraphics), t2.remove(this._backgroundGraphic), t2.remove(this._centerGraphic), t2.remove(this._rotateHandleGraphic), t2.remove(this._rotateLineGraphic)), this._vertexGraphics = [], this._backgroundGraphic = null, this._centerGraphic = null, this._rotateHandleGraphic = null, this._rotateLineGraphic = null;
  }
  _setupMover() {
    let t2 = [];
    this.enableScaling && (t2 = t2.concat(this._vertexGraphics)), this.enableMovement && (t2 = t2.concat(this.graphics, this._backgroundGraphic)), this.enableRotation && t2.push(this._rotateHandleGraphic), this.showCenterGraphic && t2.push(this._centerGraphic), this._mover = new D({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, view: this.view, graphics: t2, callbacks: { onGraphicClick: (t3) => this._onGraphicClickCallback(t3), onGraphicMoveStart: (t3) => this._onGraphicMoveStartCallback(t3), onGraphicMove: (t3) => this._onGraphicMoveCallback(t3), onGraphicMoveStop: (t3) => this._onGraphicMoveStopCallback(t3), onGraphicPointerOver: (t3) => this._onGraphicPointerOverCallback(t3), onGraphicPointerOut: (t3) => this._onGraphicPointerOutCallback(t3) } });
  }
  _getStartInfo(t2) {
    const [e3, i3, s3, r2] = this._getBoxBounds(u()), o2 = Math.abs(s3 - e3), a2 = Math.abs(r2 - i3), h4 = (s3 + e3) / 2, n3 = (r2 + i3) / 2, { x: l2, y: p } = t2.geometry;
    return { width: o2, height: a2, centerX: h4, centerY: n3, startX: l2, startY: p, graphicInfos: this._getGraphicInfos(), box: this._backgroundGraphic.geometry, rotate: this._rotateHandleGraphic.geometry };
  }
  _getGraphicInfos() {
    return this.graphics.map((t2) => this._getGraphicInfo(t2));
  }
  _getGraphicInfo(t2) {
    const e3 = t2.geometry, [i3, s3, r2, o2] = this._getBounds(u(), [e3]);
    return { width: Math.abs(r2 - i3), height: Math.abs(o2 - s3), centerX: (r2 + i3) / 2, centerY: (o2 + s3) / 2, geometry: e3 };
  }
  _onGraphicClickCallback(t2) {
    t2.viewEvent.stopPropagation(), this.emit("graphic-click", t2), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(t2);
  }
  _onGraphicMoveStartCallback(t2) {
    const { _angleOfRotation: e3, _xScale: i3, _yScale: s3, _backgroundGraphic: r2, _vertexGraphics: o2, _rotateHandleGraphic: a2, symbols: h4 } = this, c = t2.graphic;
    this._resetGraphicStateVars(), this._hideGraphicsBeforeUpdate(), r2.symbol = h4.fill.active, this._startInfo = this._getStartInfo(c), c === a2 ? (this.view.cursor = "grabbing", this.emit("rotate-start", new H(this.graphics, c, e3))) : o2.includes(c) ? (this._activeHandleGraphic = c, this.emit("scale-start", new O(this.graphics, c, i3, s3))) : this.emit("move-start", new R(this.graphics, c, t2.dx, t2.dy));
  }
  _onGraphicMoveCallback(t2) {
    const e3 = t2.graphic;
    if (this._startInfo)
      if (this._vertexGraphics.includes(e3))
        this._scaleGraphic(e3), this.emit("scale", new E(this.graphics, e3, this._xScale, this._yScale));
      else if (e3 === this._rotateHandleGraphic)
        this._rotateGraphic(e3), this.emit("rotate", new M(this.graphics, e3, this._angleOfRotation));
      else {
        const { dx: i3, dy: s3 } = t2;
        this._totalDx += i3, this._totalDy += s3, this._moveGraphic(e3, i3, s3), this.emit("move", new I(this.graphics, e3, i3, s3));
      }
  }
  _onGraphicMoveStopCallback(t2) {
    const e3 = t2.graphic;
    if (!this._startInfo)
      return void this.refresh();
    const { _angleOfRotation: i3, _totalDx: s3, _totalDy: r2, _xScale: o2, _yScale: a2, _vertexGraphics: h4, _rotateHandleGraphic: c } = this;
    this.refresh(), e3 === c ? (this.view.cursor = "pointer", this.emit("rotate-stop", new j2(this.graphics, e3, i3))) : h4.includes(e3) ? this.emit("scale-stop", new B(this.graphics, e3, o2, a2)) : this.emit("move-stop", new C(this.graphics, e3, s3, r2));
  }
  _onGraphicPointerOverCallback(t2) {
    const { _backgroundGraphic: e3, _vertexGraphics: i3, graphics: s3, _rotateHandleGraphic: r2, symbols: o2, view: a2 } = this, h4 = t2.graphic;
    if (h4 === r2)
      return r2.symbol = o2.rotator.hover, void (a2.cursor = "pointer");
    if (s3.includes(h4) || h4 === e3)
      return void (a2.cursor = "move");
    if (!i3.includes(h4))
      return void (a2.cursor = "pointer");
    t2.graphic.symbol = o2.handles.hover;
    const c = a2.rotation;
    let n3, l2 = t2.index;
    switch (l2 < 8 && (c >= 0 && c < 45 ? l2 %= 8 : l2 = c >= 45 && c < 90 ? (l2 + 1) % 8 : c >= 90 && c < 135 ? (l2 + 2) % 8 : c >= 135 && c < 180 ? (l2 + 3) % 8 : c >= 180 && c < 225 ? (l2 + 4) % 8 : c >= 225 && c < 270 ? (l2 + 5) % 8 : c >= 270 && c < 315 ? (l2 + 6) % 8 : (l2 + 7) % 8), l2) {
      case 0:
      case 4:
        n3 = "nwse-resize";
        break;
      case 1:
      case 5:
        n3 = "ns-resize";
        break;
      case 2:
      case 6:
        n3 = "nesw-resize";
        break;
      case 3:
      case 7:
        n3 = "ew-resize";
        break;
      default:
        n3 = "pointer";
    }
    a2.cursor = n3;
  }
  _onGraphicPointerOutCallback(t2) {
    const { _vertexGraphics: e3, _rotateHandleGraphic: i3, symbols: s3, view: r2 } = this;
    t2.graphic === i3 ? i3.symbol = s3.rotator.default : e3.includes(t2.graphic) && (t2.graphic.symbol = s3.handles.default), r2.cursor = "default";
  }
  _scaleGraphic(t2) {
    const { _startInfo: e3, _vertexGraphics: i3, preserveAspectRatio: s3, view: r2 } = this, { centerX: o2, centerY: a2, startX: h4, startY: c } = e3, { resolution: n3, transform: l2 } = r2.state, p = i3.indexOf(t2);
    1 !== p && 5 !== p || this._updateX(t2, o2), 3 !== p && 7 !== p || this._updateY(t2, a2);
    const { x: _, y: g2 } = t2.geometry, m5 = l2[0] * _ + l2[2] * g2 + l2[4], y2 = l2[1] * _ + l2[3] * g2 + l2[5], G = e3.graphicInfos.map((t3) => t3.geometry);
    if (s3) {
      const t3 = l2[0] * o2 + l2[2] * a2 + l2[4], e4 = l2[1] * o2 + l2[3] * a2 + l2[5], i4 = l2[0] * h4 + l2[2] * c + l2[4], s4 = l2[1] * h4 + l2[3] * c + l2[5];
      this._xScale = this._yScale = a(t3, e4, i4, s4, m5, y2);
      for (const r3 of G) {
        const t4 = G.indexOf(r3);
        this.graphics[t4].geometry = i(r3, this._xScale, this._yScale, [o2, a2]);
      }
      this._updateBackgroundGraphic();
    } else {
      const { width: t3, height: i4 } = e3;
      let s4 = _ - h4, l3 = c - g2;
      if (1 === p || 5 === p ? s4 = 0 : 3 !== p && 7 !== p || (l3 = 0), 0 === s4 && 0 === l3)
        return;
      const m6 = t3 + (h4 > o2 ? s4 : -1 * s4), v2 = i4 + (c < a2 ? l3 : -1 * l3), y3 = o2 + s4 / 2, f2 = a2 + l3 / 2;
      this._xScale = m6 / t3 || 1, this._yScale = v2 / i4 || 1, 1 === p || 5 === p ? this._xScale = 1 : 3 !== p && 7 !== p || (this._yScale = 1);
      const b = (y3 - o2) / n3, w = (f2 - a2) / n3, S2 = i(e3.box, this._xScale, this._yScale);
      this._backgroundGraphic.geometry = s(S2, b, w, r2, true);
      const { centerX: k, centerY: R2 } = this._getGraphicInfo(this._backgroundGraphic), I2 = (k - o2) / n3, C2 = -1 * (R2 - a2) / n3;
      for (const e4 of G) {
        const t4 = G.indexOf(e4), i5 = i(e4, this._xScale, this._yScale, [o2, a2]);
        this.graphics[t4].geometry = s(i5, I2, C2, r2, true);
      }
      this._centerGraphic.geometry = new j(k, R2, r2.spatialReference);
    }
  }
  _rotateGraphic(t2) {
    const { centerX: e3, centerY: i3, startX: s3, startY: r2, box: o2, rotate: a2 } = this._startInfo, h4 = new j(s3, r2, this.view.spatialReference), c = new j(e3, i3, this.view.spatialReference), n3 = t2.geometry;
    this._angleOfRotation = m4(h4, n3, c);
    const l2 = this._startInfo.graphicInfos.map((t3) => t3.geometry);
    for (const _ of l2) {
      const t3 = l2.indexOf(_), e4 = s2(_, this._angleOfRotation, c);
      this.graphics[t3].geometry = e4;
    }
    this._backgroundGraphic.geometry = s2(o2, this._angleOfRotation, c), this._rotateHandleGraphic.geometry = s2(a2, this._angleOfRotation, c);
  }
  _moveGraphic(t2, e3, i3) {
    if (this.graphics.includes(t2)) {
      const s3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = s(s3, e3, i3, this.view);
      for (const r2 of this.graphics)
        r2 !== t2 && (r2.geometry = s(r2.geometry, e3, i3, this.view));
    } else if (t2 === this._centerGraphic) {
      const t3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = s(t3, e3, i3, this.view);
    }
    if (t2 === this._backgroundGraphic || t2 === this._centerGraphic)
      for (const s3 of this.graphics)
        s3.geometry = s(s3.geometry, e3, i3, this.view);
  }
  _setUpHighlights() {
    var _a;
    this.highlightsEnabled && this.graphics.length && ((_a = this._highlightHelper) == null ? void 0 : _a.add(this.graphics));
  }
  _setupGraphics() {
    const { _graphicAttributes: t2, symbols: i3 } = this;
    this._centerGraphic = new g(null, i3.centerIndicator, t2), this.showCenterGraphic && this.layer.add(this._centerGraphic), this._backgroundGraphic = new g(null, i3.fill.default, t2), this.layer.add(this._backgroundGraphic), this._rotateLineGraphic = new g(null, i3.rotatorLine, t2), this._rotateHandleGraphic = new g(null, i3.rotator.default, t2), this.enableRotation && !this._hasExtentGraphic() && this.layer.addMany([this._rotateLineGraphic, this._rotateHandleGraphic]);
    for (let s3 = 0; s3 < 8; s3++)
      this._vertexGraphics.push(new g(null, i3.handles.default, t2));
    this.enableScaling && this.layer.addMany(this._vertexGraphics);
  }
  _updateGraphics() {
    this._updateBackgroundGraphic(), this._updateHandleGraphics(), this._updateCenterGraphic(), this._updateRotateGraphic(), this._updateRotateLineGraphic();
  }
  _hideGraphicsBeforeUpdate() {
    this._centerGraphic.visible = false, this._rotateHandleGraphic.visible = false, this._rotateLineGraphic.visible = false, this._vertexGraphics.forEach((t2) => t2.visible = false);
  }
  _updateHandleGraphics() {
    const t2 = this._getCoordinates(true);
    this._vertexGraphics.forEach((e3, i3) => {
      const [s3, r2] = t2[i3];
      this._updateXY(e3, s3, r2);
    });
  }
  _updateBackgroundGraphic() {
    const t2 = this._getCoordinates();
    this._backgroundGraphic.geometry = new v({ rings: t2, spatialReference: this.view.spatialReference });
  }
  _updateCenterGraphic() {
    const [t2, e3, i3, s3] = this._getBoxBounds(u()), r2 = (i3 + t2) / 2, o2 = (s3 + e3) / 2;
    this._centerGraphic.geometry = new j(r2, o2, this.view.spatialReference);
  }
  _updateRotateGraphic() {
    if (!this._vertexGraphics.length)
      return;
    const { x: t2, y: e3 } = this._vertexGraphics[1].geometry, i3 = e3 + this.view.state.resolution * this._rotateGraphicOffset;
    this._rotateHandleGraphic.geometry = new j(t2, i3, this.view.spatialReference);
  }
  _updateRotateLineGraphic() {
    if (!this._vertexGraphics.length || !this._rotateHandleGraphic || !this._rotateHandleGraphic.geometry)
      return;
    const t2 = this._vertexGraphics[1].geometry, e3 = this._rotateHandleGraphic.geometry;
    this._rotateLineGraphic.geometry = new m2({ paths: [[t2.x, t2.y], [e3.x, e3.y]], spatialReference: this.view.spatialReference });
  }
  _updateXY(t2, e3, i3) {
    t2.geometry = new j(e3, i3, this.view.spatialReference);
  }
  _updateX(t2, e3) {
    const i3 = t2.geometry.y;
    t2.geometry = new j(e3, i3, this.view.spatialReference);
  }
  _updateY(t2, e3) {
    const i3 = t2.geometry.x;
    t2.geometry = new j(i3, e3, this.view.spatialReference);
  }
  _hasExtentGraphic() {
    return this.graphics.some((t2) => t2 && r(t2.geometry) && "extent" === t2.geometry.type);
  }
  _getBoxBounds(t2) {
    const e3 = this.graphics.map((t3) => t3.geometry);
    return this._getBounds(t2, e3);
  }
  _getCoordinates(t2) {
    const [e3, i3, s3, r2] = this._getBoxBounds(u());
    if (t2) {
      const t3 = (e3 + s3) / 2, o2 = (r2 + i3) / 2;
      return [[e3, r2], [t3, r2], [s3, r2], [s3, o2], [s3, i3], [t3, i3], [e3, i3], [e3, o2]];
    }
    return [[e3, r2], [s3, r2], [s3, i3], [e3, i3]];
  }
};
e([d({ readOnly: true })], z.prototype, "type", void 0), e([d()], z.prototype, "callbacks", void 0), e([d()], z.prototype, "enableMovement", void 0), e([d()], z.prototype, "enableRotation", void 0), e([d()], z.prototype, "enableScaling", void 0), e([d()], z.prototype, "graphics", void 0), e([d()], z.prototype, "highlightsEnabled", void 0), e([d()], z.prototype, "layer", void 0), e([d()], z.prototype, "preserveAspectRatio", void 0), e([d()], z.prototype, "showCenterGraphic", void 0), e([d({ readOnly: true })], z.prototype, "state", null), e([d({ value: Y, cast(t2) {
  const { centerIndicator: e3 = Y.centerIndicator, fill: i3 = Y.fill, handles: s3 = Y.handles, rotator: r2 = Y.rotator, rotatorLine: o2 = Y.rotatorLine } = t2 || {};
  return { centerIndicator: e3, fill: i3, handles: s3, rotator: r2, rotatorLine: o2 };
} })], z.prototype, "symbols", void 0), e([d({ constructOnly: true })], z.prototype, "view", void 0), z = e([n("esri.views.draw.support.Box")], z);
var N = z;
export {
  N as default
};
//# sourceMappingURL=Box-FU23Q26W.js.map
