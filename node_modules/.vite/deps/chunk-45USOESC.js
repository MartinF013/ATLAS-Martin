import {
  e
} from "./chunk-SXVJRHUR.js";
import {
  a
} from "./chunk-HMUUQDIL.js";
import {
  t
} from "./chunk-RFOZTYJH.js";
import {
  B
} from "./chunk-Q3R7XFM5.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";

// node_modules/@arcgis/core/support/requestPresets.js
async function n(n2) {
  const { data: o } = await U(n2, { responseType: "json", query: { f: "json" } });
  return o;
}

// node_modules/@arcgis/core/portal/support/layersLoader.js
async function l(e2, t2) {
  const r = e2.instance.portalItem;
  if (r && r.id)
    return await r.load(t2), s2(e2), i(e2, t2);
}
function s2(t2) {
  const r = t2.instance.portalItem;
  if (!t2.supportedTypes.includes(r.type))
    throw new s("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}'", { type: r.type, expectedType: t2.supportedTypes.join(", ") });
}
async function i(e2, t2) {
  const r = e2.instance, o = r.portalItem, { url: l2, title: s3 } = o, i2 = e(o);
  if ("group" === r.type)
    return r.read({ title: s3 }, i2), u(r, e2);
  l2 && r.read({ url: l2 }, i2);
  const c2 = await d(e2, t2);
  return c2 && r.read(c2, i2), r.resourceReferences = { portalItem: o, paths: i2.readResourcePaths }, r.read({ title: s3 }, i2), t(r, i2);
}
function u(r, n2) {
  let a2;
  const o = r.portalItem.type;
  switch (o) {
    case "Feature Service":
    case "Feature Collection":
      a2 = a.FeatureLayer;
      break;
    case "Stream Service":
      a2 = a.StreamLayer;
      break;
    case "Scene Service":
      a2 = a.SceneLayer;
      break;
    default:
      throw new s("portal:unsupported-item-type-as-group", `The item type '${o}' is not supported as a 'IGroupLayer'`);
  }
  let l2;
  return a2().then((e2) => (l2 = e2, d(n2))).then(async (e2) => "Feature Service" === o ? (e2 = await f(e2, r.portalItem.url), p(r, l2, e2)) : I(e2) > 0 ? p(r, l2, e2) : c(r, l2));
}
function c(e2, t2) {
  return e2.portalItem.url ? n(e2.portalItem.url).then((r) => {
    var _a, _b;
    function n2(e3) {
      return { id: e3.id, name: e3.name };
    }
    r && p(e2, t2, { layers: (_a = r.layers) == null ? void 0 : _a.map(n2), tables: (_b = r.tables) == null ? void 0 : _b.map(n2) });
  }) : Promise.resolve();
}
function p(e2, t2, r) {
  let n2 = r.layers || [];
  const a2 = r.tables || [];
  "Feature Collection" === e2.portalItem.type && (n2.forEach((e3) => {
    var _a;
    "Table" === ((_a = e3 == null ? void 0 : e3.layerDefinition) == null ? void 0 : _a.type) && a2.push(e3);
  }), n2 = n2.filter((e3) => {
    var _a;
    return "Table" !== ((_a = e3 == null ? void 0 : e3.layerDefinition) == null ? void 0 : _a.type);
  })), n2.reverse().forEach((n3) => {
    const a3 = y(e2, t2, r, n3);
    e2.add(a3);
  }), a2.reverse().forEach((n3) => {
    const a3 = y(e2, t2, r, n3);
    e2.tables.add(a3);
  });
}
function y(e2, t2, n2, a2) {
  const o = new t2({ portalItem: e2.portalItem.clone(), layerId: a2.id, sublayerTitleMode: "service-name" });
  if ("Feature Collection" === e2.portalItem.type) {
    const t3 = { origin: "portal-item", portal: e2.portalItem.portal || B.getDefault() };
    o.read(a2, t3);
    const l2 = n2.showLegend;
    null != l2 && o.read({ showLegend: l2 }, t3);
  }
  return o;
}
function d(e2, t2) {
  if (false === e2.supportsData)
    return Promise.resolve(void 0);
  const r = e2.instance;
  return r.portalItem.fetchData("json", t2).catch(() => null).then(async (e3) => {
    if (b(r)) {
      let t3, n2 = true;
      return e3 && I(e3) > 0 && (null == r.layerId && (r.layerId = m(e3)), t3 = h(e3, r.layerId), t3 && (1 === I(e3) && (n2 = false), null != e3.showLegend && (t3.showLegend = e3.showLegend))), n2 && "service-name" !== r.sublayerTitleMode && (r.sublayerTitleMode = "item-title-and-service-name"), t3;
    }
    return e3;
  });
}
async function f(e2, t2) {
  if (null == (e2 == null ? void 0 : e2.layers) || null == (e2 == null ? void 0 : e2.tables)) {
    const r = await n(t2);
    (e2 = e2 || {}).layers = e2.layers || (r == null ? void 0 : r.layers), e2.tables = e2.tables || (r == null ? void 0 : r.tables);
  }
  return e2;
}
function m(e2) {
  const t2 = e2.layers;
  if (t2 && t2.length)
    return t2[0].id;
  const r = e2.tables;
  return r && r.length ? r[0].id : null;
}
function h(e2, t2) {
  const r = e2.layers;
  if (r) {
    for (let a2 = 0; a2 < r.length; a2++)
      if (r[a2].id === t2)
        return r[a2];
  }
  const n2 = e2.tables;
  if (n2) {
    for (let a2 = 0; a2 < n2.length; a2++)
      if (n2[a2].id === t2)
        return n2[a2];
  }
  return null;
}
function I(e2) {
  var _a, _b;
  return (((_a = e2 == null ? void 0 : e2.layers) == null ? void 0 : _a.length) ?? 0) + (((_b = e2 == null ? void 0 : e2.tables) == null ? void 0 : _b.length) ?? 0);
}
function b(e2) {
  return "stream" !== e2.type && "layerId" in e2;
}

export {
  n,
  l,
  f,
  m,
  I
};
//# sourceMappingURL=chunk-45USOESC.js.map
