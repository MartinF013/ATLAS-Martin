import {
  n
} from "./chunk-GVELBHGI.js";
import {
  A,
  Bt,
  D,
  E,
  F,
  H,
  I,
  J,
  St,
  V,
  W,
  X,
  b,
  j,
  mt,
  z
} from "./chunk-5N3FSR63.js";
import {
  g,
  m as m2,
  p,
  v
} from "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  r as r2
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  a,
  e,
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/support/apiKeyUtils.js
var t = ["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"];
function r3(c) {
  const r4 = H(c, true);
  return r4 && r4.endsWith(".arcgis.com") && !t.includes(r4) && !c.endsWith("/sharing/rest/generateToken");
}

// node_modules/@arcgis/core/support/requestUtils.js
function a2(r4, n2, s2 = false, i) {
  return new Promise((c, a3) => {
    if (p(i))
      return void a3(m3());
    let u2 = () => {
      l(), a3(new Error(`Unable to load ${n2}`));
    }, d2 = () => {
      const e2 = r4;
      l(), c(e2);
    }, f2 = () => {
      if (!r4)
        return;
      const e2 = r4;
      l(), e2.src = "", a3(m3());
    };
    const l = () => {
      a("esri-image-decode") || (r4.removeEventListener("error", u2), r4.removeEventListener("load", d2)), u2 = null, d2 = null, r4 = null, r(i) && i.removeEventListener("abort", f2), f2 = null, s2 && URL.revokeObjectURL(n2);
    };
    r(i) && i.addEventListener("abort", f2), a("esri-image-decode") ? r4.decode().then(d2, u2) : (r4.addEventListener("error", u2), r4.addEventListener("load", d2));
  });
}
function m3() {
  try {
    return new DOMException("Aborted", "AbortError");
  } catch {
    const r4 = new Error();
    return r4.name = "AbortError", r4;
  }
}
function u(e2) {
  r2.request.crossOriginNoCorsDomains || (r2.request.crossOriginNoCorsDomains = {});
  const o = r2.request.crossOriginNoCorsDomains;
  for (let r4 of e2)
    r4 = r4.toLowerCase(), /^https?:\/\//.test(r4) ? o[H(r4)] = 0 : (o[H("http://" + r4)] = 0, o[H("https://" + r4)] = 0);
}
function d(e2) {
  const o = r2.request.crossOriginNoCorsDomains;
  if (o) {
    let r4 = H(e2);
    if (r4)
      return r4 = r4.toLowerCase(), !z(r4, b()) && o[r4] < Date.now() - 36e5;
  }
  return false;
}
async function f(e2) {
  var _a;
  const o = r2.request.crossOriginNoCorsDomains;
  o && (o[H(e2).toLowerCase()] = Date.now());
  const t2 = j(e2);
  e2 = t2.path, "json" === ((_a = t2.query) == null ? void 0 : _a.f) && (e2 += "?f=json");
  try {
    await fetch(e2, { mode: "no-cors", credentials: "include" });
  } catch {
  }
}

// node_modules/@arcgis/core/request.js
async function U(e2, r4) {
  var _a;
  const t2 = X(e2), o = V(e2);
  o || t2 || (e2 = F(e2));
  const i = { url: e2, requestOptions: { ...e(r4) } };
  let l = W(e2);
  if (l) {
    const e3 = await G(l, i);
    if (null != e3)
      return { data: e3, getHeader: M, requestOptions: i.requestOptions, url: i.url };
    l.after || l.error || (l = null);
  }
  if (e2 = i.url, "image" === (r4 = i.requestOptions).responseType) {
    if (a("host-webworker") || a("host-node"))
      throw N("request:invalid-parameters", new Error("responseType 'image' is not supported in Web Workers or Node environment"), i);
  } else if (t2)
    throw N("request:invalid-parameters", new Error("Data URLs are not supported for responseType = " + r4.responseType), i);
  if ("head" === r4.method) {
    if (r4.body)
      throw N("request:invalid-parameters", new Error("body parameter cannot be set when method is 'head'"), i);
    if (t2 || o)
      throw N("request:invalid-parameters", new Error("data and blob URLs are not supported for method 'head'"), i);
  }
  if (await B(), j2)
    return j2.execute(e2, r4);
  const u2 = new AbortController();
  v(r4, () => u2.abort());
  const m4 = { controller: u2, credential: null, credentialToken: null, fetchOptions: null, hasToken: false, interceptor: l, params: i, redoRequest: false, useIdentity: P.useIdentity, useProxy: false, useSSL: false, withCredentials: false }, f2 = await Q(m4);
  return (_a = l == null ? void 0 : l.after) == null ? void 0 : _a.call(l, f2), f2;
}
var j2;
var P = r2.request;
var D2 = "FormData" in globalThis;
var _ = [499, 498, 403, 401];
var F2 = ["COM_0056", "COM_0057", "SB_0008"];
var I2 = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i];
var M = () => null;
var R = Symbol();
function H2(e2) {
  const r4 = H(e2);
  r4 && !U._corsServers.includes(r4) && U._corsServers.push(r4);
}
function A2(e2) {
  const r4 = H(e2);
  return !r4 || r4.endsWith(".arcgis.com") || U._corsServers.includes(r4) || D(r4);
}
function N(e2, r4, s2, n2) {
  let a3 = "Error";
  const u2 = { url: s2.url, requestOptions: s2.requestOptions, getHeader: M, ssl: false };
  if (r4 instanceof s)
    return r4.details ? (r4.details = m(r4.details), r4.details.url = s2.url, r4.details.requestOptions = s2.requestOptions) : r4.details = u2, r4;
  if (r4) {
    const e3 = n2 && ((e4) => n2.headers.get(e4)), t2 = n2 && n2.status, s3 = r4.message;
    s3 && (a3 = s3), e3 && (u2.getHeader = e3), u2.httpStatus = (null != r4.httpCode ? r4.httpCode : r4.code) || t2 || 0, u2.subCode = r4.subcode, u2.messageCode = r4.messageCode, "string" == typeof r4.details ? u2.messages = [r4.details] : u2.messages = r4.details, u2.raw = R in r4 ? r4[R] : r4;
  }
  return g(r4) ? m2() : new s(e2, a3, u2);
}
async function B() {
  a("host-webworker") ? j2 || (j2 = await import("./request-YOGZ7BRI.js")) : U._abortableFetch || (U._abortableFetch = globalThis.fetch.bind(globalThis));
}
async function $() {
  n || await import("./IdentityManager-H2MEV4LQ.js");
}
async function z2(t2) {
  var _a;
  const s2 = t2.params.url, o = t2.params.requestOptions, n2 = t2.controller.signal, a3 = o.body;
  let i = null, l = null;
  if (D2 && "HTMLFormElement" in globalThis && (a3 instanceof FormData ? i = a3 : a3 instanceof HTMLFormElement && (i = new FormData(a3))), "string" == typeof a3 && (l = a3), t2.fetchOptions = { cache: o.cacheBust && !U._abortableFetch.polyfill ? "no-cache" : "default", credentials: "same-origin", headers: o.headers || {}, method: "head" === o.method ? "HEAD" : "GET", mode: "cors", priority: P.priority, redirect: "follow", signal: n2 }, (i || l) && (t2.fetchOptions.body = i || l), "anonymous" === o.authMode && (t2.useIdentity = false), t2.hasToken = !!(/token=/i.test(s2) || ((_a = o.query) == null ? void 0 : _a.token) || (i == null ? void 0 : i.get("token"))), !t2.hasToken && r2.apiKey && r3(s2) && (o.query || (o.query = {}), o.query.token = r2.apiKey, t2.hasToken = true), t2.useIdentity && !t2.hasToken && !t2.credentialToken && !K(s2) && !p(n2)) {
    let e2;
    "immediate" === o.authMode ? (await $(), e2 = await n.getCredential(s2, { signal: n2 }), t2.credential = e2) : "no-prompt" === o.authMode ? (await $(), e2 = await n.getCredential(s2, { prompt: false, signal: n2 }).catch(() => {
    }), t2.credential = e2) : n && (e2 = n.findCredential(s2)), e2 && (t2.credentialToken = e2.token, t2.useSSL = !!e2.ssl);
  }
}
function K(e2) {
  return I2.some((r4) => r4.test(e2));
}
async function W2(e2) {
  let t2 = e2.params.url;
  const o = e2.params.requestOptions, n2 = e2.fetchOptions, a3 = V(t2) || X(t2), i = o.responseType || "json", u2 = a3 ? 0 : null != o.timeout ? o.timeout : P.timeout;
  let p2 = false;
  if (!a3) {
    e2.useSSL && (t2 = mt(t2)), o.cacheBust && "default" === n2.cache && (t2 = St(t2, "request.preventCache", Date.now()));
    let a4 = { ...o.query };
    e2.credentialToken && (a4.token = e2.credentialToken);
    let i2 = I(a4);
    a("esri-url-encodes-apostrophe") && (i2 = i2.replace(/'/g, "%27"));
    const l = t2.length + 1 + i2.length;
    let u3;
    p2 = "delete" === o.method || "post" === o.method || "put" === o.method || !!o.body || l > P.maxUrlLength;
    const c = o.useProxy || !!J(t2);
    if (c) {
      const e3 = A(t2);
      u3 = e3.path, !p2 && u3.length + 1 + l > P.maxUrlLength && (p2 = true), e3.query && (a4 = { ...e3.query, ...a4 });
    }
    if ("HEAD" === n2.method && (p2 || c)) {
      if (p2) {
        if (l > P.maxUrlLength)
          throw N("request:invalid-parameters", new Error("URL exceeds maximum length"), e2.params);
        throw N("request:invalid-parameters", new Error("cannot use POST request when method is 'head'"), e2.params);
      }
      if (c)
        throw N("request:invalid-parameters", new Error("cannot use proxy when method is 'head'"), e2.params);
    }
    if (p2 ? (n2.method = "delete" === o.method ? "DELETE" : "put" === o.method ? "PUT" : "POST", o.body ? t2 = Bt(t2, a4) : (n2.body = I(a4), n2.headers["Content-Type"] = "application/x-www-form-urlencoded")) : t2 = Bt(t2, a4), c && (e2.useProxy = true, t2 = `${u3}?${t2}`), a4.token && D2 && n2.body instanceof FormData && !/\/(sharing|usrsvcs)\/(appservices|servers)\//i.test(t2) && n2.body.set("token", a4.token), o.hasOwnProperty("withCredentials"))
      e2.withCredentials = o.withCredentials;
    else if (!z(t2, b())) {
      if (D(t2))
        e2.withCredentials = true;
      else if (n) {
        const s2 = n.findServerInfo(t2);
        s2 && s2.webTierAuth && (e2.withCredentials = true);
      }
    }
    e2.withCredentials && (n2.credentials = "include", d(t2) && await f(p2 ? Bt(t2, a4) : t2));
  }
  let h, C, x = 0, L = false;
  u2 > 0 && (x = setTimeout(() => {
    L = true, e2.controller.abort();
  }, u2));
  try {
    if ("native-request-init" === o.responseType)
      C = n2, C.url = t2;
    else if ("image" !== o.responseType || "default" !== n2.cache || "GET" !== n2.method || p2 || J2(o.headers) || !a3 && !e2.useProxy && P.proxyUrl && !A2(t2)) {
      if (h = await U._abortableFetch(t2, n2), e2.useProxy || H2(t2), "native" === o.responseType)
        C = h;
      else if ("HEAD" !== n2.method)
        if (h.ok) {
          switch (i) {
            case "array-buffer":
              C = await h.arrayBuffer();
              break;
            case "blob":
            case "image":
              C = await h.blob();
              break;
            default:
              C = await h.text();
          }
          if (x && (clearTimeout(x), x = 0), "json" === i || "xml" === i || "document" === i)
            if (C)
              switch (i) {
                case "json":
                  C = JSON.parse(C);
                  break;
                case "xml":
                  C = X2(C, "application/xml");
                  break;
                case "document":
                  C = X2(C, "text/html");
              }
            else
              C = null;
          if (C) {
            if ("array-buffer" === i || "blob" === i) {
              const e3 = h.headers.get("Content-Type");
              if (/application\/json|text\/plain/i.test(e3) && C["blob" === i ? "size" : "byteLength"] <= 750)
                try {
                  const e4 = await new Response(C).json();
                  e4.error && (C = e4);
                } catch {
                }
            }
            "image" === i && C instanceof Blob && (C = await Y(URL.createObjectURL(C), e2, true));
          }
        } else
          C = await h.text();
    } else
      C = await Y(t2, e2);
  } catch (j3) {
    if ("AbortError" === j3.name) {
      if (L)
        throw new Error("Timeout exceeded");
      throw m2("Request canceled");
    }
    if (!(!h && j3 instanceof TypeError && P.proxyUrl) || o.body || "delete" === o.method || "head" === o.method || "post" === o.method || "put" === o.method || e2.useProxy || A2(t2))
      throw j3;
    e2.redoRequest = true, E({ proxyUrl: P.proxyUrl, urlPrefix: H(t2) });
  } finally {
    x && clearTimeout(x);
  }
  return [h, C];
}
async function G(e2, r4) {
  if (null != e2.responseData)
    return e2.responseData;
  if (e2.headers && (r4.requestOptions.headers = { ...r4.requestOptions.headers, ...e2.headers }), e2.query && (r4.requestOptions.query = { ...r4.requestOptions.query, ...e2.query }), e2.before) {
    let o, n2;
    try {
      n2 = await e2.before(r4);
    } catch (s2) {
      o = N("request:interceptor", s2, r4);
    }
    if ((n2 instanceof Error || n2 instanceof s) && (o = N("request:interceptor", n2, r4)), o)
      throw e2.error && e2.error(o), o;
    return n2;
  }
}
function J2(e2) {
  if (e2) {
    for (const r4 of Object.getOwnPropertyNames(e2))
      if (e2[r4])
        return true;
  }
  return false;
}
function X2(e2, r4) {
  let t2;
  try {
    t2 = new DOMParser().parseFromString(e2, r4);
  } catch {
  }
  if (!t2 || t2.getElementsByTagName("parsererror").length)
    throw new SyntaxError("XML Parse error");
  return t2;
}
async function Q(e2) {
  var _a;
  let t2, s2;
  await z2(e2);
  try {
    do {
      [t2, s2] = await W2(e2);
    } while (!await V2(e2, t2, s2));
  } catch (a3) {
    const r4 = N("request:server", a3, e2.params, t2);
    throw r4.details.ssl = e2.useSSL, e2.interceptor && e2.interceptor.error && e2.interceptor.error(r4), r4;
  }
  const o = e2.params.url;
  if (s2 && /\/sharing\/rest\/(accounts|portals)\/self/i.test(o)) {
    if (!e2.hasToken && !e2.credentialToken && ((_a = s2.user) == null ? void 0 : _a.username) && !D(o)) {
      const e3 = H(o, true);
      e3 && P.trustedServers.push(e3);
    }
    Array.isArray(s2.authorizedCrossOriginNoCorsDomains) && u(s2.authorizedCrossOriginNoCorsDomains);
  }
  const n2 = e2.credential;
  if (n2 && n) {
    const e3 = n.findServerInfo(n2.server);
    let t3 = e3 && e3.owningSystemUrl;
    if (t3) {
      t3 = t3.replace(/\/?$/, "/sharing");
      const e4 = n.findCredential(t3, n2.userId);
      e4 && -1 === n._getIdenticalSvcIdx(t3, e4) && e4.resources.unshift(t3);
    }
  }
  return { data: s2, getHeader: t2 ? (e3) => t2.headers.get(e3) : M, requestOptions: e2.params.requestOptions, ssl: e2.useSSL, url: e2.params.url };
}
async function V2(e2, t2, s2) {
  if (e2.redoRequest)
    return e2.redoRequest = false, false;
  const o = e2.params.requestOptions;
  if (!t2 || "native" === o.responseType || "native-request-init" === o.responseType)
    return true;
  let n2, a3, i, l;
  if (!t2.ok)
    throw n2 = new Error(`Unable to load ${t2.url} status: ${t2.status}`), n2[R] = s2, n2;
  (s2 == null ? void 0 : s2.error) && (n2 = s2.error), n2 && (a3 = Number(n2.code), i = n2.hasOwnProperty("subcode") ? Number(n2.subcode) : null, l = n2.messageCode, l = l && l.toUpperCase());
  const u2 = o.authMode;
  if (403 === a3 && (4 === i || n2.message && n2.message.toLowerCase().includes("ssl") && !n2.message.toLowerCase().includes("permission"))) {
    if (!e2.useSSL)
      return e2.useSSL = true, false;
  } else if (!e2.hasToken && e2.useIdentity && ("no-prompt" !== u2 || 498 === a3) && _.includes(a3) && !K(e2.params.url) && (403 !== a3 || !F2.includes(l) && (null == i || 2 === i && e2.credentialToken))) {
    await $();
    try {
      const t3 = await n.getCredential(e2.params.url, { error: N("request:server", n2, e2.params), prompt: "no-prompt" !== u2, signal: e2.controller.signal, token: e2.credentialToken });
      return e2.credential = t3, e2.credentialToken = t3.token, e2.useSSL = e2.useSSL || t3.ssl, false;
    } catch (c) {
      if ("no-prompt" === u2)
        return e2.credential = null, e2.credentialToken = null, false;
      n2 = c;
    }
  }
  if (n2)
    throw n2;
  return true;
}
function Y(e2, r4, t2 = false) {
  const s2 = r4.controller.signal, o = new Image();
  return r4.withCredentials ? o.crossOrigin = "use-credentials" : o.crossOrigin = "anonymous", o.alt = "", o.fetchPriority = P.priority, o.src = e2, a2(o, e2, t2, s2);
}
U._abortableFetch = null, U._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"];

export {
  r3 as r,
  a2 as a,
  U
};
//# sourceMappingURL=chunk-65A2N4LL.js.map
