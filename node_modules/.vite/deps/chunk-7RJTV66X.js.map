{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/lib/SMAATechniqueConfiguration.js", "../../@arcgis/core/chunks/SMAA.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{_ as e}from\"../../../../chunks/tslib.es6.js\";import{parameter as t,ShaderTechniqueConfiguration as o}from\"../core/shaderTechnique/ShaderTechniqueConfiguration.js\";var r;!function(e){e[e.EdgeDetector=0]=\"EdgeDetector\",e[e.BlendWeight=1]=\"BlendWeight\",e[e.Blur=2]=\"Blur\",e[e.COUNT=3]=\"COUNT\"}(r||(r={}));class u extends o{constructor(){super(...arguments),this.output=r.EdgeDetector}}e([t({count:r.COUNT})],u.prototype,\"output\",void 0);export{r as SMAAOutput,u as SMAATechniqueConfiguration};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{Float4Uniform as e}from\"../views/3d/webgl-engine/core/shaderModules/Float4Uniform.js\";import{glsl as o}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as t}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DUniform as r}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DUniform.js\";import{SMAAOutput as s}from\"../views/3d/webgl-engine/lib/SMAATechniqueConfiguration.js\";import{VertexAttribute as d}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";const a={threshold:.05,localConstrastAdaption:2,maxSearchSteps:8,maxDistanceAreaTex:16};function x(x){const c=new t;return x.output===s.EdgeDetector&&(c.attributes.add(d.POSITION,\"vec2\"),c.vertex.uniforms.add(new e(\"resolution\")),c.varyings.add(\"fTexCoord\",\"vec2\"),c.varyings.add(\"fOffset[3]\",\"vec4\"),c.vertex.code.add(o`void SMAAEdgeDetectionVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\nfOffset[1] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\nfOffset[2] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAAEdgeDetectionVS( fTexCoord );\n}`),c.fragment.uniforms.add(new r(\"tColor\")),c.fragment.code.add(o`\n      vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n        vec2 threshold = vec2( ${o.float(a.threshold)} );\n\n        // Calculate color deltas:\n        vec4 delta;\n        vec3 C = texture2D( colorTex, texcoord ).rgb;\n\n        vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n        vec3 t = abs( C - Cleft );\n        delta.x = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n        t = abs( C - Ctop );\n        delta.y = max( max( t.r, t.g ), t.b );\n\n        // We do the usual threshold:\n        vec2 edges = step( threshold, delta.xy );\n\n        // Then discard if there is no edge:\n        if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n            discard;\n\n        // Calculate right and bottom deltas:\n        vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n        t = abs( C - Cright );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n        t = abs( C - Cbottom );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the maximum delta in the direct neighborhood:\n        float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n        // Calculate left-left and top-top deltas:\n        vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n        t = abs( C - Cleftleft );\n        delta.z = max( max( t.r, t.g ), t.b );\n\n        vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n        t = abs( C - Ctoptop );\n        delta.w = max( max( t.r, t.g ), t.b );\n\n        // Calculate the final maximum delta:\n        maxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n        // Local contrast adaptation in action:\n        edges.xy *= step( maxDelta, float(${o.float(a.localConstrastAdaption)}) * delta.xy );\n\n        return vec4( edges, 0.0, 0.0 );\n      }\n\n      void main() {\n        gl_FragColor = SMAAColorEdgeDetectionPS( fTexCoord, fOffset, tColor );\n      }\n    `)),x.output===s.BlendWeight&&(c.attributes.add(d.POSITION,\"vec2\"),c.vertex.uniforms.add(new e(\"resolution\")),c.varyings.add(\"fTexCoord\",\"vec2\"),c.varyings.add(\"fOffset[3]\",\"vec4\"),c.varyings.add(\"fPixCoord\",\"vec2\"),c.vertex.code.add(o`\n      void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n        fPixCoord = texcoord * resolution.zw;\n        fOffset[0] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\n        fOffset[1] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\n        fOffset[2] = vec4( fOffset[0].xz, fOffset[1].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( ${o.int(a.maxSearchSteps)} );\n      }\n\n      void main() {\n        fTexCoord = (position + 1.0 ) * 0.5;\n        gl_Position = vec4(position, 0, 1);\n        SMAABlendingWeightCalculationVS( fTexCoord );\n      }\n    `),c.fragment.uniforms.add(new r(\"tEdges\")),c.fragment.uniforms.add(new r(\"tArea\")),c.fragment.uniforms.add(new r(\"tSearch\")),c.fragment.uniforms.add(new r(\"tColor\")),c.fragment.uniforms.add(new e(\"resolution\")),c.fragment.code.add(o`\n      #define SMAA_AREATEX_PIXEL_SIZE ( 1.0 / vec2( 160.0, 560.0 ) )\n      #define SMAA_AREATEX_SUBTEX_SIZE ( 1.0 / 7.0 )\n\n      vec4 SMAASampleLevelZeroOffset(sampler2D texture, vec2 coord, vec2 offset) {\n        return texture2D(texture, coord + offset.x * resolution.xy, 0.0);\n      }\n\n      vec2 round( vec2 x ) {\n        return sign( x ) * floor( abs( x ) + 0.5 );\n      }\n\n      float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n        e.r = bias + e.r * scale;\n        return 255.0 * texture2D( searchTex, e, 0.0 ).r;\n      }\n\n      float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 2.0, 0.0 ) * resolution.xy;\n          if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x += 0.25 * resolution.x;\n        texcoord.x += resolution.x;\n        texcoord.x += 2.0 * resolution.x;\n        texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n        return texcoord.x;\n      }\n\n      float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 2.0, 0.0 ) * resolution.xy;\n          if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x -= 0.25 * resolution.x;\n        texcoord.x -= resolution.x;\n        texcoord.x -= 2.0 * resolution.x;\n        texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n        return texcoord.x;\n      }\n\n      float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 0.0, 2.0 ) * resolution.xy;\n          if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y -= 0.25 * resolution.y;\n        texcoord.y -= resolution.y;\n        texcoord.y -= 2.0 * resolution.y;\n        texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\n        return texcoord.y;\n      }\n\n      float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${o.int(a.maxSearchSteps)}; i ++ ) {\n          e = texture2D( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 0.0, 2.0 ) * resolution.xy;\n          if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y += 0.25 * resolution.y;\n        texcoord.y += resolution.y;\n        texcoord.y += 2.0 * resolution.y;\n        texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\n        return texcoord.y;\n      }\n\n      vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n        vec2 texcoord = float( ${o.int(a.maxDistanceAreaTex)} ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n        texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n        texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n        return texture2D( areaTex, texcoord, 0.0 ).rg;\n      }\n\n      vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n        vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n        vec2 e = texture2D( edgesTex, texcoord ).rg;\n        if ( e.g > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n          coords.y = offset[ 1 ].y;\n          d.x = coords.x;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).r;\n          coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n          d.y = coords.x;\n          d = d * resolution.z - pixcoord.x;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * resolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 1.0, 0.0 ) ).r;\n          weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n        }\n\n        if ( e.r > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n          coords.x = offset[ 0 ].x;\n          d.x = coords.y;\n          float e1 = texture2D( edgesTex, coords, 0.0 ).g;\n          coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n          d.y = coords.y;\n          d = d * resolution.w - pixcoord.y;\n          vec2 sqrt_d = sqrt( abs( d ) );\n          coords.y -= 1.0 * resolution.y;\n          float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, vec2( 0.0, 1.0 ) ).g;\n          weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\n          // for some reason the following lines are necessary to prevent\n          // texture lookup precision issues on some Intel integrated graphics chips\n          vec4 dbg = (offset[ 0 ]+offset[ 1 ]+offset[ 2 ] + coords.xyyx);\n          weights.r += 0.00000001 * dot(vec4(0,1,0,1),dbg);\n        }\n        return weights;\n      }\n\n      void main() {\n        gl_FragColor = SMAABlendingWeightCalculationPS( fTexCoord, fPixCoord, fOffset, tEdges, tArea, tSearch, ivec4( 0.0 ) );\n      }\n    `)),x.output===s.Blur&&(c.attributes.add(d.POSITION,\"vec2\"),c.vertex.uniforms.add(new e(\"resolution\")),c.varyings.add(\"fTexCoord\",\"vec2\"),c.varyings.add(\"fOffset[2]\",\"vec4\"),c.vertex.code.add(o`void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\nfOffset[0] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\nfOffset[1] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\n}\nvoid main() {\nfTexCoord = (position + 1.0 ) * 0.5;\ngl_Position = vec4(position, 0, 1);\nSMAANeighborhoodBlendingVS(fTexCoord);\n}`),c.fragment.uniforms.add(new r(\"tBlendWeights\")),c.fragment.uniforms.add(new r(\"tColor\")),c.fragment.uniforms.add(new e(\"resolution\")),c.fragment.code.add(o`vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\nvec4 a;\na.xz = texture2D( blendTex, texcoord ).xz;\na.y = texture2D( blendTex, offset[ 1 ].zw ).g;\na.w = texture2D( blendTex, offset[ 1 ].xy ).a;\nif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\nreturn texture2D( colorTex, texcoord, 0.0 );\n} else {\nvec2 offset;\noffset.x = a.a > a.b ? a.a : -a.b;\noffset.y = a.g > a.r ? -a.g : a.r;\nif ( abs( offset.x ) > abs( offset.y )) {\noffset.y = 0.0;\n} else {\noffset.x = 0.0;\n}\nvec4 C = texture2D( colorTex, texcoord, 0.0 );\ntexcoord += sign( offset ) * resolution.xy;\nvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\nfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\nvec4 mixed = mix(C, Cop, s);\nreturn mixed;\n}\n}\nvoid main() {\ngl_FragColor = SMAANeighborhoodBlendingPS( fTexCoord, fOffset, tColor, tBlendWeights );\n}`)),c}const c=Object.freeze(Object.defineProperty({__proto__:null,build:x},Symbol.toStringTag,{value:\"Module\"}));export{c as S,x as b};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAI0K,IAAI;AAAE,CAAC,SAASA,IAAE;AAAC,EAAAA,GAAEA,GAAE,eAAa,CAAC,IAAE,gBAAeA,GAAEA,GAAE,cAAY,CAAC,IAAE,eAAcA,GAAEA,GAAE,OAAK,CAAC,IAAE,QAAOA,GAAEA,GAAE,QAAM,CAAC,IAAE;AAAO,EAAE,MAAI,IAAE,CAAC,EAAE;AAAE,IAAM,IAAN,cAAgB,EAAC;AAAA,EAAC,cAAa;AAAC,UAAM,GAAG,SAAS,GAAE,KAAK,SAAO,EAAE;AAAA,EAAY;AAAC;AAAC,EAAE,CAACA,GAAE,EAAC,OAAM,EAAE,MAAK,CAAC,CAAC,GAAE,EAAE,WAAU,UAAS,MAAM;;;ACAiG,IAAM,IAAE,EAAC,WAAU,MAAI,wBAAuB,GAAE,gBAAe,GAAE,oBAAmB,GAAE;AAAE,SAAS,EAAEC,IAAE;AAAC,QAAMC,KAAE,IAAI;AAAE,SAAOD,GAAE,WAAS,EAAE,iBAAeC,GAAE,WAAW,IAAI,EAAE,UAAS,MAAM,GAAEA,GAAE,OAAO,SAAS,IAAI,IAAI,EAAE,YAAY,CAAC,GAAEA,GAAE,SAAS,IAAI,aAAY,MAAM,GAAEA,GAAE,SAAS,IAAI,cAAa,MAAM,GAAEA,GAAE,OAAO,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASr1B,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,QAAQ,CAAC,GAAEA,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA,iCAEhC,EAAE,MAAM,EAAE,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4CA8CR,EAAE,MAAM,EAAE,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAQvE,IAAGD,GAAE,WAAS,EAAE,gBAAcC,GAAE,WAAW,IAAI,EAAE,UAAS,MAAM,GAAEA,GAAE,OAAO,SAAS,IAAI,IAAI,EAAE,YAAY,CAAC,GAAEA,GAAE,SAAS,IAAI,aAAY,MAAM,GAAEA,GAAE,SAAS,IAAI,cAAa,MAAM,GAAEA,GAAE,SAAS,IAAI,aAAY,MAAM,GAAEA,GAAE,OAAO,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,sHAKxH,EAAE,IAAI,EAAE,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAQvI,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,QAAQ,CAAC,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,OAAO,CAAC,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,SAAS,CAAC,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,QAAQ,CAAC,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,YAAY,CAAC,GAAEA,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAmB7M,EAAE,IAAI,EAAE,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BActB,EAAE,IAAI,EAAE,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BActB,EAAE,IAAI,EAAE,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BActB,EAAE,IAAI,EAAE,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCAapB,EAAE,IAAI,EAAE,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAmDtD,IAAGD,GAAE,WAAS,EAAE,SAAOC,GAAE,WAAW,IAAI,EAAE,UAAS,MAAM,GAAEA,GAAE,OAAO,SAAS,IAAI,IAAI,EAAE,YAAY,CAAC,GAAEA,GAAE,SAAS,IAAI,aAAY,MAAM,GAAEA,GAAE,SAAS,IAAI,cAAa,MAAM,GAAEA,GAAE,OAAO,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQlM,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,eAAe,CAAC,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,QAAQ,CAAC,GAAEA,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,YAAY,CAAC,GAAEA,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0B5J,IAAGA;AAAC;AAAC,IAAM,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["e", "x", "c"]
}
