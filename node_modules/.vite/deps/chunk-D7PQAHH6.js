import {
  R,
  l as l2
} from "./chunk-A2XF5TZW.js";
import {
  H,
  L as L2,
  T,
  e as e5,
  e2 as e6,
  q,
  t as t2
} from "./chunk-73VW7LOZ.js";
import {
  E
} from "./chunk-EMETVH63.js";
import {
  e as e4,
  i,
  i2
} from "./chunk-ILEVWNLM.js";
import {
  E as E2,
  e as e3,
  p as p3,
  r as r3,
  s as s2
} from "./chunk-3HMF3PNP.js";
import {
  L,
  m as m2
} from "./chunk-N5C77AAH.js";
import {
  A,
  b,
  d as d2,
  j as j2,
  m,
  o,
  p as p2,
  s
} from "./chunk-YZNDHJDJ.js";
import {
  n as n5,
  r as r2
} from "./chunk-RTHP2LNT.js";
import {
  d as d3
} from "./chunk-JJRJ6TV3.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  l,
  w
} from "./chunk-T7BEWVV3.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import {
  n as n4
} from "./chunk-OIPX3EDD.js";
import {
  n as n3
} from "./chunk-AIRC226G.js";
import {
  d,
  n8 as n2,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  C,
  f,
  p
} from "./chunk-U3PSONS6.js";
import {
  n
} from "./chunk-23NWA6WL.js";
import {
  e as e2,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingLayerSource.js
var e7 = class extends y {
  constructor(r4) {
    super(r4), this.layer = null, this.enabled = true, this.updating = false, this.availability = 1;
  }
};
e([d({ constructOnly: true })], e7.prototype, "layer", void 0), e([d()], e7.prototype, "enabled", void 0), e([d()], e7.prototype, "updating", void 0), e([d()], e7.prototype, "availability", void 0), e7 = e([n2("esri.views.interactive.snapping.SnappingLayerSource")], e7);
var p4 = e7;

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOptions.js
var p5 = class extends y {
  constructor(e8) {
    super(e8), this.enabled = false, this.enabledToggled = false, this.selfEnabled = true, this.featureEnabled = true, this.featureSources = new j(), this.distance = p3.distance, this.touchSensitivityMultiplier = p3.touchSensitivityMultiplier;
  }
  get effectiveEnabled() {
    return this.enabledToggled ? !this.enabled : this.enabled;
  }
  get effectiveSelfEnabled() {
    return this.effectiveEnabled && this.selfEnabled;
  }
  get effectiveFeatureEnabled() {
    return this.effectiveEnabled && this.featureEnabled;
  }
};
e([d()], p5.prototype, "enabled", void 0), e([d()], p5.prototype, "enabledToggled", void 0), e([d()], p5.prototype, "selfEnabled", void 0), e([d()], p5.prototype, "featureEnabled", void 0), e([d({ type: j.ofType(p4) })], p5.prototype, "featureSources", void 0), e([d()], p5.prototype, "distance", void 0), e([d()], p5.prototype, "touchSensitivityMultiplier", void 0), e([d({ readOnly: true })], p5.prototype, "effectiveEnabled", null), e([d({ readOnly: true })], p5.prototype, "effectiveSelfEnabled", null), e([d({ readOnly: true })], p5.prototype, "effectiveFeatureEnabled", null), p5 = e([n2("esri.views.interactive.snapping.SnappingOptions")], p5);
var l3 = p5;

// node_modules/@arcgis/core/views/interactive/snapping/candidates/RightAngleSnappingCandidate.js
var o2 = class extends t2 {
  constructor({ coordinateHelper: t3, targetPoint: e8, constraint: r4, previousVertex: i5, otherVertex: o4, otherVertexType: n7, objectId: s4, elevationInfo: h2 }) {
    super(t3, e8, r4, h2), this.previousVertex = i5, this.otherVertex = o4, this.otherVertexType = n7, this.objectId = s4;
  }
  get hints() {
    const e8 = this.previousVertex, o4 = this.otherVertexType === n6.CENTER ? this.otherVertex : this.targetPoint, s4 = this.otherVertexType === n6.CENTER ? this.targetPoint : this.otherVertex, h2 = this.elevationInfo;
    return [new s2(e3.TARGET, o4, s4, h2), new s2(e3.REFERENCE, e8, o4, h2), new i2(this.previousVertex, o4, s4, h2)];
  }
};
var n6;
!function(t3) {
  t3[t3.NEXT = 0] = "NEXT", t3[t3.CENTER = 1] = "CENTER";
}(n6 || (n6 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingEngine.js
var C2 = class extends d3 {
  constructor(e8) {
    super(e8), this.options = null, this.sourceModules = { featureService: { module: null, loader: null }, featureCollection: { module: null, loader: null }, graphics: { module: null, loader: null } };
  }
  get updating() {
    return n(this.snappingSources, ({ snappingSource: e8 }) => e8.updating) || this.updatingHandles.updating;
  }
  get snappingSources() {
    const e8 = this._get("snappingSources") || /* @__PURE__ */ new Map(), t3 = /* @__PURE__ */ new Map();
    if (r(this.options) && r(this.options.featureSources))
      for (const r4 of this.options.featureSources.items) {
        const i5 = r4.layer.uid, s4 = e8.get(i5);
        if (s4) {
          e8.delete(i5), t3.set(i5, s4);
          continue;
        }
        if (!r4.layer.loaded) {
          this.updatingHandles.addPromise(r4.layer.load());
          continue;
        }
        const n7 = this._createSourceInfo(r4);
        r(n7) && t3.set(i5, n7);
      }
    for (const [, r4] of e8)
      r4.destroy();
    return t3;
  }
  initialize() {
    this.updatingHandles.add(() => this.snappingSources, () => this.notifyChange("updating"), U), r(this.view) && this.handles.add([this.view.on("layerview-create", (e8) => this._updateLayerView(e8.layer, e8.layerView)), this.view.on("layerview-destroy", (e8) => this._updateLayerView(e8.layer, null))]);
  }
  _updateLayerView(e8, t3) {
    for (const [, r4] of this.snappingSources)
      r4.snappingSource.layerSource.layer === e8 && (r4.layerView = t3);
  }
  destroy() {
    this._set("options", null);
    for (const [, e8] of this.snappingSources)
      e8.destroy();
  }
  async fetchCandidates(e8, t3, r4) {
    if (t(this.options) || !this.options.effectiveFeatureEnabled)
      return [];
    const i5 = [], n7 = this._computeScreeenSizeDistanceParameters(e8, t3), u2 = { distance: n7, point: e8, coordinateHelper: t3.coordinateHelper, types: this.types, filter: null };
    for (const [, { snappingSource: s4, layerView: a3 }] of this.snappingSources)
      !s4.layerSource.enabled || r(a3) && a3.suspended || i5.push(s4.fetchCandidates(u2, r4).then((e9) => e9.filter((e10) => !this._candidateIsExcluded(s4, e10, t3.excludeFeature))));
    const p7 = (await C(i5)).flat();
    return this._addRightAngleCandidates(p7, e8, n7, t3), f(r4), r3(e8, p7), p7;
  }
  _addRightAngleCandidates(e8, t3, r4, i5) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const s4 = r(i5.vertexHandle) ? (_b = (_a = i5.vertexHandle.rightEdge) == null ? void 0 : _a.rightVertex) == null ? void 0 : _b.pos : r(i5.editGeometryOperations) && "polygon" === i5.editGeometryOperations.data.type ? (_d = e2((_c = i5.editGeometryOperations.data.components[0]) == null ? void 0 : _c.getFirstVertex())) == null ? void 0 : _d.pos : null, a3 = r(i5.vertexHandle) ? (_f = (_e = i5.vertexHandle.leftEdge) == null ? void 0 : _e.leftVertex) == null ? void 0 : _f.pos : r(i5.editGeometryOperations) ? (_h = e2((_g = i5.editGeometryOperations.data.components[0]) == null ? void 0 : _g.getLastVertex())) == null ? void 0 : _h.pos : null, c3 = e8.length;
    for (let o4 = 0; o4 < c3; o4++)
      this._addRightAngleCandidate(e8[o4], a3, t3, r4, i5, e8), this._addRightAngleCandidate(e8[o4], s4, t3, r4, i5, e8);
  }
  _addRightAngleCandidate(e8, t3, r4, i5, o4, n7) {
    if (t(t3) || !(e8 instanceof e6))
      return;
    const a3 = e8.constraint.closestTo(t3), c3 = (a3[0] - r4[0]) / i5.x, u2 = (a3[1] - r4[1]) / i5.y;
    if (c3 * c3 + u2 * u2 <= 1) {
      const r5 = o4.coordinateHelper;
      n7.push(new o2({ coordinateHelper: r5, targetPoint: a3, otherVertex: t3, otherVertexType: n6.NEXT, previousVertex: e8.constraint.start, constraint: new q(r5, t3, a3), objectId: e8.objectId, elevationInfo: e8.elevationInfo }));
    }
  }
  _computeScreeenSizeDistanceParameters(e8, t3) {
    const r4 = r(this.options) ? this.options.distance * ("touch" === t3.pointer ? this.options.touchSensitivityMultiplier : 1) : 0;
    if (t(this.view))
      return { x: r4, y: r4, pixelSize: r4 };
    if ("2d" === this.view.type) {
      const e9 = r4 * this.view.resolution;
      return { x: e9, y: e9, pixelSize: e9 };
    }
    return this._computeScreenSizeDistanceParameters3D(e8, r4, this.view, t3);
  }
  _computeScreenSizeDistanceParameters3D(e8, t3, r4, i5) {
    const { coordinateHelper: o4, elevationInfo: s4 } = i5, n7 = r4.state.camera.computeScreenPixelSizeAt(l2(e8, o4, s4, r4, M)), a3 = n7 * r4.renderCoordsHelper.unitInMeters / r4.mapCoordsHelper.unitInMeters, c3 = t3 * a3;
    return { x: c3 / this._computeScreenMagnitudeOfMapOffset(e8, a3, 0, r4, i5), y: c3 / this._computeScreenMagnitudeOfMapOffset(e8, 0, a3, r4, i5), pixelSize: n7 };
  }
  _computeScreenMagnitudeOfMapOffset(e8, t3, r4, i5, { coordinateHelper: o4, elevationInfo: s4 }) {
    const n7 = o4.clone(e8);
    n7[0] += t3, n7[1] += r4;
    const a3 = R(e8, o4, s4, i5), c3 = R(n7, o4, s4, i5), u2 = c3.x - a3.x, p7 = c3.y - a3.y;
    return Math.sqrt(u2 * u2 + p7 * p7);
  }
  get types() {
    return E.EDGE | E.VERTEX;
  }
  _candidateIsExcluded(e8, t3, r4) {
    if (t(r4))
      return false;
    const i5 = this._getCandidateObjectId(t3);
    if (t(i5))
      return false;
    const o4 = e8.layerSource.layer;
    return "graphics" === o4.type ? r4.uid === i5 : r4.sourceLayer === o4 && (!(!r4.attributes || !("objectIdField" in o4)) && r4.attributes[o4.objectIdField] === i5);
  }
  _getCandidateObjectId(e8) {
    return e8 instanceof e5 ? e8.objectId : null;
  }
  _createSourceInfo(e8) {
    const t3 = this._createFeatureSnappingSourceType(e8);
    if (t(t3))
      return null;
    if ("loading" in t3)
      return this.updatingHandles.addPromise(t3.loading.then(() => {
        this.destroyed || this.notifyChange("snappingSources");
      })), null;
    const r4 = r(this.view) ? this.view.allLayerViews.find((t4) => t4.layer === e8.layer) : null;
    return new H2(t3.source, r4);
  }
  _createFeatureSnappingSourceType(e8) {
    switch (e8.layer.type) {
      case "feature":
      case "geojson":
      case "csv":
      case "subtype-group":
      case "wfs":
        return this._createFeatureSnappingSourceFeatureLayer(e8);
      case "graphics":
        return this._createFeatureSnappingSourceGraphicsLayer(e8);
    }
    return null;
  }
  _createFeatureSnappingSourceFeatureLayer(e8) {
    switch (e8.layer.source.type) {
      case "feature-layer": {
        const t3 = this._getSourceModule("featureService");
        return r(t3.module) ? { source: new t3.module.FeatureServiceSnappingSource({ spatialReference: this.spatialReference, view: this.view, layerSource: e8 }) } : { loading: t3.loader };
      }
      case "memory":
      case "csv":
      case "geojson":
      case "wfs": {
        if ("mesh" === e8.layer.geometryType)
          return null;
        const t3 = this._getSourceModule("featureCollection");
        return r(t3.module) ? { source: new t3.module.FeatureCollectionSnappingSource({ layerSource: e8 }) } : { loading: t3.loader };
      }
    }
    return null;
  }
  _createFeatureSnappingSourceGraphicsLayer(e8) {
    const t3 = this._getSourceModule("graphics");
    return r(t3.module) ? { source: new t3.module.GraphicsSnappingSource({ spatialReference: this.spatialReference, view: this.view, layerSource: e8 }) } : { loading: t3.loader };
  }
  _getSourceModule(e8) {
    const t3 = this.sourceModules[e8];
    if (t(t3.loader)) {
      const r4 = this._loadSourceModule(e8).then((e9) => {
        t3.module = e9;
      });
      return t3.loader = r4, { module: t3.module, loader: r4 };
    }
    return { module: t3.module, loader: t3.loader };
  }
  _loadSourceModule(e8) {
    switch (e8) {
      case "featureService":
        return this.updatingHandles.addPromise(import("./FeatureServiceSnappingSource-CPMDP64A.js"));
      case "featureCollection":
        return this.updatingHandles.addPromise(import("./FeatureCollectionSnappingSource-LDBKAZ5F.js"));
      case "graphics":
        return this.updatingHandles.addPromise(import("./GraphicsSnappingSource-GVCMVEN3.js"));
    }
    return null;
  }
};
e([d({ constructOnly: true })], C2.prototype, "spatialReference", void 0), e([d({ constructOnly: true })], C2.prototype, "view", void 0), e([d()], C2.prototype, "options", void 0), e([d({ readOnly: true })], C2.prototype, "updating", null), e([d({ readOnly: true })], C2.prototype, "snappingSources", null), C2 = e([n2("esri.views.interactive.snapping.FeatureSnappingEngine")], C2);
var H2 = class {
  constructor(e8, t3) {
    this.snappingSource = e8, this.layerView = t3, this.handles = new u();
    const i5 = this.snappingSource.layerSource.layer;
    if ("refresh" in i5) {
      const t4 = i5;
      this.handles.add(t4.on("refresh", () => e8.refresh()));
    }
    this.handles.add([l(() => e8.updating, (t4) => e8.layerSource.updating = t4, w), l(() => e8.availability, (t4) => e8.layerSource.availability = t4, w)]);
  }
  destroy() {
    this.snappingSource.destroy(), this.handles.destroy();
  }
};
var M = n3();

// node_modules/@arcgis/core/views/interactive/snapping/SnappingAlgorithm.js
var i3 = class {
  constructor(e8, r4) {
    this.view = e8, this.options = r4, this.squaredShortLineThreshold = p3.shortLineThreshold * p3.shortLineThreshold;
  }
  snap(t3, r4) {
    return r(r4.vertexHandle) ? "vertex" !== r4.vertexHandle.type ? [] : this.snapExistingVertex(t3, r4) : this.snapNewVertex(t3, r4);
  }
  edgeExceedsShortLineThreshold(e8, t3) {
    return this.exceedsShortLineThreshold(e8.leftVertex.pos, e8.rightVertex.pos, t3);
  }
  exceedsShortLineThreshold(e8, t3, { elevationInfo: i5, editGeometryOperations: o4 }) {
    const h2 = o4.data.coordinateHelper;
    return 0 === this.squaredShortLineThreshold || E2(R(t3, h2, i5, this.view), R(e8, h2, i5, this.view)) > this.squaredShortLineThreshold;
  }
  squaredProximityTreshold(e8) {
    return "touch" === e8 ? this.squaredTouchProximityThreshold : this.squaredMouseProximityTreshold;
  }
  get squaredMouseProximityTreshold() {
    return this.options.distance * this.options.distance;
  }
  get squaredTouchProximityThreshold() {
    const { distance: e8, touchSensitivityMultiplier: t3 } = this.options, r4 = e8 * t3;
    return r4 * r4;
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/candidates/LineSnappingCandidate.js
var a = class extends t2 {
  constructor({ coordinateHelper: t3, lineStart: n7, lineEnd: e8, targetPoint: r4, elevationInfo: a3 }) {
    super(t3, r4, new H(t3, n7, e8), a3), this.referenceLineHint = new s2(e3.REFERENCE_EXTENSION, n7, e8, a3);
  }
  get hints() {
    return [this.referenceLineHint, new s2(e3.TARGET, this._lineEndClosestToTarget(), this.targetPoint, this.elevationInfo)];
  }
  _lineEndClosestToTarget() {
    const e8 = this.constraint.start, i5 = this.constraint.end;
    return Math.sign(j2(o(c, i5, e8), o(p6, this.targetPoint, e8))) > 0 ? i5 : e8;
  }
};
var p6 = n5();
var c = n5();

// node_modules/@arcgis/core/views/interactive/snapping/LineSnapper.js
var d4 = class extends i3 {
  snapNewVertex(e8, t3) {
    const o4 = t3.editGeometryOperations.data.components[0], r4 = o4.edges.length, s4 = [];
    if (r4 < 1)
      return s4;
    const n7 = t3.coordinateHelper, d6 = R(e8, n7, t3.elevationInfo, this.view), p7 = o4.edges[r4 - 1];
    let a3 = p7;
    do {
      this.edgeExceedsShortLineThreshold(a3, t3) && this._processCandidateProposal(a3.leftVertex.pos, a3.rightVertex.pos, e8, d6, t3, s4), a3 = a3.leftVertex.leftEdge;
    } while (a3 && a3 !== p7);
    return s4;
  }
  snapExistingVertex(t3, o4) {
    const r4 = [], s4 = e2(o4.vertexHandle), n7 = s4.component;
    if (n7.edges.length < 2)
      return r4;
    const d6 = o4.coordinateHelper, p7 = R(t3, d6, o4.elevationInfo, this.view), a3 = s4.leftEdge, h2 = s4.rightEdge;
    a3 && h2 && this.edgeExceedsShortLineThreshold(a3, o4) && this.edgeExceedsShortLineThreshold(h2, o4) && this._processCandidateProposal(a3.leftVertex.pos, h2.rightVertex.pos, t3, p7, o4, r4);
    const l4 = n7.edges[0];
    let g = l4;
    do {
      g !== s4.leftEdge && g !== s4.rightEdge && this.edgeExceedsShortLineThreshold(g, o4) && this._processCandidateProposal(g.leftVertex.pos, g.rightVertex.pos, t3, p7, o4, r4), g = g.rightVertex.rightEdge;
    } while (g && g !== l4);
    return r4;
  }
  _processCandidateProposal(e8, o4, d6, p7, a3, h2) {
    const l4 = L(n5(), d6, e8, o4), { coordinateHelper: g, elevationInfo: c3, pointer: f3 } = a3, m5 = g.fromXYZ(l4, g.getZ(d6, 0));
    E2(p7, R(m5, g, c3, this.view)) < this.squaredProximityTreshold(f3) && h2.push(new a({ coordinateHelper: g, lineStart: e8, lineEnd: o4, targetPoint: m5, elevationInfo: c3 }));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/candidates/ParallelLineSnappingCandidate.js
var o3 = class extends t2 {
  constructor({ coordinateHelper: i5, referenceLine: r4, lineStart: s4, targetPoint: a3, elevationInfo: o4 }) {
    const f3 = i5.clone(s4);
    o(f3, s(f3, f3, r4.rightVertex.pos), r4.leftVertex.pos), super(i5, a3, new H(i5, s4, f3), o4), this._referenceLines = [{ edge: r4, fadeLeft: true, fadeRight: true }];
  }
  get hints() {
    const e8 = this.elevationInfo;
    return [new s2(e3.TARGET, this.constraint.start, this.targetPoint, e8), new e4(this.constraint.start, this.targetPoint, e8), ...this._referenceLines.map((t3) => new s2(e3.REFERENCE, t3.edge.leftVertex.pos, t3.edge.rightVertex.pos, e8, t3.fadeLeft, t3.fadeRight))];
  }
  addReferenceLine(e8) {
    const t3 = { edge: e8, fadeLeft: true, fadeRight: true };
    this._referenceLines.forEach((n7) => {
      e8.rightVertex.rightEdge === n7.edge && (n7.fadeLeft = false, t3.fadeRight = false), e8.leftVertex.leftEdge === n7.edge && (n7.fadeRight = false, t3.fadeLeft = false);
    }), this._referenceLines.push(t3);
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/ParallelLineSnapper.js
var c2 = class extends i3 {
  constructor() {
    super(...arguments), this._tmpProjection = n5();
  }
  snapNewVertex(e8, t3) {
    const r4 = t3.editGeometryOperations.data.components[0], o4 = r4.edges.length, i5 = r4.vertices.length, s4 = [];
    if (o4 < 2)
      return s4;
    const n7 = R(e8, t3.coordinateHelper, t3.elevationInfo, this.view), a3 = r4.vertices[i5 - 1], c3 = r4.vertices[0], h2 = r4.edges[o4 - 1];
    let p7 = h2;
    do {
      this.edgeExceedsShortLineThreshold(p7, t3) && (this._checkEdgeForParalleLines(p7, a3.pos, e8, n7, t3, s4), this._checkEdgeForParalleLines(p7, c3.pos, e8, n7, t3, s4)), p7 = p7.leftVertex.leftEdge;
    } while (p7 && p7 !== h2);
    return s4;
  }
  snapExistingVertex(t3, r4) {
    const o4 = [], i5 = e2(r4.vertexHandle), s4 = i5.component;
    if (s4.edges.length < 3)
      return o4;
    const n7 = R(t3, r4.coordinateHelper, r4.elevationInfo, this.view), a3 = i5.leftEdge, c3 = i5.rightEdge, h2 = s4.vertices[0], p7 = s4.vertices.length, d6 = s4.vertices[p7 - 1], g = s4.edges[0];
    let m5 = g;
    do {
      m5 !== a3 && m5 !== c3 && this.edgeExceedsShortLineThreshold(m5, r4) && (a3 && this._checkEdgeForParalleLines(m5, a3.leftVertex.pos, t3, n7, r4, o4), c3 && this._checkEdgeForParalleLines(m5, c3.rightVertex.pos, t3, n7, r4, o4), i5 === h2 ? this._checkEdgeForParalleLines(m5, d6.pos, t3, n7, r4, o4) : i5 === d6 && this._checkEdgeForParalleLines(m5, h2.pos, t3, n7, r4, o4)), m5 = m5.rightVertex.rightEdge;
    } while (m5 && m5 !== g);
    return o4;
  }
  _checkEdgeForParalleLines(e8, r4, i5, c3, h2, p7) {
    const d6 = e8.leftVertex.pos, g = e8.rightVertex.pos;
    if (L(this._tmpProjection, r4, d6, g), b(this._tmpProjection, r4) < p3.parallelLineThreshold)
      return;
    L(this._tmpProjection, i5, d6, g, r4);
    const { coordinateHelper: m5, elevationInfo: f3, pointer: v } = h2, P = m5.fromXYZ(this._tmpProjection, m5.getZ(i5, 0));
    if (E2(c3, R(P, m5, f3, this.view)) < this.squaredProximityTreshold(v)) {
      if (this._parallelToPreviousCandidate(e8, p7))
        return;
      p7.push(new o3({ coordinateHelper: m5, referenceLine: e8, lineStart: r4, targetPoint: P, elevationInfo: f3 }));
    }
  }
  _parallelToPreviousCandidate(e8, r4) {
    const i5 = e8.leftVertex.pos, s4 = e8.rightVertex.pos;
    for (const n7 of r4)
      if (L(this._tmpProjection, s4, n7.constraint.start, n7.constraint.end, i5), b(this._tmpProjection, s4) < p3.parallelLineThreshold)
        return n7.addReferenceLine(e8), true;
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/RightAngleSnapper.js
var f2 = class extends i3 {
  constructor() {
    super(...arguments), this._tmp = n5();
  }
  snapNewVertex(e8, t3) {
    const r4 = t3.editGeometryOperations.data.components[0], i5 = r4.vertices.length, o4 = [];
    if (i5 < 2)
      return o4;
    const s4 = R(e8, t3.coordinateHelper, t3.elevationInfo, this.view), n7 = r4.vertices[i5 - 1];
    this._checkForSnappingCandidate(o4, n7.leftEdge, n7.pos, e8, n7.leftEdge.leftVertex.pos, n7.pos, t3, e8, s4);
    const p7 = r4.vertices[0];
    return this._checkForSnappingCandidate(o4, p7.rightEdge, p7.pos, e8, p7.rightEdge.rightVertex.pos, p7.pos, t3, e8, s4), o4;
  }
  snapExistingVertex(t3, r4) {
    const i5 = [], o4 = e2(r4.vertexHandle), s4 = o4.component, n7 = s4.vertices.length;
    if (n7 < 3)
      return i5;
    const p7 = R(t3, r4.coordinateHelper, r4.elevationInfo, this.view), g = o4.leftEdge, h2 = o4.rightEdge, a3 = s4.vertices[0], d6 = s4.vertices[n7 - 1];
    if (!g)
      return this._checkForSnappingCandidate(i5, a3.rightEdge.rightVertex.rightEdge, a3.rightEdge.rightVertex.pos, t3, a3.rightEdge.rightVertex.rightEdge.rightVertex.pos, a3.rightEdge.rightVertex.pos, r4, t3, p7), i5;
    if (!h2)
      return this._checkForSnappingCandidate(i5, d6.leftEdge.leftVertex.leftEdge, d6.leftEdge.leftVertex.pos, t3, d6.leftEdge.leftVertex.leftEdge.leftVertex.pos, d6.leftEdge.leftVertex.pos, r4, t3, p7), i5;
    if (g && g.leftVertex.leftEdge) {
      const e8 = g.leftVertex.leftEdge;
      this._checkForSnappingCandidate(i5, e8, g.leftVertex.pos, t3, e8.leftVertex.pos, g.leftVertex.pos, r4, t3, p7);
    }
    if (h2 && h2.rightVertex.rightEdge) {
      const e8 = h2.rightVertex.rightEdge;
      this._checkForSnappingCandidate(i5, e8, h2.rightVertex.pos, t3, e8.rightVertex.pos, h2.rightVertex.pos, r4, t3, p7);
    }
    return i5;
  }
  _checkForSnappingCandidate(e8, p7, f3, l4, x, V, m5, E3, v) {
    if (!this.edgeExceedsShortLineThreshold(p7, m5))
      return;
    o(this._tmp, p7.rightVertex.pos, p7.leftVertex.pos);
    const u2 = r2(this._tmp[1], -this._tmp[0]), _2 = j2(u2, o(this._tmp, l4, f3)) / p2(u2), { coordinateHelper: S, elevationInfo: C3, pointer: k } = m5, j3 = S.fromXYZ(d2(n5(), V, u2, _2), S.getZ(E3, 0));
    E2(v, R(j3, S, C3, this.view)) < this.squaredProximityTreshold(k) && e8.push(new o2({ coordinateHelper: S, targetPoint: j3, constraint: new q(S, V, d2(S.createVector(), V, u2, Math.sign(_2))), previousVertex: x, otherVertex: V, otherVertexType: n6.CENTER, elevationInfo: C3 }));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/candidates/RightAngleTriangleSnappingCandidate.js
var a2 = class extends t2 {
  constructor({ coordinateHelper: i5, targetPoint: o4, point1: p7, point2: r4, elevationInfo: e8 }) {
    super(i5, o4, new T(i5, A(h, p7, r4, 0.5), 0.5 * m(p7, r4)), e8), this.p1 = p7, this.p2 = r4;
  }
  get hints() {
    const t3 = this.elevationInfo;
    return [new s2(e3.REFERENCE, this.targetPoint, this.p1, t3), new s2(e3.REFERENCE, this.targetPoint, this.p2, t3), new i2(this.p1, this.targetPoint, this.p2, t3)];
  }
};
var h = n5();

// node_modules/@arcgis/core/views/interactive/snapping/RightAngleTriangleSnapper.js
var d5 = class extends i3 {
  snapNewVertex(e8, t3) {
    const o4 = t3.editGeometryOperations.data.components[0], r4 = [], s4 = o4.vertices.length;
    if ("polygon" !== t3.editGeometryOperations.data.type || s4 < 2)
      return r4;
    const i5 = o4.vertices[0], n7 = o4.vertices[s4 - 1];
    return this._processCandidateProposal(i5.pos, n7.pos, e8, t3, r4), r4;
  }
  snapExistingVertex(t3, o4) {
    const r4 = [], s4 = e2(o4.vertexHandle), i5 = s4.component;
    return i5.edges.length < 2 ? r4 : "polyline" !== o4.editGeometryOperations.data.type || 0 !== s4.index && s4.index !== i5.vertices.length - 1 ? (this._processCandidateProposal(s4.leftEdge.leftVertex.pos, s4.rightEdge.rightVertex.pos, t3, o4, r4), r4) : r4;
  }
  _processCandidateProposal(e8, s4, d6, l4, m5) {
    if (!this.exceedsShortLineThreshold(e8, s4, l4))
      return;
    const c3 = A(n5(), e8, s4, 0.5), g = 0.5 * m(e8, s4), h2 = m2(n5(), d6, c3, g), { coordinateHelper: f3, elevationInfo: v, pointer: x } = l4, u2 = f3.fromXYZ(h2, f3.getZ(d6, 0)), y2 = R(d6, f3, v, this.view);
    E2(y2, R(u2, f3, v, this.view)) < this.squaredProximityTreshold(x) && m5.push(new a2({ coordinateHelper: f3, targetPoint: u2, point1: e8, point2: s4, elevationInfo: v }));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SelfSnappingEngine.js
var m3 = class extends y {
  constructor(s4) {
    super(s4), this.updating = false, this._snappers = new j();
  }
  initialize() {
    this._snappers.push(new c2(this.view, this.options), new d4(this.view, this.options), new f2(this.view, this.options), new d5(this.view, this.options));
  }
  set options(s4) {
    this._set("options", s4);
    for (const o4 of this._snappers)
      o4.options = s4;
  }
  async fetchCandidates(s4, o4) {
    if (!this.options.effectiveSelfEnabled)
      return [];
    const t3 = [];
    for (const r4 of this._snappers.items)
      t3.push(...r4.snap(s4, o4));
    return r3(s4, t3), t3;
  }
};
e([d({ readOnly: true })], m3.prototype, "updating", void 0), e([d({ constructOnly: true })], m3.prototype, "view", void 0), e([d()], m3.prototype, "options", null), m3 = e([n2("esri.views.interactive.snapping.SelfSnappingEngine")], m3);

// node_modules/@arcgis/core/views/interactive/snapping/snappingFactory.js
function i4(i5, p7) {
  return [new m3({ view: i5, options: p7 }), new C2({ view: i5, options: p7, spatialReference: i5.spatialReference })];
}

// node_modules/@arcgis/core/views/interactive/snapping/candidates/IntersectionSnappingCandidate.js
var s3 = class extends t2 {
  constructor(i5, n7, s4, r4, o4) {
    super(i5, n7, new L2(i5, n7, s4.constraint, r4.constraint), o4), this.first = s4, this.second = r4;
  }
  get hints() {
    return this.first.targetPoint = this.targetPoint, this.second.targetPoint = this.targetPoint, [...this.first.hints, ...this.second.hints, new i(this.targetPoint, this.elevationInfo)];
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SnappingManager.js
var _ = class extends n4.EventedMixin(d3) {
  constructor(t3) {
    super(t3), this.options = new l3(), this.snappingEnginesFactory = i4, this._engines = [], this._currentMainCandidate = null, this._currentOtherActiveCandidates = [];
  }
  initialize() {
    this.handles.add([l(() => {
      const { effectiveFeatureEnabled: t3, effectiveSelfEnabled: e8, touchSensitivityMultiplier: i5, distance: n7 } = this.options;
      return { effectiveFeatureEnabled: t3, effectiveSelfEnabled: e8, touchSensitivityMultiplier: i5, distance: n7 };
    }, () => {
      this.doneSnapping(), this.emit("changed");
    }, U), l(() => this.options, (t3) => {
      for (const e8 of this._engines)
        e8.options = t3;
    }, U), l(() => ({ viewReady: this.view.ready, viewSpatialReference: this.view.spatialReference, snappingEnginesFactory: this.snappingEnginesFactory }), ({ viewReady: t3, snappingEnginesFactory: e8 }) => this._recreateEngines(t3, e8), w)]);
  }
  destroy() {
    this._destroyEngines();
  }
  get updating() {
    return this._engines.some((t3) => t3.updating);
  }
  _recreateEngines(t3, e8) {
    if (this._destroyEngines(), !t3)
      return;
    const { view: i5, options: n7 } = this;
    this._engines = e8(i5, n7);
  }
  _destroyEngines() {
    for (const t3 of this._engines)
      t3.destroy();
    this._engines = [];
  }
  get squaredMouseProximityTreshold() {
    return this.options.distance * this.options.distance;
  }
  get squaredTouchProximityThreshold() {
    const { distance: t3, touchSensitivityMultiplier: e8 } = this.options, i5 = t3 * e8;
    return i5 * i5;
  }
  async snap(t3, e8, i5) {
    const r4 = e8.coordinateHelper.pointToVector(t3), o4 = await this._fetchCandidates(r4, e8, i5);
    return { get valid() {
      return !p(i5);
    }, apply: () => {
      const { snappedPoint: t4, hints: i6 } = this._processCandidates(r4, o4, e8);
      return this._removeVisualization(), r(e8.visualizer) && this.handles.add(e8.visualizer.draw(i6, { coordinateHelper: e8.coordinateHelper, elevationInfo: e8.elevationInfo, view: this.view }), m4), t4;
    } };
  }
  update(t3, e8) {
    this._removeVisualization();
    let i5 = t3;
    const s4 = [];
    if (r(this._currentMainCandidate)) {
      const n7 = e8.coordinateHelper, r4 = n7.pointToVector(t3), o4 = this._currentMainCandidate.constraint.closestTo(r4);
      if (E2(R(r4, n7, e8.elevationInfo, this.view), R(o4, n7, e8.elevationInfo, this.view)) < this._squaredPointProximityThreshold(e8.pointer)) {
        i5 = n7.vectorToDehydratedPoint(o4), this._currentMainCandidate.targetPoint = o4, s4.push(...this._currentMainCandidate.hints);
        for (const t4 of this._currentOtherActiveCandidates)
          t4.targetPoint = o4, s4.push(...t4.hints);
      } else
        this._currentMainCandidate = null, this._currentOtherActiveCandidates = [];
    }
    return r(e8.visualizer) && this.handles.add(e8.visualizer.draw(s4, { coordinateHelper: e8.coordinateHelper, elevationInfo: e8.elevationInfo, view: this.view }), m4), i5;
  }
  doneSnapping() {
    this._removeVisualization(), this._currentMainCandidate = null, this._currentOtherActiveCandidates = [];
  }
  _removeVisualization() {
    this.handles.remove(m4);
  }
  async _fetchCandidates(t3, e8, i5) {
    return (await Promise.all(this._engines.map((n7) => n7.fetchCandidates(t3, e8, i5)))).flat();
  }
  _processCandidates(t3, e8, i5) {
    if (e8.length < 1)
      return this.doneSnapping(), { snappedPoint: i5.coordinateHelper.vectorToDehydratedPoint(t3), hints: [] };
    r3(t3, e8);
    const s4 = this._currentMainCandidate;
    if (r(s4)) {
      const n7 = this._findOldConstraintInNewCandidates(s4, e8);
      if (n7 >= 0) {
        if (!(e8[n7] instanceof s3))
          return this._intersectWithOtherCandidates(n7, e8, t3, i5);
        if (b(t3, s4.targetPoint) < this._squaredPointProximityThreshold(i5.pointer))
          return this._updateSnappingCandidate(s4, e8, i5);
      }
    }
    return this._intersectWithOtherCandidates(0, e8, t3, i5);
  }
  _findOldConstraintInNewCandidates(t3, e8) {
    return t3 instanceof s3 ? this._findOldCandidateIndex(e8, t3.first) >= 0 && this._findOldCandidateIndex(e8, t3.second) >= 0 ? 0 : -1 : this._findOldCandidateIndex(e8, t3);
  }
  _intersectWithOtherCandidates(t3, e8, i5, n7) {
    const s4 = e8[t3], r4 = [], o4 = n7.coordinateHelper;
    for (let a3 = 0; a3 < e8.length; ++a3) {
      if (a3 === t3)
        continue;
      const d6 = e8[a3];
      for (const t4 of s4.constraint.intersect(d6.constraint)) {
        const e9 = o4.fromXYZ(t4.intersection, s4.targetPoint[2]);
        r4.push([new s3(o4, e9, s4, d6, d6.elevationInfo), E2(R(i5, n7.coordinateHelper, n7.elevationInfo, this.view), R(e9, n7.coordinateHelper, n7.elevationInfo, this.view))]);
      }
    }
    return r4.length > 0 && (r4.sort((t4, e9) => t4[1] - e9[1]), r4[0][1] < this._squaredPointProximityThreshold(n7.pointer)) ? this._updateSnappingCandidate(r4[0][0], e8, n7) : this._updateSnappingCandidate(s4, e8, n7);
  }
  _updateSnappingCandidate(t3, e8, i5) {
    this.doneSnapping(), this._currentMainCandidate = t3;
    const n7 = this._currentMainCandidate.targetPoint, s4 = [];
    s4.push(...t3.hints);
    for (const r4 of e8) {
      if (t3 instanceof s3) {
        if (r4.constraint.objectEqual(t3.first.constraint) || r4.constraint.objectEqual(t3.second.constraint))
          continue;
      } else if (r4.constraint.objectEqual(t3.constraint))
        continue;
      r4.constraint.check(n7) && (r4.targetPoint = n7, this._currentOtherActiveCandidates.push(r4), s4.push(...r4.hints));
    }
    return { snappedPoint: i5.coordinateHelper.vectorToDehydratedPoint(n7), hints: s4 };
  }
  _squaredPointProximityThreshold(t3) {
    return "touch" === t3 ? this.squaredTouchProximityThreshold : this.squaredMouseProximityTreshold;
  }
  _findOldCandidateIndex(t3, e8) {
    let i5 = -1;
    for (let n7 = 0; n7 < t3.length; ++n7)
      if (e8.constraint.objectEqual(t3[n7].constraint)) {
        i5 = n7;
        break;
      }
    return i5;
  }
  get test() {
    return { visualizationsActive: this.handles.has(m4), engines: this._engines };
  }
};
e([d({ constructOnly: true })], _.prototype, "view", void 0), e([d()], _.prototype, "options", void 0), e([d({ readOnly: true })], _.prototype, "updating", null), e([d()], _.prototype, "snappingEnginesFactory", void 0), e([d()], _.prototype, "_engines", void 0), e([d()], _.prototype, "squaredMouseProximityTreshold", null), e([d()], _.prototype, "squaredTouchProximityThreshold", null), _ = e([n2("esri.views.interactive.snapping.SnappingManager")], _);
var m4 = "visualization-handle";

export {
  p4 as p,
  l3 as l,
  _
};
//# sourceMappingURL=chunk-D7PQAHH6.js.map
