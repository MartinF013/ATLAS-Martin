import {
  e
} from "./chunk-Z4FD36CT.js";
import {
  s as s3,
  t as t2
} from "./chunk-OZT6RDST.js";
import {
  c,
  f,
  l,
  y
} from "./chunk-4PRVTUEZ.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/graphics/featureConversionUtils.js
function h(e2, t3) {
  return e2 ? t3 ? 4 : 3 : t3 ? 3 : 2;
}
var a = s.getLogger("esri.layers.graphics.featureConversionUtils");
var g = { esriGeometryPoint: 0, esriGeometryPolyline: 2, esriGeometryPolygon: 3, esriGeometryMultipoint: 0 };
var d = (e2, t3, n, o, r2, s4) => {
  e2[n] = r2, e2[n + 1] = s4;
};
var m = (e2, t3, n, o, r2, s4) => {
  e2[n] = r2, e2[n + 1] = s4, e2[n + 2] = t3[o + 2];
};
var y2 = (e2, t3, n, o, r2, s4) => {
  e2[n] = r2, e2[n + 1] = s4, e2[n + 2] = t3[o + 3];
};
var p = (e2, t3, n, o, r2, s4) => {
  e2[n] = r2, e2[n + 1] = s4, e2[n + 2] = t3[o + 2], e2[n + 3] = t3[o + 3];
};
function I(e2, t3, n, o) {
  if (e2) {
    if (n)
      return t3 && o ? p : m;
    if (t3 && o)
      return y2;
  } else if (t3 && o)
    return m;
  return d;
}
function b({ scale: e2, translate: t3 }, n) {
  return Math.round((n - t3[0]) / e2[0]);
}
function M({ scale: e2, translate: t3 }, n) {
  return Math.round((t3[1] - n) / e2[1]);
}
function w({ scale: e2, translate: t3 }, n) {
  return n * e2[0] + t3[0];
}
function N({ scale: e2, translate: t3 }, n) {
  return t3[1] - n * e2[1];
}
function G(e2, t3, n) {
  return e2 ? t3 ? n ? k(e2) : P(e2) : n ? Z(e2) : T(e2) : null;
}
function T(e2) {
  const t3 = e2.coords;
  return { x: t3[0], y: t3[1] };
}
function F(e2, t3) {
  return e2.coords[0] = t3.x, e2.coords[1] = t3.y, e2;
}
function P(e2) {
  const t3 = e2.coords;
  return { x: t3[0], y: t3[1], z: t3[2] };
}
function x(e2, t3) {
  return e2.coords[0] = t3.x, e2.coords[1] = t3.y, e2.coords[2] = t3.z, e2;
}
function Z(e2) {
  const t3 = e2.coords;
  return { x: t3[0], y: t3[1], m: t3[2] };
}
function j(e2, t3) {
  return e2.coords[0] = t3.x, e2.coords[1] = t3.y, e2.coords[2] = t3.m, e2;
}
function k(e2) {
  const t3 = e2.coords;
  return { x: t3[0], y: t3[1], z: t3[2], m: t3[3] };
}
function E(e2, t3) {
  return e2.coords[0] = t3.x, e2.coords[1] = t3.y, e2.coords[2] = t3.z, e2.coords[3] = t3.m, e2;
}
function z(e2, t3, n, r2) {
  let s4 = T;
  n && r2 ? s4 = k : n ? s4 = P : r2 && (s4 = Z);
  for (const c2 of t3) {
    const { geometry: t4, attributes: n2 } = c2, r3 = r(t4) ? s4(t4) : null;
    e2.push({ attributes: n2, geometry: r3 });
  }
  return e2;
}
function v(e2, t3) {
  return e2 && t3 ? E : e2 ? x : t3 ? j : F;
}
function S(e2, t3, n, o, r2) {
  const s4 = v(n, o);
  for (const c2 of t3) {
    const { geometry: t4, attributes: n2 } = c2;
    let o2;
    t4 && (o2 = s4(new t2(), t4)), e2.push(new s3(o2, n2, null, n2[r2]));
  }
  return e2;
}
function V(e2, t3, n = v(null != t3.z, null != t3.m)) {
  return n(e2, t3);
}
function Y(e2, t3, n, o) {
  for (const r2 of t3) {
    const { geometry: t4, attributes: s4 } = r2;
    let c2;
    t4 && (c2 = _(t4, n, o)), e2.push({ attributes: s4, geometry: c2 });
  }
  return e2;
}
function _(e2, t3, o) {
  if (t(e2))
    return null;
  const r2 = h(t3, o), s4 = [];
  for (let n = 0; n < e2.coords.length; n += r2) {
    const t4 = [];
    for (let o2 = 0; o2 < r2; o2++)
      t4.push(e2.coords[n + o2]);
    s4.push(t4);
  }
  return t3 ? o ? { points: s4, hasZ: t3, hasM: o } : { points: s4, hasZ: t3 } : o ? { points: s4, hasM: o } : { points: s4 };
}
function O(e2, t3, n, o, r2) {
  const s4 = h(n, o);
  for (const c2 of t3) {
    const t4 = c2.geometry, n2 = c2.attributes;
    let o2;
    t4 && (o2 = U(new t2(), t4, s4)), e2.push(new s3(o2, n2, null, n2[r2]));
  }
  return e2;
}
function U(e2, t3, n = h(t3.hasZ, t3.hasM)) {
  e2.lengths[0] = t3.points.length;
  const o = e2.coords;
  let r2 = 0;
  for (const s4 of t3.points)
    for (let e3 = 0; e3 < n; e3++)
      o[r2++] = s4[e3];
  return e2;
}
function A(e2, t3, n, r2) {
  for (const s4 of t3) {
    const { geometry: t4, attributes: c2 } = s4;
    let l2;
    r(t4) && (l2 = L(t4, n, r2)), e2.push({ attributes: c2, geometry: l2 });
  }
  return e2;
}
function L(e2, t3, n) {
  if (!e2)
    return null;
  const o = h(t3, n), { coords: r2, lengths: s4 } = e2, c2 = [];
  let l2 = 0;
  for (const u of s4) {
    const e3 = [];
    for (let t4 = 0; t4 < u; t4++) {
      const t5 = [];
      for (let e4 = 0; e4 < o; e4++)
        t5.push(r2[l2++]);
      e3.push(t5);
    }
    c2.push(e3);
  }
  return t3 ? n ? { paths: c2, hasZ: t3, hasM: n } : { paths: c2, hasZ: t3 } : n ? { paths: c2, hasM: n } : { paths: c2 };
}
function q(e2, t3, n, o, r2) {
  const s4 = h(n, o);
  for (const c2 of t3) {
    const t4 = c2.geometry, n2 = c2.attributes;
    let o2;
    t4 && (o2 = $(new t2(), t4, s4)), e2.push(new s3(o2, n2, null, n2[r2]));
  }
  return e2;
}
function $(e2, t3, n = h(t3.hasZ, t3.hasM)) {
  const { lengths: o, coords: r2 } = e2;
  let s4 = 0;
  for (const c2 of t3.paths) {
    for (const e3 of c2)
      for (let t4 = 0; t4 < n; t4++)
        r2[s4++] = e3[t4];
    o.push(c2.length);
  }
  return e2;
}
function R(e2, t3, n, r2) {
  for (const s4 of t3) {
    const { geometry: t4, attributes: c2, centroid: l2 } = s4;
    let u;
    if (r(t4) && (u = C(t4, n, r2)), r(l2)) {
      const t5 = T(l2);
      e2.push({ attributes: c2, centroid: t5, geometry: u });
    } else
      e2.push({ attributes: c2, geometry: u });
  }
  return e2;
}
function C(e2, t3, n) {
  if (!e2)
    return null;
  const o = h(t3, n), { coords: r2, lengths: s4 } = e2, c2 = [];
  let l2 = 0;
  for (const u of s4) {
    const e3 = [];
    for (let t4 = 0; t4 < u; t4++) {
      const t5 = [];
      for (let e4 = 0; e4 < o; e4++)
        t5.push(r2[l2++]);
      e3.push(t5);
    }
    c2.push(e3);
  }
  return t3 ? n ? { rings: c2, hasZ: t3, hasM: n } : { rings: c2, hasZ: t3 } : n ? { rings: c2, hasM: n } : { rings: c2 };
}
function B(e2, t3, n, r2, s4) {
  for (const c2 of t3) {
    const t4 = c2.geometry, l2 = c2.centroid, i = c2.attributes;
    let h2;
    t4 && (h2 = D(new t2(), t4, n, r2)), r(l2) ? e2.push(new s3(h2, i, F(new t2(), l2), i[s4])) : e2.push(new s3(h2, i, null, i[s4]));
  }
  return e2;
}
function D(e2, t3, n = t3.hasZ, o = t3.hasM) {
  return H(e2, t3.rings, n, o), e2;
}
function H(e2, t3, n, o) {
  const r2 = h(n, o), { lengths: s4, coords: c2 } = e2;
  let l2 = 0;
  s4.length = c2.length = 0;
  for (const u of t3) {
    for (const e3 of u)
      for (let t4 = 0; t4 < r2; t4++)
        c2[l2++] = e3[t4];
    s4.push(u.length);
  }
  return e2;
}
var J = [];
var K = [];
function Q(e2, t3, n, o, r2) {
  J[0] = e2;
  const [s4] = W(K, J, t3, n, o, r2);
  return J.length = K.length = 0, s4;
}
function W(t3, n, o, r2, s4, c2) {
  if (t3.length = 0, !o) {
    for (const e2 of n) {
      const n2 = e2.attributes[c2];
      t3.push(new s3(null, e2.attributes, null, n2));
    }
    return t3;
  }
  switch (o) {
    case "esriGeometryPoint":
      return S(t3, n, r2, s4, c2);
    case "esriGeometryMultipoint":
      return O(t3, n, r2, s4, c2);
    case "esriGeometryPolyline":
      return q(t3, n, r2, s4, c2);
    case "esriGeometryPolygon":
      return B(t3, n, r2, s4, c2);
    default:
      a.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${o}'`)), t3.length = 0;
  }
  return t3;
}
function X(t3, n, o, r2, s4, c2) {
  const l2 = t3.length;
  switch (o) {
    case "esriGeometryPoint":
      S(t3, n, r2, s4, c2);
      break;
    case "esriGeometryMultipoint":
      O(t3, n, r2, s4, c2);
      break;
    case "esriGeometryPolyline":
      q(t3, n, r2, s4, c2);
      break;
    case "esriGeometryPolygon":
      B(t3, n, r2, s4, c2);
      break;
    default:
      a.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${o}'`));
  }
  for (let e2 = 0; e2 < n.length; e2++)
    t3[e2 + l2].geometryType = o, t3[e2 + l2].insertAfter = n[e2].insertAfter, t3[e2 + l2].groupId = n[e2].groupId;
  return t3;
}
function ee(e2, t3, n, o) {
  K[0] = e2, re(J, K, t3, n, o);
  const r2 = J[0];
  return J.length = K.length = 0, r2;
}
function te(t3, o, u) {
  if (t(t3))
    return null;
  const i = new t2();
  if ("hasZ" in t3 && null == o && (o = t3.hasZ), "hasM" in t3 && null == u && (u = t3.hasM), l(t3)) {
    return v(null != o ? o : null != t3.z, null != u ? u : null != t3.m)(i, t3);
  }
  return c(t3) ? D(i, t3, o, u) : y(t3) ? $(i, t3, h(o, u)) : f(t3) ? U(i, t3, h(o, u)) : void a.error("convertFromGeometry:unknown-geometry", new s2(`Unable to parse unknown geometry type '${t3}'`));
}
function ne(t3, o, r2, s4) {
  const c2 = t3 && ("coords" in t3 ? t3 : t3.geometry);
  if (t(c2))
    return null;
  switch (o) {
    case "esriGeometryPoint": {
      let e2 = T;
      return r2 && s4 ? e2 = k : r2 ? e2 = P : s4 && (e2 = Z), e2(c2);
    }
    case "esriGeometryMultipoint":
      return _(c2, r2, s4);
    case "esriGeometryPolyline":
      return L(c2, r2, s4);
    case "esriGeometryPolygon":
      return C(c2, r2, s4);
    default:
      return void a.error("convertToGeometry:unknown-geometry", new s2(`Unable to parse unknown geometry type '${o}'`));
  }
}
function oe(e2, t3) {
  for (const n of t3)
    e2.push({ attributes: n.attributes });
  return e2;
}
function re(t3, o, r2, s4, c2) {
  if (t3.length = 0, t(r2))
    return oe(t3, o);
  switch (r2) {
    case "esriGeometryPoint":
      return z(t3, o, s4, c2);
    case "esriGeometryMultipoint":
      return Y(t3, o, s4, c2);
    case "esriGeometryPolyline":
      return A(t3, o, s4, c2);
    case "esriGeometryPolygon":
      return R(t3, o, s4, c2);
    default:
      a.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${r2}'`));
  }
  return t3;
}
function se(e2) {
  const { objectIdFieldName: t3, spatialReference: n, transform: o, fields: r2, hasM: s4, hasZ: c2, features: l2, geometryType: u, exceededTransferLimit: i, uniqueIdField: f2, queryGeometry: h2, queryGeometryType: a2 } = e2, g2 = { features: re([], l2, u, c2, s4), fields: r2, geometryType: u, objectIdFieldName: t3, spatialReference: n, uniqueIdField: f2, queryGeometry: ne(h2, a2, false, false) };
  return o && (g2.transform = o), i && (g2.exceededTransferLimit = i), s4 && (g2.hasM = s4), c2 && (g2.hasZ = c2), g2;
}
function ce(t3, n) {
  const o = new e(), { hasM: r2, hasZ: s4, features: c2, objectIdFieldName: l2, spatialReference: u, geometryType: f2, exceededTransferLimit: h2, transform: g2, fields: d2 } = t3;
  return d2 && (o.fields = d2), o.geometryType = f2, o.objectIdFieldName = l2 || n, o.spatialReference = u, o.objectIdFieldName ? (c2 && W(o.features, c2, f2, s4, r2, o.objectIdFieldName), h2 && (o.exceededTransferLimit = h2), r2 && (o.hasM = r2), s4 && (o.hasZ = s4), g2 && (o.transform = g2), o) : (a.error(new s2("optimized-features:invalid-objectIdFieldName", "objectIdFieldName is missing")), o);
}
function le(e2) {
  const { transform: t3, features: n, hasM: r2, hasZ: s4 } = e2;
  if (!t3)
    return e2;
  for (const c2 of n)
    r(c2.geometry) && me(c2.geometry, c2.geometry, r2, s4, t3), r(c2.centroid) && me(c2.centroid, c2.centroid, r2, s4, t3);
  return e2.transform = null, e2;
}
function ue(e2, t3) {
  const { geometryType: n, features: o, hasM: r2, hasZ: s4 } = t3;
  if (!e2)
    return t3;
  for (let c2 = 0; c2 < o.length; c2++) {
    const t4 = o[c2], l2 = t4.weakClone();
    l2.geometry = new t2(), ie(l2.geometry, t4.geometry, r2, s4, n, e2), t4.centroid && (l2.centroid = new t2(), ie(l2.centroid, t4.centroid, r2, s4, "esriGeometryPoint", e2)), o[c2] = l2;
  }
  return t3.transform = e2, t3;
}
function ie(e2, t3, o, r2, s4, c2, l2 = o, u = r2) {
  if (e2.lengths.length && (e2.lengths.length = 0), e2.coords.length && (e2.coords.length = 0), t(t3) || !t3.coords.length)
    return null;
  const i = g[s4], { coords: f2, lengths: a2 } = t3, d2 = h(o, r2), m2 = h(o && l2, r2 && u), y3 = I(o, r2, l2, u);
  if (!a2.length)
    return y3(e2.coords, f2, 0, 0, b(c2, f2[0]), M(c2, f2[1])), e2.lengths.length && (e2.lengths.length = 0), e2.coords.length = d2, e2;
  let p2, w2, N2, G2, T2 = 0, F2 = 0, P2 = F2;
  for (const n of a2) {
    if (n < i)
      continue;
    let t4 = 0;
    F2 = P2, N2 = p2 = b(c2, f2[T2]), G2 = w2 = M(c2, f2[T2 + 1]), y3(e2.coords, f2, F2, T2, N2, G2), t4++, T2 += d2, F2 += m2;
    for (let o2 = 1; o2 < n; o2++, T2 += d2)
      N2 = b(c2, f2[T2]), G2 = M(c2, f2[T2 + 1]), N2 === p2 && G2 === w2 || (y3(e2.coords, f2, F2, T2, N2 - p2, G2 - w2), F2 += m2, t4++, p2 = N2, w2 = G2);
    t4 >= i && (e2.lengths.push(t4), P2 = F2);
  }
  return e2.coords.length = P2, e2.coords.length ? e2 : null;
}
function fe(e2, t3, n, o, r2, s4, c2 = n, l2 = o) {
  if (e2.lengths.length && (e2.lengths.length = 0), e2.coords.length && (e2.coords.length = 0), !t3 || !t3.coords.length)
    return null;
  const u = g[r2], { coords: i, lengths: f2 } = t3, a2 = h(n, o), d2 = h(n && c2, o && l2), m2 = I(n, o, c2, l2);
  if (!f2.length)
    return m2(e2.coords, i, 0, 0, i[0], i[1]), e2.lengths.length && (e2.lengths.length = 0), e2.coords.length = a2, e2;
  let y3 = 0;
  const p2 = s4 * s4;
  for (const h2 of f2) {
    if (h2 < u) {
      y3 += h2 * a2;
      continue;
    }
    const t4 = e2.coords.length / d2, n2 = y3, o2 = y3 + (h2 - 1) * a2;
    m2(e2.coords, i, e2.coords.length, n2, i[n2], i[n2 + 1]), ae(e2.coords, i, a2, p2, m2, n2, o2), m2(e2.coords, i, e2.coords.length, o2, i[o2], i[o2 + 1]);
    const r3 = e2.coords.length / d2 - t4;
    r3 >= u ? e2.lengths.push(r3) : e2.coords.length = t4 * d2, y3 += h2 * a2;
  }
  return e2.coords.length ? e2 : null;
}
function he(e2, t3, n, o) {
  const r2 = e2[t3], s4 = e2[t3 + 1], c2 = e2[n], l2 = e2[n + 1], u = e2[o], i = e2[o + 1];
  let f2 = c2, h2 = l2, a2 = u - f2, g2 = i - h2;
  if (0 !== a2 || 0 !== g2) {
    const e3 = ((r2 - f2) * a2 + (s4 - h2) * g2) / (a2 * a2 + g2 * g2);
    e3 > 1 ? (f2 = u, h2 = i) : e3 > 0 && (f2 += a2 * e3, h2 += g2 * e3);
  }
  return a2 = r2 - f2, g2 = s4 - h2, a2 * a2 + g2 * g2;
}
function ae(e2, t3, n, o, r2, s4, c2) {
  let l2, u = o, i = 0;
  for (let f2 = s4 + n; f2 < c2; f2 += n)
    l2 = he(t3, f2, s4, c2), l2 > u && (i = f2, u = l2);
  u > o && (i - s4 > n && ae(e2, t3, n, o, r2, s4, i), r2(e2, t3, e2.length, i, t3[i], t3[i + 1]), c2 - i > n && ae(e2, t3, n, o, r2, i, c2));
}
function ge(e2, t3, o, r2) {
  if (t(t3) || !t3.coords || !t3.coords.length)
    return null;
  const s4 = h(o, r2);
  let c2 = Number.POSITIVE_INFINITY, l2 = Number.POSITIVE_INFINITY, u = Number.NEGATIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
  if (t3 && t3.coords) {
    const e3 = t3.coords;
    for (let t4 = 0; t4 < e3.length; t4 += s4) {
      const n = e3[t4], o2 = e3[t4 + 1];
      c2 = Math.min(c2, n), u = Math.max(u, n), l2 = Math.min(l2, o2), i = Math.max(i, o2);
    }
  }
  return e2[0] = c2, e2[1] = l2, e2[2] = u, e2[3] = i, e2;
}
function me(e2, t3, n, o, r2) {
  const { coords: s4, lengths: c2 } = t3, l2 = n ? o ? p : m : o ? m : d, u = h(n, o);
  if (!s4.length)
    return e2 !== t3 && (e2.lengths.length = 0, e2.coords.length = 0), e2;
  if (!c2.length)
    return l2(e2.coords, s4, 0, 0, w(r2, s4[0]), N(r2, s4[1])), e2 !== t3 && (e2.lengths.length = 0, e2.coords.length = u), e2;
  const [i, f2] = r2.scale;
  let a2 = 0;
  for (let h2 = 0; h2 < c2.length; h2++) {
    const t4 = c2[h2];
    e2.lengths[h2] = t4;
    let n2 = w(r2, s4[a2]), o2 = N(r2, s4[a2 + 1]);
    l2(e2.coords, s4, a2, a2, n2, o2), a2 += u;
    for (let r3 = 1; r3 < t4; r3++, a2 += u)
      n2 += s4[a2] * i, o2 -= s4[a2 + 1] * f2, l2(e2.coords, s4, a2, a2, n2, o2);
  }
  return e2 !== t3 && (e2.lengths.length = c2.length, e2.coords.length = s4.length), e2;
}
function ye(e2, t3, n, o, r2, s4) {
  const c2 = h(n, o), l2 = I(n, o, r2, s4), u = t3.coords;
  e2.coords.length = 0, e2.lengths.length = 0, e2.lengths.push(...t3.lengths);
  for (let i = 0; i < u.length; i += c2)
    l2(e2.coords, u, e2.coords.length, i, u[i], u[i + 1]);
  return e2;
}
function Ie(e2, t3, n, o) {
  let r2 = 0, s4 = e2[o * t3], c2 = e2[o * (t3 + 1)];
  for (let l2 = 1; l2 < n; l2++) {
    const n2 = s4 + e2[o * (t3 + l2)], u = c2 + e2[o * (t3 + l2) + 1], i = (n2 - s4) * (u + c2);
    s4 = n2, c2 = u, r2 += i;
  }
  return 0.5 * r2;
}
function be(e2, t3) {
  const { coords: n, lengths: o } = e2;
  let r2 = 0, s4 = 0;
  for (let c2 = 0; c2 < o.length; c2++) {
    s4 += Ie(n, r2, o[c2], t3), r2 += c2;
  }
  return Math.abs(s4);
}
function we(e2, t3) {
  if (t(e2))
    return null;
  const o = e2.clone(), r2 = e2.coords, s4 = e2.lengths;
  let c2 = 0;
  for (let n = 0; n < s4.length; n++) {
    const e3 = s4[n];
    let l2 = r2[t3 * c2], u = r2[t3 * c2 + 1];
    for (let n2 = 1; n2 < e3; n2++) {
      const e4 = l2 + r2[t3 * (c2 + n2)], s5 = u + r2[t3 * (c2 + n2) + 1];
      o.coords[t3 * (c2 + n2)] = e4, o.coords[t3 * (c2 + n2) + 1] = s5, l2 = e4, u = s5;
    }
    c2 += e3;
  }
  return o;
}

export {
  b,
  M,
  G,
  V,
  _,
  L,
  $,
  C,
  D,
  H,
  Q,
  W,
  X,
  ee,
  te,
  ne,
  se,
  ce,
  le,
  ue,
  ie,
  fe,
  ge,
  me,
  ye,
  be,
  we
};
//# sourceMappingURL=chunk-6SWQ7R36.js.map
