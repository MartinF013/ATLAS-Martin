import {
  a2 as a,
  a3 as a2,
  d
} from "./chunk-Q2LKCV6V.js";
import {
  I,
  c,
  f,
  g
} from "./chunk-7CXXTQLM.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/PointCloudWorkerUtil.js
function f2(e, o, n, s) {
  const { rendererJSON: i, isRGBRenderer: u } = e;
  let f3 = null, c3 = null;
  if (o && u)
    f3 = o;
  else if (o && "pointCloudUniqueValueRenderer" === i.type) {
    c3 = a2.fromJSON(i);
    const e2 = c3.colorUniqueValueInfos;
    f3 = new Uint8Array(3 * s);
    const r2 = p(c3.fieldTransformType);
    for (let t2 = 0; t2 < s; t2++) {
      const l = (r2 ? r2(o[t2]) : o[t2]) + "";
      for (let o2 = 0; o2 < e2.length; o2++)
        if (e2[o2].values.includes(l)) {
          f3[3 * t2] = e2[o2].color.r, f3[3 * t2 + 1] = e2[o2].color.g, f3[3 * t2 + 2] = e2[o2].color.b;
          break;
        }
    }
  } else if (o && "pointCloudStretchRenderer" === i.type) {
    c3 = a.fromJSON(i);
    const e2 = c3.stops;
    f3 = new Uint8Array(3 * s);
    const r2 = p(c3.fieldTransformType);
    for (let t2 = 0; t2 < s; t2++) {
      const l = r2 ? r2(o[t2]) : o[t2], n2 = e2.length - 1;
      if (l < e2[0].value)
        f3[3 * t2] = e2[0].color.r, f3[3 * t2 + 1] = e2[0].color.g, f3[3 * t2 + 2] = e2[0].color.b;
      else if (l >= e2[n2].value)
        f3[3 * t2] = e2[n2].color.r, f3[3 * t2 + 1] = e2[n2].color.g, f3[3 * t2 + 2] = e2[n2].color.b;
      else
        for (let o2 = 1; o2 < e2.length; o2++)
          if (l < e2[o2].value) {
            const r3 = (l - e2[o2 - 1].value) / (e2[o2].value - e2[o2 - 1].value);
            f3[3 * t2] = e2[o2].color.r * r3 + e2[o2 - 1].color.r * (1 - r3), f3[3 * t2 + 1] = e2[o2].color.g * r3 + e2[o2 - 1].color.g * (1 - r3), f3[3 * t2 + 2] = e2[o2].color.b * r3 + e2[o2 - 1].color.b * (1 - r3);
            break;
          }
    }
  } else if (o && "pointCloudClassBreaksRenderer" === i.type) {
    c3 = d.fromJSON(i);
    const e2 = c3.colorClassBreakInfos;
    f3 = new Uint8Array(3 * s);
    const t2 = p(c3.fieldTransformType);
    for (let r2 = 0; r2 < s; r2++) {
      const l = t2 ? t2(o[r2]) : o[r2];
      for (let o2 = 0; o2 < e2.length; o2++)
        if (l >= e2[o2].minValue && l <= e2[o2].maxValue) {
          f3[3 * r2] = e2[o2].color.r, f3[3 * r2 + 1] = e2[o2].color.g, f3[3 * r2 + 2] = e2[o2].color.b;
          break;
        }
    }
  } else {
    f3 = new Uint8Array(3 * s);
    for (let e2 = 0; e2 < f3.length; e2++)
      f3[e2] = 255;
  }
  if (n && c3 && c3.colorModulation) {
    const e2 = c3.colorModulation.minValue, o2 = c3.colorModulation.maxValue, r2 = 0.3;
    for (let t2 = 0; t2 < s; t2++) {
      const l = n[t2], s2 = l >= o2 ? 1 : l <= e2 ? r2 : r2 + (1 - r2) * (l - e2) / (o2 - e2);
      f3[3 * t2] = s2 * f3[3 * t2], f3[3 * t2 + 1] = s2 * f3[3 * t2 + 1], f3[3 * t2 + 2] = s2 * f3[3 * t2 + 2];
    }
  }
  return f3;
}
function c2(o, r2) {
  if (null == o.encoding || "" === o.encoding) {
    const t2 = g(r2, o);
    if (t(t2.vertexAttributes.position))
      return;
    const l = f(r2, t2.vertexAttributes.position), i = t2.header.fields, u = [i.offsetX, i.offsetY, i.offsetZ], f3 = [i.scaleX, i.scaleY, i.scaleZ], c3 = l.length / 3, a4 = new Float64Array(3 * c3);
    for (let e = 0; e < c3; e++)
      a4[3 * e] = l[3 * e] * f3[0] + u[0], a4[3 * e + 1] = l[3 * e + 1] * f3[1] + u[1], a4[3 * e + 2] = l[3 * e + 2] * f3[2] + u[2];
    return a4;
  }
  if ("lepcc-xyz" === o.encoding)
    return c(r2).result;
}
function a3(e, r2, t2) {
  return r(e) && e.attributeInfo.useElevation ? d2(r2, t2) : r(e) ? I(e.attributeInfo.storageInfo, e.buffer, t2) : null;
}
function d2(e, o) {
  const r2 = new Float64Array(o);
  for (let t2 = 0; t2 < o; t2++)
    r2[t2] = e[3 * t2 + 2];
  return r2;
}
function m(e, o, r2, t2, l) {
  const n = e.length / 3;
  let s = 0;
  for (let i = 0; i < n; i++) {
    let n2 = true;
    for (let e2 = 0; e2 < t2.length && n2; e2++) {
      const { filterJSON: o2 } = t2[e2], r3 = l[e2].values[i];
      switch (o2.type) {
        case "pointCloudValueFilter": {
          const e3 = "exclude" === o2.mode;
          o2.values.includes(r3) === e3 && (n2 = false);
          break;
        }
        case "pointCloudBitfieldFilter": {
          const e3 = b(o2.requiredSetBits), t3 = b(o2.requiredClearBits);
          (r3 & e3) === e3 && 0 == (r3 & t3) || (n2 = false);
          break;
        }
        case "pointCloudReturnFilter": {
          const e3 = 15 & r3, t3 = r3 >>> 4 & 15, l2 = t3 > 1, s2 = 1 === e3, i2 = e3 === t3;
          let u = false;
          for (const r4 of o2.includedReturns)
            if ("last" === r4 && i2 || "firstOfMany" === r4 && s2 && l2 || "lastOfMany" === r4 && i2 && l2 || "single" === r4 && !l2) {
              u = true;
              break;
            }
          u || (n2 = false);
          break;
        }
      }
    }
    n2 && (r2[s] = i, e[3 * s] = e[3 * i], e[3 * s + 1] = e[3 * i + 1], e[3 * s + 2] = e[3 * i + 2], o[3 * s] = o[3 * i], o[3 * s + 1] = o[3 * i + 1], o[3 * s + 2] = o[3 * i + 2], s++);
  }
  return s;
}
function p(e) {
  return null == e || "none" === e ? null : "low-four-bit" === e ? (e2) => 15 & e2 : "high-four-bit" === e ? (e2) => (240 & e2) >> 4 : "absolute-value" === e ? (e2) => Math.abs(e2) : "modulo-ten" === e ? (e2) => e2 % 10 : null;
}
function b(e) {
  let o = 0;
  for (const r2 of e || [])
    o |= 1 << r2;
  return o;
}

export {
  f2 as f,
  c2 as c,
  a3 as a,
  d2 as d,
  m
};
//# sourceMappingURL=chunk-O5HWALWY.js.map
