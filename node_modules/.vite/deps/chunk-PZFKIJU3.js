import {
  r
} from "./chunk-EPNT7GPS.js";
import {
  d
} from "./chunk-PMOPLTRU.js";
import {
  e
} from "./chunk-WW7VYUQW.js";
import {
  o
} from "./chunk-A3QLZKCF.js";
import {
  a,
  i
} from "./chunk-I5UNY2WQ.js";
import {
  n
} from "./chunk-NAB3NF54.js";
import {
  C
} from "./chunk-MDCKEJ7B.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/FloatDrawUniform.js
var e2 = class extends i {
  constructor(r2, e3) {
    super(r2, "float", a.Draw, (o2, s2, t2) => o2.setUniform1f(r2, e3(s2, t2)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js
function s(a2, e3) {
  l(a2, e3, new o("textureAlphaCutoff", (a3) => a3.textureAlphaCutoff));
}
function t(a2, r2) {
  l(a2, r2, new e2("textureAlphaCutoff", (a3) => a3.textureAlphaCutoff));
}
function l(e3, r2, s2) {
  const t2 = e3.fragment;
  switch (r2.alphaDiscardMode !== C.Mask && r2.alphaDiscardMode !== C.MaskBlend || t2.uniforms.add(s2), r2.alphaDiscardMode) {
    case C.Blend:
      return e3.include(d);
    case C.Opaque:
      t2.code.add(n`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);
      break;
    case C.Mask:
      t2.code.add(n`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);
      break;
    case C.MaskBlend:
      e3.fragment.code.add(n`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js
function i2(i3) {
  i3.include(e), i3.code.add(n`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${n.int(r.Multiply)}) {
        return allMixed;
      }
      if (mode == ${n.int(r.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${n.int(r.Replace)}) {
        return externalColor;
      }

      // tint (or something invalid)
      float vIn = rgb2v(internalMixed);
      vec3 hsvTint = rgb2hsv(externalColor);
      vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
      return hsv2rgb(hsvOut);
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${n.int(r.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${n.int(r.Replace)}) {
        return externalOpacity;
      }

      // multiply or tint (or something invalid)
      return allMixed;
    }
  `);
}

export {
  e2 as e,
  s,
  t,
  i2 as i
};
//# sourceMappingURL=chunk-PZFKIJU3.js.map
