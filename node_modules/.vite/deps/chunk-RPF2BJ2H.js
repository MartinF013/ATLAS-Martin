import {
  j as j2
} from "./chunk-DWV3HMZB.js";
import {
  f,
  l as l2
} from "./chunk-ZDSMRGKC.js";
import {
  L,
  c,
  e,
  h,
  l,
  m,
  n,
  o,
  p as p2,
  s as s3,
  t as t2,
  u as u2
} from "./chunk-I6H66HCE.js";
import {
  d as d2,
  g,
  k,
  w,
  x
} from "./chunk-RRFFPL7N.js";
import {
  p,
  y
} from "./chunk-HB4HVKJV.js";
import {
  a
} from "./chunk-KVF4M6PZ.js";
import {
  d,
  j
} from "./chunk-TADZYUVR.js";
import {
  u
} from "./chunk-NWRK6QLX.js";
import {
  E
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/symbols/support/previewSymbol3D.js
var O = t2.size;
var C = t2.maxSize;
var I = t2.maxOutlineSize;
var R = t2.lineWidth;
var E2 = t2.tallSymbolWidth;
var Z = s.getLogger("esri.symbols.support.previewSymbol3D");
function q(e2) {
  const t3 = e2.outline, s4 = r(e2.material) ? e2.material.color : null, r2 = r(s4) ? s4.toHex() : null;
  if (t(t3) || "pattern" in t3 && r(t3.pattern) && "style" === t3.pattern.type && "none" === t3.pattern.style)
    return "fill" === e2.type && "#ffffff" === r2 ? { color: "#bdc3c7", width: 0.75 } : null;
  const a2 = u(t3.size) || 0;
  return { color: "rgba(" + (r(t3.color) ? t3.color.toRgba() : "255,255,255,1") + ")", width: Math.min(a2, I), style: "pattern" in t3 && r(t3.pattern) && "style" === t3.pattern.type ? x(t3.pattern.style) : null, join: "butt", cap: "patternCap" in t3 ? t3.patternCap : "butt" };
}
function A(t3, s4) {
  const r2 = s4 && s4.resource, a2 = r2 && r2.href;
  if (t3.thumbnail && t3.thumbnail.url)
    return Promise.resolve(t3.thumbnail.url);
  if (a2 && "object" !== s4.type)
    return Promise.resolve(g(t3, s4));
  const o2 = a("esri/images/Legend/legend3dsymboldefault.png");
  return t3.styleOrigin && (t3.styleOrigin.styleName || t3.styleOrigin.styleUrl) ? j2(t3.styleOrigin, { portal: t3.styleOrigin.portal }, "webRef").catch((e2) => e2).then((e2) => {
    var _a;
    return ((_a = e2 == null ? void 0 : e2.thumbnail) == null ? void 0 : _a.url) || o2;
  }) : Promise.resolve(o2);
}
function H(e2, r2 = 1) {
  const a2 = e2.a, o2 = y(e2), n2 = o2.h, l3 = o2.s / r2, i = 100 - (100 - o2.v) / r2, { r: c2, g: p3, b: h2 } = p({ h: n2, s: l3, v: i });
  return [c2, p3, h2, a2];
}
function N(e2) {
  return "water" === e2.type ? t(e2.color) ? null : e2.color : t(e2.material) || t(e2.material.color) ? null : e2.material.color;
}
function T(e2, t3 = 0) {
  const s4 = N(e2);
  if (!s4) {
    if ("fill" === e2.type)
      return null;
    const s5 = k.r, r3 = h(s5, t3);
    return [r3, r3, r3, 100];
  }
  const r2 = s4.toRgba();
  for (let a2 = 0; a2 < 3; a2++)
    r2[a2] = h(r2[a2], t3);
  return r2;
}
async function W(t3, s4) {
  const r2 = t3.style;
  if ("none" === r2)
    return null;
  return { type: "pattern", x: 0, y: 0, src: await w(a(`esri/symbols/patterns/${r2}.png`), s4.toCss(true)), width: 5, height: 5 };
}
function $(e2) {
  return e2.outline ? q(e2) : { color: "rgba(0, 0, 0, 1)", width: 1.5 };
}
function B(e2, t3) {
  const s4 = N(e2);
  if (!s4)
    return null;
  let r2 = "rgba(";
  return r2 += h(s4.r, t3) + ",", r2 += h(s4.g, t3) + ",", r2 += h(s4.b, t3) + ",", r2 + s4.a + ");";
}
function F(e2, t3) {
  const s4 = B(e2, t3);
  if (!s4)
    return {};
  if ("pattern" in e2 && r(e2.pattern) && "style" === e2.pattern.type && "none" === e2.pattern.style)
    return null;
  return { color: s4, width: Math.min(e2.size ? u(e2.size) : 0.75, I), style: "pattern" in e2 && r(e2.pattern) && "style" === e2.pattern.type ? x(e2.pattern.style) : null, cap: "cap" in e2 ? e2.cap : null, join: "join" in e2 ? "miter" === e2.join ? u(2) : e2.join : null };
}
function G(e2, t3, s4) {
  const r2 = 0.75 * s4;
  return { type: "linear", x1: r2 ? 0.25 * r2 : 0, y1: r2 ? 0.5 * r2 : 0, x2: r2 || 4, y2: r2 ? 0.5 * r2 : 4, colors: [{ color: e2, offset: 0 }, { color: t3, offset: 1 }] };
}
function J(e2) {
  const t3 = e2.depth, s4 = e2.height, r2 = e2.width;
  return r2 && t3 && s4 && r2 === t3 && r2 < s4;
}
function K(e2, t3, s4) {
  const r2 = [];
  if (!e2)
    return r2;
  switch (e2.type) {
    case "icon": {
      const s5 = 0, a2 = 0, o2 = t3, n2 = t3;
      switch (e2.resource && e2.resource.primitive || j) {
        case "circle":
          r2.push({ shape: { type: "circle", cx: 0, cy: 0, r: 0.5 * t3 }, fill: T(e2, 0), stroke: q(e2) });
          break;
        case "square":
          r2.push({ shape: { type: "path", path: [{ command: "M", values: [s5, n2] }, { command: "L", values: [s5, a2] }, { command: "L", values: [o2, a2] }, { command: "L", values: [o2, n2] }, { command: "Z", values: [] }] }, fill: T(e2, 0), stroke: q(e2) });
          break;
        case "triangle":
          r2.push({ shape: { type: "path", path: [{ command: "M", values: [s5, n2] }, { command: "L", values: [0.5 * o2, a2] }, { command: "L", values: [o2, n2] }, { command: "Z", values: [] }] }, fill: T(e2, 0), stroke: q(e2) });
          break;
        case "cross":
          r2.push({ shape: { type: "path", path: [{ command: "M", values: [0.5 * o2, a2] }, { command: "L", values: [0.5 * o2, n2] }, { command: "M", values: [s5, 0.5 * n2] }, { command: "L", values: [o2, 0.5 * n2] }] }, stroke: $(e2) });
          break;
        case "x":
          r2.push({ shape: { type: "path", path: [{ command: "M", values: [s5, a2] }, { command: "L", values: [o2, n2] }, { command: "M", values: [o2, a2] }, { command: "L", values: [s5, n2] }] }, stroke: $(e2) });
          break;
        case "kite":
          r2.push({ shape: { type: "path", path: [{ command: "M", values: [s5, 0.5 * n2] }, { command: "L", values: [0.5 * o2, a2] }, { command: "L", values: [o2, 0.5 * n2] }, { command: "L", values: [0.5 * o2, n2] }, { command: "Z", values: [] }] }, fill: T(e2, 0), stroke: q(e2) });
      }
      break;
    }
    case "object":
      switch (e2.resource && e2.resource.primitive || d) {
        case "cone": {
          const a2 = G(T(e2, 0), T(e2, -0.6), s4 ? E2 : t3), o2 = l(t3, s4);
          r2.push({ shape: o2[0], fill: a2 }), r2.push({ shape: o2[1], fill: a2 });
          break;
        }
        case "inverted-cone": {
          const s5 = T(e2, 0), a2 = G(s5, T(e2, -0.6), t3), o2 = o(t3);
          r2.push({ shape: o2[0], fill: a2 }), r2.push({ shape: o2[1], fill: s5 });
          break;
        }
        case "cube": {
          const a2 = n(t3, s4);
          r2.push({ shape: a2[0], fill: T(e2, 0) }), r2.push({ shape: a2[1], fill: T(e2, -0.3) }), r2.push({ shape: a2[2], fill: T(e2, -0.5) });
          break;
        }
        case "cylinder": {
          const a2 = G(T(e2, 0), T(e2, -0.6), s4 ? E2 : t3), o2 = L(t3, s4);
          r2.push({ shape: o2[0], fill: a2 }), r2.push({ shape: o2[1], fill: a2 }), r2.push({ shape: o2[2], fill: T(e2, 0) });
          break;
        }
        case "diamond": {
          const s5 = s3(t3);
          r2.push({ shape: s5[0], fill: T(e2, -0.3) }), r2.push({ shape: s5[1], fill: T(e2, 0) }), r2.push({ shape: s5[2], fill: T(e2, -0.3) }), r2.push({ shape: s5[3], fill: T(e2, -0.7) });
          break;
        }
        case "sphere": {
          const s5 = G(T(e2, 0), T(e2, -0.6));
          s5.x1 = 0, s5.y1 = 0, s5.x2 = 0.25 * t3, s5.y2 = 0.25 * t3, r2.push({ shape: { type: "circle", cx: 0, cy: 0, r: 0.5 * t3 }, fill: s5 });
          break;
        }
        case "tetrahedron": {
          const s5 = u2(t3);
          r2.push({ shape: s5[0], fill: T(e2, -0.3) }), r2.push({ shape: s5[1], fill: T(e2, 0) }), r2.push({ shape: s5[2], fill: T(e2, -0.6) });
          break;
        }
      }
      break;
  }
  return r2;
}
function Q(e2) {
  const t3 = "number" == typeof (e2 == null ? void 0 : e2.size) ? e2 == null ? void 0 : e2.size : null;
  return t3 ? u(t3) : null;
}
function V(e2) {
  return "icon" === e2.type ? "multiply" : "tint";
}
function X(e2, t3) {
  const s4 = Q(t3), r2 = t3 && t3.maxSize ? u(t3.maxSize) : null, a2 = t3 && t3.disableUpsampling, o2 = e2.symbolLayers, n2 = [];
  let c2 = 0, p3 = 0;
  const h2 = o2.getItemAt(o2.length - 1);
  let u3;
  return h2 && "icon" === h2.type && (u3 = h2.size && u(h2.size)), o2.forEach((o3) => {
    var _a;
    if ("icon" !== o3.type && "object" !== o3.type)
      return;
    const l3 = "icon" === o3.type ? o3.size && u(o3.size) : 0, h3 = s4 || l3 ? Math.ceil(Math.min(s4 || l3, r2 || C)) : O;
    if (o3 && o3.resource && o3.resource.href) {
      const t4 = A(e2, o3).then((e3) => {
        const t5 = o3.get("material.color"), s5 = V(o3);
        return f(e3, h3, t5, s5, a2);
      }).then((e3) => {
        const t5 = e3.width, s5 = e3.height;
        return c2 = Math.max(c2, t5), p3 = Math.max(p3, s5), [{ shape: { type: "image", x: 0, y: 0, width: t5, height: s5, src: e3.url }, fill: null, stroke: null }];
      });
      n2.push(t4);
    } else {
      let e3 = h3;
      "icon" === o3.type && u3 && s4 && (e3 = h3 * (l3 / u3));
      const r3 = "tall" === (t3 == null ? void 0 : t3.symbolConfig) || ((_a = t3 == null ? void 0 : t3.symbolConfig) == null ? void 0 : _a.isTall) || "object" === o3.type && J(o3);
      c2 = Math.max(c2, r3 ? E2 : e3), p3 = Math.max(p3, e3), n2.push(Promise.resolve(K(o3, e3, r3)));
    }
  }), E(n2).then((e3) => {
    const s5 = [];
    return e3.forEach((e4) => {
      e4.value ? s5.push(e4.value) : e4.error && Z.warn("error while building swatchInfo!", e4.error);
    }), l2(s5, [c2, p3], { node: t3 && t3.node, scale: false, opacity: t3 && t3.opacity });
  });
}
function Y(e2, t3) {
  const s4 = e2.symbolLayers, r2 = [], a2 = d2(e2), n2 = Q(t3), l3 = (t3 && t3.maxSize ? u(t3.maxSize) : null) || I;
  let c2, p3 = 0, h2 = 0;
  return s4.forEach((e3, t4) => {
    if (!e3)
      return;
    if ("line" !== e3.type && "path" !== e3.type)
      return;
    const s5 = [];
    switch (e3.type) {
      case "line": {
        const r3 = F(e3, 0);
        if (t(r3))
          break;
        const a3 = r3 && r3.width || 0;
        0 === t4 && (c2 = a3);
        const i = Math.min(n2 || a3, l3), u3 = 0 === t4 ? i : n2 ? i * (a3 / c2) : i, m2 = u3 > R / 2 ? 2 * u3 : R;
        h2 = Math.max(h2, u3), p3 = Math.max(p3, m2), r3.width = u3, s5.push({ shape: { type: "path", path: [{ command: "M", values: [0, 0.5 * h2] }, { command: "L", values: [p3, 0.5 * h2] }] }, stroke: r3 });
        break;
      }
      case "path": {
        const t5 = Math.min(n2 || O, l3), r3 = T(e3, 0), a3 = T(e3, -0.2), o2 = B(e3, -0.4), i = o2 ? { color: o2, width: 1 } : {};
        if ("quad" === e3.profile) {
          const t6 = e3.width, o3 = e3.height, n3 = m(t6 && o3 ? t6 / o3 : 1, 0 === o3, 0 === t6), l4 = { ...i, join: "bevel" };
          s5.push({ shape: n3[0], fill: a3, stroke: l4 }), s5.push({ shape: n3[1], fill: a3, stroke: l4 }), s5.push({ shape: n3[2], fill: r3, stroke: l4 });
        } else
          s5.push({ shape: e.pathSymbol3DLayer[0], fill: a3, stroke: i }), s5.push({ shape: e.pathSymbol3DLayer[1], fill: r3, stroke: i });
        h2 = Math.max(h2, t5), p3 = h2;
      }
    }
    r2.push(s5);
  }), Promise.resolve(l2(r2, [p3, h2], { node: t3 && t3.node, scale: a2, opacity: t3 && t3.opacity }));
}
async function _(e2, t3) {
  const s4 = "mesh-3d" === e2.type, r2 = e2.symbolLayers, a2 = Q(t3), l3 = t3 && t3.maxSize ? u(t3.maxSize) : null, c2 = a2 || O, p3 = [];
  let h2 = 0, u3 = 0, m2 = false;
  for (let i = 0; i < r2.length; i++) {
    const e3 = r2.getItemAt(i), t4 = [];
    if (s4 && "fill" !== e3.type)
      continue;
    const a3 = e.fill[0];
    switch (e3.type) {
      case "fill": {
        const r3 = q(e3), o2 = Math.min(c2, l3 || C);
        h2 = Math.max(h2, o2), u3 = Math.max(u3, o2), m2 = true;
        let i2 = T(e3, 0);
        const p4 = "pattern" in e3 && e3.pattern, f2 = N(e3);
        !s4 && r(p4) && "style" === p4.type && "solid" !== p4.style && f2 && (i2 = await W(p4, f2)), t4.push({ shape: a3, fill: i2, stroke: r3 });
        break;
      }
      case "line": {
        const s5 = F(e3, 0);
        if (t(s5))
          break;
        const r3 = { stroke: s5, shape: a3 };
        h2 = Math.max(h2, O), u3 = Math.max(u3, O), t4.push(r3);
        break;
      }
      case "extrude": {
        const s5 = { join: "round", width: 1, ...F(e3, -0.4) }, r3 = T(e3, 0), a4 = T(e3, -0.2), o2 = Math.min(c2, l3 || C), n2 = c(o2);
        s5.width = 1, t4.push({ shape: n2[0], fill: a4, stroke: s5 }), t4.push({ shape: n2[1], fill: a4, stroke: s5 }), t4.push({ shape: n2[2], fill: r3, stroke: s5 });
        const i2 = O, p4 = 0.7 * O + 0.5 * o2;
        h2 = Math.max(h2, i2), u3 = Math.max(u3, p4);
        break;
      }
      case "water": {
        const s5 = N(e3), r3 = H(s5), a4 = H(s5, 2), o2 = H(s5, 3), n2 = p2();
        m2 = true, t4.push({ shape: n2[0], fill: r3 }), t4.push({ shape: n2[1], fill: a4 }), t4.push({ shape: n2[2], fill: o2 });
        const i2 = Math.min(c2, l3 || C);
        h2 = Math.max(h2, i2), u3 = Math.max(u3, i2);
        break;
      }
    }
    p3.push(t4);
  }
  return l2(p3, [h2, u3], { node: t3 && t3.node, scale: m2, opacity: t3 && t3.opacity });
}
function ee(e2, t3) {
  if (0 === e2.symbolLayers.length)
    return Promise.reject(new s2("symbolPreview: renderPreviewHTML3D", "No symbolLayers in the symbol."));
  switch (e2.type) {
    case "point-3d":
      return X(e2, t3);
    case "line-3d":
      return Y(e2, t3);
    case "polygon-3d":
    case "mesh-3d":
      return _(e2, t3);
  }
  return Promise.reject(new s2("symbolPreview: swatchInfo3D", "symbol not supported."));
}

export {
  T,
  W,
  Q,
  ee
};
//# sourceMappingURL=chunk-RPF2BJ2H.js.map
