import {
  A,
  Z,
  a,
  r as r2,
  t,
  te,
  x
} from "./chunk-436X6OVY.js";
import {
  dt
} from "./chunk-HH3D3A65.js";
import {
  e as e2,
  i,
  n
} from "./chunk-YDPQRKY4.js";
import {
  s as s3
} from "./chunk-ZEIWFXXO.js";
import {
  o
} from "./chunk-YXFNNKMT.js";
import {
  C,
  M,
  e as e3,
  i as i2,
  n as n2,
  o as o2,
  p
} from "./chunk-IG4CY4XM.js";
import {
  i as i3,
  o as o3
} from "./chunk-D7DLEBS2.js";
import {
  e,
  u
} from "./chunk-NWRK6QLX.js";
import {
  c as c2,
  s as s2,
  y
} from "./chunk-4PRVTUEZ.js";
import {
  l
} from "./chunk-FVPTCNCX.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  c,
  m
} from "./chunk-G5JBUC5N.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/symbols/cim/SDFHelper.js
function r3(t3) {
  var _a;
  if (!t3)
    return null;
  switch (t3.type) {
    case "CIMPointSymbol": {
      const n5 = t3.symbolLayers;
      return n5 && 1 === n5.length ? r3(n5[0]) : null;
    }
    case "CIMVectorMarker": {
      const n5 = t3.markerGraphics;
      if (!n5 || 1 !== n5.length)
        return null;
      const o5 = n5[0];
      if (!o5)
        return null;
      const r5 = o5.geometry;
      if (!r5)
        return null;
      const l2 = o5.symbol;
      return !l2 || "CIMPolygonSymbol" !== l2.type && "CIMLineSymbol" !== l2.type || ((_a = l2.symbolLayers) == null ? void 0 : _a.some((t4) => !!t4.effects)) ? null : { geom: r5, asFill: "CIMPolygonSymbol" === l2.type };
    }
    case "sdf":
      return { geom: t3.geom, asFill: t3.asFill };
  }
  return null;
}
function e4(t3) {
  return t3 ? t3.rings ? t3.rings : t3.paths ? t3.paths : void 0 !== t3.xmin && void 0 !== t3.ymin && void 0 !== t3.xmax && void 0 !== t3.ymax ? [[[t3.xmin, t3.ymin], [t3.xmin, t3.ymax], [t3.xmax, t3.ymax], [t3.xmax, t3.ymin], [t3.xmin, t3.ymin]]] : null : null;
}
function s4(t3) {
  let n5 = 1 / 0, r5 = -1 / 0, l2 = 1 / 0, e6 = -1 / 0;
  for (const o5 of t3)
    for (const t4 of o5)
      t4[0] < n5 && (n5 = t4[0]), t4[0] > r5 && (r5 = t4[0]), t4[1] < l2 && (l2 = t4[1]), t4[1] > e6 && (e6 = t4[1]);
  return new t(n5, l2, r5 - n5, e6 - l2);
}
function i4(t3) {
  let n5 = 1 / 0, o5 = -1 / 0, r5 = 1 / 0, l2 = -1 / 0;
  for (const e6 of t3)
    for (const t4 of e6)
      t4[0] < n5 && (n5 = t4[0]), t4[0] > o5 && (o5 = t4[0]), t4[1] < r5 && (r5 = t4[1]), t4[1] > l2 && (l2 = t4[1]);
  return [n5, r5, o5, l2];
}
function f(t3) {
  return t3 ? t3.rings ? i4(t3.rings) : t3.paths ? i4(t3.paths) : s2(t3) ? [t3.xmin, t3.ymin, t3.xmax, t3.ymax] : null : null;
}
function m2(t3, n5, o5, r5, l2) {
  const [e6, s5, i5, f3] = t3;
  if (i5 < e6 || f3 < s5)
    return [0, 0, 0];
  const m3 = i5 - e6, a3 = f3 - s5, u4 = 128, c6 = 1, y3 = Math.floor(0.5 * (0.5 * u4 - c6)), h = (u4 - 2 * (y3 + c6)) / Math.max(m3, a3), x3 = Math.round(m3 * h) + 2 * y3, M2 = Math.round(a3 * h) + 2 * y3;
  let g = 1;
  if (n5) {
    g = M2 / h / (n5.ymax - n5.ymin);
  }
  let p2 = 0, d = 0;
  if (r5)
    if (l2) {
      if (n5 && o5 && n5.ymax - n5.ymin > 0) {
        const t4 = (n5.xmax - n5.xmin) / (n5.ymax - n5.ymin);
        p2 = r5.x / (o5 * t4), d = r5.y / o5;
      }
    } else
      p2 = r5.x, d = r5.y;
  p2 = 0.5 * (n5.xmax + n5.xmin) + p2 * (n5.xmax - n5.xmin), d = 0.5 * (n5.ymax + n5.ymin) + d * (n5.ymax - n5.ymin), p2 -= e6, d -= s5, p2 *= h, d *= h, p2 += y3, d += y3;
  return [g, p2 / x3 - 0.5, -(d / M2 - 0.5)];
}
function a2(t3) {
  const n5 = e4(t3.geom), o5 = s4(n5), r5 = 128, l2 = 1, i5 = Math.floor(0.5 * (0.5 * r5 - l2)), f3 = (r5 - 2 * (i5 + l2)) / Math.max(o5.width, o5.height), m3 = Math.round(o5.width * f3) + 2 * i5, a3 = Math.round(o5.height * f3) + 2 * i5, h = [];
  for (const e6 of n5)
    if (e6 && e6.length > 1) {
      const n6 = [];
      for (const r6 of e6) {
        let [l3, e7] = r6;
        l3 -= o5.x, e7 -= o5.y, l3 *= f3, e7 *= f3, l3 += i5 - 0.5, e7 += i5 - 0.5, t3.asFill ? n6.push([l3, e7]) : n6.push([Math.round(l3), Math.round(e7)]);
      }
      if (t3.asFill) {
        const t4 = n6.length - 1;
        n6[0][0] === n6[t4][0] && n6[0][1] === n6[t4][1] || n6.push(n6[0]);
      }
      h.push(n6);
    }
  const x3 = u2(h, m3, a3, i5);
  return t3.asFill && c3(h, m3, a3, i5, x3), [y2(x3, i5), m3, a3];
}
function u2(t3, n5, o5, r5) {
  const l2 = n5 * o5, e6 = new Array(l2), s5 = r5 * r5 + 1;
  for (let i5 = 0; i5 < l2; ++i5)
    e6[i5] = s5;
  for (const i5 of t3) {
    const t4 = i5.length;
    for (let l3 = 1; l3 < t4; ++l3) {
      const t5 = i5[l3 - 1], s6 = i5[l3];
      let f3, m3, a3, u4;
      t5[0] < s6[0] ? (f3 = t5[0], m3 = s6[0]) : (f3 = s6[0], m3 = t5[0]), t5[1] < s6[1] ? (a3 = t5[1], u4 = s6[1]) : (a3 = s6[1], u4 = t5[1]);
      let c6 = Math.floor(f3) - r5, y3 = Math.floor(m3) + r5, h = Math.floor(a3) - r5, x3 = Math.floor(u4) + r5;
      c6 < 0 && (c6 = 0), y3 > n5 && (y3 = n5), h < 0 && (h = 0), x3 > o5 && (x3 = o5);
      const M2 = s6[0] - t5[0], g = s6[1] - t5[1], p2 = M2 * M2 + g * g;
      for (let r6 = c6; r6 < y3; r6++)
        for (let l4 = h; l4 < x3; l4++) {
          let i6, f4, m4 = (r6 - t5[0]) * M2 + (l4 - t5[1]) * g;
          m4 < 0 ? (i6 = t5[0], f4 = t5[1]) : m4 > p2 ? (i6 = s6[0], f4 = s6[1]) : (m4 /= p2, i6 = t5[0] + m4 * M2, f4 = t5[1] + m4 * g);
          const a4 = (r6 - i6) * (r6 - i6) + (l4 - f4) * (l4 - f4), u5 = (o5 - l4 - 1) * n5 + r6;
          a4 < e6[u5] && (e6[u5] = a4);
        }
    }
  }
  for (let i5 = 0; i5 < l2; ++i5)
    e6[i5] = Math.sqrt(e6[i5]);
  return e6;
}
function c3(t3, n5, o5, r5, l2) {
  for (const e6 of t3) {
    const t4 = e6.length;
    for (let s5 = 1; s5 < t4; ++s5) {
      const t5 = e6[s5 - 1], i5 = e6[s5];
      let f3, m3, a3, u4;
      t5[0] < i5[0] ? (f3 = t5[0], m3 = i5[0]) : (f3 = i5[0], m3 = t5[0]), t5[1] < i5[1] ? (a3 = t5[1], u4 = i5[1]) : (a3 = i5[1], u4 = t5[1]);
      let c6 = Math.floor(f3), y3 = Math.floor(m3) + 1, h = Math.floor(a3), x3 = Math.floor(u4) + 1;
      c6 < r5 && (c6 = r5), y3 > n5 - r5 && (y3 = n5 - r5), h < r5 && (h = r5), x3 > o5 - r5 && (x3 = o5 - r5);
      for (let e7 = h; e7 < x3; ++e7) {
        if (t5[1] > e7 == i5[1] > e7)
          continue;
        const s6 = (o5 - e7 - 1) * n5;
        for (let n6 = c6; n6 < y3; ++n6)
          n6 < (i5[0] - t5[0]) * (e7 - t5[1]) / (i5[1] - t5[1]) + t5[0] && (l2[s6 + n6] = -l2[s6 + n6]);
        for (let t6 = r5; t6 < c6; ++t6)
          l2[s6 + t6] = -l2[s6 + t6];
      }
    }
  }
}
function y2(n5, o5) {
  const r5 = 2 * o5, l2 = n5.length, e6 = new Uint8Array(4 * l2);
  for (let s5 = 0; s5 < l2; ++s5) {
    const o6 = 0.5 - n5[s5] / r5;
    o(o6, e6, 4 * s5);
  }
  return e6;
}

// node_modules/@arcgis/core/symbols/cim/effects/CIMEffectHelper.js
var c4 = 96 / 72;
var f2 = class {
  static executeEffects(t3, s5, r5) {
    const f3 = a(s5), p2 = c4;
    let u4 = new r2(f3);
    for (const e6 of t3) {
      const t4 = A(e6);
      t4 && (u4 = t4.execute(u4, e6, p2, r5));
    }
    return u4;
  }
  static next(t3) {
    const s5 = t3.next();
    return x(s5), s5;
  }
  static applyEffects(e6, r5, c6) {
    if (!e6)
      return r5;
    let f3 = new r2(r5);
    for (const t3 of e6) {
      const s5 = A(t3);
      s5 && (f3 = s5.execute(f3, t3, 1, c6));
    }
    let p2, u4 = null;
    for (; p2 = f3.next(); )
      u4 ? y(u4) ? y(p2) && u4.paths.push(...p2.paths) : c2(u4) && c2(p2) && u4.rings.push(...p2.rings) : u4 = p2;
    return u4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/fontUtils.js
function t2(e6) {
  const r5 = e6.toLowerCase().split(" ").join("-");
  switch (r5) {
    case "serif":
      return "noto-serif";
    case "sans-serif":
      return "arial-unicode-ms";
    case "monospace":
      return "ubuntu-mono";
    case "fantasy":
      return "cabin-sketch";
    case "cursive":
      return "redressed";
    default:
      return r5;
  }
}
function n3(e6) {
  const r5 = u3(e6) + c5(e6);
  return t2(e6.family) + (r5.length > 0 ? r5 : "-regular");
}
function u3(e6) {
  if (!e6.weight)
    return "";
  switch (e6.weight.toLowerCase()) {
    case "bold":
    case "bolder":
      return "-bold";
  }
  return "";
}
function c5(e6) {
  if (!e6.style)
    return "";
  switch (e6.style.toLowerCase()) {
    case "italic":
    case "oblique":
      return "-italic";
  }
  return "";
}

// node_modules/@arcgis/core/views/2d/engine/webgl/grouping.js
function e5(e6, o5) {
  let r5;
  if ("string" == typeof e6)
    r5 = c(e6 + `-seed(${o5})`);
  else {
    let t3 = 12;
    r5 = e6 ^ o5;
    do {
      r5 = 107 * (r5 >> 8 ^ r5) + t3 | 0;
    } while (0 != --t3);
  }
  return (1 + r5 / (1 << 31)) / 2;
}
function o4(t3) {
  return Math.floor(e5(t3, r4) * n4);
}
var r4 = 53290320;
var n4 = 10;

// node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var w = s.getLogger("esri.symbols.cim.cimAnalyzer");
function L(e6) {
  switch (e6) {
    case "Butt":
      return e2.BUTT;
    case "Square":
      return e2.SQUARE;
    default:
      return e2.ROUND;
  }
}
function X(e6) {
  switch (e6) {
    case "Bevel":
      return n.BEVEL;
    case "Miter":
      return n.MITER;
    default:
      return n.ROUND;
  }
}
function z(e6) {
  switch (e6) {
    case "Left":
    default:
      return "left";
    case "Right":
      return "right";
    case "Center":
      return "center";
    case "Justify":
      return w.warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."), "center";
  }
}
function A2(e6) {
  switch (e6) {
    case "Top":
    default:
      return "top";
    case "Center":
      return "middle";
    case "Baseline":
      return "baseline";
    case "Bottom":
      return "bottom";
  }
}
function R(e6) {
  let t3 = "", i5 = "";
  if (e6) {
    const o5 = e6.toLowerCase();
    o5.includes("italic") ? t3 = "italic" : o5.includes("oblique") && (t3 = "oblique"), o5.includes("bold") ? i5 = "bold" : o5.includes("light") && (i5 = "lighter");
  }
  return { style: t3, weight: i5 };
}
function J(e6) {
  return e6.underline ? "underline" : e6.strikethrough ? "line-through" : "none";
}
function x2(e6, t3, i5, o5) {
  let r5;
  e6[t3] ? r5 = e6[t3] : (r5 = {}, e6[t3] = r5), r5[i5] = o5;
}
function H(e6) {
  const t3 = e6.markerPlacement;
  return t3 && t3.angleToLine ? i.MAP : i.SCREEN;
}
async function Y(e6, t3, i5, o5, r5) {
  const n5 = o5 ?? [];
  if (!e6)
    return n5;
  let l2, s5;
  const c6 = {};
  if ("CIMSymbolReference" !== e6.type)
    return w.error("Expect cim type to be 'CIMSymbolReference'"), n5;
  if (l2 = e6.symbol, s5 = e6.primitiveOverrides, s5) {
    const e7 = [];
    for (const i6 of s5) {
      const o6 = i6.valueExpressionInfo;
      if (o6 && t3) {
        const r6 = o6.expression, n6 = i3(r6, t3.spatialReference, t3.fields).then((e8) => {
          e8 && x2(c6, i6.primitiveName, i6.propertyName, e8);
        });
        e7.push(n6);
      } else
        null != i6.value && x2(c6, i6.primitiveName, i6.propertyName, i6.value);
    }
    e7.length > 0 && await Promise.all(e7);
  }
  const f3 = [];
  switch (fe(l2, i5, f3), f3.length > 0 && await Promise.all(f3), l2.type) {
    case "CIMPointSymbol":
    case "CIMLineSymbol":
    case "CIMPolygonSymbol":
      $(l2, s5, c6, t3, n5, i5, r5);
  }
  return n5;
}
function $(e6, t3, i5, o5, r5, n5, l2) {
  if (!e6)
    return;
  const a3 = e6.symbolLayers;
  if (!a3)
    return;
  const s5 = e6.effects;
  let p2;
  const u4 = Z.getSize(e6);
  "CIMPointSymbol" === e6.type && "Map" === e6.angleAlignment && (p2 = i.MAP);
  let y3 = a3.length;
  for (; y3--; ) {
    const c6 = a3[y3];
    if (!c6 || false === c6.enable)
      continue;
    let m3;
    s5 && s5.length && (m3 = [...s5]);
    const h = c6.effects;
    h && h.length && (s5 ? m3.push(...h) : m3 = [...h]);
    const g = [];
    let d;
    te.findEffectOverrides(m3, t3, g), d = g.length > 0 ? re(m3, g, i5, o5) : m3;
    const S = [];
    switch (te.findApplicableOverrides(c6, t3, S), c6.type) {
      case "CIMSolidFill":
        E(c6, d, i5, S, o5, r5);
        break;
      case "CIMPictureFill":
        T(c6, d, i5, S, o5, n5, r5);
        break;
      case "CIMHatchFill":
        j(c6, d, i5, S, o5, r5);
        break;
      case "CIMGradientFill":
        F(c6, d, i5, S, o5, r5);
        break;
      case "CIMSolidStroke":
        W(c6, d, i5, S, o5, r5, "CIMPolygonSymbol" === e6.type, u4);
        break;
      case "CIMPictureStroke":
        D(c6, d, i5, S, o5, r5, "CIMPolygonSymbol" === e6.type, u4);
        break;
      case "CIMGradientStroke":
        U(c6, d, i5, S, o5, r5, "CIMPolygonSymbol" === e6.type, u4);
        break;
      case "CIMCharacterMarker":
        if (G(c6, d, i5, S, o5, r5))
          break;
        break;
      case "CIMPictureMarker":
        if (G(c6, d, i5, S, o5, r5))
          break;
        "CIMLineSymbol" === e6.type && (p2 = H(c6)), B(c6, d, i5, S, o5, n5, r5, p2, u4);
        break;
      case "CIMVectorMarker":
        if (G(c6, d, i5, S, o5, r5))
          break;
        "CIMLineSymbol" === e6.type && (p2 = H(c6)), q(c6, d, i5, S, o5, r5, n5, p2, u4, l2);
        break;
      default:
        w.error("Cannot analyze CIM layer", c6.type);
    }
  }
}
function E(e6, t3, i5, o5, r5, n5) {
  const a3 = e6.primitiveName, s5 = i2(e6.color), [c6, f3] = ce(o5, a3, t3, null, null), m3 = c(JSON.stringify(e6) + f3).toString();
  n5.push({ type: "fill", templateHash: m3, materialHash: c6 ? () => m3 : m3, cim: e6, materialOverrides: null, colorLocked: e6.colorLocked, color: ie(a3, i5, "Color", r5, s5, te2), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: t3, applyRandomOffset: false, sampleAlphaOnly: true });
}
function T(e6, t3, i5, r5, n5, a3, s5) {
  const c6 = e6.primitiveName, f3 = e6.tintColor ? i2(e6.tintColor) : { r: 255, g: 255, b: 255, a: 1 }, [m3, p2] = ce(r5, c6, t3, null, null), u4 = c(JSON.stringify(e6) + p2).toString(), y3 = c(`${e6.url}${JSON.stringify(e6.colorSubstitutions)}`).toString();
  let h = M(e6.scaleX);
  if ("width" in e6) {
    const t4 = e6.width;
    let i6 = 1;
    const r6 = a3.getResource(e6.url);
    r(r6) && (i6 = r6.width / r6.height), h /= i6 * (e6.height / t4);
  }
  s5.push({ type: "fill", templateHash: u4, materialHash: m3 ? () => y3 : y3, cim: e6, materialOverrides: null, colorLocked: e6.colorLocked, effects: t3, color: ie(c6, i5, "TintColor", n5, f3, te2), height: ie(c6, i5, "Height", n5, e6.height), scaleX: ie(c6, i5, "ScaleX", n5, h), angle: ie(c6, i5, "Rotation", n5, M(e6.rotation)), offsetX: ie(c6, i5, "OffsetX", n5, M(e6.offsetX)), offsetY: ie(c6, i5, "OffsetY", n5, M(e6.offsetY)), url: e6.url, applyRandomOffset: false, sampleAlphaOnly: false });
}
function j(e6, t3, i5, o5, r5, n5) {
  var _a;
  const a3 = ["Rotation", "OffsetX", "OffsetY"], s5 = o5.filter((t4) => t4.primitiveName !== e6.primitiveName && !a3.includes(t4.propertyName)), c6 = e6.primitiveName, [f3, m3] = ce(o5, c6, t3, null, null), p2 = c(JSON.stringify(e6) + m3).toString(), u4 = c(`${e6.separation}${JSON.stringify(e6.lineSymbol)}`).toString();
  let y3 = { r: 255, g: 255, b: 255, a: 1 };
  if (e6.lineSymbol) {
    const t4 = (_a = e6.lineSymbol) == null ? void 0 : _a.symbolLayers.find((e7) => "CIMSolidStroke" === e7.type);
    t4 && (y3 = i2(t4.color));
  }
  n5.push({ type: "fill", templateHash: p2, materialHash: f3 ? ae(u4, i5, s5, r5) : u4, cim: e6, materialOverrides: s5, colorLocked: e6.colorLocked, effects: t3, color: y3, height: ie(c6, i5, "Separation", r5, e6.separation), scaleX: 1, angle: ie(c6, i5, "Rotation", r5, M(e6.rotation)), offsetX: ie(c6, i5, "OffsetX", r5, M(e6.offsetX)), offsetY: ie(c6, i5, "OffsetY", r5, M(e6.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true });
}
function F(e6, t3, i5, o5, r5, n5) {
  const a3 = e6.primitiveName, [s5, c6] = ce(o5, a3, t3, null, null), f3 = c(JSON.stringify(e6) + c6).toString();
  n5.push({ type: "fill", templateHash: f3, materialHash: s5 ? ae(f3, i5, o5, r5) : f3, cim: e6, materialOverrides: null, colorLocked: e6.colorLocked, effects: t3, color: { r: 128, g: 128, b: 128, a: 1 }, height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, applyRandomOffset: false, sampleAlphaOnly: false });
}
function W(e6, t3, i5, o5, r5, n5, a3, s5) {
  const c6 = e6.primitiveName, f3 = i2(e6.color), m3 = void 0 !== e6.width ? e6.width : 4, p2 = L(e6.capStyle), u4 = X(e6.joinStyle), y3 = e6.miterLimit, [h, d] = ce(o5, c6, t3, null, null), S = c(JSON.stringify(e6) + d).toString();
  let v, N;
  if (t3 && t3 instanceof Array && t3.length > 0) {
    const e7 = t3[t3.length - 1];
    if ("CIMGeometricEffectDashes" === e7.type && "NoConstraint" === e7.lineDashEnding && null === e7.offsetAlongLine) {
      const e8 = (t3 = [...t3]).pop();
      v = e8.dashTemplate, N = e8.scaleDash;
    }
  }
  n5.push({ type: "line", templateHash: S, materialHash: h ? () => S : S, cim: e6, materialOverrides: null, isOutline: a3, colorLocked: e6.colorLocked, effects: t3, color: ie(c6, i5, "Color", r5, f3, te2), width: ie(c6, i5, "Width", r5, m3), cap: ie(c6, i5, "CapStyle", r5, p2), join: ie(c6, i5, "JoinStyle", r5, u4), miterLimit: ie(c6, i5, "MiterLimit", r5, y3), referenceWidth: s5, zOrder: ee(e6.name), dashTemplate: v, scaleDash: N, sampleAlphaOnly: true });
}
function D(e6, t3, i5, o5, r5, n5, a3, s5) {
  const c6 = c(`${e6.url}${JSON.stringify(e6.colorSubstitutions)}`).toString(), f3 = e6.primitiveName, m3 = i2(e6.tintColor), p2 = void 0 !== e6.width ? e6.width : 4, u4 = L(e6.capStyle), y3 = X(e6.joinStyle), h = e6.miterLimit, [d, S] = ce(o5, f3, t3, null, null), v = c(JSON.stringify(e6) + S).toString();
  n5.push({ type: "line", templateHash: v, materialHash: d ? () => c6 : c6, cim: e6, materialOverrides: null, isOutline: a3, colorLocked: e6.colorLocked, effects: t3, color: ie(f3, i5, "TintColor", r5, m3, te2), width: ie(f3, i5, "Width", r5, p2), cap: ie(f3, i5, "CapStyle", r5, u4), join: ie(f3, i5, "JoinStyle", r5, y3), miterLimit: ie(f3, i5, "MiterLimit", r5, h), referenceWidth: s5, zOrder: ee(e6.name), dashTemplate: null, scaleDash: false, url: e6.url, sampleAlphaOnly: false });
}
function U(e6, t3, i5, o5, r5, n5, a3, s5) {
  const c6 = e6.primitiveName, f3 = void 0 !== e6.width ? e6.width : 4, m3 = L(e6.capStyle), p2 = X(e6.joinStyle), u4 = e6.miterLimit, [y3, h] = ce(o5, c6, t3, null, null), g = c(JSON.stringify(e6) + h).toString();
  n5.push({ type: "line", templateHash: g, materialHash: y3 ? ae(g, i5, o5, r5) : g, cim: e6, materialOverrides: null, isOutline: a3, colorLocked: e6.colorLocked, effects: t3, color: { r: 128, g: 128, b: 128, a: 1 }, width: ie(c6, i5, "Width", r5, f3), cap: ie(c6, i5, "CapStyle", r5, m3), join: ie(c6, i5, "JoinStyle", r5, p2), miterLimit: ie(c6, i5, "MiterLimit", r5, u4), referenceWidth: s5, zOrder: ee(e6.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
}
function G(e6, t3, i5, o5, r5, a3) {
  const s5 = e6.markerPlacement;
  if (!s5 || "CIMMarkerPlacementInsidePolygon" !== s5.type)
    return false;
  const c6 = s5, f3 = Math.abs(c6.stepX), m3 = Math.abs(c6.stepY);
  if (0 === f3 || 0 === m3)
    return true;
  const p2 = ["Rotation", "OffsetX", "OffsetY"], u4 = o5.filter((t4) => t4.primitiveName !== e6.primitiveName && !p2.includes(t4.propertyName)), y3 = "url" in e6 ? e6.url : null, [h, S] = ce(o5, c6.primitiveName, t3, null, null), v = c(JSON.stringify(e6) + S).toString();
  let N, b, O = null;
  if ("Random" === s5.gridType) {
    const e7 = e(dt), t4 = Math.max(Math.floor(e7 / f3), 1), i6 = Math.max(Math.floor(e7 / m3), 1);
    N = m3 * i6, O = (e8) => e8 ? e8 * i6 : 0;
    b = t4 * f3 / N;
  } else
    s5.shiftOddRows ? (N = 2 * m3, O = (e7) => e7 ? 2 * e7 : 0, b = f3 / m3 * 0.5) : (N = m3, O = null, b = f3 / m3);
  let C2 = { r: 255, g: 255, b: 255, a: 1 };
  return "tintColor" in e6 && (C2 = i2(e6.tintColor)), a3.push({ type: "fill", templateHash: v, materialHash: h ? ae(v, i5, u4, r5) : v, cim: e6, materialOverrides: u4, colorLocked: e6.colorLocked, effects: t3, color: ie(c6.primitiveName, i5, "TintColor", r5, C2, te2), height: ie(c6.primitiveName, i5, "StepY", r5, N, O), scaleX: b, angle: ie(c6.primitiveName, i5, "GridAngle", r5, c6.gridAngle), offsetX: ie(c6.primitiveName, i5, "OffsetX", r5, M(c6.offsetX)), offsetY: ie(c6.primitiveName, i5, "OffsetY", r5, M(c6.offsetY)), url: y3, applyRandomOffset: "Random" === s5.gridType, sampleAlphaOnly: !y3 }), true;
}
function B(e6, t3, i5, r5, n5, a3, s5, c6, f3) {
  const m3 = e6.primitiveName, p2 = M(e6.size);
  let u4 = M(e6.scaleX);
  const y3 = M(e6.rotation), h = M(e6.offsetX), S = M(e6.offsetY), v = e6.tintColor ? i2(e6.tintColor) : { r: 255, g: 255, b: 255, a: 1 }, b = c(`${e6.url}${JSON.stringify(e6.colorSubstitutions)}${JSON.stringify(e6.animatedSymbolProperties)}`).toString(), O = ne(e6.markerPlacement, r5, i5, n5), C2 = le(e6.animatedSymbolProperties, r5, i5, n5), [k, P] = ce(r5, m3, t3, O, C2), M2 = c(JSON.stringify(e6) + P).toString(), w2 = e6.anchorPoint ?? { x: 0, y: 0 };
  if ("width" in e6) {
    const t4 = e6.width;
    let i6 = 1;
    const r6 = a3.getResource(e6.url);
    r(r6) && (i6 = r6.width / r6.height), u4 /= i6 * (p2 / t4);
  }
  function L2(e7, t4) {
    return e3(C2, e7, t4);
  }
  const X2 = e6.animatedSymbolProperties && true === e6.animatedSymbolProperties.randomizeStartTime ? (e7, t4, i6, o5) => {
    const r6 = o4(o5), n6 = L2(e7, t4);
    return b + `-MATERIALGROUP(${r6})-ASP(${JSON.stringify(n6)})`;
  } : k ? (e7, t4) => {
    const i6 = L2(e7, t4);
    return b + `-ASP(${JSON.stringify(i6)})`;
  } : b;
  s5.push({ type: "marker", templateHash: M2, materialHash: X2, cim: e6, materialOverrides: null, colorLocked: e6.colorLocked, effects: t3, scaleSymbolsProportionally: false, alignment: c6, size: ie(m3, i5, "Size", n5, p2), scaleX: ie(m3, i5, "ScaleX", n5, u4), rotation: ie(m3, i5, "Rotation", n5, y3), offsetX: ie(m3, i5, "OffsetX", n5, h), offsetY: ie(m3, i5, "OffsetY", n5, S), color: ie(m3, i5, "TintColor", n5, v, te2), anchorPoint: { x: w2.x, y: -w2.y }, isAbsoluteAnchorPoint: "Relative" !== e6.anchorPointUnits, outlineColor: { r: 0, g: 0, b: 0, a: 0 }, outlineWidth: 0, frameHeight: 0, rotateClockwise: e6.rotateClockwise, referenceSize: f3, sizeRatio: 1, markerPlacement: O, url: e6.url, animatedSymbolProperties: C2 });
}
function q(e6, t3, i5, o5, r5, n5, l2, a3, s5, c6) {
  const f3 = e6.markerGraphics;
  if (!f3)
    return;
  let m3 = 0;
  if (e6.scaleSymbolsProportionally) {
    const t4 = e6.frame;
    t4 && (m3 = t4.ymax - t4.ymin);
  }
  const p2 = ne(e6.markerPlacement, o5, i5, r5);
  for (const u4 of f3)
    if (u4) {
      const f4 = u4.symbol;
      if (!f4)
        continue;
      switch (f4.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          K(e6, t3, p2, null, u4, o5, i5, r5, n5, l2, a3, s5, m3, c6);
          break;
        case "CIMTextSymbol":
          V(e6, t3, p2, u4, i5, o5, r5, n5, a3, s5, m3);
      }
    }
}
function V(e6, t3, i5, o5, r5, n5, a3, s5, m3, p2, u4) {
  const y3 = [];
  te.findApplicableOverrides(o5, n5, y3);
  const h = o5.geometry;
  if (!("x" in h) || !("y" in h))
    return;
  const b = o5.symbol, O = J(b), C2 = R(b.fontStyleName), k = t2(b.fontFamilyName);
  b.font = { family: k, decoration: O, ...C2 };
  const P = e6.frame, I = h.x - 0.5 * (P.xmin + P.xmax), w2 = h.y - 0.5 * (P.ymin + P.ymax), L2 = e6.size / u4, X2 = e6.primitiveName, x3 = M(b.height) * L2, H2 = M(b.angle), Y2 = M(e6.offsetX) + (M(b.offsetX) + I) * L2, $2 = M(e6.offsetY) + (M(b.offsetY) + w2) * L2, E2 = i2(Z.getFillColor(b));
  let T2 = i2(Z.getStrokeColor(b)), j2 = Z.getStrokeWidth(b);
  j2 || (T2 = i2(Z.getFillColor(b.haloSymbol)), j2 = b.haloSize * L2);
  const [F2, W2] = ce(n5, X2, t3, i5, null), D2 = JSON.stringify(e6.effects) + Number(e6.colorLocked) + JSON.stringify(e6.anchorPoint) + e6.anchorPointUnits + JSON.stringify(e6.markerPlacement), U2 = c(JSON.stringify(o5) + D2 + W2).toString();
  let G2 = ie(o5.primitiveName, r5, "TextString", a3, o5.textString, o2, b.textCase);
  if (null == G2)
    return;
  const { fontStyleName: B2 } = b, q2 = k + (B2 ? "-" + B2.toLowerCase() : "-regular"), V2 = q2;
  "string" == typeof G2 && G2.includes("[") && b.fieldMap && (G2 = n2(b.fieldMap, G2, b.textCase)), s5.push({ type: "text", templateHash: U2, materialHash: F2 || "function" == typeof G2 || G2.match(/\[(.*?)\]/) ? (e7, t4, i6) => V2 + "-" + e3(G2, e7, t4, i6) : V2 + "-" + c(G2), cim: b, materialOverrides: null, colorLocked: e6.colorLocked, effects: t3, alignment: m3, anchorPoint: { x: e6.anchorPoint ? e6.anchorPoint.x : 0, y: e6.anchorPoint ? e6.anchorPoint.y : 0 }, isAbsoluteAnchorPoint: "Relative" !== e6.anchorPointUnits, fontName: q2, decoration: O, weight: ie(X2, r5, "Weight", a3, C2.weight), style: ie(X2, r5, "Size", a3, C2.style), size: ie(X2, r5, "Size", a3, x3), angle: ie(X2, r5, "Rotation", a3, H2), offsetX: ie(X2, r5, "OffsetX", a3, Y2), offsetY: ie(X2, r5, "OffsetY", a3, $2), horizontalAlignment: z(b.horizontalAlignment), verticalAlignment: A2(b.verticalAlignment), text: G2, color: E2, outlineColor: T2, outlineSize: j2, referenceSize: p2, sizeRatio: 1, markerPlacement: i5 });
}
function K(e6, t3, i5, r5, n5, a3, s5, f3, m3, p2, u4, S, v, N) {
  const b = n5.symbol, O = b.symbolLayers;
  if (!O)
    return;
  if (N)
    return void _(e6, t3, i5, r5, n5, s5, a3, f3, m3, p2, u4, S, v);
  let k = O.length;
  if (me(O))
    return void Q(e6, t3, i5, r5, n5, O, a3, s5, f3, m3, u4, S, v);
  const P = f2.applyEffects(b.effects, n5.geometry, p2.geometryEngine);
  if (P)
    for (; k--; ) {
      const N2 = O[k];
      if (N2 && false !== N2.enable)
        switch (N2.type) {
          case "CIMSolidFill":
          case "CIMSolidStroke": {
            const b2 = f2.applyEffects(N2.effects, P, p2.geometryEngine), O2 = f(b2);
            if (!O2)
              continue;
            const [k2, M2, I] = m2(O2, e6.frame, e6.size, e6.anchorPoint, "Relative" !== e6.anchorPointUnits), w2 = "CIMSolidFill" === N2.type, L2 = { type: "sdf", geom: b2, asFill: w2 }, X2 = e6.primitiveName, z2 = M(e6.size) ?? 10, A3 = M(e6.rotation), R2 = M(e6.offsetX), J2 = M(e6.offsetY), x3 = N2.path, H2 = N2.primitiveName, Y2 = i2(w2 ? Z.getFillColor(N2) : Z.getStrokeColor(N2)), $2 = w2 ? { r: 0, g: 0, b: 0, a: 0 } : i2(Z.getStrokeColor(N2)), E2 = Z.getStrokeWidth(N2);
            if (!w2 && !E2)
              break;
            let T2 = false, j2 = "";
            for (const e7 of a3)
              e7.primitiveName !== H2 && e7.primitiveName !== X2 || (void 0 !== e7.value ? j2 += `-${e7.primitiveName}-${e7.propertyName}-${JSON.stringify(e7.value)}` : e7.valueExpressionInfo && (T2 = true));
            r(t3) && "function" == typeof t3 && (T2 = true);
            const F2 = JSON.stringify({ ...e6, markerGraphics: null }), W2 = c(JSON.stringify(L2) + x3).toString(), D2 = { type: "marker", templateHash: c(JSON.stringify(n5) + JSON.stringify(N2) + F2 + j2).toString(), materialHash: T2 ? () => W2 : W2, cim: L2, materialOverrides: null, colorLocked: e6.colorLocked, effects: t3, scaleSymbolsProportionally: e6.scaleSymbolsProportionally, alignment: u4, anchorPoint: { x: M2, y: I }, isAbsoluteAnchorPoint: false, size: ie(e6.primitiveName, s5, "Size", f3, z2), rotation: ie(e6.primitiveName, s5, "Rotation", f3, A3), offsetX: ie(e6.primitiveName, s5, "OffsetX", f3, R2), offsetY: ie(e6.primitiveName, s5, "OffsetY", f3, J2), scaleX: 1, frameHeight: v, rotateClockwise: e6.rotateClockwise, referenceSize: S, sizeRatio: k2, color: ie(H2, s5, "Color", f3, Y2, te2), outlineColor: ie(H2, s5, "Color", f3, $2, te2), outlineWidth: ie(H2, s5, "Width", f3, E2), markerPlacement: i5, animatedSymbolProperties: r5, path: x3 };
            m3.push(D2);
            break;
          }
          default:
            _(e6, t3, i5, r5, n5, s5, a3, f3, m3, p2, u4, S, v);
        }
    }
}
function Q(e6, t3, i5, o5, r5, n5, a3, s5, f3, m3, p2, u4, S) {
  const v = r5.geometry, N = n5[0], b = n5[1], O = f(v);
  if (!O)
    return;
  const [C2, k, P] = m2(O, e6.frame, e6.size, e6.anchorPoint, "Relative" !== e6.anchorPointUnits), M2 = { type: "sdf", geom: v, asFill: true }, I = e6.primitiveName, w2 = M(e6.size), L2 = M(e6.rotation), X2 = M(e6.offsetX), z2 = M(e6.offsetY), A3 = b.path, R2 = b.primitiveName, J2 = N.primitiveName, x3 = i2(Z.getFillColor(b)), H2 = i2(Z.getStrokeColor(N)), Y2 = Z.getStrokeWidth(N);
  let $2 = false, E2 = "";
  for (const l2 of a3)
    l2.primitiveName !== R2 && l2.primitiveName !== J2 && l2.primitiveName !== I || (void 0 !== l2.value ? E2 += `-${l2.primitiveName}-${l2.propertyName}-${JSON.stringify(l2.value)}` : l2.valueExpressionInfo && ($2 = true));
  const T2 = JSON.stringify({ ...e6, markerGraphics: null }), j2 = c(JSON.stringify(M2) + A3).toString(), F2 = { type: "marker", templateHash: c(JSON.stringify(r5) + JSON.stringify(b) + JSON.stringify(N) + T2 + E2).toString(), materialHash: $2 ? () => j2 : j2, cim: M2, materialOverrides: null, colorLocked: e6.colorLocked, effects: t3, scaleSymbolsProportionally: e6.scaleSymbolsProportionally, alignment: p2, anchorPoint: { x: k, y: P }, isAbsoluteAnchorPoint: false, size: ie(e6.primitiveName, s5, "Size", f3, w2), rotation: ie(e6.primitiveName, s5, "Rotation", f3, L2), offsetX: ie(e6.primitiveName, s5, "OffsetX", f3, X2), offsetY: ie(e6.primitiveName, s5, "OffsetY", f3, z2), scaleX: 1, frameHeight: S, rotateClockwise: e6.rotateClockwise, referenceSize: u4, sizeRatio: C2, color: ie(R2, s5, "Color", f3, x3, te2), outlineColor: ie(J2, s5, "Color", f3, H2, te2), outlineWidth: ie(J2, s5, "Width", f3, Y2), markerPlacement: i5, path: A3, animatedSymbolProperties: o5 };
  m3.push(F2);
}
function _(e6, t3, i5, n5, a3, s5, f3, m3, p2, u4, y3, h, g) {
  const S = Z2(e6, a3);
  let v = [];
  const N = ["Rotation", "OffsetX", "OffsetY"];
  v = f3.filter((t4) => t4.primitiveName !== e6.primitiveName || !N.includes(t4.propertyName));
  let b = "";
  for (const o5 of f3)
    void 0 !== o5.value && (b += `-${o5.primitiveName}-${o5.propertyName}-${JSON.stringify(o5.value)}`);
  const [O, C2, k] = Z.getTextureAnchor(S, u4), P = e6.primitiveName, M2 = M(e6.rotation), I = M(e6.offsetX), w2 = M(e6.offsetY), L2 = c(JSON.stringify(S) + b).toString(), X2 = { type: "marker", templateHash: L2, materialHash: v.length > 0 || r(t3) && "function" == typeof t3 ? ae(L2, s5, v, m3) : L2, cim: S, materialOverrides: v, colorLocked: e6.colorLocked, effects: t3, scaleSymbolsProportionally: e6.scaleSymbolsProportionally, alignment: y3, anchorPoint: { x: O, y: C2 }, isAbsoluteAnchorPoint: false, size: e6.size, rotation: ie(P, s5, "Rotation", m3, M2), offsetX: ie(P, s5, "OffsetX", m3, I), offsetY: ie(P, s5, "OffsetY", m3, w2), color: { r: 255, g: 255, b: 255, a: 1 }, outlineColor: { r: 0, g: 0, b: 0, a: 0 }, outlineWidth: 0, scaleX: 1, frameHeight: g, rotateClockwise: e6.rotateClockwise, referenceSize: h, sizeRatio: k / u(e6.size), markerPlacement: i5, animatedSymbolProperties: n5 };
  p2.push(X2);
}
function Z2(e6, t3) {
  return { type: e6.type, enable: true, name: e6.name, colorLocked: e6.colorLocked, primitiveName: e6.primitiveName, anchorPoint: e6.anchorPoint, anchorPointUnits: e6.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e6.rotateClockwise, rotation: 0, size: e6.size, billboardMode3D: e6.billboardMode3D, depth3D: e6.depth3D, frame: e6.frame, markerGraphics: [t3], scaleSymbolsProportionally: e6.scaleSymbolsProportionally, respectFrame: e6.respectFrame, clippingPath: e6.clippingPath };
}
function ee(e6) {
  if (e6 && 0 === e6.indexOf("Level_")) {
    const t3 = parseInt(e6.substr(6), 10);
    if (!isNaN(t3))
      return t3;
  }
  return 0;
}
function te2(t3) {
  if (!t3 || 0 === t3.length)
    return null;
  const i5 = new l(t3).toRgba();
  return { r: i5[0], g: i5[1], b: i5[2], a: i5[3] };
}
function ie(e6, t3, i5, o5, r5, n5, l2) {
  const a3 = t3[e6];
  if (a3) {
    const e7 = a3[i5];
    if ("string" == typeof e7 || "number" == typeof e7 || e7 instanceof Array)
      return n5 ? n5.call(null, e7, l2) : e7;
    if (null != e7 && e7 instanceof o3)
      return (t4, i6, a4) => {
        let s5 = s3(e7, t4, { $view: a4 }, o5.geometryType, i6);
        return null !== s5 && n5 && (s5 = n5.call(null, s5, l2)), null !== s5 ? s5 : r5;
      };
  }
  return r5;
}
function oe(e6) {
  return e6 ? e6.charAt(0).toLowerCase() + e6.substr(1) : e6;
}
function re(e6, i5, o5, r5) {
  for (const t3 of i5) {
    if (t3.valueExpressionInfo) {
      const e7 = o5[t3.primitiveName] && o5[t3.primitiveName][t3.propertyName];
      e7 instanceof o3 && (t3.fn = (t4, i6, o6) => s3(e7, t4, { $view: o6 }, r5.geometryType, i6));
    }
  }
  return (o6, r6, n5) => {
    for (const e7 of i5)
      e7.fn && (e7.value = e7.fn(o6, r6, n5));
    const l2 = [];
    for (let a3 of e6) {
      const e7 = a3 == null ? void 0 : a3.primitiveName;
      if (e7) {
        let o7 = false;
        for (const r7 of i5)
          if (r7.primitiveName === e7) {
            const e8 = oe(r7.propertyName);
            null != r7.value && r7.value !== a3[e8] && (o7 || (a3 = m(a3), o7 = true), a3[e8] = r7.value);
          }
      }
      l2.push(a3);
    }
    return l2;
  };
}
function ne(e6, i5, o5, r5) {
  const n5 = [];
  if (te.findApplicableOverrides(e6, i5, n5), 0 === n5.length)
    return e6;
  for (const t3 of n5) {
    if (t3.valueExpressionInfo) {
      const e7 = o5[t3.primitiveName] && o5[t3.primitiveName][t3.propertyName];
      e7 instanceof o3 && (t3.fn = (t4, i6, o6) => s3(e7, t4, { $view: o6 }, r5.geometryType, i6));
    }
  }
  return (i6, o6, r6) => {
    for (const e7 of n5)
      e7.fn && (e7.value = e7.fn(i6, o6, r6));
    const l2 = m(e6), a3 = e6.primitiveName;
    for (const e7 of n5)
      if (e7.primitiveName === a3) {
        const t3 = oe(e7.propertyName);
        null != e7.value && e7.value !== l2[t3] && (l2[t3] = e7.value);
      }
    return l2;
  };
}
function le(e6, i5, o5, r5) {
  const n5 = [];
  if (te.findApplicableOverrides(e6, i5, n5), 0 === n5.length)
    return e6;
  for (const t3 of n5) {
    if (t3.valueExpressionInfo) {
      const e7 = o5[t3.primitiveName] && o5[t3.primitiveName][t3.propertyName];
      e7 instanceof o3 && (t3.fn = (t4, i6, o6) => s3(e7, t4, { $view: o6 }, r5.geometryType, i6));
    }
  }
  return (i6, o6, r6) => {
    for (const e7 of n5)
      e7.fn && (e7.value = e7.fn(i6, o6, r6));
    const l2 = m(e6), a3 = e6.primitiveName;
    for (const e7 of n5)
      if (e7.primitiveName === a3) {
        const t3 = oe(e7.propertyName);
        null != e7.value && e7.value !== l2[t3] && (l2[t3] = e7.value);
      }
    return l2;
  };
}
function ae(e6, t3, i5, o5) {
  for (const r5 of i5) {
    if (r5.valueExpressionInfo) {
      const e7 = t3[r5.primitiveName] && t3[r5.primitiveName][r5.propertyName];
      e7 instanceof o3 && (r5.fn = (t4, i6, r6) => s3(e7, t4, { $view: r6 }, o5.geometryType, i6));
    }
  }
  return (t4, o6, r5) => {
    for (const e7 of i5)
      e7.fn && (e7.value = e7.fn(t4, o6, r5));
    return c(e6 + te.buildOverrideKey(i5)).toString();
  };
}
function se(e6, t3) {
  if (!t3 || 0 === t3.length)
    return e6;
  const i5 = JSON.parse(JSON.stringify(e6));
  return te.applyOverrides(i5, t3), i5;
}
function ce(e6, t3, i5, r5, n5) {
  let l2 = false, a3 = "";
  for (const o5 of e6)
    o5.primitiveName === t3 && (void 0 !== o5.value ? a3 += `-${o5.primitiveName}-${o5.propertyName}-${JSON.stringify(o5.value)}` : o5.valueExpressionInfo && (l2 = true));
  return r(i5) && "function" == typeof i5 && (l2 = true), r(r5) && "function" == typeof r5 && (l2 = true), r(n5) && "function" == typeof n5 && (l2 = true), [l2, a3];
}
function fe(e6, t3, i5) {
  if (e6 && t3)
    switch (e6.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol": {
        const o5 = e6.symbolLayers;
        if (!o5)
          return;
        for (const e7 of o5)
          switch (ue(e7, t3, i5), e7.type) {
            case "CIMPictureFill":
            case "CIMHatchFill":
            case "CIMGradientFill":
            case "CIMPictureStroke":
            case "CIMGradientStroke":
            case "CIMCharacterMarker":
            case "CIMPictureMarker":
              "url" in e7 && e7.url && i5.push(t3.fetchResource(e7.url, null));
              break;
            case "CIMVectorMarker": {
              const o6 = e7.markerGraphics;
              if (!o6)
                continue;
              for (const e8 of o6)
                if (e8) {
                  const o7 = e8.symbol;
                  o7 && fe(o7, t3, i5);
                }
            }
          }
      }
    }
}
var me = (e6) => e6 && 2 === e6.length && e6[0].enable && e6[1].enable && "CIMSolidStroke" === e6[0].type && "CIMSolidFill" === e6[1].type && !e6[0].effects && !e6[1].effects;
var pe;
function ue(e6, t3, i5) {
  if (!e6.effects || r(t3.geometryEngine))
    return;
  if (pe)
    return void i5.push(pe);
  p(e6.effects) && (pe = C(), i5.push(pe), pe.then((e7) => t3.geometryEngine = e7));
}

export {
  f2 as f,
  r3 as r,
  a2 as a,
  n3 as n,
  e5 as e,
  o4 as o,
  Y,
  se
};
//# sourceMappingURL=chunk-IEPHENP2.js.map
