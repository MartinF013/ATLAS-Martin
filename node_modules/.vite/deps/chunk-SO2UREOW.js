import {
  A
} from "./chunk-43ZVVGJH.js";
import {
  c2 as c,
  d2,
  f,
  m as m2,
  x as x3,
  z
} from "./chunk-WKUIJCRG.js";
import {
  e as e4
} from "./chunk-XQ337NY7.js";
import {
  i
} from "./chunk-UMSO3HI4.js";
import {
  f as f2
} from "./chunk-VKEKAYXP.js";
import {
  u as u2
} from "./chunk-6UGZAJSY.js";
import {
  v
} from "./chunk-WL7KJZAL.js";
import {
  S
} from "./chunk-HH3D3A65.js";
import {
  h as h2
} from "./chunk-OA3NMCNZ.js";
import {
  l as l3
} from "./chunk-TCBD6DES.js";
import {
  l as l2
} from "./chunk-G2GJVIQC.js";
import {
  l as l4
} from "./chunk-6EODZIDR.js";
import {
  e as e3
} from "./chunk-PQO66WZ2.js";
import {
  y as y2
} from "./chunk-OMNBM2E4.js";
import {
  u
} from "./chunk-M2WA2LMI.js";
import {
  x as x2
} from "./chunk-4XBERLPX.js";
import {
  b as b2
} from "./chunk-GSFXXEAM.js";
import {
  h,
  j as j3,
  l
} from "./chunk-T7BEWVV3.js";
import {
  g as g2
} from "./chunk-BLINZ65M.js";
import {
  _
} from "./chunk-FTLBKDGL.js";
import {
  j as j2
} from "./chunk-TT2HIXWQ.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  D,
  b,
  g,
  j,
  x
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  a,
  e as e2,
  o,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/AggregateGraphic.js
var p = class extends g2 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e6 = false) {
    if (this.popupTemplate)
      return this.popupTemplate;
    const r2 = this.sourceLayer && this.sourceLayer.featureReduction;
    return r2 && "popupTemplate" in r2 && r2.popupEnabled ? r2.popupTemplate : null;
  }
  getObjectId() {
    return this.objectId;
  }
};
e([d({ type: Boolean })], p.prototype, "isAggregate", void 0), e([d({ type: [String, Number], json: { read: true } })], p.prototype, "objectId", void 0), p = e([n("esri.AggregateGraphic")], p);
var s3 = p;

// node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var o2 = class extends y {
  constructor(e6) {
    super(e6), this._filter = null, this.duration = a("mapview-transitions-duration"), this._excludedEffectView = new h2(e6), this._includedEffectView = new h2(e6);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e6) {
    this._get("featureEffect") !== e6 && this._transitionTo(e6);
  }
  get filter() {
    var _a;
    return this._filter || ((_a = e2(this.featureEffect)) == null ? void 0 : _a.filter) || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e6) {
    this._set("scale", e6), this._excludedEffectView.scale = e6, this._includedEffectView.scale = e6;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  transitionStep(e6, t2) {
    this._set("scale", t2), this.transitioning ? (this._includedEffectView.transitionStep(e6, t2), this._excludedEffectView.transitionStep(e6, t2), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t2, this._includedEffectView.scale = t2);
  }
  end() {
    this._includedEffectView.end(), this._excludedEffectView.end(), this._filter = null;
  }
  _transitionTo(e6) {
    const t2 = this._get("featureEffect"), i3 = e2(e6), f3 = e2(i3 == null ? void 0 : i3.includedEffect), c4 = e2(i3 == null ? void 0 : i3.excludedEffect), r2 = this._includedEffectView.canTransitionTo(f3) && this._excludedEffectView.canTransitionTo(c4);
    this._includedEffectView.effect = f3, this._excludedEffectView.effect = c4, this._set("featureEffect", i3), this._filter = (i3 == null ? void 0 : i3.filter) || (t2 == null ? void 0 : t2.filter) || null, r2 || this.end();
  }
};
e([d()], o2.prototype, "_filter", void 0), e([d()], o2.prototype, "_excludedEffectView", void 0), e([d()], o2.prototype, "_includedEffectView", void 0), e([d()], o2.prototype, "duration", void 0), e([d()], o2.prototype, "excludedEffects", null), e([d()], o2.prototype, "featureEffect", null), e([d()], o2.prototype, "filter", null), e([d()], o2.prototype, "hasEffects", null), e([d()], o2.prototype, "includedEffects", null), e([d({ value: 0 })], o2.prototype, "scale", null), e([d()], o2.prototype, "transitioning", null), o2 = e([n("esri.layers.effects.FeatureEffectView")], o2);
var n2 = o2;

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers.js
async function e5(e6, r2) {
  if (!e6)
    return null;
  switch (e6.type) {
    case "symbol":
      return new (await import("./SymbolTileRenderer-XGGOYJX6.js")).default(r2);
    case "heatmap":
      return new (await import("./HeatmapTileRenderer-FQ6JTGK5.js")).default(r2);
  }
}

// node_modules/@arcgis/core/views/2d/layers/support/FeatureCommandQueue.js
function a2(e6) {
  return e6.some((e7) => e7.globalId);
}
function d3(e6) {
  return e6.filter((e7) => !e7.error).map((e7) => e7.objectId ?? e7.globalId);
}
function i2(e6, r2) {
  const s5 = new Set(e6);
  for (const t2 of r2.values())
    s5.add(t2);
  return s5;
}
function n3(e6, r2) {
  const s5 = new Set(e6);
  for (const t2 of r2.values())
    s5.delete(t2);
  return s5;
}
var c2 = class extends y {
  constructor(e6) {
    super(e6), this._hasGlobalIds = false;
  }
  normalizeCtorArgs(e6) {
    return this._queueProcessor = new l2({ concurrency: 1, process: e6.process }), {};
  }
  destroy() {
    this.clear();
  }
  get updating() {
    return this._queueProcessor.length > 0;
  }
  clear() {
    this._queueProcessor.clear();
  }
  push(e6) {
    const r2 = this._queueProcessor, s5 = r2.last();
    switch (e6.type) {
      case "update":
      case "refresh":
        if ((s5 == null ? void 0 : s5.type) === e6.type)
          return;
        r2.push(e6).finally(() => this.notifyChange("updating"));
        break;
      case "edit": {
        const t2 = "processed-edit" === (s5 == null ? void 0 : s5.type) ? s5 : null;
        t2 && r2.popLast();
        const o3 = this._mergeEdits(t2, e6);
        for (const e7 of o3)
          r2.push(e7).finally(() => this.notifyChange("updating"));
        break;
      }
    }
    this.notifyChange("updating");
  }
  _mergeEdits(e6, r2) {
    const { addedFeatures: s5, deletedFeatures: t2, updatedFeatures: o3 } = r2.edits;
    if (this._hasGlobalIds = this._hasGlobalIds || a2(s5) || a2(o3) || a2(t2), this._hasGlobalIds) {
      return [e6, { type: "processed-edit", edits: { addOrModified: [...s5, ...o3], removed: t2 } }];
    }
    const c4 = new Set(d3((e6 == null ? void 0 : e6.edits.addOrModified) ?? [])), u5 = new Set(d3((e6 == null ? void 0 : e6.edits.removed) ?? [])), p2 = /* @__PURE__ */ new Set([...d3(s5), ...d3(o3)]), l7 = new Set(d3(t2));
    return [{ type: "processed-edit", edits: { addOrModified: Array.from(i2(n3(c4, l7), p2)).map((e7) => ({ objectId: e7 })), removed: Array.from(i2(n3(u5, p2), l7)).map((e7) => ({ objectId: e7 })) } }];
  }
};
e([d({ readOnly: true })], c2.prototype, "updating", null), c2 = e([n("esri.views.2d.layers.support.FeatureCommandQueue")], c2);
var u3 = c2;

// node_modules/@arcgis/core/views/2d/layers/support/FeatureLayerProxy.js
function c3(e6) {
  return Array.isArray(e6);
}
var l5 = class extends _ {
  constructor(e6) {
    super(e6), this._startupResolver = D(), this.isReady = false;
  }
  initialize() {
    this._controller = new AbortController(), this.addResolvingPromise(this._startWorker(this._controller.signal));
  }
  destroy() {
    this._controller.abort(), this._connection && this._connection.close();
  }
  set tileRenderer(e6) {
    this.client.tileRenderer = e6;
  }
  get closed() {
    return this._connection.closed;
  }
  async startup(e6, t2, r2, s5) {
    await this.when();
    const o3 = this._controller.signal, i3 = c3(r2.source) ? { transferList: r2.source, signal: o3 } : void 0, n4 = { service: r2, config: t2, tileInfo: e6.tileInfo.toJSON(), tiles: s5 };
    await this._connection.invoke("startup", n4, i3), this._startupResolver.resolve(), this._set("isReady", true);
  }
  async updateTiles(e6) {
    return await this._startupResolver.promise, j(this._connection.invoke("updateTiles", e6));
  }
  async update(e6) {
    const t2 = { config: e6 };
    return await this._startupResolver.promise, this._connection.invoke("update", t2);
  }
  async applyUpdate(e6) {
    return await this._startupResolver.promise, this._connection.invoke("applyUpdate", e6);
  }
  async setHighlight(e6) {
    return await this._startupResolver.promise, j(this._connection.invoke("controller.setHighlight", e6));
  }
  async stop() {
    if (await this._startupResolver.promise, !this.closed)
      return j(this._connection.invoke("stop"));
  }
  async refresh(e6) {
    return await this._startupResolver.promise, j(this._connection.invoke("controller.refresh", e6));
  }
  async querySummaryStatistics(e6, t2, r2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.querySummaryStatistics", { query: e6.toJSON(), params: t2 }, r2);
  }
  async queryUniqueValues(e6, t2, r2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryUniqueValues", { query: e6.toJSON(), params: t2 }, r2);
  }
  async queryClassBreaks(e6, t2, r2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryClassBreaks", { query: e6.toJSON(), params: t2 }, r2);
  }
  async queryHistogram(e6, t2, r2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryHistogram", { query: e6.toJSON(), params: t2 }, r2);
  }
  async queryFeatures(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryFeatures", e6.toJSON(), t2);
  }
  async queryVisibleFeatures(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryVisibleFeatures", e6.toJSON(), t2);
  }
  async queryObjectIds(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryObjectIds", e6.toJSON(), t2);
  }
  async queryFeatureCount(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryFeatureCount", e6.toJSON(), t2);
  }
  async queryExtent(e6, t2) {
    return this._connection.invoke("controller.queryExtent", e6.toJSON(), t2);
  }
  async queryLatestObservations(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryLatestObservations", e6.toJSON(), t2);
  }
  async queryStatistics(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryStatistics", e6);
  }
  async getObjectId(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getObjectId", e6);
  }
  async getDisplayId(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getDisplayId", e6);
  }
  async getFeatures(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getFeatures", e6);
  }
  async getAggregates() {
    return await this._startupResolver.promise, this._connection.invoke("controller.getAggregates");
  }
  async getAggregateValueRanges() {
    return await this._startupResolver.promise, this._connection.invoke("controller.getAggregateValueRanges");
  }
  async mapValidDisplayIds(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.mapValidDisplayIds", e6);
  }
  async onEdits(e6) {
    return await this._startupResolver.promise, j(this._connection.invoke("controller.onEdits", e6));
  }
  async enableEvent(e6, t2) {
    return await this._startupResolver.promise, j(this._connection.invoke("controller.enableEvent", { name: e6, value: t2 }));
  }
  pauseStream() {
    return j(this._connection.invoke("controller.pauseStream"));
  }
  resumeStream() {
    return j(this._connection.invoke("controller.resumeStream"));
  }
  async _startWorker(e6) {
    try {
      this._connection = await u("Pipeline", { client: this.client, strategy: "dedicated", signal: e6 });
    } catch (t2) {
      b(t2);
    }
  }
};
e([d()], l5.prototype, "isReady", void 0), e([d()], l5.prototype, "client", void 0), e([d()], l5.prototype, "tileRenderer", null), l5 = e([n("esri.views.2d.layers.support.FeatureLayerProxy")], l5);
var u4 = l5;

// node_modules/@arcgis/core/views/2d/tiling/TileManager.js
var l6 = 1e-6;
var s4 = class {
  constructor(e6) {
    this._tiles = /* @__PURE__ */ new Map(), this.buffer = 0, this.acquireTile = e6.acquireTile, this.releaseTile = e6.releaseTile, this.tileInfoView = e6.tileInfoView, this.buffer = e6.buffer;
  }
  destroy() {
  }
  clear() {
    this._tiles.forEach((e6) => this._releaseTile(e6));
  }
  tileKeys() {
    const e6 = [];
    return this._tiles.forEach((i3, t2) => e6.push(t2)), e6;
  }
  update(e6) {
    const l7 = this.tileInfoView.getTileCoverage(e6.state, this.buffer, "closest"), { spans: s5, lodInfo: r2 } = l7, { level: a3 } = r2, o3 = [], d4 = [], h3 = /* @__PURE__ */ new Set(), n4 = /* @__PURE__ */ new Set();
    for (const { row: i3, colFrom: c4, colTo: f3 } of s5)
      for (let e7 = c4; e7 <= f3; e7++) {
        const l8 = e3.getId(a3, i3, r2.normalizeCol(e7), r2.getWorldForColumn(e7)), s6 = this._getOrAcquireTile(o3, l8);
        h3.add(l8), s6.isReady ? s6.visible = true : n4.add(s6.key);
      }
    n4.forEach((e7) => this._addPlaceholders(h3, e7)), this._tiles.forEach((e7) => {
      h3.has(e7.key.id) || (d4.push(e7.key.id), this._releaseTile(e7));
    }), l3.pool.release(l7);
    return { hasMissingTiles: n4.size > 0, added: o3, removed: d4 };
  }
  _getOrAcquireTile(e6, i3) {
    if (!this._tiles.has(i3)) {
      const l7 = this.acquireTile(new e3(i3));
      e6.push(i3), this._tiles.set(i3, l7), l7.visible = false;
    }
    return this._tiles.get(i3);
  }
  _getTile(e6) {
    return this._tiles.get(e6);
  }
  _releaseTile(e6) {
    this._tiles.delete(e6.key.id), this.releaseTile(e6);
  }
  _addPlaceholders(e6, i3) {
    const t2 = this._addPlaceholderChildren(e6, i3);
    if (!(Math.abs(1 - t2) < l6)) {
      if (!this._addPlaceholderParent(e6, i3)) {
        this._getTile(i3.id).visible = true;
      }
    }
  }
  _addPlaceholderChildren(e6, i3) {
    let t2 = 0;
    return this._tiles.forEach((l7) => {
      t2 += this._addPlaceholderChild(e6, l7, i3);
    }), t2;
  }
  _addPlaceholderChild(e6, i3, t2) {
    if (i3.key.level <= t2.level || !i3.hasData || !t2.contains(i3.key))
      return 0;
    i3.visible = true, e6.add(i3.key.id);
    return 1 / (1 << 2 * (i3.key.level - t2.level));
  }
  _addPlaceholderParent(i3, t2) {
    let l7 = t2.getParentKey(), s5 = 0, r2 = null;
    for (; r(l7); ) {
      if (i3.has(l7.id))
        return true;
      const e6 = this._getTile(l7.id);
      if (e6 == null ? void 0 : e6.isReady)
        return e6.visible = true, i3.add(e6.key.id), true;
      (e6 == null ? void 0 : e6.hasData) && e6.patchCount > s5 && (s5 = e6.patchCount, r2 = e6), l7 = l7.getParentKey();
    }
    return !!r2 && (r2.visible = true, i3.add(r2.key.id), true);
  }
};

// node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function Q(e6) {
  return e6 && "openPorts" in e6;
}
var A2 = s.getLogger("esri.views.2d.layers.FeatureLayerView2D");
var M2 = class extends A(i(f2(u2))) {
  constructor() {
    super(...arguments), this._pipelineIsUpdating = true, this._commandsQueue = new u3({ process: (e6) => {
      switch (e6.type) {
        case "processed-edit":
          return this._doEdit(e6);
        case "refresh":
          return this._doRefresh(e6.dataChanged);
        case "update":
          return this._doUpdate();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._highlightIds = /* @__PURE__ */ new Map(), this._updateHighlight = x(async () => this._proxy.setHighlight(Array.from(this._highlightIds.keys()))), this._uploadsLocked = false, this._needsClusterSizeUpdate = false, this.featureEffectView = new n2(), this._lastDefinitionExpression = null;
  }
  destroy() {
    var _a;
    o(this._updateClusterSizeTask, (e6) => e6.remove()), (_a = this._proxy) == null ? void 0 : _a.destroy(), this._commandsQueue.destroy();
  }
  initialize() {
    this.addResolvingPromise(Promise.all([this._initProxy(), this._initServiceOptions()])), this.handles.add([this.on("valueRangesChanged", (e6) => {
      this._set("_aggregateValueRanges", e6.valueRanges);
    }), l(() => this.featureEffect, (e6) => {
      this.featureEffectView.featureEffect = e6;
    }, { initial: true, sync: true })]);
  }
  async _initProxy() {
    const e6 = this.layer;
    if ("isTable" in e6 && e6.isTable)
      throw new s2("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: this.layer });
    const t2 = "feature" === e6.type || "subtype-group" === e6.type, i3 = "capabilities" in e6 && e6.capabilities.operations.supportsQuery;
    if (t2 && !i3)
      throw new s2("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e6 });
    this._proxy && this._proxy.destroy();
    const r2 = this._createClientOptions();
    return this._set("_proxy", new u4({ client: r2 })), this._proxy.when();
  }
  async _initServiceOptions() {
    return this._set("_serviceOptions", await this._createServiceOptions()), this._serviceOptions;
  }
  get orderByFields() {
    return "stream" !== this._serviceOptions.type && this._serviceOptions.orderByFields;
  }
  get labelsVisible() {
    const e6 = "subtype-group" === this.layer.type ? this.layer.sublayers.items : [this.layer];
    return !this.suspended && e6.some((e7) => e7.labelingInfo && e7.labelsVisible);
  }
  get queryMode() {
    return this._serviceOptions.type;
  }
  get renderingConfigHash() {
    if (!this.layer)
      return null;
    const e6 = this.availableFields, t2 = this.layer, i3 = this.view.floors, { definitionExpression: r2 } = t2, s5 = "subtype-group" !== this.layer.type && this.layer.labelsVisible && this.layer.labelingInfo, a3 = "renderer" in t2 && t2.renderer, n4 = "feature" === t2.type ? t2.gdbVersion : void 0, o3 = "feature" === t2.type && t2.historicMoment ? t2.historicMoment.getTime() : void 0, { timeExtent: l7 } = this, u5 = "customParameters" in t2 ? JSON.stringify(t2.customParameters) : void 0, d4 = "apiKey" in t2 ? t2.apiKey : void 0, p2 = "stream" === t2.type ? `${JSON.stringify(t2.geometryDefinition)}${t2.definitionExpression}` : null, y3 = JSON.stringify(this.clips), c4 = t2.featureReduction && t2.featureReduction.toJSON(), f3 = "orderBy" in this.layer && JSON.stringify(this.layer.orderBy), g3 = "sublayers" in this.layer && this.layer.sublayers.items.reduce((e7, t3) => e7 + `${t3.visible ? 1 : 0}.${JSON.stringify(t3.renderer)}.${t3.labelsVisible}
.${JSON.stringify(t3.labelingInfo)}`, ""), m3 = "subtypeCode" in this.layer && this.layer.subtypeCode;
    return JSON.stringify({ orderBy: f3, sublayerHash: g3, subtypeCode: m3, filterHash: r(this.filter) && this.filter.toJSON(), effectHash: r(this.featureEffect) && this.featureEffect.toJSON(), streamFilter: p2, gdbVersion: n4, definitionExpression: r2, historicMoment: o3, availableFields: e6, renderer: a3, labelingInfo: s5, timeExtent: l7, floors: i3, clipsHash: y3, featureReduction: c4, customParameters: u5, apiKey: d4 });
  }
  highlight(e6) {
    let t2;
    return e6 instanceof g2 ? t2 = [e6.getObjectId()] : "number" == typeof e6 || "string" == typeof e6 ? t2 = [e6] : Array.isArray(e6) && e6.length > 0 ? t2 = "number" == typeof e6[0] || "string" == typeof e6[0] ? e6 : e6.map((e7) => e7 == null ? void 0 : e7.getObjectId()) : j2.isCollection(e6) && e6.length > 0 && (t2 = e6.map((e7) => e7 == null ? void 0 : e7.getObjectId()).toArray()), t2 = t2 == null ? void 0 : t2.filter((e7) => null != e7), t2 && t2.length ? (this._addHighlight(t2), { remove: () => this._removeHighlight(t2) }) : { remove: () => {
    } };
  }
  hasHighlight() {
    return !!this._highlightIds.size;
  }
  async hitTest(e6, r2) {
    if (!this.tileRenderer)
      return null;
    const s5 = await this.tileRenderer.hitTest(r2);
    if (0 === s5.length)
      return null;
    const { features: a3, aggregates: n4 } = await this._proxy.getFeatures(s5);
    return [...n4.map((i3) => this._createGraphicHit(e6, s3.fromJSON(i3))), ...a3.map((t2) => this._createGraphicHit(e6, g2.fromJSON(t2)))];
  }
  async queryAggregates() {
    return (await this._proxy.getAggregates()).map((e6) => s3.fromJSON(e6));
  }
  queryStatistics() {
    return this._proxy.queryStatistics();
  }
  async querySummaryStatistics(e6, t2, i3) {
    const r2 = { ...t2, scale: this.view.scale };
    return this._proxy.querySummaryStatistics(this._cleanUpQuery(e6), r2, i3);
  }
  async queryUniqueValues(e6, t2, i3) {
    const r2 = { ...t2, scale: this.view.scale };
    return this._proxy.queryUniqueValues(this._cleanUpQuery(e6), r2, i3);
  }
  async queryClassBreaks(e6, t2, i3) {
    const r2 = { ...t2, scale: this.view.scale };
    return this._proxy.queryClassBreaks(this._cleanUpQuery(e6), r2, i3);
  }
  async queryHistogram(e6, t2, i3) {
    const r2 = { ...t2, scale: this.view.scale };
    return this._proxy.queryHistogram(this._cleanUpQuery(e6), r2, i3);
  }
  queryFeatures(e6, t2) {
    return this.queryFeaturesJSON(e6, t2).then((e7) => {
      const t3 = x2.fromJSON(e7);
      return t3.features.forEach((e8) => this._setLayersForFeature(e8)), t3;
    });
  }
  queryVisibleFeatures(e6, t2) {
    return this._proxy.queryVisibleFeatures(this._cleanUpQuery(e6), t2).then((e7) => {
      const t3 = x2.fromJSON(e7);
      return t3.features.forEach((e8) => this._setLayersForFeature(e8)), t3;
    });
  }
  queryFeaturesJSON(e6, t2) {
    return this._proxy.queryFeatures(this._cleanUpQuery(e6), t2);
  }
  queryObjectIds(e6, t2) {
    return this._proxy.queryObjectIds(this._cleanUpQuery(e6), t2);
  }
  queryFeatureCount(e6, t2) {
    return this._proxy.queryFeatureCount(this._cleanUpQuery(e6), t2);
  }
  queryExtent(e6, t2) {
    return this._proxy.queryExtent(this._cleanUpQuery(e6), t2).then((e7) => ({ count: e7.count, extent: M.fromJSON(e7.extent) }));
  }
  setVisibility(e6, t2) {
    t2 ? this._visibilityOverrides.delete(e6) : this._visibilityOverrides.add(e6), this._update();
  }
  update(e6) {
    if (!this._tileStrategy || !this.tileRenderer)
      return;
    const { hasMissingTiles: t2, added: i3, removed: r2 } = this._tileStrategy.update(e6);
    (i3.length || r2.length) && this._proxy.updateTiles({ added: i3, removed: r2 }), t2 && this.requestUpdate(), this.notifyChange("updating");
  }
  attach() {
    this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this._tileStrategy = new s4({ acquireTile: (e6) => this._acquireTile(e6), releaseTile: (e6) => this._releaseTile(e6), tileInfoView: this.view.featuresTilingScheme, buffer: 0 }), this.handles.add(l(() => this.renderingConfigHash, () => this._update(), h), "attach"), "stream" !== this.layer.type && this.handles.add(this.layer.on("edits", (e6) => this._edit(e6)), "attach");
  }
  detach() {
    var _a;
    this._commandsQueue.clear(), (_a = this._proxy) == null ? void 0 : _a.stop(), this.container.removeAllChildren(), this.handles.remove("attach"), this.tileRenderer && (this.tileRenderer.uninstall(this.container), this.tileRenderer = null), this._tileStrategy && (this._tileStrategy.destroy(), this._tileStrategy = null), this._tileRendererHash = null;
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  isUpdating() {
    var _a;
    const e6 = "renderer" in this.layer && null != this.layer.renderer, t2 = this._commandsQueue.updating, i3 = null != this._updatingRequiredFieldsPromise, r2 = !this._proxy || !this._proxy.isReady, s5 = this._pipelineIsUpdating, n4 = null == this.tileRenderer || ((_a = this.tileRenderer) == null ? void 0 : _a.updating), o3 = e6 && (t2 || i3 || r2 || s5 || n4);
    return a("esri-2d-log-updating") && console.log(`Updating FLV2D: ${o3}
  -> hasRenderer ${e6}
  -> hasPendingCommand ${t2}
  -> updatingRequiredFields ${i3}
  -> updatingProxy ${r2}
  -> updatingPipeline ${s5}
  -> updatingTileRenderer ${n4}
`), o3;
  }
  _createClientOptions() {
    return { setUpdating: (e6) => {
      this._set("_pipelineIsUpdating", e6);
    }, emitEvent: (e6) => {
      this.emit(e6.name, e6.event);
    } };
  }
  async _detectQueryMode(e6) {
    var _a;
    const t2 = "path" in e6, i3 = "editingInfo" in this.layer && ((_a = this.layer.editingInfo) == null ? void 0 : _a.lastEditDate), r2 = !!this.layer.refreshInterval, s5 = !i3 && r2;
    if (t2 && ("feature" === this.layer.type || "subtype-group" === this.layer.type) && "point" === this.layer.geometryType && this.layer.capabilities.query.supportsPagination && !this.layer.capabilities.operations.supportsEditing && !s5 && a("featurelayer-snapshot-enabled"))
      try {
        const e7 = await this.layer.queryFeatureCount();
        if (e7 <= a("featurelayer-snapshot-point-min-threshold"))
          return { mode: "snapshot", featureCount: e7 };
        const t3 = a("featurelayer-snapshot-point-max-threshold"), i4 = a("featurelayer-snapshot-point-coverage"), r3 = this.view.extent, s6 = e2(this.layer.fullExtent), n4 = s6 == null ? void 0 : s6.clone().intersection(r3), o3 = r(n4) ? n4.width * n4.height : 0, l7 = (s6 == null ? void 0 : s6.width) * (s6 == null ? void 0 : s6.height), d4 = 0 === l7 ? 0 : o3 / l7;
        if (e7 <= t3 && d4 >= i4)
          return { mode: "snapshot", featureCount: e7 };
      } catch (n4) {
        A2.warn("mapview-feature-layer", "Encountered an error when querying for featureCount", { error: n4 });
      }
    return { mode: "on-demand" };
  }
  async _createServiceOptions() {
    const e6 = this.layer;
    if ("stream" === e6.type)
      return null;
    const { capabilities: t2, objectIdField: i3 } = e6, r2 = e6.fields.map((e7) => e7.toJSON()), s5 = r(e6.fullExtent) && e6.fullExtent.toJSON(), a3 = e4(e6.geometryType), o3 = e6.timeInfo && e6.timeInfo.toJSON() || null, l7 = e6.spatialReference ? e6.spatialReference.toJSON() : null, u5 = "feature" === e6.type ? e6.globalIdField : null;
    let d4;
    "ogc-feature" === e6.type ? d4 = e6.source.getFeatureDefinition() : Q(e6.source) ? d4 = await e6.source.openPorts() : e6.parsedUrl && (d4 = m(e6.parsedUrl), "dynamicDataSource" in e6 && e6.dynamicDataSource && (d4.query = { layer: JSON.stringify({ source: e6.dynamicDataSource }) }));
    const p2 = "datesInUnknownTimezone" in this.layer && this.layer.datesInUnknownTimezone, y3 = ("subtypeField" in this.layer && this.layer.subtypeField) ?? null, { mode: c4, featureCount: f3 } = await this._detectQueryMode(d4);
    let g3 = this.layer.objectIdField;
    if ("feature" === this.layer.type && r(this.layer.orderBy) && this.layer.orderBy.length) {
      const e7 = !this.layer.orderBy[0].valueExpression && this.layer.orderBy[0].field;
      e7 && (g3 = e7);
    }
    return { type: c4, timeReferenceUnknownClient: p2, subtypeField: y3, featureCount: f3, globalIdField: u5, maxRecordCount: t2.query.maxRecordCount, tileMaxRecordCount: t2.query.tileMaxRecordCount, capabilities: t2, fields: r2, fullExtent: s5, geometryType: a3, objectIdField: i3, source: d4, timeInfo: o3, spatialReference: l7, orderByFields: g3 };
  }
  async _createMemoryServiceOptions(e6) {
    const t2 = await e6.openPorts();
    return { ...this._createServiceOptions(), type: "memory", source: t2 };
  }
  _cleanUpQuery(e6) {
    const t2 = b2.from(e6) || this.createQuery();
    return t2.outSpatialReference || (t2.outSpatialReference = this.view.spatialReference), t2;
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  async _edit(e6) {
    if (this.suspended)
      return void this._clearTiles();
    return this._validateEdit(e6) ? this._commandsQueue.push({ type: "edit", edits: e6 }) : void 0;
  }
  async doRefresh(e6) {
    if (this._tileStrategy.tileKeys().length)
      return this.suspended && e6 ? void this._clearTiles() : this._commandsQueue.push({ type: "refresh", dataChanged: e6 });
  }
  _clearTiles() {
    this._tileStrategy.tileKeys().length && (this._proxy.updateTiles({ added: [], removed: this._tileStrategy.tileKeys() }), this._tileStrategy.clear(), this.requestUpdate(), this._commandsQueue.clear(), this._update());
  }
  _validateEdit(e6) {
    const t2 = "globalIdField" in this.layer && this.layer.globalIdField, i3 = e6.deletedFeatures.some((e7) => -1 === e7.objectId || !e7.objectId), r2 = t2 && this.availableFields.includes(t2);
    return i3 && !r2 ? (A2.error(new s2("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${t2} to be included the layer's outFields for updates to be reflected on the map`)), null) : e6;
  }
  async _doUpdate() {
    try {
      if (this.destroyed || !this._hasRequiredSupport(this.layer) || !this._tileStrategy)
        return;
      const { featureEffectView: t2, filter: i3 } = this;
      await this._updateRequiredFields();
      const { renderer: r2 } = this._getEffectiveRenderer();
      this._set("_effectiveRenderer", r2);
      const s5 = this._createSchemaConfig(), a3 = this._createConfiguration(s5, i3, t2.filter), n4 = this._lastDefinitionExpression !== a3.schema.source.definitionExpression;
      this._lastDefinitionExpression = a3.schema.source.definitionExpression;
      const o3 = a3.schema.tileRenderer, l7 = this._createTileRendererHash(o3);
      if ("snapshot" === this._serviceOptions.type && (a3.schema.source.featureCount = this._serviceOptions.featureCount), l7 !== this._tileRendererHash) {
        await this._initTileRenderer(o3, r2);
        const e6 = this.layer, t3 = "stream" === e6.type ? await this._initServiceOptions() : this._serviceOptions;
        this.tileRenderer.onConfigUpdate(r2), "stream" !== e6.type && Q(e6.source) && (t3.source = await e6.source.openPorts());
        const i4 = { added: this._tileStrategy.tileKeys(), removed: [] };
        await this._proxy.startup(this.view.featuresTilingScheme, a3, t3, i4), this.hasHighlight() && await this._proxy.setHighlight(Array.from(this._highlightIds.keys())), await this._onceTilesUpdated(), this.tileRenderer.onConfigUpdate(r2);
      } else {
        "snapshot" === this._serviceOptions.type && n4 && (a3.schema.source.featureCount = await this.layer.queryFeatureCount());
        const t3 = await this._proxy.update(a3);
        (t3.mesh || t3.targets.aggregate) && this._lockGPUUploads();
        try {
          await this._proxy.applyUpdate(t3);
        } catch (e6) {
          g(e6) || A2.error(e6);
        }
        (t3.mesh || t3.targets.aggregate) && this._unlockGPUUploads(), this.tileRenderer.onConfigUpdate(r2), this._updateClusterSizeVariable(), this._forceAttributeTextureUpload();
      }
      this._tileRendererHash = l7, this.tileRenderer.invalidateLabels(), this.requestUpdate();
    } catch (e6) {
    }
  }
  async _doEdit(e6) {
    try {
      await this._proxy.onEdits(e6);
    } catch (t2) {
      g(t2), 0;
    }
  }
  async _doRefresh(e6) {
    var _a;
    this._lockGPUUploads();
    try {
      await this._proxy.refresh(e6);
    } catch (t2) {
      g(t2), 0;
    }
    this._unlockGPUUploads(), ((_a = this.layer) == null ? void 0 : _a.featureReduction) && this._updateClusterSizeVariable();
  }
  _updateClusterSizeVariable() {
    this._needsClusterSizeUpdate && (this.tileRenderer.onConfigUpdate(this._effectiveRenderer), this._needsClusterSizeUpdate = false);
  }
  _createUpdateClusterSizeTask(e6, t2) {
    return l(() => this._aggregateValueRanges, (i3) => {
      this._updateClusterEffectiveRendererSizeVariable(e6, t2, i3), this._needsClusterSizeUpdate = true, this._uploadsLocked || this._updateClusterSizeVariable();
    });
  }
  async _updateClusterEffectiveRendererSizeVariable(e6, t2, i3) {
    if (e6.dynamicClusterSize && "visualVariables" in e6 && e6.visualVariables) {
      const r2 = d2(e6.visualVariables);
      if (r(r2) && "cluster_count" === r2.field) {
        const s5 = e6.visualVariables.indexOf(r2);
        e6.visualVariables[s5] = f(t2, i3);
        const a3 = e6.clone();
        a3.dynamicClusterSize = true, this._set("_effectiveRenderer", a3);
      }
    }
  }
  _getEffectiveRenderer() {
    const e6 = "renderer" in this.layer && this.layer.renderer, t2 = this.layer.featureReduction;
    if (r(this._updateClusterSizeTask) && (this._updateClusterSizeTask.remove(), this._updateClusterSizeTask = null), t2 && "renderer" in t2 && t2.renderer) {
      const e7 = [];
      for (const i3 of t2.fields ?? [])
        x3(e7, i3);
      return { renderer: t2.renderer, aggregateFields: e7, featureReduction: t2 };
    }
    if (t2 && "cluster" === t2.type && m2(e6)) {
      const i3 = t2, r2 = [], s5 = c(r2, e6, i3, this._aggregateValueRanges);
      return o(this._updateClusterSizeTask, (e7) => e7.remove()), this._updateClusterSizeTask = this._createUpdateClusterSizeTask(s5, i3), { renderer: s5, aggregateFields: r2, featureReduction: t2 };
    }
    return { renderer: e6, aggregateFields: [], featureReduction: null };
  }
  _acquireTile(e6) {
    const t2 = this.tileRenderer.acquireTile(e6);
    return t2.once("attach", () => {
      this.requestUpdate();
    }), t2;
  }
  _releaseTile(e6) {
    this.tileRenderer.releaseTile(e6);
  }
  async _initTileRenderer(e6, t2) {
    const i3 = await e5(e6, { layerView: this, tileInfoView: this.view.featuresTilingScheme, layer: this.layer });
    return this.tileRenderer && (this._tileStrategy.clear(), this.tileRenderer.uninstall(this.container), this.tileRenderer.destroy(), this.tileRenderer = null), this.destroyed ? null : (this._proxy.tileRenderer = i3, this._set("tileRenderer", i3), this.tileRenderer.install(this.container), this.tileRenderer.onConfigUpdate(t2), this.requestUpdate(), this.tileRenderer);
  }
  _createTileRendererHash(e6) {
    return `${e6.type}`;
  }
  get hasFilter() {
    const e6 = !!("floorInfo" in this.layer && this.layer.floorInfo && this.view.floors && this.view.floors.length);
    return !!this.filter || e6 || !!this._visibilityOverrides.size || !!this.timeExtent;
  }
  _injectOverrides(e6) {
    const t2 = r(e6) ? e6.timeExtent : null, i3 = r(this.timeExtent) && r(t2) ? this.timeExtent.intersection(t2) : this.timeExtent || t2;
    let r2 = null;
    const s5 = "floorInfo" in this.layer && this.layer.floorInfo;
    if (s5) {
      const t3 = r(e6) && e6.where;
      r2 = this._addFloorFilterClause(t3);
    }
    if (!this._visibilityOverrides.size && !i3 && !s5)
      return r(e6) ? e6.toJSON() : null;
    (e6 = r(e6) && e6.clone() || new y2()).timeExtent = i3, r2 && (e6.where = r2);
    const a3 = e6.toJSON();
    return a3.hiddenIds = Array.from(this._visibilityOverrides), a3;
  }
  _addFloorFilterClause(e6) {
    var _a;
    const t2 = this.layer;
    let i3 = e6 || "";
    if ("floorInfo" in t2 && t2.floorInfo) {
      let e7 = this.view.floors;
      if (!e7 || !e7.length)
        return i3;
      ((_a = t2.floorInfo.viewAllLevelIds) == null ? void 0 : _a.length) && (e7 = t2.floorInfo.viewAllLevelIds);
      const r2 = e7.filter((e8) => "" !== e8).map((e8) => "'" + e8 + "'");
      r2.push("''");
      const s5 = t2.floorInfo.floorField;
      let a3 = "(" + s5 + " IN ({ids}) OR " + s5 + " IS NULL)";
      if (a3 = a3.replace("{ids}", r2.join(", ")), r(i3) && i3.includes(s5)) {
        let e8 = new RegExp("AND \\(" + s5 + ".*NULL\\)", "g");
        i3 = i3.replace(e8, ""), e8 = new RegExp("\\(" + s5 + ".*NULL\\)", "g"), i3 = i3.replace(e8, ""), i3 = i3.replace(/\s+/g, " ").trim();
      }
      i3 = "" !== i3 ? "(" + i3 + ") AND " + a3 : a3;
    }
    return "" !== i3 ? i3 : null;
  }
  _createConfiguration(e6, t2, i3) {
    const r2 = "feature" === this.layer.type && this.layer.historicMoment ? this.layer.historicMoment.getTime() : void 0, s5 = "feature" === this.layer.type ? this.layer.gdbVersion : void 0, a3 = new Array(S), n4 = this._injectOverrides(t2);
    a3[0] = n4, a3[1] = r(i3) ? i3.toJSON() : null;
    const o3 = z(e6);
    if (t(o3))
      return null;
    const l7 = l4("2d");
    return { availableFields: this.availableFields, gdbVersion: s5, historicMoment: r2, devicePixelRatio: window.devicePixelRatio || 1, filters: a3, schema: o3, supportsTextureFloat: l7.supportsTextureFloat, maxTextureSize: l7.maxTextureSize };
  }
  _hasRequiredSupport(e6) {
    return !("renderer" in e6) || v(e6.renderer);
  }
  _onceTilesUpdated() {
    return this.requestUpdate(), j3(() => !this._pipelineIsUpdating);
  }
  _lockGPUUploads() {
    this.tileRenderer && (this._uploadsLocked = true, this.tileRenderer.lockGPUUploads());
  }
  _unlockGPUUploads() {
    this.tileRenderer && (this._uploadsLocked = false, this.tileRenderer.unlockGPUUploads());
  }
  _forceAttributeTextureUpload() {
    this.tileRenderer && this.tileRenderer.forceAttributeTextureUpload();
  }
  _createSchemaConfig() {
    const e6 = "feature" === this.layer.type ? this.layer.historicMoment : null, t2 = "feature" === this.layer.type ? this.layer.gdbVersion : null;
    return { renderer: "renderer" in this.layer && this.layer.renderer, spatialReference: this.layer.spatialReference, timeExtent: this.layer.timeExtent, definitionExpression: this.layer.definitionExpression, featureReduction: this.layer.featureReduction, fields: this.layer.fields, geometryType: this.layer.geometryType, historicMoment: e6, labelsVisible: "labelsVisible" in this.layer && this.layer.labelsVisible, labelingInfo: "labelingInfo" in this.layer && this.layer.labelingInfo, availableFields: this.availableFields, featureEffect: this.featureEffect, filter: this.filter, gdbVersion: t2, pixelBuffer: 0, orderBy: "orderBy" in this.layer && this.layer.orderBy ? this.layer.orderBy : null, customParameters: { ..."customParameters" in this.layer ? this.layer.customParameters : void 0, token: "apiKey" in this.layer ? this.layer.apiKey : void 0 }, subtypeCode: "subtypeCode" in this.layer ? this.layer.subtypeCode : void 0, subtypeField: "subtypeField" in this.layer ? this.layer.subtypeField : void 0 };
  }
  _addHighlight(e6) {
    for (const t2 of e6)
      if (this._highlightIds.has(t2)) {
        const e7 = this._highlightIds.get(t2);
        this._highlightIds.set(t2, e7 + 1);
      } else
        this._highlightIds.set(t2, 1);
    this._updateHighlight().catch((e7) => {
      g(e7) || A2.error(e7);
    });
  }
  _removeHighlight(e6) {
    for (const t2 of e6)
      if (this._highlightIds.has(t2)) {
        const e7 = this._highlightIds.get(t2) - 1;
        0 === e7 ? this._highlightIds.delete(t2) : this._highlightIds.set(t2, e7);
      }
    this._updateHighlight().catch((e7) => {
      g(e7) || A2.error(e7);
    });
  }
  _setLayersForFeature(e6) {
    const t2 = this.layer;
    e6.layer = t2, e6.sourceLayer = t2;
  }
  _createGraphicHit(e6, t2) {
    return this._setLayersForFeature(t2), r(t2.geometry) && (t2.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t2, layer: this.layer, mapPoint: e6 };
  }
};
e([d()], M2.prototype, "_serviceOptions", void 0), e([d()], M2.prototype, "_proxy", void 0), e([d()], M2.prototype, "_pipelineIsUpdating", void 0), e([d()], M2.prototype, "_effectiveRenderer", void 0), e([d()], M2.prototype, "_aggregateValueRanges", void 0), e([d()], M2.prototype, "_commandsQueue", void 0), e([d()], M2.prototype, "featureEffectView", void 0), e([d()], M2.prototype, "labelsVisible", null), e([d({ readOnly: true })], M2.prototype, "queryMode", null), e([d()], M2.prototype, "renderingConfigHash", null), e([d()], M2.prototype, "tileRenderer", void 0), e([d()], M2.prototype, "updating", void 0), M2 = e([n("esri.views.2d.layers.FeatureLayerView2D")], M2);
var B = M2;

export {
  B
};
//# sourceMappingURL=chunk-SO2UREOW.js.map
