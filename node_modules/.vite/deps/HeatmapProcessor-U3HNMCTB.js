import {
  p
} from "./chunk-TSYXLDAN.js";
import {
  l as l2
} from "./chunk-AKQ6VRGN.js";
import {
  o as o2
} from "./chunk-HH3D3A65.js";
import "./chunk-FR7M4UDR.js";
import "./chunk-PQO66WZ2.js";
import "./chunk-QZTJM4HG.js";
import {
  m
} from "./chunk-EGR3VVZG.js";
import {
  l
} from "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-56RHM4A6.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  o,
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/2d/layers/features/processors/HeatmapProcessor.js
var p2 = class {
  constructor(e2, t) {
    this.offset = e2, this.extent = t;
  }
};
function c(e2) {
  const t = e2.key, s = /* @__PURE__ */ new Map(), r2 = 256, i = o2, o3 = e2.tileInfoView.tileInfo.isWrappable;
  return s.set(l2(t, -1, -1, o3).id, new p2([-i, -i], [i - r2, i - r2, i, i])), s.set(l2(t, 0, -1, o3).id, new p2([0, -i], [0, i - r2, i, i])), s.set(l2(t, 1, -1, o3).id, new p2([i, -i], [0, i - r2, r2, i])), s.set(l2(t, -1, 0, o3).id, new p2([-i, 0], [i - r2, 0, i, i])), s.set(l2(t, 1, 0, o3).id, new p2([i, 0], [0, 0, r2, i])), s.set(l2(t, -1, 1, o3).id, new p2([-i, i], [i - r2, 0, i, r2])), s.set(l2(t, 0, 1, o3).id, new p2([0, i], [0, 0, i, r2])), s.set(l2(t, 1, 1, o3).id, new p2([i, i], [0, 0, r2, r2])), s;
}
var l3 = class extends p {
  constructor() {
    super(...arguments), this.type = "heatmap", this._tileKeyToFeatureSets = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.handles.add([this.tileStore.on("update", this.onTileUpdate.bind(this))]);
  }
  async update(e2, t) {
    const s = t.schema.processors[0];
    if ("heatmap" !== s.type)
      return;
    m(this._schema, s) && (e2.mesh = true, this._schema = s);
  }
  onTileUpdate(e2) {
    for (const t of e2.removed)
      this._tileKeyToFeatureSets.delete(t.key.id);
  }
  onTileClear(e2) {
    const t = { clear: true };
    return this._tileKeyToFeatureSets.delete(e2.key.id), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: t });
  }
  async onTileMessage(e2, r2, i) {
    this._tileKeyToFeatureSets.has(e2.key.id) || this._tileKeyToFeatureSets.set(e2.key.id, /* @__PURE__ */ new Map());
    const a = this._tileKeyToFeatureSets.get(e2.key.id);
    if (r(r2.addOrUpdate) && r2.addOrUpdate.hasFeatures && a.set(r2.addOrUpdate.instance, r2), r2.end) {
      const t = [], r3 = c(e2);
      this._tileKeyToFeatureSets.forEach((i2, o3) => {
        if (o3 === e2.key.id)
          i2.forEach((e3) => o(e3.addOrUpdate, (e4) => t.push(e4)));
        else if (r3.has(o3)) {
          const e3 = r3.get(o3), [a3, n3] = e3.offset;
          i2.forEach((e4) => o(e4.addOrUpdate, (e5) => {
            const s = e5.transform(a3, n3, 1, 1);
            t.push(s);
          }));
        }
      });
      const a2 = l(t, this._schema.mesh, 512, 512), n2 = { tileKey: e2.key.id, intensityInfo: a2 }, d = [a2.matrix];
      return this.remoteClient.invoke("tileRenderer.onTileData", n2, { ...i, transferList: d });
    }
  }
  onTileError(e2, t, s) {
    return this.remoteClient.invoke("tileRenderer.onTileError", { tileKey: e2.id, error: t }, s);
  }
};
l3 = e([n("esri.views.2d.layers.features.processors.HeatmapProcessor")], l3);
var h = l3;
export {
  h as default
};
//# sourceMappingURL=HeatmapProcessor-U3HNMCTB.js.map
