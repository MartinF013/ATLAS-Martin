import {
  Ce
} from "./chunk-PZWU5EHT.js";
import {
  S
} from "./chunk-HR2OX32D.js";
import {
  z
} from "./chunk-RN2KRYDN.js";
import {
  u
} from "./chunk-56RHM4A6.js";
import {
  M as M2,
  p,
  x
} from "./chunk-BPZGJQOB.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  c,
  f
} from "./chunk-YPZEGNLG.js";
import {
  P,
  k2 as k,
  s as s2
} from "./chunk-3NMRL5CR.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  e,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/terrain/TilingScheme.js
var v = 12;
var M3 = class {
  constructor(e2) {
    const i = M3.checkUnsupported(e2);
    if (r(i))
      throw i;
    const t2 = e(e2);
    this.spatialReference = t2.spatialReference, this._isWebMercator = this.spatialReference.isWebMercator, this._isGCS = Ce(this.spatialReference) || P(this.spatialReference) || s2(this.spatialReference), this.origin = [t2.origin.x, t2.origin.y], this.pixelSize = t2.size[0], this.dpi = t2.dpi;
    const s3 = t2.lods.reduce((e3, i2, t3) => (i2.level < e3.min && (e3.min = i2.level, e3.minIndex = t3), e3.max = Math.max(e3.max, i2.level), e3), { min: 1 / 0, minIndex: 0, max: -1 / 0 }), l = t2.lods[s3.minIndex], o = 2 ** l.level;
    let a = l.resolution * o, c2 = l.scale * o;
    this.levels = new Array(s3.max + 1);
    for (let r2 = 0; r2 < this.levels.length; r2++)
      this.levels[r2] = { resolution: a, scale: c2, tileSize: [a * t2.size[0], a * t2.size[1]] }, a /= 2, c2 /= 2;
  }
  clone() {
    return new M3(this.toTileInfo());
  }
  toTileInfo() {
    return new S({ dpi: this.dpi, origin: { x: this.origin[0], y: this.origin[1], spatialReference: this.spatialReference }, size: [this.pixelSize, this.pixelSize], spatialReference: this.spatialReference, lods: this.levels.map((e2, i) => ({ level: i, scale: e2.scale, resolution: e2.resolution })) });
  }
  getExtent(e2, i, t2, s3) {
    const r2 = this.levels[e2], l = r2.tileSize[0], n = r2.tileSize[1];
    s3[0] = this.origin[0] + t2 * l, s3[2] = this.origin[0] + (t2 + 1) * l, s3[3] = this.origin[1] - i * n, s3[1] = this.origin[1] - (i + 1) * n;
  }
  convertExtentToRadians(e2, t2) {
    this._isWebMercator ? (t2[0] = f(e2[0]), t2[1] = c(e2[1]), t2[2] = f(e2[2]), t2[3] = c(e2[3])) : this._isGCS && (t2[0] = M2(e2[0]), t2[1] = M2(e2[1]), t2[2] = M2(e2[2]), t2[3] = M2(e2[3]));
  }
  getExtentGeometry(e2, i, t2, s3 = new M()) {
    return this.getExtent(e2, i, t2, w), s3.spatialReference = this.spatialReference, s3.xmin = w[0], s3.ymin = w[1], s3.xmax = w[2], s3.ymax = w[3], s3.zmin = void 0, s3.zmax = void 0, s3;
  }
  ensureMaxLod(e2) {
    if (null == e2)
      return false;
    let i = false;
    for (; this.levels.length <= e2; ) {
      const e3 = this.levels[this.levels.length - 1], t2 = e3.resolution / 2;
      this.levels.push({ resolution: t2, scale: e3.scale / 2, tileSize: [t2 * this.pixelSize, t2 * this.pixelSize] }), i = true;
    }
    return i;
  }
  capMaxLod(e2) {
    this.levels.length > e2 + 1 && (this.levels.length = e2 + 1);
  }
  getMaxLod() {
    return this.levels.length - 1;
  }
  scaleAtLevel(e2) {
    return this.levels[0].scale / 2 ** e2;
  }
  levelAtScale(e2) {
    const i = this.levels[0].scale;
    return e2 >= i ? 0 : Math.log(i / e2) * Math.LOG2E;
  }
  resolutionAtLevel(e2) {
    return this.levels[0].resolution / 2 ** e2;
  }
  compatibleWith(e2) {
    if (!(e2 instanceof M3)) {
      if (M3.checkUnsupported(e2))
        return false;
      e2 = new M3(e2);
    }
    if (!e2.spatialReference.equals(this.spatialReference))
      return false;
    if (e2.pixelSize !== this.pixelSize)
      return false;
    const i = Math.min(this.levels.length, e2.levels.length) - 1, s3 = this.levels[i].resolution;
    let r2 = 0.5 * s3;
    if (!p(e2.origin[0], this.origin[0], r2) || !p(e2.origin[1], this.origin[1], r2))
      return false;
    return r2 = 0.5 * s3 / 2 ** i / this.pixelSize * v, p(s3, e2.levels[i].resolution, r2);
  }
  rootTilesInExtent(e2, i = null, t2 = 1 / 0) {
    const s3 = new Array(), n = this.levels[0].tileSize;
    if (t(e2) || 0 === n[0] || 0 === n[1])
      return s3;
    M3.computeRowColExtent(e2, n, this.origin, w);
    let o = w[1], a = w[3], h = w[0], c2 = w[2];
    const m = c2 - h, u2 = a - o;
    if (m * u2 > t2) {
      const e3 = Math.floor(Math.sqrt(t2));
      u2 > e3 && (o = o + Math.floor(0.5 * u2) - Math.floor(0.5 * e3), a = o + e3), m > e3 && (h = h + Math.floor(0.5 * m) - Math.floor(0.5 * e3), c2 = h + e3);
    }
    for (let r2 = o; r2 < a; r2++)
      for (let e3 = h; e3 < c2; e3++)
        s3.push([0, r2, e3]);
    return r(i) && (i[0] = this.origin[0] + h * n[0], i[1] = this.origin[1] - a * n[1], i[2] = this.origin[0] + c2 * n[0], i[3] = this.origin[1] - o * n[1]), s3;
  }
  static computeRowColExtent(e2, i, t2, s3) {
    const r2 = 1e-3 * (e2[2] - e2[0] + (e2[3] - e2[1]));
    s3[0] = Math.max(0, Math.floor((e2[0] + r2 - t2[0]) / i[0])), s3[2] = Math.max(0, Math.ceil((e2[2] - r2 - t2[0]) / i[0])), s3[1] = Math.max(0, Math.floor((t2[1] - e2[3] + r2) / i[1])), s3[3] = Math.max(0, Math.ceil((t2[1] - e2[1] - r2) / i[1]));
  }
  static isPowerOfTwo(e2) {
    const i = e2.lods, t2 = i[0].resolution * 2 ** i[0].level;
    return !i.some((e3) => !x(e3.resolution, t2 / 2 ** e3.level));
  }
  static hasGapInLevels(e2) {
    const i = e2.lods.map((e3) => e3.level);
    i.sort((e3, i2) => e3 - i2);
    for (let t2 = 1; t2 < i.length; t2++)
      if (i[t2] !== i[0] + t2)
        return true;
    return false;
  }
  static tileSizeSupported(e2) {
    const i = e2.size[1];
    return i === e2.size[0] && 0 == (i & i - 1) && i >= 128 && i <= 512;
  }
  static hasOriginPerLODs(e2) {
    const i = e2.origin;
    return e2.lods.some((e3) => null != e3.origin && (e3.origin[0] !== i.x || e3.origin[1] !== i.y));
  }
  static getMissingTileInfoError() {
    return new s("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
  }
  static checkUnsupported(i) {
    return t(i) ? d() : i.lods.length < 1 ? new s("tilingscheme:generic", "Tiling scheme must have at least one level") : M3.isPowerOfTwo(i) ? M3.hasGapInLevels(i) ? new s("tilingscheme:gaps", "Tiling scheme levels must not have gaps between min and max level") : M3.tileSizeSupported(i) ? M3.hasOriginPerLODs(i) ? new s("tilingscheme:multiple-origin", "Tiling scheme levels must not have their own origin") : null : new s("tilingscheme:tile-size", "Tiles must be square and size must be one of [128, 256, 512]") : new s("tilingscheme:power-of-two", "Tiling scheme must be power of two");
  }
  static fromExtent(e2, i) {
    const t2 = e2[2] - e2[0], s3 = e2[3] - e2[1], r2 = z(i), l = 1.2 * Math.max(t2, s3), n = 256, a = 96, h = 0.0254, c2 = new M3(new S({ size: [n, n], origin: { x: e2[0] - 0.5 * (l - t2), y: e2[3] + 0.5 * (l - s3) }, lods: [{ level: 0, resolution: l / n, scale: 1 / (n / a * h / (l * r2)) }], spatialReference: i }));
    return c2.ensureMaxLod(20), c2;
  }
  static makeWebMercatorAuxiliarySphere(e2) {
    const i = new M3(M3.WebMercatorAuxiliarySphereTileInfo);
    return i.ensureMaxLod(e2), i;
  }
  static makeGCSWithTileSize(e2, i = 256, t2 = 16) {
    const s3 = 256 / i, r2 = new M3(new S({ size: [i, i], origin: { x: -180, y: 90, spatialReference: e2 }, spatialReference: e2, lods: [{ level: 0, resolution: 0.703125 * s3, scale: 295497598570834e-6 * s3 }] }));
    return r2.ensureMaxLod(t2), r2;
  }
  get test() {
    return { isWebMercator: this._isWebMercator, isGCS: this._isGCS };
  }
};
function d() {
  return new s("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
}
M3.WebMercatorAuxiliarySphereTileInfo = new S({ size: [256, 256], origin: { x: -20037508342787e-6, y: 20037508342787e-6, spatialReference: k.WebMercator }, spatialReference: k.WebMercator, lods: [{ level: 0, resolution: 156543.03392800014, scale: 591657527591555e-6 }] }), M3.WebMercatorAuxiliarySphere = M3.makeWebMercatorAuxiliarySphere(19);
var w = u();

export {
  M3 as M,
  d
};
//# sourceMappingURL=chunk-EJ4V43KX.js.map
