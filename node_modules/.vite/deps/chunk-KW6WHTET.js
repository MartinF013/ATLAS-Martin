import {
  f
} from "./chunk-HPO2NV7P.js";
import {
  n,
  r as r2
} from "./chunk-WKRVG5MO.js";
import {
  a
} from "./chunk-D7DLEBS2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  c,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/featureExpressionInfoUtils.js
var n2 = s.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");
function c2(e) {
  return { cachedResult: e.cachedResult, arcade: e.arcade ? { func: e.arcade.func, context: e.arcade.modules.arcadeUtils.createExecContext(null, { sr: e.arcade.context.spatialReference }), modules: e.arcade.modules } : null };
}
function o(e) {
  const t2 = e && e.expression;
  if ("string" == typeof t2) {
    const e2 = p(t2);
    if (null != e2)
      return { cachedResult: e2 };
  }
  return null;
}
async function a2(e, t2, n3) {
  const c3 = e && e.expression;
  if ("string" != typeof c3)
    return null;
  const o2 = p(c3);
  if (null != o2)
    return { cachedResult: o2 };
  const a3 = await a(), u2 = a3.arcadeUtils, s3 = u2.createSyntaxTree(c3);
  return u2.dependsOnView(s3) ? (null != n3 && n3.error("Expressions containing '$view' are not supported on ElevationInfo"), { cachedResult: 0 }) : { arcade: { func: u2.createFunction(s3), context: u2.createExecContext(null, { sr: t2 }), modules: a3 } };
}
function u(e, t2, r3) {
  return e.arcadeUtils.createFeature(t2.attributes, t2.geometry, r3);
}
function s2(e, r3) {
  if (null != e && !f2(e)) {
    if (!r3 || !e.arcade)
      return void n2.errorOncePerTick("Arcade support required but not provided");
    const c3 = r3;
    c3._geometry && (c3._geometry = f(c3._geometry)), e.arcade.modules.arcadeUtils.updateExecContext(e.arcade.context, r3);
  }
}
function l(e) {
  if (null != e) {
    if (f2(e))
      return e.cachedResult;
    const t2 = e.arcade;
    let r3 = e.arcade.modules.arcadeUtils.executeFunction(t2.func, t2.context);
    return "number" != typeof r3 && (e.cachedResult = 0, r3 = 0), r3;
  }
  return 0;
}
function i(e, t2 = false) {
  let r3 = e && e.featureExpressionInfo;
  const n3 = r3 && r3.expression;
  return t2 || "0" === n3 || (r3 = null), r3;
}
var d = { cachedResult: 0 };
function f2(e) {
  return null != e.cachedResult;
}
function p(e) {
  return "0" === e ? 0 : null;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationContext.js
var h = class {
  constructor() {
    this._meterUnitOffset = 0, this._renderUnitOffset = 0, this._unit = "meters", this._metersPerElevationInfoUnit = 1, this._featureExpressionInfoContext = null, this.centerPointInElevationSR = null, this.mode = null;
  }
  get featureExpressionInfoContext() {
    return this._featureExpressionInfoContext;
  }
  get meterUnitOffset() {
    return this._meterUnitOffset;
  }
  get unit() {
    return this._unit;
  }
  set unit(t2) {
    this._unit = t2, this._metersPerElevationInfoUnit = r2(t2);
  }
  get requiresSampledElevationInfo() {
    return "absolute-height" !== this.mode;
  }
  reset() {
    this.mode = null, this._meterUnitOffset = 0, this._renderUnitOffset = 0, this._featureExpressionInfoContext = null, this.unit = "meters";
  }
  set offsetMeters(t2) {
    this._meterUnitOffset = t2, this._renderUnitOffset = 0;
  }
  set offsetElevationInfoUnits(t2) {
    this._meterUnitOffset = t2 * this._metersPerElevationInfoUnit, this._renderUnitOffset = 0;
  }
  addOffsetRenderUnits(t2) {
    this._renderUnitOffset += t2;
  }
  geometryZWithOffset(t2, e) {
    const n3 = this.calculateOffsetRenderUnits(e);
    return null != this.featureExpressionInfoContext ? n3 : t2 + n3;
  }
  calculateOffsetRenderUnits(t2) {
    let e = this._meterUnitOffset;
    const n3 = this.featureExpressionInfoContext;
    return null != n3 && (e += l(n3) * this._metersPerElevationInfoUnit), e / t2.unitInMeters + this._renderUnitOffset;
  }
  setFromElevationInfo(e) {
    this.mode = e.mode, this.unit = n(e.unit) ? e.unit : "meters", this.offsetElevationInfoUnits = c(e.offset, 0);
  }
  updateFeatureExpressionInfoContext(t2, s3, i2) {
    if (t(t2))
      return void (this._featureExpressionInfoContext = null);
    const r3 = t2 && t2.arcade;
    r3 && r(s3) && r(i2) ? (this._featureExpressionInfoContext = c2(t2), s2(this._featureExpressionInfoContext, u(r3.modules, s3, i2))) : this._featureExpressionInfoContext = t2;
  }
  static fromElevationInfo(t2) {
    const e = new h();
    return r(t2) && e.setFromElevationInfo(t2), e;
  }
};

export {
  o,
  a2 as a,
  u,
  s2 as s,
  i,
  d,
  h
};
//# sourceMappingURL=chunk-KW6WHTET.js.map
