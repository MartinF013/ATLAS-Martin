import {
  L
} from "./chunk-536JSWCC.js";
import {
  Y
} from "./chunk-COK4R22F.js";
import {
  e as e3
} from "./chunk-2I27THZD.js";
import {
  m
} from "./chunk-X64NQ2GK.js";
import {
  Me,
  ce,
  le
} from "./chunk-RHH23PAT.js";
import {
  t as t2
} from "./chunk-OZT6RDST.js";
import {
  Bn,
  bn,
  rn,
  tn
} from "./chunk-PZWU5EHT.js";
import {
  y as y3
} from "./chunk-OMNBM2E4.js";
import {
  x as x2
} from "./chunk-4XBERLPX.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import {
  n as n3
} from "./chunk-U7B2WKBH.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  j
} from "./chunk-T7BEWVV3.js";
import {
  Z
} from "./chunk-RN2KRYDN.js";
import {
  G,
  a
} from "./chunk-TMBOFNWA.js";
import {
  E,
  h,
  o as o3,
  u as u3,
  x
} from "./chunk-56RHM4A6.js";
import {
  n as n2
} from "./chunk-OIPX3EDD.js";
import {
  o as o2
} from "./chunk-BPZGJQOB.js";
import {
  O,
  o,
  u
} from "./chunk-PKZEO23A.js";
import {
  M as M2
} from "./chunk-Q72YFZUL.js";
import {
  M
} from "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  s as s3
} from "./chunk-SN4RUQ4N.js";
import {
  d,
  n8 as n,
  y3 as y2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  e as e2,
  r,
  t,
  v2 as v,
  y2 as y
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SMeshViewFilter.js
var D = s.getLogger("esri.views.3d.layers.i3s.I3SMeshViewFilter");
var C = class extends y2 {
  constructor(e4) {
    super(e4), this._projectionEngineLoaded = false;
  }
  initialize() {
    j(() => {
      var _a;
      return ((_a = e2(this.viewFilter)) == null ? void 0 : _a.geometry) || r(this.layerFilter);
    }).then(() => this.loadAsyncModule(import("./@arcgis_core_geometry_geometryEngine.js").then((e4) => {
      this.destroyed || (this._geometryEngine = e4, this.applyFilters());
    })));
  }
  get sortedObjectIds() {
    if (t(this.viewFilter) || t(this.viewFilter.objectIds))
      return null;
    const e4 = new Float64Array(this.viewFilter.objectIds);
    return e4.sort(), e4;
  }
  get parsedWhereClause() {
    const e4 = r(this.viewFilter) ? this.viewFilter.where : null;
    if (t(e4) || !e4)
      return null;
    try {
      return m.create(e4, this.layerFieldsIndex);
    } catch (t3) {
      D.error(`Failed to parse filter where clause: ${t3}`);
    }
    return null;
  }
  addFilters(e4, t3, r2, i) {
    const s5 = this.sortedObjectIds;
    r(s5) && e4.push((e5) => le(s5, true, e5)), this.addSqlFilter(e4, this.parsedWhereClause);
    const o4 = this._layerMaskGeometries, n5 = this._geometryEngine;
    if (r(o4) && r(this.layerFilter) && r(n5)) {
      const s6 = this.layerFilter.spatialRelationship;
      e4.push((e5, a2) => L2(n5, e5, a2, i, t3, r2, o4, s6));
    }
    const l3 = this._viewMaskGeometries;
    if (r(l3) && r(this.viewFilter) && r(n5)) {
      const s6 = this.viewFilter.spatialRelationship;
      e4.push((e5, o5) => L2(n5, e5, o5, i, t3, r2, l3, s6));
    }
  }
  isMBSGeometryVisible(e4, t3, r2) {
    const i = this._layerMaskGeometries, s5 = this._geometryEngine;
    if (r(i) && r(this.layerFilter) && r(s5)) {
      const o5 = this.layerFilter.spatialRelationship, n5 = i[0].spatialReference || t3;
      if (!bn(e4, r2, W, n5))
        return D.warnOnce("SceneLayer.mask geometry is using unsupported SpatialReference, skipping geometry filter for MBS"), true;
      return B(s5, W, i, n5, o5);
    }
    const o4 = this._viewMaskGeometries;
    if (r(o4) && r(this.viewFilter) && r(s5)) {
      const i2 = this.viewFilter.spatialRelationship, n5 = o4[0].spatialReference || t3;
      if (!bn(e4, r2, W, n5))
        return D.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter for MBS"), true;
      return B(s5, W, o4, n5, i2);
    }
    return true;
  }
  get parsedGeometry() {
    const e4 = this._viewMaskGeometries, t3 = this._layerMaskGeometries;
    return t(e4) || t(t3) ? e4 || t3 : t3.concat(e4);
  }
  get _layerMaskGeometries() {
    const e4 = this.layerFilter;
    return t(e4) || t(this._geometryEngine) ? null : O2(this._geometryEngine, e4.geometry, e4.spatialRelationship);
  }
  get _viewMaskGeometries() {
    if (t(this.viewFilter) || t(this._geometryEngine))
      return null;
    const { geometry: e4 } = this.viewFilter;
    if (t(e4))
      return null;
    const { distance: t3, units: r2 } = this.viewFilter, i = this.viewFilter.spatialRelationship, s5 = "mesh" === e4.type ? e4.extent : e4;
    if (t(t3) || 0 === t3)
      return O2(this._geometryEngine, s5, i);
    const o4 = r2 || Z(s5.spatialReference);
    if (s5.spatialReference.isWGS84) {
      const e5 = this._geometryEngine.geodesicBuffer(s5, t3, o4);
      return O2(this._geometryEngine, e5, i);
    }
    const l3 = M(s5, k.WGS84);
    if (r(l3)) {
      const e5 = M(this._geometryEngine.geodesicBuffer(l3, t3, o4), s5.spatialReference);
      return O2(this._geometryEngine, e5, i);
    }
    if (!this._projectionEngineLoaded && (this.loadAsyncModule(tn().then(() => this._projectionEngineLoaded = true)), !this._projectionEngineLoaded))
      return null;
    let c = null;
    try {
      c = rn(s5, k.WGS84);
    } catch (u4) {
    }
    if (c)
      try {
        c = rn(this._geometryEngine.geodesicBuffer(c, t3, o4), s5.spatialReference);
      } catch (u4) {
        c = null;
      }
    return c || D.error(`Filter by geodesic buffer (distance) unsupported, failed to project input geometry (${s5.spatialReference.wkid}) to WGS84.`), O2(this._geometryEngine, c, i);
  }
  static checkSupport(e4) {
    return !t(e4) && (e4.timeExtent ? (D.warn("Filters with a timeExtent are not supported for mesh scene layers"), false) : !!A(e4.spatialRelationship) || (D.warn(`Filters with spatialRelationship other than ${G2.join(", ")} are not supported for mesh scene layers`), false));
  }
};
e([d()], C.prototype, "layerFilter", void 0), e([d({ type: y3 })], C.prototype, "viewFilter", void 0), e([d()], C.prototype, "layerFieldsIndex", void 0), e([d()], C.prototype, "loadAsyncModule", void 0), e([d()], C.prototype, "applyFilters", void 0), e([d()], C.prototype, "addSqlFilter", void 0), e([d({ readOnly: true })], C.prototype, "sortedObjectIds", null), e([d({ readOnly: true })], C.prototype, "parsedWhereClause", null), e([d({ readOnly: true })], C.prototype, "parsedGeometry", null), e([d({ readOnly: true })], C.prototype, "_layerMaskGeometries", null), e([d({ readOnly: true })], C.prototype, "_viewMaskGeometries", null), e([d()], C.prototype, "_projectionEngineLoaded", void 0), e([d()], C.prototype, "_geometryEngine", void 0), C = e([n("esri.views.3d.layers.i3s.I3SMeshViewFilter")], C);
var G2 = ((e4) => e4)(["contains", "intersects", "disjoint"]);
function A(e4) {
  return null != e4 && G2.includes(e4);
}
var x3;
function O2(e4, t3, s5) {
  if (t(t3))
    return null;
  if ("disjoint" === s5 && "polygon" === t3.type) {
    const s6 = new Array(t3.rings.length);
    for (let e5 = 0; e5 < t3.rings.length; ++e5) {
      const r2 = o3(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      x(r2, t3.rings[e5]), s6[e5] = { type: "polygon", rings: [t3.rings[e5]], spatialReference: t3.spatialReference, aabr: r2 };
    }
    s6.sort((e5, t4) => e5.aabr[0] - t4.aabr[0]);
    const o4 = /* @__PURE__ */ new Set(), n5 = new y();
    for (let t4 = 0; t4 < s6.length; ++t4) {
      const r2 = s6[t4];
      for (let e5 = t4 + 1; e5 < s6.length; ++e5) {
        const t5 = s6[e5];
        if (t5.aabr[0] >= r2.aabr[2])
          break;
        o4.add(t5);
      }
      o4.forEach((t5) => {
        if (r2 !== t5) {
          if (t5.aabr[2] <= r2.aabr[0])
            o4.delete(t5);
          else if (e4.intersects(r2, t5)) {
            r2.rings = r2.rings.concat(t5.rings), h(r2.aabr, t5.aabr, r2.aabr), delete r2._geVersion, o4.delete(t5);
            const e5 = v(s6, t5, s6.length, n5);
            s6.splice(e5, 1);
          }
        }
      }), o4.add(r2);
    }
    for (const e5 of s6)
      delete e5.aabr;
    return s6;
  }
  return [t3];
}
function B(e4, t3, r2, i, s5) {
  const o4 = K(e4, t3, i);
  return r2.every((t4) => V(e4, t4, o4, s5) !== x3.DISCARD);
}
function L2(e4, t3, r2, i, s5, o4, n5, a2) {
  const l3 = n5[0].spatialReference || s5.spatialReference;
  if (!bn(r2.node.mbs, o4, W, l3))
    return void D.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter");
  const c = K(e4, W, l3), p2 = P(a2, s5, l3, i, r2.objectHandle);
  for (const u4 of n5) {
    if (0 === t3.length)
      return;
    switch (V(e4, u4, c, a2)) {
      case x3.DISCARD:
        return void (t3.length = 0);
      case x3.KEEP:
        continue;
    }
    ce(t3, r2.featureIds, (t4) => Z2(e4, u4, t4, p2));
  }
}
!function(e4) {
  e4[e4.KEEP = 0] = "KEEP", e4[e4.DISCARD = 1] = "DISCARD", e4[e4.TEST = 2] = "TEST";
}(x3 || (x3 = {}));
var W = [0, 0, 0, 0];
function P(e4, t3, r2, i, s5) {
  const o4 = t3.renderSpatialReference, n5 = /* @__PURE__ */ new Map(), a2 = { rings: [[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]], hasZ: false, hasM: false, type: "polygon", spatialReference: r2 };
  a2.rings[0][3] = a2.rings[0][0];
  const l3 = { indices: null, data: null, stride: 0, startIndex: 0, endIndex: 0 };
  let c, p2;
  switch (e4) {
    case "intersects":
      c = (e5, t4, r3) => e5.intersects(t4, r3) ? x3.KEEP : x3.TEST, p2 = U;
      break;
    case "contains":
      c = (e5, t4, r3) => e5.contains(t4, r3) ? x3.TEST : x3.DISCARD, p2 = U;
      break;
    default:
      c = (e5, t4, r3) => e5.disjoint(t4, r3) ? x3.TEST : x3.DISCARD, p2 = q;
  }
  return { collection: i, object: s5, type: e4, maskSR: r2, renderSR: o4, aabbCache: n5, triangle: a2, positions: l3, triangleTest: c, geometryTest: p2 };
}
function K(e4, t3, r2) {
  const i = { x: t3[0], y: t3[1], hasZ: false, hasM: false, type: "point", spatialReference: r2 }, s5 = !r2.isWGS84 && !r2.isWebMercator, n5 = Number.isNaN(t3[3]) ? 0 : o2(t3[3], 0, 2 * s3.radius), a2 = s5 ? e4.buffer(i, n5, 1) : e4.geodesicBuffer(i, n5, 1);
  return a2.type = "polygon", a2;
}
function V(e4, t3, r2, i) {
  switch (i) {
    case "intersects":
    case "contains":
      return U(e4, t3, r2);
    case "disjoint":
      return q(e4, t3, r2);
  }
}
function U(e4, t3, r2) {
  return e4.intersects(t3, r2) ? e4.contains(t3, r2) ? x3.KEEP : x3.TEST : x3.DISCARD;
}
function q(e4, t3, r2) {
  return e4.intersects(t3, r2) ? e4.contains(t3, r2) ? x3.DISCARD : x3.TEST : x3.KEEP;
}
var N = 2 ** -32;
function Z2(e4, t3, r2, i) {
  const { collection: s5, object: o4, renderSR: n5, maskSR: a2, geometryTest: l3, aabbCache: c } = i;
  let p2 = c.get(r2);
  if (!p2) {
    const e5 = s5.getObjectTransform(o4);
    s5.getComponentAabb(o4, r2, $);
    const t4 = [[$[0], $[1], 0], [$[0], $[4], 0], [$[3], $[4], 0], [$[3], $[1], 0]];
    for (let r3 = 0; r3 < 4; ++r3)
      O(t4[r3], t4[r3], e5.rotationScale), u(t4[r3], t4[r3], e5.position), Bn(t4[r3], n5, t4[r3], a2);
    p2 = { rings: [t4], hasZ: false, hasM: false, type: "polygon", spatialReference: a2 }, p2.rings[0][4] = p2.rings[0][0], c.set(r2, p2);
  }
  switch (l3(e4, t3, p2)) {
    case x3.DISCARD:
      return false;
    case x3.KEEP:
      return true;
  }
  const { triangle: u4, triangleTest: g, positions: h3 } = i, m2 = u4.rings[0][0], S = u4.rings[0][1], j2 = u4.rings[0][2], E2 = s5.getObjectTransform(o4);
  s5.getComponentPositions(o4, r2, h3);
  const { indices: b2, data: R, stride: F, startIndex: v2, endIndex: _ } = h3;
  for (let I = v2; I < _; I += 3) {
    const r3 = F * b2[I + 0], i2 = F * b2[I + 1], s6 = F * b2[I + 2];
    o(m2, R[r3 + 0], R[r3 + 1], R[r3 + 2]), o(S, R[i2 + 0], R[i2 + 1], R[i2 + 2]), o(j2, R[s6 + 0], R[s6 + 1], R[s6 + 2]), O(m2, m2, E2.rotationScale), O(S, S, E2.rotationScale), O(j2, j2, E2.rotationScale), u(m2, m2, E2.position), u(S, S, E2.position), u(j2, j2, E2.position), Bn(m2, n5, m2, a2), Bn(S, n5, S, a2), Bn(j2, n5, j2, a2);
    const o5 = S[0] - m2[0], l4 = S[1] - m2[1], c2 = j2[0] - m2[0], p3 = j2[1] - m2[1];
    if (!(Math.abs(o5 * p3 - l4 * c2) < N))
      switch (delete u4._geVersion, g(e4, t3, u4)) {
        case x3.DISCARD:
          return false;
        case x3.KEEP:
          return true;
      }
  }
  return "intersects" !== i.type;
}
var $ = a();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SQueryEngine.js
var l = Y;
var p = class extends y2 {
  constructor(e4) {
    super(e4), this._dataQueryEngineInstance = null, this._handles = new u2();
  }
  get defaultQueryJSON() {
    return new b({ outSpatialReference: this.spatialReference }).toJSON();
  }
  get dataQueryEngine() {
    return this._ensureDataQueryEngine();
  }
  initialize() {
    this._handles.add(this.layerView.on("visible-geometry-changed", () => this.spatialIndex.events.emit("changed")));
  }
  destroy() {
    this._dataQueryEngineInstance && (this._dataQueryEngineInstance.destroy(), this._dataQueryEngineInstance = null), this._handles && (this._handles.destroy(), this._handles = null), this._set("layerView", null);
  }
  async executeQueryForCount(e4, r2) {
    return this.dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e4), r2);
  }
  async executeQueryForExtent(e4, r2) {
    const { count: t3, extent: s5 } = await this.dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e4), r2);
    return { count: t3, extent: M2.fromJSON(s5) };
  }
  async executeQueryForIds(e4, r2) {
    return this.dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e4), r2);
  }
  async executeQuery(e4, r2) {
    const s5 = this._ensureQueryJSON(e4);
    if (s5.returnGeometry)
      throw new s2("feature-store:unsupported-query", "returnGeometry is not yet supported for mesh scene layer queries");
    if (s5.returnCentroid)
      throw new s2("feature-store:unsupported-query", "returnCentroid is not yet supported for mesh scene layer queries");
    const n5 = await this.dataQueryEngine.executeQuery(s5, r2), o4 = x2.fromJSON(n5);
    return o4.features.forEach((e5) => {
      e5.geometry = null;
    }), o4;
  }
  _ensureQueryJSON(e4) {
    return t(e4) ? this.defaultQueryJSON : e4.toJSON();
  }
  _ensureDataQueryEngine() {
    if (this._dataQueryEngineInstance)
      return this._dataQueryEngineInstance;
    const e4 = this.layer.objectIdField || "OBJECTID", r2 = "esriGeometryPolygon", t3 = this.layer.fields.map((e5) => e5.toJSON()), s5 = this.layerView.view.resourceController.scheduler, n5 = this.spatialReference.toJSON(), o4 = this.priority, i = this.spatialIndex;
    return this._dataQueryEngineInstance = new l({ hasZ: true, hasM: false, geometryType: r2, fields: t3, timeInfo: null, spatialReference: n5, objectIdField: e4, featureStore: i, scheduler: s5, priority: o4 }), this._dataQueryEngineInstance;
  }
};
e([d({ constructOnly: true })], p.prototype, "layerView", void 0), e([d({ constructOnly: true })], p.prototype, "priority", void 0), e([d({ constructOnly: true })], p.prototype, "spatialIndex", void 0), e([d({ readOnly: true, aliasOf: "layerView.view.spatialReference" })], p.prototype, "spatialReference", void 0), e([d({ readOnly: true, aliasOf: "layerView.i3slayer" })], p.prototype, "layer", void 0), e([d({ readOnly: true })], p.prototype, "defaultQueryJSON", null), p = e([n("esri.views.3d.layers.i3s.I3SQueryEngine")], p);

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SQueryFeatureAdapter.js
var n4 = class {
  constructor(t3) {
    this.objectIdField = t3.objectIdField, this.getFeatureExtent = t3.getFeatureExtent;
  }
  getObjectId(t3) {
    return t3.id;
  }
  getAttributes(e4) {
    const { meta: r2, index: o4 } = e4, n5 = {};
    this.objectIdField && (n5[this.objectIdField] = e4.id);
    const s5 = r(r2.attributeInfo) && r2.attributeInfo.attributeData;
    if (r(s5))
      for (const t3 of Object.keys(s5))
        n5[t3] = Me(s5[t3], o4);
    return n5;
  }
  getAttribute(e4, r2) {
    if (r2 === this.objectIdField)
      return e4.id;
    const { meta: o4, index: n5 } = e4, s5 = r(o4.attributeInfo) && o4.attributeInfo.attributeData;
    return r(s5) ? Me(s5[r2], n5) : null;
  }
  getGeometry(t3) {
    if (t3.geometry)
      return t3.geometry;
    const [e4, r2, i, n5, a2] = this.getFeatureExtent(t3, s4);
    return new t2([5], [e4, r2, i, n5, r2, i, n5, a2, i, e4, a2, i, e4, r2, i]);
  }
  getCentroid(t3, e4) {
    if (t3.geometry)
      return e3(new t2(), t3.geometry, e4.hasZ, e4.hasM);
    const [i, n5, a2, m2, u4, d2] = this.getFeatureExtent(t3, s4);
    return new t2([0], [(i + m2) / 2, (n5 + u4) / 2, (a2 + d2) / 2]);
  }
  cloneWithGeometry(t3, e4) {
    const { id: r2, index: o4, meta: i } = t3;
    return { id: r2, index: o4, meta: i, geometry: e4 };
  }
};
var s4 = a();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SQueryFeatureStore.js
var f = class extends y2 {
  constructor(r2) {
    super(r2), this.events = new n2();
  }
  forEach(r2) {
    this.forAllFeatures((t3) => (r2(t3), L.CONTINUE));
  }
  forEachBounds(r2, t3, e4) {
    const o4 = this.getFeatureExtent;
    for (const s5 of r2)
      t3(o4(s5, e4));
  }
  forEachInBounds(r2, t3) {
    this.forAllFeatures((e4) => {
      const o4 = this.getFeatureExtent(e4, y4);
      return E(r2, G(o4, h2)) && t3(e4), L.CONTINUE;
    }, (t4) => {
      if (bn(t4.node.mbs, this.sourceSpatialReference, l2, this.viewSpatialReference), l2[0] >= r2[0] && l2[2] <= r2[2] && l2[1] >= r2[1] && l2[3] <= r2[3])
        return L.CONTINUE;
      const e4 = Math.max(r2[0], Math.min(l2[0], r2[2])), o4 = Math.max(r2[1], Math.min(l2[1], r2[3])), s5 = l2[0] - e4, c = l2[1] - o4;
      return s5 * s5 + c * c <= l2[3] * l2[3] ? L.CONTINUE : L.SKIP;
    });
  }
};
e([d({ constructOnly: true })], f.prototype, "featureAdapter", void 0), e([d({ constructOnly: true })], f.prototype, "toArray", void 0), e([d({ constructOnly: true })], f.prototype, "forAllFeatures", void 0), e([d({ constructOnly: true })], f.prototype, "getFeatureExtent", void 0), e([d({ constructOnly: true })], f.prototype, "sourceSpatialReference", void 0), e([d({ constructOnly: true })], f.prototype, "viewSpatialReference", void 0), f = e([n("esri.views.3d.layers.i3s.I3SQueryFeatureStore")], f);
var l2 = n3();
var y4 = a();
var h2 = u3();

export {
  C,
  p,
  n4 as n,
  f
};
//# sourceMappingURL=chunk-T6YZ2CRM.js.map
