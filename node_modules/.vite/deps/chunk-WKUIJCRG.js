import {
  e as e4
} from "./chunk-XQ337NY7.js";
import {
  h,
  u as u3
} from "./chunk-WL7KJZAL.js";
import {
  c as c2
} from "./chunk-KXE4LGFJ.js";
import {
  x
} from "./chunk-Z34NAJDO.js";
import {
  o
} from "./chunk-HHJIVHSH.js";
import {
  t as t2
} from "./chunk-436X6OVY.js";
import {
  o as o2
} from "./chunk-FMIFCFD7.js";
import {
  re
} from "./chunk-UGLXR5OV.js";
import {
  A,
  S
} from "./chunk-6FQZDXGD.js";
import {
  q
} from "./chunk-HH3D3A65.js";
import {
  t as t3
} from "./chunk-ODX6X222.js";
import {
  j,
  l
} from "./chunk-I4USSDLI.js";
import {
  e as e3
} from "./chunk-OEQ3EDRD.js";
import {
  u as u2
} from "./chunk-56RHM4A6.js";
import {
  u
} from "./chunk-NWRK6QLX.js";
import {
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  R
} from "./chunk-3NMRL5CR.js";
import {
  r as r2
} from "./chunk-ZIHDQYKE.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  a,
  c,
  e as e2,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/engine/LevelDependentSizeVariable.js
var l2;
var n2 = l2 = class extends j {
  writeLevels(e6, s3, i) {
    for (const t4 in e6) {
      const e7 = this.levels[t4];
      return void (s3.stops = e7);
    }
  }
  clone() {
    return new l2({ axis: this.axis, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, maxDataValue: this.maxDataValue, maxSize: e3(this.maxSize) ? this.maxSize.clone() : this.maxSize, minDataValue: this.minDataValue, minSize: e3(this.minSize) ? this.minSize.clone() : this.minSize, normalizationField: this.normalizationField, stops: this.stops && this.stops.map((e6) => e6.clone()), target: this.target, useSymbolValue: this.useSymbolValue, valueRepresentation: this.valueRepresentation, valueUnit: this.valueUnit, legendOptions: this.legendOptions && this.legendOptions.clone(), levels: m(this.levels) });
  }
};
e([d()], n2.prototype, "levels", void 0), e([r2("levels")], n2.prototype, "writeLevels", null), n2 = l2 = e([n("esri.views.2d.engine.LevelDependentSizeVariable")], n2);

// node_modules/@arcgis/core/views/2d/layers/support/clusterUtils.js
var o3 = s.getLogger("esri.views.2d.layers.support.clusterUtils");
a.add("esri-cluster-arcade-enabled", true);
var u4 = a("esri-cluster-arcade-enabled");
var c3 = (e6, i, t4, s3) => {
  const a2 = i.clone();
  if (!m2(a2))
    return a2;
  if (t4.fields)
    for (const r4 of t4.fields)
      x2(e6, r4);
  if ("visualVariables" in a2) {
    const i2 = (a2.visualVariables || []).filter((e7) => "$view.scale" !== e7.valueExpression), n6 = d2(i2);
    i2.forEach((i3) => {
      "rotation" === i3.type ? i3.field ? i3.field = y(e6, i3.field, "avg_angle") : i3.valueExpression && (i3.field = S2(e6, i3.valueExpression, "avg_angle"), i3.valueExpression = null) : i3.normalizationField ? (i3.field = y(e6, i3.field, "norm", i3.normalizationField), i3.normalizationField = null) : i3.field ? i3.field = y(e6, i3.field, "avg") : (i3.field = S2(e6, i3.valueExpression, "avg"), i3.valueExpression = null);
    }), t(n6) && !p(i2) && (i2.push(f(t4, s3)), a2.dynamicClusterSize = true), a2.visualVariables = i2;
  }
  switch (a2.type) {
    case "simple":
      break;
    case "unique-value":
      a2.field ? a2.field = y(e6, a2.field, "mode") : a2.valueExpression && (a2.field = S2(e6, a2.valueExpression, "mode"), a2.valueExpression = null);
      break;
    case "class-breaks":
      a2.normalizationField ? (a2.field = y(e6, a2.field, "norm", a2.normalizationField), a2.normalizationField = null) : a2.field ? a2.field = y(e6, a2.field, "avg") : (a2.field = S2(e6, a2.valueExpression, "avg"), a2.valueExpression = null);
  }
  return a2;
};
var d2 = (e6) => {
  for (const i of e6)
    if ("size" === i.type)
      return i;
  return null;
};
var p = (e6) => {
  for (const i of e6)
    if ("cluster_count" === i.field)
      return true;
  return false;
};
var f = (e6, i) => {
  const t4 = [new l({ value: 0, size: 0 }), new l({ value: 1 })];
  if (t(i))
    return new j({ field: "cluster_count", stops: [...t4, new l({ value: 2, size: 0 })] });
  const s3 = Object.keys(i).reduce((r4, s4) => ({ ...r4, [s4]: [...t4, new l({ value: Math.max(2, i[s4].minValue), size: e6.clusterMinSize }), new l({ value: Math.max(3, i[s4].maxValue), size: e6.clusterMaxSize })] }), {});
  return new n2({ field: "cluster_count", levels: s3 });
};
var m2 = (i) => {
  const t4 = (t5) => o3.error(new s2("Unsupported-renderer", t5, { renderer: i }));
  if ("unique-value" === i.type) {
    if (i.field2 || i.field3)
      return t4("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
  } else if ("class-breaks" === i.type) {
    if (i.normalizationField) {
      const e6 = i.normalizationType;
      if ("field" !== e6)
        return t4(`FeatureReductionCluster does not support a normalizationType of ${e6}`), false;
    }
  } else if ("simple" !== i.type)
    return t4(`FeatureReductionCluster does not support renderers of type ${i.type}`), false;
  if (!u4) {
    if ("valueExpression" in i && i.valueExpression)
      return t4("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in i && i.visualVariables || []).some((e6) => !(!("valueExpression" in e6) || !e6.valueExpression)))
      return t4("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function v2(e6, i, t4) {
  switch (e6) {
    case "avg":
    case "avg_angle":
      return `cluster_avg_${i}`;
    case "mode":
      return `cluster_type_${i}`;
    case "norm": {
      const e7 = t4, r4 = "field", a2 = i.toLowerCase() + ",norm:" + r4 + "," + e7.toLowerCase();
      return "cluster_avg_" + x(a2);
    }
  }
}
function x2(i, t4) {
  const { name: r4, outStatistic: a2 } = t4, { onStatisticField: n6, onStatisticValueExpression: l3, statisticType: u6 } = a2;
  if (l3) {
    const e6 = x(l3.toLowerCase());
    i.push({ name: r4, outStatistic: { onStatisticField: e6, onStatisticValueExpression: l3, statisticType: u6 } });
  } else
    n6 ? i.push({ name: r4, outStatistic: { onStatisticField: n6, statisticType: u6 } }) : o3.error(new s2("mapview-unsupported-field", "Unable to handle field", { field: t4 }));
}
function S2(e6, i, t4) {
  const r4 = x(i), a2 = "mode" === t4 ? `cluster_type_${r4}` : `cluster_avg_${r4}`;
  return e6.some((e7) => e7.name === a2) || e6.push({ name: a2, outStatistic: { onStatisticField: r4, onStatisticValueExpression: i, statisticType: t4 } }), a2;
}
function y(e6, i, t4, r4) {
  if ("cluster_count" === i || e6.some((e7) => e7.name === i))
    return i;
  const s3 = v2(t4, i, r4);
  return e6.some((e7) => e7.name === s3) || ("norm" === t4 ? e6.push({ name: s3, outStatistic: { onStatisticField: i, onStatisticNormalizationField: r4, statisticType: t4 } }) : e6.push({ name: s3, outStatistic: { onStatisticField: i, statisticType: t4 } })), s3;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/util/vvFlagUtils.js
function e5(e6) {
  if (!e6)
    return A.NONE;
  let r4 = 0;
  for (const i of e6)
    if ("size" === i.type) {
      const t4 = o2(i);
      r4 |= t4, "outline" === i.target && (r4 |= t4 << 4);
    } else
      "color" === i.type ? r4 |= A.COLOR : "opacity" === i.type ? r4 |= A.OPACITY : "rotation" === i.type && (r4 |= A.ROTATION);
  return r4;
}

// node_modules/@arcgis/core/views/2d/layers/graphics/graphicsUtils.js
var c4 = 512;
var g = 50;
function p2(e6, t4) {
  const n6 = R(t4);
  if (!n6)
    return null;
  const [i, s3] = n6.valid;
  return e6[2] > s3 ? [u2([e6[0], e6[1], s3, e6[3]]), u2([i, e6[1], i + e6[2] - s3, e6[3]])] : e6[0] < i ? [u2([i, e6[1], e6[2], e6[3]]), u2([s3 - (i - e6[0]), e6[1], s3, e6[3]])] : null;
}
function u5(e6) {
  return "text" === e6 || "esriTS" === e6;
}
function h2(e6) {
  return "simple-marker" === e6 || "picture-marker" === e6 || "esriSMS" === e6 || "esriPMS" === e6;
}
function y2(e6) {
  switch (e2(e6.geometry).type) {
    case "point":
    case "multipoint":
      return 0;
    case "polyline":
      return 1;
    case "polygon":
    case "extent":
      return 2;
  }
  return 0;
}
function d3(e6) {
  if (!e6)
    return null;
  const { xmin: t4, ymin: n6, xmax: r4, ymax: o4, spatialReference: s3 } = e6;
  return new v({ rings: [[[t4, n6], [t4, o4], [r4, o4], [r4, n6], [t4, n6]]], spatialReference: s3 });
}

// node_modules/@arcgis/core/views/2d/layers/features/support/pixelBuffering.js
function m3(t4) {
  if (!("visualVariables" in t4))
    return 0;
  if (!t4.hasVisualVariables("size"))
    return 0;
  const e6 = t4.getVisualVariablesForType("size");
  if (!e6[0])
    return 0;
  const r4 = e6[0];
  if ("outline" === r4.target)
    return 0;
  if ("stops" === r4.transformationType)
    return r4.stops.map((t5) => t5.size).reduce(g2, 0);
  if ("clamped-linear" === r4.transformationType) {
    let t5 = -1 / 0, e7 = -1 / 0;
    return t5 = "number" == typeof r4.maxSize ? r4.maxSize : r4.maxSize.stops.map((t6) => t6.size).reduce(g2, 0), e7 = "number" == typeof r4.minSize ? r4.minSize : r4.minSize.stops.map((t6) => t6.size).reduce(g2, 0), Math.max(t5, e7);
  }
  return "real-world-size" === r4.transformationType ? 30 : void 0;
}
var h3 = { sdf: true, code: 99, metrics: q.metrics, rect: new t2(0, 0, 24, 24), page: 0, textureBinding: 2 };
function g2(t4, e6) {
  return Math.max(t4, e6);
}

// node_modules/@arcgis/core/views/2d/layers/features/schemaUtils.js
var w = s.getLogger("esri.views.2d.layers.features.schemaUtils");
var T = "ValidationError";
var E = { esriGeometryPoint: ["above-right", "above-center", "above-left", "center-center", "center-left", "center-right", "below-center", "below-left", "below-right"], esriGeometryPolygon: ["always-horizontal"], esriGeometryPolyline: ["center-along"], esriGeometryMultipoint: null };
function I(e6) {
  return e6;
}
function S3(e6) {
  let t4 = 0, r4 = 0, i = S.DEFAULT;
  if (r(e6)) {
    if (r4 = m3(e6), "visualVariables" in e6 && (t4 = e5(e6.visualVariables || []), "dot-density" === e6.type && (i = S.DOT_DENSITY)), "heatmap" === e6.type && (i = S.HEATMAP), "dictionary" === e6.type)
      return { maxVVSize: r4, vvFlags: t4, symbologyType: S.DEFAULT };
    if ("pie-chart" === e6.type)
      return { maxVVSize: r4, vvFlags: t4, symbologyType: S.PIE_CHART };
    if (i !== S.DOT_DENSITY && i !== S.HEATMAP) {
      const t5 = e6.getSymbols();
      "backgroundFillSymbol" in e6 && e6.backgroundFillSymbol && t5.push(e6.backgroundFillSymbol);
      let r5 = true, n6 = true;
      for (const e7 of t5)
        if ("cim" === e7.type && (n6 = false), "simple-fill" === e7.type || "picture-fill" === e7.type) {
          const t6 = e7.outline, i2 = t6 && "none" !== t6.style && "solid" !== t6.style, l3 = "simple-fill" === e7.type && "none" !== e7.style && "solid" !== e7.style, s3 = "picture-fill" === e7.type || l3 || i2;
          i2 && (r5 = false), s3 && (n6 = false);
        }
      r5 ? i = n6 ? S.OUTLINE_FILL_SIMPLE : S.OUTLINE_FILL : n6 && (i = S.SIMPLE);
    }
  }
  return { vvFlags: t4, maxVVSize: r4, symbologyType: i };
}
function F(t4, r4) {
  const i = t4.labelPlacement, n6 = E[r4];
  if (!t4.symbol)
    return w.warn("No ILabelClass symbol specified."), true;
  if (!n6)
    return w.error(new s2("mapview-labeling:unsupported-geometry-type", `Unable to create labels for Feature Layer, ${r4} is not supported`)), true;
  if (!n6.includes(i)) {
    const e6 = n6[0];
    i && w.warn(`Found invalid label placement type ${i} for ${r4}. Defaulting to ${e6}`), t4.labelPlacement = e6;
  }
  return false;
}
function V(e6, t4) {
  const i = m(e6);
  return i.some((e7) => F(e7, t4)) ? [] : i;
}
function z(e6) {
  return a("esri-2d-update-debug") && console.debug("Created new schema", N(e6, true)), N(e6);
}
function N(e6, t4 = false) {
  var _a, _b;
  try {
    const r4 = U(e6, t4), i = $(e6), l3 = {};
    r4.map((t5) => M(l3, e6, t5));
    const s3 = r(e6.subtypeCode) ? `${e6.subtypeField} = ${e6.subtypeCode}` : null, o4 = t3(e6.definitionExpression, s3);
    return { source: { definitionExpression: o4, fields: e6.fields.map((e7) => e7.toJSON()), gdbVersion: e6.gdbVersion, historicMoment: (_a = e6.historicMoment) == null ? void 0 : _a.getTime(), outFields: e6.availableFields, pixelBuffer: e6.pixelBuffer, spatialReference: e6.spatialReference.toJSON(), timeExtent: (_b = e6.timeExtent) == null ? void 0 : _b.toJSON(), customParameters: e6.customParameters }, attributes: { fields: {}, indexCount: 0 }, processors: r4, tileRenderer: i, targets: l3 };
  } catch (r4) {
    if (r4.fieldName === T)
      return w.error(r4), null;
    throw r4;
  }
}
function M(t4, r4, i) {
  switch (i.target) {
    case "feature":
      return void P(t4, O(r4), i);
    case "aggregate": {
      if (!("featureReduction" in r4))
        return;
      const n6 = r4.featureReduction;
      switch (n6.type) {
        case "selection":
          throw new s2(T, "Mapview does not support `selection` reduction type", n6);
        case "binning":
          return P(t4, O(r4), i), void j4(t4, n6, i);
        case "cluster":
          return P(t4, O(r4), i), void R2(t4, n6, i);
      }
    }
  }
}
function L(e6, t4) {
  for (const r4 in t4) {
    const i = t4[r4];
    if (i.target !== e6.name)
      continue;
    const n6 = e6.attributes[r4];
    n6 ? (n6.context.mesh = n6.context.mesh || i.context.mesh, n6.context.storage = n6.context.storage || i.context.storage) : e6.attributes[r4] = i;
  }
  return e6;
}
function O(e6) {
  var _a, _b, _c;
  return [((_a = e2(e6.filter)) == null ? void 0 : _a.toJSON()) ?? null, ((_c = e2((_b = e2(e6.featureEffect)) == null ? void 0 : _b.filter)) == null ? void 0 : _c.toJSON()) ?? null];
}
function P(e6, t4, r4) {
  return e6.feature || (e6.feature = { name: "feature", input: "source", filters: t4, attributes: {} }), L(e6.feature, r4.attributes.fields), e6;
}
function j4(e6, t4, r4) {
  return e6.aggregate || (e6.aggregate = { name: "aggregate", type: "bin", filters: null, input: "feature", params: { fixedBinLevel: t4.fixedBinLevel }, attributes: {} }), L(e6.aggregate, r4.attributes.fields), e6;
}
function R2(e6, t4, r4) {
  return e6.aggregate || (e6.aggregate = { name: "aggregate", type: "cluster", input: "feature", filters: null, attributes: {}, params: { clusterRadius: u(t4.clusterRadius / 2), clusterPixelBuffer: 64 * Math.ceil(u(t4.clusterMaxSize) / 64), fields: r4.aggregateFields } }), L(e6.aggregate, r4.attributes.fields), e6;
}
function B(e6, t4) {
  return t4.field ? k(e6, { ...t4, type: "field", field: t4.field }) : t4.valueExpression ? k(e6, { ...t4, type: "expression", valueExpression: t4.valueExpression }) : { field: null, fieldIndex: null };
}
function k(e6, t4) {
  switch (t4.type) {
    case "expression": {
      const r4 = I(t4.valueExpression);
      if (!e6.fields[r4]) {
        const i = e6.indexCount++;
        e6.fields[r4] = { ...t4, name: r4, fieldIndex: i };
      }
      return { fieldIndex: e6.fields[r4].fieldIndex };
    }
    case "label-expression": {
      const r4 = I(JSON.stringify(t4.label));
      if (!e6.fields[r4]) {
        const i = e6.indexCount++;
        e6.fields[r4] = { ...t4, name: r4, fieldIndex: i };
      }
      return { fieldIndex: e6.fields[r4].fieldIndex };
    }
    case "field": {
      const r4 = t4.field;
      return "aggregate" === t4.target && e6.fields[r4] || (e6.fields[r4] = { ...t4, name: r4 }), { field: r4 };
    }
    case "statistic":
      return e6.fields[t4.name] = { ...t4 }, { field: t4.name };
  }
}
function U(e6, t4 = false) {
  const r4 = new Array();
  let i = 0;
  return r4.push(A2(e6, i++, t4)), r4;
}
function C(e6, t4, r4, i, n6, l3 = false) {
  const s3 = k(t4, { type: "label-expression", target: i, context: { mesh: true }, resultType: "string", label: { labelExpression: r4.labelExpression, labelExpressionInfo: r4.labelExpressionInfo ? { expression: r4.labelExpressionInfo.expression } : null, symbol: !!r4.symbol, where: r4.where } }), { fieldIndex: o4 } = s3, a2 = S3(e6);
  return { ...o(r4, a2, l3), fieldIndex: o4, target: i, index: n6 };
}
function D(t4, r4, i) {
  const n6 = "featureReduction" in r4 && r4.featureReduction;
  if (!n6)
    return { fields: [], labels: [], matcher: null, rendererOverride: null };
  const l3 = "aggregate", s3 = [];
  let o4 = null, a2 = e4(r4.geometryType), u6 = [], f3 = null;
  if (n6)
    switch (n6.type) {
      case "selection":
        throw new s2(T, "Mapview does not support `selection` reduction type", n6);
      case "cluster":
      case "binning":
        if ("cluster" === n6.type ? a2 = "esriGeometryPoint" : "binning" === n6.type && (a2 = "esriGeometryPolygon"), n6.renderer) {
          for (const e6 of n6.fields)
            x2(s3, e6);
          f3 = n6.renderer, o4 = K(null, l3, n6.renderer, i), u6 = n6 && n6.labelsVisible && n6.labelingInfo || [];
        } else if ("cluster" === n6.type) {
          if (f3 = c3(s3, r4.renderer, n6, null), n6.symbol) {
            const e6 = S3(f3);
            o4 = { type: "simple", symbol: o(n6.symbol, e6, i), symbologyType: e6.symbologyType };
          }
          u6 = n6 && n6.labelsVisible && n6.labelingInfo || [];
        }
    }
  q2(t4, s3);
  return { labels: V(u6, "binning" === n6.type ? "esriGeometryPolygon" : a2), matcher: o4, fields: s3, rendererOverride: f3 };
}
function A2(t4, r4, i = false) {
  const l3 = { indexCount: 0, fields: {} }, s3 = "featureReduction" in t4 && t4.featureReduction ? "aggregate" : "feature";
  if ("sublayers" in t4) {
    const r5 = { type: "subtype", subtypeField: t4.subtypeField, renderers: {}, symbologyType: S.DEFAULT }, o5 = { type: "subtype", mapping: {}, target: "feature" }, a3 = { type: "subtype", classes: {} }, u7 = { type: "symbol", target: "feature", aggregateFields: [], attributes: l3, storage: o5, mesh: { matcher: r5, aggregateMatcher: null, labels: a3, sortKey: null } }, d5 = /* @__PURE__ */ new Set();
    let p4 = 0;
    for (const { renderer: f3, subtypeCode: c6, labelingInfo: y4, labelsVisible: m5 } of t4.sublayers) {
      const t5 = K(l3, s3, f3, i), u8 = J(l3, s3, f3), g3 = m5 && y4;
      if ("visualVariables" in f3 && f3.visualVariables && f3.visualVariables.length)
        throw new s2(T, "Visual variables are currently not supported for subtype layers");
      if ("dictionary" === t5.type)
        throw new s2(T, "Dictionary renderer is not supported in subtype layers");
      if ("subtype" === t5.type)
        throw new s2(T, "Nested subtype renderers is not supported");
      if (r(u8) && "subtype" === u8.type)
        throw new s2(T, "Nested subtype storage is not supported");
      if (r(u8) && r(u8.attributeMapping))
        throw new s2(T, "Non-visual-variable attributes are not supported in subtype layers");
      if ("heatmap" === t5.type)
        throw new s2(T, "Heatmaps are not supported in subtype layers");
      if ("pie-chart" === t5.type)
        throw new s2(T, "Pie-charts are not supported in subtype layers");
      if (d5.has(c6))
        throw new s2(T, "Subtype codes for sublayers must be unique");
      d5.add(c6), r5.renderers[c6] = t5, o5.mapping[c6] = u8, g3 && (a3.classes[c6] = g3.map((e6) => C(f3, l3, e6, "feature", p4++, i)));
    }
    return u7;
  }
  if ("heatmap" === t4.renderer.type && "raster" === h()) {
    const { radius: e6, fieldOffset: r5, field: i2 } = t4.renderer;
    return { type: "heatmap", aggregateFields: [], attributes: l3, target: s3, storage: null, mesh: { radius: e6, fieldOffset: r5, field: B(l3, { target: s3, field: i2, resultType: "numeric" }).field } };
  }
  const o4 = D(l3, t4, i), a2 = e4(t4.geometryType), u6 = o4.rendererOverride ?? t4.renderer, d4 = K(l3, s3, u6, i), p3 = J(l3, s3, u6), c5 = G(l3, t4.orderBy), y3 = V(t4.labelsVisible && t4.labelingInfo || [], a2);
  let m4 = 0;
  const b = [...y3.map((e6) => C(u6, l3, e6, "feature", m4++, i)), ...o4.labels.map((e6) => C(u6, l3, e6, "aggregate", m4++, i))];
  return { type: "symbol", target: s3, attributes: l3, aggregateFields: o4.fields, storage: p3, mesh: { matcher: d4, labels: { type: "simple", classes: b }, aggregateMatcher: o4.matcher, sortKey: c5 } };
}
function $(e6) {
  var _a;
  return "heatmap" === ((_a = e6.renderer) == null ? void 0 : _a.type) && "raster" === h() ? { type: "heatmap" } : { type: "symbol" };
}
function G(t4, r4) {
  if (t(r4) || !r4.length)
    return null;
  r4.length > 1 && w.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${r4.length}. All but the first will be discarded`);
  const i = r4[0], n6 = "ascending" === i.order ? "asc" : "desc";
  if (i.field)
    return { field: i.field, order: n6 };
  if (i.valueExpression) {
    return { fieldIndex: k(t4, { type: "expression", target: "feature", valueExpression: i.valueExpression, resultType: "numeric" }).fieldIndex, order: n6 };
  }
  return w.error(new s2(T, "Expected to find a field or valueExpression for OrderByInfo", i)), null;
}
function q2(e6, t4) {
  const r4 = { mesh: true, storage: true };
  for (const i of t4) {
    const { name: t5, outStatistic: n6 } = i, { statisticType: l3, onStatisticField: s3 } = n6;
    let o4 = null, a2 = null, u6 = null;
    const f3 = "numeric", d4 = "feature";
    if ("onStatisticValueExpression" in n6) {
      a2 = k(e6, { type: "expression", target: d4, valueExpression: n6.onStatisticValueExpression, resultType: f3 }).fieldIndex;
    } else if ("onStatisticNormalizationField" in n6) {
      o4 = k(e6, { type: "field", target: d4, field: s3, resultType: f3 }).field, u6 = n6.onStatisticNormalizationField;
    } else {
      o4 = k(e6, { type: "field", target: d4, field: s3, resultType: f3 }).field;
    }
    k(e6, { type: "statistic", target: "aggregate", name: t5, context: r4, inField: o4, inNormalizationField: u6, inFieldIndex: a2, statisticType: l3 });
  }
}
function J(e6, t4, r4) {
  let i;
  switch (r4.type) {
    case "simple":
    case "class-breaks":
    case "unique-value":
    case "dictionary":
      i = { visualVariables: true, attributes: null };
      break;
    default:
      i = c2(r4).getStorageSpec(r4);
  }
  return _(e6, t4, i, r4);
}
function _(e6, t4, r4, i) {
  if (t(r4))
    return null;
  const { visualVariables: l3, attributes: o4 } = r4;
  let a2 = null;
  l3 && "visualVariables" in i && (a2 = H(e6, t4, i.visualVariables));
  const u6 = r(a2) ? 4 : 0;
  let f3 = null;
  return r(o4) && (f3 = o4.map((r5, i2) => {
    const { field: n6, fieldIndex: l4 } = B(e6, { valueExpression: r5.valueExpression, field: r5.field, resultType: "numeric", target: t4 });
    return { binding: i2 + u6, field: n6, fieldIndex: l4 };
  })), { type: "simple", target: t4, attributeMapping: f3, vvMapping: a2 };
}
function H(e6, t4, r4) {
  if (!r4 || !r4.length)
    return [];
  const i = { storage: true }, n6 = "numeric";
  return u3(r4).map((r5) => {
    const l3 = re(r5.type), { field: s3, fieldIndex: o4 } = B(e6, { target: t4, valueExpression: r5.valueExpression, field: r5.field, context: i, resultType: n6 });
    switch (r5.type) {
      case "size":
        return "$view.scale" === r5.valueExpression ? null : { type: "size", binding: l3, field: s3, fieldIndex: o4, normalizationField: B(e6, { target: t4, field: r5.normalizationField, context: i, resultType: n6 }).field, valueRepresentation: r5.valueRepresentation ?? null };
      case "color":
        return { type: "color", binding: l3, field: s3, fieldIndex: o4, normalizationField: B(e6, { target: t4, field: r5.normalizationField, context: i, resultType: n6 }).field };
      case "opacity":
        return { type: "opacity", binding: l3, field: s3, fieldIndex: o4, normalizationField: B(e6, { target: t4, field: r5.normalizationField, context: i, resultType: n6 }).field };
      case "rotation":
        return { type: "rotation", binding: l3, field: s3, fieldIndex: o4 };
    }
  }).filter((e7) => e7);
}
function K(e6, t4, r4, i = false) {
  const n6 = c(e6, { indexCount: 0, fields: {} });
  switch (r4.type) {
    case "simple":
    case "dot-density":
      return Y(n6, r4, i);
    case "class-breaks":
      return W(n6, t4, r4, i);
    case "unique-value":
      return X(n6, t4, r4, i);
    case "dictionary":
      return Z2(n6, r4, i);
    case "heatmap":
      return ee(n6, r4, i);
    case "pie-chart":
      return Q(n6, r4, i);
  }
}
function Y(e6, t4, r4 = false) {
  const i = t4.getSymbols(), n6 = i.length ? i[0] : null, l3 = S3(t4);
  return { type: "simple", symbol: o(n6, l3, r4), symbologyType: l3.symbologyType };
}
function Q(e6, t4, r4 = false) {
  const i = t4.getSymbols(), n6 = i[0], l3 = i.length > 1 ? i[1] : null, s3 = S3(t4);
  return { type: "pie-chart", markerSymbol: o(n6, s3, r4), fillSymbol: o(l3, s3, r4), symbologyType: s3.symbologyType };
}
function W(e6, t4, r4, i = false) {
  const n6 = { mesh: true, use: "renderer.field" }, l3 = r4.backgroundFillSymbol, { field: s3, fieldIndex: o4 } = B(e6, { target: t4, field: r4.field, valueExpression: r4.valueExpression, resultType: "numeric", context: n6 }), a2 = r4.normalizationType, u6 = "log" === a2 ? "esriNormalizeByLog" : "percent-of-total" === a2 ? "esriNormalizeByPercentOfTotal" : "field" === a2 ? "esriNormalizeByField" : null, f3 = S3(r4), d4 = r4.classBreakInfos.map((e7) => ({ symbol: o(e7.symbol, f3, i), min: e7.minValue, max: e7.maxValue })).sort((e7, t5) => e7.min - t5.min);
  return { type: "interval", attributes: e6.fields, field: s3, fieldIndex: o4, backgroundFillSymbol: o(l3, f3, i), defaultSymbol: o(r4.defaultSymbol, f3, i), intervals: d4, normalizationField: r4.normalizationField, normalizationTotal: r4.normalizationTotal, normalizationType: u6, isMaxInclusive: r4.isMaxInclusive, symbologyType: f3.symbologyType };
}
function X(t4, r4, i, n6 = false) {
  const l3 = [], s3 = i.backgroundFillSymbol, o4 = { target: r4, context: { mesh: true }, resultType: "string" };
  if (i.field && "string" != typeof i.field)
    throw new s2(T, "Expected renderer.field to be a string", i);
  const { field: a2, fieldIndex: u6 } = B(t4, { ...o4, field: i.field, valueExpression: i.valueExpression }), f3 = S3(i);
  for (const e6 of i.uniqueValueInfos)
    l3.push({ value: "" + e6.value, symbol: o(e6.symbol, f3, n6) });
  return { type: "map", attributes: t4.fields, field: a2, fieldIndex: u6, field2: B(t4, { ...o4, field: i.field2 }).field, field3: B(t4, { ...o4, field: i.field3 }).field, fieldDelimiter: i.fieldDelimiter, backgroundFillSymbol: o(s3, f3), defaultSymbol: o(i.defaultSymbol, f3), map: l3, symbologyType: f3.symbologyType };
}
function Z2(e6, t4, r4 = false) {
  const i = S3(t4);
  return { type: "dictionary", config: t4.config, fieldMap: t4.fieldMap, scaleExpression: t4.scaleExpression, url: t4.url, symbolOptions: i, symbologyType: i.symbologyType };
}
function ee(e6, t4, r4 = false) {
  const i = t4.getSymbols(), n6 = i.length ? i[0] : null, l3 = S3(t4);
  return { type: "heatmap", symbol: o(n6, l3, r4), symbologyType: l3.symbologyType };
}

export {
  c4 as c,
  g,
  p2 as p,
  u5 as u,
  h2 as h,
  y2 as y,
  d3 as d,
  c3 as c2,
  d2,
  f,
  m2 as m,
  x2 as x,
  S3 as S,
  z,
  K
};
//# sourceMappingURL=chunk-WKUIJCRG.js.map
