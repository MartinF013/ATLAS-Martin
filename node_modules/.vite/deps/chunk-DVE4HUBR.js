import {
  m
} from "./chunk-RC6OMMF6.js";
import {
  d,
  o as o2
} from "./chunk-OYNEZ5VG.js";
import {
  e as e2
} from "./chunk-AALA53RH.js";
import {
  m as m2
} from "./chunk-DMGVDNFD.js";
import {
  o as o3
} from "./chunk-BMA2CXVS.js";
import {
  e
} from "./chunk-4MKQUQD4.js";
import {
  o as o4
} from "./chunk-A3QLZKCF.js";
import {
  a
} from "./chunk-I5UNY2WQ.js";
import {
  n as n4
} from "./chunk-NAB3NF54.js";
import {
  r as r2
} from "./chunk-MLAOYRDT.js";
import {
  n as n2
} from "./chunk-U7B2WKBH.js";
import {
  n as n3
} from "./chunk-P6G64ARX.js";
import {
  r
} from "./chunk-ZOKX6UGH.js";
import {
  o
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl.js
function t(t2) {
  t2.extensions.add("GL_EXT_shader_texture_lod"), t2.extensions.add("GL_OES_standard_derivatives"), t2.fragment.code.add(n4`#ifndef GL_EXT_shader_texture_lod
float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {
float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));
return max(0.0, 0.5 * log2(deltaMaxSqr));
}
#endif
vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {
vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;
vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;
float maxdUV = 0.125;
vec2 dUVdx = clamp(dFdx(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
vec2 dUVdy = clamp(dFdy(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
#ifdef GL_EXT_shader_texture_lod
return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);
#else
vec2 dUVdxAuto = dFdx(uvAtlas);
vec2 dUVdyAuto = dFdy(uvAtlas);
float mipMapLevel = calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);
float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);
return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);
#endif
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl.js
function a2(a4, s) {
  switch (a4.include(d, s), a4.fragment.code.add(n4`
  struct TextureLookupParameter {
    vec2 uv;
    ${s.supportsTextureAtlas ? "vec2 size;" : ""}
  } vtc;
  `), s.textureCoordinateType) {
    case o2.Default:
      return void a4.fragment.code.add(n4`vec4 textureLookup(sampler2D texture, TextureLookupParameter params) {
return texture2D(texture, params.uv);
}`);
    case o2.Atlas:
      return a4.include(t), void a4.fragment.code.add(n4`vec4 textureLookup(sampler2D texture, TextureLookupParameter params) {
return textureAtlasLookup(texture, params.size, params.uv, vuvRegion);
}`);
    default:
      n3(s.textureCoordinateType);
    case o2.None:
    case o2.COUNT:
      return;
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js
var u = r2(0, 0.6, 0.2);
var l;
!function(e3) {
  e3[e3.Disabled = 0] = "Disabled", e3[e3.Normal = 1] = "Normal", e3[e3.Schematic = 2] = "Schematic", e3[e3.Water = 3] = "Water", e3[e3.WaterOnIntegratedMesh = 4] = "WaterOnIntegratedMesh", e3[e3.COUNT = 5] = "COUNT";
}(l || (l = {}));
function d2(e3, n5) {
  const u2 = e3.fragment, m4 = n5.hasMetalnessAndRoughnessTexture || n5.hasEmissionTexture || n5.hasOcclusionTexture;
  if (n5.pbrMode === l.Normal && m4 && e3.include(a2, n5), n5.pbrMode !== l.Schematic)
    if (n5.pbrMode !== l.Disabled) {
      if (n5.pbrMode === l.Normal) {
        u2.code.add(n4`vec3 mrr;
vec3 emission;
float occlusion;`);
        const e4 = n5.supportsTextureAtlas, s = n5.pbrTextureBindType;
        n5.hasMetalnessAndRoughnessTexture && (u2.uniforms.add(s === a.Pass ? m2("texMetallicRoughness", (e5) => e5.textureMetallicRoughness, e4) : m("texMetallicRoughness", (e5) => e5.textureMetallicRoughness, e4)), u2.code.add(n4`void applyMetallnessAndRoughness(TextureLookupParameter params) {
vec3 metallicRoughness = textureLookup(texMetallicRoughness, params).rgb;
mrr[0] *= metallicRoughness.b;
mrr[1] *= metallicRoughness.g;
}`)), n5.hasEmissionTexture && (u2.uniforms.add(s === a.Pass ? m2("texEmission", (e5) => e5.textureEmissive, e4) : m("texEmission", (e5) => e5.textureEmissive, e4)), u2.code.add(n4`void applyEmission(TextureLookupParameter params) {
emission *= textureLookup(texEmission, params).rgb;
}`)), n5.hasOcclusionTexture ? (u2.uniforms.add(s === a.Pass ? m2("texOcclusion", (e5) => e5.textureOcclusion, e4) : m("texOcclusion", (e5) => e5.textureOcclusion, e4)), u2.code.add(n4`void applyOcclusion(TextureLookupParameter params) {
occlusion *= textureLookup(texOcclusion, params).r;
}
float getBakedOcclusion() {
return occlusion;
}`)) : u2.code.add(n4`float getBakedOcclusion() { return 1.0; }`), u2.uniforms.add(s === a.Pass ? [new e("emissionFactor", (e5) => e5.emissiveFactor), new e("mrrFactors", (e5) => e5.mrrFactors)] : [new o3("emissionFactor", (e5) => e5.emissiveFactor), new o3("mrrFactors", (e5) => e5.mrrFactors)]), u2.code.add(n4`
    void applyPBRFactors() {
      mrr = mrrFactors;
      emission = emissionFactor;
      occlusion = 1.0;
      ${m4 ? "vtc.uv = vuv0;" : ""}
      ${n5.hasMetalnessAndRoughnessTexture ? n5.supportsTextureAtlas ? "vtc.size = texMetallicRoughnessSize; applyMetallnessAndRoughness(vtc);" : "applyMetallnessAndRoughness(vtc);" : ""}
      ${n5.hasEmissionTexture ? n5.supportsTextureAtlas ? "vtc.size = texEmissionSize; applyEmission(vtc);" : "applyEmission(vtc);" : ""}
      ${n5.hasOcclusionTexture ? n5.supportsTextureAtlas ? "vtc.size = texOcclusionSize; applyOcclusion(vtc);" : "applyOcclusion(vtc);" : ""}
    }
  `);
      }
    } else
      u2.code.add(n4`float getBakedOcclusion() { return 1.0; }`);
  else
    u2.code.add(n4`vec3 mrr = vec3(0.0, 0.6, 0.2);
vec3 emission = vec3(0.0);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js
function m3(n5, g) {
  const m4 = n5.fragment, o7 = void 0 !== g.lightingSphericalHarmonicsOrder ? g.lightingSphericalHarmonicsOrder : 2;
  0 === o7 ? (m4.uniforms.add(new e("lightingAmbientSH0", (n6, t2) => o(a3, t2.lighting.sh.r[0], t2.lighting.sh.g[0], t2.lighting.sh.b[0]))), m4.code.add(n4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 1 === o7 ? (m4.uniforms.add([new e2("lightingAmbientSH_R", (i, n6) => r(r3, n6.lighting.sh.r[0], n6.lighting.sh.r[1], n6.lighting.sh.r[2], n6.lighting.sh.r[3])), new e2("lightingAmbientSH_G", (i, n6) => r(r3, n6.lighting.sh.g[0], n6.lighting.sh.g[1], n6.lighting.sh.g[2], n6.lighting.sh.g[3])), new e2("lightingAmbientSH_B", (i, n6) => r(r3, n6.lighting.sh.b[0], n6.lighting.sh.b[1], n6.lighting.sh.b[2], n6.lighting.sh.b[3]))]), m4.code.add(n4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 2 === o7 && (m4.uniforms.add([new e("lightingAmbientSH0", (n6, t2) => o(a3, t2.lighting.sh.r[0], t2.lighting.sh.g[0], t2.lighting.sh.b[0])), new e2("lightingAmbientSH_R1", (i, n6) => r(r3, n6.lighting.sh.r[1], n6.lighting.sh.r[2], n6.lighting.sh.r[3], n6.lighting.sh.r[4])), new e2("lightingAmbientSH_G1", (i, n6) => r(r3, n6.lighting.sh.g[1], n6.lighting.sh.g[2], n6.lighting.sh.g[3], n6.lighting.sh.g[4])), new e2("lightingAmbientSH_B1", (i, n6) => r(r3, n6.lighting.sh.b[1], n6.lighting.sh.b[2], n6.lighting.sh.b[3], n6.lighting.sh.b[4])), new e2("lightingAmbientSH_R2", (i, n6) => r(r3, n6.lighting.sh.r[5], n6.lighting.sh.r[6], n6.lighting.sh.r[7], n6.lighting.sh.r[8])), new e2("lightingAmbientSH_G2", (i, n6) => r(r3, n6.lighting.sh.g[5], n6.lighting.sh.g[6], n6.lighting.sh.g[7], n6.lighting.sh.g[8])), new e2("lightingAmbientSH_B2", (i, n6) => r(r3, n6.lighting.sh.b[5], n6.lighting.sh.b[6], n6.lighting.sh.b[7], n6.lighting.sh.b[8]))]), m4.code.add(n4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`), g.pbrMode !== l.Normal && g.pbrMode !== l.Schematic || m4.code.add(n4`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`));
}
var a3 = n();
var r3 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js
function o6(o7, a4) {
  const g = o7.fragment;
  a4.isGround ? g.uniforms.add(new o4("lightingFixedFactor", (i, n5) => (1 - n5.lighting.groundLightingFactor) * (1 - n5.lighting.globalFactor))) : g.constants.add("lightingFixedFactor", "float", 0), g.uniforms.add([new e("lightingMainDirection", (i, n5) => n5.lighting.lightingMainDirection), new e("lightingMainIntensity", (i, n5) => n5.lighting.mainLight.intensity)]), g.code.add(n4`vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {
float dotVal = clamp(dot(normal_global, lightingMainDirection), 0.0, 1.0);
dotVal = mix(dotVal, 1.0, lightingFixedFactor);
return lightingMainIntensity * ((1.0 - shadowing) * dotVal);
}`);
}

export {
  t,
  a2 as a,
  u,
  l,
  d2 as d,
  m3 as m,
  o6 as o
};
//# sourceMappingURL=chunk-DVE4HUBR.js.map
