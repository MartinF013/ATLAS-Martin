import {
  J
} from "./chunk-BBUIX72C.js";
import {
  n as n4
} from "./chunk-GKYJJGE3.js";
import {
  o as o2
} from "./chunk-KSOWE6GO.js";
import {
  c as c3
} from "./chunk-Y5AGUEHG.js";
import {
  g
} from "./chunk-767LZ6IM.js";
import {
  e as e5
} from "./chunk-AALA53RH.js";
import {
  a as a2
} from "./chunk-BOVIIQLB.js";
import {
  c as c2
} from "./chunk-DMGVDNFD.js";
import {
  e as e4
} from "./chunk-46N7XS5M.js";
import {
  e as e2
} from "./chunk-4MKQUQD4.js";
import {
  o
} from "./chunk-A3QLZKCF.js";
import {
  a
} from "./chunk-OYAHQ564.js";
import {
  e as e3
} from "./chunk-LGILR4HN.js";
import {
  i2 as i
} from "./chunk-I5UNY2WQ.js";
import {
  n as n3
} from "./chunk-NAB3NF54.js";
import {
  e
} from "./chunk-YFBAFAZ2.js";
import {
  r as r2
} from "./chunk-YZNDHJDJ.js";
import {
  f,
  n as n2
} from "./chunk-RTHP2LNT.js";
import {
  c,
  h
} from "./chunk-ASC3X65B.js";
import {
  L,
  z
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/chunks/ShadowHighlight.glsl.js
var F = { highlightedThreshold: 0.99999, selfShadowThreshold: 0.025 };
function y() {
  const i2 = new i();
  i2.include(c3, { receiveShadows: true });
  const l = i2.fragment;
  return l.include(a), l.include(a2), i2.include(n4), i2.include(o2), l.uniforms.add([new c2("defaultDepthTex", (e6, o3) => o3.shadowMap.getSnapshot(J.Default)), new c2("highlightDepthTex", (e6, o3) => o3.shadowMap.getSnapshot(J.Highlight)), new c2("depthMap", (e6, o3) => o3.linearDepthTexture), new c2("highlightMap", (e6, o3) => o3.highlightColorTexture), new e5("uColor", (e6) => e6.shadowColor), new e3("nearFar", (e6, o3) => o3.camera.nearFar), new o("opacity", (e6) => e6.shadowOpacity), new o("occludedOpacity", (e6) => e6.occludedShadowOpacity), new o("terminationFactor", (e6) => e6.opacityElevation * e6.dayNightTerminator), new e2("lightingMainDirectionView", (e6, o3) => z(z2, L(z2, o3.lighting.lightingMainDirection, o3.camera.viewInverseTransposeMatrix))), new e3("texelSize", (o3, r3) => r(r3.linearDepthTexture) ? r2(T, 1 / r3.linearDepthTexture.descriptor.width, 1 / r3.linearDepthTexture.descriptor.height) : f), new e4("inverseViewMatrix", (e6, i3) => h(j, c(j, i3.camera.viewMatrix, i3.camera.center)))]), l.constants.add("unoccludedHighlightFlag", "vec4", g).add("highlightedThreshold", "float", F.highlightedThreshold).add("selfShadowThreshold", "float", F.selfShadowThreshold), l.code.add(n3`vec3 normalFromDepth(vec3 pixelPos, vec2 fragCoord, vec2 uv, vec2 texelSize, sampler2D depthMap, vec2 nearFar) {
float leftPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(-1.0, 0.0) * texelSize, nearFar);
float rightPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(1.0, 0.0) * texelSize, nearFar);
float bottomPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(0.0, -1.0) * texelSize, nearFar);
float topPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(0.0, 1.0) * texelSize, nearFar);
bool pickLeft = abs(pixelPos.z - leftPixelDepth) < abs(pixelPos.z - rightPixelDepth);
bool pickBottom = abs(pixelPos.z - bottomPixelDepth) < abs(pixelPos.z - topPixelDepth);
vec3 fragCoordHorizontal = pickLeft
? vec3(fragCoord + vec2(-1.0, 0.0), leftPixelDepth)
: vec3(fragCoord + vec2(1.0, 0.0), rightPixelDepth);
vec3 fragCoordVertical = pickBottom
? vec3(fragCoord + vec2(0.0, -1.0), bottomPixelDepth)
: vec3(fragCoord + vec2(0.0, 1.0), topPixelDepth);
vec3 verticalPixelPos = reconstructPosition(fragCoordHorizontal.xy, fragCoordHorizontal.z);
vec3 horizontalPixelPos = reconstructPosition(fragCoordVertical.xy, fragCoordVertical.z);
vec3 normal = normalize(cross(verticalPixelPos - pixelPos, horizontalPixelPos - pixelPos));
return pickLeft == pickBottom ? normal : -normal;
}`), l.code.add(n3`void main(void) {
vec4 highlightInfo = texture2D(highlightMap, uv);
float visiblyHighlighted = (1.0 - clamp(distance(unoccludedHighlightFlag, highlightInfo), 0.0, 1.0)) * highlightInfo.a;
if (visiblyHighlighted > highlightedThreshold) {
discard;
}
float depth = rgba2float(texture2D(depthMap, uv));
if (depth == 0.0) {
discard;
}
float currentPixelDepth = linearDepthFromFloat(depth, nearFar);
if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {
discard;
}
vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;
mat4 shadowMatrix;
float linearDepth = -currentPixelDepth;
int i = chooseCascade(linearDepth, shadowMatrix);
if (i >= numCascades) {
discard;
}
vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
discard;
}
vec2 uvShadow = cascadeCoordinates(i, lvpos);
float depthHighlight = readShadowMapDepth(uvShadow, highlightDepthTex);
bool shadowHighlight = depthHighlight < lvpos.z;
if (!shadowHighlight) {
discard;
}
float depthDefault = readShadowMapDepth(uvShadow, defaultDepthTex);
bool shadowDefault = depthDefault < lvpos.z;
vec3 normal = normalFromDepth(currentPixelPos.xyz, gl_FragCoord.xy, uv, texelSize, depthMap, nearFar);
bool shaded = dot(normal, lightingMainDirectionView) < selfShadowThreshold;
float fragOpacity = (shadowDefault || shaded) ? occludedOpacity : opacity;
gl_FragColor = vec4(uColor.rgb, uColor.a * fragOpacity * terminationFactor);
}`), i2;
}
var j = e();
var z2 = n();
var T = n2();
var C = Object.freeze(Object.defineProperty({ __proto__: null, build: y }, Symbol.toStringTag, { value: "Module" }));

export {
  y,
  C
};
//# sourceMappingURL=chunk-NQLNYYVG.js.map
