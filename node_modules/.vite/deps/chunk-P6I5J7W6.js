import {
  e
} from "./chunk-ORGMKDYR.js";
import {
  d
} from "./chunk-HJHWUUQQ.js";
import {
  a,
  n
} from "./chunk-D7DLEBS2.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  l
} from "./chunk-FVPTCNCX.js";
import {
  g
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  c
} from "./chunk-G5JBUC5N.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/renderers/support/DictionaryLoader.js
var f = s.getLogger("esri.renderers.support.DictionaryLoader");
var h = { type: "CIMSimpleLineCallout", lineSymbol: { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", width: 0.5, color: [0, 0, 0, 255] }] } };
var y = class {
  constructor(e2, t, s3) {
    this.config = null, this.fieldMap = null, this.url = null, this._ongoingRequests = /* @__PURE__ */ new Map(), this._symbolCache = new e(100), this.url = e2, this.config = t, this.fieldMap = s3;
  }
  getSymbolFields() {
    return this._symbolFields;
  }
  async getSymbolAsync(t, s3) {
    let o;
    this._dictionaryPromise || (this._dictionaryPromise = this.fetchResources(s3));
    try {
      o = await this._dictionaryPromise;
    } catch (d2) {
      if (g(d2))
        return this._dictionaryPromise = null, null;
    }
    const i = {};
    if (this.fieldMap)
      for (const e2 of this._symbolFields) {
        const s4 = this.fieldMap[e2];
        if (s4 && null != t.attributes[s4]) {
          const o2 = "" + t.attributes[s4];
          i[e2] = o2;
        } else
          i[e2] = "";
      }
    const a2 = o(i, s3);
    if (!a2 || "string" != typeof a2)
      return null;
    const c2 = c(a2).toString(), m = this._symbolCache.get(c2);
    if (m)
      return m.catch(() => {
        this._symbolCache.pop(c2);
      }), m;
    const f2 = a2.split(";"), h2 = [], y2 = [];
    for (const r2 of f2)
      if (r2)
        if (r2.includes("po:")) {
          const t2 = r2.substr(3).split("|");
          if (3 === t2.length) {
            const s4 = t2[0], o2 = t2[1];
            let i2 = t2[2];
            if ("DashTemplate" === o2)
              i2 = i2.split(" ").map((e2) => Number(e2));
            else if ("Color" === o2) {
              const t3 = new l(i2).toRgba();
              i2 = [t3[0], t3[1], t3[2], 255 * t3[3]];
            } else
              i2 = Number(i2);
            y2.push({ primitiveName: s4, propertyName: o2, value: i2 });
          }
        } else if (r2.includes("|")) {
          for (const e2 of r2.split("|"))
            if (this._itemNames.has(e2)) {
              h2.push(e2);
              break;
            }
        } else
          this._itemNames.has(r2) && h2.push(r2);
    const u2 = !r(t.geometry) || !t.geometry.hasZ && "point" === t.geometry.type, p2 = this._cimPartsToCIMSymbol(h2, y2, u2, s3);
    return this._symbolCache.put(c2, p2, 1), p2;
  }
  async fetchResources(e2) {
    if (this._dictionaryPromise)
      return this._dictionaryPromise;
    if (!this.url)
      return void f.error("no valid URL!");
    const o = U(this.url + "/resources/styles/dictionary-info.json", { responseType: "json", query: { f: "json" }, signal: r(e2) ? e2.signal : null }), [{ data: i }] = await Promise.all([o, a()]);
    if (!i)
      throw this._dictionaryPromise = null, new s2("esri.renderers.DictionaryRenderer", "Bad dictionary data!");
    const n2 = i.expression, l2 = i.authoringInfo;
    this._refSymbolUrlTemplate = this.url + "/" + i.cimRefTemplateUrl, this._itemNames = new Set(i.itemsNames), this._symbolFields = l2.symbol;
    const m = {};
    if (this.config) {
      const e3 = this.config;
      for (const t in e3)
        m[t] = e3[t];
    }
    if (l2.configuration)
      for (const t of l2.configuration)
        m.hasOwnProperty(t.name) || (m[t.name] = t.value);
    const h2 = [];
    if (r(e2) && e2.fields && this.fieldMap)
      for (const t of this._symbolFields) {
        const s3 = this.fieldMap[t], o2 = e2.fields.filter((e3) => e3.name === s3);
        o2.length > 0 && h2.push({ ...o2[0], name: t });
      }
    return this._dictionaryPromise = n(n2, r(e2) ? e2.spatialReference : null, h2, m).then((e3) => {
      const t = { scale: 0 };
      return (s3, o2) => {
        const i2 = e3.repurposeFeature({ geometry: null, attributes: s3 });
        return t.scale = r(o2) ? o2.scale : void 0, e3.evaluate({ $feature: i2, $view: t });
      };
    }).catch((e3) => (f.error("Creating dictinoary expression failed:", e3), null)), this._dictionaryPromise;
  }
  async _cimPartsToCIMSymbol(e2, t, s3, o) {
    const i = new Array(e2.length);
    for (let l2 = 0; l2 < e2.length; l2++)
      i[l2] = this._getSymbolPart(e2[l2], o);
    const r2 = await Promise.all(i), n2 = this.fieldMap;
    for (const l2 of r2)
      u(l2, n2);
    return new d({ data: this._combineSymbolParts(r2, t, s3) });
  }
  async _getSymbolPart(e2, s3) {
    if (this._ongoingRequests.has(e2))
      return this._ongoingRequests.get(e2).then((e3) => e3.data);
    const o = this._refSymbolUrlTemplate.replace(/\{itemName\}/gi, e2), i = U(o, { responseType: "json", query: { f: "json" }, ...s3 });
    this._ongoingRequests.set(e2, i);
    try {
      return (await i).data;
    } catch (r2) {
      throw this._ongoingRequests.delete(e2), r2;
    }
  }
  _combineSymbolParts(e2, t, s3) {
    if (!e2 || 0 === e2.length)
      return null;
    const o = { ...e2[0] };
    if (e2.length > 1) {
      o.symbolLayers = [];
      for (const t2 of e2) {
        const e3 = t2;
        o.symbolLayers.unshift(...e3.symbolLayers);
      }
    }
    return s3 && (o.callout = h), { type: "CIMSymbolReference", symbol: o, primitiveOverrides: t };
  }
};
function u(e2, t) {
  if (!e2)
    return;
  const s3 = e2.symbolLayers;
  if (!s3)
    return;
  let o = s3.length;
  for (; o--; ) {
    const e3 = s3[o];
    if (e3 && false !== e3.enable && "CIMVectorMarker" === e3.type)
      p(e3, t);
  }
}
function p(e2, t) {
  const s3 = e2.markerGraphics;
  if (s3)
    for (const o of s3) {
      if (!o)
        continue;
      const e3 = o.symbol;
      if (e3)
        switch (e3.type) {
          case "CIMPointSymbol":
          case "CIMLineSymbol":
          case "CIMPolygonSymbol":
            u(e3, t);
            break;
          case "CIMTextSymbol":
            e3.fieldMap = t;
        }
    }
}

export {
  y
};
//# sourceMappingURL=chunk-P6I5J7W6.js.map
