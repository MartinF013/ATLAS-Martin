import {
  m as m3,
  p as p3
} from "./chunk-HTS3HEEU.js";
import {
  I,
  e as e6,
  n as n4,
  r as r4
} from "./chunk-7CXXTQLM.js";
import {
  n as n3,
  r as r3
} from "./chunk-EPNT7GPS.js";
import {
  e as e5,
  t as t3
} from "./chunk-MLAOYRDT.js";
import {
  W,
  Z
} from "./chunk-53KI6WDE.js";
import {
  B,
  S as S2,
  y
} from "./chunk-DLM6NKXW.js";
import {
  e as e4
} from "./chunk-TQLSOIYV.js";
import {
  e as e3
} from "./chunk-YFBAFAZ2.js";
import {
  e as e2
} from "./chunk-LUU3J646.js";
import {
  p as p2
} from "./chunk-3NPGGTI6.js";
import {
  l as l2
} from "./chunk-ZN2MGN4S.js";
import {
  An,
  Bn,
  Un,
  bn,
  qn
} from "./chunk-PZWU5EHT.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import {
  n as n2
} from "./chunk-U7B2WKBH.js";
import {
  h
} from "./chunk-ASC3X65B.js";
import {
  O,
  p
} from "./chunk-RN2KRYDN.js";
import {
  a as a2
} from "./chunk-TMBOFNWA.js";
import {
  D,
  E as E2,
  m as m2,
  u as u4
} from "./chunk-56RHM4A6.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  J,
  L,
  S,
  Y,
  c,
  e,
  f as f2,
  g,
  l,
  m,
  o,
  q,
  r as r2,
  s as s2,
  u as u3
} from "./chunk-PKZEO23A.js";
import {
  n,
  t as t2,
  u as u2
} from "./chunk-AIRC226G.js";
import {
  T,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  E
} from "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  M,
  a,
  d2 as d,
  f2 as f,
  r,
  t,
  u2 as u,
  x
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/support/dito.js
var t4 = 1e-6;
var n5 = [0, 0, 0];
var r5 = [0, 0, 0];
function i(t5, i2) {
  const { data: s5, size: e8 } = t5, a5 = s5.length / e8;
  if (a5 <= 0)
    return;
  const c4 = new H(t5);
  L2(n5, c4.minProj, c4.maxProj), R(n5, n5, 0.5), Q(r5, c4.maxProj, c4.minProj);
  const h4 = K(r5), u6 = new J2();
  u6.quality = h4, a5 < 14 && (t5 = { data: new Float64Array(c4.buffer, 112, 42), size: 3 });
  const f5 = [0, 0, 0], m5 = [0, 0, 0], P3 = [0, 0, 0], j2 = [0, 0, 0], b3 = [0, 0, 0], x3 = [0, 0, 0], I5 = [0, 0, 0];
  switch (o2(c4, t5, I5, f5, m5, P3, j2, b3, x3, u6)) {
    case 1:
      return void z(n5, r5, i2);
    case 2:
      return void G(t5, j2, i2);
  }
  l3(t5, I5, f5, m5, P3, j2, b3, x3, u6), O2(t5, u6.b0, u6.b1, u6.b2, Y2, _);
  const N3 = [0, 0, 0];
  Q(N3, _, Y2), u6.quality = K(N3), u6.quality < h4 ? C(u6.b0, u6.b1, u6.b2, Y2, _, N3, i2) : z(n5, r5, i2);
}
function o2(n6, r6, i2, o3, s5, e8, a5, c4, h4, u6) {
  if (P(n6, o3, s5), $(o3, s5) < t4)
    return 1;
  Q(a5, o3, s5), X(a5, a5);
  return b2(r6, o3, a5, e8) < t4 ? 2 : (Q(c4, s5, e8), X(c4, c4), Q(h4, e8, o3), X(h4, h4), W2(i2, c4, a5), X(i2, i2), d2(r6, i2, a5, c4, h4, u6), 0);
}
var s3 = [0, 0, 0];
var e7 = [0, 0, 0];
var a3 = [0, 0, 0];
var c2 = [0, 0, 0];
var h2 = [0, 0, 0];
var u5 = [0, 0, 0];
var f3 = [0, 0, 0];
var m4 = [0, 0, 0];
function l3(t5, n6, r6, i2, o3, l4, P3, j2, b3) {
  I2(t5, n6, r6, s3, e7), void 0 !== s3[0] && (Q(a3, s3, r6), X(a3, a3), Q(c2, s3, i2), X(c2, c2), Q(h2, s3, o3), X(h2, h2), W2(u5, c2, l4), X(u5, u5), W2(f3, h2, P3), X(f3, f3), W2(m4, a3, j2), X(m4, m4), d2(t5, u5, l4, c2, a3, b3), d2(t5, f3, P3, h2, c2, b3), d2(t5, m4, j2, a3, h2, b3)), void 0 !== e7[0] && (Q(a3, e7, r6), X(a3, a3), Q(c2, e7, i2), X(c2, c2), Q(h2, e7, o3), X(h2, h2), W2(u5, c2, l4), X(u5, u5), W2(f3, h2, P3), X(f3, f3), W2(m4, a3, j2), X(m4, m4), d2(t5, u5, l4, c2, a3, b3), d2(t5, f3, P3, h2, c2, b3), d2(t5, m4, j2, a3, h2, b3));
}
function P(t5, n6, r6) {
  let i2 = $(t5.maxVert[0], t5.minVert[0]), o3 = 0;
  for (let s5 = 1; s5 < 7; ++s5) {
    const n7 = $(t5.maxVert[s5], t5.minVert[s5]);
    n7 > i2 && (i2 = n7, o3 = s5);
  }
  U2(n6, t5.minVert[o3]), U2(r6, t5.maxVert[o3]);
}
var j = [0, 0, 0];
function b2(t5, n6, r6, i2) {
  const { data: o3, size: s5 } = t5;
  let e8 = Number.NEGATIVE_INFINITY, a5 = 0;
  for (let c4 = 0; c4 < o3.length; c4 += s5) {
    j[0] = o3[c4] - n6[0], j[1] = o3[c4 + 1] - n6[1], j[2] = o3[c4 + 2] - n6[2];
    const t6 = r6[0] * j[0] + r6[1] * j[1] + r6[2] * j[2], i3 = r6[0] * r6[0] + r6[1] * r6[1] + r6[2] * r6[2], s6 = j[0] * j[0] + j[1] * j[1] + j[2] * j[2] - t6 * t6 / i3;
    s6 > e8 && (e8 = s6, a5 = c4);
  }
  return U2(i2, o3, a5), e8;
}
var x2 = [0, 0];
function I2(n6, r6, i2, o3, s5) {
  T2(n6, r6, x2, s5, o3);
  const e8 = tt(i2, r6);
  x2[1] - t4 <= e8 && (o3[0] = void 0), x2[0] + t4 >= e8 && (s5[0] = void 0);
}
var N = [0, 0, 0];
var V = [0, 0, 0];
var y2 = [0, 0, 0];
var q2 = [0, 0, 0];
var w = [0, 0, 0];
var A = [0, 0, 0];
function d2(n6, r6, i2, o3, s5, e8) {
  if (Z2(r6) < t4)
    return;
  W2(N, i2, r6), W2(V, o3, r6), W2(y2, s5, r6), F(n6, r6, x2), w[1] = x2[0], q2[1] = x2[1], A[1] = q2[1] - w[1];
  const a5 = [i2, o3, s5], c4 = [N, V, y2];
  for (let t5 = 0; t5 < 3; ++t5) {
    F(n6, a5[t5], x2), w[0] = x2[0], q2[0] = x2[1], F(n6, c4[t5], x2), w[2] = x2[0], q2[2] = x2[1], A[0] = q2[0] - w[0], A[2] = q2[2] - w[2];
    const i3 = K(A);
    i3 < e8.quality && (U2(e8.b0, a5[t5]), U2(e8.b1, r6), U2(e8.b2, c4[t5]), e8.quality = i3);
  }
}
var M2 = [0, 0, 0];
function F(t5, n6, r6) {
  const { data: i2, size: o3 } = t5;
  r6[0] = Number.POSITIVE_INFINITY, r6[1] = Number.NEGATIVE_INFINITY;
  for (let s5 = 0; s5 < i2.length; s5 += o3) {
    const t6 = i2[s5] * n6[0] + i2[s5 + 1] * n6[1] + i2[s5 + 2] * n6[2];
    r6[0] = Math.min(r6[0], t6), r6[1] = Math.max(r6[1], t6);
  }
}
function T2(t5, n6, r6, i2, o3) {
  const { data: s5, size: e8 } = t5;
  U2(i2, s5), U2(o3, i2), r6[0] = tt(M2, n6), r6[1] = r6[0];
  for (let a5 = e8; a5 < s5.length; a5 += e8) {
    const t6 = s5[a5] * n6[0] + s5[a5 + 1] * n6[1] + s5[a5 + 2] * n6[2];
    t6 < r6[0] && (r6[0] = t6, U2(i2, s5, a5)), t6 > r6[1] && (r6[1] = t6, U2(o3, s5, a5));
  }
}
function z(t5, n6, r6) {
  U2(r6.center, t5), R(r6.halfSize, n6, 0.5), r6.quaternion[0] = 0, r6.quaternion[1] = 0, r6.quaternion[2] = 0, r6.quaternion[3] = 1;
}
var E3 = [0, 0, 0];
var v = [0, 0, 0];
var g2 = [0, 0, 0];
var Y2 = [0, 0, 0];
var _ = [0, 0, 0];
var S3 = [0, 0, 0];
function G(n6, r6, i2) {
  U2(E3, r6), Math.abs(r6[0]) > Math.abs(r6[1]) && Math.abs(r6[0]) > Math.abs(r6[2]) ? E3[0] = 0 : Math.abs(r6[1]) > Math.abs(r6[2]) ? E3[1] = 0 : E3[2] = 0, Z2(E3) < t4 && (E3[0] = E3[1] = E3[2] = 1), W2(v, r6, E3), X(v, v), W2(g2, r6, v), X(g2, g2), O2(n6, r6, v, g2, Y2, _), Q(S3, _, Y2), C(r6, v, g2, Y2, _, S3, i2);
}
function O2(t5, n6, r6, i2, o3, s5) {
  F(t5, n6, x2), o3[0] = x2[0], s5[0] = x2[1], F(t5, r6, x2), o3[1] = x2[0], s5[1] = x2[1], F(t5, i2, x2), o3[2] = x2[0], s5[2] = x2[1];
}
var p4 = [0, 0, 0];
var B2 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
var k2 = [0, 0, 0];
function C(t5, n6, r6, i2, o3, s5, e8) {
  B2[0] = t5[0], B2[1] = t5[1], B2[2] = t5[2], B2[3] = n6[0], B2[4] = n6[1], B2[5] = n6[2], B2[6] = r6[0], B2[7] = r6[1], B2[8] = r6[2], nt(e8.quaternion, B2), L2(k2, i2, o3), R(k2, k2, 0.5), R(e8.center, t5, k2[0]), R(p4, n6, k2[1]), L2(e8.center, e8.center, p4), R(p4, r6, k2[2]), L2(e8.center, e8.center, p4), R(e8.halfSize, s5, 0.5);
}
var D2 = 7;
var H = class {
  constructor(t5) {
    this.minVert = new Array(D2), this.maxVert = new Array(D2);
    const n6 = 64 * D2;
    this.buffer = new ArrayBuffer(n6);
    let r6 = 0;
    this.minProj = new Float64Array(this.buffer, r6, D2), r6 += 8 * D2, this.maxProj = new Float64Array(this.buffer, r6, D2), r6 += 8 * D2;
    for (let a5 = 0; a5 < D2; ++a5)
      this.minVert[a5] = new Float64Array(this.buffer, r6, 3), r6 += 24;
    for (let a5 = 0; a5 < D2; ++a5)
      this.maxVert[a5] = new Float64Array(this.buffer, r6, 3), r6 += 24;
    for (let a5 = 0; a5 < D2; ++a5)
      this.minProj[a5] = Number.POSITIVE_INFINITY, this.maxProj[a5] = Number.NEGATIVE_INFINITY;
    const i2 = new Array(D2), o3 = new Array(D2), { data: s5, size: e8 } = t5;
    for (let a5 = 0; a5 < s5.length; a5 += e8) {
      let t6 = s5[a5];
      t6 < this.minProj[0] && (this.minProj[0] = t6, i2[0] = a5), t6 > this.maxProj[0] && (this.maxProj[0] = t6, o3[0] = a5), t6 = s5[a5 + 1], t6 < this.minProj[1] && (this.minProj[1] = t6, i2[1] = a5), t6 > this.maxProj[1] && (this.maxProj[1] = t6, o3[1] = a5), t6 = s5[a5 + 2], t6 < this.minProj[2] && (this.minProj[2] = t6, i2[2] = a5), t6 > this.maxProj[2] && (this.maxProj[2] = t6, o3[2] = a5), t6 = s5[a5] + s5[a5 + 1] + s5[a5 + 2], t6 < this.minProj[3] && (this.minProj[3] = t6, i2[3] = a5), t6 > this.maxProj[3] && (this.maxProj[3] = t6, o3[3] = a5), t6 = s5[a5] + s5[a5 + 1] - s5[a5 + 2], t6 < this.minProj[4] && (this.minProj[4] = t6, i2[4] = a5), t6 > this.maxProj[4] && (this.maxProj[4] = t6, o3[4] = a5), t6 = s5[a5] - s5[a5 + 1] + s5[a5 + 2], t6 < this.minProj[5] && (this.minProj[5] = t6, i2[5] = a5), t6 > this.maxProj[5] && (this.maxProj[5] = t6, o3[5] = a5), t6 = s5[a5] - s5[a5 + 1] - s5[a5 + 2], t6 < this.minProj[6] && (this.minProj[6] = t6, i2[6] = a5), t6 > this.maxProj[6] && (this.maxProj[6] = t6, o3[6] = a5);
    }
    for (let a5 = 0; a5 < D2; ++a5) {
      let t6 = i2[a5];
      U2(this.minVert[a5], s5, t6), t6 = o3[a5], U2(this.maxVert[a5], s5, t6);
    }
  }
};
var J2 = class {
  constructor() {
    this.b0 = [1, 0, 0], this.b1 = [0, 1, 0], this.b2 = [0, 0, 1], this.quality = 0;
  }
};
function K(t5) {
  return t5[0] * t5[1] + t5[0] * t5[2] + t5[1] * t5[2];
}
function L2(t5, n6, r6) {
  t5[0] = n6[0] + r6[0], t5[1] = n6[1] + r6[1], t5[2] = n6[2] + r6[2];
}
function Q(t5, n6, r6) {
  t5[0] = n6[0] - r6[0], t5[1] = n6[1] - r6[1], t5[2] = n6[2] - r6[2];
}
function R(t5, n6, r6) {
  t5[0] = n6[0] * r6, t5[1] = n6[1] * r6, t5[2] = n6[2] * r6;
}
function U2(t5, n6, r6 = 0) {
  t5[0] = n6[r6 + 0], t5[1] = n6[r6 + 1], t5[2] = n6[r6 + 2];
}
function W2(t5, n6, r6) {
  const i2 = n6[0], o3 = n6[1], s5 = n6[2], e8 = r6[0], a5 = r6[1], c4 = r6[2];
  t5[0] = o3 * c4 - s5 * a5, t5[1] = s5 * e8 - i2 * c4, t5[2] = i2 * a5 - o3 * e8;
}
function X(t5, n6) {
  const r6 = n6[0] * n6[0] + n6[1] * n6[1] + n6[2] * n6[2];
  if (r6 > 0) {
    const i2 = 1 / Math.sqrt(r6);
    t5[0] = n6[0] * i2, t5[1] = n6[1] * i2, t5[2] = n6[2] * i2;
  }
}
function Z2(t5) {
  return t5[0] * t5[0] + t5[1] * t5[1] + t5[2] * t5[2];
}
function $(t5, n6) {
  const r6 = n6[0] - t5[0], i2 = n6[1] - t5[1], o3 = n6[2] - t5[2];
  return r6 * r6 + i2 * i2 + o3 * o3;
}
function tt(t5, n6) {
  return t5[0] * n6[0] + t5[1] * n6[1] + t5[2] * n6[2];
}
function nt(t5, n6) {
  const r6 = n6[0] + n6[4] + n6[8];
  if (r6 > 0) {
    let i2 = Math.sqrt(r6 + 1);
    t5[3] = 0.5 * i2, i2 = 0.5 / i2, t5[0] = (n6[5] - n6[7]) * i2, t5[1] = (n6[6] - n6[2]) * i2, t5[2] = (n6[1] - n6[3]) * i2;
  } else {
    let r7 = 0;
    n6[4] > n6[0] && (r7 = 1), n6[8] > n6[3 * r7 + r7] && (r7 = 2);
    const i2 = (r7 + 1) % 3, o3 = (r7 + 2) % 3;
    let s5 = Math.sqrt(n6[3 * r7 + r7] - n6[3 * i2 + i2] - n6[3 * o3 + o3] + 1);
    t5[r7] = 0.5 * s5, s5 = 0.5 / s5, t5[3] = (n6[3 * i2 + o3] - n6[3 * o3 + i2]) * s5, t5[i2] = (n6[3 * i2 + r7] + n6[3 * r7 + i2]) * s5, t5[o3] = (n6[3 * o3 + r7] + n6[3 * r7 + o3]) * s5;
  }
}

// node_modules/@arcgis/core/views/3d/support/orientedBoundingBox.js
var w3 = e4();
var A2 = n();
var B3 = n();
var I3 = n2();
var C2 = e2();
var D3 = class {
  constructor(t5) {
    const e8 = 56, a5 = 0, n6 = 24, r6 = 36, s5 = t5 * e8;
    this.buffer = new ArrayBuffer(s5), this.obbs = new Array(t5);
    for (let o3 = 0; o3 < t5; o3++)
      this.obbs[o3] = { center: u2(this.buffer, e8 * o3 + a5), halfSize: e5(this.buffer, e8 * o3 + n6), quaternion: n4(this.buffer, e8 * o3 + r6) };
  }
};
function E4(t5 = [0, 0, 0], e8 = [-1, -1, -1], a5 = [0, 0, 0, 1]) {
  return { center: t2(t5), halfSize: t3(e8), quaternion: r4(a5) };
}
function F2(t5) {
  return E4(t5.center, t5.halfSize, t5.quaternion);
}
function G2(t5, e8) {
  r2(e8.center, t5.center), r2(e8.halfSize, t5.halfSize), B(e8.quaternion, t5.quaternion);
}
function H2(t5, e8) {
  return e8 = e8 || E4(), i(t5, e8), e8;
}
function J3(t5, e8) {
  const a5 = W(e8, t5.center), n6 = U3(t5, Z(e8));
  return a5 > n6 ? 1 : a5 < -n6 ? -1 : 0;
}
function K2(e8, a5) {
  a5 || (a5 = a2());
  const n6 = p2(C2, e8.quaternion), r6 = e8.halfSize[0] * Math.abs(n6[0]) + e8.halfSize[1] * Math.abs(n6[3]) + e8.halfSize[2] * Math.abs(n6[6]), s5 = e8.halfSize[0] * Math.abs(n6[1]) + e8.halfSize[1] * Math.abs(n6[4]) + e8.halfSize[2] * Math.abs(n6[7]), f5 = e8.halfSize[0] * Math.abs(n6[2]) + e8.halfSize[1] * Math.abs(n6[5]) + e8.halfSize[2] * Math.abs(n6[8]);
  return a5[0] = e8.center[0] - r6, a5[1] = e8.center[1] - s5, a5[2] = e8.center[2] - f5, a5[3] = e8.center[0] + r6, a5[4] = e8.center[1] + s5, a5[5] = e8.center[2] + f5, a5;
}
function L3(t5, e8) {
  return W(e8, t5.center) - U3(t5, Z(e8));
}
function N2(t5, e8) {
  return W(e8, t5.center) + U3(t5, Z(e8));
}
function O4(t5, e8) {
  return J3(t5, e8[0]) <= 0 && J3(t5, e8[1]) <= 0 && J3(t5, e8[2]) <= 0 && J3(t5, e8[3]) <= 0 && J3(t5, e8[4]) <= 0 && J3(t5, e8[5]) <= 0;
}
function P2(t5, e8, a5, n6 = 0) {
  S2(w3, t5.quaternion), e(A2, e8, t5.center);
  const s5 = S(A2, A2, w3), f5 = S(B3, a5, w3);
  let o3 = -1 / 0, i2 = 1 / 0;
  for (let r6 = 0; r6 < 3; r6++)
    if (Math.abs(f5[r6]) > 1e-6) {
      const e9 = (n6 + t5.halfSize[r6] - s5[r6]) / f5[r6], a6 = (-n6 - t5.halfSize[r6] - s5[r6]) / f5[r6];
      o3 = Math.max(o3, Math.min(e9, a6)), i2 = Math.min(i2, Math.max(e9, a6));
    } else if (s5[r6] > t5.halfSize[r6] + n6 || s5[r6] < -t5.halfSize[r6] - n6)
      return false;
  return o3 <= i2;
}
var T3 = (() => {
  const t5 = new Int8Array(162);
  let e8 = 0;
  const a5 = (a6) => {
    for (let n6 = 0; n6 < a6.length; n6++)
      t5[e8 + n6] = a6[n6];
    e8 += 6;
  };
  return a5([6, 2, 3, 1, 5, 4]), a5([0, 2, 3, 1, 5, 4]), a5([0, 2, 3, 7, 5, 4]), a5([0, 1, 3, 2, 6, 4]), a5([0, 1, 3, 2, 0, 0]), a5([0, 1, 5, 7, 3, 2]), a5([0, 1, 3, 7, 6, 4]), a5([0, 1, 3, 7, 6, 2]), a5([0, 1, 5, 7, 6, 2]), a5([0, 1, 5, 4, 6, 2]), a5([0, 1, 5, 4, 0, 0]), a5([0, 1, 3, 7, 5, 4]), a5([0, 2, 6, 4, 0, 0]), a5([0, 0, 0, 0, 0, 0]), a5([1, 3, 7, 5, 0, 0]), a5([2, 3, 7, 6, 4, 0]), a5([2, 3, 7, 6, 0, 0]), a5([2, 3, 1, 5, 7, 6]), a5([0, 1, 5, 7, 6, 2]), a5([0, 1, 5, 7, 6, 4]), a5([0, 1, 3, 7, 6, 4]), a5([4, 5, 7, 6, 2, 0]), a5([4, 5, 7, 6, 0, 0]), a5([4, 5, 1, 3, 7, 6]), a5([0, 2, 3, 7, 5, 4]), a5([6, 2, 3, 7, 5, 4]), a5([6, 2, 3, 1, 5, 4]), t5;
})();
function U3(t5, e8) {
  S2(w3, t5.quaternion), S(A2, e8, w3);
  const a5 = t5.halfSize;
  return Math.abs(A2[0] * a5[0]) + Math.abs(A2[1] * a5[1]) + Math.abs(A2[2] * a5[2]);
}
function V2(t5, e8) {
  for (let a5 = 0; a5 < 8; ++a5) {
    const n6 = e8[a5];
    n6[0] = 1 & a5 ? -t5.halfSize[0] : t5.halfSize[0], n6[1] = 2 & a5 ? -t5.halfSize[1] : t5.halfSize[1], n6[2] = 4 & a5 ? -t5.halfSize[2] : t5.halfSize[2], S(n6, n6, t5.quaternion), u3(n6, n6, t5.center);
  }
}
function W3(t5) {
  return Y(t5.halfSize);
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SProjectionUtil.js
function a4(o3, n6, a5, s5) {
  const c4 = h3(o3, n6, a5), i2 = e3();
  return qn(a5, c4, i2, s5), i2;
}
var s4 = 1;
var c3 = 5 - s4;
function h3(t5, r6, a5) {
  const h4 = n(), i2 = t5[3], e8 = 2 ** (Math.ceil(Math.log(i2) * Math.LOG2E / c3) * c3 + s4);
  if (a5.isGeographic) {
    const o3 = e8 / p(a5).radius * 180 / Math.PI, r7 = Math.round(t5[1] / o3), s5 = Math.max(-90, Math.min(90, r7 * o3)), c4 = o3 / Math.cos((Math.abs(s5) - o3 / 2) / 180 * Math.PI), i3 = Math.round(t5[0] / c4) * c4;
    h4[0] = i3, h4[1] = s5;
  } else {
    const o3 = Math.round(t5[0] / e8), r7 = Math.round(t5[1] / e8);
    h4[0] = o3 * e8, h4[1] = r7 * e8;
  }
  const M3 = t5[2] + r6, m5 = Math.round(M3 / e8);
  return h4[2] = m5 * e8, h4;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SUtil.js
function ae(e8) {
  return e8 && parseInt(e8.substring(e8.lastIndexOf("/") + 1, e8.length), 10);
}
function ie(e8) {
  var _a;
  if (a("disable-feature:i3s-draco") || !e8)
    return false;
  for (const t5 of e8)
    for (const e9 of t5.geometryBuffers)
      if ("draco" === ((_a = e9.compressedAttributes) == null ? void 0 : _a.encoding))
        return true;
  return false;
}
function se(e8, t5, r6, n6, o3, a5) {
  const i2 = t5 !== n6;
  o3.traverse(r6, (r7) => {
    let o4 = r7.mbs;
    i2 && (o4 = pe, bn(r7.mbs, n6, o4, t5));
    return me(e8, o4) !== he.OUTSIDE && (a5(r7), true);
  });
}
function ce(e8, t5, r6) {
  let n6 = 0, o3 = 0;
  for (let a5 = 0; a5 < t5.length && n6 < e8.length; a5++)
    e8[n6] === t5[a5] && (r6(a5) && (e8[o3] = e8[n6], o3++), n6++);
  e8.length = o3;
}
function le(e8, r6, n6) {
  let o3 = 0, a5 = 0;
  for (; o3 < n6.length; ) {
    M(e8, n6[o3]) >= 0 === r6 && (n6[a5] = n6[o3], a5++), o3++;
  }
  n6.length = a5;
}
var fe = u4();
function ue(e8, t5) {
  if (0 === t5.rotationScale[1] && 0 === t5.rotationScale[2] && 0 === t5.rotationScale[3] && 0 === t5.rotationScale[5] && 0 === t5.rotationScale[6] && 0 === t5.rotationScale[7])
    return fe[0] = (e8[0] - t5.position[0]) / t5.rotationScale[0], fe[1] = (e8[1] - t5.position[1]) / t5.rotationScale[4], fe[2] = (e8[2] - t5.position[0]) / t5.rotationScale[0], fe[3] = (e8[3] - t5.position[1]) / t5.rotationScale[4], fe;
}
var pe = n2();
var he;
function me(e8, t5) {
  const r6 = t5[0], n6 = t5[1], o3 = t5[3], a5 = e8[0] - r6, i2 = r6 - e8[2], s5 = e8[1] - n6, c4 = n6 - e8[3], l4 = Math.max(a5, i2, 0), f5 = Math.max(s5, c4, 0), u6 = l4 * l4 + f5 * f5;
  if (u6 > o3 * o3)
    return he.OUTSIDE;
  if (u6 > 0)
    return he.INTERSECTS_CENTER_OUTSIDE;
  return -Math.max(a5, i2, s5, c4) > o3 ? he.INSIDE : he.INTERSECTS_CENTER_INSIDE;
}
function ye(e8, t5, r6) {
  const n6 = [], o3 = r6 && r6.missingFields, a5 = r6 && r6.originalFields;
  for (const i2 of e8) {
    const e9 = i2.toLowerCase();
    let r7 = false;
    for (const o4 of t5)
      if (e9 === o4.name.toLowerCase()) {
        n6.push(o4.name), r7 = true, a5 && a5.push(i2);
        break;
      }
    !r7 && o3 && o3.push(i2);
  }
  return n6;
}
async function Se(e8, t5, n6, a5, c4) {
  if (0 === t5.length)
    return [];
  const l4 = e8.attributeStorageInfo;
  if (r(e8.associatedLayer))
    try {
      return await be(e8.associatedLayer, t5, n6, a5);
    } catch (f5) {
      if (e8.associatedLayer.loaded)
        throw f5;
    }
  if (l4) {
    const i2 = ge(t5, n6, c4);
    if (t(i2))
      throw new s("scenelayer:features-not-loaded", "Tried to query attributes for unloaded features");
    const f5 = e8.parsedUrl.path, u6 = await Promise.all(i2.map((e9) => Ee(f5, l4, e9.node, e9.indices, a5).then((t6) => {
      for (let r6 = 0; r6 < e9.graphics.length; r6++) {
        const n7 = e9.graphics[r6], o3 = t6[r6];
        if (n7.attributes)
          for (const e10 in n7.attributes)
            e10 in o3 || (o3[e10] = n7.attributes[e10]);
        n7.attributes = o3;
      }
      return e9.graphics;
    })));
    return x(u6);
  }
  throw new s("scenelayer:no-attribute-source", "This scene layer does not have a source for attributes available");
}
function ge(e8, t5, r6) {
  const n6 = /* @__PURE__ */ new Map(), o3 = [], a5 = r6();
  for (const i2 of e8) {
    const e9 = i2.attributes[t5];
    for (let t6 = 0; t6 < a5.length; t6++) {
      const r7 = a5[t6], s5 = r7.featureIds.indexOf(e9);
      if (s5 >= 0) {
        let e10 = n6.get(r7.node);
        e10 || (e10 = { node: r7.node, indices: [], graphics: [] }, o3.push(e10), n6.set(r7.node, e10)), e10.indices.push(s5), e10.graphics.push(i2);
        for (let r8 = t6; r8 > 0; r8--)
          a5[r8] = a5[r8 - 1];
        a5[0] = r7;
        break;
      }
    }
  }
  return o3;
}
async function be(e8, t5, r6, n6) {
  t5.sort((e9, t6) => e9.attributes[r6] - t6.attributes[r6]);
  const o3 = t5.map((e9) => e9.attributes[r6]), a5 = [], i2 = ye(n6, e8.fields, { originalFields: a5 }), s5 = await we(e8, o3, i2);
  for (let c4 = 0; c4 < t5.length; c4++) {
    const e9 = t5[c4], r7 = s5[c4], n7 = {};
    if (e9.attributes)
      for (const t6 in e9.attributes)
        n7[t6] = e9.attributes[t6];
    for (let t6 = 0; t6 < a5.length; t6++)
      n7[a5[t6]] = r7[i2[t6]];
    e9.attributes = n7;
  }
  return t5;
}
function we(e8, t5, a5) {
  const i2 = e8.capabilities.query.maxRecordCount;
  if (null != i2 && t5.length > i2) {
    const o3 = d(t5, i2);
    return Promise.all(o3.map((t6) => we(e8, t6, a5))).then(x);
  }
  const s5 = new b({ objectIds: t5, outFields: a5, orderByFields: [e8.objectIdField] });
  return e8.queryFeatures(s5).then((e9) => {
    if (e9 && e9.features && e9.features.length === t5.length)
      return e9.features.map((e10) => e10.attributes);
    throw new s("scenelayer:feature-not-in-associated-layer", "Feature not found in associated feature layer");
  });
}
function Ee(t5, r6, n6, o3, a5) {
  const i2 = [];
  for (const e8 of r6)
    if (e8 && a5.includes(e8.name)) {
      const r7 = `${t5}/nodes/${n6.resources.attributes}/attributes/${e8.key}/0`;
      i2.push({ url: r7, storageInfo: e8 });
    }
  return E(i2.map((t6) => U(t6.url, { responseType: "array-buffer" }).then((e8) => I(t6.storageInfo, e8.data)))).then((e8) => {
    const t6 = [];
    for (const r7 of o3) {
      const n7 = {};
      for (let t7 = 0; t7 < e8.length; t7++)
        null != e8[t7].value && (n7[i2[t7].storageInfo.name] = Me(e8[t7].value, r7));
      t6.push(n7);
    }
    return t6;
  });
}
!function(e8) {
  e8[e8.OUTSIDE = 0] = "OUTSIDE", e8[e8.INTERSECTS_CENTER_OUTSIDE = 1] = "INTERSECTS_CENTER_OUTSIDE", e8[e8.INTERSECTS_CENTER_INSIDE = 2] = "INTERSECTS_CENTER_INSIDE", e8[e8.INSIDE = 3] = "INSIDE";
}(he || (he = {}));
var Te = -32768;
var Ie = -(2 ** 31);
function Me(e8, t5) {
  if (!e8)
    return null;
  const r6 = e8[t5];
  if (u(e8))
    return r6 === Te ? null : r6;
  if (f(e8))
    return r6 === Ie ? null : r6;
  return r6 != r6 ? null : r6;
}
function ve(e8) {
  const t5 = e8.store.indexCRS || e8.store.geographicCRS, r6 = void 0 === t5 ? e8.store.indexWKT : void 0;
  if (r6) {
    if (!e8.spatialReference)
      throw new s("layerview:no-store-spatial-reference-wkt-index-and-no-layer-spatial-reference", "Found indeWKT in the scene layer store but no layer spatial reference", {});
    if (r6 !== e8.spatialReference.wkt)
      throw new s("layerview:store-spatial-reference-wkt-index-incompatible", "The indeWKT of the scene layer store does not match the WKT of the layer spatial reference", {});
  }
  const n6 = t5 ? new k(ae(t5)) : e8.spatialReference;
  return n6.equals(e8.spatialReference) ? e8.spatialReference : n6;
}
function Re(e8) {
  const t5 = e8.store.vertexCRS || e8.store.projectedCRS, r6 = void 0 === t5 ? e8.store.vertexWKT : void 0;
  if (r6) {
    if (!e8.spatialReference)
      throw new s("layerview:no-store-spatial-reference-wkt-vertex-and-no-layer-spatial-reference", "Found vertexWKT in the scene layer store but no layer spatial reference", {});
    if (r6 !== e8.spatialReference.wkt)
      throw new s("layerview:store-spatial-reference-wkt-vertex-incompatible", "The vertexWKT of the scene layer store does not match the WKT of the layer spatial reference", {});
  }
  const n6 = t5 ? new k(ae(t5)) : e8.spatialReference;
  return n6.equals(e8.spatialReference) ? e8.spatialReference : n6;
}
function xe(e8, t5) {
  return t(t5) ? "@null" : t5 === O(t5) ? "@ECEF" : e8.equals(t5) ? "" : null != t5.wkid ? "@" + t5.wkid : null;
}
function je(e8, t5, r6) {
  if (!An(e8, t5))
    throw new s("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
  if ("local" === r6 && !qe(e8, t5))
    throw new s("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
}
function qe(e8, t5) {
  return e8.equals(t5) || e8.isWGS84 && t5.isWebMercator || e8.isWebMercator && t5.isWGS84;
}
function ze(e8, t5, r6) {
  const n6 = ve(e8), o3 = Re(e8);
  je(n6, t5, r6), je(o3, t5, r6);
}
function Ce(e8) {
  return (null == e8.geometryType || "triangles" === e8.geometryType) && ((null == e8.topology || "PerAttributeArray" === e8.topology) && (null != e8.vertexAttributes && null != e8.vertexAttributes.position));
}
function Ne(e8) {
  if (null == e8.store || null == e8.store.defaultGeometrySchema || !Ce(e8.store.defaultGeometrySchema))
    throw new s("scenelayer:unsupported-geometry-schema", "The geometry schema of this scene layer is not supported.", { url: e8.parsedUrl.path });
}
function ke(e8, t5) {
  ze(e8, t5.spatialReference, t5.viewingMode);
}
function De(e8) {
  return null != e8.geometryType && "points" === e8.geometryType && ((null == e8.topology || "PerAttributeArray" === e8.topology) && ((null == e8.encoding || "" === e8.encoding || "lepcc-xyz" === e8.encoding) && (null != e8.vertexAttributes && null != e8.vertexAttributes.position)));
}
function Ue(e8) {
  if (null == e8.store || null == e8.store.defaultGeometrySchema || !De(e8.store.defaultGeometrySchema))
    throw new s("pointcloud:unsupported-geometry-schema", "The geometry schema of this point cloud scene layer is not supported.", {});
}
function _e(e8, t5) {
  je(e8.spatialReference, t5.spatialReference, t5.viewingMode);
}
function We(e8) {
  return "simple" === e8.type || "class-breaks" === e8.type || "unique-value" === e8.type;
}
function Ae(e8) {
  return "mesh-3d" === e8.type;
}
function Fe(e8) {
  if (null == e8 || !We(e8))
    return true;
  if (("unique-value" === e8.type || "class-breaks" === e8.type) && null == e8.defaultSymbol)
    return true;
  const t5 = e8.getSymbols();
  if (0 === t5.length)
    return true;
  for (const r6 of t5) {
    if (!Ae(r6) || 0 === r6.symbolLayers.length)
      return true;
    for (const e9 of r6.symbolLayers.items)
      if ("fill" !== e9.type || t(e9.material) || t(e9.material.color) || "replace" !== e9.material.colorMixMode)
        return true;
  }
  return false;
}
var Oe = m3({ color: [0, 0, 0, 0], opacity: 0 });
var Ge = class {
  constructor() {
    this.edgeMaterial = null, this.material = null, this.castShadows = true;
  }
};
function Ke(e8) {
  const t5 = new Ge();
  let r6 = false, n6 = false;
  for (const o3 of e8.symbolLayers.items)
    if ("fill" === o3.type && o3.enabled) {
      const e9 = o3.material, a5 = o3.edges;
      if (r(e9) && !r6) {
        const n7 = e9.color, a6 = n3(e9.colorMixMode);
        r(n7) ? t5.material = { color: [n7.r / 255, n7.g / 255, n7.b / 255], alpha: n7.a, colorMixMode: a6 } : t5.material = { color: [1, 1, 1], alpha: 1, colorMixMode: r3.Multiply }, t5.castShadows = o3.castShadows, r6 = true;
      }
      r(a5) && !n6 && (t5.edgeMaterial = p3(a5, {}), n6 = true);
    }
  return t5.material || (t5.material = { color: [1, 1, 1], alpha: 1, colorMixMode: r3.Multiply }), t5;
}
function Le(e8, t5) {
  return (0 | e8) + (0 | t5) | 0;
}
function Be(e8, t5, r6, n6, o3 = 0) {
  n6 === O(n6) ? t5.isGeographic ? at(e8, r6, t5, o3) : ot(e8, r6, t5, o3) : t5.isWGS84 && (n6.isWebMercator || T(n6)) ? He(t5, e8, n6, r6, o3) : t5.isWebMercator && T(n6) ? rt(t5, e8, n6, r6, o3) : e8 === r6 ? (r6.center[2] += o3, Un(r6.center, t5, 0, r6.center, n6, 0, 1)) : (o(r6.center, e8.center[0], e8.center[1], e8.center[2] + o3), Un(r6.center, t5, 0, r6.center, n6, 0, 1), B(r6.quaternion, e8.quaternion), r2(r6.halfSize, e8.halfSize));
}
function Pe(e8, t5, r6, n6, o3) {
  if (B(o3.quaternion, e8.quaternion), n6 === l2.Global) {
    S2(Ze, e8.quaternion), S($e, e8.center, Ze), f2(Qe, $e), m(Ve, Qe, e8.halfSize), J(Ve, Qe, Ve);
    const n7 = s2(Ve);
    u3(Ve, Qe, e8.halfSize);
    const a5 = s2(Ve);
    if (n7 < r6)
      r2(o3.center, e8.center), o($e, r6, r6, r6), u3(o3.halfSize, e8.halfSize, $e);
    else {
      const i2 = a5 > 0 ? 1 + t5 / a5 : 1, s5 = n7 > 0 ? 1 + r6 / n7 : 1, c4 = (s5 + i2) / 2, l4 = (s5 - i2) / 2;
      q(o3.halfSize, Qe, l4), g(o3.halfSize, o3.halfSize, e8.halfSize, c4), q(o3.center, Qe, c4), g(o3.center, o3.center, e8.halfSize, l4), l($e, $e), c(o3.center, o3.center, $e), S(o3.center, o3.center, o3.quaternion);
    }
  } else {
    const n7 = o($e, 0, 0, 1);
    g(o3.center, e8.center, n7, (r6 + t5) / 2), S2(Ze, e8.quaternion), S(n7, n7, Ze), f2(n7, n7), g(o3.halfSize, e8.halfSize, n7, (r6 - t5) / 2);
  }
  return o3;
}
var $e = n();
var Qe = n();
var Ve = n();
var Ze = e4();
function He(e8, t5, r6, n6, o3) {
  r2(et, t5.center), et[2] += o3;
  const a5 = O(r6);
  Un(et, e8, 0, et, a5, 0, 1), nt2(a5, t5, et, r6, n6);
}
var Je = new Float64Array(24);
var Xe = { data: Je, size: 3 };
var Ye = n();
var et = n();
var tt2 = e2();
function rt(e8, t5, r6, n6, o3) {
  r2(et, t5.center), et[2] += o3, nt2(e8, t5, et, r6, n6);
}
function nt2(e8, t5, r6, n6, o3) {
  const a5 = p2(tt2, t5.quaternion);
  for (let i2 = 0; i2 < 8; ++i2) {
    for (let e9 = 0; e9 < 3; ++e9)
      Ye[e9] = t5.halfSize[e9] * (0 != (i2 & 1 << e9) ? -1 : 1);
    for (let e9 = 0; e9 < 3; ++e9) {
      let t6 = r6[e9];
      for (let r7 = 0; r7 < 3; ++r7)
        t6 += Ye[r7] * a5[3 * r7 + e9];
      Je[3 * i2 + e9] = t6;
    }
  }
  Un(Je, e8, 0, Je, n6, 0, 8), H2(Xe, o3);
}
function ot(e8, t5, r6, n6) {
  V2(e8, ht), o(t5.center, e8.center[0], e8.center[1], e8.center[2] + n6), qn(r6, t5.center, ut, O(r6)), o(t5.center, ut[12], ut[13], ut[14]);
  const o3 = 2 * Math.sqrt(1 + ut[0] + ut[5] + ut[10]);
  pt[0] = (ut[6] - ut[9]) / o3, pt[1] = (ut[8] - ut[2]) / o3, pt[2] = (ut[1] - ut[4]) / o3, pt[3] = 0.25 * o3, y(t5.quaternion, pt, e8.quaternion), S2(pt, t5.quaternion);
  let a5 = 0, i2 = 0, s5 = 0;
  for (const c4 of ht)
    c4[2] += n6, Un(c4, r6, 0, c4, O(r6), 0, 1), J(St, c4, t5.center), S(St, St, pt), a5 = Math.max(a5, Math.abs(St[0])), i2 = Math.max(i2, Math.abs(St[1])), s5 = Math.max(s5, Math.abs(St[2]));
  o(t5.halfSize, a5, i2, s5);
}
function at(e8, t5, r6, n6) {
  const o3 = p(r6), a5 = 1 + Math.max(0, n6) / (o3.radius + e8.center[2]);
  o(t5.center, e8.center[0], e8.center[1], e8.center[2] + n6), Un(t5.center, r6, 0, t5.center, O(r6), 0, 1), B(t5.quaternion, e8.quaternion), S2(pt, e8.quaternion), o(St, 0, 0, 1), S(St, St, pt), o(St, e8.halfSize[0] * Math.abs(St[0]), e8.halfSize[1] * Math.abs(St[1]), e8.halfSize[2] * Math.abs(St[2])), q(St, St, o3.inverseFlattening), u3(t5.halfSize, e8.halfSize, St), q(t5.halfSize, t5.halfSize, a5);
}
function it(e8, t5, r6, n6, o3, a5) {
  if (!a5 || 0 === a5.length || t(t5))
    return null;
  const c4 = a4(e8.mbs, o3, r6, t5);
  let l4;
  h(bt, c4);
  const f5 = () => {
    if (!l4)
      if (l4 = ht, D(dt), r(e8.serviceObb)) {
        Be(e8.serviceObb, r6, yt, t5, o3), V2(yt, l4);
        for (const e9 of l4)
          L(e9, e9, bt), m2(dt, e9);
      } else {
        const n7 = e8.mbs, a6 = n7[3];
        Bn(n7, r6, St, t5), L(St, St, bt), St[2] += o3;
        for (let e9 = 0; e9 < 8; ++e9) {
          const t6 = 1 & e9 ? a6 : -a6, r7 = 2 & e9 ? a6 : -a6, n8 = 4 & e9 ? a6 : -a6, o4 = l4[e9];
          r2(o4, [St[0] + t6, St[1] + r7, St[2] + n8]), m2(dt, o4);
        }
      }
  };
  let u6 = 1 / 0, p5 = -1 / 0;
  const m5 = (e9) => {
    if ("replace" !== e9.type)
      return;
    const r7 = e9.geometry;
    if (!r7.hasZ)
      return;
    D(mt);
    const o4 = r7.spatialReference || n6, a6 = r7.rings.reduce((e10, r8) => r8.reduce((e11, r9) => (Bn(r9, o4, St, t5), L(St, St, bt), m2(mt, St), Math.min(St[2], e11)), e10), 1 / 0);
    f5(), E2(dt, mt) && (u6 = Math.min(u6, a6), p5 = Math.max(p5, a6));
  };
  if (a5.forEach((e9) => m5(e9)), u6 === 1 / 0)
    return null;
  const d3 = (e9, t6, r7) => {
    L(St, r7, c4), e9[t6 + 0] = St[0], e9[t6 + 1] = St[1], e9[t6 + 2] = St[2], t6 += 24, r7[2] = u6, L(St, r7, c4), e9[t6 + 0] = St[0], e9[t6 + 1] = St[1], e9[t6 + 2] = St[2], t6 += 24, r7[2] = p5, L(St, r7, c4), e9[t6 + 0] = St[0], e9[t6 + 1] = St[1], e9[t6 + 2] = St[2];
  };
  for (let i2 = 0; i2 < 8; ++i2)
    d3(gt.data, 3 * i2, l4[i2]);
  return H2(gt);
}
function st(e8) {
  return r(e8) && e8.halfSize[0] >= 0;
}
function ct(e8) {
  return e8[3] >= 0;
}
function lt(e8) {
  r(e8) && (e8.halfSize[0] = -1);
}
function ft(e8) {
  r(e8) && (e8[3] = -1);
}
var ut = e3();
var pt = e6();
var ht = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]];
var mt = u4();
var dt = u4();
var yt = E4();
var St = [0, 0, 0];
var gt = { data: new Array(72), size: 3 };
var bt = e3();

// node_modules/@arcgis/core/views/3d/support/index.js
var A3;
!function(A4) {
  A4[A4.ELEVATION = 0] = "ELEVATION", A4[A4.BASEMAP = 1] = "BASEMAP", A4[A4.I3S_INDEX = 2] = "I3S_INDEX", A4[A4.I3S_DATA = 3] = "I3S_DATA", A4[A4.SYMBOLOGY = 4] = "SYMBOLOGY";
}(A3 || (A3 = {}));
var E5 = (() => {
  const E6 = new Array();
  return E6[A3.ELEVATION] = 10, E6[A3.BASEMAP] = 10, E6[A3.I3S_INDEX] = 10, E6[A3.I3S_DATA] = 10, E6[A3.SYMBOLOGY] = 5, E6;
})();
var I4 = 30;

export {
  a4 as a,
  h3 as h,
  D3 as D,
  E4 as E,
  F2 as F,
  G2 as G,
  H2 as H,
  J3 as J,
  K2 as K,
  L3 as L,
  N2 as N,
  O4 as O,
  P2 as P,
  U3 as U,
  W3 as W,
  ie,
  se,
  ce,
  le,
  ue,
  he,
  me,
  ye,
  Se,
  Me,
  ve,
  Re,
  xe,
  je,
  ze,
  Ne,
  ke,
  Ue,
  _e,
  Fe,
  Oe,
  Ke,
  Le,
  Be,
  Pe,
  it,
  st,
  ct,
  lt,
  ft,
  A3 as A,
  E5 as E2,
  I4 as I
};
//# sourceMappingURL=chunk-RHH23PAT.js.map
