import {
  m as m2
} from "./chunk-PT7GCS5M.js";
import {
  l as l2
} from "./chunk-CBFCCRGT.js";
import {
  n as n4
} from "./chunk-WLVMYWO2.js";
import {
  i
} from "./chunk-UMSO3HI4.js";
import {
  u as u2
} from "./chunk-6UGZAJSY.js";
import {
  T as T2
} from "./chunk-52W4YMC2.js";
import {
  T as T3
} from "./chunk-MHEQOIKQ.js";
import {
  E as E3,
  e as e2,
  t2
} from "./chunk-AIONJO5O.js";
import {
  g as g2
} from "./chunk-7OZR6JFF.js";
import {
  L
} from "./chunk-5LWMNFCG.js";
import {
  D
} from "./chunk-FPMD6IB4.js";
import {
  T
} from "./chunk-PLLZPG4O.js";
import {
  o
} from "./chunk-MDCKEJ7B.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  o as o2
} from "./chunk-V7M26XZ7.js";
import {
  a as a2,
  n as n3
} from "./chunk-QKRZMDWG.js";
import {
  j
} from "./chunk-T7BEWVV3.js";
import {
  E as E2,
  I,
  U,
  a,
  l,
  s as s2,
  u
} from "./chunk-56RHM4A6.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  d,
  n2 as n,
  n8 as n2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  E,
  f,
  g,
  m,
  p,
  v,
  x
} from "./chunk-U3PSONS6.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/layers/support/overlayImageUtils.js
function a3(n5, r2, i2) {
  const o3 = s2(n5) / l(n5), a4 = { width: i2, height: i2 };
  return o3 > 1.0001 ? a4.height = i2 / o3 : o3 < 0.9999 && (a4.width = i2 * o3), a4.width = Math.round(a4.width / (s2(n5) / s2(r2))), a4.height = Math.round(a4.height / (l(n5) / l(r2))), a4;
}
function h(t3) {
  return T2.createSquareGeometry([[t3[0], t3[1], -1], [t3[2], t3[1], -1], [t3[2], t3[3], -1], [t3[0], t3[3], -1]]);
}
function l3(t3, e3) {
  if (!E2(t3, e3))
    return h(e3);
  const i2 = [t3[1] - e3[1], Math.min(t3[3], e3[3]) - Math.max(t3[1], e3[1]), e3[3] - t3[3], 123456], a4 = [t3[0] - e3[0], Math.min(t3[2], e3[2]) - Math.max(t3[0], e3[0]), e3[2] - t3[2], 123456], l4 = e3[2] - e3[0], u3 = e3[3] - e3[1], m3 = a4[0] > 0 && a4[2] > 0 ? 3 : 2, c = i2[0] > 0 && i2[2] > 0 ? 3 : 2, g3 = (c + 1) * (m3 + 1), w = new Float64Array(3 * g3), f2 = new Float32Array(2 * g3), d2 = new Uint32Array(6 * (c * m3 - 1));
  let y = 0, M2 = 0, b = 0, p2 = 0, x2 = 0;
  for (let n5 = 0; n5 < 4; n5++) {
    const t4 = i2[n5];
    if (t4 <= 0)
      continue;
    let r2 = 0;
    for (let i3 = 0; i3 < 4; i3++) {
      const t5 = a4[i3];
      t5 <= 0 || (w[M2++] = e3[0] + r2, w[M2++] = e3[1] + y, w[M2++] = -1, f2[b++] = r2 / l4, f2[b++] = y / u3, i3 < 3 && n5 < 3 && (1 !== i3 || 1 !== n5) && (d2[x2++] = p2, d2[x2++] = p2 + 1, d2[x2++] = p2 + m3 + 1, d2[x2++] = p2 + 1, d2[x2++] = p2 + m3 + 2, d2[x2++] = p2 + m3 + 1), p2++, r2 += t5);
    }
    y += t4;
  }
  const A = new Uint32Array(d2.length);
  return new g2([[O.POSITION, { size: 3, data: w, exclusive: true }], [O.NORMAL, { size: 3, data: s3, exclusive: true }], [O.UV0, { size: 2, data: f2, exclusive: true }]], [[O.POSITION, d2], [O.NORMAL, A], [O.UV0, d2]]);
}
var s3 = [0, 0, 1];

// node_modules/@arcgis/core/views/3d/layers/DynamicLayerView3D.js
var z = s.getLogger("esri.views.3d.layers.DynamicLayerView3D");
var F = class extends i(n4(u2)) {
  constructor() {
    super(...arguments), this.drapeSourceType = e2.RasterImage, this.updatePolicy = o.SYNC, this.fullExtentInLocalViewSpatialReference = null, this.maximumDataResolution = null, this._images = new Array(), this._extents = new Array(), this._overlays = new Array(), this.updateWhenStationary = true, this._drapeSourceRenderer = null, this.refreshDebounced = x(async (e3) => {
      this.destroyed || await this._doRefresh(e3).catch((e4) => {
        g(e4) || s.getLogger(this.declaredClass).error(e4);
      });
    }, 2e3);
  }
  initialize() {
    this._drapeSourceRenderer = this.view.basemapTerrain.overlayManager.registerGeometryDrapeSource(this), this.handles.add(n(() => this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))), this.addResolvingPromise(l2(this).then((e3) => this._set("fullExtentInLocalViewSpatialReference", e3))), this.updatingHandles.add(() => this.suspended, () => this._suspendedChangeHandler()), this.handles.add(this.view.resourceController.scheduler.registerIdleStateCallbacks(() => {
      this._isScaleRangeActive() && this.notifyChange("suspended");
    }, () => {
    })), this._isScaleRangeLayer() && this.updatingHandles.add(() => this.layer.effectiveScaleRange, () => this.notifyChange("suspended"));
  }
  destroy() {
    this.clear();
  }
  setDrapingExtent(e3, t3) {
    this._spatialReference = t3, e3.forEach((e4) => {
      this._overlays[e4.index] = e4, this._updateImageExtent(e4);
    });
  }
  _updateImageExtent(e3) {
    const t3 = this._clippedExtent(e3.extent, W);
    if (t(t3))
      return;
    const r2 = a3(e3.extent, t3, e3.resolution);
    let i2 = e3.pixelRatio * this.view.state.pixelRatio;
    if ("imageMaxWidth" in this.layer || "imageMaxHeight" in this.layer) {
      const e4 = this.layer.imageMaxWidth, t4 = this.layer.imageMaxHeight;
      if (r2.width > e4) {
        const t5 = e4 / r2.width;
        r2.height = Math.floor(r2.height * t5), r2.width = e4, i2 *= t5;
      }
      if (r2.height > t4) {
        const e5 = t4 / r2.height;
        r2.width = Math.floor(r2.width * e5), r2.height = t4, i2 *= e5;
      }
    }
    const a4 = this._extents[e3.index];
    a4 && I(a4.extent, t3) && this._imageSizeEquals(t3, a4.imageSize, r2) || (this._extents[e3.index] = { extent: u(t3), imageSize: r2, pixelRatio: i2 }, this.suspended || this._fetch(e3.index).catch((e4) => {
      g(e4) || z.error(e4);
    }));
  }
  clear() {
    for (let e3 = 0; e3 < this._images.length; e3++)
      this._clearImage(e3);
  }
  async doRefresh() {
    return this._doRefresh();
  }
  async _doRefresh(e3) {
    if (this.suspended)
      return;
    const t3 = [];
    for (let r2 = 0; r2 < this._extents.length; r2++)
      this._extents[r2] && t3.push(this._fetch(r2, e3));
    await E(t3);
  }
  canResume() {
    if (!super.canResume())
      return false;
    const e3 = this.layer;
    if (this._isScaleRangeActive()) {
      const { minScale: t3, maxScale: r2 } = e3.effectiveScaleRange, i2 = this.view.scale;
      if (i2 < r2 || t3 > 0 && i2 > t3)
        return false;
    }
    return true;
  }
  isUpdating() {
    return this._images.some((e3) => !!e3.loadingPromise);
  }
  async processResult(e3, t3, r2) {
    (t3 instanceof HTMLImageElement || t3 instanceof HTMLCanvasElement) && (e3.image = t3);
  }
  findExtentInfoAt(e3) {
    for (const t3 of this._extents) {
      const r2 = t3.extent;
      if (new M(r2[0], r2[1], r2[2], r2[3], this._spatialReference).contains(e3))
        return t3;
    }
    return null;
  }
  getFetchOptions() {
  }
  async redraw(e3, r2) {
    await n3(this._images, async (t3, i2) => {
      t3 && (await e3(t3, r2), await this._createStageObjects(i2, t3.image, r2));
    });
  }
  _imageSizeEquals(e3, t3, r2) {
    if (!this.maximumDataResolution)
      return false;
    const i2 = s2(e3) / this.maximumDataResolution.x, a4 = l(e3) / this.maximumDataResolution.y, s4 = i2 / t3.width, n5 = a4 / t3.height, o3 = i2 / r2.width, l4 = a4 / r2.height, h2 = Math.abs(s4 - o3), m3 = Math.abs(n5 - l4), d2 = t2.TESTS_DISABLE_OPTIMIZATIONS ? 0 : 1.5;
    return h2 <= d2 && m3 <= d2;
  }
  async _fetch(e3, t3) {
    if (this.suspended)
      return;
    const r2 = this._extents[e3], i2 = r2.extent;
    this._images[e3] || (this._images[e3] = { texture: null, material: null, renderGeometry: null, loadingPromise: null, loadingAbortController: null, image: null, pixelData: null, renderExtent: u(i2) });
    const a4 = this._images[e3];
    a4.loadingAbortController && (a4.loadingAbortController.abort(), a4.loadingAbortController = null);
    const s4 = new M(i2[0], i2[1], i2[2], i2[3], this._spatialReference);
    if (0 === s4.width || 0 === s4.height)
      return void this._clearImage(e3);
    const n5 = new AbortController();
    a4.loadingAbortController = n5, v(t3, () => n5.abort());
    const o3 = n5.signal, h2 = this._waitFetchReady(o3).then(async () => {
      const t4 = { requestAsImageElement: true, pixelRatio: this._overlays[e3].pixelRatio, ...this.getFetchOptions(), signal: o3 }, { height: i3, width: a5 } = r2.imageSize;
      return this.layer.fetchImage(s4, a5, i3, t4);
    }).then((e4) => {
      if (p(o3))
        throw z.warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."), m();
      return this.processResult(a4, e4);
    }).then(() => {
      a(a4.renderExtent, i2);
    }).finally(() => {
      h2 === a4.loadingPromise && (a4.loadingPromise = null, a4.loadingAbortController = null);
    });
    a4.loadingPromise = h2, this.notifyChange("updating"), await h2.then(async () => {
      if (o3.aborted)
        throw m();
      await this._createStageObjects(e3, a4.image, o3), this.notifyChange("updating");
    }).catch((e4) => {
      throw e4 && !g(e4) && z.error(e4), this.notifyChange("updating"), e4;
    });
  }
  _clearImage(e3) {
    const t3 = this._images[e3];
    if (t3) {
      r(t3.renderGeometry) && (this._drapeSourceRenderer.removeGeometries([t3.renderGeometry], E3.Geometry.UPDATE), t3.renderGeometry = null);
      const e4 = this.view._stage;
      e4.remove(t3.texture), t3.texture = null, e4.remove(t3.material), t3.material = null, t3.loadingAbortController && (t3.loadingAbortController.abort(), t3.loadingAbortController = null), t3.loadingPromise = null, t3.image = null, t3.pixelData = null;
    }
  }
  async _createStageObjects(e3, t3, i2) {
    const a4 = this.view._stage, o3 = this._images[e3], l4 = () => {
      a4.remove(o3.texture), o3.texture = null, r(o3.renderGeometry) && (this._drapeSourceRenderer.removeGeometries([o3.renderGeometry], E3.Geometry.UPDATE), o3.renderGeometry = null);
    };
    if (t3) {
      const n5 = new L(t3, { width: t3.width, height: t3.height, preMultiplyAlpha: true, wrap: { s: D.CLAMP_TO_EDGE, t: D.CLAMP_TO_EDGE } });
      let h2;
      if (await a2(this._images[e3 === T.INNER ? T.OUTER : T.INNER].loadingPromise), f(i2), e3 === T.INNER)
        h2 = h(o3.renderExtent);
      else {
        const e4 = this._images[0].renderExtent;
        if (!e4)
          return void l4();
        h2 = l3(e4, o3.renderExtent);
      }
      l4(), a4.add(n5), await a4.loadImmediate(n5), o3.texture = n5, t(o3.material) ? (o3.material = new m2({ transparent: true, textureId: n5.id }), a4.add(o3.material)) : o3.material.setParameters({ textureId: n5.id }), o3.renderGeometry = new T3(h2, o3.material), o3.renderGeometry.origin = this._overlays[e3].renderLocalOrigin, this._drapeSourceRenderer.addGeometries([o3.renderGeometry], E3.Geometry.UPDATE);
    } else
      l4(), a4.remove(o3.material), o3.material = null;
  }
  _isScaleRangeLayer() {
    return "effectiveScaleRange" in this.layer;
  }
  _isScaleRangeActive() {
    const e3 = this.layer;
    if (!this._isScaleRangeLayer())
      return false;
    const { minScale: t3, maxScale: r2 } = e3.effectiveScaleRange;
    return o2(t3, r2);
  }
  _clippedExtent(e3, t3) {
    if ("local" !== this.view.viewingMode)
      return a(t3, e3);
    const r2 = this.view.basemapTerrain;
    return r2.ready ? U(e3, r2.extent, t3) : a(t3, e3);
  }
  _suspendedChangeHandler() {
    this.suspended ? this.clear() : this.refreshDebounced();
  }
  async _waitFetchReady(e3) {
    await j(() => this.view.stationary, e3), f(e3);
  }
};
e([d()], F.prototype, "layer", void 0), e([d()], F.prototype, "suspended", void 0), e([d({ readOnly: true })], F.prototype, "fullExtentInLocalViewSpatialReference", void 0), e([d()], F.prototype, "updating", void 0), F = e([n2("esri.views.3d.layers.DynamicLayerView3D")], F);
var q = F;
var W = u();

export {
  q
};
//# sourceMappingURL=chunk-HAAERIOR.js.map
