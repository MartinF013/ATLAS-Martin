import {
  s as s2
} from "./chunk-UCWSHVC4.js";
import {
  e as e4
} from "./chunk-46N7XS5M.js";
import {
  e as e2
} from "./chunk-4MKQUQD4.js";
import {
  o as o2
} from "./chunk-A3QLZKCF.js";
import {
  e as e3
} from "./chunk-LGILR4HN.js";
import {
  a,
  i
} from "./chunk-I5UNY2WQ.js";
import {
  n as n3
} from "./chunk-NAB3NF54.js";
import {
  e
} from "./chunk-YFBAFAZ2.js";
import {
  r as r2
} from "./chunk-YZNDHJDJ.js";
import {
  f,
  n as n2
} from "./chunk-RTHP2LNT.js";
import {
  o
} from "./chunk-BPZGJQOB.js";
import {
  n
} from "./chunk-AIRC226G.js";
import {
  s
} from "./chunk-SN4RUQ4N.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/environment/CloudsCompositionParameters.js
var r3 = class {
  constructor() {
    this.startTime = 0, this.startTimeHeightFade = 0, this.cameraPositionLastFrame = n(), this.parallax = { anchorPointClouds: n(), cloudsHeight: 1e5, radiusCurvatureCorrectionFactor: 0, transform: e() }, this.parallaxNew = { anchorPointClouds: n(), cloudsHeight: 1e5, radiusCurvatureCorrectionFactor: 0, transform: e() }, this.crossFade = { enabled: false, factor: 0, distanceThresholdFactor: 0.3 }, this.fadeInOut = { stage: o3.FINISHED, factor: 0, distanceThresholdFactor: 0.6 }, this.fadeIn = { stage: s3.FINISHED, factor: 0, distanceThresholdFactor: 2 }, this.fadeInOutHeight = { stage: e5.FINISHED, factor: -1 };
  }
};
var s3;
var o3;
var e5;
!function(t) {
  t[t.FINISHED = 0] = "FINISHED", t[t.CHANGE_ANCHOR = 1] = "CHANGE_ANCHOR", t[t.FADE_IN = 2] = "FADE_IN";
}(s3 || (s3 = {})), function(t) {
  t[t.FINISHED = 0] = "FINISHED", t[t.FADE_OUT = 1] = "FADE_OUT", t[t.SWITCH = 2] = "SWITCH", t[t.FADE_IN = 3] = "FADE_IN";
}(o3 || (o3 = {})), function(t) {
  t[t.FINISHED = 0] = "FINISHED", t[t.HEIGHT_FADE = 1] = "HEIGHT_FADE";
}(e5 || (e5 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/TextureCubePassUniform.js
var s4 = class extends i {
  constructor(e6, s5) {
    super(e6, "samplerCube", a.Pass, (r4, o4, t) => r4.bindTexture(e6, s5(o4, t)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl.js
function v(r4) {
  const v2 = r4.fragment;
  v2.uniforms.add([new e4("rotationMatrixClouds", (o4, t) => t.clouds.parallax.transform), new e4("rotationMatrixCloudsCrossFade", (o4, t) => t.clouds.parallaxNew.transform), new e2("anchorPosition", (o4, t) => t.clouds.parallax.anchorPointClouds), new e2("anchorPositionCrossFade", (o4, t) => t.clouds.parallaxNew.anchorPointClouds), new e3("cloudVariables", (o4, r5) => r(r5.clouds.data) ? r2(h, r5.clouds.data.coverage, r5.clouds.data.absorption) : f), new o2("cloudsHeight", (o4, t) => t.clouds.parallax.cloudsHeight), new o2("radiusCurvatureCorrectionFactor", (o4, t) => t.clouds.parallax.radiusCurvatureCorrectionFactor), new o2("totalFadeInOut", (t, a2) => a2.clouds.fadeInOut.stage === o3.FINISHED ? a2.clouds.fadeInOutHeight.factor + Math.max(o(a2.clouds.fadeIn.factor, 0, 1)) : a2.clouds.fadeInOutHeight.factor + Math.max(o(a2.clouds.fadeInOut.factor, 0, 1))), new o2("crossFadeAnchorFactor", (t, a2) => o(a2.clouds.crossFade.factor, 0, 1)), new s4("cubeMap", (o4, a2) => r(a2.clouds.data) ? a2.clouds.data.cubeMap.colorTexture : null), new s2("crossFade", (o4, t) => t.clouds.crossFade.enabled)]), v2.constants.add("planetRadius", "float", s.radius), v2.code.add(n3`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`), v2.code.add(n3`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`), v2.code.add(n3`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`), v2.uniforms.add([new e2("lightingMainDirection", (o4, t) => t.lighting.lightingMainDirection), new e2("lightingMainIntensity", (o4, t) => t.lighting.mainLight.intensity)]), v2.code.add(n3`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(lightingMainDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(lightingMainDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((lightingMainIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * pow(dirDotLight, RIM_SCATTERING_FACTOR) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`), v2.code.add(n3`vec4 getCloudData(vec3 rayDir)
{
vec4 cloudData = textureCube(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
return mix(vec4(vec3(clamp(1.0 - cloudVariables.y, 0.6, 1.0)), 0.0), cloudData, smoothstep(-0.01, mix(0.0, 0.075, cloudVariables.x), abs(mu)));
}`), v2.code.add(n3`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`), v2.code.add(n3`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`), v2.code.add(n3`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`);
}
var h = n2();

export {
  r3 as r,
  s3 as s,
  o3 as o,
  e5 as e,
  v
};
//# sourceMappingURL=chunk-ZTFWVZTL.js.map
