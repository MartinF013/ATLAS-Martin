import {
  o as o2,
  r,
  t as t2
} from "./chunk-MOZ4GR2L.js";
import {
  T,
  i
} from "./chunk-MQBVOUKB.js";
import {
  e as e2
} from "./chunk-YFBAFAZ2.js";
import {
  e
} from "./chunk-LUU3J646.js";
import {
  a,
  j,
  o,
  z as z2
} from "./chunk-3NPGGTI6.js";
import {
  Un,
  qn
} from "./chunk-PZWU5EHT.js";
import {
  O
} from "./chunk-RN2KRYDN.js";
import {
  O as O2,
  z
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";
import {
  c
} from "./chunk-YPZEGNLG.js";
import {
  P,
  s as s2,
  u
} from "./chunk-3NMRL5CR.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/projection.js
var g = s.getLogger("esri.geometry.support.meshUtils.normalProjection");
function j2(r2, e3, o3, t3, n2) {
  return S(t3) ? (B(Y.TO_PCPF, i.fromTypedArray(r2), T.fromTypedArray(e3), T.fromTypedArray(o3), t3, i.fromTypedArray(n2)), n2) : (g.error("Cannot convert spatial reference to PCPF"), n2);
}
function h(r2, e3, o3, t3, n2) {
  return S(t3) ? (B(Y.FROM_PCPF, i.fromTypedArray(r2), T.fromTypedArray(e3), T.fromTypedArray(o3), t3, i.fromTypedArray(n2)), n2) : (g.error("Cannot convert to spatial reference from PCPF"), n2);
}
function M(r2, e3, o3) {
  return Un(r2, e3, 0, o3, O(e3), 0, r2.length / 3), o3;
}
function O3(r2, e3, o3) {
  return Un(r2, O(o3), 0, e3, o3, 0, r2.length / 3), e3;
}
function R(r2, o3, t3) {
  if (t(r2))
    return o3;
  const n2 = T.fromTypedArray(r2), f = T.fromTypedArray(o3);
  return t2(f, n2, t3), o3;
}
function v(r2, n2, f) {
  if (t(r2))
    return n2;
  j(x, f);
  const a2 = i.fromTypedArray(r2), c2 = i.fromTypedArray(n2);
  return r(c2, a2, x), z2(x) || o2(c2, c2), n2;
}
function V(r2, n2, f) {
  if (t(r2))
    return n2;
  j(x, f);
  const a2 = i.fromTypedArray(r2, 4 * Float32Array.BYTES_PER_ELEMENT), c2 = i.fromTypedArray(n2, 4 * Float32Array.BYTES_PER_ELEMENT);
  if (r(c2, a2, x), z2(x) || o2(c2, c2), r2 !== n2)
    for (let e3 = 3; e3 < r2.length; e3 += 4)
      n2[e3] = r2[e3];
  return n2;
}
function k(r2, e3, o3, t3, n2) {
  if (!S(t3))
    return g.error("Cannot convert spatial reference to PCPF"), n2;
  B(Y.TO_PCPF, i.fromTypedArray(r2, 4 * Float32Array.BYTES_PER_ELEMENT), T.fromTypedArray(e3), T.fromTypedArray(o3), t3, i.fromTypedArray(n2, 4 * Float32Array.BYTES_PER_ELEMENT));
  for (let f = 3; f < r2.length; f += 4)
    n2[f] = r2[f];
  return n2;
}
function L(r2, e3, o3, t3, n2) {
  if (!S(t3))
    return g.error("Cannot convert to spatial reference from PCPF"), n2;
  B(Y.FROM_PCPF, i.fromTypedArray(r2, 16), T.fromTypedArray(e3), T.fromTypedArray(o3), t3, i.fromTypedArray(n2, 16));
  for (let f = 3; f < r2.length; f += 4)
    n2[f] = r2[f];
  return n2;
}
function B(r2, e3, o3, t3, a2, c2) {
  if (!e3)
    return;
  const i2 = o3.count, y = O(a2);
  if (b(a2))
    for (let s3 = 0; s3 < i2; s3++)
      t3.getVec(s3, U), e3.getVec(s3, w), qn(y, U, W, y), a(x, W), r2 === Y.FROM_PCPF && o(x, x), O2(w, w, x), c2.setVec(s3, w);
  else
    for (let u2 = 0; u2 < i2; u2++) {
      t3.getVec(u2, U), e3.getVec(u2, w), qn(y, U, W, y), a(x, W);
      const a3 = c(o3.get(u2, 1));
      let i3 = Math.cos(a3);
      r2 === Y.TO_PCPF && (i3 = 1 / i3), x[0] *= i3, x[1] *= i3, x[2] *= i3, x[3] *= i3, x[4] *= i3, x[5] *= i3, r2 === Y.FROM_PCPF && o(x, x), O2(w, w, x), z(w, w), c2.setVec(u2, w);
    }
  return c2;
}
function S(r2) {
  return b(r2) || N(r2);
}
function b(r2) {
  return r2.isWGS84 || u(r2) || P(r2) || s2(r2);
}
function N(r2) {
  return r2.isWebMercator;
}
var Y;
!function(r2) {
  r2[r2.TO_PCPF = 0] = "TO_PCPF", r2[r2.FROM_PCPF = 1] = "FROM_PCPF";
}(Y || (Y = {}));
var U = n();
var w = n();
var W = e2();
var x = e();

export {
  j2 as j,
  h,
  M,
  O3 as O,
  R,
  v,
  V,
  k,
  L
};
//# sourceMappingURL=chunk-FFHGE66H.js.map
