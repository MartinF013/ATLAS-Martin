import {
  R as R2,
  g,
  j,
  j2,
  p
} from "./chunk-YPZEGNLG.js";
import {
  R,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  r as r2
} from "./chunk-G5JBUC5N.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/geometry/support/contains.js
var t2 = [0, 0];
function r3(t3, r4) {
  return !!r(r4) && f(t3, r4.x, r4.y, r4.z);
}
function i(n2, t3) {
  if (!t3.points || t3.points.length)
    return false;
  for (const r4 of t3.points)
    if (!u(n2, r4))
      return false;
  return true;
}
function o(n2, t3) {
  const { xmin: r4, ymin: i3, zmin: o3, xmax: u4, ymax: e3, zmax: c3 } = t3;
  return n2.hasZ && t3.hasZ ? f(n2, r4, i3, o3) && f(n2, r4, e3, o3) && f(n2, u4, e3, o3) && f(n2, u4, i3, o3) && f(n2, r4, i3, c3) && f(n2, r4, e3, c3) && f(n2, u4, e3, c3) && f(n2, u4, i3, c3) : f(n2, r4, i3) && f(n2, r4, e3) && f(n2, u4, e3) && f(n2, u4, i3);
}
function u(n2, t3) {
  return f(n2, t3[0], t3[1]);
}
function e2(n2, t3) {
  return f(n2, t3[0], t3[1], t3[2]);
}
function f(n2, t3, r4, i3) {
  return t3 >= n2.xmin && t3 <= n2.xmax && r4 >= n2.ymin && r4 <= n2.ymax && (null == i3 || !n2.hasZ || i3 >= n2.zmin && i3 <= n2.zmax);
}
function c(n2, r4) {
  return t2[1] = r4.y, t2[0] = r4.x, m(n2, t2);
}
function m(n2, t3) {
  return s(n2.rings, t3);
}
function s(n2, t3) {
  if (!n2)
    return false;
  if (x(n2))
    return a(false, n2, t3);
  let r4 = false;
  for (let i3 = 0, o3 = n2.length; i3 < o3; i3++)
    r4 = a(r4, n2[i3], t3);
  return r4;
}
function x(n2) {
  return !Array.isArray(n2[0][0]);
}
function a(n2, t3, r4) {
  const [i3, o3] = r4;
  let u4 = n2, e3 = 0;
  for (let f4 = 0, c3 = t3.length; f4 < c3; f4++) {
    e3++, e3 === c3 && (e3 = 0);
    const [n3, r5] = t3[f4], [m3, s3] = t3[e3];
    (r5 < o3 && s3 >= o3 || s3 < o3 && r5 >= o3) && n3 + (o3 - r5) / (s3 - r5) * (m3 - n3) < i3 && (u4 = !u4);
  }
  return u4;
}

// node_modules/@arcgis/core/geometry/support/intersectsBase.js
function i2(t3, e3) {
  return r3(t3, e3);
}
function o2(n2, t3) {
  const e3 = n2.hasZ && t3.hasZ;
  let r4, i3, o3;
  if (n2.xmin <= t3.xmin) {
    if (r4 = t3.xmin, n2.xmax < r4)
      return false;
  } else if (r4 = n2.xmin, t3.xmax < r4)
    return false;
  if (n2.ymin <= t3.ymin) {
    if (i3 = t3.ymin, n2.ymax < i3)
      return false;
  } else if (i3 = n2.ymin, t3.ymax < i3)
    return false;
  if (e3 && t3.hasZ) {
    if (n2.zmin <= t3.zmin) {
      if (o3 = t3.zmin, n2.zmax < o3)
        return false;
    } else if (o3 = n2.zmin, t3.zmax < o3)
      return false;
  }
  return true;
}
function f2(n2, t3) {
  const { points: i3, hasZ: o3 } = t3, f4 = o3 ? e2 : u;
  for (const e3 of i3)
    if (f4(n2, e3))
      return true;
  return false;
}
var s2 = [0, 0];
var u2 = [0, 0];
var c2 = [0, 0];
var m2 = [0, 0];
var l = [s2, u2, c2, m2];
var a2 = [[c2, s2], [s2, u2], [u2, m2], [m2, c2]];
function x2(n2, t3) {
  return y(n2, t3.rings);
}
function y(n2, r4) {
  s2[0] = n2.xmin, s2[1] = n2.ymax, u2[0] = n2.xmax, u2[1] = n2.ymax, c2[0] = n2.xmin, c2[1] = n2.ymin, m2[0] = n2.xmax, m2[1] = n2.ymin;
  for (const e3 of l)
    if (s(r4, e3))
      return true;
  for (const t3 of r4) {
    if (!t3.length)
      continue;
    let r5 = t3[0];
    if (u(n2, r5))
      return true;
    for (let i3 = 1; i3 < t3.length; i3++) {
      const o3 = t3[i3];
      if (u(n2, o3) || z(r5, o3, a2))
        return true;
      r5 = o3;
    }
  }
  return false;
}
function h(n2, t3) {
  s2[0] = n2.xmin, s2[1] = n2.ymax, u2[0] = n2.xmax, u2[1] = n2.ymax, c2[0] = n2.xmin, c2[1] = n2.ymin, m2[0] = n2.xmax, m2[1] = n2.ymin;
  const r4 = t3.paths;
  for (const i3 of r4) {
    if (!r4.length)
      continue;
    let t4 = i3[0];
    if (u(n2, t4))
      return true;
    for (let r5 = 1; r5 < i3.length; r5++) {
      const o3 = i3[r5];
      if (u(n2, o3) || z(t4, o3, a2))
        return true;
      t4 = o3;
    }
  }
  return false;
}
var g2 = [0, 0];
function p2(n2) {
  for (let t3 = 0; t3 < n2.length; t3++) {
    const e3 = n2[t3];
    for (let i3 = 0; i3 < e3.length - 1; i3++) {
      const r5 = e3[i3], o3 = e3[i3 + 1];
      for (let e4 = t3 + 1; e4 < n2.length; e4++)
        for (let t4 = 0; t4 < n2[e4].length - 1; t4++) {
          const i4 = n2[e4][t4], f4 = n2[e4][t4 + 1];
          if (G(r5, o3, i4, f4, g2) && !(g2[0] === r5[0] && g2[1] === r5[1] || g2[0] === i4[0] && g2[1] === i4[1] || g2[0] === o3[0] && g2[1] === o3[1] || g2[0] === f4[0] && g2[1] === f4[1]))
            return true;
        }
    }
    const r4 = e3.length;
    if (!(r4 <= 4))
      for (let n3 = 0; n3 < r4 - 3; n3++) {
        let t4 = r4 - 1;
        0 === n3 && (t4 = r4 - 2);
        const i3 = e3[n3], o3 = e3[n3 + 1];
        for (let r5 = n3 + 2; r5 < t4; r5++) {
          const n4 = e3[r5], t5 = e3[r5 + 1];
          if (G(i3, o3, n4, t5, g2) && !(g2[0] === i3[0] && g2[1] === i3[1] || g2[0] === n4[0] && g2[1] === n4[1] || g2[0] === o3[0] && g2[1] === o3[1] || g2[0] === t5[0] && g2[1] === t5[1]))
            return true;
        }
      }
  }
  return false;
}
function z(n2, t3, e3) {
  for (let r4 = 0; r4 < e3.length; r4++)
    if (G(n2, t3, e3[r4][0], e3[r4][1]))
      return true;
  return false;
}
function G(n2, t3, e3, r4, i3) {
  const [o3, f4] = n2, [s3, u4] = t3, [c3, m3] = e3, [l2, a3] = r4, x3 = l2 - c3, y2 = o3 - c3, h2 = s3 - o3, g3 = a3 - m3, p3 = f4 - m3, z3 = u4 - f4, G2 = g3 * h2 - x3 * z3;
  if (0 === G2)
    return false;
  const Z2 = (x3 * p3 - g3 * y2) / G2, P = (h2 * p3 - z3 * y2) / G2;
  return Z2 >= 0 && Z2 <= 1 && P >= 0 && P <= 1 && (i3 && (i3[0] = o3 + Z2 * (s3 - o3), i3[1] = f4 + Z2 * (u4 - f4)), true);
}
function Z(n2) {
  switch (n2) {
    case "esriGeometryEnvelope":
    case "extent":
      return o2;
    case "esriGeometryMultipoint":
    case "multipoint":
      return f2;
    case "esriGeometryPoint":
    case "point":
      return i2;
    case "esriGeometryPolygon":
    case "polygon":
      return x2;
    case "esriGeometryPolyline":
    case "polyline":
      return h;
  }
}

// node_modules/@arcgis/core/geometry/Extent.js
var u3;
function f3(t3) {
  return t3 && ("esri.geometry.SpatialReference" === t3.declaredClass || null != t3.wkid);
}
function d2(t3, i3, e3) {
  return null == i3 ? e3 : null == e3 ? i3 : t3(i3, e3);
}
var z2 = u3 = class extends p {
  constructor(...t3) {
    super(...t3), this.type = "extent", this.xmin = 0, this.ymin = 0, this.mmin = void 0, this.zmin = void 0, this.xmax = 0, this.ymax = 0, this.mmax = void 0, this.zmax = void 0;
  }
  normalizeCtorArgs(t3, i3, e3, s3, n2) {
    return f3(t3) ? { spatialReference: t3, xmin: 0, ymin: 0, xmax: 0, ymax: 0 } : "object" == typeof t3 ? (t3.spatialReference = null == t3.spatialReference ? k.WGS84 : t3.spatialReference, t3) : { xmin: t3, ymin: i3, xmax: e3, ymax: s3, spatialReference: null == n2 ? k.WGS84 : n2 };
  }
  static fromBounds(t3, i3) {
    return new u3({ xmin: t3[0], ymin: t3[1], xmax: t3[2], ymax: t3[3], spatialReference: i3 });
  }
  static fromPoint(t3) {
    return new u3({ xmin: t3.x, ymin: t3.y, zmin: t3.z, xmax: t3.x, ymax: t3.y, zmax: t3.z, spatialReference: t3.spatialReference });
  }
  get cache() {
    return this.commitProperty("xmin"), this.commitProperty("ymin"), this.commitProperty("zmin"), this.commitProperty("mmin"), this.commitProperty("xmax"), this.commitProperty("ymax"), this.commitProperty("zmax"), this.commitProperty("mmax"), this.commitProperty("spatialReference"), {};
  }
  get center() {
    const t3 = new j2({ x: 0.5 * (this.xmin + this.xmax), y: 0.5 * (this.ymin + this.ymax), spatialReference: this.spatialReference });
    return this.hasZ && (t3.z = 0.5 * (this.zmin + this.zmax)), this.hasM && (t3.m = 0.5 * (this.mmin + this.mmax)), t3;
  }
  get extent() {
    return this.clone();
  }
  get hasM() {
    return null != this.mmin && null != this.mmax;
  }
  get hasZ() {
    return null != this.zmin && null != this.zmax;
  }
  get height() {
    return Math.abs(this.ymax - this.ymin);
  }
  get width() {
    return Math.abs(this.xmax - this.xmin);
  }
  centerAt(t3) {
    const i3 = this.center;
    return null != t3.z && this.hasZ ? this.offset(t3.x - i3.x, t3.y - i3.y, t3.z - i3.z) : this.offset(t3.x - i3.x, t3.y - i3.y);
  }
  clone() {
    const t3 = new u3();
    return t3.xmin = this.xmin, t3.ymin = this.ymin, t3.xmax = this.xmax, t3.ymax = this.ymax, t3.spatialReference = this.spatialReference, null != this.zmin && (t3.zmin = this.zmin, t3.zmax = this.zmax), null != this.mmin && (t3.mmin = this.mmin, t3.mmax = this.mmax), t3;
  }
  contains(t3) {
    if (!t3)
      return false;
    const i3 = this.spatialReference, e3 = t3.spatialReference;
    return i3 && e3 && !i3.equals(e3) && g(i3, e3) && (t3 = i3.isWebMercator ? R2(t3) : j(t3, true)), "point" === t3.type ? r3(this, t3) : "extent" === t3.type && o(this, t3);
  }
  equals(t3) {
    if (this === t3)
      return true;
    if (t(t3))
      return false;
    const e3 = this.spatialReference, s3 = t3.spatialReference;
    return e3 && s3 && !e3.equals(s3) && g(e3, s3) && (t3 = e3.isWebMercator ? R2(t3) : j(t3, true)), this.xmin === t3.xmin && this.ymin === t3.ymin && this.zmin === t3.zmin && this.mmin === t3.mmin && this.xmax === t3.xmax && this.ymax === t3.ymax && this.zmax === t3.zmax && this.mmax === t3.mmax;
  }
  expand(t3) {
    const i3 = 0.5 * (1 - t3), e3 = this.width * i3, s3 = this.height * i3;
    if (this.xmin += e3, this.ymin += s3, this.xmax -= e3, this.ymax -= s3, this.hasZ) {
      const t4 = (this.zmax - this.zmin) * i3;
      this.zmin += t4, this.zmax -= t4;
    }
    if (this.hasM) {
      const t4 = (this.mmax - this.mmin) * i3;
      this.mmin += t4, this.mmax -= t4;
    }
    return this;
  }
  intersects(t3) {
    if (t(t3))
      return false;
    "mesh" === t3.type && (t3 = t3.extent);
    const e3 = this.spatialReference, s3 = t3.spatialReference;
    e3 && s3 && !e3.equals(s3) && g(e3, s3) && (t3 = e3.isWebMercator ? R2(t3) : j(t3, true));
    return Z(t3.type)(this, t3);
  }
  normalize() {
    const t3 = this._normalize(false, true);
    return Array.isArray(t3) ? t3 : [t3];
  }
  offset(t3, i3, e3) {
    return this.xmin += t3, this.ymin += i3, this.xmax += t3, this.ymax += i3, null != e3 && (this.zmin += e3, this.zmax += e3), this;
  }
  shiftCentralMeridian() {
    return this._normalize(true);
  }
  union(t3) {
    return this === t3 || (this.xmin = Math.min(this.xmin, t3.xmin), this.ymin = Math.min(this.ymin, t3.ymin), this.xmax = Math.max(this.xmax, t3.xmax), this.ymax = Math.max(this.ymax, t3.ymax), (this.hasZ || t3.hasZ) && (this.zmin = d2(Math.min, this.zmin, t3.zmin), this.zmax = d2(Math.max, this.zmax, t3.zmax)), (this.hasM || t3.hasM) && (this.mmin = d2(Math.min, this.mmin, t3.mmin), this.mmax = d2(Math.max, this.mmax, t3.mmax))), this;
  }
  intersection(t3) {
    return this === t3 ? this : t(t3) || !this.intersects(t3) ? null : (this.xmin = Math.max(this.xmin, t3.xmin), this.ymin = Math.max(this.ymin, t3.ymin), this.xmax = Math.min(this.xmax, t3.xmax), this.ymax = Math.min(this.ymax, t3.ymax), (this.hasZ || t3.hasZ) && (this.zmin = d2(Math.max, this.zmin, t3.zmin), this.zmax = d2(Math.min, this.zmax, t3.zmax)), (this.hasM || t3.hasM) && (this.mmin = d2(Math.max, this.mmin, t3.mmin), this.mmax = d2(Math.min, this.mmax, t3.mmax)), this);
  }
  toJSON(t3) {
    return this.write({}, t3);
  }
  _shiftCM(t3 = R(this.spatialReference)) {
    if (!t3 || !this.spatialReference)
      return this;
    const i3 = this.spatialReference, s3 = this._getCM(t3);
    if (s3) {
      const n2 = i3.isWebMercator ? j(s3) : s3;
      this.xmin -= s3.x, this.xmax -= s3.x, i3.isWebMercator || (n2.x = this._normalizeX(n2.x, t3).x), this.spatialReference = new k(r2(i3.isWGS84 ? t3.altTemplate : t3.wkTemplate, { Central_Meridian: n2.x }));
    }
    return this;
  }
  _getCM(t3) {
    let i3 = null;
    const [e3, s3] = t3.valid, n2 = this.xmin, m3 = this.xmax;
    return n2 >= e3 && n2 <= s3 && (m3 >= e3 && m3 <= s3) || (i3 = this.center), i3;
  }
  _normalize(t3, i3, e3) {
    const s3 = this.spatialReference;
    if (!s3)
      return this;
    if (!(e3 = e3 || R(s3)))
      return this;
    const n2 = this._getParts(e3).map((t4) => t4.extent);
    if (n2.length < 2)
      return n2[0] || this;
    if (n2.length > 2)
      return t3 ? this._shiftCM(e3) : this.set({ xmin: e3.valid[0], xmax: e3.valid[1] });
    if (t3)
      return this._shiftCM(e3);
    if (i3)
      return n2;
    let m3 = true, r4 = true;
    return n2.forEach((t4) => {
      t4.hasZ || (m3 = false), t4.hasM || (r4 = false);
    }), { rings: n2.map((t4) => {
      const i4 = [[t4.xmin, t4.ymin], [t4.xmin, t4.ymax], [t4.xmax, t4.ymax], [t4.xmax, t4.ymin], [t4.xmin, t4.ymin]];
      if (m3) {
        const e4 = (t4.zmax - t4.zmin) / 2;
        for (let t5 = 0; t5 < i4.length; t5++)
          i4[t5].push(e4);
      }
      if (r4) {
        const e4 = (t4.mmax - t4.mmin) / 2;
        for (let t5 = 0; t5 < i4.length; t5++)
          i4[t5].push(e4);
      }
      return i4;
    }), hasZ: m3, hasM: r4, spatialReference: s3 };
  }
  _getParts(t3) {
    let i3 = this.cache._parts;
    if (!i3) {
      i3 = [];
      const { ymin: e4, ymax: s4, spatialReference: n2 } = this, m3 = this.width, r4 = this.xmin, a3 = this.xmax;
      let h2;
      t3 = t3 || R(n2);
      const [o3, x3] = t3.valid;
      h2 = this._normalizeX(this.xmin, t3);
      const p3 = h2.x, c3 = h2.frameId;
      h2 = this._normalizeX(this.xmax, t3);
      const y2 = h2.x, f4 = h2.frameId, d3 = p3 === y2 && m3 > 0;
      if (m3 > 2 * x3) {
        const t4 = new u3(r4 < a3 ? p3 : y2, e4, x3, s4, n2), m4 = new u3(o3, e4, r4 < a3 ? y2 : p3, s4, n2), h3 = new u3(0, e4, x3, s4, n2), l2 = new u3(o3, e4, 0, s4, n2), d4 = [], z3 = [];
        t4.contains(h3) && d4.push(c3), t4.contains(l2) && z3.push(c3), m4.contains(h3) && d4.push(f4), m4.contains(l2) && z3.push(f4);
        for (let i4 = c3 + 1; i4 < f4; i4++)
          d4.push(i4), z3.push(i4);
        i3.push({ extent: t4, frameIds: [c3] }, { extent: m4, frameIds: [f4] }, { extent: h3, frameIds: d4 }, { extent: l2, frameIds: z3 });
      } else
        p3 > y2 || d3 ? i3.push({ extent: new u3(p3, e4, x3, s4, n2), frameIds: [c3] }, { extent: new u3(o3, e4, y2, s4, n2), frameIds: [f4] }) : i3.push({ extent: new u3(p3, e4, y2, s4, n2), frameIds: [c3] });
      this.cache._parts = i3;
    }
    const e3 = this.hasZ, s3 = this.hasM;
    if (e3 || s3) {
      const t4 = {};
      e3 && (t4.zmin = this.zmin, t4.zmax = this.zmax), s3 && (t4.mmin = this.mmin, t4.mmax = this.mmax);
      for (let e4 = 0; e4 < i3.length; e4++)
        i3[e4].extent.set(t4);
    }
    return i3;
  }
  _normalizeX(t3, i3) {
    const [e3, s3] = i3.valid, n2 = 2 * s3;
    let m3, r4 = 0;
    return t3 > s3 ? (m3 = Math.ceil(Math.abs(t3 - s3) / n2), t3 -= m3 * n2, r4 = m3) : t3 < e3 && (m3 = Math.ceil(Math.abs(t3 - e3) / n2), t3 += m3 * n2, r4 = -m3), { x: t3, frameId: r4 };
  }
};
e([d({ readOnly: true })], z2.prototype, "cache", null), e([d({ readOnly: true })], z2.prototype, "center", null), e([d({ readOnly: true })], z2.prototype, "extent", null), e([d({ readOnly: true, json: { write: { enabled: false, overridePolicy: null } } })], z2.prototype, "hasM", null), e([d({ readOnly: true, json: { write: { enabled: false, overridePolicy: null } } })], z2.prototype, "hasZ", null), e([d({ readOnly: true })], z2.prototype, "height", null), e([d({ readOnly: true })], z2.prototype, "width", null), e([d({ type: Number, json: { type: [Number, String], write: { enabled: true, allowNull: true } } })], z2.prototype, "xmin", void 0), e([d({ type: Number, json: { write: true } })], z2.prototype, "ymin", void 0), e([d({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], z2.prototype, "mmin", void 0), e([d({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], z2.prototype, "zmin", void 0), e([d({ type: Number, json: { write: true } })], z2.prototype, "xmax", void 0), e([d({ type: Number, json: { write: true } })], z2.prototype, "ymax", void 0), e([d({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], z2.prototype, "mmax", void 0), e([d({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], z2.prototype, "zmax", void 0), z2 = u3 = e([n("esri.geometry.Extent")], z2), z2.prototype.toJSON.isDefaultToJSON = true;
var M = z2;

export {
  r3 as r,
  i,
  e2 as e,
  f,
  c,
  s,
  o2 as o,
  p2 as p,
  G,
  Z,
  M
};
//# sourceMappingURL=chunk-Q72YFZUL.js.map
