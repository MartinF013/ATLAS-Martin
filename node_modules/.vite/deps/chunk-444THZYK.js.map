{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{TextureCoordinateAttributeType as e}from\"../attributes/TextureCoordinateAttribute.glsl.js\";import{VertexTextureCoordinates as t}from\"../attributes/VertexTextureCoordinates.glsl.js\";import{NormalsDoubleSidedMode as n}from\"./Normals.glsl.js\";import{glsl as a}from\"../../shaderModules/interfaces.js\";import{createTexture2DDrawSizeUniforms as r}from\"../../shaderModules/Texture2DDrawUniform.js\";import{createTexture2DPassSizeUniforms as o}from\"../../shaderModules/Texture2DPassUniform.js\";import{BindType as s}from\"../../shaderTechnique/BindType.js\";import{VertexAttribute as d}from\"../../../lib/VertexAttribute.js\";function m(m,c){const i=m.fragment;if(c.hasVertexTangents?(m.attributes.add(d.TANGENT,\"vec4\"),m.varyings.add(\"vTangent\",\"vec4\"),c.doubleSidedMode===n.WindingOrder?i.code.add(a`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\nvec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`):i.code.add(a`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = vTangent.w;\nvec3 tangent = normalize(vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`)):(m.extensions.add(\"GL_OES_standard_derivatives\"),i.code.add(a`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\nvec3 Q1 = dFdx(pos);\nvec3 Q2 = dFdy(pos);\nvec2 stx = dFdx(st);\nvec2 sty = dFdy(st);\nfloat det = stx.t * sty.s - sty.t * stx.s;\nvec3 T = stx.t * Q2 - sty.t * Q1;\nT = T - normal * dot(normal, T);\nT *= inversesqrt(max(dot(T,T), 1.e-10));\nvec3 B = sign(det) * cross(normal, T);\nreturn mat3(T, B, normal);\n}`)),c.textureCoordinateType!==e.None){m.include(t,c);const e=c.supportsTextureAtlas;i.uniforms.add(c.pbrTextureBindType===s.Pass?o(\"normalTexture\",(e=>e.textureNormal),e):r(\"normalTexture\",(e=>e.textureNormal),e)),i.code.add(a`\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ${c.supportsTextureAtlas?\"vtc.size = normalTextureSize;\":\"\"}\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  `)}}export{m as ComputeNormalTexture};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AAI2mB,SAASA,GAAEA,IAAE,GAAE;AAAC,QAAMC,KAAED,GAAE;AAAS,MAAG,EAAE,qBAAmBA,GAAE,WAAW,IAAI,EAAE,SAAQ,MAAM,GAAEA,GAAE,SAAS,IAAI,YAAW,MAAM,GAAE,EAAE,oBAAkB,EAAE,eAAaC,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,EAKvxB,IAAEA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,EAKb,MAAID,GAAE,WAAW,IAAI,6BAA6B,GAAEC,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW/D,IAAG,EAAE,0BAAwB,EAAE,MAAK;AAAC,IAAAD,GAAE,QAAQ,GAAE,CAAC;AAAE,UAAM,IAAE,EAAE;AAAqB,IAAAC,GAAE,SAAS,IAAI,EAAE,uBAAqBC,GAAE,OAAKF,GAAE,iBAAiB,CAAAG,OAAGA,GAAE,eAAe,CAAC,IAAE,EAAE,iBAAiB,CAAAA,OAAGA,GAAE,eAAe,CAAC,CAAC,GAAEF,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA,QAG1N,EAAE,uBAAqB,kCAAgC;AAAA;AAAA;AAAA;AAAA,GAI5D;AAAA,EAAC;AAAC;",
  "names": ["m", "i", "a", "e"]
}
