import {
  d as d3,
  s as s3
} from "./chunk-7S6G3GM7.js";
import {
  s as s2
} from "./chunk-4OFLHC3C.js";
import {
  c
} from "./chunk-GTBTSR4X.js";
import {
  n as n3
} from "./chunk-QJN4GT4E.js";
import {
  i as i2,
  r as r3
} from "./chunk-TUZ3FLXS.js";
import {
  L
} from "./chunk-4I3W4KD5.js";
import {
  e as e2,
  n as n2,
  o as o2
} from "./chunk-6FKG7JUE.js";
import {
  i as i3
} from "./chunk-X57S4DWT.js";
import {
  t as t3
} from "./chunk-ODX6X222.js";
import {
  g
} from "./chunk-JT3LXQ47.js";
import {
  y
} from "./chunk-TBT57L4K.js";
import {
  g as g2
} from "./chunk-BLINZ65M.js";
import {
  a as a2
} from "./chunk-D7DLEBS2.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  i
} from "./chunk-C4LU7RDX.js";
import {
  t as t2
} from "./chunk-EPCCNF3D.js";
import {
  d as d2,
  v as v2
} from "./chunk-4PRVTUEZ.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  r as r2
} from "./chunk-ZIHDQYKE.js";
import {
  o
} from "./chunk-GSRNZQFV.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  E
} from "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  v
} from "./chunk-23NWA6WL.js";
import {
  a,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/rest/operations/identify.js
var o3 = (e3) => e3.spatialReference.wkid || JSON.stringify(e3.spatialReference);
function l2(r4, i5) {
  const { dpi: n4, gdbVersion: s4, geometry: l3, geometryPrecision: f2, height: p2, layerOption: m3, mapExtent: y3, maxAllowableOffset: c2, returnFieldName: u3, returnGeometry: d4, returnUnformattedValues: g3, returnZ: x2, spatialReference: b, timeExtent: h, tolerance: E2, width: O } = r4.toJSON(), { dynamicLayers: S, layerDefs: j, layerIds: N } = a3(r4), J = i5 && r(i5.geometry) ? i5.geometry : null, R = { geometryPrecision: f2, maxAllowableOffset: c2, returnFieldName: u3, returnGeometry: d4, returnUnformattedValues: g3, returnZ: x2, tolerance: E2 }, $ = J && J.toJSON() || l3;
  if (R.imageDisplay = `${O},${p2},${n4}`, s4 && (R.gdbVersion = s4), $ && (delete $.spatialReference, R.geometry = JSON.stringify($), R.geometryType = v2($)), b ? R.sr = b.wkid || JSON.stringify(b) : $ && $.spatialReference ? R.sr = o3($) : y3 && y3.spatialReference && (R.sr = o3(y3)), R.time = h ? [h.start, h.end].join(",") : null, y3) {
    const { xmin: e3, ymin: r5, xmax: t4, ymax: i6 } = y3;
    R.mapExtent = `${e3},${r5},${t4},${i6}`;
  }
  return j && (R.layerDefs = j), S && !j && (R.dynamicLayers = S), R.layers = "popup" === m3 ? "visible" : m3, N && !S && (R.layers += `:${N.join(",")}`), R;
}
function a3(r4) {
  var _a, _b;
  const { mapExtent: t4, floors: o4, width: l3, sublayers: a6, layerIds: p2, layerOption: m3, gdbVersion: y3 } = r4, c2 = (_b = (_a = a6 == null ? void 0 : a6.find((e3) => null != e3.layer)) == null ? void 0 : _a.layer) == null ? void 0 : _b.serviceSublayers, u3 = "popup" === m3, d4 = {}, g3 = r3({ extent: t4, width: l3, spatialReference: t4 == null ? void 0 : t4.spatialReference }), x2 = [], b = (e3) => {
    const r5 = 0 === g3, t5 = 0 === e3.minScale || g3 <= e3.minScale, i5 = 0 === e3.maxScale || g3 >= e3.maxScale;
    if (e3.visible && (r5 || t5 && i5))
      if (e3.sublayers)
        e3.sublayers.forEach(b);
      else {
        if (false === (p2 == null ? void 0 : p2.includes(e3.id)) || u3 && (!e3.popupTemplate || !e3.popupEnabled))
          return;
        x2.unshift(e3);
      }
  };
  if (a6 == null ? void 0 : a6.forEach(b), a6 && !x2.length)
    d4.layerIds = [];
  else {
    const r5 = i3(x2, c2, y3), t5 = x2.map((e3) => {
      const r6 = n3(o4, e3);
      return e3.toExportImageJSON(r6);
    });
    if (r5)
      d4.dynamicLayers = JSON.stringify(t5);
    else {
      if (a6) {
        let e3 = x2.map(({ id: e4 }) => e4);
        p2 && (e3 = e3.filter((e4) => p2.includes(e4))), d4.layerIds = e3;
      } else
        (p2 == null ? void 0 : p2.length) && (d4.layerIds = p2);
      const r6 = f(o4, x2);
      if (r(r6) && r6.length) {
        const e3 = {};
        for (const t6 of r6)
          t6.definitionExpression && (e3[t6.id] = t6.definitionExpression);
        Object.keys(e3).length && (d4.layerDefs = JSON.stringify(e3));
      }
    }
  }
  return d4;
}
function f(e3, t4) {
  const i5 = !!(e3 == null ? void 0 : e3.length), s4 = t4.filter((e4) => null != e4.definitionExpression || i5 && null != e4.floorInfo);
  return s4.length ? s4.map((t5) => {
    const i6 = n3(e3, t5), s5 = t3(i6, t5.definitionExpression);
    return { id: t5.id, definitionExpression: s5 };
  }) : null;
}

// node_modules/@arcgis/core/rest/support/IdentifyParameters.js
var m;
var a4 = m = class extends l {
  constructor(t4) {
    super(t4), this.dpi = 96, this.floors = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = null, this.height = 400, this.layerIds = null, this.layerOption = "top", this.mapExtent = null, this.maxAllowableOffset = null, this.returnFieldName = true, this.returnGeometry = false, this.returnM = false, this.returnUnformattedValues = true, this.returnZ = false, this.spatialReference = null, this.sublayers = null, this.timeExtent = null, this.tolerance = null, this.width = 400;
  }
  static from(t4) {
    return v(m, t4);
  }
};
e([d({ type: Number, json: { write: true } })], a4.prototype, "dpi", void 0), e([d()], a4.prototype, "floors", void 0), e([d({ type: String, json: { write: true } })], a4.prototype, "gdbVersion", void 0), e([d({ types: i, json: { read: d2, write: true } })], a4.prototype, "geometry", void 0), e([d({ type: Number, json: { write: true } })], a4.prototype, "geometryPrecision", void 0), e([d({ type: Number, json: { write: true } })], a4.prototype, "height", void 0), e([d({ type: [Number], json: { write: true } })], a4.prototype, "layerIds", void 0), e([d({ type: ["top", "visible", "all", "popup"], json: { write: true } })], a4.prototype, "layerOption", void 0), e([d({ type: M, json: { write: true } })], a4.prototype, "mapExtent", void 0), e([d({ type: Number, json: { write: true } })], a4.prototype, "maxAllowableOffset", void 0), e([d({ type: Boolean, json: { write: true } })], a4.prototype, "returnFieldName", void 0), e([d({ type: Boolean, json: { write: true } })], a4.prototype, "returnGeometry", void 0), e([d({ type: Boolean, json: { write: true } })], a4.prototype, "returnM", void 0), e([d({ type: Boolean, json: { write: true } })], a4.prototype, "returnUnformattedValues", void 0), e([d({ type: Boolean, json: { write: true } })], a4.prototype, "returnZ", void 0), e([d({ type: k, json: { write: true } })], a4.prototype, "spatialReference", void 0), e([d()], a4.prototype, "sublayers", void 0), e([d({ type: y, json: { write: true } })], a4.prototype, "timeExtent", void 0), e([d({ type: Number, json: { write: true } })], a4.prototype, "tolerance", void 0), e([d({ type: Number, json: { write: true } })], a4.prototype, "width", void 0), a4 = m = e([n("esri.rest.support.IdentifyParameters")], a4);
var u = a4;

// node_modules/@arcgis/core/rest/support/IdentifyResult.js
var u2 = class extends l {
  constructor(r4) {
    super(r4), this.displayFieldName = null, this.feature = null, this.layerId = null, this.layerName = null;
  }
  readFeature(r4, t4) {
    return g2.fromJSON({ attributes: { ...t4.attributes }, geometry: { ...t4.geometry } });
  }
  writeFeature(r4, e3) {
    if (!r4)
      return;
    const { attributes: t4, geometry: s4 } = r4;
    t4 && (e3.attributes = { ...t4 }), r(s4) && (e3.geometry = s4.toJSON(), e3.geometryType = t2.toJSON(s4.type));
  }
};
e([d({ type: String, json: { write: true } })], u2.prototype, "displayFieldName", void 0), e([d({ type: g2 })], u2.prototype, "feature", void 0), e([o("feature", ["attributes", "geometry"])], u2.prototype, "readFeature", null), e([r2("feature")], u2.prototype, "writeFeature", null), e([d({ type: Number, json: { write: true } })], u2.prototype, "layerId", void 0), e([d({ type: String, json: { write: true } })], u2.prototype, "layerName", void 0), u2 = e([n("esri.rest.support.IdentifyResult")], u2);
var y2 = u2;

// node_modules/@arcgis/core/rest/identify.js
async function i4(u3, f2, i5) {
  const c2 = (f2 = a5(f2)).geometry ? [f2.geometry] : [], l3 = n2(u3);
  return l3.path += "/identify", L(c2).then((r4) => {
    const e3 = l2(f2, { geometry: r4 && r4[0] }), u4 = o2({ ...l3.query, f: "json", ...e3 }), a6 = e2(u4, i5);
    return U(l3.path, a6).then(m2).then((t4) => p(t4, f2.sublayers));
  });
}
function m2(t4) {
  const r4 = t4.data;
  r4.results = r4.results || [];
  const e3 = { results: [] };
  return e3.results = r4.results.map((t5) => y2.fromJSON(t5)), e3;
}
function a5(t4) {
  return t4 = u.from(t4);
}
function p(t4, r4) {
  if (!(r4 == null ? void 0 : r4.length))
    return t4;
  const e3 = /* @__PURE__ */ new Map();
  function s4(t5) {
    e3.set(t5.id, t5), t5.sublayers && t5.sublayers.forEach(s4);
  }
  r4.forEach(s4);
  for (const o4 of t4.results)
    o4.feature.sourceLayer = e3.get(o4.layerId);
  return t4;
}

// node_modules/@arcgis/core/views/layers/MapImageLayerView.js
var x = (x2) => {
  let g3 = class extends x2 {
    initialize() {
      this.exportImageParameters = new c({ layer: this.layer });
    }
    destroy() {
      this.exportImageParameters.destroy(), this.exportImageParameters = null;
    }
    get exportImageVersion() {
      var _a;
      return (_a = this.exportImageParameters) == null ? void 0 : _a.commitProperty("version"), this.commitProperty("timeExtent"), (this._get("exportImageVersion") || 0) + 1;
    }
    async fetchPopupFeatures(e3, t4) {
      var _a, _b, _c, _d;
      const { layer: s4 } = this;
      if (!e3)
        throw new s("mapimagelayer:fetchPopupFeatures", "Nothing to fetch without area", { layer: s4 });
      const a6 = ((_b = (_a = this.layer.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQuery) ?? true;
      if (!((((_d = (_c = this.layer.capabilities) == null ? void 0 : _c.operations) == null ? void 0 : _d.supportsIdentify) ?? true) && this.layer.version >= 10.5) && !a6)
        throw new s("mapimagelayer:fetchPopupFeatures-not-supported", "query operation is disabled for this service", { layer: s4 });
      return a6 ? this._fetchPopupFeaturesUsingQueries(e3, t4) : this._fetchPopupFeaturesUsingIdentify(e3, t4);
    }
    canResume() {
      var _a;
      return !!super.canResume() && !((_a = this.timeExtent) == null ? void 0 : _a.isEmpty);
    }
    async _fetchPopupFeaturesUsingIdentify(e3, r4) {
      const t4 = await this._createIdentifyParameters(e3, r4);
      if (t(t4))
        return [];
      const { results: a6 } = await i4(this.layer.parsedUrl, t4);
      return a6.map((e4) => e4.feature);
    }
    async _createIdentifyParameters(e3, r4) {
      var _a, _b;
      const { floors: s4, spatialReference: o4, scale: i5 } = this.view, p2 = r(r4) ? r4.event : null, m3 = await this._collectPopupProviders(this.layer.sublayers, i5, r4);
      if (!m3.length)
        return null;
      await Promise.all(m3.map(({ sublayer: e4 }) => e4.load().catch(() => {
      })));
      const c2 = Math.min(a("mapimagelayer-popup-identify-max-tolerance"), this.layer.allSublayers.reduce((e4, r5) => r5.renderer ? s2({ renderer: r5.renderer, event: p2 }) : e4, 2)), u3 = this.createFetchPopupFeaturesQueryGeometry(e3, c2), h = i2(i5, o4), d4 = Math.round(u3.width / h), w = new M({ xmin: u3.center.x - h * d4, ymin: u3.center.y - h * d4, xmax: u3.center.x + h * d4, ymax: u3.center.y + h * d4, spatialReference: u3.spatialReference }), P = false === ((_b = (_a = this.layer.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQuery) || await new Promise((e4) => {
        let r5 = false;
        Promise.all(m3.map(async ({ popupTemplate: t4 }) => {
          if (t4) {
            const s5 = await this._loadArcadeModules(t4);
            if (r5)
              return;
            const a6 = s5 == null ? void 0 : s5.arcadeUtils.hasGeometryOperations(t4);
            a6 && (r5 = true, e4(true));
          }
        })).finally(() => e4(false));
      });
      return new u({ floors: s4, gdbVersion: this.layer.gdbVersion, geometry: e3, height: d4, layerOption: "popup", mapExtent: w, maxAllowableOffset: P ? 0 : h, returnGeometry: true, spatialReference: o4, sublayers: this.layer.sublayers, timeExtent: this.timeExtent, tolerance: c2, width: d4 });
    }
    async _fetchPopupFeaturesUsingQueries(e3, r4) {
      const t4 = await this._collectPopupProviders(this.layer.sublayers, this.view.scale, r4), s4 = r(r4) ? r4.event : null, i5 = t4.map(async ({ sublayer: r5, popupTemplate: t5 }) => {
        var _a, _b;
        await r5.load().catch(() => {
        });
        const o4 = r5.createQuery(), i6 = s2({ renderer: r5.renderer, event: s4 }), p2 = this.createFetchPopupFeaturesQueryGeometry(e3, i6);
        if (o4.geometry = p2, o4.outFields = await d3(r5, t5), "floors" in this.view) {
          const e4 = (_b = (_a = this.view) == null ? void 0 : _a.floors) == null ? void 0 : _b.clone(), t6 = n3(e4, r5);
          r(t6) && (o4.where = o4.where ? `(${o4.where}) AND (${t6})` : t6);
        }
        const n4 = await this._loadArcadeModules(t5);
        n4 && n4.arcadeUtils.hasGeometryOperations(t5) || (o4.maxAllowableOffset = p2.width / i6);
        return (await r5.queryFeatures(o4)).features;
      });
      return (await E(i5)).reduce((e4, r5) => r5.value ? [...e4, ...r5.value] : e4, []).filter((e4) => null != e4);
    }
    async _collectPopupProviders(e3, r4, t4) {
      const s4 = [], o4 = async (e4) => {
        const i6 = 0 === e4.minScale || r4 <= e4.minScale, p2 = 0 === e4.maxScale || r4 >= e4.maxScale;
        if (e4.visible && i6 && p2) {
          if (e4.sublayers)
            e4.sublayers.forEach(o4);
          else if (e4.popupEnabled) {
            const r5 = s3(e4, { ...t4, defaultPopupTemplateEnabled: false });
            r(r5) && s4.unshift({ sublayer: e4, popupTemplate: r5 });
          }
        }
      }, i5 = e3.toArray().reverse().map(o4);
      return await Promise.all(i5), s4;
    }
    _loadArcadeModules(e3) {
      var _a;
      if (((_a = e3.expressionInfos) == null ? void 0 : _a.length) || Array.isArray(e3.content) && e3.content.some((e4) => "expression" === e4.type))
        return a2();
    }
  };
  return e([d()], g3.prototype, "exportImageParameters", void 0), e([d({ readOnly: true })], g3.prototype, "exportImageVersion", null), e([d()], g3.prototype, "layer", void 0), e([d()], g3.prototype, "suspended", void 0), e([d(g)], g3.prototype, "timeExtent", void 0), g3 = e([n("esri.views.layers.MapImageLayerView")], g3), g3;
};

export {
  x
};
//# sourceMappingURL=chunk-EGLS3G77.js.map
