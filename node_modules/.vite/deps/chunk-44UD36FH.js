import {
  i
} from "./chunk-ODYLXHP4.js";
import {
  l
} from "./chunk-DVE4HUBR.js";
import {
  o as o2
} from "./chunk-AWPZQDE5.js";
import {
  t as t2
} from "./chunk-DHZ2TSD5.js";
import {
  e as e4
} from "./chunk-FAF3GP2W.js";
import {
  o
} from "./chunk-BMA2CXVS.js";
import {
  e as e5
} from "./chunk-46N7XS5M.js";
import {
  e as e3
} from "./chunk-4MKQUQD4.js";
import {
  n as n2,
  t
} from "./chunk-NAB3NF54.js";
import {
  n as n3
} from "./chunk-MLAOYRDT.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  e as e2
} from "./chunk-YFBAFAZ2.js";
import {
  e
} from "./chunk-LUU3J646.js";
import {
  n
} from "./chunk-AIRC226G.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js
function o3(o4) {
  o4.attributes.add(O.POSITION, "vec3"), o4.vertex.code.add(n2`vec3 positionModel() { return position; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js
function F(r, o4) {
  r.include(o3);
  const e6 = r.vertex;
  e6.include(i, o4), r.varyings.add("vPositionWorldCameraRelative", "vec3"), r.varyings.add("vPosition_view", "vec3"), e6.uniforms.add([new e3("transformWorldFromViewTH", (r2) => r2.transformWorldFromViewTH), new e3("transformWorldFromViewTL", (r2) => r2.transformWorldFromViewTL), new e4("transformViewFromCameraRelativeRS", (r2) => r2.transformViewFromCameraRelativeRS), new e5("transformProjFromView", (r2) => r2.transformProjFromView), new o2("transformWorldFromModelRS", (r2) => r2.transformWorldFromModelRS), new o("transformWorldFromModelTH", (r2) => r2.transformWorldFromModelTH), new o("transformWorldFromModelTL", (r2) => r2.transformWorldFromModelTL)]), e6.code.add(n2`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = transformWorldFromModelRS * positionModel();
vec3 transform_CameraRelativeFromModel = dpAdd(
transformWorldFromModelTL,
transformWorldFromModelTH,
-transformWorldFromViewTL,
-transformWorldFromViewTH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}`), e6.code.add(n2`
    void forwardPosition(float fOffset) {
      vPositionWorldCameraRelative = positionWorldCameraRelative();
      if (fOffset != 0.0) {
        vPositionWorldCameraRelative += fOffset * ${o4.spherical ? n2`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)` : n2`vec3(0.0, 0.0, 1.0)`};
      }

      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;
      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);
    }
  `), r.fragment.uniforms.add(new e3("transformWorldFromViewTL", (r2) => r2.transformWorldFromViewTL)), e6.code.add(n2`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`), r.fragment.code.add(n2`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`);
}
var c = class extends t {
  constructor() {
    super(...arguments), this.transformWorldFromViewTH = n(), this.transformWorldFromViewTL = n(), this.transformViewFromCameraRelativeRS = e(), this.transformProjFromView = e2();
  }
};
var W = class extends t {
  constructor() {
    super(...arguments), this.transformWorldFromModelRS = e(), this.transformWorldFromModelTH = n3(), this.transformWorldFromModelTL = n3();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js
function t3(t4) {
  const a = t4.fragment.code;
  a.add(n2`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)
{
return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;
}`), a.add(n2`float integratedRadiance(float cosTheta2, float roughness)
{
return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);
}`), a.add(n2`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)
{
float cosTheta2 = 1.0 - RdotNG * RdotNG;
float intRadTheta = integratedRadiance(cosTheta2, roughness);
float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;
float sky = 2.0 - ground;
return (ground * ambientGround + sky * ambientSky) * 0.5;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js
function n4(n5, r) {
  const l2 = n5.fragment.code;
  n5.include(t2), r.pbrMode === l.Water || r.pbrMode === l.WaterOnIntegratedMesh ? (l2.add(n2`
    struct PBRShadingWater
    {
        float NdotL;   // cos angle between normal and light direction
        float NdotV;   // cos angle between normal and view direction
        float NdotH;   // cos angle between normal and half vector
        float VdotH;   // cos angle between view direction and half vector
        float LdotH;   // cos angle between light direction and half vector
        float VdotN;   // cos angle between view direction and normal vector
    };

    float dtrExponent = ${r.useCustomDTRExponentForWater ? "2.2" : "2.0"};
    `), l2.add(n2`vec3 fresnelReflection(float angle, vec3 f0, float f90) {
return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);
}`), l2.add(n2`float normalDistributionWater(float NdotH, float roughness)
{
float r2 = roughness * roughness;
float NdotH2 = NdotH * NdotH;
float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;
return r2 / denom;
}`), l2.add(n2`float geometricOcclusionKelemen(float LoH)
{
return 0.25 / (LoH * LoH);
}`), l2.add(n2`vec3 brdfSpecularWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)
{
vec3  F = fresnelReflection(props.VdotH, F0, F0Max);
float dSun = normalDistributionWater(props.NdotH, roughness);
float V = geometricOcclusionKelemen(props.LdotH);
float diffusionSunHaze = mix(roughness + 0.045, roughness + 0.385, 1.0 - props.VdotH);
float strengthSunHaze  = 1.2;
float dSunHaze = normalDistributionWater(props.NdotH, diffusionSunHaze)*strengthSunHaze;
return ((dSun + dSunHaze) * V) * F;
}
vec3 tonemapACES(const vec3 x) {
return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);
}`)) : r.pbrMode !== l.Normal && r.pbrMode !== l.Schematic || (n5.include(t3), l2.add(n2`struct PBRShadingInfo
{
float NdotL;
float NdotV;
float NdotH;
float VdotH;
float LdotH;
float NdotNG;
float RdotNG;
float NdotAmbDir;
float NdotH_Horizon;
vec3 skyRadianceToSurface;
vec3 groundRadianceToSurface;
vec3 skyIrradianceToSurface;
vec3 groundIrradianceToSurface;
float averageAmbientRadiance;
float ssao;
vec3 albedoLinear;
vec3 f0;
vec3 f90;
vec3 diffuseColor;
float metalness;
float roughness;
};`), l2.add(n2`float normalDistribution(float NdotH, float roughness)
{
float a = NdotH * roughness;
float b = roughness / (1.0 - NdotH * NdotH + a * a);
return b * b * INV_PI;
}`), l2.add(n2`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);
const vec2 c2 = vec2(-1.04, 1.04);
vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
return c2 * a004 + r.zw;
}`), l2.add(n2`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {
vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);
vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);
vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;
vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);
vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;
vec3 specularComponent = specularColor * indirectSpecular;
return (diffuseComponent + specularComponent);
}`), l2.add(n2`float gamutMapChanel(float x, vec2 p){
return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );
}`), l2.add(n2`vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){
vec3 outColor;
vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));
outColor.x = gamutMapChanel(inColor.x, p) ;
outColor.y = gamutMapChanel(inColor.y, p) ;
outColor.z = gamutMapChanel(inColor.z, p) ;
return outColor;
}`));
}

export {
  o3 as o,
  F,
  c,
  W,
  n4 as n
};
//# sourceMappingURL=chunk-44UD36FH.js.map
