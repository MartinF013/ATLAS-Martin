import {
  p as p2
} from "./chunk-2LGANX7J.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  f,
  h,
  l
} from "./chunk-T7BEWVV3.js";
import {
  d,
  e2,
  n4 as n,
  n5 as n2,
  n8 as n3,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  $,
  k,
  m,
  p
} from "./chunk-U3PSONS6.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  a2 as a,
  c,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/support/PromiseQueue.js
var i = class extends y {
  constructor() {
    super(...arguments), this._tasks = new Array(), this.running = false;
  }
  get length() {
    return this._tasks.length;
  }
  destroy() {
    this.cancelAll();
  }
  runTask(s2) {
    for (; !s2.done && this._process(s2); )
      s2.madeProgress();
  }
  push(s2, r2, t2) {
    return this.running = true, new Promise((e3, o) => this._tasks.push(new a2(e3, o, s2, r2, t2)));
  }
  unshift(s2, r2, t2) {
    return this.running = true, new Promise((e3, o) => this._tasks.unshift(new a2(e3, o, s2, r2, t2)));
  }
  _process(s2) {
    if (0 === this._tasks.length)
      return false;
    const r2 = this._tasks.shift();
    try {
      const c2 = p(r2.signal);
      if (c2 && !r2.abortCallback)
        r2.reject(m());
      else {
        const t2 = c2 ? r2.abortCallback(m()) : r2.callback(s2);
        k(t2) ? t2.then(r2.resolve, r2.reject) : r2.resolve(t2);
      }
    } catch (c2) {
      r2.reject(c2);
    }
    return this.running = this._tasks.length > 0, true;
  }
  cancelAll() {
    const s2 = m();
    for (const r2 of this._tasks)
      if (r2.abortCallback) {
        const t2 = r2.abortCallback(s2);
        r2.resolve(t2);
      } else
        r2.reject(s2);
    this._tasks.length = 0, this.running = false;
  }
};
e([d()], i.prototype, "running", void 0), i = e([n3("esri.layers.support.PromiseQueue")], i);
var a2 = class {
  constructor(s2, r2, t2, e3, o) {
    this.resolve = s2, this.reject = r2, this.callback = t2, this.signal = e3, this.abortCallback = o;
  }
};

// node_modules/@arcgis/core/views/support/Scheduler.js
var f2 = s.getLogger("esri.views.support.Scheduler");
function A() {
  return new D.Scheduler();
}
var L;
!function(e3) {
  e3.RESOURCE_CONTROLLER = "schedule", e3.SLIDE = "slide", e3.STREAM_DATA_LOADER = "stream loader", e3.ELEVATION_QUERY = "elevation query", e3.TERRAIN_SURFACE = "terrain", e3.SURFACE_GEOMETRY_UPDATES = "surface geometry updates", e3.GRAPHICS_CORE = "Graphics3D", e3.I3S_CONTROLLER = "I3S", e3.POINT_CLOUD_LAYER = "point cloud", e3.FEATURE_TILE_FETCHER = "feature fetcher", e3.OVERLAY = "overlay", e3.STAGE = "stage", e3.GRAPHICS_DECONFLICTOR = "graphics deconflictor", e3.FILTER_VISIBILITY = "Graphics3D filter visibility", e3.SCALE_VISIBILITY = "Graphics3D scale visibility", e3.FRUSTUM_VISIBILITY = "Graphics3D frustum visibility", e3.POINT_OF_INTEREST_FREQUENT = "POI frequent", e3.POINT_OF_INTEREST_INFREQUENT = "POI infrequent", e3.LABELER = "labeler", e3.FEATURE_QUERY_ENGINE = "feature query", e3.FEATURE_TILE_TREE = "feature tile tree", e3.FEATURE_TILE_TREE_ACTIVE = "fast feature tile tree", e3.ELEVATION_ALIGNMENT = "elevation alignment", e3.TEXT_TEXTURE_ATLAS = "text texture atlas", e3.TEXTURE_UNLOAD = "texture unload", e3.LINE_OF_SIGHT_TOOL = "line of sight tool", e3.LINE_OF_SIGHT_TOOL_INTERACTIVE = "interactive line of sight tool", e3.ELEVATION_PROFILE = "elevation profile", e3.SNAPPING = "snapping", e3.SHADOW_ACCUMULATOR = "shadow accumulator", e3.CLOUDS_GENERATOR = "cloud generator", e3[e3.TEST_PRIO = 1] = "TEST_PRIO";
}(L || (L = {}));
var S = 0;
var b = /* @__PURE__ */ new Map([[L.RESOURCE_CONTROLLER, S], [L.SLIDE, S], [L.STREAM_DATA_LOADER, S], [L.ELEVATION_QUERY, S], [L.TERRAIN_SURFACE, 1], [L.SURFACE_GEOMETRY_UPDATES, 1], [L.GRAPHICS_CORE, 2], [L.I3S_CONTROLLER, 2], [L.POINT_CLOUD_LAYER, 2], [L.FEATURE_TILE_FETCHER, 2], [L.OVERLAY, 4], [L.STAGE, 4], [L.GRAPHICS_DECONFLICTOR, 4], [L.FILTER_VISIBILITY, 4], [L.SCALE_VISIBILITY, 4], [L.FRUSTUM_VISIBILITY, 4], [L.POINT_OF_INTEREST_FREQUENT, 6], [L.POINT_OF_INTEREST_INFREQUENT, 30], [L.LABELER, 8], [L.FEATURE_QUERY_ENGINE, 8], [L.FEATURE_TILE_TREE, 16], [L.FEATURE_TILE_TREE_ACTIVE, S], [L.ELEVATION_ALIGNMENT, 12], [L.TEXT_TEXTURE_ATLAS, 12], [L.CLOUDS_GENERATOR, 12], [L.TEXTURE_UNLOAD, 12], [L.LINE_OF_SIGHT_TOOL, 16], [L.LINE_OF_SIGHT_TOOL_INTERACTIVE, S], [L.SNAPPING, S], [L.SHADOW_ACCUMULATOR, 30]]);
function k2(e3) {
  return b.has(e3) ? b.get(e3) : "number" == typeof e3 ? e3 : 1;
}
var N;
!function(e3) {
  e3[e3.ANIMATING = 0] = "ANIMATING", e3[e3.INTERACTING = 1] = "INTERACTING", e3[e3.IDLE = 2] = "IDLE";
}(N || (N = {}));
var O = n2(6.5);
var U = n2(1);
var P = n2(30);
var y2 = n2(1e3 / 30);
var C = n2(100);
var F = 0.9;
var D;
var G;
!function(r2) {
  let _ = class extends y {
    constructor() {
      super(), this.updating = true, this._microTaskQueued = false, this.performanceInfo = { total: new e2("total"), tasks: /* @__PURE__ */ new Map() }, this._frameTaskTimes = /* @__PURE__ */ new Map(), this._budget = new l2(), this._state = N.INTERACTING, this._tasks = new n(), this._runQueue = new n(), this._load = 0, this._idleStateCallbacks = new n(), this._idleUpdatesStartFired = false, this._maxReschedule = B, this._forceTask = false, this._debug = false, this._debugHandle = l(() => p2.SCHEDULER_LOG_SLOW_TASKS, (e4) => this._debug = e4, h);
      for (const s2 of Object.keys(L))
        this.performanceInfo.tasks.set(L[s2], new e2(L[s2]));
      let e3;
      const t2 = this;
      this._test = { get state() {
        return c(e3, t2._state);
      }, set state(t3) {
        e3 = t3;
      }, FRAME_SAFETY_BUDGET: O, INTERACTING_BUDGET: y2, IDLE_BUDGET: C, get availableBudget() {
        return t2._budget.budget;
      }, usedBudget: 0, getBudget: () => t2._budget, setBudget: (e4) => t2._budget = e4, updateTask: (e4) => this._updateTask(e4), getState: (e4) => this._getState(e4), getRuntime: (e4) => this._getRuntime(e4), frameTaskTimes: this._frameTaskTimes, resetRuntimes: () => this._resetRuntimes(), getRunning: () => this._getRunning() };
    }
    destroy() {
      this._tasks.toArray().forEach((e3) => e3.remove()), this._tasks.clear(), a(this._debugHandle), this._microTaskQueued = false, this.updating = false;
    }
    activate() {
      this._budget.done || this._microTaskQueued || (this._microTaskQueued = true, queueMicrotask(() => {
        this._microTaskQueued && (this._microTaskQueued = false, this._budget.done || (this._maxReschedule = B, this._schedule(), this.frame()));
      }));
    }
    registerTask(e3, t2) {
      const s2 = k2(e3), r3 = new d2(this, e3, t2, s2);
      return this._tasks.push(r3), this.performanceInfo.tasks.has(e3) || this.performanceInfo.tasks.set(e3, new e2(e3)), r3;
    }
    registerIdleStateCallbacks(e3, t2) {
      const s2 = { idleBegin: e3, idleEnd: t2 };
      this._idleStateCallbacks.push(s2), this.state === N.IDLE && this._idleUpdatesStartFired && s2.idleBegin();
      const r3 = this;
      return { remove: () => this._removeIdleStateCallbacks(s2), set idleBegin(e4) {
        r3._idleUpdatesStartFired && (s2.idleEnd(), r3._state === N.IDLE && e4()), s2.idleBegin = e4;
      }, set idleEnd(e4) {
        s2.idleEnd = e4;
      } };
    }
    get load() {
      return this._load;
    }
    set state(e3) {
      this._state !== e3 && (this._state = e3, this.state !== N.IDLE && this._idleUpdatesStartFired && (this._idleUpdatesStartFired = false, this._idleStateCallbacks.forAll((e4) => e4.idleEnd())));
    }
    get state() {
      return t(this._test.state) ? this._state : this._test.state;
    }
    updateBudget(e3) {
      this._test.usedBudget = 0;
      let t2 = O, s2 = e3.frameDuration, r3 = U;
      switch (this.state) {
        case N.IDLE:
          t2 = n2(0), s2 = n2(Math.max(C, e3.frameDuration)), r3 = P;
          break;
        case N.INTERACTING:
          s2 = n2(Math.max(y2, e3.frameDuration));
        case N.ANIMATING:
      }
      return s2 = n2(s2 - e3.elapsedFrameTime - t2), this.state !== N.IDLE && s2 < U && !this._forceTask ? (this._forceTask = true, false) : (s2 = n2(Math.max(s2, r3)), this._budget.reset(s2, this.state), this._maxReschedule = B, this._updateLoad(), this._schedule());
    }
    frame() {
      switch (this._forceTask = false, this._microTaskQueued = false, this.state) {
        case N.IDLE:
          this._idleUpdatesStartFired || (this._idleUpdatesStartFired = true, this._idleStateCallbacks.forAll((e3) => e3.idleBegin())), this._runIdle();
          break;
        case N.INTERACTING:
          this._runInteracting();
          break;
        default:
          this._runAnimating();
      }
      this._test.usedBudget = this._budget.elapsed;
    }
    stopFrame() {
      this._budget.reset(n2(0), this._state), this._budget.madeProgress();
    }
    _removeIdleStateCallbacks(e3) {
      this._idleUpdatesStartFired && e3.idleEnd(), this._idleStateCallbacks.removeUnordered(e3);
    }
    removeTask(e3) {
      this._tasks.removeUnordered(e3), this._runQueue.removeUnordered(e3);
    }
    _updateTask(e3) {
      this._tasks.forAll((t2) => {
        t2.name === e3 && t2.setPriority(e3);
      });
    }
    _getState(e3) {
      if (this._runQueue.some((t3) => t3.name === e3))
        return G.SCHEDULED;
      let t2 = G.IDLE;
      return this._tasks.forAll((s2) => {
        s2.name === e3 && s2.needsUpdate && (s2.schedulePriority <= 1 ? t2 = G.READY : t2 !== G.READY && (t2 = G.WAITING));
      }), t2;
    }
    _getRuntime(e3) {
      let t2 = 0;
      return this._tasks.forAll((s2) => {
        s2.name === e3 && (t2 += s2.runtime);
      }), t2;
    }
    _resetRuntimes() {
      this._tasks.forAll((e3) => e3.runtime = 0);
    }
    _getRunning() {
      const e3 = /* @__PURE__ */ new Map();
      if (this._tasks.forAll((t3) => {
        t3.needsUpdate && e3.set(t3.name, (e3.get(t3.name) || 0) + 1);
      }), 0 === e3.size)
        return null;
      let t2 = "";
      return e3.forEach((e4, s2) => {
        t2 += e4 > 1 ? ` ${e4}x ${s2}` : ` ${s2}`;
      }), t2;
    }
    _runIdle() {
      this._run();
    }
    _runInteracting() {
      this._run();
    }
    _runAnimating() {
      this._run();
    }
    _updateLoad() {
      const e3 = this._tasks.reduce((e4, t2) => t2.needsUpdate ? ++e4 : e4, 0);
      this._load = this._load * F + e3 * (1 - F);
    }
    _schedule() {
      if (this._maxReschedule <= 0)
        return false;
      for (this._runQueue.filterInPlace((e3) => !!e3.needsUpdate || (e3.schedulePriority = e3.basePriority, false)), this._tasks.forAll((e3) => {
        e3.basePriority === S && e3.needsUpdate && !this._runQueue.includes(e3) && this._runQueue.unshift(e3);
      }); 0 === this._runQueue.length; ) {
        let e3 = false, t2 = 0;
        if (this._tasks.forAll((s2) => {
          if (s2.needsUpdate && 0 !== s2.schedulePriority && s2.basePriority !== S)
            if (e3 = true, t2 = Math.max(t2, s2.basePriority), 1 === s2.schedulePriority)
              s2.schedulePriority = 0, this._runQueue.push(s2);
            else
              --s2.schedulePriority;
        }), !e3)
          return this.updating = false, false;
        this._maxReschedule === B && (this._maxReschedule = t2), --this._maxReschedule;
      }
      return this.updating = true, true;
    }
    _run() {
      const e3 = this._budget.now();
      this._startFrameTaskTimes();
      do {
        for (; this._runQueue.length > 0; ) {
          const s2 = this._budget.now(), r3 = this._runQueue.pop();
          this._budget.resetProgress();
          try {
            r3.task.runTask(this._budget);
          } catch (t2) {
            f2.error(`Exception in task "${r3.name}"`, t2);
          }
          r3.schedulePriority = r3.basePriority;
          const i2 = this._budget.now() - s2;
          if (r3.runtime += i2, this._frameTaskTimes.set(r3.priority, this._frameTaskTimes.get(r3.priority) + i2), this._debug && this._budget.elapsed > 2 * this._budget.budget && console.log("Task", r3.name, "used", this._budget.elapsed, "of max", this._budget.budget, "ms"), this._budget.remaining <= 0)
            return this.updating = this._tasks.some((e4) => e4.needsUpdate), void this._recordFrameTaskTimes(this._budget.now() - e3);
        }
      } while (this._schedule());
      this.updating = this._tasks.some((e4) => e4.needsUpdate), this._recordFrameTaskTimes(this._budget.now() - e3);
    }
    _startFrameTaskTimes() {
      for (const e3 of Object.keys(L))
        this._frameTaskTimes.set(L[e3], 0);
    }
    _recordFrameTaskTimes(e3) {
      this._frameTaskTimes.forEach((e4, t2) => this.performanceInfo.tasks.get(t2).record(e4)), this.performanceInfo.total.record(e3);
    }
    get test() {
      return this._test;
    }
  };
  e([d()], _.prototype, "updating", void 0), _ = e([n3("esri.views.support.Scheduler")], _), r2.Scheduler = _;
  let d2 = class extends y {
    constructor(e3, t2, r3, i2) {
      super({}), this._scheduler = e3, this.name = t2, this._basePriority = i2, this.runtime = 0, this._queue = new i(), this._handles = new u(), this.schedulePriority = this._basePriority, this.task = r(r3) ? r3 : this._queue, this._handles.add(f(() => this.task.running, () => e3.activate()));
    }
    get updating() {
      return this._queue.running;
    }
    normalizeCtorArgs() {
      return {};
    }
    remove() {
      this.processQueue(w), this._scheduler.removeTask(this), this.schedule = Q.schedule, this.reschedule = Q.reschedule, this._handles.destroy();
    }
    get basePriority() {
      return this._basePriority;
    }
    setPriority(e3) {
      this.name = e3;
      const t2 = k2(e3);
      this._basePriority !== S && 0 === this.schedulePriority || (this.schedulePriority = t2), this._basePriority = t2;
    }
    get priority() {
      return this.name;
    }
    set priority(e3) {
      this.setPriority(e3);
    }
    get needsUpdate() {
      return this.updating || this.task.running;
    }
    schedule(e3, t2, s2) {
      return this._queue.push(e3, t2, s2);
    }
    reschedule(e3, t2, s2) {
      return this._queue.unshift(e3, t2, s2);
    }
    processQueue(e3) {
      this._queue.runTask(e3);
    }
  };
  e([d({ constructOnly: true })], d2.prototype, "task", void 0), e([d({ readOnly: true })], d2.prototype, "updating", null), d2 = e([n3("esri.views.support.SchedulerTask")], d2);
  class l2 {
    constructor() {
      this._begin = "undefined" != typeof performance ? performance.now() : 0, this._budget = 0, this._state = N.IDLE, this._didWork = false, this._enabled = true;
    }
    run(e3) {
      return !this.done && (true === e3() && (this._didWork = true), true);
    }
    get done() {
      return this._didWork && this.elapsed >= this._budget && this._enabled;
    }
    get budget() {
      return this._budget;
    }
    madeProgress() {
      this._didWork = true;
    }
    get state() {
      return this._state;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(e3) {
      this._enabled = e3;
    }
    reset(e3, t2) {
      this._begin = this.now(), this._budget = e3, this._state = t2, this._didWork = false;
    }
    get remaining() {
      return Math.max(this._budget - this.elapsed, 0);
    }
    now() {
      return performance.now();
    }
    get elapsed() {
      return performance.now() - this._begin;
    }
    resetProgress() {
      this._didWork = false;
    }
    get hasProgressed() {
      return this._didWork;
    }
  }
  r2.Budget = l2;
}(D || (D = {})), function(e3) {
  e3.SCHEDULED = "s", e3.READY = "r", e3.WAITING = "w", e3.IDLE = "i";
}(G || (G = {}));
var w = (() => {
  const e3 = new D.Budget();
  return e3.enabled = false, e3;
})();
var v = class {
  remove() {
  }
  processQueue() {
  }
  schedule(e3, t2, s2) {
    try {
      if (p(t2)) {
        const e4 = m();
        return s2 ? Promise.resolve(s2(e4)) : Promise.reject(e4);
      }
      return $(e3(w));
    } catch (r2) {
      return Promise.reject(r2);
    }
  }
  reschedule(e3, t2, s2) {
    return this.schedule(e3, t2, s2);
  }
};
var Q = new v();
var B = Number.MAX_SAFE_INTEGER;

export {
  i,
  A,
  L,
  N,
  w,
  Q
};
//# sourceMappingURL=chunk-JZY7CGEI.js.map
