{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{glsl as e}from\"../../shaderModules/interfaces.js\";import{VertexAttribute as t}from\"../../../lib/VertexAttribute.js\";function o(o){o.attributes.add(t.POSITION,\"vec3\"),o.vertex.code.add(e`vec3 positionModel() { return position; }`)}export{o as PositionAttribute};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{c as r}from\"../../../../../../chunks/mat3f64.js\";import{c as o}from\"../../../../../../chunks/mat4f64.js\";import{c as e}from\"../../../../../../chunks/vec3f32.js\";import{c as t}from\"../../../../../../chunks/vec3f64.js\";import{PositionAttribute as a}from\"./PositionAttribute.glsl.js\";import{DoublePrecision as s}from\"../util/DoublePrecision.glsl.js\";import{Float3DrawUniform as i}from\"../../shaderModules/Float3DrawUniform.js\";import{Float3PassUniform as m}from\"../../shaderModules/Float3PassUniform.js\";import{glsl as d,NoParameters as n}from\"../../shaderModules/interfaces.js\";import{Matrix3DrawUniform as l}from\"../../shaderModules/Matrix3DrawUniform.js\";import{Matrix3PassUniform as f}from\"../../shaderModules/Matrix3PassUniform.js\";import{Matrix4PassUniform as v}from\"../../shaderModules/Matrix4PassUniform.js\";function F(r,o){r.include(a);const e=r.vertex;e.include(s,o),r.varyings.add(\"vPositionWorldCameraRelative\",\"vec3\"),r.varyings.add(\"vPosition_view\",\"vec3\"),e.uniforms.add([new m(\"transformWorldFromViewTH\",(r=>r.transformWorldFromViewTH)),new m(\"transformWorldFromViewTL\",(r=>r.transformWorldFromViewTL)),new f(\"transformViewFromCameraRelativeRS\",(r=>r.transformViewFromCameraRelativeRS)),new v(\"transformProjFromView\",(r=>r.transformProjFromView)),new l(\"transformWorldFromModelRS\",(r=>r.transformWorldFromModelRS)),new i(\"transformWorldFromModelTH\",(r=>r.transformWorldFromModelTH)),new i(\"transformWorldFromModelTL\",(r=>r.transformWorldFromModelTL))]),e.code.add(d`vec3 positionWorldCameraRelative() {\nvec3 rotatedModelPosition = transformWorldFromModelRS * positionModel();\nvec3 transform_CameraRelativeFromModel = dpAdd(\ntransformWorldFromModelTL,\ntransformWorldFromModelTH,\n-transformWorldFromViewTL,\n-transformWorldFromViewTH\n);\nreturn transform_CameraRelativeFromModel + rotatedModelPosition;\n}`),e.code.add(d`\n    void forwardPosition(float fOffset) {\n      vPositionWorldCameraRelative = positionWorldCameraRelative();\n      if (fOffset != 0.0) {\n        vPositionWorldCameraRelative += fOffset * ${o.spherical?d`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)`:d`vec3(0.0, 0.0, 1.0)`};\n      }\n\n      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;\n      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);\n    }\n  `),r.fragment.uniforms.add(new m(\"transformWorldFromViewTL\",(r=>r.transformWorldFromViewTL))),e.code.add(d`vec3 positionWorld() {\nreturn transformWorldFromViewTL + vPositionWorldCameraRelative;\n}`),r.fragment.code.add(d`vec3 positionWorld() {\nreturn transformWorldFromViewTL + vPositionWorldCameraRelative;\n}`)}class c extends n{constructor(){super(...arguments),this.transformWorldFromViewTH=t(),this.transformWorldFromViewTL=t(),this.transformViewFromCameraRelativeRS=r(),this.transformProjFromView=o()}}class W extends n{constructor(){super(...arguments),this.transformWorldFromModelRS=r(),this.transformWorldFromModelTH=e(),this.transformWorldFromModelTL=e()}}export{F as VertexPosition,W as VertexPositionDrawParameters,c as VertexPositionPassParameters};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{glsl as e}from\"../../shaderModules/interfaces.js\";function t(t){const a=t.fragment.code;a.add(e`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)\n{\nreturn ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n}`),a.add(e`float integratedRadiance(float cosTheta2, float roughness)\n{\nreturn (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);\n}`),a.add(e`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)\n{\nfloat cosTheta2 = 1.0 - RdotNG * RdotNG;\nfloat intRadTheta = integratedRadiance(cosTheta2, roughness);\nfloat ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;\nfloat sky = 2.0 - ground;\nreturn (ground * ambientGround + sky * ambientSky) * 0.5;\n}`)}export{t as AnalyticalSkyModel};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.24/esri/copyright.txt for details.\n*/\nimport{AnalyticalSkyModel as e}from\"./AnalyticalSkyModel.glsl.js\";import{PBRMode as o}from\"./PhysicallyBasedRenderingParameters.glsl.js\";import{PiUtils as t}from\"./PiUtils.glsl.js\";import{glsl as a}from\"../../shaderModules/interfaces.js\";function n(n,r){const l=n.fragment.code;n.include(t),r.pbrMode===o.Water||r.pbrMode===o.WaterOnIntegratedMesh?(l.add(a`\n    struct PBRShadingWater\n    {\n        float NdotL;   // cos angle between normal and light direction\n        float NdotV;   // cos angle between normal and view direction\n        float NdotH;   // cos angle between normal and half vector\n        float VdotH;   // cos angle between view direction and half vector\n        float LdotH;   // cos angle between light direction and half vector\n        float VdotN;   // cos angle between view direction and normal vector\n    };\n\n    float dtrExponent = ${r.useCustomDTRExponentForWater?\"2.2\":\"2.0\"};\n    `),l.add(a`vec3 fresnelReflection(float angle, vec3 f0, float f90) {\nreturn f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n}`),l.add(a`float normalDistributionWater(float NdotH, float roughness)\n{\nfloat r2 = roughness * roughness;\nfloat NdotH2 = NdotH * NdotH;\nfloat denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;\nreturn r2 / denom;\n}`),l.add(a`float geometricOcclusionKelemen(float LoH)\n{\nreturn 0.25 / (LoH * LoH);\n}`),l.add(a`vec3 brdfSpecularWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)\n{\nvec3  F = fresnelReflection(props.VdotH, F0, F0Max);\nfloat dSun = normalDistributionWater(props.NdotH, roughness);\nfloat V = geometricOcclusionKelemen(props.LdotH);\nfloat diffusionSunHaze = mix(roughness + 0.045, roughness + 0.385, 1.0 - props.VdotH);\nfloat strengthSunHaze  = 1.2;\nfloat dSunHaze = normalDistributionWater(props.NdotH, diffusionSunHaze)*strengthSunHaze;\nreturn ((dSun + dSunHaze) * V) * F;\n}\nvec3 tonemapACES(const vec3 x) {\nreturn (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n}`)):r.pbrMode!==o.Normal&&r.pbrMode!==o.Schematic||(n.include(e),l.add(a`struct PBRShadingInfo\n{\nfloat NdotL;\nfloat NdotV;\nfloat NdotH;\nfloat VdotH;\nfloat LdotH;\nfloat NdotNG;\nfloat RdotNG;\nfloat NdotAmbDir;\nfloat NdotH_Horizon;\nvec3 skyRadianceToSurface;\nvec3 groundRadianceToSurface;\nvec3 skyIrradianceToSurface;\nvec3 groundIrradianceToSurface;\nfloat averageAmbientRadiance;\nfloat ssao;\nvec3 albedoLinear;\nvec3 f0;\nvec3 f90;\nvec3 diffuseColor;\nfloat metalness;\nfloat roughness;\n};`),l.add(a`float normalDistribution(float NdotH, float roughness)\n{\nfloat a = NdotH * roughness;\nfloat b = roughness / (1.0 - NdotH * NdotH + a * a);\nreturn b * b * INV_PI;\n}`),l.add(a`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\nconst vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\nconst vec2 c2 = vec2(-1.04, 1.04);\nvec2 prefilteredDFGAnalytical(float roughness, float NdotV) {\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;\nreturn c2 * a004 + r.zw;\n}`),l.add(a`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {\nvec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);\nvec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);\nvec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;\nvec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);\nvec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;\nvec3 specularComponent = specularColor * indirectSpecular;\nreturn (diffuseComponent + specularComponent);\n}`),l.add(a`float gamutMapChanel(float x, vec2 p){\nreturn (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );\n}`),l.add(a`vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){\nvec3 outColor;\nvec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));\noutColor.x = gamutMapChanel(inColor.x, p) ;\noutColor.y = gamutMapChanel(inColor.y, p) ;\noutColor.z = gamutMapChanel(inColor.z, p) ;\nreturn outColor;\n}`))}export{n as PhysicallyBasedRendering};\n"],
  "mappings": "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",
  "names": ["o", "n", "o", "e", "r", "n", "t", "n", "n", "l", "t"]
}
