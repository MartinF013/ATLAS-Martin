import {
  A as A2,
  E,
  F as F2,
  J,
  L as L2,
  O,
  U2 as U,
  Z,
  p2,
  q2,
  x2,
  z as z2
} from "./chunk-53KI6WDE.js";
import {
  f,
  h as h2,
  n as n2
} from "./chunk-W2HLA6I3.js";
import {
  A,
  b,
  v as v2
} from "./chunk-Q6AASANP.js";
import {
  c,
  s as s3
} from "./chunk-ZYIEYKCD.js";
import {
  e as e2
} from "./chunk-YFBAFAZ2.js";
import {
  h,
  o as o2,
  p
} from "./chunk-ASC3X65B.js";
import {
  l
} from "./chunk-BPZGJQOB.js";
import {
  F,
  H,
  L,
  P,
  e,
  o,
  q,
  r as r2,
  s as s2,
  u,
  v,
  x,
  z
} from "./chunk-PKZEO23A.js";
import {
  n,
  r,
  t
} from "./chunk-AIRC226G.js";
import {
  s
} from "./chunk-CVWDM4C7.js";

// node_modules/@arcgis/core/chunks/boundedPlane.js
var L3 = s.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");
var z3 = class {
  constructor() {
    this.plane = p2(), this.origin = n(), this.basis1 = n(), this.basis2 = n();
  }
};
function G(s4 = vs) {
  return { plane: p2(s4.plane), origin: t(s4.origin), basis1: t(s4.basis1), basis2: t(s4.basis2) };
}
function W(s4, i, t2) {
  const n3 = Ss.get();
  return n3.origin = s4, n3.basis1 = i, n3.basis2 = t2, n3.plane = E(0, 0, 0, 0), H2(n3), n3;
}
function X(s4, i = G()) {
  return D(s4.origin, s4.basis1, s4.basis2, i);
}
function Z2(s4, i) {
  r2(i.origin, s4.origin), r2(i.basis1, s4.basis1), r2(i.basis2, s4.basis2), A2(i.plane, s4.plane);
}
function D(s4, i, t2, n3 = G()) {
  return r2(n3.origin, s4), r2(n3.basis1, i), r2(n3.basis2, t2), H2(n3), ys(n3, "fromValues()"), n3;
}
function H2(s4) {
  O(s4.basis2, s4.basis1, s4.origin, s4.plane);
}
function J2(s4, i, t2) {
  s4 !== t2 && X(s4, t2);
  const n3 = q(c.get(), ms(s4), i);
  return u(t2.origin, t2.origin, n3), t2.plane[3] -= i, t2;
}
function K(s4, i, t2) {
  return Q(i, t2), J2(t2, gs(s4, s4.origin), t2), t2;
}
function Q(s4, i = G()) {
  const t2 = (s4[2] - s4[0]) / 2, n3 = (s4[3] - s4[1]) / 2;
  return o(i.origin, s4[0] + t2, s4[1] + n3, 0), o(i.basis1, t2, 0, 0), o(i.basis2, 0, n3, 0), F2(0, 0, 1, 0, i.plane), i;
}
function $(s4, i, t2) {
  return !!q2(s4.plane, i, t2) && hs(s4, t2);
}
function ss(s4, i, t2) {
  if ($(s4, i, t2))
    return t2;
  const n3 = is(s4, i, c.get());
  return u(t2, i.origin, q(c.get(), i.direction, x(i.origin, n3) / s2(i.direction))), t2;
}
function is(s4, t2, n3) {
  const o3 = Ns.get();
  Ps(s4, t2, o3, Ns.get());
  let r3 = Number.POSITIVE_INFINITY;
  for (const e3 of Ts) {
    const a = Is(s4, e3, ws.get()), u2 = c.get();
    if (x2(o3, a, u2)) {
      const s5 = H(c.get(), t2.origin, u2), o4 = Math.abs(l(P(t2.direction, s5)));
      o4 < r3 && (r3 = o4, r2(n3, u2));
    }
  }
  return r3 === Number.POSITIVE_INFINITY ? ts(s4, t2, n3) : n3;
}
function ts(s4, i, t2) {
  if ($(s4, i, t2))
    return t2;
  const n3 = Ns.get(), o3 = Ns.get();
  Ps(s4, i, n3, o3);
  let r3 = Number.POSITIVE_INFINITY;
  for (const e3 of Ts) {
    const a = Is(s4, e3, ws.get()), u2 = c.get();
    if (U(n3, a, u2)) {
      const s5 = h2(i, u2);
      if (!z2(o3, u2))
        continue;
      s5 < r3 && (r3 = s5, r2(t2, u2));
    }
  }
  return rs(s4, i.origin) < r3 && ns(s4, i.origin, t2), t2;
}
function ns(s4, i, t2) {
  const n3 = J(s4.plane, i, c.get()), o3 = A(js(s4, s4.basis1), n3, -1, 1, c.get()), r3 = A(js(s4, s4.basis2), n3, -1, 1, c.get());
  return e(t2, u(c.get(), o3, r3), s4.origin), t2;
}
function os(s4, i, t2) {
  const { origin: n3, basis1: o3, basis2: r3 } = s4, e3 = e(c.get(), i, n3), a = f(o3, e3), c2 = f(r3, e3), u2 = f(ms(s4), e3);
  return o(t2, a, c2, u2);
}
function rs(s4, i) {
  const t2 = os(s4, i, c.get()), { basis1: n3, basis2: o3 } = s4, r3 = s2(n3), e3 = s2(o3), a = Math.max(Math.abs(t2[0]) - r3, 0), c2 = Math.max(Math.abs(t2[1]) - e3, 0), u2 = t2[2];
  return a * a + c2 * c2 + u2 * u2;
}
function es(s4, i) {
  return Math.sqrt(rs(s4, i));
}
function as(s4, i) {
  let t2 = Number.NEGATIVE_INFINITY;
  for (const n3 of Ts) {
    const o3 = Is(s4, n3, ws.get()), r3 = b(o3, i);
    r3 > t2 && (t2 = r3);
  }
  return Math.sqrt(t2);
}
function cs(s4, i) {
  return z2(s4.plane, i) && hs(s4, i);
}
function us(s4, i, t2, n3) {
  return ds(s4, t2, n3);
}
function gs(s4, i) {
  const t2 = -s4.plane[3];
  return f(ms(s4), i) - t2;
}
function bs(s4, i, t2, n3) {
  const o3 = gs(s4, i), r3 = q(Ms, ms(s4), t2 - o3);
  return u(n3, i, r3), n3;
}
function fs(s4, i) {
  return F(s4.basis1, i.basis1) && F(s4.basis2, i.basis2) && F(s4.origin, i.origin);
}
function ls(s4, i, t2) {
  return s4 !== t2 && X(s4, t2), h(As, i), o2(As, As), L(t2.basis1, s4.basis1, As), L(t2.basis2, s4.basis2, As), L(Z(t2.plane), Z(s4.plane), As), L(t2.origin, s4.origin, i), L2(t2.plane, t2.plane, t2.origin), t2;
}
function ps(s4, i, t2, n3) {
  return s4 !== n3 && X(s4, n3), p(xs, i, t2), L(n3.basis1, s4.basis1, xs), L(n3.basis2, s4.basis2, xs), H2(n3), n3;
}
function ms(s4) {
  return Z(s4.plane);
}
function ds(s4, i, t2) {
  switch (i) {
    case n2.X:
      r2(t2, s4.basis1), z(t2, t2);
      break;
    case n2.Y:
      r2(t2, s4.basis2), z(t2, t2);
      break;
    case n2.Z:
      r2(t2, ms(s4));
  }
  return t2;
}
function hs(s4, i) {
  const t2 = e(c.get(), i, s4.origin), n3 = v(s4.basis1), o3 = v(s4.basis2), r3 = P(s4.basis1, t2), e3 = P(s4.basis2, t2);
  return -r3 - n3 < 0 && r3 - n3 < 0 && -e3 - o3 < 0 && e3 - o3 < 0;
}
function js(s4, i) {
  const t2 = ws.get();
  return r2(t2.origin, s4.origin), r2(t2.vector, i), t2;
}
function Is(s4, i, t2) {
  const { basis1: n3, basis2: o3, origin: r3 } = s4, e3 = q(c.get(), n3, i.origin[0]), a = q(c.get(), o3, i.origin[1]);
  u(t2.origin, e3, a), u(t2.origin, t2.origin, r3);
  const c2 = q(c.get(), n3, i.direction[0]), b2 = q(c.get(), o3, i.direction[1]);
  return q(t2.vector, u(c2, c2, b2), 2), t2;
}
function ys(s4, i) {
  Math.abs(P(s4.basis1, s4.basis2) / (s2(s4.basis1) * s2(s4.basis2))) > 1e-6 && L3.warn(i, "Provided basis vectors are not perpendicular"), Math.abs(P(s4.basis1, ms(s4))) > 1e-6 && L3.warn(i, "Basis vectors and plane normal are not perpendicular"), Math.abs(-P(ms(s4), s4.origin) - s4.plane[3]) > 1e-6 && L3.warn(i, "Plane offset is not consistent with plane origin");
}
function Ps(s4, i, t2, n3) {
  const o3 = ms(s4);
  O(o3, i.direction, i.origin, t2), O(Z(t2), o3, i.origin, n3);
}
var vs = { plane: p2(), origin: r(0, 0, 0), basis1: r(1, 0, 0), basis2: r(0, 1, 0) };
var Ns = new s3(p2);
var ws = new s3(v2);
var Ms = n();
var Ss = new s3(() => ({ origin: null, basis1: null, basis2: null, plane: null }));
var Ts = [{ origin: [-1, -1], direction: [1, 0] }, { origin: [1, -1], direction: [0, 1] }, { origin: [1, 1], direction: [-1, 0] }, { origin: [-1, 1], direction: [0, -1] }];
var As = e2();
var xs = e2();
var Vs = Object.freeze(Object.defineProperty({ __proto__: null, BoundedPlaneClass: z3, create: G, wrap: W, copy: X, copyWithoutVerify: Z2, fromValues: D, updateUnboundedPlane: H2, elevate: J2, setExtent: K, fromAABoundingRect: Q, intersectRay: $, intersectRayClosestSilhouette: ss, closestPointOnSilhouette: is, closestPoint: ts, projectPoint: ns, projectPointLocal: os, distance2: rs, distance: es, distanceToSilhouette: as, extrusionContainsPoint: cs, axisAt: us, altitudeAt: gs, setAltitudeAt: bs, equals: fs, transform: ls, rotate: ps, normal: ms, UP: vs }, Symbol.toStringTag, { value: "Module" }));

export {
  z3 as z,
  G,
  X,
  D,
  H2 as H,
  Q,
  $,
  es,
  cs,
  fs,
  ls,
  ps,
  ms,
  Vs
};
//# sourceMappingURL=chunk-7GTYHKA3.js.map
