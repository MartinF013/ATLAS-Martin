import {
  n as n3
} from "./chunk-JYMQQ22E.js";
import {
  O,
  P
} from "./chunk-EHWEX2VK.js";
import {
  H
} from "./chunk-Y75V5CF3.js";
import {
  n as n2,
  r as r2,
  t as t2
} from "./chunk-KD6KBT2L.js";
import {
  h
} from "./chunk-EEJIELE6.js";
import {
  e
} from "./chunk-YFBAFAZ2.js";
import {
  x
} from "./chunk-ASC3X65B.js";
import {
  D,
  a
} from "./chunk-ZOKX6UGH.js";
import {
  L,
  o
} from "./chunk-PKZEO23A.js";
import {
  f,
  n
} from "./chunk-AIRC226G.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/interactive/visualElements/LineVisualElement.js
var C = class extends n3 {
  constructor(e2) {
    super(e2), this._renderOccluded = h.OccludeAndTransparent, this._width = 1, this._color = r2(1, 0, 1, 1), this._innerWidth = 1, this._innerColor = null, this._stipplePattern = null, this._stippleOffColor = null, this._stipplePreferContinuous = true, this._writeDepthEnabled = true, this._falloff = 0, this._polygonOffset = false, this.applyProps(e2);
  }
  setGeometryFromRenderSpacePoint(e2, t3 = 1e3) {
    const r3 = [];
    r3.push([[e2[0] - t3, e2[1] + 0, e2[2] + 0], [e2[0] + t3, e2[1] + 0, e2[2] + 0]]), r3.push([[e2[0] - 0, e2[1] - t3, e2[2] + 0], [e2[0] + 0, e2[1] + t3, e2[2] + 0]]), r3.push([[e2[0] - 0, e2[1] + 0, e2[2] - t3], [e2[0] + 0, e2[1] + 0, e2[2] + t3]]), this.geometry = r3;
  }
  setGeometryFromExtent(e2) {
    const t3 = this.view.spatialReference, r3 = n(), s = n(), o2 = 100, n4 = [];
    o(r3, e2[0], e2[1], o2), this.view.renderCoordsHelper.toRenderCoords(r3, t3, s), n4.push([s[0], s[1], s[2]]), o(r3, e2[2], e2[1], o2), this.view.renderCoordsHelper.toRenderCoords(r3, t3, s), n4.push([s[0], s[1], s[2]]), o(r3, e2[2], e2[3], o2), this.view.renderCoordsHelper.toRenderCoords(r3, t3, s), n4.push([s[0], s[1], s[2]]), o(r3, e2[0], e2[3], o2), this.view.renderCoordsHelper.toRenderCoords(r3, t3, s), n4.push([s[0], s[1], s[2]]), o(r3, e2[0], e2[1], o2), this.view.renderCoordsHelper.toRenderCoords(r3, t3, s), n4.push([s[0], s[1], s[2]]), o(r3, e2[0], e2[1], o2), this.view.renderCoordsHelper.toRenderCoords(r3, t3, s), n4.push([s[0], s[1], s[2]]), this.geometry = [n4];
  }
  setGeometryFromFrustum(e2) {
    const t3 = [];
    e2.lines.forEach((e3) => {
      t3.push([e3.origin[0], e3.origin[1], e3.origin[2]]), t3.push([e3.endpoint[0], e3.endpoint[1], e3.endpoint[2]]);
    }), this.geometry = [t3];
  }
  setGeometryFromBoundedPlane(e2) {
    const t3 = [], r3 = e2.origin, s = e2.basis1, i = e2.basis2, o2 = 0.5, n4 = n(), h2 = n(), a2 = n(), p = n();
    n4[0] = r3[0] - s[0] * o2 - i[0] * o2, n4[1] = r3[1] - s[1] * o2 - i[1] * o2, n4[2] = r3[2] - s[2] * o2 - i[2] * o2, h2[0] = r3[0] - s[0] * o2 + i[0] * o2, h2[1] = r3[1] - s[1] * o2 + i[1] * o2, h2[2] = r3[2] - s[2] * o2 + i[2] * o2, a2[0] = r3[0] + s[0] * o2 + i[0] * o2, a2[1] = r3[1] + s[1] * o2 + i[1] * o2, a2[2] = r3[2] + s[2] * o2 + i[2] * o2, p[0] = r3[0] + s[0] * o2 - i[0] * o2, p[1] = r3[1] + s[1] * o2 - i[1] * o2, p[2] = r3[2] + s[2] * o2 - i[2] * o2, t3.push([n4[0], n4[1], n4[2]]), t3.push([h2[0], h2[1], h2[2]]), t3.push([a2[0], a2[1], a2[2]]), t3.push([p[0], p[1], p[2]]), t3.push([n4[0], n4[1], n4[2]]), this.geometry = [t3];
  }
  setGeometryFromSegment(e2) {
    const t3 = e2.endRenderSpace;
    this.transform = x(y, t3);
    const { points: s } = e2.createRenderGeometry(t3, this.view.renderCoordsHelper);
    this.geometry = [s];
  }
  setGeometryFromSegments(e2, t3 = f) {
    this.transform = x(y, t3), this.geometry = e2.map((e3) => e3.createRenderGeometry(t3, this.view.renderCoordsHelper).points);
  }
  getTransformedGeometry() {
    return t(this._geometry) ? null : this._geometry.map((e2) => e2.map((e3) => L(n(), e3, this.transform)));
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e2) {
    e2 !== this._renderOccluded && (this._renderOccluded = e2, this._updateMaterial());
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e2) {
    this._geometry = e2, this.recreateGeometry();
  }
  get width() {
    return this._width;
  }
  set width(e2) {
    e2 !== this._width && (this._width = e2, this._updateMaterial());
  }
  get color() {
    return this._color;
  }
  set color(e2) {
    D(e2, this._color) || (a(this._color, e2), this._updateMaterial());
  }
  get innerWidth() {
    return this._innerWidth;
  }
  set innerWidth(e2) {
    e2 !== this._innerWidth && (this._innerWidth = e2, this._updateMaterial());
  }
  get innerColor() {
    return this._innerColor;
  }
  set innerColor(r3) {
    r(r3) ? !t(this._innerColor) && D(r3, this._innerColor) || (this._innerColor = a(n2(), r3), this._updateMaterial()) : r(this._innerColor) && (this._innerColor = null, this._updateMaterial());
  }
  get stipplePattern() {
    return this._stipplePattern;
  }
  set stipplePattern(e2) {
    const r3 = r(e2) !== r(this._stipplePattern);
    this._stipplePattern = e2, r3 ? this.recreate() : this._updateMaterial();
  }
  get stippleOffColor() {
    return this._stippleOffColor;
  }
  set stippleOffColor(r3) {
    (t(r3) || t(this._stippleOffColor) || !D(r3, this._stippleOffColor)) && (this._stippleOffColor = r(r3) ? t2(r3) : null, this._updateMaterial());
  }
  get stipplePreferContinuous() {
    return this._stipplePreferContinuous;
  }
  set stipplePreferContinuous(e2) {
    this._stipplePreferContinuous !== e2 && (this._stipplePreferContinuous = e2, this._updateMaterial());
  }
  get writeDepthEnabled() {
    return this._writeDepthEnabled;
  }
  set writeDepthEnabled(e2) {
    this._writeDepthEnabled !== e2 && (this._writeDepthEnabled = e2, this._updateMaterial());
  }
  get falloff() {
    return this._falloff;
  }
  set falloff(e2) {
    e2 !== this._falloff && (this._falloff = e2, this._updateMaterial());
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(e2) {
    e2 !== this._polygonOffset && (this._polygonOffset = e2, this._updateMaterial());
  }
  createExternalResources() {
    this._material = new H(this.materialParameters);
  }
  destroyExternalResources() {
    this._material = null;
  }
  createGeometries(e2) {
    const t3 = this._createLineGeometries();
    if (0 !== t3.length)
      for (let r3 = 0; r3 < t3.length; ++r3) {
        const s = O(t3[r3]);
        e2.addGeometry(s, this._material);
      }
  }
  forEachExternalMaterial(e2) {
    e2(this._material);
  }
  get materialParameters() {
    return { width: this._width, color: this._color, stippleOffColor: this._stippleOffColor, stipplePattern: this._stipplePattern, stipplePreferContinuous: this._stipplePreferContinuous, isClosed: false, falloff: this._falloff, innerColor: this._innerColor, innerWidth: this._innerWidth, hasPolygonOffset: this._polygonOffset, renderOccluded: this._renderOccluded, writeDepth: this._writeDepthEnabled };
  }
  _updateMaterial() {
    this.attached && this._material.setParameters(this.materialParameters);
  }
  _createLineGeometries() {
    const t3 = this.geometry;
    if (t(t3) || 0 === t3.length)
      return [];
    const r3 = [];
    return t3.forEach((e2) => {
      const t4 = e2.length, s = new Float64Array(3 * t4);
      e2.forEach((e3, t5) => {
        s[3 * t5 + 0] = e3[0], s[3 * t5 + 1] = e3[1], s[3 * t5 + 2] = e3[2];
      });
      const i = { overlayInfo: null, attributeData: { position: s }, removeDuplicateStartEnd: P.KEEP };
      r3.push(i);
    }), r3;
  }
};
var y = e();

export {
  C
};
//# sourceMappingURL=chunk-OGZ4KF5L.js.map
