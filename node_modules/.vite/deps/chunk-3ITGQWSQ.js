import {
  i
} from "./chunk-UQFAHV7T.js";
import {
  h as h2
} from "./chunk-25Y2OKSP.js";
import {
  o as o4,
  t as t4
} from "./chunk-DJFBTMGM.js";
import {
  C,
  E as E2,
  P as P2,
  d as d3,
  e as e5,
  e2 as e6,
  e3 as e7,
  e4 as e8,
  n as n7,
  r as r4,
  y as y2
} from "./chunk-PUR7HIYZ.js";
import {
  a as a10,
  i as i3
} from "./chunk-KW6WHTET.js";
import {
  c as c5,
  w as w3
} from "./chunk-HPO2NV7P.js";
import {
  j as j3
} from "./chunk-Y75V5CF3.js";
import {
  l as l3
} from "./chunk-PQM6RARY.js";
import {
  e as e4
} from "./chunk-HTS3HEEU.js";
import {
  t as t5,
  x
} from "./chunk-WQLER7IU.js";
import {
  o as o2
} from "./chunk-MDCKEJ7B.js";
import {
  M as M2,
  O as O2,
  T as T2
} from "./chunk-SOZCO2CU.js";
import {
  o as o3
} from "./chunk-NMRWU44S.js";
import {
  c as c4
} from "./chunk-V7M26XZ7.js";
import {
  L,
  Q,
  w as w2
} from "./chunk-JZY7CGEI.js";
import {
  s as s3,
  t as t3
} from "./chunk-OZT6RDST.js";
import {
  An,
  Bn,
  Pn,
  Un,
  gn,
  zn
} from "./chunk-PZWU5EHT.js";
import {
  a as a8,
  c as c3,
  u as u4
} from "./chunk-6O2ARNGD.js";
import {
  e as e3,
  i as i2
} from "./chunk-CQ47VEUP.js";
import {
  P
} from "./chunk-KUWW4YJ7.js";
import {
  d as d2,
  m as m2
} from "./chunk-EGR3VVZG.js";
import {
  a as a5
} from "./chunk-QKRZMDWG.js";
import {
  b
} from "./chunk-SIH2IMSA.js";
import {
  r as r3
} from "./chunk-WKRVG5MO.js";
import {
  u as u2
} from "./chunk-G4IZ2HTT.js";
import {
  a as a3,
  f as f2,
  j as j2,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import {
  a as a7
} from "./chunk-TVXPO7T5.js";
import {
  W
} from "./chunk-RN2KRYDN.js";
import {
  S2 as S,
  a as a6,
  b as b2,
  b2 as b3,
  b3 as b4,
  c as c2,
  f as f3,
  h as h3,
  m2 as m3
} from "./chunk-TADZYUVR.js";
import {
  B,
  G,
  O,
  a as a4,
  h,
  k,
  p
} from "./chunk-TMBOFNWA.js";
import {
  D,
  u as u3
} from "./chunk-56RHM4A6.js";
import {
  a as a9
} from "./chunk-D7DLEBS2.js";
import {
  n as n6
} from "./chunk-OIPX3EDD.js";
import {
  o,
  q,
  r as r2,
  u
} from "./chunk-PKZEO23A.js";
import {
  n as n5
} from "./chunk-AIRC226G.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  d,
  n2 as n,
  n4 as n2,
  n8 as n4,
  v,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  E,
  T,
  f,
  g
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  n as n3,
  t as t2
} from "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  F,
  a,
  a2,
  c,
  e as e2,
  l,
  m,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/symbols/support/defaults3D.js
var a11 = h3.fromSimpleMarkerSymbol(c3);
var c6 = b3.fromSimpleLineSymbol(u4);
var S2 = S.fromSimpleFillSymbol(a8);
var u5 = new a6({ symbolLayers: [new f3({ material: { color: e3 }, edges: new c2({ size: "1px", color: i2 }) })] });
function b5(r5) {
  if (t(r5))
    return null;
  switch (r5.type) {
    case "mesh":
      return u5;
    case "point":
    case "multipoint":
      return a11;
    case "polyline":
      return c6;
    case "polygon":
    case "extent":
      return S2;
  }
  return null;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFeatureStore.js
var l4 = class extends y {
  constructor(t7) {
    super(t7), this.events = new n6(), this.hasZ = null, this.hasM = null, this.objectIdField = null, this.viewSpatialReference = null, this.featureAdapter = { getAttribute: (t8, e10) => "graphic" in t8 ? t8.graphic.attributes[e10] : i.getAttribute(t8, e10), getAttributes: (t8) => "graphic" in t8 ? t8.graphic.attributes : i.getAttributes(t8), getObjectId: (t8) => "graphic" in t8 ? O2(t8.graphic, this.objectIdField) : i.getObjectId(t8), getGeometry: (t8) => "graphic" in t8 ? t8.getAsOptimizedGeometry(this.hasZ, this.hasM) : i.getGeometry(t8), getCentroid: (t8, e10) => {
      if ("graphic" in t8) {
        let r5 = null;
        r(t8.centroid) ? r5 = t8.centroid : "point" === t8.graphic.geometry.type && Pn(t8.graphic.geometry, u6, this.viewSpatialReference) && (r5 = u6);
        const i4 = new Array(2 + (e10.hasZ ? 1 : 0) + (e10.hasM ? 1 : 0));
        return t(r5) ? (i4[0] = 0, i4[1] = 0, i4[2] = 0, i4[3] = 0) : (i4[0] = r5.x, i4[1] = r5.y, e10.hasZ && (i4[2] = r5.hasZ ? r5.z : 0), e10.hasM && (i4[e10.hasZ ? 3 : 2] = r5.hasM ? r5.m : 0)), new t3([], i4);
      }
      return i.getCentroid(t8, e10);
    }, cloneWithGeometry: (t8, e10) => "graphic" in t8 ? new s3(e10, this.featureAdapter.getAttributes(t8), null, this.featureAdapter.getObjectId(t8)) : i.cloneWithGeometry(t8, e10) };
  }
  forEachInBounds(t7, e10) {
    this.getSpatialIndex().forEachInBounds(t7, e10);
  }
  forEachBounds(t7, e10, r5) {
    const s6 = this.getSpatialIndex();
    for (const i4 of t7) {
      const t8 = this.featureAdapter.getObjectId(i4);
      r(s6.getBounds(t8, r5)) && e10(r5);
    }
  }
};
e([d({ constructOnly: true })], l4.prototype, "getSpatialIndex", void 0), e([d({ constructOnly: true })], l4.prototype, "toArray", void 0), e([d({ constructOnly: true })], l4.prototype, "forEach", void 0), e([d({ constructOnly: true })], l4.prototype, "hasZ", void 0), e([d({ constructOnly: true })], l4.prototype, "hasM", void 0), e([d({ constructOnly: true })], l4.prototype, "objectIdField", void 0), e([d({ constructOnly: true })], l4.prototype, "viewSpatialReference", void 0), e([d({ constructOnly: true })], l4.prototype, "featureSpatialReference", void 0), l4 = e([n4("esri.views.3d.layers.graphics.Graphics3DFeatureStore")], l4);
var u6 = { type: "point", x: 0, y: 0, hasZ: false, hasM: false, spatialReference: null };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolCreationContext.js
var e9 = class {
  constructor(e10) {
    this.schedule = e10, this.sharedResources = null, this.streamDataRequester = null, this.elevationProvider = null, this.renderer = null, this.stage = null, this.clippingExtent = null, this.renderCoordsHelper = null, this.overlaySR = null, this.layer = null, this.drapeSourceRenderer = null, this.graphicsCoreOwner = null, this.localOriginFactory = null, this.featureExpressionInfoContext = null, this.screenSizePerspectiveEnabled = true, this.slicePlaneEnabled = false, this.physicalBasedRenderingEnabled = false, this.isAsync = false;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPointSymbol.js
var s4 = class extends d3 {
  constructor(r5, t7, a12) {
    super(r5, t7, a12), this.calloutSymbolLayer = null, this.symbol.hasVisibleCallout() && (this.calloutSymbolLayer = e7(this.symbol, t7));
  }
  async doLoad(t7) {
    var _a;
    const a12 = this.calloutSymbolLayer ? a5(this.calloutSymbolLayer.load()) : null;
    try {
      await super.doLoad(t7), f(t7);
    } catch (o5) {
      throw (_a = this.calloutSymbolLayer) == null ? void 0 : _a.abortLoad(), o5;
    }
    a12 && await a12;
  }
  destroy() {
    super.destroy(), this.calloutSymbolLayer = l(this.calloutSymbolLayer);
  }
  createGraphics3DGraphic(r5, t7) {
    const e10 = super.createGraphics3DGraphic(r5, t7);
    if (r(this.calloutSymbolLayer) && r(e10)) {
      const t8 = this._createCalloutGraphic(r5);
      r(t8) && e10.addAuxiliaryGraphic(t8);
    }
    return e10;
  }
  globalPropertyChanged(r5, t7) {
    return !!super.globalPropertyChanged(r5, t7) && (!this.calloutSymbolLayer || this.calloutSymbolLayer.globalPropertyChanged(r5, t7, (r6) => this._getCalloutGraphicLayer(r6)));
  }
  updateGeometry(r5, t7) {
    const a12 = super.updateGeometry(r5, t7);
    if (a12 && this.calloutSymbolLayer) {
      const a13 = this._getCalloutGraphicLayer(r5);
      if (a13)
        return this.calloutSymbolLayer.updateGeometry(a13, t7);
    }
    return a12;
  }
  _createCalloutGraphic(r5) {
    const t7 = r5.renderingInfo, a12 = { renderer: t7.renderer, symbol: t7.symbol, translation: [0, 0, 0], centerOffset: [0, 0, 0, 0], screenOffset: [0, 0], centerOffsetUnits: "world", elevationOffset: 0, materialCollection: null };
    return r5.renderingInfo = a12, this.calloutSymbolLayer.createGraphics3DGraphic(r5);
  }
  _getCalloutGraphicLayer(r5) {
    for (const t7 of r5._auxiliaryGraphics)
      if (t7.graphics3DSymbolLayer === this.calloutSymbolLayer)
        return t7;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolFactory.js
function t6(t7, i4, e10) {
  let p2;
  if ("point-3d" === t7.type)
    p2 = s4;
  else
    p2 = d3;
  return new p2(t7, i4, e10);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/GraphicStateTracking.js
var s5 = class {
  constructor(t7) {
    this.graphicsCore = t7, this.idToState = /* @__PURE__ */ new Map(), this.states = /* @__PURE__ */ new Set();
    const i4 = t7.owner.layer && t7.owner.layer.objectIdField;
    i4 ? (this.getGraphicId = (t8) => O2(t8, i4), this.getGraphics3DGraphicById = (t8) => this.graphicsCore.getGraphics3DGraphicByObjectId(t8)) : (this.getGraphicId = (t8) => t8.uid, this.getGraphics3DGraphicById = (t8) => this.graphicsCore.getGraphics3DGraphicById(t8));
  }
  destroy() {
    this.idToState.clear(), this.states.forEach((t7, i4) => this.remove(i4));
  }
  add(t7) {
    const e10 = { remove: () => this.remove(t7) };
    if (this.states.has(t7))
      return e10;
    const s6 = this.getGraphicId(t7.graphic), a12 = this.getGraphics3DGraphicById(s6);
    this.states.has(t7) || this.states.add(t7);
    return this._ensureStateList(s6).push(t7), t7.displaying = !!r(a12) && a12.isVisible(), t7.isDraped = !!r(a12) && a12.isDraped, t7.tracking = true, r(a12) && t7.emit("changed", {}), e10;
  }
  remove(i4) {
    if (this.states.has(i4)) {
      if (this.idToState.size) {
        const e10 = this.getGraphicId(i4.graphic), s6 = this.idToState.get(e10);
        s6 && (F(s6, i4), 0 === s6.length && this.idToState.delete(e10));
      }
      this.states.delete(i4), i4.tracking = false, i4.displaying = false;
    }
  }
  addGraphic(t7) {
    this._forEachState(t7, (i4) => {
      i4.displaying = t7.isVisible(), i4.isDraped = t7.isDraped, i4.emit("changed", {});
    });
  }
  removeGraphic(t7) {
    this._forEachState(t7, (t8) => {
      t8.displaying = false, t8.isDraped = false;
    });
  }
  updateGraphicGeometry(t7) {
    this._forEachState(t7, (t8) => {
      t8.emit("changed", {});
    });
  }
  updateGraphicVisibility(t7) {
    this._forEachState(t7, (i4) => {
      i4.displaying = t7.isVisible();
    });
  }
  allGraphicsDeleted() {
    this.states.forEach((t7) => {
      t7.displaying = false;
    });
  }
  _ensureStateList(t7) {
    const i4 = this.idToState.get(t7);
    if (i4)
      return i4;
    const e10 = new Array();
    return this.idToState.set(t7, e10), e10;
  }
  _forEachState(t7, i4) {
    if (0 === this.states.size || 0 === this.idToState.size)
      return;
    const e10 = this.getGraphicId(t7.graphic), s6 = this.idToState.get(e10);
    null != s6 && s6.forEach(i4);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/SpatialIndex2D.js
var d4 = class extends y {
  constructor(t7) {
    super(t7), this._index = new h2(9, a("esri-csp-restrictions") ? (t8) => ({ minX: t8.extent[0], minY: t8.extent[1], maxX: t8.extent[2], maxY: t8.extent[3] }) : [".extent[0]", ".extent[1]", ".extent[2]", ".extent[3]"]), this._missing = /* @__PURE__ */ new Set(), this._boundsByFeature = /* @__PURE__ */ new Map(), this.spatialReference = null, this.hasZ = null, this.hasM = null, this.objectIdField = null, this.updating = false;
  }
  setup(t7) {
    this._addMany(t7);
  }
  destroy() {
    this._missing.clear(), this._index.destroy(), this._index = null, this._boundsByFeature.clear(), this._boundsByFeature = null;
  }
  update() {
    this._missing.size > 0 && (this._addMany(Array.from(this._missing.values())), this.updating = false, this._missing.clear());
  }
  get updatingRemaining() {
    return this._missing.size;
  }
  queryGraphicUIDsInExtent(t7, e10, s6) {
    e10.equals(this.spatialReference) && (u7.minX = t7[0], u7.minY = t7[1], u7.maxX = t7[2], u7.maxY = t7[3], this.update(), this._index.search(u7, (t8) => s6(t8.graphic.uid)));
  }
  add(t7) {
    this._missing.add(t7), this.updating = true;
  }
  remove(t7) {
    if (this._missing.delete(t7))
      return void (this.updating = this._missing.size > 0);
    this._index.remove(t7);
    const e10 = O2(t7.graphic, this._get("objectIdField"));
    null != e10 && this._boundsByFeature.delete(e10);
  }
  _addMany(t7) {
    if (0 === t7.length)
      return;
    const e10 = this._get("objectIdField");
    for (const s6 of t7) {
      s6.computeExtent(this.spatialReference);
      const t8 = O2(s6.graphic, e10);
      null != t8 && this._boundsByFeature.set(t8, s6.extent);
    }
    this._index.load(t7);
  }
  clear() {
    this._index.clear(), this._missing.clear(), this._boundsByFeature.clear(), this.updating = false;
  }
  forEachInBounds(t7, e10) {
    u7.minX = t7[0], u7.minY = t7[1], u7.maxX = t7[2], u7.maxY = t7[3], this.update(), this._index.search(u7, (t8) => {
      e10(t8);
    });
  }
  getBounds(t7, e10) {
    this.update();
    const s6 = this._boundsByFeature.get(t7);
    return s6 ? O(e10, s6) : null;
  }
};
e([d({ constructOnly: true })], d4.prototype, "spatialReference", void 0), e([d({ constructOnly: true })], d4.prototype, "hasZ", void 0), e([d({ constructOnly: true })], d4.prototype, "hasM", void 0), e([d({ constructOnly: true })], d4.prototype, "objectIdField", void 0), e([d()], d4.prototype, "updating", void 0), e([d({ readOnly: true })], d4.prototype, "updatingRemaining", null), d4 = e([n4("esri.views.3d.layers.graphics.SpatialIndex2D")], d4);
var u7 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };

// node_modules/@arcgis/core/views/3d/layers/support/StageLayerElevationProvider.js
var g2 = s.getLogger("esri.views.3d.layers.support.StageLayerElevationProvider");
var j4 = 1;
var b6 = class extends n6.EventedMixin(y) {
  constructor(e10) {
    super(e10), this.elevationOffset = 0, this._layerHandes = new u2();
  }
  initialize() {
    this.renderCoordsHelper = this.view.renderCoordsHelper, this.intersectLayers = [this.stageLayer], this.intersector = x(this.view.state.viewingMode), this.intersector.options.store = t5.MIN;
    const e10 = this._computeLayerExtent(this.stageLayer);
    this.zmin = e10[2], this.zmax = e10[5];
    const t7 = this.stageLayer.events;
    this._layerHandes.add([t7.on("layerObjectAdded", (e11) => this._objectChanged(e11.object)), t7.on("layerObjectRemoved", (e11) => this._objectChanged(e11.object)), t7.on("objectGeometryAdded", (e11) => this._objectChanged(e11.object)), t7.on("objectGeometryRemoved", (e11) => this._objectChanged(e11.object)), t7.on("vertexAttrsUpdated", (e11) => this._objectChanged(e11.object)), t7.on("objectTransformation", (e11) => this._objectChanged(e11))]);
  }
  dispose() {
    this._layerHandes.destroy();
  }
  elevationInfoChanged() {
    const e10 = null != this.layer ? this.layer.elevationInfo : null;
    if (null != e10 && "on-the-ground" !== e10.mode) {
      const t7 = W(this.layer.spatialReference), o5 = r3(e10.unit);
      this.elevationOffset = c(e10.offset, 0) * o5 / t7;
    } else
      this.elevationOffset = 0;
  }
  getElevation(e10, t7, o5, r5) {
    if (_[0] = e10, _[1] = t7, _[2] = o5, !this.renderCoordsHelper.toRenderCoords(_, r5, _))
      return g2.error("could not project point for elevation alignment"), null;
    const s6 = this.elevationOffset, i4 = this.zmin + s6, n8 = this.zmax + s6;
    this.renderCoordsHelper.setAltitude(B2, n8, _), this.renderCoordsHelper.setAltitude(R, i4, _);
    const a12 = (e11) => e11.metadata && e11.metadata.isElevationSource;
    return this.intersector.reset(B2, R, null), this.intersector.intersect(this.intersectLayers, null, j4, null, a12), this.intersector.results.min.getIntersectionPoint(_) ? this.renderCoordsHelper.getAltitude(_) : null;
  }
  _objectChanged(e10) {
    var _a;
    if (!((_a = e10.metadata) == null ? void 0 : _a.isElevationSource) || !this.spatialReference)
      return;
    B(x2), e10.metadata.lastValidElevationBB.isEmpty() || this._expandExtent(e10.metadata.lastValidElevationBB.min, e10.metadata.lastValidElevationBB.max, x2);
    const t7 = e10.boundingVolumeWorldSpace.min, o5 = e10.boundingVolumeWorldSpace.max;
    this._expandExtent(t7, o5, x2), G(x2, E3), this.zmin = Math.min(this.zmin, x2[2]), this.zmax = Math.max(this.zmax, x2[5]), C2.extent = E3, C2.spatialReference = this.spatialReference, this.emit("elevation-change", C2), r2(e10.metadata.lastValidElevationBB.min, t7), r2(e10.metadata.lastValidElevationBB.max, o5);
  }
  _computeLayerExtent(e10) {
    return B(x2), e10.objects.forAll((e11) => this._expandExtent(e11.boundingVolumeWorldSpace.min, e11.boundingVolumeWorldSpace.max, x2)), x2;
  }
  _expandExtent(e10, t7, o5) {
    for (let r5 = 0; r5 < 8; ++r5)
      _[0] = 1 & r5 ? e10[0] : t7[0], _[1] = 2 & r5 ? e10[1] : t7[1], _[2] = 4 & r5 ? e10[2] : t7[2], this.renderCoordsHelper.fromRenderCoords(_, _, this.spatialReference), h(o5, _);
    return o5;
  }
};
e([d({ constructOnly: true })], b6.prototype, "layer", void 0), e([d({ constructOnly: true })], b6.prototype, "stageLayer", void 0), e([d({ constructOnly: true })], b6.prototype, "view", void 0), e([d({ readOnly: true, aliasOf: "view.spatialReference" })], b6.prototype, "spatialReference", void 0), b6 = e([n4("esri.views.3d.layers.support.StageLayerElevationProvider")], b6);
var x2 = B();
var E3 = D();
var C2 = { spatialReference: null, extent: E3, context: "scene" };
var _ = n5();
var B2 = n5();
var R = n5();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DCore.js
var Ue;
var Oe = n5();
var Ae = a4();
var Le = s.getLogger("esri.views.3d.layers.graphics.Graphics3DCore");
var je = Ue = class extends y {
  constructor(e10) {
    super(e10), this.propertiesPool = new o3({ computedExtent: M }, this), this.computedExtent = null, this.currentRenderer = null, this.rendererHasGeometryOperations = false, this.graphicStateTracking = null, this.symbolCreationContext = new e9((e11, t7) => this._frameTask.schedule(e11, t7)), this.graphics3DGraphics = /* @__PURE__ */ new Map(), this.stageLayer = null, this.stage = null, this.graphicsDrapedUids = /* @__PURE__ */ new Set(), this.graphicsBySymbol = /* @__PURE__ */ new Map(), this.symbolConversionCache = /* @__PURE__ */ new Map(), this.symbols = /* @__PURE__ */ new Map(), this.graphicsWithoutSymbol = /* @__PURE__ */ new Map(), this.graphicsWaitingForSymbol = /* @__PURE__ */ new Map(), this.graphicsUpdateId = 0, this._handles = new u2(), this._frameTask = Q, this.suspendSymbolCleanup = false, this._viewSpatialReference = null, this.arcadeOnDemand = null, this.rendererChangeAbortController = null, this.elevationInfoChangeAbortController = null, this.setupAbortController = null, this.elevationAlignment = null, this.scaleVisibility = null, this._spatialIndex = null, this.extentPadding = 0, this._updatingPendingLoadedGraphicsChange = null, this.featureStore = null, this.deconflictor = null, this.labeler = null, this.objectStates = null, this.viewElevationProvider = null, this.stageLayerElevationProvider = null, this.sharedSymbolResourcesOwnerHandle = null, this.whenGraphics3DGraphicRequests = {}, this.pendingUpdates = /* @__PURE__ */ new Map(), this.numberOfGraphics = 0, this.numberOfGraphicsProvidingElevation = 0, this.pendingAdds = 0, this.pendingRemoves = 0, this._loadingSymbols = 0, this.pendingUpdatesPool = new n2({ allocator: (e11) => e11 || new Fe(), deallocator: (e11) => (e11.clear(), e11) }), this.symbolWarningLogged = false, this.geometryWarningLogged = false, this.objectIdInvisibleSet = /* @__PURE__ */ new Set(), this._whenSymbolRemoved = new n2(), this.preferredUpdatePolicy = o2.SYNC, this.forcedUpdatePolicy = null, this.elevationFeatureExpressionEnabled = true, this.owner = null, this.layer = null, this.graphicSymbolSupported = true, this.getRenderingInfoWithoutRenderer = false, this.hasZ = null, this.hasM = null, this._usedMemory = 0, this._visible = void 0, this._startCreateGraphics = false;
  }
  get spatialIndex() {
    var _a;
    return this._spatialIndex || (this._spatialIndex = new d4({ objectIdField: (_a = this.owner.layer) == null ? void 0 : _a.objectIdField, spatialReference: this._viewSpatialReference, hasZ: this.hasZ, hasM: this.hasM }), this._spatialIndex.setup(Array.from(this.graphics3DGraphics.values()))), this._spatialIndex.update(), this._spatialIndex;
  }
  get effectiveUpdatePolicy() {
    return r(this.currentRenderer) && "dictionary" === this.currentRenderer.type ? o2.ASYNC : c(this.forcedUpdatePolicy, this.preferredUpdatePolicy);
  }
  get updating() {
    var _a;
    return !!(this.graphicsWaitingForSymbol.size > 0 || this.running || ((_a = this.elevationAlignment) == null ? void 0 : _a.updating) || r(this.scaleVisibility) && this.scaleVisibility.updating || r(this.filterVisibility) && this.filterVisibility.updating || this.rendererChangeAbortController || this.elevationInfoChangeAbortController || this._updatingPendingLoadedGraphicsChange || this._frameTask.updating || this._loadingSymbols > 0);
  }
  get running() {
    var _a;
    return this.pendingUpdates.size > 0 || !!((_a = this._spatialIndex) == null ? void 0 : _a.updating);
  }
  get suspendedOrOutsideOfView() {
    var _a;
    return this.owner.suspended || ((_a = this.owner.suspendInfo) == null ? void 0 : _a.outsideOfView);
  }
  get updatingRemaining() {
    var _a, _b;
    return this.updating ? this.pendingUpdates.size + 0.1 * (((_a = this._spatialIndex) == null ? void 0 : _a.updatingRemaining) || 0) + 0.1 * (((_b = this.elevationAlignment) == null ? void 0 : _b.updatingRemaining) || 0) : 0;
  }
  get displayFeatureLimit() {
    const e10 = this.owner && this.owner.view && this.owner.view.qualitySettings, t7 = e10 ? e10.graphics3D.minTotalNumberOfFeatures : 0, i4 = e10 ? e10.graphics3D.maxTotalNumberOfFeatures : 0, r5 = e10 ? e10.graphics3D.maxTotalNumberOfPrimitives : 0, s6 = this.averageSymbolComplexity, a12 = Math.max(1, r(s6) ? s6.primitivesPerFeature : 1), n8 = r(s6) && s6.drawCallsPerFeature > 0 ? i4 / s6.drawCallsPerFeature * 0.3 : i4, o5 = Math.ceil(r5 / a12), l5 = Math.max(t7, Math.min(i4, o5, n8)), d6 = this._get("displayFeatureLimit");
    return d6 && d6.minimumTotalNumberOfFeatures === t7 && d6.maximumTotalNumberOfFeatures === i4 && d6.maximumTotalNumberOfPrimitives === r5 && d6.averageSymbolComplexity === s6 && d6.maximumNumberOfFeatures === l5 ? d6 : { minimumTotalNumberOfFeatures: t7, maximumTotalNumberOfFeatures: i4, maximumTotalNumberOfPrimitives: r5, averageSymbolComplexity: s6, maximumNumberOfFeatures: l5 };
  }
  get averageSymbolComplexity() {
    const e10 = y2(this.symbolComplexities), t7 = this._get("averageSymbolComplexity");
    return 0 === e10.numComplexities || r(t7) && (e10.estimated && (t7.primitivesPerFeature >= e10.primitivesPerFeature || t7.primitivesPerCoordinate >= e10.primitivesPerCoordinate || t7.drawCallsPerFeature >= e10.drawCallsPerFeature) || t7.primitivesPerFeature === e10.primitivesPerFeature && t7.primitivesPerCoordinate === e10.primitivesPerCoordinate && t7.drawCallsPerFeature === e10.drawCallsPerFeature) ? t7 : e10;
  }
  get usedMemory() {
    const e10 = r(this.averageSymbolComplexity) && this.labelsEnabled ? this.averageSymbolComplexity.memory.bytesPerFeatureLabel * this.numberOfGraphics : 0;
    return this._usedMemory + e10;
  }
  get usedMemoryPerGraphic() {
    if (this._usedMemory && this.numberOfGraphics)
      return Math.abs(this.pendingAdds - this.pendingRemoves) / this.numberOfGraphics > 30 ? 0 : this._usedMemory / this.numberOfGraphics;
    if (r(this.averageSymbolComplexity)) {
      const e10 = this.labelsEnabled ? this.averageSymbolComplexity.memory.bytesPerFeatureLabel : 0;
      return this.averageSymbolComplexity.memory.bytesPerFeature + e10;
    }
    return 0;
  }
  get unprocessedMemoryEstimate() {
    return Math.max(0, (this.pendingAdds - this.pendingRemoves) * this.usedMemoryPerGraphic);
  }
  get symbolComplexities() {
    return this.currentRenderer ? this._getSymbolComplexitiesUsedOrRenderer(this.currentRenderer) : this._getSymbolComplexitiesUsed();
  }
  _getConvertedSymbol(e10) {
    if ("web-style" === e10.type)
      return e10.clone();
    const t7 = this.symbolConversionCache.get(e10.id);
    if (r(t7))
      return t7;
    const i4 = a7(e10, { retainId: true, hasLabelingContext: this._hasLabelingContext(e10) }), r5 = i4.symbol || null;
    return t(r5) && i4.error && Le.error(i4.error.message), this.symbolConversionCache.set(e10.id, r5), r5;
  }
  _getSymbolComplexitiesUsedOrRenderer(e10) {
    if (t(e10))
      return [];
    const t7 = e10.getSymbols(), i4 = "backgroundFillSymbol" in e10 && e10.backgroundFillSymbol;
    if (!(i4 || t7 && t7.length))
      return [];
    const r5 = [], s6 = this._getSymbolComplexityUsedOrRenderer(i4);
    r(s6) && r5.push(s6);
    for (const a12 of t7) {
      const e11 = this._getSymbolComplexityUsedOrRenderer(a12);
      r(e11) && r5.push(e11);
    }
    return r5;
  }
  _getSymbolComplexityUsedOrRenderer(e10) {
    if (t(e10))
      return null;
    const t7 = this.symbols.get(e10.id);
    if (r(t7))
      return t7.complexity;
    const i4 = this._getConvertedSymbol(e10);
    return r(i4) ? P2(i4) : null;
  }
  _getSymbolComplexitiesUsed() {
    const e10 = [];
    return this.symbols.forEach((t7) => {
      r(t7) && e10.push(t7.complexity);
    }), e10;
  }
  initialize() {
    this._viewSpatialReference = this.owner.view.spatialReference, this._set("featureStore", new l4({ objectIdField: this.owner.layer && this.owner.layer.objectIdField, hasZ: this.hasZ, hasM: this.hasM, viewSpatialReference: this._viewSpatialReference, featureSpatialReference: this.owner.featureSpatialReference, getSpatialIndex: () => this.spatialIndex, forEach: (e10) => this.graphics3DGraphics.forEach(e10), toArray: () => Array.from(this.graphics3DGraphics.values()) }));
  }
  async setup(e10) {
    this.setupAbortController = new AbortController();
    const t7 = this.setupAbortController.signal;
    this._set("elevationAlignment", e10.elevationAlignment), this._set("scaleVisibility", e10.scaleVisibility), this._set("filterVisibility", e10.filterVisibility), this._set("deconflictor", e10.deconflictor), this._set("labeler", e10.labeler), this._set("objectStates", e10.objectStates);
    const i4 = this.owner.view;
    this.viewElevationProvider = new n7(this._viewSpatialReference, i4), this._initializeStage(i4, this.layer.uid), this.symbolCreationContext.sharedResources = i4.sharedSymbolResources, this.sharedSymbolResourcesOwnerHandle = i4.sharedSymbolResources.addGraphicsOwner(this.owner), r(this.currentRenderer) && (this.symbolCreationContext.renderer = this.currentRenderer), this.symbolCreationContext.stage = this.stage, this.symbolCreationContext.streamDataRequester = i4.sharedSymbolResources.streamDataRequester, this.symbolCreationContext.renderCoordsHelper = i4.renderCoordsHelper, this.symbolCreationContext.layer = this.layer, this.symbolCreationContext.graphicsCoreOwner = this.owner, this.symbolCreationContext.localOriginFactory = new j3(i4.renderSpatialReference), this.symbolCreationContext.elevationProvider = i4.elevationProvider, this.symbolCreationContext.notifyGraphicGeometryChanged = (e11) => this.notifyGraphicGeometryChanged(e11), this.symbolCreationContext.notifyGraphicVisibilityChanged = (e11) => this.notifyGraphicVisibilityChanged(e11);
    const r5 = i3(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled);
    if (this.symbolCreationContext.featureExpressionInfoContext = await a10(r5, this._viewSpatialReference, Le), f(t7), this.symbolCreationContext.screenSizePerspectiveEnabled = i4.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled, this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled, this.symbolCreationContext.physicalBasedRenderingEnabled = !!this.owner.view.qualitySettings.physicallyBasedRenderingEnabled, "drapeSourceType" in this.owner) {
      const { owner: e11 } = this;
      this.symbolCreationContext.drapeSourceRenderer = i4.basemapTerrain.overlayManager.registerGeometryDrapeSource(e11), this._handles.add(n(() => i4.basemapTerrain.overlayManager.unregisterDrapeSource(e11)));
    }
    this._handles.add([l2(() => this.suspendedOrOutsideOfView, () => this._frameTask.reschedule(() => this._updateLayerVisibility())), l2(() => {
      var _a;
      return [(_a = this.layer) == null ? void 0 : _a.screenSizePerspectiveEnabled, this.owner.view.screenSizePerspectiveEnabled];
    }, () => {
      var _a;
      const e11 = i4.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled;
      e11 !== this.symbolCreationContext.screenSizePerspectiveEnabled && (this.symbolCreationContext.screenSizePerspectiveEnabled = e11, (_a = this.labeler) == null ? void 0 : _a.reset(), this.recreateAllGraphicsAndSymbols());
    }), l2(() => this.owner.slicePlaneEnabled, (e11) => this._slicePlaneEnabledChange(!!e11)), l2(() => {
      var _a;
      return (_a = this.owner.view.state) == null ? void 0 : _a.pixelRatio;
    }, () => this._pixelRatioChange()), l2(() => {
      var _a;
      return (_a = this.owner.view.qualitySettings) == null ? void 0 : _a.physicallyBasedRenderingEnabled;
    }, (e11) => this._physicalBasedRenderingChange(e11)), f2(() => {
      var _a;
      return (_a = i4.basemapTerrain) == null ? void 0 : _a.tilingScheme;
    }, (e11) => {
      if (e11.spatialReference.equals(this.symbolCreationContext.overlaySR) || (this.symbolCreationContext.overlaySR = i4.basemapTerrain.spatialReference), this._handles.has("loaded-graphics"))
        this.recreateAllGraphics();
      else {
        const e12 = () => {
          var _a;
          return (_a = this.owner) == null ? void 0 : _a.loadedGraphics;
        };
        this._handles.add([a3(e12, "change", (e13) => {
          this._graphicsCollectionChanged(e13), this._signalUpdatingDuringAsyncLoadedGraphicsChange();
        }, { onListenerAdd: () => {
          this.recreateAllGraphics(), this._signalUpdatingDuringAsyncLoadedGraphicsChange();
        } })], "loaded-graphics");
      }
    }, { initial: true }), l2(() => this.effectiveUpdatePolicy, (e11) => {
      r(this.stageLayer) && (this.stageLayer.updatePolicy = e11), this.symbolCreationContext.isAsync = this.effectiveUpdatePolicy === o2.ASYNC, e11 === o2.SYNC && this.runTask(w2);
    }, w)]), this._frameTask = i4.resourceController.scheduler.registerTask(L.GRAPHICS_CORE, this), this.layer && "featureReduction" in this.layer && this._handles.add(l2(() => this.layer.featureReduction, () => this.deconflictor.featureReductionChange())), this.notifyChange("averageSymbolComplexity");
    try {
      await this.rendererChange(this.layer.renderer);
    } catch {
    }
    f(t7), this.setupAbortController = null;
  }
  _abortSetup() {
    this.setupAbortController && (this.setupAbortController.abort(), this.setupAbortController = null);
  }
  destroy() {
    this._abortSetup(), this._abortRendererChange(), this._abortElevationInfoChange(), this.owner.view.deconflictor.removeGraphicsOwner(this), this.owner.view.labeler.removeGraphicsOwner(this), this._updatingPendingLoadedGraphicsChange = a2(this._updatingPendingLoadedGraphicsChange), this.clear(), this.graphicStateTracking = l(this.graphicStateTracking), this.stage && (this.stage.remove(this.stageLayer), this.stageLayer = null, this.stage = null), this._handles = l(this._handles), this._frameTask.remove(), this._frameTask = Q, this._viewSpatialReference = null, this._set("owner", null);
    for (const e10 in this.whenGraphics3DGraphicRequests)
      this.whenGraphics3DGraphicRequests[e10].reject(new s2("graphic:layer-destroyed", "Layer has been destroyed"));
    this.whenGraphics3DGraphicRequests = null, this.sharedSymbolResourcesOwnerHandle = a2(this.sharedSymbolResourcesOwnerHandle), this.propertiesPool = l(this.propertiesPool), this.pendingUpdatesPool = null, this.symbolConversionCache.clear(), this.objectIdInvisibleSet.clear(), this._spatialIndex = l(this._spatialIndex), this._set("featureStore", l(this.featureStore));
  }
  clear() {
    var _a, _b;
    (_a = this.objectStates) == null ? void 0 : _a.allGraphicsDeleted(), r(this.graphicStateTracking) && this.graphicStateTracking.allGraphicsDeleted(), this.graphics3DGraphics.forEach((e10) => e10.destroy()), (_b = this._spatialIndex) == null ? void 0 : _b.clear(), this.graphics3DGraphics.clear(), this.numberOfGraphics = 0, this._usedMemory = 0, this._updateLayerVisibility(), this.symbols.forEach(l), this.symbols.clear(), this.graphicsBySymbol.clear(), this.graphicsWithoutSymbol.clear(), this.graphicsWaitingForSymbol.clear(), this.pendingUpdates.clear(), this.pendingUpdatesPool.clear(), this.pendingAdds = 0, this.pendingRemoves = 0, this.notifyChange("updating"), this.notifyChange("running"), this.notifyChange("updatingRemaining"), this.featureStore.events.emit("changed");
  }
  _initializeStage(e10, t7) {
    this.stage = e10._stage, this.stageLayer = new l3({ isPickable: !this.suspendedOrOutsideOfView, updatePolicy: this.effectiveUpdatePolicy }, t7), this.stage.add(this.stageLayer);
    const i4 = this.stageLayer.events;
    i4.on("objectTransformation", (e11) => this.notifyGraphicGeometryChanged(e11.metadata.graphicUid)), i4.on("visibilityChanged", (e11) => this.notifyGraphicVisibilityChanged(e11.metadata.graphicUid)), i4.on("objectGeometryAdded", (e11) => this.notifyGraphicGeometryChanged(e11.object.metadata.graphicUid)), i4.on("objectGeometryRemoved", (e11) => this.notifyGraphicGeometryChanged(e11.object.metadata.graphicUid)), i4.on("vertexAttrsUpdated", (e11) => this.notifyGraphicGeometryChanged(e11.object.metadata.graphicUid));
  }
  notifyGraphicGeometryChanged(e10) {
    if (t(this.graphicStateTracking) || t(e10))
      return;
    const t7 = this.graphics3DGraphics.get(e10);
    t7 && this.graphicStateTracking.updateGraphicGeometry(t7);
  }
  notifyGraphicVisibilityChanged(e10) {
    if (t(this.graphicStateTracking) || t(e10))
      return;
    const t7 = this.graphics3DGraphics.get(e10);
    t7 && this.graphicStateTracking.updateGraphicVisibility(t7);
  }
  _updateLayerVisibility() {
    const e10 = this.displayFeatureLimit.maximumNumberOfFeatures, t7 = this.numberOfGraphics > e10 * Te, i4 = !this.suspendedOrOutsideOfView && !t7;
    i4 !== this._visible && (this._visible = i4, i4 ? (this.stageLayer.isPickable = true, this.updateAllGraphicsVisibility()) : (this.stageLayer.isPickable = false, this._hideAllGraphics()), this._updateStageLayerVisibility());
  }
  _updateStageLayerVisibility() {
    this.stageLayer.isVisible = this._visible && (null == this.layer.opacity || this.layer.opacity > 0);
  }
  getGraphics3DGraphicById(e10) {
    return this.graphics3DGraphics.get(e10);
  }
  getGraphics3DGraphicByObjectId(e10) {
    var _a;
    return ((_a = this.owner.layer) == null ? void 0 : _a.objectIdField) ? this._findGraphics3DGraphicByObjectId(e10) : null;
  }
  _getGraphicObjectID(e10, t7 = this.owner.layer && this.owner.layer.objectIdField) {
    return O2(e10, t7);
  }
  get graphics3DGraphicsByObjectID() {
    const e10 = this.owner.layer && this.owner.layer.objectIdField;
    if (!e10)
      return null;
    const t7 = /* @__PURE__ */ new Map();
    return this.graphics3DGraphics.forEach((i4) => {
      if (!i4)
        return;
      const r5 = i4.graphic, s6 = this._getGraphicObjectID(r5, e10);
      r(s6) && t7.set(s6, i4);
    }), t7;
  }
  get labelsEnabled() {
    return !(!this.labeler || !this.labeler.layerLabelsEnabled());
  }
  async updateLabelingInfo(e10) {
    const t7 = this.deconflictor && this.deconflictor.labelingInfoChange(e10), i4 = this.labeler && this.labeler.labelingInfoChange(e10);
    await E([t7, i4]);
  }
  updateVisibilityInfo() {
    this.deconflictor && this.deconflictor.labelingInfoChange(), this.labeler && this.labeler.visibilityInfoChange();
  }
  get symbolUpdateType() {
    if (this.pendingUpdates.size > 0)
      return "unknown";
    let e10 = 0, t7 = 0;
    return n3(this.symbols, (i4, r5) => {
      if (r(i4)) {
        const s6 = i4.getFastUpdateStatus();
        if (s6.loading > 0)
          return true;
        this.graphicsBySymbol.has(r5) && (t7 += s6.fast, e10 += s6.slow);
      }
      return false;
    }) ? "unknown" : t7 >= 0 && 0 === e10 ? "fast" : e10 >= 0 && 0 === t7 ? "slow" : "mixed";
  }
  runTask(e10) {
    this._frameTask.processQueue(e10), this._applyPendingUpdates(e10), this.notifyChange("running"), this.running || this.notifyChange("updating"), this.notifyChange("updatingRemaining");
  }
  setObjectIdVisibility(e10, t7) {
    t7 ? this.objectIdInvisibleSet.delete(e10) : this.objectIdInvisibleSet.add(e10);
    const i4 = this._findGraphics3DGraphicByObjectId(e10);
    r(i4) && this._updateUserVisibility(i4);
  }
  _findGraphics3DGraphicByObjectId(e10) {
    return t2(this.graphics3DGraphics, (t7) => this._getGraphicObjectID(t7.graphic) === e10);
  }
  _updateUserVisibility(e10) {
    if (t(e10))
      return false;
    const t7 = e10.graphic, i4 = this._getGraphicObjectID(t7), r5 = t7.visible && !this.owner.suspended && (t(i4) || !this.objectIdInvisibleSet.has(i4));
    return e10.setVisibilityFlag(C.USER_SETTING, r5, E2.GRAPHIC);
  }
  _whenGraphics3DGraphic(e10) {
    const t7 = this.graphics3DGraphics.get(e10.uid);
    if (t7)
      return Promise.resolve(t7);
    const i4 = this.whenGraphics3DGraphicRequests[e10.uid];
    if (i4)
      return i4.promise;
    const r5 = T();
    return this.whenGraphics3DGraphicRequests[e10.uid] = r5, r5.promise;
  }
  async _boundsForGraphics3DGraphic(e10, t7) {
    const i4 = this._viewSpatialReference, r5 = this.owner.view.renderSpatialReference, s6 = this.owner.view.basemapTerrain.spatialReference, a12 = (e11, t8, s7) => Un(e11, r5, t8, e11, i4, t8, s7), n8 = (e11, t8, r6) => Un(e11, s6, t8, e11, i4, t8, r6), o5 = this.viewElevationProvider ? { service: this.viewElevationProvider, useViewElevation: r(t7) && t7.useViewElevation, minDemResolution: r(t7) && t7.minDemResolution, minDemResolutionForPoints: this.owner.view.resolution } : null, l5 = await e10.getProjectedBoundingBox(a12, n8, o5, m(t7, "signal"));
    if (!l5)
      return null;
    const p2 = l5.boundingBox;
    if (l5.requiresDrapedElevation) {
      const e11 = this.symbolCreationContext.elevationProvider;
      if (e11) {
        p(p2, Oe);
        const t8 = c(e11.getElevation(Oe[0], Oe[1], 0, i4, "ground"), 0);
        p2[2] = Math.min(p2[2], t8), p2[5] = Math.max(p2[5], t8);
      }
    }
    return { boundingBox: p2, screenSpaceObjects: l5.screenSpaceObjects };
  }
  async whenGraphicBounds(e10, t7) {
    await j2(() => {
      var _a;
      return (_a = this.owner) == null ? void 0 : _a.loadedGraphics;
    });
    const i4 = this.owner.layer && this.owner.layer.objectIdField, s6 = this.owner.loadedGraphics.find((t8) => t8 === e10 || i4 && t8.attributes && e10.attributes && t8.attributes[i4] === e10.attributes[i4]);
    if (!s6)
      throw new s2("internal:graphic-not-part-of-view", "Graphic is not part of this view");
    const a12 = await this._whenGraphics3DGraphic(s6);
    return this._boundsForGraphics3DGraphic(a12, t7);
  }
  computeAttachmentOrigin(e10, t7) {
    const i4 = this.graphics3DGraphics.get(e10.uid);
    if (!i4)
      return null;
    const r5 = i4.computeAttachmentOrigin();
    if (0 === r5.render.num && 0 === r5.draped.num)
      return null;
    o(ke, 0, 0, 0);
    let s6 = 0;
    if (r5.render.num > 0) {
      if (!Bn(r5.render.origin, this.symbolCreationContext.renderCoordsHelper.spatialReference, Me, t7))
        return null;
      u(ke, ke, Me), s6++;
    }
    if (r5.draped.num > 0) {
      const [e11, i5] = r5.draped.origin, a12 = c(this.viewElevationProvider.getElevation(e11, i5, "ground"), 0);
      if (o(Me, e11, i5, a12), !Bn(Me, this.viewElevationProvider.spatialReference, Me, t7))
        return null;
      u(ke, ke, Me), s6++;
    }
    return s6 > 1 && q(ke, ke, 1 / s6), new j({ x: ke[0], y: ke[1], z: ke[2], spatialReference: t7 });
  }
  getSymbolLayerSize(e10, t7) {
    const i4 = this.symbols.get(e10.id);
    if (t(i4))
      throw new s2("internal:symbol-not-part-of-view", "Symbol is not part of this view");
    const s6 = e10.symbolLayers.indexOf(t7);
    if (-1 === s6)
      throw new s2("internal:missing-symbol-layer", "Symbol layer is not in symbol");
    const a12 = i4.getSymbolLayerSize(s6);
    if (null == a12)
      throw new s2("internal:missing-size", "Symbol layer has no valid size");
    return a12;
  }
  _graphicsCollectionChanged(e10) {
    this._startCreateGraphics && (this.add(e10.added), this.remove(e10.removed));
  }
  graphicUpdateHandler(e10) {
    const t7 = e10.graphic.uid, i4 = this.graphics3DGraphics.get(t7);
    if (!t(i4) || !t(this.graphicsWithoutSymbol.get(t7)))
      switch (e10.property) {
        case "visible":
          this._graphicUpdateVisibleHandler(i4);
          break;
        case "geometry":
          this._graphicUpdateGeometryHandler(i4, e10);
          break;
        case "symbol":
          this._graphicUpdateSymbolHandler(i4, e10);
          break;
        case "attributes":
          break;
        case "transform":
          this._graphicUpdateTransformHandler(i4, e10);
      }
  }
  _graphicUpdateGeometryHandler(e10, t7) {
    const i4 = t7.graphic.geometry;
    if (t(i4))
      return void this._recreateGraphic(t7.graphic);
    if (t(e10)) {
      const e11 = t7.graphic.symbol && t7.graphic.symbol.id;
      if (e11) {
        const t8 = this.symbols.get(e11);
        if (r(t8) && t8.loadStatus === e6.LOADING)
          return;
      }
      return void this._recreateGraphic(t7.graphic);
    }
    const r5 = e10.graphics3DSymbol;
    !t(t7.newValue) && r5.updateGeometry(e10, t7.newValue) || this._recreateGraphic(e10.graphic), this._expandComputedExtent(i4);
  }
  _graphicUpdateSymbolHandler(e10, t7) {
    const i4 = t7.graphic, r5 = r(e10) ? e10.graphics3DSymbol : r(t7.oldValue) ? this.symbols.get(t7.oldValue.id) : null;
    if (t(r5) || t(t7.newValue))
      return void this._recreateGraphic(i4);
    const s6 = r5.symbol, a12 = this._getConvertedSymbol(t7.newValue);
    if (r(a12) && (a12.type !== s6.type || "web-style" === a12.type) || "web-style" === s6.type)
      return void this._recreateGraphic(i4);
    const n8 = this.graphicsBySymbol.get(s6.id);
    if (n8 && 1 !== n8.size)
      return void this._recreateGraphic(i4);
    const o5 = m2(s6, a12);
    if (t(o5))
      return void this._updateSymbolMapping(s6.id, a12);
    const l5 = { diff: o5, graphics3DGraphicPatches: [], symbolStatePatches: [] };
    if (r5.prepareSymbolPatch(l5), !d2(l5.diff))
      return void this._recreateGraphic(i4);
    const d6 = this._getRenderingInfo(i4);
    if (t(d6))
      return void this._recreateGraphic(i4);
    const c7 = r5.extentPadding;
    for (const h4 of l5.symbolStatePatches)
      h4();
    if (c7 !== r5.extentPadding && this._recomputeExtentPadding(), r(e10))
      for (const h4 of l5.graphics3DGraphicPatches)
        h4(e10, d6);
    this._updateSymbolMapping(s6.id, a12);
  }
  _graphicUpdateVisibleHandler(e10) {
    this._updateUserVisibility(e10) && (this.labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty());
  }
  _graphicUpdateTransformHandler(e10, t7) {
  }
  recreateGraphics(e10) {
    this.suspendSymbolCleanup = true, this.remove(e10), this.add(e10), this.suspendSymbolCleanup = false, this.effectiveUpdatePolicy === o2.SYNC && this._cleanupSymbols();
  }
  _recreateGraphic(e10) {
    this.recreateGraphics([e10]);
  }
  _beginGraphicUpdate(e10) {
    const t7 = this.graphicsUpdateId;
    return this.graphicsUpdateId++, this.graphicsWaitingForSymbol.set(e10.uid, t7), 1 === this.graphicsWaitingForSymbol.size && this.notifyChange("updating"), t7;
  }
  _endGraphicUpdate(e10) {
    e10 && (this.graphicsWaitingForSymbol.delete(e10.uid), 0 === this.graphicsWaitingForSymbol.size && (this._cleanupSymbols(), this.notifyChange("updating")));
  }
  _recomputeExtentPadding() {
    let e10 = 0;
    this.symbols.forEach((t7) => {
      r(t7) && (e10 = Math.max(e10, t7.extentPadding));
    }), this._set("extentPadding", e10);
  }
  _expandComputedExtent(e10) {
    const t7 = Ae, i4 = e10.spatialReference;
    T2(e10, t7);
    const r5 = this._viewSpatialReference, s6 = Ue.tmpVec;
    if (i4.equals(r5) || gn(t7[0], t7[1], 0, i4, s6, r5) && (t7[0] = s6[0], t7[1] = s6[1], gn(t7[3], t7[4], 0, i4, s6, r5), t7[3] = s6[0], t7[4] = s6[1]), !(isFinite(t7[0]) && isFinite(t7[3]) && isFinite(t7[1]) && isFinite(t7[4])))
      return;
    const a12 = this.computedExtent;
    let n8 = null;
    const o5 = isFinite(t7[2]) && isFinite(t7[5]), l5 = o5 && (!a12 || null == a12.zmin || t7[2] < a12.zmin), h4 = o5 && (!a12 || null == a12.zmax || t7[5] > a12.zmax);
    if (a12) {
      (t7[0] < a12.xmin || t7[1] < a12.ymin || t7[3] > a12.xmax || t7[4] > a12.ymax || l5 || h4) && (n8 = this.propertiesPool.get("computedExtent"), n8.xmin = Math.min(t7[0], a12.xmin), n8.ymin = Math.min(t7[1], a12.ymin), n8.xmax = Math.max(t7[3], a12.xmax), n8.ymax = Math.max(t7[4], a12.ymax), n8.spatialReference = r5);
    } else
      n8 = this.propertiesPool.get("computedExtent"), n8.xmin = t7[0], n8.ymin = t7[1], n8.xmax = t7[3], n8.ymax = t7[4], n8.spatialReference = r5;
    n8 && (l5 && (n8.zmin = t7[2]), h4 && (n8.zmax = t7[5]), this._set("computedExtent", n8));
  }
  _abortElevationInfoChange() {
    this.elevationInfoChangeAbortController && (this.elevationInfoChangeAbortController.abort(), this.elevationInfoChangeAbortController = null);
  }
  async elevationInfoChange() {
    var _a, _b;
    this._abortElevationInfoChange();
    const e10 = new AbortController();
    this.elevationInfoChangeAbortController = e10;
    const t7 = i3(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled);
    this.symbolCreationContext.featureExpressionInfoContext = await a10(t7, this._viewSpatialReference, Le), f(e10), this.elevationInfoChangeAbortController = null, (_a = this.labeler) == null ? void 0 : _a.elevationInfoChange(), this.forEachGraphics3DSymbol((e11, t8, i4) => {
      e11.globalPropertyChanged("elevationInfo", t8) ? t8.forEach((e12) => {
        const t9 = e12.graphic, i5 = e12.labelGraphics;
        for (const r5 of i5) {
          r5.graphics3DSymbolLayer.updateGraphicElevationContext(t9, r5);
        }
      }) : this._recreateSymbol(i4);
    }), this.updateStageLayerElevationProvider(), (_b = this.elevationAlignment) == null ? void 0 : _b.elevationInfoChange();
  }
  updateStageLayerElevationProvider() {
    this.stageLayerElevationProvider ? (this.layer.elevationInfo && "relative-to-scene" === this.layer.elevationInfo.mode || 0 === this.numberOfGraphicsProvidingElevation) && (this.owner.view.elevationProvider.unregister(this.stageLayerElevationProvider), this.stageLayerElevationProvider.dispose(), this.stageLayerElevationProvider = null) : (!this.layer.elevationInfo || this.layer.elevationInfo && "relative-to-scene" !== this.layer.elevationInfo.mode) && this.numberOfGraphicsProvidingElevation > 0 && (this.stageLayerElevationProvider = new b6({ layer: this.layer, stageLayer: this.stageLayer, view: this.owner.view }), this.owner.view.elevationProvider.register("scene", this.stageLayerElevationProvider));
  }
  _clearSymbolsAndGraphics() {
    var _a, _b, _c, _d;
    this.clear(), r(this.filterVisibility) && this.filterVisibility.clear(), (_a = this.labeler) == null ? void 0 : _a.reset(), (_b = this.deconflictor) == null ? void 0 : _b.clear(), (_c = this.elevationAlignment) == null ? void 0 : _c.clear(), (_d = this.stageLayer) == null ? void 0 : _d.invalidateSpatialQueryAccelerator(), this.stageLayerElevationProvider && (this.owner.view.elevationProvider.unregister(this.stageLayerElevationProvider), this.stageLayerElevationProvider.dispose(), this.stageLayerElevationProvider = null);
  }
  startCreateGraphics() {
    this._startCreateGraphics = true, this.recreateAllGraphics();
  }
  recreateAllGraphics() {
    this._recreateAllGraphics(false);
  }
  recreateAllGraphicsAndSymbols() {
    this._recreateAllGraphics(true);
  }
  _recreateAllGraphics(e10 = false) {
    if (!this._startCreateGraphics)
      return;
    const { loadedGraphics: t7, view: i4 } = this.owner, r5 = i4.basemapTerrain.tilingScheme && t7 && t7.length ? t7.toArray() : null;
    !e10 && r5 || this._clearSymbolsAndGraphics(), this.symbolCreationContext.screenSizePerspectiveEnabled = this.owner.view.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled, this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled, this._set("computedExtent", null), r5 && (e10 ? this.add(r5) : this.recreateGraphics(r5));
  }
  _recreateSymbol(e10) {
    const t7 = this.graphicsBySymbol.get(e10), i4 = [];
    t7 && (t7.forEach((e11, t8) => {
      var _a;
      const r6 = e11.usedMemory;
      this._conditionalRemove(e11, t8), (_a = this._spatialIndex) == null ? void 0 : _a.remove(e11), i4.push(e11.graphic), e11.destroy(), this._removeGraphics3DGraphic(t8, r6), this._updateLayerVisibility(), this.featureStore.events.emit("changed");
    }), this.graphicsBySymbol.set(e10, /* @__PURE__ */ new Map()));
    const r5 = this.symbols.get(e10);
    l(r5), this.symbols.delete(e10), this.add(i4);
  }
  _recreateGraphicsForSymbol(e10) {
    const t7 = this.graphicsBySymbol.get(e10);
    if (t7) {
      const e11 = [];
      t7.forEach((t8) => e11.push(t8.graphic)), this.recreateGraphics(e11);
    }
  }
  _conditionalRemove(e10, t7) {
    var _a, _b, _c;
    this.graphicsDrapedUids.delete(t7), (_a = this.objectStates) == null ? void 0 : _a.removeGraphic(e10), (_b = this.labeler) == null ? void 0 : _b.removeGraphic(e10), (_c = this.deconflictor) == null ? void 0 : _c.removeGraphic(e10), r(this.graphicStateTracking) && this.graphicStateTracking.removeGraphic(e10);
  }
  add(e10) {
    e10 && 0 !== e10.length && (this.owner.view.basemapTerrain && this.owner.view.basemapTerrain.tilingScheme ? (this._updatePolicyForGraphics(e10) === o2.ASYNC ? this._addDelayed(e10) : this._addImmediate(e10), this.notifyChange("updating")) : Le.error("#add()", "Cannot add graphics before terrain surface has been initialized"));
  }
  _updatePolicyForGraphics(e10) {
    if (this.effectiveUpdatePolicy === o2.SYNC && ("mesh" === this.layer.geometryType || null == this.layer.geometryType)) {
      for (const t7 of e10)
        if (r(t7.geometry) && "mesh" === t7.geometry.type && !t7.geometry.loaded)
          return o2.ASYNC;
    }
    return this.effectiveUpdatePolicy;
  }
  _addImmediate(e10) {
    this.geometryWarningLogged = false, this.symbolWarningLogged = false;
    for (const t7 of e10)
      this._addGraphic(t7, this._getRenderingInfo(t7, Le), o2.SYNC);
    this._cleanupSymbols(), this.labeler && (this.owner.view.labeler.setDirty(), this._cleanupSymbols()), this.owner.view.deconflictor.setDirty();
  }
  _addDelayed(e10) {
    for (const t7 of e10) {
      const e11 = t7.uid;
      let i4 = this.pendingUpdates.get(e11);
      i4 ? i4.add ? i4.state !== Ve.NEW && i4.abortController.abort() : this.pendingAdds++ : (i4 = this.pendingUpdatesPool.pushNew(), this.pendingAdds++, this.pendingUpdates.set(e11, i4)), i4.add = t7;
    }
    this.notifyChange("running"), this.notifyChange("updatingRemaining");
  }
  remove(e10) {
    this.effectiveUpdatePolicy === o2.ASYNC ? this._removeDelayed(e10) : this._removeImmediate(e10), this.notifyChange("updating");
  }
  _removeImmediate(e10) {
    for (const t7 of e10)
      this._removeGraphic(t7);
    this._cleanupSymbols(), this.labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty();
  }
  _removeDelayed(e10) {
    for (const t7 of e10) {
      const e11 = t7.uid, i4 = this.pendingUpdates.get(e11);
      if (i4)
        i4.add && (i4.remove ? i4.add = null : this.pendingUpdates.delete(e11), i4.state === Ve.LOADING && i4.abortController.abort(), this.pendingAdds--);
      else {
        const i5 = this.pendingUpdatesPool.pushNew();
        i5.remove = t7, this.pendingUpdates.set(e11, i5), this.pendingRemoves++;
      }
    }
    0 === this.pendingUpdates.size && this._finishPendingUpdates(), this.notifyChange("running"), this.notifyChange("updatingRemaining");
  }
  _finishPendingUpdates() {
    this.pendingUpdatesPool.clear(), this._cleanupSymbols(), (this.pendingAdds || this.pendingRemoves) && Le.warn("pendingAdds/Removes in inconsistent state!"), this.pendingAdds = 0, this.pendingRemoves = 0;
  }
  _applyPendingUpdates(e10) {
    var _a;
    if (this.geometryWarningLogged = false, this.symbolWarningLogged = false, 0 === this.pendingUpdates.size && ((_a = this._spatialIndex) == null ? void 0 : _a.updating))
      this._spatialIndex.update();
    else {
      for (const [t7, i4] of this.pendingUpdates) {
        if (e10.done)
          break;
        i4.add && i4.state === Ve.NEW && this._processPendingUpdateNew(i4);
        let r5 = this.effectiveUpdatePolicy;
        if (!i4.remove || i4.add && i4.state !== Ve.READY || (this.pendingRemoves--, e10.madeProgress(), this._removeGraphic(i4.remove), i4.remove = null, r5 = o2.SYNC), i4.add)
          switch (i4.state) {
            case Ve.READY:
              this._addGraphic(i4.add, i4.renderingInfo, r5), i4.add = null, this.pendingAdds--, e10.madeProgress();
              break;
            case Ve.REJECTED:
              i4.add = null, this.pendingAdds--;
            case Ve.LOADING:
          }
        null == i4.remove && null == i4.add && this.pendingUpdates.delete(t7);
      }
      0 === this.pendingUpdates.size && (this._finishPendingUpdates(), this.notifyChange("running"));
    }
  }
  _processPendingUpdateNew(e10) {
    if (!e10.add)
      return void (e10.state = Ve.READY);
    const t7 = e10.add.geometry;
    r(t7) && "mesh" === t7.type && !t7.loaded ? this._processPendingUpdateNewMesh(e10, t7) : this._processPendingUpdateNewRenderingInfo(e10);
  }
  async _processPendingUpdateNewMesh(e10, t7) {
    e10.state = Ve.LOADING, e10.abortController = new AbortController();
    const i4 = e10.abortController.signal;
    try {
      await t7.load({ signal: i4 });
    } catch (r5) {
      return this._processPendingUpdateNewError(e10, r5);
    }
    e10.abortController = null, this._processPendingUpdateNewRenderingInfo(e10);
  }
  _processPendingUpdateNewError(e10, t7) {
    e10.abortController = null, g(t7) ? e10.state = Ve.NEW : e10.state = Ve.REJECTED;
  }
  async _processPendingUpdateNewRenderingInfo(e10) {
    if (t(this.layer.renderer) || "dictionary" !== this.layer.renderer.type)
      return e10.renderingInfo = this._getRenderingInfo(e10.add, Le), void (e10.state = Ve.READY);
    e10.state = Ve.LOADING, e10.abortController = new AbortController();
    let t7 = null;
    try {
      t7 = await this._getRenderingInfoAsync(e10.add, { signal: e10.abortController.signal });
    } catch (i4) {
      return e10.abortController = null, void (g(i4) ? e10.state = Ve.NEW : e10.state = Ve.REJECTED);
    }
    t(t7) || t(t7.symbol) ? (Le && !this.symbolWarningLogged && (this.symbolWarningLogged = true, Le.warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), e10.renderingInfo = null) : e10.renderingInfo = t7, e10.state = Ve.READY;
  }
  _addGraphic(e10, t7, i4) {
    if (this.graphicsWithoutSymbol.set(e10.uid, e10), t(t7) || t(t7.symbol) || !M2(e10))
      return;
    const r5 = t7.symbol, s6 = this.getOrCreateGraphics3DSymbol(r5, t7.renderer);
    if (t(s6))
      return;
    this._expandComputedExtent(e10.geometry);
    const a12 = this._beginGraphicUpdate(e10), n8 = new r4(e10, t7, this.layer);
    let o5 = false;
    const l5 = (e11) => {
      e11 === s6.symbol.id && (o5 = true);
    };
    this._whenSymbolRemoved.push(l5);
    const d6 = () => {
      if (--this._loadingSymbols, this.destroyed)
        return;
      this._whenSymbolRemoved.removeUnordered(l5);
      if (this.graphicsWaitingForSymbol.get(e10.uid) !== a12 || o5 || s6.destroyed || this.graphicSymbolSupported && e10.symbol && e10.symbol.id !== s6.symbol.id)
        --s6.referenced, this._cleanupSymbols();
      else {
        const t8 = this._createGraphics3DGraphic(s6, n8);
        this._spatialIndex && r(t8) && this._spatialIndex.add(t8), --s6.referenced, this._endGraphicUpdate(e10);
      }
      this.featureStore.events.emit("changed"), this.labeler && this.owner.view.labeler.setDirty();
    }, c7 = (t8) => {
      --this._loadingSymbols, this.destroyed || (this._whenSymbolRemoved.removeUnordered(l5), o5 || (g(t8) ? this.add([e10]) : s6.destroyed || this._endGraphicUpdate(e10)));
    };
    ++this._loadingSymbols, i4 === o2.ASYNC ? s6.load(() => this._frameTask.schedule(d6), (e11) => this._frameTask.schedule(() => c7(e11))) : s6.load(d6, c7);
  }
  _removeGraphic(e10) {
    var _a;
    const t7 = e10.uid, i4 = this.graphics3DGraphics.get(t7);
    if (i4) {
      i4.graphics3DSymbol.onRemoveGraphic(i4);
      const e11 = i4.usedMemory, r5 = i4.isElevationSource;
      this._conditionalRemove(i4, t7), (_a = this._spatialIndex) == null ? void 0 : _a.remove(i4);
      const s6 = i4.graphics3DSymbol.symbol.id;
      this.graphicsBySymbol.get(s6).delete(t7), this.graphicsWithoutSymbol.delete(t7), this._removeGraphics3DGraphic(t7, e11, r5), i4.destroy(), this.featureStore.events.emit("changed");
    } else
      this.graphicsWithoutSymbol.delete(t7), this.graphicsWaitingForSymbol.delete(t7), 0 === this.graphicsWaitingForSymbol.size && (this._cleanupSymbols(), this.notifyChange("updating"));
  }
  _hasLabelingContext(e10) {
    if (e10 instanceof b2 || e10 instanceof m3) {
      const t7 = this.symbolCreationContext.layer;
      return !!t7.labelingInfo && t7.labelingInfo.some((t8) => t8.symbol === e10);
    }
    return false;
  }
  _hasValidSymbolCreationContext(e10) {
    return !(e10 instanceof b2 && !this._hasLabelingContext(e10)) || (Le.error("LabelSymbol3D is only valid as part of a LabelClass. Using LabelSymbol3D as a renderer symbol is not supported."), false);
  }
  _getRenderingInfo(e10, t7) {
    const i4 = e10.geometry;
    if (t(i4))
      return t7 && !this.geometryWarningLogged && (this.geometryWarningLogged = true, t7.warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)), null;
    if (!An(i4.spatialReference, this._viewSpatialReference))
      return t7 && !this.geometryWarningLogged && (this.geometryWarningLogged = true, t7.warn(`Graphic in layer ${this.layer.id} has incompatible spatial reference and will not render`)), null;
    if (!this.graphicSymbolSupported && r(e10.symbol))
      return t7 && !this.symbolWarningLogged && (this.symbolWarningLogged = true, t7.warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null;
    const r5 = this.rendererHasGeometryOperations ? c5(e10, this.layer) : e10;
    let s6;
    if (this.owner.getRenderingInfo && (this.getRenderingInfoWithoutRenderer || r(this.currentRenderer)))
      s6 = this.owner.getRenderingInfo(r5, this.currentRenderer, e2(this.arcadeOnDemand));
    else {
      s6 = { symbol: r5.symbol || b5(r5.geometry) };
    }
    return t(s6) || t(s6.symbol) ? (t7 && !this.symbolWarningLogged && (this.symbolWarningLogged = true, t7.warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), null) : s6;
  }
  _getRenderingInfoAsync(e10, t7) {
    const i4 = e10.geometry;
    if (t(i4))
      return Le && !this.geometryWarningLogged && (this.geometryWarningLogged = true, Le.warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)), null;
    if (!this.graphicSymbolSupported && r(e10.symbol))
      return Le && !this.symbolWarningLogged && (this.symbolWarningLogged = true, Le.warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null;
    const r5 = this.rendererHasGeometryOperations ? c5(e10, this.layer) : e10;
    return this.owner.getRenderingInfoAsync(r5, e2(this.currentRenderer), e2(this.arcadeOnDemand), t7);
  }
  _createGraphics3DSymbol(e10, t7) {
    if (!this._hasValidSymbolCreationContext(e10))
      return null;
    const i4 = this._getConvertedSymbol(e10);
    if (!i4)
      return null;
    let r5;
    if (r(t7) && "backgroundFillSymbol" in t7 && t7.backgroundFillSymbol) {
      const e11 = a7(t7.backgroundFillSymbol, { ignoreDrivers: true });
      r(e11.symbol) && "web-style" !== e11.symbol.type && "cim" !== e11.symbol.type && (r5 = e11.symbol.symbolLayers);
    }
    const s6 = t6(i4, this.symbolCreationContext, r5);
    return s6.load(() => {
      const e11 = s6.extentPadding;
      e11 > this.extentPadding && this._set("extentPadding", e11), this.notifyChange("averageSymbolComplexity");
    }, () => {
    }), s6;
  }
  getOrCreateGraphics3DSymbol(e10, t7) {
    let i4 = this.symbols.get(e10.id);
    return void 0 === i4 && (i4 = e10 instanceof b4 ? new e8(e10, (e11) => this._frameTask.schedule(e11), (e11) => this._createGraphics3DSymbol(e11, t7)) : this._createGraphics3DSymbol(e10, t7), this.symbols.set(e10.id, i4)), r(i4) && ++i4.referenced, i4;
  }
  trackGraphicState(e10) {
    return t(this.graphicStateTracking) && (this.graphicStateTracking = new s5(this)), this.graphicStateTracking.add(e10);
  }
  _addGraphics3DGraphic(e10) {
    this._usedMemory += e10.usedMemory, this.graphics3DGraphics.set(e10.graphic.uid, e10), this.numberOfGraphics++, e10.isElevationSource && (this.numberOfGraphicsProvidingElevation++, this.updateStageLayerElevationProvider()), this._updateLayerVisibility();
  }
  _removeGraphics3DGraphic(e10, t7, i4 = false) {
    this._usedMemory -= t7, this.graphics3DGraphics.delete(e10), this.numberOfGraphics--, i4 && (this.numberOfGraphicsProvidingElevation--, this.updateStageLayerElevationProvider()), this._updateLayerVisibility();
  }
  _createGraphics3DGraphic(e10, t7) {
    var _a, _b, _c;
    const i4 = t7.graphic;
    if (this.graphicsWithoutSymbol.delete(i4.uid), !this.symbols.has(e10.symbol.id))
      return this.add([i4]), null;
    if (this.graphics3DGraphics.has(i4.uid))
      return null;
    const r5 = e10.createGraphics3DGraphic(t7);
    if (t(r5))
      return null;
    this._addGraphics3DGraphic(r5);
    const s6 = e10.symbol.id;
    this.graphicsBySymbol.has(s6) || this.graphicsBySymbol.set(s6, /* @__PURE__ */ new Map()), this.graphicsBySymbol.get(s6).set(i4.uid, r5);
    r5.isDraped && this.graphicsDrapedUids.add(i4.uid), r5.centroid = null, r(i4.geometry) && "point" !== i4.geometry.type && (r5.centroid = w3(i4.geometry, this._viewSpatialReference)), this._updateUserVisibility(r5), r(this.scaleVisibility) && this.scaleVisibility.updateVisibility(r5), r(this.filterVisibility) && this.filterVisibility.updateVisibility(r5), (_a = this.deconflictor) == null ? void 0 : _a.addGraphic(r5), (_b = this.labeler) == null ? void 0 : _b.addGraphic(r5), (_c = this.objectStates) == null ? void 0 : _c.addGraphic(r5), this.deconflictor && this.owner.view.deconflictor.setInitialIconVisibilityFlag(this, r5), r5.initialize(this.stage, this.stageLayer, this.owner), r(this.graphicStateTracking) && this.graphicStateTracking.addGraphic(r5);
    const a12 = this.whenGraphics3DGraphicRequests[i4.uid];
    return a12 && (delete this.whenGraphics3DGraphicRequests[i4.uid], a12.resolve(r5)), r5;
  }
  _abortRendererChange() {
    this.rendererChangeAbortController && (this.rendererChangeAbortController.abort(), this.rendererChangeAbortController = null);
  }
  async rendererChange(e10) {
    if (this._abortRendererChange(), e10 !== this.currentRenderer)
      if (this._validateRenderer(e10), t(e10) && this._currentRendererChange(null, false), o4(e10))
        if (r(e10) && e10.arcadeRequired) {
          const t7 = new AbortController();
          this.rendererChangeAbortController = t7;
          const { arcadeUtils: i4 } = await this._ensureArcade();
          f(t7), i4.hasGeometryOperations(e10) && (await i4.enableGeometryOperations(), f(t7)), this.effectiveUpdatePolicy === o2.ASYNC ? await this._frameTask.schedule(() => this._currentRendererChange(e10, true), t7.signal) : this._currentRendererChange(e10, true), this.rendererChangeAbortController = null;
        } else if (this.effectiveUpdatePolicy === o2.ASYNC) {
          const t7 = new AbortController();
          this.rendererChangeAbortController = t7, await this._frameTask.schedule(() => this._currentRendererChange(e10, false), t7.signal), this.rendererChangeAbortController = null;
        } else
          this._currentRendererChange(e10, false);
      else
        this._currentRendererChange(e10, false);
  }
  async _ensureArcade() {
    return t(this.arcadeOnDemand) ? (this.arcadeOnDemand = await a9(), this.arcadeOnDemand) : this.arcadeOnDemand;
  }
  _currentRendererChange(e10, t7) {
    this.currentRenderer = e10, this.rendererHasGeometryOperations = t7, this.symbolCreationContext.arcade = e2(this.arcadeOnDemand);
    const i4 = this.symbolCreationContext.renderer;
    if (e10 === i4)
      return;
    if (this.symbolConversionCache.clear(), t(e10))
      return this.symbolCreationContext.renderer = null, void this.recreateAllGraphicsAndSymbols();
    const r5 = m2(i4, e10);
    this._updateUnchangedSymbolMappings(r5, e10, i4), this.symbolCreationContext.renderer = e10, t(r5) || ("complete" === r5.type ? this.recreateAllGraphicsAndSymbols() : "partial" === r5.type && (this._applyRendererDiff(r5, e10, i4) ? this._volatileGraphicsUpdated() : this.recreateAllGraphicsAndSymbols()), this.notifyChange("averageSymbolComplexity"));
  }
  _diffHasSymbolChange(e10) {
    for (const t7 in e10.diff)
      switch (t7) {
        case "visualVariables":
        case "defaultSymbol":
        case "uniqueValueInfos":
          break;
        case "authoringInfo":
        case "fieldDelimiter":
          delete e10.diff[t7];
          break;
        default:
          return true;
      }
    return false;
  }
  _applySymbolSetDiff(e10, t7, i4) {
    e10 = e10 || [], t7 = t7 || [];
    const r5 = [];
    for (const s6 of t7) {
      const t8 = this.graphicsBySymbol.get(s6.id);
      t8 && t8.forEach((a12, n8) => {
        const o5 = a12.graphic, l5 = this.layer instanceof b ? this.layer : null, h4 = e2(this.arcadeOnDemand);
        if (s6 === i4.defaultSymbol && i4.getSymbol(c5(o5, l5), { arcade: h4 }) === i4.defaultSymbol)
          return;
        const d6 = a12.usedMemory;
        e10.length || i4.defaultSymbol ? r5.push(o5) : this.graphicsWithoutSymbol.set(n8, o5);
        const p2 = this.graphics3DGraphics.get(n8);
        this._conditionalRemove(p2, n8), a12.destroy(), t8.delete(n8), this._removeGraphics3DGraphic(n8, d6), this._updateLayerVisibility();
      }), this._whenSymbolRemoved.forAll((e11) => e11(s6.id));
    }
    (e10.length || r5.length) && (this.graphicsWithoutSymbol.forEach((e11) => r5.push(e11)), this.graphicsWithoutSymbol.clear(), this.add(r5)), this._cleanupSymbols(), this.labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty();
  }
  _applyUniqueValueRendererDiff(e10, t7, i4) {
    const r5 = e10.diff.defaultSymbol, s6 = e10.diff.uniqueValueInfos;
    if (r5 || s6) {
      const a12 = s6 ? s6.added.map((e11) => e11.symbol) : [], n8 = s6 ? s6.removed.map((e11) => e11.symbol) : [];
      if (s6)
        for (let e11 = 0; e11 < s6.changed.length; e11++)
          a12.push(s6.changed[e11].newValue.symbol), n8.push(s6.changed[e11].oldValue.symbol);
      return r5 ? (i4.defaultSymbol && n8.push(i4.defaultSymbol), t7.defaultSymbol && a12.push(t7.defaultSymbol)) : i4.defaultSymbol && a12.length && n8.push(t7.defaultSymbol), this._applySymbolSetDiff(a12, n8, t7), delete e10.diff.defaultSymbol, delete e10.diff.uniqueValueInfos, true;
    }
    return false;
  }
  _calculateUnchangedSymbolMapping(e10, t7, i4) {
    if ("unique-value" !== (t7 == null ? void 0 : t7.type) || "unique-value" !== (i4 == null ? void 0 : i4.type) || r(e10) && "partial" !== e10.type)
      return [];
    const r5 = (e11) => r(e11) ? e11.id : null, s6 = e10 && e10.diff, a12 = s6 && s6.defaultSymbol, n8 = s6 && s6.uniqueValueInfos;
    let o5;
    if (n8)
      o5 = n8.unchanged.map((e11) => ({ oldId: r5(e11.oldValue.symbol), newId: r5(e11.newValue.symbol) }));
    else {
      o5 = [];
      for (const e11 of i4.uniqueValueInfos) {
        const i5 = r5(e11.symbol), s7 = t7.uniqueValueInfos.find((t8) => t8.value === e11.value);
        s7 && i5 !== r5(s7.symbol) && o5.push({ oldId: i5, newId: r5(s7.symbol) });
      }
    }
    return !a12 && i4.defaultSymbol && o5.push({ oldId: r5(i4.defaultSymbol), newId: r5(t7.defaultSymbol) }), o5;
  }
  _updateSymbolMapping(e10, t7) {
    const i4 = r(t7) && t7 ? "string" == typeof t7 ? t7 : t7.id : null;
    if (!e10 || e10 === i4)
      return;
    const r5 = this.graphicsBySymbol.get(e10);
    this.graphicsBySymbol.delete(e10), void 0 !== r5 && this.graphicsBySymbol.set(i4, r5);
    const s6 = this.symbols.get(e10);
    if (void 0 !== s6 && (this.symbols.delete(e10), this.symbols.set(i4, s6), r(s6))) {
      const e11 = "string" == typeof t7 ? null : t7;
      r(e11) ? s6.symbol = e11 : s6.symbol.id = i4;
    }
  }
  _updateUnchangedSymbolMappings(e10, t7, i4) {
    const r5 = this._calculateUnchangedSymbolMapping(e10, t7, i4);
    for (const { oldId: s6, newId: a12 } of r5)
      this._updateSymbolMapping(s6, a12);
  }
  _applyRendererDiff(e10, i4, r5) {
    if (this._diffHasSymbolChange(e10))
      return false;
    if (i4 instanceof P && r5 instanceof P && this._applyUniqueValueRendererDiff(e10, i4, r5) && 0 === Object.keys(e10.diff).length)
      return true;
    for (const [t7] of this.graphicsBySymbol) {
      const r6 = this.symbols.get(t7);
      if (r(r6))
        switch (r6.applyRendererDiff(e10, i4)) {
          case e5.Recreate_Symbol:
            this._recreateSymbol(t7);
            break;
          case e5.Recreate_Graphics:
            this._recreateGraphicsForSymbol(t7);
          case e5.Fast_Update:
        }
    }
    return true;
  }
  opacityChange() {
    this.forEachGraphics3DSymbol((e10, t7) => e10.globalPropertyChanged("opacity", t7)), this._updateStageLayerVisibility();
  }
  _slicePlaneEnabledChange(e10) {
    e10 !== this.symbolCreationContext.slicePlaneEnabled && (this.symbolCreationContext.slicePlaneEnabled = e10, this.stageLayer.isSliceable = e10, this.forEachGraphics3DSymbol((e11, t7) => e11.globalPropertyChanged("slicePlaneEnabled", t7)), this.deconflictor && this.deconflictor.slicePlaneEnabledChange(), this.labeler && this.labeler.slicePlaneEnabledChange());
  }
  _physicalBasedRenderingChange(e10) {
    e10 !== this.symbolCreationContext.physicalBasedRenderingEnabled && (this.symbolCreationContext.physicalBasedRenderingEnabled = e10, this.forEachGraphics3DSymbol((e11, t7, i4) => {
      e11.globalPropertyChanged("physicalBasedRenderingEnabled", t7) || this._recreateSymbol(i4);
    }));
  }
  _pixelRatioChange() {
    this.forEachGraphics3DSymbol((e10, t7, i4) => {
      e10.globalPropertyChanged("pixelRatio", t7) || this._recreateSymbol(i4);
    });
  }
  _signalUpdatingDuringAsyncLoadedGraphicsChange() {
    this._updatingPendingLoadedGraphicsChange && this._updatingPendingLoadedGraphicsChange.remove(), this._updatingPendingLoadedGraphicsChange = v(() => {
      this._updatingPendingLoadedGraphicsChange = null;
    });
  }
  setClippingExtent(e10, t7) {
    const i4 = this.symbolCreationContext.clippingExtent, r5 = u3();
    return e4(e10, r5, t7) ? this.symbolCreationContext.clippingExtent = O(a4(), r5) : this.symbolCreationContext.clippingExtent = null, !k(this.symbolCreationContext.clippingExtent, i4);
  }
  modifyGraphics3DGraphicVisibilities(e10) {
    let t7 = false;
    this.graphics3DGraphics.forEach((i4) => {
      e10(i4) && (t7 = true);
    }), t7 && (this.labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty());
  }
  forEachGraphics3DSymbol(e10) {
    for (const [t7, i4] of this.symbols) {
      if (t(i4))
        return;
      e10(i4, this.graphicsBySymbol.get(t7) || We, t7);
    }
  }
  updateAllGraphicsVisibility() {
    r(this.filterVisibility) && (this.filterVisibility.dirty = true), this.modifyGraphics3DGraphicVisibilities((e10) => {
      const t7 = this._updateUserVisibility(e10), i4 = r(this.scaleVisibility) && this.scaleVisibility.updateVisibility(e10);
      return t7 || i4;
    });
  }
  _hideAllGraphics() {
    this.modifyGraphics3DGraphicVisibilities((e10) => e10.setVisibilityFlag(C.USER_SETTING, false, E2.GRAPHIC));
  }
  _validateRenderer(e10) {
    const t7 = t4(e10);
    if (t7) {
      const e11 = `Renderer for layer '${this.layer.title ? `${this.layer.title}, ` : ""}, id:${this.layer.id}' is not supported in a SceneView`;
      Le.warn(e11, t7.message);
    }
  }
  _volatileGraphicsUpdated() {
    var _a;
    (_a = this.labeler) == null ? void 0 : _a.reset(), this.stageLayer.shaderTransformationChanged(), this.notifyChange("updating");
  }
  _cleanupSymbols() {
    if (this.graphicsWaitingForSymbol.size > 0 || this.suspendSymbolCleanup)
      return;
    let e10 = false;
    this.symbols.forEach((t7, i4) => {
      if (t(t7) || t7.referenced > 0)
        return;
      const r5 = this.graphicsBySymbol.get(i4);
      r5 && 0 !== r5.size || (this.graphicsBySymbol.delete(i4), this.symbols.delete(i4), l(t7), e10 = true);
    }), e10 && (this._recomputeExtentPadding(), this.notifyChange("averageSymbolComplexity"));
  }
  get test() {
    return { snapshotInternals: () => ({ graphics: [...this.graphics3DGraphics.keys()].sort(), symbols: [...this.symbols.keys()].sort(), graphicsBySymbol: [...this.graphicsBySymbol.keys()].sort().map((e10) => ({ symbolId: e10, graphics: [...this.graphicsBySymbol.get(e10).keys()].sort() })), graphicsWithoutSymbol: [...this.graphicsWithoutSymbol.keys()].sort(), graphicsDrapedUids: [...this.graphicsDrapedUids].sort(), pendingUpdates: this.pendingUpdates }), symbols: this.symbols, filterVisibility: this.filterVisibility, numPending: this.pendingUpdates.size, forceUpdatePolicy: (e10) => {
      this.forcedUpdatePolicy = e10;
    } };
  }
  get performanceInfo() {
    return { visible: this.graphics3DGraphics.size, missing: this.graphicsWithoutSymbol.size, pending: this.pendingUpdates.size };
  }
};
var Ve;
je.tmpVec = n5(), e([d({ readOnly: true })], je.prototype, "computedExtent", void 0), e([d()], je.prototype, "currentRenderer", void 0), e([d()], je.prototype, "rendererHasGeometryOperations", void 0), e([d()], je.prototype, "_frameTask", void 0), e([d()], je.prototype, "rendererChangeAbortController", void 0), e([d()], je.prototype, "elevationInfoChangeAbortController", void 0), e([d()], je.prototype, "setupAbortController", void 0), e([d({ readOnly: true })], je.prototype, "elevationAlignment", void 0), e([d({ readOnly: true })], je.prototype, "scaleVisibility", void 0), e([d({ readOnly: true })], je.prototype, "filterVisibility", void 0), e([d()], je.prototype, "_spatialIndex", void 0), e([d({ readOnly: true })], je.prototype, "extentPadding", void 0), e([d()], je.prototype, "_updatingPendingLoadedGraphicsChange", void 0), e([d({ readOnly: true })], je.prototype, "featureStore", void 0), e([d({ readOnly: true })], je.prototype, "deconflictor", void 0), e([d({ readOnly: true })], je.prototype, "labeler", void 0), e([d({ readOnly: true })], je.prototype, "objectStates", void 0), e([d()], je.prototype, "_loadingSymbols", void 0), e([d()], je.prototype, "preferredUpdatePolicy", void 0), e([d()], je.prototype, "forcedUpdatePolicy", void 0), e([d({ readOnly: true })], je.prototype, "effectiveUpdatePolicy", null), e([d({ constructOnly: true })], je.prototype, "elevationFeatureExpressionEnabled", void 0), e([d({ constructOnly: true })], je.prototype, "owner", void 0), e([d({ constructOnly: true })], je.prototype, "layer", void 0), e([d({ constructOnly: true })], je.prototype, "graphicSymbolSupported", void 0), e([d({ constructOnly: true })], je.prototype, "getRenderingInfoWithoutRenderer", void 0), e([d({ readOnly: true })], je.prototype, "updating", null), e([d({ readOnly: true })], je.prototype, "running", null), e([d({ readOnly: true })], je.prototype, "suspendedOrOutsideOfView", null), e([d({ readOnly: true, dependsOn: [] })], je.prototype, "updatingRemaining", null), e([d({ readOnly: true, dependsOn: ["owner.view.qualitySettings.graphics3D.maxTotalNumberOfPrimitives", "owner.view.qualitySettings.graphics3D.maxTotalNumberOfFeatures", "averageSymbolComplexity"] })], je.prototype, "displayFeatureLimit", null), e([d({ readOnly: true, dependsOn: [] })], je.prototype, "averageSymbolComplexity", null), e([d({ constructOnly: true })], je.prototype, "hasZ", void 0), e([d({ constructOnly: true })], je.prototype, "hasM", void 0), je = Ue = e([n4("esri.views.3d.layers.graphics.Graphics3DCore")], je), function(e10) {
  e10[e10.NEW = 0] = "NEW", e10[e10.LOADING = 1] = "LOADING", e10[e10.READY = 2] = "READY", e10[e10.REJECTED = 3] = "REJECTED";
}(Ve || (Ve = {}));
var Fe = class {
  constructor() {
    this.add = null, this.renderingInfo = null, this.state = Ve.NEW, this.remove = null;
  }
  clear() {
    this.add = null, this.renderingInfo = null, this.state = Ve.NEW, this.abortController = null, this.remove = null;
  }
};
var Te = 10;
var ke = n5();
var Me = n5();
var We = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DScaleVisibility.js
var g3 = class extends y {
  constructor() {
    super(...arguments), this._scaleRangeActive = false, this.layerScaleRangeVisibilityQuery = false, this.handles = new u2(), this.graphicsCoreOwner = null, this.layer = null, this.queryGraphicUIDsInExtent = null, this.extent = null, this.graphicsCore = null, this.basemapTerrain = null, this.layerScaleEnabled = true, this.suspended = false, this.updating = true;
  }
  setup(e10, i4, t7, s6, a12) {
    this.graphicsCoreOwner = e10, this.layer = i4, this.queryGraphicUIDsInExtent = t7, this.graphicsCore = s6, this.basemapTerrain = a12, this.updateScaleRangeActive();
    const r5 = this.graphicsCoreOwner.view.resourceController.scheduler;
    this.handles.add(r5.registerTask(L.SCALE_VISIBILITY, this));
  }
  destroy() {
    this.handles.destroy(), this.handles = null, this.graphicsCoreOwner = null, this.extent = null, this.queryGraphicUIDsInExtent = null, this.graphicsCore = null;
  }
  _setDirty() {
    this.updating || this._set("updating", true);
  }
  setExtent(e10) {
    const i4 = this.graphicsCoreOwner.view.spatialReference, t7 = this.graphicsCoreOwner.view.basemapTerrain.spatialReference;
    if (i4 === t7)
      this.extent = e10;
    else {
      const s6 = u3();
      zn(e10, i4, s6, t7) ? this.extent = s6 : this.extent = null;
    }
    this._setDirty();
  }
  scaleRangeActive() {
    return this._scaleRangeActive;
  }
  updateScaleRangeActive() {
    const e10 = this.layer, i4 = e10.effectiveScaleRange;
    let t7 = this.layerScaleEnabled && y3(i4.minScale, i4.maxScale);
    e10.labelingInfo && !t7 && (t7 = e10.labelingInfo.some((e11) => e11 && y3(e11.minScale, e11.maxScale)));
    const s6 = this._scaleRangeActive !== t7;
    return this._scaleRangeActive = t7, t7 && !this.handles.has(d5) && this.basemapTerrain ? (this.handles.add(this.basemapTerrain.on("scale-change", (e11) => this._scaleUpdateHandler(e11)), d5), this.layerScaleEnabled && this.handles.add(this.basemapTerrain.on("tiles-visibility-changed", () => this._setDirty()), d5)) : !t7 && this.handles.has(d5) && this.handles.remove(d5), s6;
  }
  get running() {
    return !(!this.graphicsCoreOwner.view.basemapTerrain || !this.updating);
  }
  runTask() {
    const e10 = this.graphicsCoreOwner.view.basemapTerrain;
    if (this.extent && e10 && e10.ready && this._scaleRangeActive && this.layerScaleEnabled) {
      if (!this.layerScaleRangeVisibilityQuery) {
        this.layerScaleRangeVisibilityQuery = true;
        const i4 = this.layer.effectiveScaleRange;
        e10.queryVisibleScaleRange(this.extent, i4.minScale, i4.maxScale, (e11) => this._finishUpdate(e11));
      }
    } else
      this._finishUpdate(true);
  }
  _finishUpdate(e10) {
    this.layerScaleRangeVisibilityQuery = false, this._set("suspended", !e10), this._set("updating", false);
  }
  _visibleAtLayerScale(e10) {
    const i4 = this.layer.effectiveScaleRange;
    return !this.layerScaleEnabled || c4(e10, i4.minScale || 0, i4.maxScale || 0);
  }
  _visibleAtLabelScale(e10, i4) {
    return c4(e10, i4.minScale || 0, i4.maxScale || 0);
  }
  _graphicScale(e10) {
    let i4;
    if (r(e10.centroid) ? i4 = e10.centroid : r(e10.graphic.geometry) && "point" === e10.graphic.geometry.type && (i4 = e10.graphic.geometry), i4) {
      return this.graphicsCoreOwner.view.basemapTerrain ? this.graphicsCoreOwner.view.basemapTerrain.getScale(i4) : 1;
    }
    return null;
  }
  _graphicVisible(e10) {
    if (!this.layerScaleEnabled)
      return true;
    const i4 = this._graphicScale(e10);
    return this._visibleAtLayerScale(i4);
  }
  updateVisibility(e10) {
    if (this._scaleRangeActive) {
      const i4 = this._graphicVisible(e10);
      return e10.setVisibilityFlag(C.SCALE_RANGE, i4, E2.GRAPHIC);
    }
    return false;
  }
  updateGraphicLabelScaleVisibility(e10) {
    if (!this._scaleRangeActive)
      return false;
    if (!e10.labelGraphics || 0 === e10.labelGraphics.length)
      return false;
    const i4 = this._graphicScale(e10), t7 = this._updateLabelScaleVisibility(e10, i4);
    return t7 && (this.graphicsCoreOwner.view.deconflictor.setDirty(), this.graphicsCoreOwner.view.labeler.setDirty()), t7;
  }
  _updateLabelScaleVisibility(e10, i4) {
    if (!e10.labelGraphics || 0 === e10.labelGraphics.length)
      return false;
    const t7 = e10.labelGraphics[0]._labelClass;
    if (t7 && null != t7.minScale && null != t7.maxScale) {
      const s6 = this._visibleAtLabelScale(i4, t7);
      if (e10.setVisibilityFlag(C.SCALE_RANGE, s6, E2.LABEL))
        return true;
    }
    return false;
  }
  _scaleUpdateHandler(e10) {
    if (this._setDirty(), this.graphicsCoreOwner.suspended)
      return;
    const i4 = e10.extent, t7 = e10.scale, r5 = this._visibleAtLayerScale(t7);
    let l5 = false;
    this.queryGraphicUIDsInExtent(i4, e10.spatialReference, (e11) => {
      const n8 = this.graphicsCore.getGraphics3DGraphicById(e11);
      if (t(n8))
        return;
      const c7 = n8.centroid;
      r(c7) && (i4[0] > c7.x || i4[1] > c7.y || i4[2] < c7.x || i4[3] < c7.y) || (n8.setVisibilityFlag(C.SCALE_RANGE, r5, E2.GRAPHIC) && (l5 = true), this._updateLabelScaleVisibility(n8, t7) && (l5 = true));
    }), l5 && (this.graphicsCoreOwner.view.deconflictor.setDirty(), this.graphicsCoreOwner.view.labeler.setDirty());
  }
  layerMinMaxScaleChangeHandler() {
    this.updateScaleRangeActive() && !this._scaleRangeActive ? this.graphicsCore.modifyGraphics3DGraphicVisibilities((e10) => e10.clearVisibilityFlag(C.SCALE_RANGE)) : this._scaleRangeActive && this.graphicsCore.updateAllGraphicsVisibility(), this._setDirty();
  }
};
function y3(e10, i4) {
  return e10 > 0 || i4 > 0;
}
e([d({ constructOnly: true })], g3.prototype, "layerScaleEnabled", void 0), e([d({ readOnly: true })], g3.prototype, "suspended", void 0), e([d({ readOnly: true })], g3.prototype, "updating", void 0), g3 = e([n4("esri.views.3d.layers.graphics.Graphics3DScaleVisibility")], g3);
var d5 = "terrain-events";
var b7 = g3;

export {
  je,
  b7 as b
};
//# sourceMappingURL=chunk-3ITGQWSQ.js.map
