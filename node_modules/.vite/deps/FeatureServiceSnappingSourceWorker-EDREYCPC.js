import {
  h,
  u as u3
} from "./chunk-4QVQG5LC.js";
import "./chunk-UQFAHV7T.js";
import {
  Y
} from "./chunk-COK4R22F.js";
import "./chunk-T6XN76GI.js";
import "./chunk-EZ4QR7V3.js";
import "./chunk-25Y2OKSP.js";
import "./chunk-EMETVH63.js";
import "./chunk-V56SVRSV.js";
import "./chunk-XZHFGTRH.js";
import "./chunk-2I27THZD.js";
import "./chunk-X64NQ2GK.js";
import "./chunk-NVOCHKIH.js";
import "./chunk-DGELARKE.js";
import "./chunk-WN3KE5M2.js";
import "./chunk-KBCUY3VB.js";
import "./chunk-Z7BSDVJ3.js";
import "./chunk-CC32E45Q.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import {
  S as S2,
  c as c3,
  d as d3,
  x
} from "./chunk-TB42IUV7.js";
import {
  a
} from "./chunk-ZWMYDR2G.js";
import "./chunk-ZZY5IDKU.js";
import {
  ce,
  ge,
  le
} from "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import "./chunk-4I3W4KD5.js";
import "./chunk-JNXH4TTS.js";
import "./chunk-PZWU5EHT.js";
import {
  v
} from "./chunk-J6DXGG2A.js";
import "./chunk-S4ZKPFDU.js";
import "./chunk-YG6VFATO.js";
import {
  S
} from "./chunk-HR2OX32D.js";
import {
  e as e3,
  o,
  r as r2
} from "./chunk-7ZPDA3EC.js";
import {
  g
} from "./chunk-6GPADSSO.js";
import "./chunk-FU5UMT3R.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import "./chunk-QZTJM4HG.js";
import "./chunk-F5A4XAOJ.js";
import "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  u as u4
} from "./chunk-QKRZMDWG.js";
import "./chunk-TBT57L4K.js";
import "./chunk-GRILTTJT.js";
import {
  d as d2
} from "./chunk-JJRJ6TV3.js";
import {
  c as c2
} from "./chunk-K2FQEYBG.js";
import {
  u
} from "./chunk-G4IZ2HTT.js";
import {
  U,
  j,
  l
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-Z6EP2GTZ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-PZG7CR4Y.js";
import "./chunk-2HDG7SIE.js";
import {
  E,
  c,
  f as f2,
  u as u2,
  y as y2
} from "./chunk-56RHM4A6.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-5Z5455ZY.js";
import "./chunk-D7DLEBS2.js";
import "./chunk-TT2HIXWQ.js";
import {
  n as n3
} from "./chunk-OIPX3EDD.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n2 as n,
  n8 as n2,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  O,
  T,
  f,
  w
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  e as e2,
  i2 as i,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/core/AsyncSequence.js
var r3 = class extends y {
  constructor() {
    super(...arguments), this.updating = false, this.pending = [];
  }
  push(s2, t3) {
    this.pending.push({ promise: s2, callback: t3 }), 1 === this.pending.length && this._process();
  }
  _process() {
    if (!this.pending.length)
      return void (this.updating = false);
    this.updating = true;
    const s2 = this.pending[0];
    s2.promise.then((t3) => s2.callback(t3)).catch(() => {
    }).then(() => {
      this.pending.shift(), this._process();
    });
  }
};
e([d()], r3.prototype, "updating", void 0), r3 = e([n2("esri.core.AsyncSequence")], r3);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var o2 = class {
  constructor(t3, e4) {
    this.data = t3, this.resolution = e4, this.state = { type: u5.CREATED }, this.alive = true;
  }
  process(t3) {
    switch (this.state.type) {
      case u5.CREATED:
        return this.state = this._gotoFetchCount(this.state, t3), this.state.task.promise.then(t3.resume, t3.resume);
      case u5.FETCH_COUNT:
        break;
      case u5.FETCHED_COUNT:
        return this.state = this._gotoFetchFeatures(this.state, t3), this.state.task.promise.then(t3.resume, t3.resume);
      case u5.FETCH_FEATURES:
        break;
      case u5.FETCHED_FEATURES:
        this.state = this._goToDone(this.state, t3);
      case u5.DONE:
    }
    return null;
  }
  get debugInfo() {
    return { data: this.data, featureCount: this.featureCount, state: this.stateToString };
  }
  get featureCount() {
    switch (this.state.type) {
      case u5.CREATED:
      case u5.FETCH_COUNT:
        return 0;
      case u5.FETCHED_COUNT:
        return this.state.featureCount;
      case u5.FETCH_FEATURES:
        return this.state.previous.featureCount;
      case u5.FETCHED_FEATURES:
        return this.state.features.length;
      case u5.DONE:
        return this.state.previous.features.length;
    }
  }
  get stateToString() {
    switch (this.state.type) {
      case u5.CREATED:
        return "created";
      case u5.FETCH_COUNT:
        return "fetch-count";
      case u5.FETCHED_COUNT:
        return "fetched-count";
      case u5.FETCH_FEATURES:
        return "fetch-features";
      case u5.FETCHED_FEATURES:
        return "fetched-features";
      case u5.DONE:
        return "done";
    }
  }
  _gotoFetchCount(e4, a2) {
    return { type: u5.FETCH_COUNT, previous: e4, task: O(async (e5) => {
      const s2 = await u4(a2.fetchCount(this, e5));
      this.state.type === u5.FETCH_COUNT && (this.state = this._gotoFetchedCount(this.state, s2.ok ? s2.value : 1 / 0));
    }) };
  }
  _gotoFetchedCount(t3, e4) {
    return { type: u5.FETCHED_COUNT, featureCount: e4, previous: t3 };
  }
  _gotoFetchFeatures(e4, a2) {
    return { type: u5.FETCH_FEATURES, previous: e4, task: O(async (s2) => {
      const r4 = await u4(a2.fetchFeatures(this, e4.featureCount, s2));
      this.state.type === u5.FETCH_FEATURES && (this.state = this._gotoFetchedFeatures(this.state, r4.ok ? r4.value : []));
    }) };
  }
  _gotoFetchedFeatures(t3, e4) {
    return { type: u5.FETCHED_FEATURES, previous: t3, features: e4 };
  }
  _goToDone(t3, e4) {
    return e4.finish(this, t3.features), { type: u5.DONE, previous: t3 };
  }
  reset() {
    const t3 = this.state;
    switch (this.state = { type: u5.CREATED }, t3.type) {
      case u5.CREATED:
      case u5.FETCHED_COUNT:
      case u5.FETCHED_FEATURES:
      case u5.DONE:
        break;
      case u5.FETCH_COUNT:
      case u5.FETCH_FEATURES:
        t3.task.abort();
    }
  }
  intersects(t3) {
    return !(!t(t3) && this.data.extent) || (c(t3, T2), E(this.data.extent, T2));
  }
};
var u5;
!function(t3) {
  t3[t3.CREATED = 0] = "CREATED", t3[t3.FETCH_COUNT = 1] = "FETCH_COUNT", t3[t3.FETCHED_COUNT = 2] = "FETCHED_COUNT", t3[t3.FETCH_FEATURES = 3] = "FETCH_FEATURES", t3[t3.FETCHED_FEATURES = 4] = "FETCHED_FEATURES", t3[t3.DONE = 5] = "DONE";
}(u5 || (u5 = {}));
var T2 = u2();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var S3 = s.getLogger("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher");
var C = class extends d2 {
  constructor(e4) {
    super(e4), this.tilesOfInterest = [], this.availability = 0, this.pendingTiles = /* @__PURE__ */ new Map(), this.pendingEdits = new r3(), this.pendingEditsAbortController = new AbortController();
  }
  get minimumVerticesPerFeature() {
    var _a;
    switch ((_a = this.store) == null ? void 0 : _a.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  set filter(e4) {
    const t3 = this._get("filter"), i2 = this._filterProperties(e4);
    JSON.stringify(t3) !== JSON.stringify(i2) && this._set("filter", i2);
  }
  set customParameters(e4) {
    const t3 = this._get("customParameters");
    JSON.stringify(t3) !== JSON.stringify(e4) && this._set("customParameters", e4);
  }
  get configuration() {
    return { filter: this.filter, customParameters: this.customParameters, tileInfo: this.tileInfo, tileSize: this.tileSize };
  }
  set tileInfo(e4) {
    const t3 = this._get("tileInfo");
    t3 !== e4 && (r(e4) && r(t3) && JSON.stringify(e4) === JSON.stringify(t3) || (this._set("tileInfo", e4), this.store.tileInfo = e4));
  }
  set tileSize(e4) {
    this._get("tileSize") !== e4 && this._set("tileSize", e4);
  }
  get updating() {
    return this.updatingHandles.updating || this.pendingEdits.updating;
  }
  initialize() {
    this._initializeFetchExtent(), this.updatingHandles.add(() => this.configuration, () => this.refresh()), this.updatingHandles.add(() => this.tilesOfInterest, (e4, i2) => {
      i(e4, i2, ({ id: e5 }, { id: t3 }) => e5 === t3) || this._process();
    }, U);
  }
  destroy() {
    this.pendingTiles.forEach((e4) => this._deletePendingTile(e4)), this.pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this.pendingEditsAbortController.abort(), this.pendingEditsAbortController = null;
  }
  refresh() {
    this.store.refresh(), this.pendingTiles.forEach((e4) => this._deletePendingTile(e4)), this._process();
  }
  applyEdits(e4) {
    this.pendingEdits.push(e4, async (e5) => {
      if (0 === e5.addedFeatures.length && 0 === e5.updatedFeatures.length && 0 === e5.deletedFeatures.length)
        return;
      for (const [, i2] of this.pendingTiles)
        i2.reset();
      const t3 = { ...e5, deletedFeatures: e5.deletedFeatures.map(({ objectId: e6, globalId: t4 }) => e6 && -1 !== e6 ? e6 : this._lookupObjectIdByGlobalId(t4)) };
      await this.updatingHandles.addPromise(this.store.processEdits(t3, (e6, t4) => this._queryFeaturesById(e6, t4), this.pendingEditsAbortController.signal)), this._processPendingTiles();
    });
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !g(this.url))
      return;
    const e4 = O(async (e5) => {
      var _a;
      try {
        const t3 = await x(this.url, new b({ where: "1=1", outSpatialReference: this.spatialReference, cacheHint: !!this.capabilities.query.supportsCacheHint || void 0 }), { query: this.configuration.customParameters, signal: e5 });
        this.store.extent = M.fromJSON((_a = t3.data) == null ? void 0 : _a.extent);
      } catch (t3) {
        w(t3), S3.warn("Failed to fetch data extent", t3);
      }
    });
    this.updatingHandles.addPromise(e4.promise.then(() => this._process())), this.handles.add(n(() => e4.abort()));
  }
  get debugInfo() {
    return { numberOfFeatures: this.store.featureStore.numFeatures, tilesOfInterest: this.tilesOfInterest, pendingTiles: Array.from(this.pendingTiles.values()).map((e4) => e4.debugInfo), storedTiles: this.store.debugInfo };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const [, e4] of this.pendingTiles)
      e4.alive = false;
  }
  _createPendingTiles() {
    const e4 = this._collectMissingTilesInfo();
    if (this._setAvailability(t(e4) ? 1 : e4.coveredArea / e4.fullArea), !t(e4))
      for (const { data: t3, resolution: i2 } of e4.missingTiles) {
        const e5 = this.pendingTiles.get(t3.id);
        e5 ? (e5.resolution = i2, e5.alive = true) : this._createPendingTile(t3, i2);
      }
  }
  _collectMissingTilesInfo() {
    let e4 = null;
    for (let t3 = this.tilesOfInterest.length - 1; t3 >= 0; t3--) {
      const i2 = this.tilesOfInterest[t3], s2 = this.store.process(i2, (e5, t4) => this._verifyTileComplexity(e5, t4));
      t(e4) ? e4 = s2 : e4.prepend(s2);
    }
    return e4;
  }
  _deletePendingTiles() {
    for (const [, e4] of this.pendingTiles)
      e4.alive || this._deletePendingTile(e4);
  }
  _processPendingTiles() {
    const e4 = { fetchCount: (e5, t3) => this._fetchCount(e5, t3), fetchFeatures: (e5, t3, i2) => this._fetchFeatures(e5, t3, i2), finish: (e5, t3) => this._finishPendingTile(e5, t3), resume: () => this._processPendingTiles() };
    if (this._ensureFetchAllCounts(e4))
      for (const [, t3] of this.pendingTiles)
        this._verifyTileComplexity(this.store.getFeatureCount(t3.data), t3.resolution) && this.updatingHandles.addPromise(t3.process(e4));
  }
  _verifyTileComplexity(e4, t3) {
    return this._verifyVertexComplexity(e4) && this._verifyFeatureDensity(e4, t3);
  }
  _verifyVertexComplexity(e4) {
    return e4 * this.minimumVerticesPerFeature < E2;
  }
  _verifyFeatureDensity(e4, t3) {
    if (t(this.tileInfo))
      return false;
    const i2 = this.tileSize * t3;
    return e4 * (w2 / (i2 * i2)) < q;
  }
  _ensureFetchAllCounts(e4) {
    let t3 = true;
    for (const [, i2] of this.pendingTiles)
      i2.state.type < u5.FETCHED_COUNT && this.updatingHandles.addPromise(i2.process(e4)), i2.state.type <= u5.FETCH_COUNT && (t3 = false);
    return t3;
  }
  _finishPendingTile(e4, t3) {
    this.store.add(e4.data, t3), this._deletePendingTile(e4), this._updateAvailability();
  }
  _updateAvailability() {
    const e4 = this._collectMissingTilesInfo();
    this._setAvailability(t(e4) ? 1 : e4.coveredArea / e4.fullArea);
  }
  _setAvailability(e4) {
    this._set("availability", e4);
  }
  _createPendingTile(e4, t3) {
    const i2 = new o2(e4, t3);
    return this.pendingTiles.set(e4.id, i2), i2;
  }
  _deletePendingTile(e4) {
    e4.reset(), this.pendingTiles.delete(e4.data.id);
  }
  async _fetchCount(e4, t3) {
    return this.store.fetchCount(e4.data, this.url, this._createCountQuery(e4), { query: this.customParameters, timeout: x2, signal: t3 });
  }
  async _fetchFeatures(e4, t3, i2) {
    let s2, r4 = 0, o3 = 0, n4 = t3;
    for (; ; ) {
      const a2 = this._createFeaturesQuery(e4), u6 = this._setPagingParameters(a2, r4, n4), { features: c4, exceededTransferLimit: d4 } = await this._queryFeatures(a2, i2);
      if (u6 && (r4 += e2(a2.num)), o3 += c4.length, s2 = s2 ? s2.concat(c4) : c4, n4 = t3 - o3, !u6 || !d4 || n4 <= 0)
        return s2;
    }
  }
  _filterProperties(e4) {
    return t(e4) ? { where: "1=1", gdbVersion: void 0, timeExtent: void 0 } : { where: e4.where || "1=1", timeExtent: e4.timeExtent, gdbVersion: e4.gdbVersion };
  }
  _lookupObjectIdByGlobalId(e4) {
    const t3 = this.globalIdField, i2 = this.objectIdField;
    if (t(t3))
      throw new Error("Expected globalIdField to be defined");
    let s2 = null;
    if (this.store.featureStore.forEach((r4) => {
      e4 === r4.attributes[t3] && (s2 = r4.objectId ?? r4.attributes[i2]);
    }), t(s2))
      throw new Error(`Expected to find a feature with globalId ${e4}`);
    return s2;
  }
  _queryFeaturesById(e4, t3) {
    const i2 = this._createFeaturesQuery(null);
    return i2.objectIds = e4, this._queryFeatures(i2, t3);
  }
  _queryFeatures(e4, t3) {
    return this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e4, t3) : this._queryFeaturesJSON(e4, t3);
  }
  async _queryFeaturesPBF(e4, t3) {
    const { sourceSpatialReference: i2 } = this, { data: s2 } = await d3(this.url, e4, new a({ sourceSpatialReference: i2 }), { query: this.configuration.customParameters, timeout: x2, signal: t3 });
    return le(s2);
  }
  async _queryFeaturesJSON(e4, t3) {
    const { sourceSpatialReference: i2 } = this, { data: s2 } = await c3(this.url, e4, i2, { query: this.configuration.customParameters, timeout: x2, signal: t3 });
    return ce(s2, this.objectIdField);
  }
  _createCountQuery(e4) {
    const t3 = this._createBaseQuery(e4);
    return this.capabilities.query.supportsCacheHint && (t3.cacheHint = true), t3;
  }
  _createFeaturesQuery(e4) {
    const t3 = this._createBaseQuery(e4);
    return t3.outFields = this.globalIdField ? [this.globalIdField, this.objectIdField] : [this.objectIdField], t3.returnGeometry = true, r(e4) && (this.capabilities.query.supportsResultType ? t3.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t3.cacheHint = true)), t3;
  }
  _createBaseQuery(e4) {
    const t3 = new b({ returnZ: false, returnM: false, geometry: r(this.tileInfo) && r(e4) ? f2(e4.data.extent, this.tileInfo.spatialReference) : void 0 }), i2 = this.configuration.filter;
    return r(i2) && (t3.where = i2.where, t3.gdbVersion = i2.gdbVersion, t3.timeExtent = i2.timeExtent), t3.outSpatialReference = this.spatialReference, t3;
  }
  _setPagingParameters(e4, t3, i2) {
    if (!this.capabilities.query.supportsPagination)
      return false;
    const { supportsMaxRecordCountFactor: s2, supportsCacheHint: r4, tileMaxRecordCount: o3, maxRecordCount: n4, supportsResultType: a2 } = this.capabilities.query, l2 = s2 ? b.MAX_MAX_RECORD_COUNT_FACTOR : 1, u6 = l2 * ((a2 || r4) && o3 ? o3 : n4 || j2);
    return e4.start = t3, s2 ? (e4.maxRecordCountFactor = Math.min(l2, Math.ceil(i2 / u6)), e4.num = Math.min(i2, e4.maxRecordCountFactor * u6)) : e4.num = Math.min(i2, u6), true;
  }
};
e([d({ constructOnly: true })], C.prototype, "url", void 0), e([d({ constructOnly: true })], C.prototype, "objectIdField", void 0), e([d({ constructOnly: true })], C.prototype, "globalIdField", void 0), e([d({ constructOnly: true })], C.prototype, "capabilities", void 0), e([d({ constructOnly: true })], C.prototype, "sourceSpatialReference", void 0), e([d({ constructOnly: true })], C.prototype, "spatialReference", void 0), e([d({ constructOnly: true })], C.prototype, "store", void 0), e([d({ readOnly: true })], C.prototype, "minimumVerticesPerFeature", null), e([d()], C.prototype, "filter", null), e([d()], C.prototype, "customParameters", null), e([d({ readOnly: true })], C.prototype, "configuration", null), e([d()], C.prototype, "tileInfo", null), e([d()], C.prototype, "tileSize", null), e([d()], C.prototype, "tilesOfInterest", void 0), e([d({ readOnly: true })], C.prototype, "updating", null), e([d({ readOnly: true })], C.prototype, "availability", void 0), C = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], C);
var j2 = 2e3;
var x2 = 6e5;
var E2 = 1e6;
var w2 = 25;
var q = 1;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t2 = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._byteSize = 0;
  }
  set(t3, e4) {
    this.delete(t3), this._store.set(t3, e4), this._byteSize += e4.byteSize;
  }
  delete(t3) {
    const e4 = this._store.get(t3);
    return !!this._store.delete(t3) && (this._byteSize -= e4.byteSize, true);
  }
  get(t3) {
    return this._used(t3), this._store.get(t3);
  }
  has(t3) {
    return this._used(t3), this._store.has(t3);
  }
  clear() {
    this._store.clear();
  }
  applyByteSizeLimit(t3, e4) {
    for (const [s2, r4] of this._store) {
      if (this._byteSize <= t3)
        break;
      this.delete(s2), e4(r4);
    }
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
  _used(t3) {
    const e4 = this._store.get(t3);
    e4 && (this._store.delete(t3), this._store.set(t3, e4));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var v2 = class extends y {
  constructor(e4) {
    super(e4), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10 * o.MEGABYTES, this.tileBounds = new h(), this.tiles = new t2(), this.refCounts = /* @__PURE__ */ new Map(), this.tileFeatureCounts = /* @__PURE__ */ new Map(), this.tmpBoundingRect = u2();
  }
  add(e4, t3) {
    const s2 = [];
    for (const i2 of t3)
      this._referenceFeature(i2.objectId) === w3.ADDED && s2.push(i2);
    this._addTileStorage(e4, new Set(t3.map(({ objectId: e5 }) => e5)), y3(t3)), this.featureStore.addMany(s2), this.tiles.applyByteSizeLimit(this.maximumByteSize, (e5) => this._removeTileStorage(e5));
  }
  destroy() {
    this.clear(), this.tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this.tileBounds.clear(), this.tiles.clear(), this.refCounts.clear();
  }
  refresh() {
    this.clear(), this.tileFeatureCounts.clear();
  }
  processEdits(e4, t3, s2) {
    return this._processEditsDelete(e4.deletedFeatures.concat(e4.updatedFeatures)), this._processEditsRefetch(e4.addedFeatures.concat(e4.updatedFeatures), t3, s2);
  }
  _addTileStorage(e4, t3, s2) {
    this.tiles.set(e4.id, new S4(e4, t3, s2)), this.tileBounds.set(e4.id, e4.extent), this.tileFeatureCounts.set(e4.id, t3.size);
  }
  _remove({ id: e4 }) {
    const t3 = this.tiles.get(e4);
    t3 && this._removeTileStorage(t3);
  }
  _removeTileStorage(e4) {
    const t3 = [];
    for (const i2 of e4.objectIds)
      this._unreferenceFeature(i2) === w3.REMOVED && t3.push(i2);
    this.featureStore.removeManyById(t3);
    const s2 = e4.data.id;
    this.tiles.delete(s2), this.tileBounds.delete(s2);
  }
  _processEditsDelete(e4) {
    this.featureStore.removeManyById(e4);
    for (const [, t3] of this.tiles) {
      for (const s2 of e4)
        t3.objectIds.delete(s2);
      this.tileFeatureCounts.set(t3.data.id, t3.objectIds.size);
    }
    for (const t3 of e4)
      this.refCounts.delete(t3);
  }
  async _processEditsRefetch(e4, t3, s2) {
    const i2 = (await t3(e4, s2)).features, { hasZ: r4, hasM: n4 } = this.featureStore;
    for (const l2 of i2) {
      const e5 = ge(this.tmpBoundingRect, l2.geometry, r4, n4);
      t(e5) || this.tileBounds.forEachInBounds(e5, (e6) => {
        const t4 = this.tiles.get(e6);
        this.featureStore.add(l2), t4.objectIds.has(l2.objectId) || (t4.objectIds.add(l2.objectId), this._referenceFeature(l2.objectId), this.tileFeatureCounts.set(t4.data.id, t4.objectIds.size));
      });
    }
  }
  process(e4, t3 = () => true) {
    if (t(this.tileInfo) || !e4.extent || r(this.extent) && !E(c(this.extent, this.tmpBoundingRect), e4.extent))
      return new I(e4);
    if (this.tiles.has(e4.id))
      return new I(e4);
    const s2 = this._createTileTree(e4, this.tileInfo);
    return this._simplify(s2, t3, null, 0, 1), this._collectMissingTiles(e4, s2, this.tileInfo);
  }
  get debugInfo() {
    return Array.from(this.tiles.values()).map(({ data: e4 }) => ({ data: e4, featureCount: this.tileFeatureCounts.get(e4.id) || 0 }));
  }
  getFeatureCount(e4) {
    return this.tileFeatureCounts.get(e4.id) ?? 0;
  }
  async fetchCount(e4, t3, s2, i2) {
    const r4 = this.tileFeatureCounts.get(e4.id);
    if (null != r4)
      return r4;
    const o3 = await S2(t3, s2, i2);
    return this.tileFeatureCounts.set(e4.id, o3.data.count), o3.data.count;
  }
  _createTileTree(e4, t3) {
    const s2 = new T3(e4.level, e4.row, e4.col);
    return t3.updateTileInfo(s2, S.ExtrapolateOptions.POWER_OF_TWO), this.tileBounds.forEachInBounds(e4.extent, (i2) => {
      const r4 = this.tiles.get(i2).data;
      this._tilesAreRelated(e4, r4) && this._populateChildren(s2, r4, t3, this.tileFeatureCounts.get(r4.id) || 0);
    }), s2;
  }
  _tilesAreRelated(e4, t3) {
    if (!e4 || !t3)
      return false;
    if (e4.level === t3.level)
      return e4.row === t3.row && e4.col === t3.col;
    const s2 = e4.level < t3.level, i2 = s2 ? e4 : t3, r4 = s2 ? t3 : e4, o3 = 1 << r4.level - i2.level;
    return Math.floor(r4.row / o3) === i2.row && Math.floor(r4.col / o3) === i2.col;
  }
  _populateChildren(e4, t3, s2, i2) {
    const r4 = t3.level - e4.level - 1;
    if (r4 < 0)
      return void (e4.isLeaf = true);
    const o3 = t3.row >> r4, l2 = t3.col >> r4, a2 = e4.row << 1, c4 = l2 - (e4.col << 1) + (o3 - a2 << 1), h2 = e4.children[c4];
    if (r(h2))
      this._populateChildren(h2, t3, s2, i2);
    else {
      const r5 = new T3(e4.level + 1, o3, l2);
      s2.updateTileInfo(r5, S.ExtrapolateOptions.POWER_OF_TWO), e4.children[c4] = r5, this._populateChildren(r5, t3, s2, i2);
    }
  }
  _simplify(e4, t3, s2, i2, r4) {
    const o3 = r4 * r4;
    if (e4.isLeaf)
      return t3(this.getFeatureCount(e4), r4) ? 0 : (this._remove(e4), r(s2) && (s2.children[i2] = null), o3);
    const l2 = r4 / 2, a2 = l2 * l2;
    let c4 = 0;
    for (let h2 = 0; h2 < e4.children.length; h2++) {
      const s3 = e4.children[h2];
      c4 += r(s3) ? this._simplify(s3, t3, e4, h2, l2) : a2;
    }
    return 0 === c4 ? this._mergeChildren(e4) : 1 - c4 / o3 < F && (this._purge(e4), r(s2) && (s2.children[i2] = null), c4 = o3), c4;
  }
  _mergeChildren(e4) {
    const t3 = /* @__PURE__ */ new Set();
    let s2 = 0;
    this._forEachLeaf(e4, (e5) => {
      const i2 = this.tiles.get(e5.id);
      if (i2) {
        s2 += i2.byteSize;
        for (const e6 of i2.objectIds)
          t3.has(e6) || (t3.add(e6), this._referenceFeature(e6));
        this._remove(e5);
      }
    }), this._addTileStorage(e4, t3, s2), e4.isLeaf = true, e4.children[0] = e4.children[1] = e4.children[2] = e4.children[3] = null, this.tileFeatureCounts.set(e4.id, t3.size);
  }
  _forEachLeaf(e4, t3) {
    for (const s2 of e4.children)
      t(s2) || (s2.isLeaf ? t3(s2) : this._forEachLeaf(s2, t3));
  }
  _purge(e4) {
    if (!t(e4))
      if (e4.isLeaf)
        this._remove(e4);
      else
        for (let t3 = 0; t3 < e4.children.length; t3++) {
          const s2 = e4.children[t3];
          this._purge(s2), e4.children[t3] = null;
        }
  }
  _collectMissingTiles(e4, t3, s2) {
    const i2 = new j3(s2, e4, this.extent);
    return this._collectMissingTilesRecurse(t3, i2, 1), i2.info;
  }
  _collectMissingTilesRecurse(e4, t3, s2) {
    if (e4.isLeaf)
      return;
    if (!e4.hasChildren)
      return void t3.addMissing(e4.level, e4.row, e4.col, s2);
    const i2 = s2 / 2;
    for (let r4 = 0; r4 < e4.children.length; r4++) {
      const s3 = e4.children[r4];
      t(s3) ? t3.addMissing(e4.level + 1, (e4.row << 1) + ((2 & r4) >> 1), (e4.col << 1) + (1 & r4), i2) : this._collectMissingTilesRecurse(s3, t3, i2);
    }
  }
  _referenceFeature(e4) {
    const t3 = (this.refCounts.get(e4) || 0) + 1;
    return this.refCounts.set(e4, t3), 1 === t3 ? w3.ADDED : w3.UNCHANGED;
  }
  _unreferenceFeature(e4) {
    const t3 = (this.refCounts.get(e4) || 0) - 1;
    return 0 === t3 ? (this.refCounts.delete(e4), w3.REMOVED) : (t3 > 0 && this.refCounts.set(e4, t3), w3.UNCHANGED);
  }
  get test() {
    return { tiles: Array.from(this.tiles.values()).map((e4) => `${e4.data.id}:[${Array.from(e4.objectIds)}]`), featureReferences: Array.from(this.refCounts.keys()).map((e4) => `${e4}:${this.refCounts.get(e4)}`) };
  }
};
function y3(e4) {
  return e4.reduce((e5, t3) => e5 + C2(t3), 0);
}
function C2(e4) {
  return 32 + E3(e4.geometry) + r2(e4.attributes);
}
function E3(e4) {
  if (t(e4))
    return 0;
  const t3 = e3(e4.lengths, 4);
  return 32 + e3(e4.coords, 8) + t3;
}
e([d({ constructOnly: true })], v2.prototype, "featureStore", void 0), e([d()], v2.prototype, "tileInfo", void 0), e([d()], v2.prototype, "extent", void 0), e([d()], v2.prototype, "maximumByteSize", void 0), v2 = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], v2);
var S4 = class {
  constructor(e4, t3, s2) {
    this.data = e4, this.objectIds = t3, this.byteSize = s2;
  }
};
var T3 = class {
  constructor(e4, t3, s2) {
    this.level = e4, this.row = t3, this.col = s2, this.isLeaf = false, this.extent = null, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (r(this.children[0]) || r(this.children[1]) || r(this.children[2]) || r(this.children[3]));
  }
};
var I = class {
  constructor(e4, t3 = []) {
    this.missingTiles = t3, this.fullArea = 0, this.coveredArea = 0, this.fullArea = y2(e4.extent), this.coveredArea = this.fullArea;
  }
  prepend(e4) {
    this.missingTiles = e4.missingTiles.concat(this.missingTiles), this.coveredArea += e4.coveredArea, this.fullArea += e4.fullArea;
  }
};
var j3 = class {
  constructor(e4, t3, s2) {
    this.tileInfo = e4, this.extent = null, this.info = new I(t3), r(s2) && (this.extent = c(s2));
  }
  addMissing(e4, t3, s2, i2) {
    const r4 = { id: null, level: e4, row: t3, col: s2 };
    this.tileInfo.updateTileInfo(r4, S.ExtrapolateOptions.POWER_OF_TWO), t(r4.extent) || r(this.extent) && !E(this.extent, r4.extent) || (this.info.missingTiles.push({ data: r4, resolution: i2 }), this.info.coveredArea -= y2(r4.extent));
  }
};
var F = 0.18751;
var w3;
!function(e4) {
  e4[e4.ADDED = 0] = "ADDED", e4[e4.REMOVED = 1] = "REMOVED", e4[e4.UNCHANGED = 2] = "UNCHANGED";
}(w3 || (w3 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var I2 = class extends n3.EventedAccessor {
  constructor() {
    super(...arguments), this.isInitializing = true, this.whenSetup = T(), this.handles = new u(), this.updatingHandles = new c2(), this.pendingApplyEdits = /* @__PURE__ */ new Map();
  }
  get updating() {
    return this.featureFetcher.updating || this.isInitializing || this.updatingHandles.updating;
  }
  destroy() {
    this.featureFetcher.destroy(), this.queryEngine.destroy(), this.featureStore.clear(), this.handles.destroy();
  }
  async setup(e4) {
    const { geometryType: t3, objectIdField: i2, timeInfo: r4, fields: s2 } = e4.serviceInfo;
    return this.featureStore = new u3({ ...e4.serviceInfo, hasZ: false, hasM: false }), this.queryEngine = new Y({ spatialReference: e4.spatialReference, featureStore: this.featureStore, geometryType: t3, fields: s2, hasZ: false, hasM: false, objectIdField: i2, timeInfo: r4 ? v.fromJSON(r4) : null }), this.featureFetcher = new C({ store: new v2({ featureStore: this.featureStore }), url: e4.serviceInfo.url, objectIdField: e4.serviceInfo.objectIdField, globalIdField: e4.serviceInfo.globalIdField, capabilities: e4.serviceInfo.capabilities, spatialReference: k.fromJSON(e4.spatialReference), sourceSpatialReference: k.fromJSON(e4.serviceInfo.spatialReference) }), this.handles.add([l(() => this.featureFetcher.availability, (e5) => this.emit("notify-availability", { availability: e5 }), U), l(() => this.updating, () => this._notifyUpdating())]), this.whenSetup.resolve(), this.isInitializing = false, this.configure(e4.configuration);
  }
  async configure(e4) {
    return await this.updatingHandles.addPromise(this.whenSetup.promise), this._updateFeatureFetcherConfiguration(e4), { result: {} };
  }
  async fetchCandidates(e4, t3) {
    await this.whenSetup.promise, f(t3);
    return { result: await this.queryEngine.executeQueryForSnapping({ point: e4.point, distance: e4.distance, types: e4.types, query: r(e4.filter) ? e4.filter : { where: "1=1" } }, r(t3) ? t3.signal : null) };
  }
  async updateTiles(e4, t3) {
    return await this.updatingHandles.addPromise(this.whenSetup.promise), f(t3), this.featureFetcher.tileSize = e4.tileSize, this.featureFetcher.tilesOfInterest = e4.tiles, this.featureFetcher.tileInfo = r(e4.tileInfo) ? S.fromJSON(e4.tileInfo) : null, { result: {} };
  }
  async refresh(e4, t3) {
    return await this.updatingHandles.addPromise(this.whenSetup.promise), f(t3), this.featureFetcher.refresh(), { result: {} };
  }
  async whenNotUpdating(e4, t3) {
    return await this.updatingHandles.addPromise(this.whenSetup.promise), f(t3), await j(() => !this.updating, t3), f(t3), { result: {} };
  }
  async getDebugInfo(e4, t3) {
    return f(t3), { result: this.featureFetcher.debugInfo };
  }
  async beginApplyEdits(e4, t3) {
    this.updatingHandles.addPromise(this.whenSetup.promise), f(t3);
    const i2 = T();
    return this.pendingApplyEdits.set(e4.id, i2), this.featureFetcher.applyEdits(i2.promise), this.updatingHandles.addPromise(i2.promise), { result: {} };
  }
  async endApplyEdits(e4, t3) {
    const i2 = this.pendingApplyEdits.get(e4.id);
    return i2 && i2.resolve(e4.edits), f(t3), { result: {} };
  }
  _updateFeatureFetcherConfiguration(e4) {
    this.featureFetcher.filter = r(e4.filter) ? b.fromJSON(e4.filter) : null, this.featureFetcher.customParameters = e4.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", { updating: this.updating });
  }
};
function w4() {
  return new I2();
}
e([d({ readOnly: true })], I2.prototype, "updating", null), e([d()], I2.prototype, "isInitializing", void 0), I2 = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], I2);
export {
  I2 as FeatureServiceSnappingSourceWorker,
  w4 as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-EDREYCPC.js.map
