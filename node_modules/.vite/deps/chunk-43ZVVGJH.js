import {
  d as d2,
  s as s3
} from "./chunk-7S6G3GM7.js";
import {
  o
} from "./chunk-QJN4GT4E.js";
import {
  w as w2
} from "./chunk-XLCZFN6R.js";
import {
  y
} from "./chunk-OMNBM2E4.js";
import {
  b
} from "./chunk-GSFXXEAM.js";
import {
  g
} from "./chunk-JT3LXQ47.js";
import {
  a,
  l,
  w
} from "./chunk-T7BEWVV3.js";
import {
  A,
  F,
  I,
  N,
  V,
  _,
  de,
  g as g2,
  j,
  y as y2
} from "./chunk-5Z5455ZY.js";
import {
  a as a2
} from "./chunk-D7DLEBS2.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  E,
  r as r2
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var O = s.getLogger("esri.views.layers.FeatureLayerView");
var A2 = (i) => {
  let A3 = class extends i {
    constructor(...e2) {
      super(...e2), this._updatingRequiredFieldsPromise = null, this.filter = null, this.timeExtent = null, this.layer = null, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.handles.add([l(() => {
        var _a;
        const e2 = this.layer;
        return [(_a = e2 == null ? void 0 : e2.elevationInfo) == null ? void 0 : _a.featureExpressionInfo, e2 == null ? void 0 : e2.displayField, e2 == null ? void 0 : e2.timeInfo, e2 && "renderer" in e2 && e2.renderer, e2 && "labelingInfo" in e2 && e2.labelingInfo, e2 && "floorInfo" in e2 && e2.floorInfo, this.filter, this.featureEffect, this.timeExtent];
      }, () => this._handleRequiredFieldsChange(), w), a(() => {
        var _a;
        return (_a = this.view) == null ? void 0 : _a.floors;
      }, "change", () => this._handleRequiredFieldsChange()), a(() => {
        const e2 = this.layer;
        return e2 && "sublayers" in e2 && e2.sublayers;
      }, "change", () => this._handleRequiredFieldsChange())]);
    }
    get availableFields() {
      const { layer: e2, layer: { fieldsIndex: t2 }, requiredFields: r3 } = this;
      return "outFields" in e2 && e2.outFields ? y2(t2, [...I(t2, e2.outFields), ...r3]) : y2(t2, r3);
    }
    set effect(e2) {
      r2(O, "effect", { replacement: "featureEffect", version: "4.22" }), this.featureEffect = e2;
    }
    get effect() {
      return r2(O, "effect", { replacement: "featureEffect", version: "4.22" }), this.featureEffect;
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e2) {
      void 0 !== e2 ? this._override("featureEffect", e2) : this._clearOverride("featureEffect");
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e2) {
      O.error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    highlight(e2) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e2 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t2 = r(this.filter) ? this.filter.createQuery(e2) : new b(e2);
      if ("feature" === this.layer.type) {
        const e3 = o(this);
        r(e3) && (t2.where = t2.where ? `(${t2.where}) AND (${e3})` : e3);
      }
      return r(this.timeExtent) && (t2.timeExtent = r(t2.timeExtent) ? t2.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t2;
    }
    queryFeatures(e2, t2) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e2, t2) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e2, t2) {
      throw new Error("missing implementation");
    }
    queryExtent(e2, t2) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeatures(e2, t2) {
      const r3 = this.validateFetchPopupFeatures(t2);
      if (r3)
        throw r3;
      return this.fetchClientPopupFeatures(t2);
    }
    _loadArcadeModules(e2) {
      if (e2.get("expressionInfos.length") || Array.isArray(e2.content) && e2.content.some((e3) => "expression" === e3.type))
        return a2();
    }
    _handleRequiredFieldsChange() {
      const e2 = this._updateRequiredFields();
      this._set("_updatingRequiredFieldsPromise", e2), e2.then(() => {
        this._updatingRequiredFieldsPromise === e2 && this._set("_updatingRequiredFieldsPromise", null);
      });
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view)
        return;
      const e2 = "3d" === this.view.type, { layer: t2, layer: { fieldsIndex: r3, objectIdField: i2 } } = this, o2 = "renderer" in t2 && t2.renderer, a3 = "orderBy" in t2 && t2.orderBy, l2 = t2.featureReduction, u = /* @__PURE__ */ new Set(), p = await E([o2 ? o2.collectRequiredFields(u, r3) : null, j(u, t2), e2 ? A(u, t2) : null, r(this.filter) ? V(u, t2, this.filter) : null, r(this.featureEffect) ? V(u, t2, this.featureEffect.filter) : null, l2 ? N(u, t2, l2) : null, a3 ? _(u, t2, a3) : null]);
      if (t2.timeInfo && this.timeExtent && g2(u, t2.fieldsIndex, [t2.timeInfo.startField, t2.timeInfo.endField]), "feature" === t2.type && t2.floorInfo && g2(u, t2.fieldsIndex, [t2.floorInfo.floorField]), "subtype-group" === t2.type) {
        F(u, r3, t2.subtypeField);
        const e3 = t2.sublayers.map((e4) => {
          var _a;
          return Promise.all([(_a = e4.renderer) == null ? void 0 : _a.collectRequiredFields(u, r3), j(u, e4)]);
        });
        await E(e3);
      }
      for (const s4 of p)
        s4.error && O.error(s4.error);
      F(u, r3, i2), e2 && "displayField" in t2 && t2.displayField && F(u, r3, t2.displayField);
      const f = Array.from(u).sort();
      this._set("requiredFields", f);
    }
    validateFetchPopupFeatures(e2) {
      if (t(e2))
        return null;
      for (const t2 of e2.clientGraphics) {
        const i2 = t2.layer;
        if ("popupEnabled" in i2 && !i2.popupEnabled)
          return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i2 });
        if (t2.isAggregate) {
          if (!(i2.featureReduction && "popupTemplate" in i2.featureReduction && i2.featureReduction.popupEnabled && i2.featureReduction.popupTemplate))
            return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i2 });
        } else if ("popupTemplate" in i2) {
          if (!s3(i2, e2))
            return new s2("featurelayerview:fetchPopupFeatures", "Layer does not define a popup template", { layer: i2 });
        }
      }
    }
    async fetchClientPopupFeatures(e2) {
      const t2 = r(e2) ? e2.clientGraphics : null;
      if (!t2 || 0 === t2.length)
        return [];
      const r3 = new Array(t2.length), i2 = /* @__PURE__ */ new Map(), n2 = await this.createPopupQuery(e2);
      for (let s4 = 0; s4 < t2.length; s4++) {
        const a3 = t2[s4];
        if (a3.isAggregate) {
          r3[s4] = a3;
          continue;
        }
        const { layer: l2 } = a3;
        if (!("popupEnabled" in l2))
          continue;
        const u = I(this.layer.fieldsIndex, n2.outFields), p = s3(l2, e2);
        if (t(p))
          continue;
        const f = await this._loadArcadeModules(p);
        f && f.arcadeUtils.hasGeometryOperations(p) || !de(u, a3) ? i2.set(a3.getObjectId(), s4) : r3[s4] = a3;
      }
      if ("stream" === this.layer.type || 0 === i2.size)
        return r3.filter(Boolean);
      n2.objectIds = Array.from(i2.keys());
      try {
        const e3 = await this.layer.queryFeatures(n2);
        for (const t3 of e3.features) {
          r3[i2.get(t3.getObjectId())] = t3;
        }
      } catch {
      }
      return r3.filter(Boolean);
    }
    async createPopupQuery(e2) {
      const t2 = this.layer.createQuery(), r3 = /* @__PURE__ */ new Set();
      let i2 = false;
      const n2 = r(e2) && e2.clientGraphics ? e2.clientGraphics.map((e3) => e3.layer) : [this.layer];
      for (const s4 of n2) {
        if (!("popupEnabled" in s4))
          continue;
        const t3 = s3(s4, e2);
        if (t(t3))
          continue;
        const n3 = await this._loadArcadeModules(t3), a3 = n3 && n3.arcadeUtils.hasGeometryOperations(t3);
        i2 = !("point" !== this.layer.geometryType && !a3);
        const l2 = await d2(this.layer, t3);
        for (const e3 of l2)
          r3.add(e3);
      }
      if (t2.returnGeometry = i2, t2.returnZ = i2, t2.returnM = i2, t2.outFields = Array.from(r3), t2.outSpatialReference = this.view.spatialReference, "feature" === this.layer.type) {
        const e3 = o(this);
        r(e3) && (t2.where = t2.where ? `(${t2.where}) AND (${e3})` : e3);
      }
      return t2;
    }
    canResume() {
      return !!super.canResume() && (!r(this.timeExtent) || !this.timeExtent.isEmpty);
    }
  };
  return e([d()], A3.prototype, "_updatingRequiredFieldsPromise", void 0), e([d({ readOnly: true })], A3.prototype, "availableFields", null), e([d()], A3.prototype, "effect", null), e([d({ type: w2 })], A3.prototype, "featureEffect", null), e([d({ type: y })], A3.prototype, "filter", void 0), e([d(g)], A3.prototype, "timeExtent", void 0), e([d()], A3.prototype, "layer", void 0), e([d({ type: Number })], A3.prototype, "maximumNumberOfFeatures", null), e([d({ readOnly: true, type: Boolean })], A3.prototype, "maximumNumberOfFeaturesExceeded", null), e([d({ readOnly: true })], A3.prototype, "requiredFields", void 0), e([d()], A3.prototype, "suspended", void 0), e([d()], A3.prototype, "view", void 0), A3 = e([n("esri.views.layers.FeatureLayerView")], A3), A3;
};

export {
  A2 as A
};
//# sourceMappingURL=chunk-43ZVVGJH.js.map
