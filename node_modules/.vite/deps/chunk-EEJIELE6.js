import {
  E,
  u
} from "./chunk-Y55TYMBP.js";
import {
  t as t2
} from "./chunk-NAB3NF54.js";
import {
  c as c2
} from "./chunk-MDCKEJ7B.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  e as e2
} from "./chunk-NAIF4GWX.js";
import {
  l
} from "./chunk-ZN2MGN4S.js";
import {
  a,
  q,
  w
} from "./chunk-TMBOFNWA.js";
import {
  M,
  o as o2,
  s
} from "./chunk-BPZGJQOB.js";
import {
  _,
  o,
  z
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";
import {
  e3 as e
} from "./chunk-2QOWZFCU.js";
import {
  c2 as c,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObject.js
var r2 = class {
  constructor() {
    this.id = e();
  }
  unload() {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObjectType.js
var e3;
!function(e4) {
  e4[e4.Layer = 0] = "Layer", e4[e4.Object = 1] = "Object", e4[e4.Geometry = 2] = "Geometry", e4[e4.Material = 3] = "Material", e4[e4.Texture = 4] = "Texture", e4[e4.COUNT = 5] = "COUNT";
}(e3 || (e3 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/screenSizePerspectiveUtils.js
function r3(e4, t3) {
  return new p(e4, h, t3);
}
function n2(e4, t3) {
  const { curvatureDependent: a2, scaleStart: i, scaleFallOffRange: r4 } = h;
  return new p(e4, { curvatureDependent: { min: { curvature: a2.min.curvature, tiltAngle: a2.min.tiltAngle, scaleFallOffFactor: v.curvatureDependent.min.scaleFallOffFactor }, max: { curvature: a2.max.curvature, tiltAngle: a2.max.tiltAngle, scaleFallOffFactor: v.curvatureDependent.max.scaleFallOffFactor } }, scaleStart: i, scaleFallOffRange: r4, minPixelSize: v.minPixelSize }, t3);
}
function l2(e4) {
  return Math.abs(e4 * e4 * e4);
}
function s2(e4, t3, a2) {
  const i = a2.parameters, r4 = a2.paddingPixelsOverride;
  return x.scale = Math.min(i.divisor / (t3 - i.offset), 1), x.factor = l2(e4), x.minPixelSize = i.minPixelSize, x.paddingPixels = r4, x;
}
function c3(e4, t3) {
  return 0 === e4 ? t3.minPixelSize : t3.minPixelSize * (1 + 2 * t3.paddingPixels / e4);
}
function o3(t3, a2) {
  return Math.max(s(t3 * a2.scale, t3, a2.factor), c3(t3, a2));
}
function u2(e4, t3, a2) {
  const i = s2(e4, t3, a2);
  return i.minPixelSize = 0, i.paddingPixels = 0, o3(1, i);
}
function d(e4, t3, a2, i) {
  i.scale = u2(e4, t3, a2), i.factor = 0, i.minPixelSize = a2.parameters.minPixelSize, i.paddingPixels = a2.paddingPixelsOverride;
}
function f(e4, t3, a2 = [0, 0]) {
  const i = Math.min(Math.max(t3.scale, c3(e4[1], t3) / Math.max(1e-5, e4[1])), 1);
  return a2[0] = e4[0] * i, a2[1] = e4[1] * i, a2;
}
function m(e4, t3, a2, i) {
  return o3(e4, s2(t3, a2, i));
}
var p = class {
  constructor(e4, t3, a2, r4 = g(), n3) {
    this.viewingMode = e4, this.description = t3, this.ellipsoidRadius = a2, this.parameters = r4, this._paddingPixelsOverride = n3, this.viewingMode === l.Local ? (this.coverageCompensation = this._surfaceCoverageCompensationLocal, this.calculateCurvatureDependentParameters = this._calculateCurvatureDependentParametersLocal) : (this.coverageCompensation = this._surfaceCoverageCompensationGlobal, this.calculateCurvatureDependentParameters = this._calculateCurvatureDependentParametersGlobal);
  }
  get paddingPixelsOverride() {
    return this._paddingPixelsOverride || this.parameters.paddingPixels;
  }
  update(e4) {
    return (!this.parameters || this.parameters.camera.fovY !== e4.fovY || this.parameters.camera.distance !== e4.distance) && (this._calculateParameters(e4, this.ellipsoidRadius, this.parameters), true);
  }
  overridePadding(e4) {
    return e4 !== this.paddingPixelsOverride ? new p(this.viewingMode, this.description, this.ellipsoidRadius, this.parameters, e4) : this;
  }
  _calculateParameters(e4, t3, a2) {
    const { scaleStart: i, scaleFallOffRange: r4, minPixelSize: n3 } = this.description, { fovY: l3, distance: s3 } = e4, c4 = this.calculateCurvatureDependentParameters(e4, t3), o5 = this.coverageCompensation(e4, t3, c4), { tiltAngle: u3, scaleFallOffFactor: d3 } = c4, f2 = Math.sin(u3) * s3, m2 = 0.5 * Math.PI - u3 - l3 * (0.5 - i * o5), p2 = f2 / Math.cos(m2), h3 = m2 + l3 * r4 * o5, v3 = (p2 - d3 * (f2 / Math.cos(h3))) / (1 - d3);
    return a2.camera.fovY = e4.fovY, a2.camera.distance = e4.distance, a2.offset = v3, a2.divisor = p2 - v3, a2.minPixelSize = n3, a2;
  }
  _calculateCurvatureDependentParametersLocal(e4, t3, a2 = P) {
    return a2.tiltAngle = this.description.curvatureDependent.min.tiltAngle, a2.scaleFallOffFactor = this.description.curvatureDependent.min.scaleFallOffFactor, a2;
  }
  _calculateCurvatureDependentParametersGlobal(t3, i, r4 = P) {
    const n3 = this.description.curvatureDependent, l3 = 1 + t3.distance / i, s3 = Math.sqrt(l3 * l3 - 1), [c4, o5] = [n3.min.curvature, n3.max.curvature], u3 = o2((s3 - c4) / (o5 - c4), 0, 1), [d3, f2] = [n3.min, n3.max];
    return r4.tiltAngle = s(d3.tiltAngle, f2.tiltAngle, u3), r4.scaleFallOffFactor = s(d3.scaleFallOffFactor, f2.scaleFallOffFactor, u3), r4;
  }
  _surfaceCoverageCompensationLocal(e4, t3, a2) {
    return (e4.fovY - a2.tiltAngle) / e4.fovY;
  }
  _surfaceCoverageCompensationGlobal(e4, t3, a2) {
    const i = t3 * t3, r4 = a2.tiltAngle + 0.5 * Math.PI, { fovY: n3, distance: l3 } = e4, s3 = l3 * l3 + i - 2 * Math.cos(r4) * l3 * t3, c4 = Math.sqrt(s3), o5 = Math.sqrt(s3 - i);
    return (Math.acos(o5 / c4) - Math.asin(t3 / (c4 / Math.sin(r4))) + 0.5 * n3) / n3;
  }
};
var h = { curvatureDependent: { min: { curvature: M(10), tiltAngle: M(12), scaleFallOffFactor: 0.5 }, max: { curvature: M(70), tiltAngle: M(40), scaleFallOffFactor: 0.8 } }, scaleStart: 0.3, scaleFallOffRange: 0.65, minPixelSize: 0 };
var v = { curvatureDependent: { min: { scaleFallOffFactor: 0.7 }, max: { scaleFallOffFactor: 0.95 } }, minPixelSize: 14 };
function g() {
  return { camera: { distance: 0, fovY: 0 }, divisor: 0, offset: 0, minPixelSize: 0, paddingPixels: 0 };
}
var x = { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 };
var P = { tiltAngle: 0, scaleFallOffFactor: 0 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/MaterialUtil.js
var g2 = a();
function x2(t3, n3, e4, o5, i, r4, s3) {
  if (!u(n3))
    if (t3.boundingInfo) {
      e2(t3.primitiveType === c2.Triangle);
      const n4 = e4.tolerance;
      M2(t3.boundingInfo, o5, i, n4, r4, s3);
    } else {
      const n4 = t3.indices.get(O.POSITION), e5 = t3.vertexAttributes.get(O.POSITION);
      v2(o5, i, 0, n4.length / 3, n4, e5, void 0, r4, s3);
    }
}
var b = n();
function M2(t3, n3, i, r4, s3, c4) {
  if (t(t3))
    return;
  const f2 = N(n3, i, b);
  if (q(g2, t3.getBBMin()), w(g2, t3.getBBMax()), r(s3) && s3.applyToAabb(g2), O2(g2, n3, f2, r4)) {
    const { primitiveIndices: e4, indices: o5, position: f3 } = t3, a2 = e4 ? e4.length : o5.length / 3;
    if (a2 > W) {
      const e5 = t3.getChildren();
      if (void 0 !== e5) {
        for (let t4 = 0; t4 < 8; ++t4)
          void 0 !== e5[t4] && M2(e5[t4], n3, i, r4, s3, c4);
        return;
      }
    }
    v2(n3, i, 0, a2, o5, f3, e4, s3, c4);
  }
}
var y = n();
function v2(t3, n3, e4, i, r4, s3, c4, f2, a2) {
  if (c4)
    return I(t3, n3, e4, i, r4, s3, c4, f2, a2);
  const l3 = s3.data, u3 = s3.stride || s3.size, m2 = t3[0], p2 = t3[1], h3 = t3[2], d3 = n3[0] - m2, g3 = n3[1] - p2, x3 = n3[2] - h3;
  for (let b2 = e4, M3 = 3 * e4; b2 < i; ++b2) {
    let t4 = u3 * r4[M3++], n4 = l3[t4++], e5 = l3[t4++], i2 = l3[t4];
    t4 = u3 * r4[M3++];
    let s4 = l3[t4++], c5 = l3[t4++], v3 = l3[t4];
    t4 = u3 * r4[M3++];
    let I2 = l3[t4++], T2 = l3[t4++], j2 = l3[t4];
    r(f2) && ([n4, e5, i2] = f2.applyToVertex(n4, e5, i2, b2), [s4, c5, v3] = f2.applyToVertex(s4, c5, v3, b2), [I2, T2, j2] = f2.applyToVertex(I2, T2, j2, b2));
    const N2 = s4 - n4, O3 = c5 - e5, V2 = v3 - i2, L2 = I2 - n4, S2 = T2 - e5, B2 = j2 - i2, E3 = g3 * B2 - S2 * x3, P3 = x3 * L2 - B2 * d3, U2 = d3 * S2 - L2 * g3, W2 = N2 * E3 + O3 * P3 + V2 * U2;
    if (Math.abs(W2) <= Number.EPSILON)
      continue;
    const z2 = m2 - n4, k = p2 - e5, R = h3 - i2, C = z2 * E3 + k * P3 + R * U2;
    if (W2 > 0) {
      if (C < 0 || C > W2)
        continue;
    } else if (C > 0 || C < W2)
      continue;
    const H = k * V2 - O3 * R, X = R * N2 - V2 * z2, Y = z2 * O3 - N2 * k, Z = d3 * H + g3 * X + x3 * Y;
    if (W2 > 0) {
      if (Z < 0 || C + Z > W2)
        continue;
    } else if (Z > 0 || C + Z < W2)
      continue;
    const _2 = (L2 * H + S2 * X + B2 * Y) / W2;
    if (_2 >= 0) {
      a2(_2, A(N2, O3, V2, L2, S2, B2, y), b2, false);
    }
  }
}
function I(t3, n3, e4, i, r4, s3, c4, f2, a2) {
  const l3 = s3.data, u3 = s3.stride || s3.size, m2 = t3[0], p2 = t3[1], h3 = t3[2], d3 = n3[0] - m2, g3 = n3[1] - p2, x3 = n3[2] - h3;
  for (let b2 = e4; b2 < i; ++b2) {
    const t4 = c4[b2];
    let n4 = 3 * t4, e5 = u3 * r4[n4++], i2 = l3[e5++], s4 = l3[e5++], M3 = l3[e5];
    e5 = u3 * r4[n4++];
    let v3 = l3[e5++], I2 = l3[e5++], T2 = l3[e5];
    e5 = u3 * r4[n4];
    let j2 = l3[e5++], N2 = l3[e5++], O3 = l3[e5];
    r(f2) && ([i2, s4, M3] = f2.applyToVertex(i2, s4, M3, b2), [v3, I2, T2] = f2.applyToVertex(v3, I2, T2, b2), [j2, N2, O3] = f2.applyToVertex(j2, N2, O3, b2));
    const V2 = v3 - i2, L2 = I2 - s4, S2 = T2 - M3, B2 = j2 - i2, E3 = N2 - s4, P3 = O3 - M3, U2 = g3 * P3 - E3 * x3, W2 = x3 * B2 - P3 * d3, z2 = d3 * E3 - B2 * g3, k = V2 * U2 + L2 * W2 + S2 * z2;
    if (Math.abs(k) <= Number.EPSILON)
      continue;
    const R = m2 - i2, C = p2 - s4, H = h3 - M3, X = R * U2 + C * W2 + H * z2;
    if (k > 0) {
      if (X < 0 || X > k)
        continue;
    } else if (X > 0 || X < k)
      continue;
    const Y = C * S2 - L2 * H, Z = H * V2 - S2 * R, _2 = R * L2 - V2 * C, q2 = d3 * Y + g3 * Z + x3 * _2;
    if (k > 0) {
      if (q2 < 0 || X + q2 > k)
        continue;
    } else if (q2 > 0 || X + q2 < k)
      continue;
    const w2 = (B2 * Y + E3 * Z + P3 * _2) / k;
    if (w2 >= 0) {
      a2(w2, A(V2, L2, S2, B2, E3, P3, y), t4, false);
    }
  }
}
var T = n();
var j = n();
function A(t3, n3, e4, o5, c4, f2, a2) {
  return o(T, t3, n3, e4), o(j, o5, c4, f2), _(a2, T, j), z(a2, a2), a2;
}
function N(t3, n3, e4) {
  return o(e4, 1 / (n3[0] - t3[0]), 1 / (n3[1] - t3[1]), 1 / (n3[2] - t3[2]));
}
function O2(t3, n3, e4, o5) {
  return V(t3, n3, e4, o5, 1 / 0);
}
function V(t3, n3, e4, o5, i) {
  const r4 = (t3[0] - o5 - n3[0]) * e4[0], s3 = (t3[3] + o5 - n3[0]) * e4[0];
  let c4 = Math.min(r4, s3), f2 = Math.max(r4, s3);
  const a2 = (t3[1] - o5 - n3[1]) * e4[1], l3 = (t3[4] + o5 - n3[1]) * e4[1];
  if (f2 = Math.min(f2, Math.max(a2, l3)), f2 < 0)
    return false;
  if (c4 = Math.max(c4, Math.min(a2, l3)), c4 > f2)
    return false;
  const u3 = (t3[2] - o5 - n3[2]) * e4[2], m2 = (t3[5] + o5 - n3[2]) * e4[2];
  return f2 = Math.min(f2, Math.max(u3, m2)), !(f2 < 0) && (c4 = Math.max(c4, Math.min(u3, m2)), !(c4 > f2) && c4 < i);
}
function L(t3, e4, i, r4, s3) {
  let c4 = (i.screenLength || 0) * t3.pixelRatio;
  r(s3) && (c4 = m(c4, r4, e4, s3));
  const f2 = c4 * Math.tan(0.5 * t3.fovY) / (0.5 * t3.fullHeight);
  return o2(f2 * e4, i.minWorldLength || 0, null != i.maxWorldLength ? i.maxWorldLength : 1 / 0);
}
function S(t3, n3) {
  const e4 = n3 ? S(n3) : {};
  for (const o5 in t3) {
    let n4 = t3[o5];
    n4 && n4.forEach && (n4 = P2(n4)), null == n4 && o5 in e4 || (e4[o5] = n4);
  }
  return e4;
}
function B(n3, e4) {
  let o5 = false;
  for (const i in e4) {
    const r4 = e4[i];
    void 0 !== r4 && (Array.isArray(r4) ? null === n3[i] ? (n3[i] = r4.slice(), o5 = true) : c(n3[i], r4) && (o5 = true) : n3[i] !== r4 && (o5 = true, n3[i] = r4));
  }
  return o5;
}
function E2(t3, e4, o5, i, r4, s3) {
  if (!e4.options.selectionMode)
    return;
  const c4 = t3.vertexAttributes.get(O.POSITION).data, f2 = t3.vertexAttributes.get(O.SIZE), a2 = f2 && f2.data[0], l3 = i[0], u3 = i[1], m2 = ((a2 + r4) / 2 + 4) * t3.screenToWorldRatio;
  let p2 = Number.MAX_VALUE, d3 = 0;
  for (let h3 = 0; h3 < c4.length - 5; h3 += 3) {
    const t4 = c4[h3], e5 = c4[h3 + 1], o6 = l3 - t4, i2 = u3 - e5, r5 = c4[h3 + 3] - t4, s4 = c4[h3 + 4] - e5, f3 = o2((r5 * o6 + s4 * i2) / (r5 * r5 + s4 * s4), 0, 1), a3 = r5 * f3 - o6, m3 = s4 * f3 - i2, g3 = a3 * a3 + m3 * m3;
    g3 < p2 && (p2 = g3, d3 = h3 / 3);
  }
  p2 < m2 * m2 && s3(o5.dist, o5.normal, d3, false);
}
function P2(t3) {
  const n3 = [];
  return t3.forEach((t4) => n3.push(t4)), n3;
}
var U = { multiply: 1, ignore: 2, replace: 3, tint: 4 };
var W = 1e3;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Material.js
var d2 = class extends r2 {
  constructor(e4, r4) {
    super(), this.type = e3.Material, this.supportsEdges = false, this._visible = true, this._renderPriority = 0, this._insertOrder = 0, this._vertexAttributeLocations = E, this._parameters = S(e4, r4), this.validateParameters(this._parameters);
  }
  dispose() {
  }
  get parameters() {
    return this._parameters;
  }
  update(e4) {
    return false;
  }
  setParameters(e4, r4 = true) {
    B(this._parameters, e4) && (this.validateParameters(this._parameters), r4 && this.parametersChanged());
  }
  validateParameters(e4) {
  }
  get visible() {
    return this._visible;
  }
  set visible(e4) {
    e4 !== this._visible && (this._visible = e4, this.parametersChanged());
  }
  shouldRender(e4) {
    return this.isVisible() && this.isVisibleInPass(e4.pass) && 0 != (this.renderOccluded & e4.renderOccludedMask);
  }
  isVisibleInPass(e4) {
    return true;
  }
  get renderOccluded() {
    return this.parameters.renderOccluded;
  }
  get renderPriority() {
    return this._renderPriority;
  }
  set renderPriority(e4) {
    e4 !== this._renderPriority && (this._renderPriority = e4, this.parametersChanged());
  }
  get insertOrder() {
    return this._insertOrder;
  }
  set insertOrder(e4) {
    e4 !== this._insertOrder && (this._insertOrder = e4, this.parametersChanged());
  }
  get vertexAttributeLocations() {
    return this._vertexAttributeLocations;
  }
  isVisible() {
    return this._visible;
  }
  parametersChanged() {
    r(this.repository) && this.repository.materialChanged(this);
  }
};
var h2;
!function(e4) {
  e4[e4.Occlude = 1] = "Occlude", e4[e4.Transparent = 2] = "Transparent", e4[e4.OccludeAndTransparent = 4] = "OccludeAndTransparent", e4[e4.OccludeAndTransparentStencil = 8] = "OccludeAndTransparentStencil", e4[e4.Opaque = 16] = "Opaque";
}(h2 || (h2 = {}));
var o4 = class extends t2 {
  constructor() {
    super(...arguments), this.renderOccluded = h2.Occlude;
  }
};

export {
  r2 as r,
  e3 as e,
  r3 as r2,
  n2 as n,
  o3 as o,
  d,
  f,
  x2 as x,
  v2 as v,
  A,
  N,
  O2 as O,
  V,
  L,
  S,
  B,
  E2 as E,
  U,
  d2,
  h2 as h,
  o4 as o2
};
//# sourceMappingURL=chunk-EEJIELE6.js.map
