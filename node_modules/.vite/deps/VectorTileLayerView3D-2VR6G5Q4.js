import {
  c,
  i as i2,
  l as l3,
  r as r2
} from "./chunk-YEGLNVAS.js";
import {
  c as c2
} from "./chunk-CULPK55Q.js";
import {
  n as n2
} from "./chunk-WLVMYWO2.js";
import {
  o
} from "./chunk-446VAMJ3.js";
import "./chunk-56CVOKCW.js";
import {
  u as u2
} from "./chunk-6UGZAJSY.js";
import {
  y
} from "./chunk-JWKDNFWF.js";
import "./chunk-KXE4LGFJ.js";
import "./chunk-SASFTPK5.js";
import "./chunk-436X6OVY.js";
import "./chunk-UJS24K6P.js";
import "./chunk-RB2H3SKO.js";
import "./chunk-UKBGUXUQ.js";
import "./chunk-AKNCAMEF.js";
import "./chunk-UGLXR5OV.js";
import "./chunk-RGZ7VIMW.js";
import "./chunk-6FQZDXGD.js";
import {
  l as l2
} from "./chunk-57NDR3D3.js";
import {
  a,
  i
} from "./chunk-PNNMRFHO.js";
import "./chunk-4V2P7IXX.js";
import "./chunk-SF7Z6XNR.js";
import "./chunk-YRAX326I.js";
import "./chunk-HH3D3A65.js";
import "./chunk-YDPQRKY4.js";
import "./chunk-CMKLTW5X.js";
import {
  a as a2,
  m,
  s as s4
} from "./chunk-5CPRHNFX.js";
import "./chunk-LAHCYKZK.js";
import "./chunk-567AWHAB.js";
import "./chunk-TZD2AXJG.js";
import "./chunk-FZCDFXBT.js";
import "./chunk-KD6KBT2L.js";
import "./chunk-RVR2DEVB.js";
import "./chunk-AS3OSZXK.js";
import "./chunk-IYLBVJ6T.js";
import "./chunk-YXFNNKMT.js";
import "./chunk-YSQDB5AA.js";
import "./chunk-Z7AZMEL6.js";
import "./chunk-FUKESVWQ.js";
import "./chunk-T3KDRLPE.js";
import "./chunk-EJ7RFMRW.js";
import "./chunk-VQLKKADV.js";
import "./chunk-33INAWJA.js";
import {
  I,
  R
} from "./chunk-FPMD6IB4.js";
import {
  M,
  V
} from "./chunk-4CRT3CQZ.js";
import "./chunk-EJ4V43KX.js";
import "./chunk-PLLZPG4O.js";
import "./chunk-NAIF4GWX.js";
import "./chunk-2EPPX4WN.js";
import {
  t as t2
} from "./chunk-MEW2XKT2.js";
import "./chunk-RB3LJE4I.js";
import "./chunk-MV2XZ5BA.js";
import {
  e as e2
} from "./chunk-PQO66WZ2.js";
import "./chunk-3NPGGTI6.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-4P4OV7G6.js";
import "./chunk-ZUDEVIXR.js";
import "./chunk-IG4CY4XM.js";
import "./chunk-HB4HVKJV.js";
import "./chunk-ZN2MGN4S.js";
import "./chunk-JZY7CGEI.js";
import "./chunk-2LGANX7J.js";
import "./chunk-RTHP2LNT.js";
import "./chunk-ZZY5IDKU.js";
import "./chunk-PZWU5EHT.js";
import "./chunk-CQSGZXR7.js";
import "./chunk-JJ7VMWJT.js";
import "./chunk-M2WA2LMI.js";
import "./chunk-UQDLDM54.js";
import "./chunk-YL26MZEL.js";
import "./chunk-YG6VFATO.js";
import "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import "./chunk-HR2OX32D.js";
import "./chunk-6GPADSSO.js";
import {
  s as s3
} from "./chunk-F5A4XAOJ.js";
import "./chunk-4TDLPK3D.js";
import "./chunk-U7B2WKBH.js";
import "./chunk-JJRJ6TV3.js";
import "./chunk-K2FQEYBG.js";
import "./chunk-G4IZ2HTT.js";
import {
  j
} from "./chunk-T7BEWVV3.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-P6G64ARX.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import {
  u
} from "./chunk-56RHM4A6.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-FTLBKDGL.js";
import "./chunk-H7JF6Q7A.js";
import "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-NWRK6QLX.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  f,
  p
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  l,
  r,
  s,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SchemaHelper.js
var e3 = class {
  constructor(e4, i3) {
    this.lockedSchemaPixelSize = e4, this.isGCS = i3;
  }
  getLevelRowColumn(e4) {
    return this.isGCS ? [e4[0], e4[1] >> 1, e4[2] >> 1] : 256 === this.lockedSchemaPixelSize && e4[0] > 0 ? [e4[0] - 1, e4[1] >> 1, e4[2] >> 1] : e4;
  }
  adjustLevel(e4) {
    return this.isGCS ? e4 : 256 === this.lockedSchemaPixelSize ? e4 > 0 ? e4 - 1 : 0 : e4;
  }
  getShift(e4, i3) {
    let t3 = 0, s5 = 0;
    return (256 === this.lockedSchemaPixelSize || this.isGCS) && (e4[2] % 2 && (t3 = i3), e4[1] % 2 && (s5 = i3)), [t3, s5];
  }
  getScale(e4) {
    if (this.isGCS) {
      if (512 === this.lockedSchemaPixelSize)
        return 4;
    } else if (256 === this.lockedSchemaPixelSize && 0 === e4)
      return 1;
    return 2;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobsUtil.js
function p2(p3, y2) {
  const a3 = [], m2 = new r2(4096, a3, () => {
    const e4 = new s4();
    return e4.show = false, e4.parts.push({ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }), e4.parts.push({ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }), e4;
  }), n3 = new i2(a3, m2, (t3, r3, o3) => new l3(t3, r3, o3, p3.styleRepository, p3.key.level, 0), (t3, e4) => {
    a2(t3, e4, false);
  }, () => 0, (t3) => {
    const e4 = y2.getStyleLayerByUID(t3).getLayoutProperty("visibility");
    return !e4 || e4.getValue() !== i.NONE;
  });
  a3.push(p3), m2.add(p3), n3.setScreenSize(512, 512), n3.continue(1 / 0);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler3D.js
var g = class extends c {
  constructor(e4, t3, o3, s5, i3) {
    super(e4, t3, o3), this._memCache = s5, this._loader = i3, this._ongoingTileRequests = /* @__PURE__ */ new Map(), this._ongoingRequestToController = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._ongoingRequestToController.forEach((e4) => e4.abort()), this._ongoingRequestToController.clear(), this._ongoingTileRequests.clear();
  }
  async getVectorTile(r3, g2, h, m2) {
    const u3 = new e2(r3, g2, h, 0);
    let c3 = this._memCache.get(u3.id);
    if (r(c3))
      return c3.retain(), c3;
    const _ = await this._getVectorTileData(u3);
    if (f(m2), !this._layer)
      return null;
    if (c3 = this._memCache.get(u3.id), r(c3))
      return c3.retain(), c3;
    const T = this._layer.tileInfo.getTileBounds(u(), u3);
    return c3 = new m(u3, T[0], T[3], 512, 512, this._styleRepository, this._memCache), r(_) ? (c3.setData(_), c3.retain(), this._memCache.put(u3.id, c3, c3.memoryUsage * c3.referenced, s3)) : c3.setData(null), c3.neededForCoverage = true, c3.transforms.tileUnitsToPixels = t2(1 / 8, 0, 0, 0, 1 / 8, 0, 0, 0, 1), p2(c3, this._styleRepository), c3;
  }
  _getVectorTileData(e4) {
    const t3 = e4.id;
    if (this._ongoingTileRequests.has(t3))
      return this._ongoingTileRequests.get(t3);
    const o3 = new AbortController(), s5 = { signal: o3.signal }, i3 = this._getParsedVectorTileData(e4, s5).then((e5) => (this._ongoingTileRequests.delete(t3), this._ongoingRequestToController.delete(t3), e5)).catch(() => (this._ongoingTileRequests.delete(t3), this._ongoingRequestToController.delete(t3), null));
    return this._ongoingTileRequests.set(t3, i3), this._ongoingRequestToController.set(t3, o3), i3;
  }
  _getParsedVectorTileData(e4, t3) {
    return this.fetchTileData(e4, t3).then((o3) => this.parseTileData({ key: e4, data: o3 }, t3));
  }
  request(e4, t3) {
    return this._loader.request(e4, "binary", t3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VTLPainter3D.js
var l4 = 1e-6;
var o2 = class {
  constructor(e4, t3) {
    this.spriteMosaic = e4, this.glyphMosaic = t3, this._brushCache = /* @__PURE__ */ new Map(), this._vtlMaterialManager = new o();
  }
  dispose() {
    this._brushCache && (this._brushCache.forEach((e4) => e4.dispose()), this._brushCache = null), this._vtlMaterialManager = s(this._vtlMaterialManager), this.spriteMosaic.dispose(), this.glyphMosaic.dispose();
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  drawTile(e4, t3, r3) {
    const { context: s5 } = e4, a3 = r3.layers;
    r3.backgroundBucketIds.length > 0 && (e4.renderPass = "background", r3.backgroundBucketIds.forEach((s6) => this._renderStyleLayer(r3.getLayerById(s6), e4, t3, true))), s5.setBlendingEnabled(false), s5.setDepthTestEnabled(true), s5.setDepthWriteEnabled(true), s5.setDepthFunction(I.LEQUAL), e4.renderPass = "opaque";
    for (let i3 = a3.length - 1; i3 >= 0; i3--)
      this._renderStyleLayer(a3[i3], e4, t3, false);
    s5.setDepthWriteEnabled(false), s5.setBlendingEnabled(true), s5.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e4.renderPass = "translucent";
    for (let i3 = 0; i3 < a3.length; i3++)
      this._renderStyleLayer(a3[i3], e4, t3, false);
    s5.setDepthTestEnabled(false), e4.renderPass = "symbol";
    for (let i3 = 0; i3 < a3.length; i3++)
      this._renderStyleLayer(a3[i3], e4, t3, false);
    s5.bindVAO();
  }
  _renderStyleLayer(e4, t3, r3, i3 = false) {
    if (!(i3 || e4 && r3.layerData.has(e4.uid)))
      return;
    const n3 = e4.getLayoutProperty("visibility");
    if (n3 && n3.getValue() === i.NONE)
      return;
    const { renderPass: o3 } = t3;
    let h;
    switch (e4.type) {
      case a.BACKGROUND:
        if ("background" !== o3)
          return;
        h = "vtlBackground";
        break;
      case a.FILL:
        if ("opaque" !== o3 && "translucent" !== t3.renderPass)
          return;
        h = "vtlFill";
        break;
      case a.LINE:
        if ("translucent" !== o3)
          return;
        h = "vtlLine";
        break;
      case a.CIRCLE:
        if ("symbol" !== o3)
          return;
        h = "vtlCircle";
        break;
      case a.SYMBOL:
        if ("symbol" !== o3)
          return;
        h = "vtlSymbol";
    }
    const c3 = t3.displayLevel;
    void 0 !== e4.minzoom && e4.minzoom > c3 + l4 || void 0 !== e4.maxzoom && e4.maxzoom <= c3 - l4 || (t3.styleLayerUID = e4.uid, t3.styleLayer = e4, this._drawWithBrush(t3, r3, h));
  }
  _drawWithBrush(e4, r3, s5) {
    if (!this._brushCache.has(s5)) {
      const e5 = y[s5];
      this._brushCache.set(s5, new e5());
    }
    this._brushCache.get(s5).drawMany(e4, [r3]);
  }
};

// node_modules/@arcgis/core/views/3d/layers/VectorTileLayerView3D.js
var C = class extends c2(n2(u2)) {
  constructor() {
    super(...arguments), this.type = "vector-tile-3d";
  }
  initialize() {
    if (t(this.layer.fullExtent))
      return void this.addResolvingPromise(Promise.reject(new s2("vectortilelayerview:full-extent-undefined", "This layer view's layer does not define a fullExtent.")));
    const { basemapTerrain: e4, spatialReference: l5, state: s5, viewingMode: n3 } = this.view, { pixelRatio: h } = s5, y2 = "local" === n3 && !M(l5) || V.force512VTL, f2 = this.layer.tileInfo.spatialReference.isGeographic, _ = y2 ? this.layer.tileInfo : this.layer.tileInfo.getOrCreateCompatible(256, f2 ? 1 : 2), C2 = this._getTileInfoSupportError(_, this.layer.fullExtent);
    if (r(C2))
      return this.addResolvingPromise(Promise.reject(C2));
    const v2 = j(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.tilingSchemeLocked;
    }).then(() => {
      const t3 = e4.tilingScheme, i3 = t3.pixelSize;
      let r3;
      if (this.schemaHelper = new e3(i3, e4.spatialReference.isGeographic), 256 === i3) {
        const e5 = this.layer.tileInfo.spatialReference.isGeographic;
        r3 = this.layer.tileInfo.getOrCreateCompatible(256, e5 ? 1 : 2);
      } else
        r3 = this.view.spatialReference.isGeographic ? this.layer.tileInfo.getOrCreateCompatible(512, 0.5) : this.layer.tileInfo;
      const l6 = this._getTileInfoCompatibilityError(r3, t3);
      if (l6)
        throw l6;
      this.tileInfo = r3;
    });
    this._tileHandlerController = new AbortController();
    const w = this.view.resourceController;
    this._memCache = w.memoryController.newCache(this.layer.uid, (e5) => {
      e5.release();
    });
    const H = new l2(this.layer.currentStyleInfo.style), j2 = e4.mapTileRequester;
    this._tileHandler = new g(this.layer, H, h, this._memCache, j2);
    const T = this._tileHandlerController.signal, R2 = (e5) => w.schedule(e5), I2 = this._tileHandler.start({ signal: T, schedule: R2 }), b = this._tileHandler.spriteMosaic;
    b.then((e5) => {
      !p(T) && this._tileHandler && (this.painter = new o2(e5, this._tileHandler.glyphMosaic));
    }), I2.then(() => this._tileHandlerController = null), this.updatingHandles.add(() => {
      var _a;
      return { style: this.layer.currentStyleInfo.style, newPixelRatio: (_a = this.view.state) == null ? void 0 : _a.pixelRatio };
    }, ({ style: e5 }) => {
      this._tileHandlerController && this._tileHandlerController.abort(), this._tileHandlerController = new AbortController(), this._memCache.clear();
      const t3 = new l2(e5), i3 = new g(this.layer, t3, h, this._memCache, j2), r3 = i3.start({ signal: this._tileHandlerController.signal, schedule: R2 }), l6 = i3.spriteMosaic;
      r3.then(() => this._tileHandlerController = null), this.updatingHandles.addPromise(Promise.all([r3, l6]).then(([, e6]) => {
        const t4 = this._tileHandler, r4 = this.painter;
        this.painter = new o2(e6, i3.glyphMosaic), this._tileHandler = i3, this.emit("data-changed"), t4.destroy(), r4 && r4.dispose();
      }));
    });
    const S = Promise.all([v2, I2, b]);
    this.addResolvingPromise(S);
  }
  destroy() {
    this.painter = s(this.painter), this._tileHandlerController && (this._tileHandlerController.abort(), this._tileHandlerController = null), l(this._tileHandler), this._memCache = l(this._memCache), this._tileHandler = null;
  }
  get dataLevelRange() {
    const e4 = this.tileInfo.lods, t3 = e4[0].scale, i3 = e4[e4.length - 1].scale, r3 = this.levelRangeFromScaleRange(t3, i3);
    return 1 === r3.minLevel && 256 === this.tileInfo.size[0] && (r3.minLevel = 0), r3;
  }
  async fetchTile(e4, t3, i3, r3) {
    return this._tileHandler.getVectorTile(e4, t3, i3, r3);
  }
};
e([d()], C.prototype, "layer", void 0), e([d()], C.prototype, "dataLevelRange", null), e([d()], C.prototype, "updatingProgressValue", void 0), C = e([n("esri.views.3d.layers.VectorTileLayerView3D")], C);
var v = C;
export {
  v as default
};
//# sourceMappingURL=VectorTileLayerView3D-2VR6G5Q4.js.map
