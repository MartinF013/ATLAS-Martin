import {
  W
} from "./chunk-JWKDNFWF.js";
import {
  s as s3
} from "./chunk-ATJYWC6C.js";
import {
  w
} from "./chunk-RGZ7VIMW.js";
import {
  I
} from "./chunk-6FQZDXGD.js";
import {
  a
} from "./chunk-RVR2DEVB.js";
import {
  f
} from "./chunk-FUKESVWQ.js";
import {
  c
} from "./chunk-T3KDRLPE.js";
import {
  C,
  E,
  F
} from "./chunk-FPMD6IB4.js";
import {
  x
} from "./chunk-RIOXX6J2.js";
import {
  e
} from "./chunk-MEW2XKT2.js";
import {
  r as r2
} from "./chunk-YZNDHJDJ.js";
import {
  n
} from "./chunk-RTHP2LNT.js";
import {
  D,
  H
} from "./chunk-6SWQ7R36.js";
import {
  t as t2
} from "./chunk-OZT6RDST.js";
import {
  l
} from "./chunk-T7BEWVV3.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/Mesh2D.js
var x2 = s.getLogger("esri.views.2d.engine.webgl.Mesh2D");
var g = (t3) => {
  switch (t3.BYTES_PER_ELEMENT) {
    case 1:
      return C.UNSIGNED_BYTE;
    case 2:
      return C.UNSIGNED_SHORT;
    case 4:
      return C.UNSIGNED_INT;
    default:
      throw new s2("Cannot get DataType of array");
  }
};
var p = (e2, t3, r3, o) => {
  let s4 = 0;
  for (let n3 = 1; n3 < r3; n3++) {
    const r4 = e2[2 * (t3 + n3 - 1)], o2 = e2[2 * (t3 + n3 - 1) + 1];
    s4 += (e2[2 * (t3 + n3)] - r4) * (e2[2 * (t3 + n3) + 1] + o2);
  }
  return o ? s4 > 0 : s4 < 0;
};
var l2 = ({ coords: e2, lengths: t3 }, r3) => {
  const s4 = [];
  for (let n3 = 0, i = 0; n3 < t3.length; i += t3[n3], n3 += 1) {
    const c2 = i, a3 = [];
    for (; n3 < t3.length - 1 && p(e2, i + t3[n3], t3[n3 + 1], r3); n3 += 1, i += t3[n3])
      a3.push(i + t3[n3] - c2);
    const f2 = e2.slice(2 * c2, 2 * (i + t3[n3])), h = x(f2, a3, 2);
    for (const e3 of h)
      s4.push(e3 + c2);
  }
  return s4;
};
var w2 = class {
  constructor(e2, t3, r3, o = false) {
    this._cache = {}, this.vertices = e2, this.indices = t3, this.primitiveType = r3, this.isMapSpace = o;
  }
  static fromRect({ x: e2, y: t3, width: r3, height: o }) {
    const s4 = e2, n3 = t3, i = s4 + r3, c2 = n3 + o;
    return w2.fromScreenExtent({ xmin: s4, ymin: n3, xmax: i, ymax: c2 });
  }
  static fromPath(e2) {
    const t3 = H(new t2(), e2.path, false, false), r3 = t3.coords, o = new Uint32Array(l2(t3, true)), s4 = new Uint32Array(r3.length / 2);
    for (let n3 = 0; n3 < s4.length; n3++)
      s4[n3] = w(Math.floor(r3[2 * n3]), Math.floor(r3[2 * n3 + 1]));
    return new w2({ geometry: s4 }, o, E.TRIANGLES);
  }
  static fromGeometry(t3, r3) {
    const o = r3.geometry.type;
    switch (o) {
      case "polygon":
        return w2.fromPolygon(t3, r3.geometry);
      case "extent":
        return w2.fromMapExtent(t3, r3.geometry);
      default:
        return x2.error(new s2("mapview-bad-type", `Unable to create a mesh from type ${o}`, r3)), w2.fromRect({ x: 0, y: 0, width: 1, height: 1 });
    }
  }
  static fromPolygon(e2, t3) {
    const r3 = D(new t2(), t3, false, false), o = r3.coords, i = new Uint32Array(l2(r3, false)), h = new Uint32Array(o.length / 2), u = n(), y = n();
    for (let n3 = 0; n3 < h.length; n3++)
      r2(u, o[2 * n3], o[2 * n3 + 1]), e2.toScreen(y, u), h[n3] = w(Math.floor(y[0]), Math.floor(y[1]));
    return new w2({ geometry: h }, i, E.TRIANGLES, true);
  }
  static fromScreenExtent({ xmin: e2, xmax: t3, ymin: r3, ymax: o }) {
    const s4 = { geometry: new Uint32Array([w(e2, r3), w(t3, r3), w(e2, o), w(e2, o), w(t3, r3), w(t3, o)]) }, n3 = new Uint32Array([0, 1, 2, 3, 4, 5]);
    return new w2(s4, n3, E.TRIANGLES);
  }
  static fromMapExtent(e2, t3) {
    const [r3, o] = e2.toScreen([0, 0], [t3.xmin, t3.ymin]), [s4, n3] = e2.toScreen([0, 0], [t3.xmax, t3.ymax]), i = { geometry: new Uint32Array([w(r3, o), w(s4, o), w(r3, n3), w(r3, n3), w(s4, o), w(s4, n3)]) }, c2 = new Uint32Array([0, 1, 2, 3, 4, 5]);
    return new w2(i, c2, E.TRIANGLES);
  }
  destroy() {
    r(this._cache.indexBuffer) && this._cache.indexBuffer.dispose();
    for (const e2 in this._cache.vertexBuffers)
      r(this._cache.vertexBuffers[e2]) && this._cache.vertexBuffers[e2].dispose();
  }
  get elementType() {
    return g(this.indices);
  }
  getIndexBuffer(e2, t3 = F.STATIC_DRAW) {
    return this._cache.indexBuffer || (this._cache.indexBuffer = c.createIndex(e2, t3, this.indices)), this._cache.indexBuffer;
  }
  getVertexBuffers(e2, t3 = F.STATIC_DRAW) {
    return this._cache.vertexBuffers || (this._cache.vertexBuffers = Object.keys(this.vertices).reduce((r3, o) => ({ ...r3, [o]: c.createVertex(e2, t3, this.vertices[o]) }), {})), this._cache.vertexBuffers;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/ClippingInfo.js
var n2 = s.getLogger("esri.views.2d.engine.webgl.ClippingInfo");
var m = (t3) => parseFloat(t3) / 100;
var p2 = class extends a {
  constructor(t3, e2) {
    super(), this._clip = e2, this._cache = {}, this.stage = t3, this._handle = l(() => e2.version, () => this._invalidate()), this.ready();
  }
  static fromClipArea(t3, e2) {
    return new p2(t3, e2);
  }
  _destroyGL() {
    r(this._cache.mesh) && (this._cache.mesh.destroy(), this._cache.mesh = null), r(this._cache.vao) && (this._cache.vao.dispose(), this._cache.vao = null);
  }
  destroy() {
    this._destroyGL(), this._handle.remove();
  }
  getVAO(t3, e2, r3, i) {
    const [o, h] = e2.size;
    if ("geometry" !== this._clip.type && this._lastWidth === o && this._lastHeight === h || (this._lastWidth = o, this._lastHeight = h, this._destroyGL()), t(this._cache.vao)) {
      const s4 = this._createMesh(e2, this._clip), o2 = s4.getIndexBuffer(t3), h2 = s4.getVertexBuffers(t3);
      this._cache.mesh = s4, this._cache.vao = new f(t3, r3, i, h2, o2);
    }
    return this._cache.vao;
  }
  _createTransforms() {
    return { dvs: e() };
  }
  _invalidate() {
    this._destroyGL(), this.requestRender();
  }
  _createScreenRect(t3, e2) {
    const [r3, s4] = t3.size, i = "string" == typeof e2.left ? m(e2.left) * r3 : e2.left, o = "string" == typeof e2.right ? m(e2.right) * r3 : e2.right, h = "string" == typeof e2.top ? m(e2.top) * s4 : e2.top, a3 = "string" == typeof e2.bottom ? m(e2.bottom) * s4 : e2.bottom, c2 = i, n3 = h;
    return { x: c2, y: n3, width: Math.max(r3 - o - c2, 0), height: Math.max(s4 - a3 - n3, 0) };
  }
  _createMesh(e2, r3) {
    switch (r3.type) {
      case "rect":
        return w2.fromRect(this._createScreenRect(e2, r3));
      case "path":
        return w2.fromPath(r3);
      case "geometry":
        return w2.fromGeometry(e2, r3);
      default:
        return n2.error(new s2("mapview-bad-type", "Unable to create ClippingInfo mesh from clip of type: ${clip.type}")), w2.fromRect({ x: 0, y: 0, width: 1, height: 1 });
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLContainer.js
var a2 = class extends s3 {
  constructor() {
    super(...arguments), this.name = this.constructor.name;
  }
  set clips(e2) {
    this._clips = e2, this.children.forEach((r3) => r3.clips = e2), this._updateClippingInfo();
  }
  _createTransforms() {
    return { dvs: e() };
  }
  doRender(e2) {
    const r3 = this.createRenderParams(e2), { painter: s4, globalOpacity: t3, profiler: i, drawPhase: n3 } = r3, a3 = n3 === I.LABEL || n3 === I.HIGHLIGHT ? 1 : t3 * this.computedOpacity;
    i.recordContainerStart(this.name), s4.beforeRenderLayer(r3, this._clippingInfos ? 255 : 0, a3), this.updateTransforms(e2.state), this.renderChildren(r3), s4.compositeLayer(r3, a3), i.recordContainerEnd();
  }
  renderChildren(r3) {
    t(this._renderPasses) && (this._renderPasses = this.prepareRenderPasses(r3.painter));
    for (const e2 of this.children)
      e2.beforeRender(r3);
    for (const e2 of this._renderPasses)
      try {
        e2.render(r3);
      } catch (s4) {
      }
    for (const e2 of this.children)
      e2.afterRender(r3);
  }
  createRenderParams(e2) {
    return e2.requireFBO = this.requiresDedicatedFBO, e2;
  }
  prepareRenderPasses(e2) {
    return [e2.registerRenderPass({ name: "clip", brushes: [W.clip], target: () => this._clippingInfos, drawPhase: I.MAP | I.LABEL | I.LABEL_ALPHA | I.DEBUG | I.HIGHLIGHT })];
  }
  updateTransforms(e2) {
    for (const r3 of this.children)
      r3.setTransform(e2);
  }
  onAttach() {
    super.onAttach(), this._updateClippingInfo();
  }
  onDetach() {
    super.onDetach(), this._updateClippingInfo();
  }
  _updateClippingInfo() {
    if (r(this._clippingInfos) && (this._clippingInfos.forEach((e3) => e3.destroy()), this._clippingInfos = null), !this.stage)
      return;
    const e2 = this._clips;
    r(e2) && e2.length && (this._clippingInfos = e2.items.map((e3) => p2.fromClipArea(this.stage, e3))), this.requestRender();
  }
};

export {
  a2 as a
};
//# sourceMappingURL=chunk-JERZLQLG.js.map
