import {
  U
} from "./chunk-UKBGUXUQ.js";
import {
  a
} from "./chunk-UGLXR5OV.js";
import {
  E,
  S
} from "./chunk-6FQZDXGD.js";
import {
  r as r2,
  s as s3
} from "./chunk-HH3D3A65.js";
import {
  C
} from "./chunk-FPMD6IB4.js";
import {
  s as s2
} from "./chunk-4TDLPK3D.js";
import {
  u
} from "./chunk-NWRK6QLX.js";
import {
  l
} from "./chunk-FVPTCNCX.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  r
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/Technique.js
var e = class {
  static getStorageSpec(t) {
    return null;
  }
  static createOrUpdateRendererSchema(e2, r3) {
    return r(e2) && "default" === e2.type ? e2 : { type: "default" };
  }
  static getVariation(t) {
    return {};
  }
  static getVariationHash(t) {
    return 0;
  }
};
e.type = "default", e.programSpec = null;

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/dotDensity/TechniqueDotDensity.js
var n = class extends e {
  static getStorageSpec({ attributes: e2 }) {
    return { visualVariables: false, attributes: e2 ?? null };
  }
  static _createRendererSchema() {
    return { type: "dot-density", colors: new Float32Array(32), dotValue: -1, dotSize: -1, dotScale: -1, dotBlending: false, backgroundColor: new Float32Array(4), activeDots: new Float32Array(8), seed: -1 };
  }
  static createOrUpdateRendererSchema(r3, a2) {
    const { attributes: n3, dotValue: i, referenceScale: d, dotSize: l3, dotBlendingEnabled: s5, seed: c2, backgroundColor: u2 } = a2, m = r(r3) && "dot-density" === r3.type ? r3 : this._createRendererSchema();
    m.dotValue = i, m.dotSize = l3, m.dotScale = d, m.dotBlending = s5, m.seed = c2;
    const { colors: g, activeDots: p2, backgroundColor: y } = m;
    for (let e2 = 0; e2 < r2; e2++) {
      const o = e2 >= n3.length ? null : n3[e2].color;
      a(g, o, 4 * e2);
    }
    for (let e2 = 0; e2 < 8; e2++)
      p2[e2] = e2 < a2.attributes.length ? 1 : 0;
    return a(y, u2), m;
  }
  static getVariation(e2) {
    return { ddDotBlending: e2.dotBlending };
  }
  static getVariationHash(e2) {
    return e2.dotBlending ? 1 : 0;
  }
};
n.type = "dot-density", n.programSpec = { shader: "materials/fill", vertexLayout: { geometry: [{ location: 0, name: "a_pos", count: 2, type: C.SHORT }, { location: 1, name: "a_id", count: 3, type: C.UNSIGNED_BYTE }, { location: 2, name: "a_bitset", count: 1, type: C.UNSIGNED_BYTE }, { location: 3, name: "a_inverseArea", count: 1, type: C.FLOAT }] } };

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/heatmap/TechniqueHeatmap.js
var n2 = class extends e {
  static getStorageSpec({ field: e2, valueExpression: t }) {
    return { visualVariables: false, attributes: e2 || t ? [{ field: e2, valueExpression: t }] : null };
  }
  static _createRendererSchema() {
    return { type: "heatmap", radius: -1, referenceScale: -1, isFieldActive: 0, minDensity: -1, densityRange: -1, kernel: null, gradient: null, gradientHash: "invalid" };
  }
  static createOrUpdateRendererSchema(a2, i) {
    const { radius: n3, minDensity: s5, maxDensity: o, referenceScale: c2, field: l3, valueExpression: m, colorStops: p2 } = i, d = o - s5, u2 = l3 || m ? 1 : 0, y = p2.map(({ color: e2, ratio: t }) => `${t}:${e2.toString()}`).join();
    let h, S2 = true;
    return r(a2) && "heatmap" === a2.type ? (h = a2, S2 = y !== a2.gradientHash) : h = this._createRendererSchema(), h.radius = u(n3), h.minDensity = s5, h.densityRange = d, h.referenceScale = c2, h.isFieldActive = u2, S2 && (h.gradient = s2(p2), h.gradientHash = y), h;
  }
};
n2.type = "heatmap", n2.programSpec = { shader: "materials/icon/heatmapAccumulate", vertexLayout: { geometry: [{ location: 0, name: "a_pos", count: 2, type: C.SHORT }, { location: 1, name: "a_vertexOffset", count: 2, type: C.SHORT }, { location: 4, name: "a_id", count: 4, type: C.UNSIGNED_BYTE }] } };

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/pieChart/TechniquePieChart.js
var l2 = class extends e {
  static getStorageSpec({ attributes: e2 }) {
    return { visualVariables: true, attributes: e2 ?? null };
  }
  static _createRendererSchema() {
    return { type: "pie-chart", colors: new Float32Array(4 * s3), defaultColor: new Float32Array(4), othersColor: new Float32Array(4), outlineColor: new Float32Array(4), holePercentage: 0, sectorThreshold: 0, outlineWidth: 1, numberOfFields: 10 };
  }
  static createOrUpdateRendererSchema(n3, i) {
    const { attributes: l3, defaultColor: s5, holePercentage: c2, othersCategory: m, outline: u2 } = i, d = r(n3) && "pie-chart" === n3.type ? n3 : this._createRendererSchema();
    for (let t = 0; t < s3; t++) {
      const o = t >= l3.length ? new l([0, 0, 0, 0]) : l3[t].color;
      a(d.colors, o, 4 * t);
    }
    return a(d.defaultColor, s5), a(d.othersColor, m == null ? void 0 : m.color), a(d.outlineColor, u2 == null ? void 0 : u2.color), d.outlineWidth = u((u2 == null ? void 0 : u2.width) || 0), d.holePercentage = c2, d.sectorThreshold = (m == null ? void 0 : m.threshold) || 0, d.numberOfFields = l3.length, d;
  }
  static getVariation(e2) {
    return { numberOfFields: e2.numberOfFields };
  }
  static getVariationHash(e2) {
    return e2.numberOfFields;
  }
};
l2.type = "pie-chart", l2.programSpec = { shader: "materials/pie", vertexLayout: { geometry: [{ location: 0, name: "a_pos", count: 2, type: C.SHORT }, { location: 1, name: "a_vertexOffset", count: 2, type: C.SHORT }, { location: 2, name: "a_texCoords", count: 2, type: C.UNSIGNED_SHORT }, { location: 3, name: "a_bitSetAndDistRatio", count: 2, type: C.UNSIGNED_SHORT }, { location: 4, name: "a_id", count: 4, type: C.UNSIGNED_BYTE }, { location: 5, name: "a_color", count: 4, type: C.UNSIGNED_BYTE, normalized: true }, { location: 6, name: "a_outlineColor", count: 4, type: C.UNSIGNED_BYTE, normalized: true }, { location: 7, name: "a_sizeAndOutlineWidth", count: 4, type: C.UNSIGNED_BYTE }, { location: 8, name: "a_zoomRange", count: 2, type: C.UNSIGNED_SHORT }] }, hittestAttributes: ["a_vertexOffset", "a_texCoords"] };

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/utils.js
function s4(r3, t) {
  if (r3.type !== t)
    throw new s("material-view-model:unexpected-renderer-schema", `expected to find renderer schema of type "${t}" but found type "${r3.type}"`);
}
function c(e2) {
  switch (e2.type) {
    case "dot-density":
      return n;
    case "heatmap":
      return n2;
    case "pie-chart":
      return l2;
    default:
      return e;
  }
}
function p(e2) {
  const { geometryType: s5, symbologyType: c2 } = U.load(e2);
  switch (s5) {
    case E.FILL:
      if (c2 === S.DOT_DENSITY)
        return n;
      break;
    case E.MARKER:
      switch (c2) {
        case S.HEATMAP:
          return n2;
        case S.PIE_CHART:
          return l2;
      }
  }
  return e;
}

export {
  e,
  s4 as s,
  c,
  p
};
//# sourceMappingURL=chunk-KXE4LGFJ.js.map
