import {
  a as a2,
  i,
  l as l3,
  o,
  r as r2,
  s as s3,
  u
} from "./chunk-YRAX326I.js";
import {
  p as p2,
  v,
  y,
  z
} from "./chunk-HB4HVKJV.js";
import {
  a
} from "./chunk-KVF4M6PZ.js";
import {
  l as l2
} from "./chunk-FVPTCNCX.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  l
} from "./chunk-ICD7AJSY.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  m,
  p
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  e as e2,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/chunks/Zlib.js
var t2;
var e3;
var r3;
var i2 = { exports: {} };
e3 = i2, void 0 !== (t2 = function() {
  function t7() {
    this.pos = 0, this.bufferLength = 0, this.eof = false, this.buffer = null;
  }
  return t7.prototype = { ensureBuffer: function(t8) {
    var e8 = this.buffer, r11 = e8 ? e8.byteLength : 0;
    if (t8 < r11)
      return e8;
    for (var i10 = 512; i10 < t8; )
      i10 <<= 1;
    for (var s10 = new Uint8Array(i10), f6 = 0; f6 < r11; ++f6)
      s10[f6] = e8[f6];
    return this.buffer = s10;
  }, getByte: function() {
    for (var t8 = this.pos; this.bufferLength <= t8; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }, getBytes: function(t8) {
    var e8 = this.pos;
    if (t8) {
      this.ensureBuffer(e8 + t8);
      for (var r11 = e8 + t8; !this.eof && this.bufferLength < r11; )
        this.readBlock();
      var i10 = this.bufferLength;
      r11 > i10 && (r11 = i10);
    } else {
      for (; !this.eof; )
        this.readBlock();
      r11 = this.bufferLength;
    }
    return this.pos = r11, this.buffer.subarray(e8, r11);
  }, lookChar: function() {
    for (var t8 = this.pos; this.bufferLength <= t8; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return String.fromCharCode(this.buffer[this.pos]);
  }, getChar: function() {
    for (var t8 = this.pos; this.bufferLength <= t8; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return String.fromCharCode(this.buffer[this.pos++]);
  }, makeSubStream: function(t8, e8, r11) {
    for (var i10 = t8 + e8; this.bufferLength <= i10 && !this.eof; )
      this.readBlock();
    return new Stream(this.buffer, t8, e8, r11);
  }, skip: function(t8) {
    t8 || (t8 = 1), this.pos += t8;
  }, reset: function() {
    this.pos = 0;
  } }, t7;
}(), r3 = function() {
  if (!self || !self.Uint32Array)
    return null;
  var e8 = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), r11 = new Uint32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), i10 = new Uint32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), s10 = [new Uint32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], f6 = [new Uint32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
  function o7(t7) {
    throw new Error(t7);
  }
  function n9(e9) {
    var r12 = 0, i11 = e9[r12++], s11 = e9[r12++];
    -1 != i11 && -1 != s11 || o7("Invalid header in flate stream"), 8 != (15 & i11) && o7("Unknown compression method in flate stream"), ((i11 << 8) + s11) % 31 != 0 && o7("Bad FCHECK in flate stream"), 32 & s11 && o7("FDICT bit set in flate stream"), this.bytes = e9, this.bytesPos = r12, this.codeSize = 0, this.codeBuf = 0, t2.call(this);
  }
  return n9.prototype = Object.create(t2.prototype), n9.prototype.getBits = function(t7) {
    for (var e9, r12 = this.codeSize, i11 = this.codeBuf, s11 = this.bytes, f7 = this.bytesPos; r12 < t7; )
      void 0 === (e9 = s11[f7++]) && o7("Bad encoding in flate stream"), i11 |= e9 << r12, r12 += 8;
    return e9 = i11 & (1 << t7) - 1, this.codeBuf = i11 >> t7, this.codeSize = r12 -= t7, this.bytesPos = f7, e9;
  }, n9.prototype.getCode = function(t7) {
    for (var e9 = t7[0], r12 = t7[1], i11 = this.codeSize, s11 = this.codeBuf, f7 = this.bytes, n10 = this.bytesPos; i11 < r12; ) {
      var h4;
      void 0 === (h4 = f7[n10++]) && o7("Bad encoding in flate stream"), s11 |= h4 << i11, i11 += 8;
    }
    var a9 = e9[s11 & (1 << r12) - 1], u7 = a9 >> 16, l6 = 65535 & a9;
    return (0 == i11 || i11 < u7 || 0 == u7) && o7("Bad encoding in flate stream"), this.codeBuf = s11 >> u7, this.codeSize = i11 - u7, this.bytesPos = n10, l6;
  }, n9.prototype.generateHuffmanTable = function(t7) {
    for (var e9 = t7.length, r12 = 0, i11 = 0; i11 < e9; ++i11)
      t7[i11] > r12 && (r12 = t7[i11]);
    for (var s11 = 1 << r12, f7 = new Uint32Array(s11), o8 = 1, n10 = 0, h4 = 2; o8 <= r12; ++o8, n10 <<= 1, h4 <<= 1)
      for (var a9 = 0; a9 < e9; ++a9)
        if (t7[a9] == o8) {
          var u7 = 0, l6 = n10;
          for (i11 = 0; i11 < o8; ++i11)
            u7 = u7 << 1 | 1 & l6, l6 >>= 1;
          for (i11 = u7; i11 < s11; i11 += h4)
            f7[i11] = o8 << 16 | a9;
          ++n10;
        }
    return [f7, r12];
  }, n9.prototype.readBlock = function() {
    function t7(t8, e9, r12, i11, s11) {
      for (var f7 = t8.getBits(r12) + i11; f7-- > 0; )
        e9[b3++] = s11;
    }
    var n10 = this.getBits(3);
    if (1 & n10 && (this.eof = true), 0 != (n10 >>= 1)) {
      var h4, a9;
      if (1 == n10)
        h4 = s10, a9 = f6;
      else if (2 == n10) {
        for (var u7 = this.getBits(5) + 257, l6 = this.getBits(5) + 1, c5 = this.getBits(4) + 4, d5 = Array(e8.length), b3 = 0; b3 < c5; )
          d5[e8[b3++]] = this.getBits(3);
        for (var v4 = this.generateHuffmanTable(d5), g5 = 0, B2 = (b3 = 0, u7 + l6), p6 = new Array(B2); b3 < B2; ) {
          var y4 = this.getCode(v4);
          16 == y4 ? t7(this, p6, 2, 3, g5) : 17 == y4 ? t7(this, p6, 3, 3, g5 = 0) : 18 == y4 ? t7(this, p6, 7, 11, g5 = 0) : p6[b3++] = g5 = y4;
        }
        h4 = this.generateHuffmanTable(p6.slice(0, u7)), a9 = this.generateHuffmanTable(p6.slice(u7, B2));
      } else
        o7("Unknown block type in flate stream");
      for (var m6 = (x4 = this.buffer) ? x4.length : 0, k4 = this.bufferLength; ; ) {
        var w3 = this.getCode(h4);
        if (w3 < 256)
          k4 + 1 >= m6 && (m6 = (x4 = this.ensureBuffer(k4 + 1)).length), x4[k4++] = w3;
        else {
          if (256 == w3)
            return void (this.bufferLength = k4);
          var C4 = (w3 = r11[w3 -= 257]) >> 16;
          C4 > 0 && (C4 = this.getBits(C4)), g5 = (65535 & w3) + C4, w3 = this.getCode(a9), (C4 = (w3 = i10[w3]) >> 16) > 0 && (C4 = this.getBits(C4));
          var L3 = (65535 & w3) + C4;
          k4 + g5 >= m6 && (m6 = (x4 = this.ensureBuffer(k4 + g5)).length);
          for (var S4 = 0; S4 < g5; ++S4, ++k4)
            x4[k4] = x4[k4 - L3];
        }
      }
    } else {
      var A3, U4 = this.bytes, P3 = this.bytesPos;
      void 0 === (A3 = U4[P3++]) && o7("Bad block header in flate stream");
      var z2 = A3;
      void 0 === (A3 = U4[P3++]) && o7("Bad block header in flate stream"), z2 |= A3 << 8, void 0 === (A3 = U4[P3++]) && o7("Bad block header in flate stream");
      var H = A3;
      void 0 === (A3 = U4[P3++]) && o7("Bad block header in flate stream"), (H |= A3 << 8) != (65535 & ~z2) && o7("Bad uncompressed block length in flate stream"), this.codeBuf = 0, this.codeSize = 0;
      var T4 = this.bufferLength, x4 = this.ensureBuffer(T4 + z2), E3 = T4 + z2;
      this.bufferLength = E3;
      for (var F = T4; F < E3; ++F) {
        if (void 0 === (A3 = U4[P3++])) {
          this.eof = true;
          break;
        }
        x4[F] = A3;
      }
      this.bytesPos = P3;
    }
  }, n9;
}()) && (e3.exports = r3);
var s4 = i2.exports;

// node_modules/@arcgis/core/layers/support/rasterFormats/ImageCanvasDecoder.js
var i3 = class {
  constructor(t7) {
    t7 && (this.canvas = t7.canvas, this.ctx = t7.ctx || t7.canvas && t7.canvas.getContext("2d"));
  }
  decode(n9, r11, s10) {
    if (!n9 || n9.byteLength < 10)
      throw new s2("imagecanvasdecoder: decode", "required a valid encoded data as input.");
    let { width: c5, height: h4, format: o7 } = r11;
    const { applyJpegMask: d5 } = r11;
    if (d5 && (!c5 || !h4))
      throw new s2("imagecanvasdecoder: decode", "image width and height are needed to apply jpeg mask directly to canvas");
    return new Promise((t7, l6) => {
      let g5 = null;
      "jpg" === o7 && d5 && (g5 = i3._getMask(n9, { width: c5, height: h4 }));
      const w3 = new Blob([new Uint8Array(n9)], { type: "image/" + o7 == "jpg" ? "jpeg" : o7 }), v4 = URL.createObjectURL(w3), m6 = new Image();
      let p6;
      m6.src = v4, m6.onload = () => {
        if (URL.revokeObjectURL(v4), p(s10))
          return void l6(m());
        c5 = m6.width, h4 = m6.height, this.canvas ? (this.canvas.width === c5 && this.canvas.height === h4 || (this.canvas.width = c5, this.canvas.height = h4), this.ctx.clearRect(0, 0, c5, h4)) : (this.canvas = document.createElement("canvas"), this.canvas.width = c5, this.canvas.height = h4, this.ctx = this.canvas.getContext("2d")), this.ctx.drawImage(m6, 0, 0);
        const n10 = this.ctx.getImageData(0, 0, c5, h4);
        let i10;
        if (p6 = n10.data, r11.renderOnCanvas) {
          if (g5)
            for (i10 = 0; i10 < g5.length; i10++)
              g5[i10] ? p6[4 * i10 + 3] = 255 : p6[4 * i10 + 3] = 0;
          return this.ctx.putImageData(n10, 0, 0), void t7(null);
        }
        const o8 = c5 * h4, d6 = new Uint8Array(o8), w4 = new Uint8Array(o8), f6 = new Uint8Array(o8);
        if (g5)
          for (i10 = 0; i10 < o8; i10++)
            d6[i10] = p6[4 * i10], w4[i10] = p6[4 * i10 + 1], f6[i10] = p6[4 * i10 + 2];
        else
          for (g5 = new Uint8Array(o8), i10 = 0; i10 < o8; i10++)
            d6[i10] = p6[4 * i10], w4[i10] = p6[4 * i10 + 1], f6[i10] = p6[4 * i10 + 2], g5[i10] = p6[4 * i10 + 3];
        t7({ width: c5, height: h4, pixels: [d6, w4, f6], mask: g5, pixelType: "u8" });
      }, m6.onerror = () => {
        URL.revokeObjectURL(v4), l6("cannot load image");
      };
    });
  }
  static _getMask(t7, e8) {
    let a9 = null;
    try {
      const i10 = new Uint8Array(t7), r11 = Math.ceil(i10.length / 2);
      let s10 = 0;
      const c5 = i10.length - 2;
      for (s10 = r11; s10 < c5 && (255 !== i10[s10] || 217 !== i10[s10 + 1]); s10++)
        ;
      if (s10 += 2, s10 < i10.length - 1) {
        const t8 = new s4(i10.subarray(s10)).getBytes();
        a9 = new Uint8Array(e8.width * e8.height);
        let r12 = 0;
        for (let e9 = 0; e9 < t8.length; e9++)
          for (let n9 = 7; n9 >= 0; n9--)
            a9[r12++] = t8[e9] >> n9 & 1;
      }
    } catch (i10) {
    }
    return a9;
  }
};

// node_modules/@arcgis/core/chunks/Jpg.js
var e4;
var n2;
var r4;
var o2 = { exports: {} };
e4 = o2, n2 = function() {
  var e8 = function() {
    function e9(e10) {
      this.message = "JPEG error: " + e10;
    }
    return e9.prototype = new Error(), e9.prototype.name = "JpegError", e9.constructor = e9, e9;
  }();
  return function() {
    if (!self || !self.Uint8ClampedArray)
      return null;
    var n9 = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), r11 = 4017, o7 = 799, a9 = 3406, t7 = 2276, i10 = 1567, s10 = 3784, c5 = 5793, f6 = 2896;
    function l6() {
      this.decodeTransform = null, this.colorTransform = -1;
    }
    function u7(e9, n10) {
      for (var r12, o8, a10 = 0, t8 = [], i11 = 16; i11 > 0 && !e9[i11 - 1]; )
        i11--;
      t8.push({ children: [], index: 0 });
      var s11, c6 = t8[0];
      for (r12 = 0; r12 < i11; r12++) {
        for (o8 = 0; o8 < e9[r12]; o8++) {
          for ((c6 = t8.pop()).children[c6.index] = n10[a10]; c6.index > 0; )
            c6 = t8.pop();
          for (c6.index++, t8.push(c6); t8.length <= r12; )
            t8.push(s11 = { children: [], index: 0 }), c6.children[c6.index] = s11.children, c6 = s11;
          a10++;
        }
        r12 + 1 < i11 && (t8.push(s11 = { children: [], index: 0 }), c6.children[c6.index] = s11.children, c6 = s11);
      }
      return t8[0].children;
    }
    function h4(e9, n10, r12) {
      return 64 * ((e9.blocksPerLine + 1) * n10 + r12);
    }
    function v4(r12, o8, a10, t8, i11, s11, c6, f7, l7) {
      var u8 = a10.mcusPerLine, v5 = a10.progressive, m7 = o8, d6 = 0, p6 = 0;
      function k4() {
        if (p6 > 0)
          return p6--, d6 >> p6 & 1;
        if (255 === (d6 = r12[o8++])) {
          var n10 = r12[o8++];
          if (n10)
            throw new e8("unexpected marker " + (d6 << 8 | n10).toString(16));
        }
        return p6 = 7, d6 >>> 7;
      }
      function g5(n10) {
        for (var r13 = n10; ; ) {
          if ("number" == typeof (r13 = r13[k4()]))
            return r13;
          if ("object" != typeof r13)
            throw new e8("invalid huffman sequence");
        }
      }
      function C4(e9) {
        for (var n10 = 0; e9 > 0; )
          n10 = n10 << 1 | k4(), e9--;
        return n10;
      }
      function w3(e9) {
        if (1 === e9)
          return 1 === k4() ? 1 : -1;
        var n10 = C4(e9);
        return n10 >= 1 << e9 - 1 ? n10 : n10 + (-1 << e9) + 1;
      }
      function x4(e9, r13) {
        var o9 = g5(e9.huffmanTableDC), a11 = 0 === o9 ? 0 : w3(o9);
        e9.blockData[r13] = e9.pred += a11;
        for (var t9 = 1; t9 < 64; ) {
          var i12 = g5(e9.huffmanTableAC), s12 = 15 & i12, c7 = i12 >> 4;
          if (0 !== s12) {
            var f8 = n9[t9 += c7];
            e9.blockData[r13 + f8] = w3(s12), t9++;
          } else {
            if (c7 < 15)
              break;
            t9 += 16;
          }
        }
      }
      function y4(e9, n10) {
        var r13 = g5(e9.huffmanTableDC), o9 = 0 === r13 ? 0 : w3(r13) << l7;
        e9.blockData[n10] = e9.pred += o9;
      }
      function D4(e9, n10) {
        e9.blockData[n10] |= k4() << l7;
      }
      var T4 = 0;
      function P3(e9, r13) {
        if (T4 > 0)
          T4--;
        else
          for (var o9 = s11, a11 = c6; o9 <= a11; ) {
            var t9 = g5(e9.huffmanTableAC), i12 = 15 & t9, f8 = t9 >> 4;
            if (0 !== i12) {
              var u9 = n9[o9 += f8];
              e9.blockData[r13 + u9] = w3(i12) * (1 << l7), o9++;
            } else {
              if (f8 < 15) {
                T4 = C4(f8) + (1 << f8) - 1;
                break;
              }
              o9 += 16;
            }
          }
      }
      var L3, A3 = 0;
      function _3(r13, o9) {
        for (var a11, t9, i12 = s11, f8 = c6, u9 = 0; i12 <= f8; ) {
          var h5 = n9[i12];
          switch (A3) {
            case 0:
              if (u9 = (t9 = g5(r13.huffmanTableAC)) >> 4, 0 == (a11 = 15 & t9))
                u9 < 15 ? (T4 = C4(u9) + (1 << u9), A3 = 4) : (u9 = 16, A3 = 1);
              else {
                if (1 !== a11)
                  throw new e8("invalid ACn encoding");
                L3 = w3(a11), A3 = u9 ? 2 : 3;
              }
              continue;
            case 1:
            case 2:
              r13.blockData[o9 + h5] ? r13.blockData[o9 + h5] += k4() << l7 : 0 == --u9 && (A3 = 2 === A3 ? 3 : 0);
              break;
            case 3:
              r13.blockData[o9 + h5] ? r13.blockData[o9 + h5] += k4() << l7 : (r13.blockData[o9 + h5] = L3 << l7, A3 = 0);
              break;
            case 4:
              r13.blockData[o9 + h5] && (r13.blockData[o9 + h5] += k4() << l7);
          }
          i12++;
        }
        4 === A3 && 0 == --T4 && (A3 = 0);
      }
      function U4(e9, n10, r13, o9, a11) {
        var t9 = r13 % u8;
        n10(e9, h4(e9, (r13 / u8 | 0) * e9.v + o9, t9 * e9.h + a11));
      }
      function z2(e9, n10, r13) {
        n10(e9, h4(e9, r13 / e9.blocksPerLine | 0, r13 % e9.blocksPerLine));
      }
      var I3, M3, Y, q, S4, R3, H = t8.length;
      R3 = v5 ? 0 === s11 ? 0 === f7 ? y4 : D4 : 0 === f7 ? P3 : _3 : x4;
      var E3, J, V2, j2, B2 = 0;
      for (J = 1 === H ? t8[0].blocksPerLine * t8[0].blocksPerColumn : u8 * a10.mcusPerColumn; B2 < J; ) {
        var N2 = i11 ? Math.min(J - B2, i11) : J;
        for (M3 = 0; M3 < H; M3++)
          t8[M3].pred = 0;
        if (T4 = 0, 1 === H)
          for (I3 = t8[0], S4 = 0; S4 < N2; S4++)
            z2(I3, R3, B2), B2++;
        else
          for (S4 = 0; S4 < N2; S4++) {
            for (M3 = 0; M3 < H; M3++)
              for (V2 = (I3 = t8[M3]).h, j2 = I3.v, Y = 0; Y < j2; Y++)
                for (q = 0; q < V2; q++)
                  U4(I3, R3, B2, Y, q);
            B2++;
          }
        p6 = 0, (E3 = b3(r12, o8)) && E3.invalid && (console.log("decodeScan - unexpected MCU data, next marker is: " + E3.invalid), o8 = E3.offset);
        var G2 = E3 && E3.marker;
        if (!G2 || G2 <= 65280)
          throw new e8("marker was not found");
        if (!(G2 >= 65488 && G2 <= 65495))
          break;
        o8 += 2;
      }
      return (E3 = b3(r12, o8)) && E3.invalid && (console.log("decodeScan - unexpected Scan data, next marker is: " + E3.invalid), o8 = E3.offset), o8 - m7;
    }
    function m6(n10, l7, u8) {
      var h5, v5, m7, d6, b4, p6, k4, g5, C4, w3, x4, y4, D4, T4, P3, L3, A3, _3 = n10.quantizationTable, U4 = n10.blockData;
      if (!_3)
        throw new e8("missing required Quantization Table.");
      for (var z2 = 0; z2 < 64; z2 += 8)
        C4 = U4[l7 + z2], w3 = U4[l7 + z2 + 1], x4 = U4[l7 + z2 + 2], y4 = U4[l7 + z2 + 3], D4 = U4[l7 + z2 + 4], T4 = U4[l7 + z2 + 5], P3 = U4[l7 + z2 + 6], L3 = U4[l7 + z2 + 7], C4 *= _3[z2], 0 != (w3 | x4 | y4 | D4 | T4 | P3 | L3) ? (w3 *= _3[z2 + 1], x4 *= _3[z2 + 2], y4 *= _3[z2 + 3], D4 *= _3[z2 + 4], T4 *= _3[z2 + 5], P3 *= _3[z2 + 6], L3 *= _3[z2 + 7], v5 = (h5 = (h5 = c5 * C4 + 128 >> 8) + (v5 = c5 * D4 + 128 >> 8) + 1 >> 1) - v5, A3 = (m7 = x4) * s10 + (d6 = P3) * i10 + 128 >> 8, m7 = m7 * i10 - d6 * s10 + 128 >> 8, k4 = (b4 = (b4 = f6 * (w3 - L3) + 128 >> 8) + (k4 = T4 << 4) + 1 >> 1) - k4, p6 = (g5 = (g5 = f6 * (w3 + L3) + 128 >> 8) + (p6 = y4 << 4) + 1 >> 1) - p6, d6 = (h5 = h5 + (d6 = A3) + 1 >> 1) - d6, m7 = (v5 = v5 + m7 + 1 >> 1) - m7, A3 = b4 * t7 + g5 * a9 + 2048 >> 12, b4 = b4 * a9 - g5 * t7 + 2048 >> 12, g5 = A3, A3 = p6 * o7 + k4 * r11 + 2048 >> 12, p6 = p6 * r11 - k4 * o7 + 2048 >> 12, k4 = A3, u8[z2] = h5 + g5, u8[z2 + 7] = h5 - g5, u8[z2 + 1] = v5 + k4, u8[z2 + 6] = v5 - k4, u8[z2 + 2] = m7 + p6, u8[z2 + 5] = m7 - p6, u8[z2 + 3] = d6 + b4, u8[z2 + 4] = d6 - b4) : (A3 = c5 * C4 + 512 >> 10, u8[z2] = A3, u8[z2 + 1] = A3, u8[z2 + 2] = A3, u8[z2 + 3] = A3, u8[z2 + 4] = A3, u8[z2 + 5] = A3, u8[z2 + 6] = A3, u8[z2 + 7] = A3);
      for (var I3 = 0; I3 < 8; ++I3)
        C4 = u8[I3], 0 != ((w3 = u8[I3 + 8]) | (x4 = u8[I3 + 16]) | (y4 = u8[I3 + 24]) | (D4 = u8[I3 + 32]) | (T4 = u8[I3 + 40]) | (P3 = u8[I3 + 48]) | (L3 = u8[I3 + 56])) ? (v5 = (h5 = 4112 + ((h5 = c5 * C4 + 2048 >> 12) + (v5 = c5 * D4 + 2048 >> 12) + 1 >> 1)) - v5, A3 = (m7 = x4) * s10 + (d6 = P3) * i10 + 2048 >> 12, m7 = m7 * i10 - d6 * s10 + 2048 >> 12, d6 = A3, k4 = (b4 = (b4 = f6 * (w3 - L3) + 2048 >> 12) + (k4 = T4) + 1 >> 1) - k4, p6 = (g5 = (g5 = f6 * (w3 + L3) + 2048 >> 12) + (p6 = y4) + 1 >> 1) - p6, A3 = b4 * t7 + g5 * a9 + 2048 >> 12, b4 = b4 * a9 - g5 * t7 + 2048 >> 12, g5 = A3, A3 = p6 * o7 + k4 * r11 + 2048 >> 12, p6 = p6 * r11 - k4 * o7 + 2048 >> 12, C4 = (C4 = (h5 = h5 + d6 + 1 >> 1) + g5) < 16 ? 0 : C4 >= 4080 ? 255 : C4 >> 4, w3 = (w3 = (v5 = v5 + m7 + 1 >> 1) + (k4 = A3)) < 16 ? 0 : w3 >= 4080 ? 255 : w3 >> 4, x4 = (x4 = (m7 = v5 - m7) + p6) < 16 ? 0 : x4 >= 4080 ? 255 : x4 >> 4, y4 = (y4 = (d6 = h5 - d6) + b4) < 16 ? 0 : y4 >= 4080 ? 255 : y4 >> 4, D4 = (D4 = d6 - b4) < 16 ? 0 : D4 >= 4080 ? 255 : D4 >> 4, T4 = (T4 = m7 - p6) < 16 ? 0 : T4 >= 4080 ? 255 : T4 >> 4, P3 = (P3 = v5 - k4) < 16 ? 0 : P3 >= 4080 ? 255 : P3 >> 4, L3 = (L3 = h5 - g5) < 16 ? 0 : L3 >= 4080 ? 255 : L3 >> 4, U4[l7 + I3] = C4, U4[l7 + I3 + 8] = w3, U4[l7 + I3 + 16] = x4, U4[l7 + I3 + 24] = y4, U4[l7 + I3 + 32] = D4, U4[l7 + I3 + 40] = T4, U4[l7 + I3 + 48] = P3, U4[l7 + I3 + 56] = L3) : (A3 = (A3 = c5 * C4 + 8192 >> 14) < -2040 ? 0 : A3 >= 2024 ? 255 : A3 + 2056 >> 4, U4[l7 + I3] = A3, U4[l7 + I3 + 8] = A3, U4[l7 + I3 + 16] = A3, U4[l7 + I3 + 24] = A3, U4[l7 + I3 + 32] = A3, U4[l7 + I3 + 40] = A3, U4[l7 + I3 + 48] = A3, U4[l7 + I3 + 56] = A3);
    }
    function d5(e9, n10) {
      for (var r12 = n10.blocksPerLine, o8 = n10.blocksPerColumn, a10 = new Int16Array(64), t8 = 0; t8 < o8; t8++)
        for (var i11 = 0; i11 < r12; i11++)
          m6(n10, h4(n10, t8, i11), a10);
      return n10.blockData;
    }
    function b3(e9, n10, r12) {
      function o8(n11) {
        return e9[n11] << 8 | e9[n11 + 1];
      }
      var a10 = e9.length - 1, t8 = r12 < n10 ? r12 : n10;
      if (n10 >= a10)
        return null;
      var i11 = o8(n10);
      if (i11 >= 65472 && i11 <= 65534)
        return { invalid: null, marker: i11, offset: n10 };
      for (var s11 = o8(t8); !(s11 >= 65472 && s11 <= 65534); ) {
        if (++t8 >= a10)
          return null;
        s11 = o8(t8);
      }
      return { invalid: i11.toString(16), marker: s11, offset: t8 };
    }
    return l6.prototype = { parse: function(r12) {
      function o8() {
        var e9 = r12[c6] << 8 | r12[c6 + 1];
        return c6 += 2, e9;
      }
      function a10() {
        var e9 = o8(), n10 = c6 + e9 - 2, a11 = b3(r12, n10, c6);
        a11 && a11.invalid && (console.log("readDataBlock - incorrect length, next marker is: " + a11.invalid), n10 = a11.offset);
        var t9 = r12.subarray(c6, n10);
        return c6 += t9.length, t9;
      }
      function t8(e9) {
        for (var n10 = Math.ceil(e9.samplesPerLine / 8 / e9.maxH), r13 = Math.ceil(e9.scanLines / 8 / e9.maxV), o9 = 0; o9 < e9.components.length; o9++) {
          H = e9.components[o9];
          var a11 = Math.ceil(Math.ceil(e9.samplesPerLine / 8) * H.h / e9.maxH), t9 = Math.ceil(Math.ceil(e9.scanLines / 8) * H.v / e9.maxV), i12 = n10 * H.h, s12 = r13 * H.v * 64 * (i12 + 1);
          H.blockData = new Int16Array(s12), H.blocksPerLine = a11, H.blocksPerColumn = t9;
        }
        e9.mcusPerLine = n10, e9.mcusPerColumn = r13;
      }
      var i11, s11, c6 = 0, f7 = null, l7 = null, h5 = [], m7 = [], p6 = [], k4 = o8();
      if (65496 !== k4)
        throw new e8("SOI not found");
      for (k4 = o8(); 65497 !== k4; ) {
        var g5, C4, w3;
        switch (k4) {
          case 65504:
          case 65505:
          case 65506:
          case 65507:
          case 65508:
          case 65509:
          case 65510:
          case 65511:
          case 65512:
          case 65513:
          case 65514:
          case 65515:
          case 65516:
          case 65517:
          case 65518:
          case 65519:
          case 65534:
            var x4 = a10();
            65504 === k4 && 74 === x4[0] && 70 === x4[1] && 73 === x4[2] && 70 === x4[3] && 0 === x4[4] && (f7 = { version: { major: x4[5], minor: x4[6] }, densityUnits: x4[7], xDensity: x4[8] << 8 | x4[9], yDensity: x4[10] << 8 | x4[11], thumbWidth: x4[12], thumbHeight: x4[13], thumbData: x4.subarray(14, 14 + 3 * x4[12] * x4[13]) }), 65518 === k4 && 65 === x4[0] && 100 === x4[1] && 111 === x4[2] && 98 === x4[3] && 101 === x4[4] && (l7 = { version: x4[5] << 8 | x4[6], flags0: x4[7] << 8 | x4[8], flags1: x4[9] << 8 | x4[10], transformCode: x4[11] });
            break;
          case 65499:
            for (var y4 = o8() + c6 - 2; c6 < y4; ) {
              var D4 = r12[c6++], T4 = new Uint16Array(64);
              if (D4 >> 4 == 0)
                for (C4 = 0; C4 < 64; C4++)
                  T4[n9[C4]] = r12[c6++];
              else {
                if (D4 >> 4 != 1)
                  throw new e8("DQT - invalid table spec");
                for (C4 = 0; C4 < 64; C4++)
                  T4[n9[C4]] = o8();
              }
              h5[15 & D4] = T4;
            }
            break;
          case 65472:
          case 65473:
          case 65474:
            if (i11)
              throw new e8("Only single frame JPEGs supported");
            o8(), (i11 = {}).extended = 65473 === k4, i11.progressive = 65474 === k4, i11.precision = r12[c6++], i11.scanLines = o8(), i11.samplesPerLine = o8(), i11.components = [], i11.componentIds = {};
            var P3, L3 = r12[c6++], A3 = 0, _3 = 0;
            for (g5 = 0; g5 < L3; g5++) {
              P3 = r12[c6];
              var U4 = r12[c6 + 1] >> 4, z2 = 15 & r12[c6 + 1];
              A3 < U4 && (A3 = U4), _3 < z2 && (_3 = z2);
              var I3 = r12[c6 + 2];
              w3 = i11.components.push({ h: U4, v: z2, quantizationId: I3, quantizationTable: null }), i11.componentIds[P3] = w3 - 1, c6 += 3;
            }
            i11.maxH = A3, i11.maxV = _3, t8(i11);
            break;
          case 65476:
            var M3 = o8();
            for (g5 = 2; g5 < M3; ) {
              var Y = r12[c6++], q = new Uint8Array(16), S4 = 0;
              for (C4 = 0; C4 < 16; C4++, c6++)
                S4 += q[C4] = r12[c6];
              var R3 = new Uint8Array(S4);
              for (C4 = 0; C4 < S4; C4++, c6++)
                R3[C4] = r12[c6];
              g5 += 17 + S4, (Y >> 4 == 0 ? p6 : m7)[15 & Y] = u7(q, R3);
            }
            break;
          case 65501:
            o8(), s11 = o8();
            break;
          case 65498:
            o8();
            var H, E3 = r12[c6++], J = [];
            for (g5 = 0; g5 < E3; g5++) {
              var V2 = i11.componentIds[r12[c6++]];
              H = i11.components[V2];
              var j2 = r12[c6++];
              H.huffmanTableDC = p6[j2 >> 4], H.huffmanTableAC = m7[15 & j2], J.push(H);
            }
            var B2 = r12[c6++], N2 = r12[c6++], G2 = r12[c6++], O3 = v4(r12, c6, i11, J, s11, B2, N2, G2 >> 4, 15 & G2);
            c6 += O3;
            break;
          case 65535:
            255 !== r12[c6] && c6--;
            break;
          default:
            if (255 === r12[c6 - 3] && r12[c6 - 2] >= 192 && r12[c6 - 2] <= 254) {
              c6 -= 3;
              break;
            }
            throw new e8("unknown marker " + k4.toString(16));
        }
        k4 = o8();
      }
      for (this.width = i11.samplesPerLine, this.height = i11.scanLines, this.jfif = f7, this.eof = c6, this.adobe = l7, this.components = [], g5 = 0; g5 < i11.components.length; g5++) {
        var Q = h5[(H = i11.components[g5]).quantizationId];
        Q && (H.quantizationTable = Q), this.components.push({ output: d5(i11, H), scaleX: H.h / i11.maxH, scaleY: H.v / i11.maxV, blocksPerLine: H.blocksPerLine, blocksPerColumn: H.blocksPerColumn });
      }
      this.numComponents = this.components.length;
    }, _getLinearizedBlockData: function(e9, n10) {
      var r12, o8, a10, t8, i11, s11, c6, f7, l7, u8, h5, v5 = this.width / e9, m7 = this.height / n10, d6 = 0, b4 = this.components.length, p6 = e9 * n10 * b4, k4 = new Uint8ClampedArray(p6), g5 = new Uint32Array(e9), C4 = 4294967288;
      for (c6 = 0; c6 < b4; c6++) {
        for (o8 = (r12 = this.components[c6]).scaleX * v5, a10 = r12.scaleY * m7, d6 = c6, h5 = r12.output, t8 = r12.blocksPerLine + 1 << 3, i11 = 0; i11 < e9; i11++)
          f7 = 0 | i11 * o8, g5[i11] = (f7 & C4) << 3 | 7 & f7;
        for (s11 = 0; s11 < n10; s11++)
          for (u8 = t8 * ((f7 = 0 | s11 * a10) & C4) | (7 & f7) << 3, i11 = 0; i11 < e9; i11++)
            k4[d6] = h5[u8 + g5[i11]], d6 += b4;
      }
      var w3 = this.decodeTransform;
      if (w3)
        for (c6 = 0; c6 < p6; )
          for (f7 = 0, l7 = 0; f7 < b4; f7++, c6++, l7 += 2)
            k4[c6] = (k4[c6] * w3[l7] >> 8) + w3[l7 + 1];
      return k4;
    }, _isColorConversionNeeded: function() {
      return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this.colorTransform : 1 === this.colorTransform;
    }, _convertYccToRgb: function(e9) {
      for (var n10, r12, o8, a10 = 0, t8 = e9.length; a10 < t8; a10 += 3)
        n10 = e9[a10], r12 = e9[a10 + 1], o8 = e9[a10 + 2], e9[a10] = n10 - 179.456 + 1.402 * o8, e9[a10 + 1] = n10 + 135.459 - 0.344 * r12 - 0.714 * o8, e9[a10 + 2] = n10 - 226.816 + 1.772 * r12;
      return e9;
    }, _convertYcckToRgb: function(e9) {
      for (var n10, r12, o8, a10, t8 = 0, i11 = 0, s11 = e9.length; i11 < s11; i11 += 4)
        n10 = e9[i11], r12 = e9[i11 + 1], o8 = e9[i11 + 2], a10 = e9[i11 + 3], e9[t8++] = r12 * (-660635669420364e-19 * r12 + 437130475926232e-18 * o8 - 54080610064599e-18 * n10 + 48449797120281e-17 * a10 - 0.154362151871126) - 122.67195406894 + o8 * (-957964378445773e-18 * o8 + 817076911346625e-18 * n10 - 0.00477271405408747 * a10 + 1.53380253221734) + n10 * (961250184130688e-18 * n10 - 0.00266257332283933 * a10 + 0.48357088451265) + a10 * (-336197177618394e-18 * a10 + 0.484791561490776), e9[t8++] = 107.268039397724 + r12 * (219927104525741e-19 * r12 - 640992018297945e-18 * o8 + 659397001245577e-18 * n10 + 426105652938837e-18 * a10 - 0.176491792462875) + o8 * (-778269941513683e-18 * o8 + 0.00130872261408275 * n10 + 770482631801132e-18 * a10 - 0.151051492775562) + n10 * (0.00126935368114843 * n10 - 0.00265090189010898 * a10 + 0.25802910206845) + a10 * (-318913117588328e-18 * a10 - 0.213742400323665), e9[t8++] = r12 * (-570115196973677e-18 * r12 - 263409051004589e-19 * o8 + 0.0020741088115012 * n10 - 0.00288260236853442 * a10 + 0.814272968359295) - 20.810012546947 + o8 * (-153496057440975e-19 * o8 - 132689043961446e-18 * n10 + 560833691242812e-18 * a10 - 0.195152027534049) + n10 * (0.00174418132927582 * n10 - 0.00255243321439347 * a10 + 0.116935020465145) + a10 * (-343531996510555e-18 * a10 + 0.24165260232407);
      return e9;
    }, _convertYcckToCmyk: function(e9) {
      for (var n10, r12, o8, a10 = 0, t8 = e9.length; a10 < t8; a10 += 4)
        n10 = e9[a10], r12 = e9[a10 + 1], o8 = e9[a10 + 2], e9[a10] = 434.456 - n10 - 1.402 * o8, e9[a10 + 1] = 119.541 - n10 + 0.344 * r12 + 0.714 * o8, e9[a10 + 2] = 481.816 - n10 - 1.772 * r12;
      return e9;
    }, _convertCmykToRgb: function(e9) {
      for (var n10, r12, o8, a10, t8 = 0, i11 = 1 / 255, s11 = 0, c6 = e9.length; s11 < c6; s11 += 4)
        n10 = e9[s11] * i11, r12 = e9[s11 + 1] * i11, o8 = e9[s11 + 2] * i11, a10 = e9[s11 + 3] * i11, e9[t8++] = 255 + n10 * (-4.387332384609988 * n10 + 54.48615194189176 * r12 + 18.82290502165302 * o8 + 212.25662451639585 * a10 - 285.2331026137004) + r12 * (1.7149763477362134 * r12 - 5.6096736904047315 * o8 - 17.873870861415444 * a10 - 5.497006427196366) + o8 * (-2.5217340131683033 * o8 - 21.248923337353073 * a10 + 17.5119270841813) - a10 * (21.86122147463605 * a10 + 189.48180835922747), e9[t8++] = 255 + n10 * (8.841041422036149 * n10 + 60.118027045597366 * r12 + 6.871425592049007 * o8 + 31.159100130055922 * a10 - 79.2970844816548) + r12 * (-15.310361306967817 * r12 + 17.575251261109482 * o8 + 131.35250912493976 * a10 - 190.9453302588951) + o8 * (4.444339102852739 * o8 + 9.8632861493405 * a10 - 24.86741582555878) - a10 * (20.737325471181034 * a10 + 187.80453709719578), e9[t8++] = 255 + n10 * (0.8842522430003296 * n10 + 8.078677503112928 * r12 + 30.89978309703729 * o8 - 0.23883238689178934 * a10 - 14.183576799673286) + r12 * (10.49593273432072 * r12 + 63.02378494754052 * o8 + 50.606957656360734 * a10 - 112.23884253719248) + o8 * (0.03296041114873217 * o8 + 115.60384449646641 * a10 - 193.58209356861505) - a10 * (22.33816807309886 * a10 + 180.12613974708367);
      return e9;
    }, getData: function(n10, r12, o8) {
      if (this.numComponents > 4)
        throw new e8("Unsupported color mode");
      var a10 = this._getLinearizedBlockData(n10, r12);
      if (1 === this.numComponents && o8) {
        for (var t8 = a10.length, i11 = new Uint8ClampedArray(3 * t8), s11 = 0, c6 = 0; c6 < t8; c6++) {
          var f7 = a10[c6];
          i11[s11++] = f7, i11[s11++] = f7, i11[s11++] = f7;
        }
        return i11;
      }
      if (3 === this.numComponents && this._isColorConversionNeeded())
        return this._convertYccToRgb(a10);
      if (4 === this.numComponents) {
        if (this._isColorConversionNeeded())
          return o8 ? this._convertYcckToRgb(a10) : this._convertYcckToCmyk(a10);
        if (o8)
          return this._convertCmykToRgb(a10);
      }
      return a10;
    } }, l6;
  }();
}, void 0 !== (r4 = n2()) && (e4.exports = r4);
var a3 = o2.exports;

// node_modules/@arcgis/core/layers/support/rasterFormats/JpgPlus.js
var n3 = class {
  static decode(n9, r11 = false) {
    const s10 = new Uint8Array(n9), o7 = new a3();
    o7.parse(s10);
    const { width: a9, height: i10, numComponents: l6, eof: h4 } = o7, c5 = o7.getData(a9, i10, true);
    let f6;
    const g5 = a9 * i10;
    let p6 = 0, u7 = 0, m6 = 0;
    if (!r11 && h4 < s10.length - 1)
      try {
        const t7 = new s4(s10.subarray(h4)).getBytes();
        f6 = new Uint8Array(g5);
        let n10 = 0;
        for (p6 = 0; p6 < t7.length; p6++)
          for (m6 = 7; m6 >= 0; m6--)
            f6[n10++] = t7[p6] >> m6 & 1;
      } catch {
      }
    let w3, y4 = null;
    if (1 === l6 && c5.length === a9 * i10)
      y4 = [c5, c5, c5];
    else {
      for (y4 = [], p6 = 0; p6 < 3; p6++)
        w3 = new Uint8Array(g5), y4.push(w3);
      for (m6 = 0, u7 = 0; u7 < g5; u7++)
        for (p6 = 0; p6 < 3; p6++)
          y4[p6][u7] = c5[m6++];
    }
    return { width: a9, height: i10, pixels: y4, mask: f6 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterFormats/Lerc.js
var t3 = [{ pixelType: "S8", size: 1, ctor: Int8Array, range: [-128, 128] }, { pixelType: "U8", size: 1, ctor: Uint8Array, range: [0, 255] }, { pixelType: "S16", size: 2, ctor: Int16Array, range: [-32768, 32767] }, { pixelType: "U16", size: 2, ctor: Uint16Array, range: [0, 65536] }, { pixelType: "S32", size: 4, ctor: Int32Array, range: [-2147483648, 2147483647] }, { pixelType: "U32", size: 4, ctor: Uint32Array, range: [0, 4294967296] }, { pixelType: "F32", size: 4, ctor: Float32Array, range: [-34027999387901484e22, 34027999387901484e22] }, { pixelType: "F64", size: 8, ctor: Float64Array, range: [-17976931348623157e292, 17976931348623157e292] }];
var n4 = null;
var r5 = false;
function a4() {
  return n4 || (n4 = import("./lerc-wasm-BD4NQHNE.js").then((e8) => e8.l).then(({ default: t7 }) => t7({ locateFile: (t8) => a(`esri/layers/support/rasterFormats/${t8}`) })).then((e8) => {
    u2(e8), r5 = true;
  }), n4);
}
var i4 = { getBlobInfo: null, decode: null };
function o3(e8) {
  return 16 + (e8 >> 3 << 3);
}
function s5(e8, t7, n9) {
  n9.set(e8.slice(t7, t7 + n9.length));
}
function u2(e8) {
  const { _malloc: n9, _free: r11, _lerc_getBlobInfo: a9, _lerc_getDataRanges: l6, _lerc_decode_4D: u7, asm: f6 } = e8;
  let c5;
  const y4 = Object.values(f6).find((t7) => t7 && "buffer" in t7 && t7.buffer === e8.HEAPU8.buffer), p6 = (e9) => {
    const t7 = e9.map((e10) => o3(e10)), r12 = t7.reduce((e10, t8) => e10 + t8), a10 = n9(r12);
    c5 = new Uint8Array(y4.buffer);
    let l7 = t7[0];
    t7[0] = a10;
    for (let n10 = 1; n10 < t7.length; n10++) {
      const e10 = t7[n10];
      t7[n10] = t7[n10 - 1] + l7, l7 = e10;
    }
    return t7;
  };
  i4.getBlobInfo = (e9) => {
    const t7 = 12, n10 = 3, i10 = new Uint8Array(4 * t7), o7 = new Uint8Array(8 * n10), [u8, f7, h4] = p6([e9.length, i10.length, o7.length]);
    c5.set(e9, u8), c5.set(i10, f7), c5.set(o7, h4);
    let g5 = a9(u8, e9.length, f7, h4, t7, n10);
    if (g5)
      throw r11(u8), `lerc-getBlobInfo: error code is ${g5}`;
    c5 = new Uint8Array(y4.buffer), s5(c5, f7, i10), s5(c5, h4, o7);
    const d5 = new Uint32Array(i10.buffer), b3 = new Float64Array(o7.buffer), [m6, A3, w3, U4, x4, T4, C4, V2, z2, , D4] = d5, F = { version: m6, dimCount: w3, width: U4, height: x4, validPixelCount: C4, bandCount: T4, blobSize: V2, maskCount: z2, dataType: A3, minValue: b3[0], maxValue: b3[1], maxZerror: b3[2], statistics: [], bandCountWithNoData: D4 };
    if (D4)
      return F;
    if (1 === w3 && 1 === T4)
      return r11(u8), F.statistics.push({ minValue: b3[0], maxValue: b3[1] }), F;
    const I3 = w3 * T4 * 8, _3 = new Uint8Array(I3), k4 = new Uint8Array(I3);
    let B2 = u8, v4 = 0, S4 = 0, O3 = false;
    if (c5.byteLength < u8 + 2 * I3 ? (r11(u8), O3 = true, [B2, v4, S4] = p6([e9.length, I3, I3]), c5.set(e9, B2)) : [v4, S4] = p6([I3, I3]), c5.set(_3, v4), c5.set(k4, S4), g5 = l6(B2, e9.length, w3, T4, v4, S4), g5)
      throw r11(B2), O3 || r11(v4), `lerc-getDataRanges: error code is ${g5}`;
    c5 = new Uint8Array(y4.buffer), s5(c5, v4, _3), s5(c5, S4, k4);
    const $ = new Float64Array(_3.buffer), j2 = new Float64Array(k4.buffer), M3 = F.statistics;
    for (let r12 = 0; r12 < T4; r12++)
      if (w3 > 1) {
        const e10 = $.slice(r12 * w3, (r12 + 1) * w3), t8 = j2.slice(r12 * w3, (r12 + 1) * w3), n11 = Math.min.apply(null, e10), a10 = Math.max.apply(null, t8);
        M3.push({ minValue: n11, maxValue: a10, dimStats: { minValues: e10, maxValues: t8 } });
      } else
        M3.push({ minValue: $[r12], maxValue: j2[r12] });
    return r11(B2), O3 || r11(v4), F;
  }, i4.decode = (e9, n10) => {
    const { maskCount: a10, dimCount: l7, bandCount: i10, width: o7, height: f7, dataType: h4, bandCountWithNoData: g5 } = n10, d5 = t3[h4], b3 = o7 * f7, m6 = new Uint8Array(b3 * i10), A3 = b3 * l7 * i10 * d5.size, w3 = new Uint8Array(A3), U4 = new Uint8Array(i10), x4 = new Uint8Array(8 * i10), [T4, C4, V2, z2, D4] = p6([e9.length, m6.length, w3.length, U4.length, x4.length]);
    c5.set(e9, T4), c5.set(m6, C4), c5.set(w3, V2), c5.set(U4, z2), c5.set(x4, D4);
    const F = u7(T4, e9.length, a10, C4, l7, o7, f7, i10, h4, V2, z2, D4);
    if (F)
      throw r11(T4), `lerc-decode: error code is ${F}`;
    c5 = new Uint8Array(y4.buffer), s5(c5, V2, w3), s5(c5, C4, m6);
    let I3 = null;
    if (g5) {
      s5(c5, z2, U4), s5(c5, D4, x4), I3 = [];
      const e10 = new Float64Array(x4.buffer);
      for (let t7 = 0; t7 < U4.length; t7++)
        I3.push(U4[t7] ? e10[t7] : null);
    }
    return r11(T4), { data: w3, maskData: m6, noDataValues: I3 };
  };
}
function f(e8, t7, n9, r11, a9) {
  if (n9 < 2)
    return e8;
  const l6 = new r11(t7 * n9);
  if (a9)
    for (let i10 = 0, o7 = 0; i10 < t7; i10++)
      for (let r12 = 0, a10 = i10; r12 < n9; r12++, a10 += t7)
        l6[a10] = e8[o7++];
  else
    for (let i10 = 0, o7 = 0; i10 < t7; i10++)
      for (let r12 = 0, a10 = i10; r12 < n9; r12++, a10 += t7)
        l6[o7++] = e8[a10];
  return l6;
}
function c(e8, n9 = {}) {
  const r11 = n9.inputOffset ?? 0, a9 = e8 instanceof Uint8Array ? e8.subarray(r11) : new Uint8Array(e8, r11), l6 = i4.getBlobInfo(a9), { data: o7, maskData: s10 } = i4.decode(a9, l6), { width: u7, height: c5, bandCount: y4, dimCount: p6, dataType: h4, maskCount: g5, statistics: d5 } = l6, b3 = t3[h4], m6 = new b3.ctor(o7.buffer), A3 = [], w3 = [], U4 = u7 * c5, x4 = U4 * p6;
  for (let t7 = 0; t7 < y4; t7++) {
    const e9 = m6.subarray(t7 * x4, (t7 + 1) * x4);
    if (n9.returnPixelInterleavedDims)
      A3.push(e9);
    else {
      const t8 = f(e9, U4, p6, b3.ctor, true);
      A3.push(t8);
    }
    w3.push(s10.subarray(t7 * x4, (t7 + 1) * x4));
  }
  const T4 = 0 === g5 ? null : 1 === g5 ? w3[0] : new Uint8Array(U4);
  if (g5 > 1) {
    T4.set(w3[0]);
    for (let e9 = 1; e9 < w3.length; e9++) {
      const t7 = w3[e9];
      for (let e10 = 0; e10 < U4; e10++)
        T4[e10] = T4[e10] & t7[e10];
    }
  }
  const { noDataValue: C4 } = n9, V2 = null != C4 && b3.range[0] <= C4 && b3.range[1] >= C4;
  if (g5 > 0 && V2)
    for (let t7 = 0; t7 < y4; t7++) {
      const e9 = A3[t7], n10 = w3[t7] || T4;
      for (let t8 = 0; t8 < U4; t8++)
        0 === n10[t8] && (e9[t8] = C4);
    }
  const z2 = g5 === y4 && y4 > 1 ? w3 : null;
  return { width: u7, height: c5, bandCount: y4, pixelType: n9.pixelType && 0 === l6.version ? n9.pixelType : b3.pixelType, dimCount: p6, statistics: d5, pixels: A3, mask: T4, bandMasks: z2 };
}

// node_modules/@arcgis/core/layers/support/rasterFormats/Lzw.js
function e5(e8, n9, t7, r11 = true) {
  if (n9 % 4 != 0 || t7 % 4 != 0) {
    const i10 = new ArrayBuffer(4 * Math.ceil(t7 / 4)), l6 = new Uint8Array(i10), o7 = new Uint8Array(e8, n9, t7);
    if (r11)
      for (let e9 = 0; e9 < l6.length; e9 += 4)
        l6[e9] = o7[e9 + 3], l6[e9 + 1] = o7[e9 + 2], l6[e9 + 2] = o7[e9 + 1], l6[e9 + 3] = o7[e9];
    else
      l6.set(o7);
    return new Uint32Array(l6.buffer);
  }
  if (r11) {
    const r12 = new Uint8Array(e8, n9, t7), i10 = new Uint8Array(r12.length);
    for (let e9 = 0; e9 < i10.length; e9 += 4)
      i10[e9] = r12[e9 + 3], i10[e9 + 1] = r12[e9 + 2], i10[e9 + 2] = r12[e9 + 1], i10[e9 + 3] = r12[e9];
    return new Uint32Array(i10.buffer);
  }
  return new Uint32Array(e8, n9, t7 / 4);
}
function n5() {
  const e8 = [];
  for (let n9 = 0; n9 <= 257; n9++)
    e8[n9] = [n9];
  return e8;
}
function t4(e8, n9) {
  for (let t7 = 0; t7 < n9.length; t7++)
    e8.push(n9[t7]);
}
var r6 = /* @__PURE__ */ new Set();
function i5(i10, l6, o7, f6 = true) {
  const s10 = e5(i10, l6, o7, f6);
  let a9 = 9, c5 = n5(), u7 = 32, h4 = c5.length, d5 = [], g5 = 1, w3 = s10[0], y4 = 0;
  const A3 = s10.length, U4 = 8 * (4 * A3 - o7), p6 = [];
  for (; null != w3; ) {
    if (u7 >= a9)
      u7 -= a9, y4 = w3 >>> 32 - a9, w3 <<= a9;
    else {
      y4 = w3 >>> 32 - u7, w3 = s10[g5++];
      const e9 = a9 - u7;
      u7 = 32 - e9, y4 = (y4 << e9) + (w3 >>> u7), w3 <<= e9;
    }
    if (257 === y4)
      break;
    if (256 === y4) {
      a9 = 9, c5 = n5(), h4 = c5.length, d5 = [];
      continue;
    }
    const e8 = c5[y4];
    if (null == e8) {
      if (y4 > c5.length)
        throw "data integrity issue: code does not exist on code page";
      d5.push(d5[0]), c5[h4++] = d5.slice(), t4(p6, d5);
    } else
      t4(p6, e8), d5.push(e8[0]), d5.length > 1 && (c5[h4++] = d5.slice()), d5 = e8.slice();
    if (r6.has(h4) && a9++, 0 === u7 && (w3 = s10[g5++], u7 = 32), g5 > A3 || g5 === A3 && u7 <= U4)
      break;
  }
  return new Uint8Array(p6);
}
r6.add(511), r6.add(1023), r6.add(2047), r6.add(4095), r6.add(8191);

// node_modules/@arcgis/core/layers/support/rasterFormats/Raw.js
var e6 = (e8, r11) => {
  const a9 = r11.width * r11.height, n9 = r11.pixelType;
  return Math.floor(e8.byteLength / (a9 * t5(n9)));
};
var t5 = (e8) => {
  let t7 = 1;
  switch (e8) {
    case Uint8Array:
    case Int8Array:
      t7 = 1;
      break;
    case Uint16Array:
    case Int16Array:
      t7 = 2;
      break;
    case Uint32Array:
    case Int32Array:
    case Float32Array:
      t7 = 4;
      break;
    case Float64Array:
      t7 = 8;
  }
  return t7;
};
var r7 = (e8, t7) => {
  if (8 * e8.byteLength < t7)
    return null;
  const r11 = new Uint8Array(e8, 0, Math.ceil(t7 / 8)), a9 = new Uint8Array(t7);
  let n9 = 0, s10 = 0, i10 = 0, h4 = 0;
  for (i10 = 0; i10 < r11.length - 1; i10++)
    for (s10 = r11[i10], h4 = 7; h4 >= 0; h4--)
      a9[n9++] = s10 >> h4 & 1;
  for (h4 = 7; n9 < t7 - 1; )
    s10 = r11[r11.length - 1], a9[n9++] = s10 >> h4 & 1, h4--;
  return a9;
};
var a5 = class {
  static decode(a9, n9) {
    const s10 = n9.pixelType, i10 = [], h4 = n9.width * n9.height, l6 = e6(a9, n9), { bandIds: c5, format: y4 } = n9, o7 = c5 && c5.length || e6(a9, n9), b3 = a9.byteLength - a9.byteLength % (h4 * t5(s10)), f6 = new s10(a9, 0, h4 * l6);
    let g5, u7, A3, p6, d5;
    if ("bip" === y4)
      for (g5 = 0; g5 < o7; g5++) {
        for (p6 = new s10(h4), d5 = c5 ? c5[g5] : g5, u7 = 0; u7 < h4; u7++)
          p6[u7] = f6[u7 * l6 + d5];
        i10.push(p6);
      }
    else if ("bsq" === y4)
      for (g5 = 0; g5 < o7; g5++)
        d5 = c5 ? c5[g5] : g5, i10.push(f6.subarray(d5 * h4, (d5 + 1) * h4));
    return b3 < a9.byteLength - 1 && (A3 = r7(a9.slice(b3), h4)), { pixels: i10, mask: A3 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/byteStreamUtils.js
function r8(r11, t7) {
  let n9 = 0, o7 = "", e8 = 0, f6 = 0;
  const c5 = r11.length;
  for (; n9 < c5; )
    f6 = r11[n9++], e8 = f6 >> 4, e8 < 8 ? e8 = 1 : 15 === e8 ? (e8 = 4, f6 = (7 & f6) << 18 | (63 & r11[n9++]) << 12 | (63 & r11[n9++]) << 6 | 63 & r11[n9++]) : 14 === e8 ? (e8 = 3, f6 = (15 & f6) << 12 | (63 & r11[n9++]) << 6 | 63 & r11[n9++]) : (e8 = 2, f6 = (31 & f6) << 6 | 63 & r11[n9++]), (0 !== f6 || t7) && (o7 += String.fromCharCode(f6));
  return o7;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/TiffTags.js
var e7 = (() => {
  const e8 = [];
  return e8[254] = "NEWSUBFILETYPE", e8[255] = "SUBFILETYPE", e8[256] = "IMAGEWIDTH", e8[257] = "IMAGELENGTH", e8[258] = "BITSPERSAMPLE", e8[259] = "COMPRESSION", e8[262] = "PHOTOMETRICINTERPRETATION", e8[263] = "THRESHHOLDING", e8[264] = "CELLWIDTH", e8[265] = "CELLLENGTH", e8[266] = "FILLORDER", e8[269] = "DOCUMENTNAME", e8[270] = "IMAGEDESCRIPTION", e8[271] = "MAKE", e8[272] = "MODEL", e8[273] = "STRIPOFFSETS", e8[274] = "ORIENTATION", e8[277] = "SAMPLESPERPIXEL", e8[278] = "ROWSPERSTRIP", e8[279] = "STRIPBYTECOUNTS", e8[280] = "MINSAMPLEVALUE", e8[281] = "MAXSAMPLEVALUE", e8[282] = "XRESOLUTION", e8[283] = "YRESOLUTION", e8[284] = "PLANARCONFIGURATION", e8[285] = "PAGENAME", e8[286] = "XPOSITION", e8[287] = "YPOSITION", e8[288] = "FREEOFFSETS", e8[289] = "FREEBYTECOUNTS", e8[290] = "GRAYRESPONSEUNIT", e8[291] = "GRAYRESPONSECURVE", e8[292] = "T4OPTIONS", e8[293] = "T6OPTIONS", e8[296] = "RESOLUTIONUNIT", e8[297] = "PAGENUMBER", e8[300] = "COLORRESPONSEUNIT", e8[301] = "TRANSFERFUNCTION", e8[305] = "SOFTWARE", e8[306] = "DATETIME", e8[315] = "ARTIST", e8[316] = "HOSTCOMPUTER", e8[317] = "PREDICTOR", e8[318] = "WHITEPOINT", e8[319] = "PRIMARYCHROMATICITIES", e8[320] = "COLORMAP", e8[321] = "HALFTONEHINTS", e8[322] = "TILEWIDTH", e8[323] = "TILELENGTH", e8[324] = "TILEOFFSETS", e8[325] = "TILEBYTECOUNTS", e8[326] = "BADFAXLINES", e8[327] = "CLEANFAXDATA", e8[328] = "CONSECUTIVEBADFAXLINES", e8[330] = "SUBIFD", e8[332] = "INKSET", e8[333] = "INKNAMES", e8[334] = "NUMBEROFINKS", e8[336] = "DOTRANGE", e8[337] = "TARGETPRINTER", e8[338] = "EXTRASAMPLES", e8[339] = "SAMPLEFORMAT", e8[340] = "SMINSAMPLEVALUE", e8[341] = "SMAXSAMPLEVALUE", e8[342] = "TRANSFERRANGE", e8[347] = "JPEGTABLES", e8[512] = "JPEGPROC", e8[513] = "JPEGIFOFFSET", e8[514] = "JPEGIFBYTECOUNT", e8[515] = "JPEGRESTARTINTERVAL", e8[517] = "JPEGLOSSLESSPREDICTORS", e8[518] = "JPEGPOINTTRANSFORM", e8[519] = "JPEGQTABLES", e8[520] = "JPEGDCTABLES", e8[521] = "JPEGACTABLES", e8[529] = "YCBCRCOEFFICIENTS", e8[530] = "YCBCRSUBSAMPLING", e8[531] = "YCBCRPOSITIONING", e8[532] = "REFERENCEBLACKWHITE", e8[700] = "XMP", e8[33550] = "GEOPIXELSCALE", e8[33922] = "GEOTIEPOINTS", e8[33432] = "COPYRIGHT", e8[42112] = "GDAL_METADATA", e8[42113] = "GDAL_NODATA", e8[50844] = "RPCCOEFFICIENT", e8[34264] = "GEOTRANSMATRIX", e8[34735] = "GEOKEYDIRECTORY", e8[34736] = "GEODOUBLEPARAMS", e8[34737] = "GEOASCIIPARAMS", e8[34665] = "EXIFIFD", e8[34853] = "GPSIFD", e8[40965] = "INTEROPERABILITYIFD", e8;
})();
var i6 = (() => {
  const i10 = [].concat(e7);
  return i10[36864] = "ExifVersion", i10[40960] = "FlashpixVersion", i10[40961] = "ColorSpace", i10[42240] = "Gamma", i10[37121] = "ComponentsConfiguration", i10[37122] = "CompressedBitsPerPixel", i10[40962] = "PixelXDimension", i10[40963] = "PixelYDimension", i10[37500] = "MakerNote", i10[37510] = "UserComment", i10[40964] = "RelatedSoundFile", i10[36867] = "DateTimeOriginal", i10[36868] = "DateTimeDigitized", i10[36880] = "OffsetTime", i10[36881] = "OffsetTimeOriginal", i10[36882] = "OffsetTimeDigitized", i10[37520] = "SubSecTime", i10[37521] = "SubSecTimeOriginal", i10[37522] = "SubSecTimeDigitized", i10[37888] = "Temperature", i10[37889] = "Humidity", i10[37890] = "Pressure", i10[37891] = "WaterDepth", i10[37892] = "Acceleration", i10[37893] = "CameraElevationAngle", i10[42016] = "ImageUniqueID", i10[42032] = "CameraOwnerName", i10[42033] = "BodySerialNumber", i10[42034] = "LensSpecification", i10[42035] = "LensMake", i10[42036] = "LensModel", i10[42037] = "LensSerialNumber", i10[33434] = "ExposureTime", i10[33437] = "FNumber", i10[34850] = "ExposureProgram", i10[34852] = "SpectralSensitivity", i10[34855] = "PhotographicSensitivity", i10[34856] = "OECF", i10[34864] = "SensitivityType", i10[34865] = "StandardOutputSensitivity", i10[34866] = "RecommendedExposureIndex", i10[34867] = "ISOSpeed", i10[34868] = "ISOSpeedLatitudeyyy", i10[34869] = "ISOSpeedLatitudezzz", i10[37377] = "ShutterSpeedValue", i10[37378] = "ApertureValue", i10[37379] = "BrightnessValue", i10[37380] = "ExposureBiasValue", i10[37381] = "MaxApertureValue", i10[37382] = "SubjectDistance", i10[37383] = "MeteringMode", i10[37384] = "LightSource", i10[37385] = "Flash", i10[37386] = "FocalLength", i10[37396] = "SubjectArea", i10[41483] = "FlashEnergy", i10[41484] = "SpatialFrequencyResponse", i10[41486] = "FocalPlaneXResolution", i10[41487] = "FocalPlaneYResolution", i10[41488] = "FocalPlaneResolutionUnit", i10[41492] = "SubjectLocation", i10[41493] = "ExposureIndex", i10[41495] = "SensingMethod", i10[41728] = "FileSource", i10[41729] = "SceneType", i10[41730] = "CFAPattern", i10[41985] = "CustomRendered", i10[41986] = "ExposureMode", i10[41987] = "WhiteBalance", i10[41988] = "DigitalZoomRatio", i10[41989] = "FocalLengthIn35mmFilm", i10[41990] = "SceneCaptureType", i10[41991] = "GainControl", i10[41992] = "Contrast", i10[41993] = "Saturation", i10[41994] = "Sharpness", i10[41995] = "DeviceSettingDescription", i10[41996] = "SubjectDistanceRange", i10;
})();
var t6 = ["GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef", "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp", "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP", "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack", "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum", "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef", "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing", "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod", "GPSAreaInformation", "GPSDateStamp", "GPSDifferential", "GPSHPositioningError"];
var o4 = (() => {
  const e8 = [];
  return e8[1024] = "GTModelTypeGeoKey", e8[1025] = "GTRasterTypeGeoKey", e8[1026] = "GTCitationGeoKey", e8[2048] = "GeographicTypeGeoKey", e8[2049] = "GeogCitationGeoKey", e8[2050] = "GeogGeodeticDatumGeoKey", e8[2051] = "GeogPrimeMeridianGeoKey", e8[2052] = "GeogLinearUnitsGeoKey", e8[2053] = "GeogLinearUnitSizeGeoKey", e8[2054] = "GeogAngularUnitsGeoKey", e8[2055] = "GeogAngularUnitSizeGeoKey", e8[2056] = "GeogEllipsoidGeoKey", e8[2057] = "GeogSemiMajorAxisGeoKey", e8[2058] = "GeogSemiMinorAxisGeoKey", e8[2059] = "GeogInvFlatteningGeoKey", e8[2061] = "GeogPrimeMeridianLongGeoKey", e8[2060] = "GeogAzimuthUnitsGeoKey", e8[3072] = "ProjectedCSTypeGeoKey", e8[3073] = "PCSCitationGeoKey", e8[3074] = "ProjectionGeoKey", e8[3075] = "ProjCoordTransGeoKey", e8[3076] = "ProjLinearUnitsGeoKey", e8[3077] = "ProjLinearUnitSizeGeoKey", e8[3078] = "ProjStdParallel1GeoKey", e8[3079] = "ProjStdParallel2GeoKey", e8[3080] = "ProjNatOriginLongGeoKey", e8[3081] = "ProjNatOriginLatGeoKey", e8[3082] = "ProjFalseEastingGeoKey", e8[3083] = "ProjFalseNorthingGeoKey", e8[3084] = "ProjFalseOriginLongGeoKey", e8[3085] = "ProjFalseOriginLatGeoKey", e8[3086] = "ProjFalseOriginEastingGeoKey", e8[3087] = "ProjFalseOriginNorthingGeoKey", e8[3088] = "ProjCenterLongGeoKey", e8[3090] = "ProjCenterEastingGeoKey", e8[3091] = "ProjCenterNorthingGeoKey", e8[3092] = "ProjScaleAtNatOriginGeoKey", e8[3093] = "ProjScaleAtCenterGeoKey", e8[3094] = "ProjAzimuthAngleGeoKey", e8[3095] = "ProjStraightVertPoleLongGeoKey", e8[4096] = "VerticalCSTypeGeoKey", e8[4097] = "VerticalCitationGeoKey", e8[4098] = "VerticalDatumGeoKey", e8[4099] = "VerticalUnitsGeoKey", e8;
})();
var S = (i10, t7) => {
  let o7 = (t7 || e7)[i10];
  return void 0 === o7 && (o7 = "unknown" + String(i10)), o7;
};
var E = /* @__PURE__ */ new Map();
E.set("EXIFIFD", i6), E.set("GPSIFD", t6);
var n6 = { TIFF_TAGS: e7, ifdTags: E, GEO_KEYS: o4, getTagName: S };

// node_modules/@arcgis/core/layers/support/rasterFormats/utils.js
var r9 = (() => {
  const r11 = new ArrayBuffer(4), n9 = new Uint8Array(r11);
  return new Uint32Array(r11)[0] = 1, 1 === n9[0];
})();

// node_modules/@arcgis/core/layers/support/rasterFormats/TiffDecoder.js
var o5 = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, -1, -1, -1, 8, 8, 8];
var f2 = 4294967296;
var c2 = /* @__PURE__ */ new Set([1, 5, 6, 7, 8, 34712, 34887]);
function u3(e8, t7) {
  let n9 = "unknown";
  return 3 === e8 ? n9 = "f32" : 1 === e8 ? 1 === t7 ? n9 = "u1" : 2 === t7 ? n9 = "u2" : 4 === t7 ? n9 = "u4" : t7 <= 8 ? n9 = "u8" : t7 <= 16 ? n9 = "u16" : t7 <= 32 && (n9 = "u32") : 2 === e8 && (t7 <= 8 ? n9 = "s8" : t7 <= 16 ? n9 = "s16" : t7 <= 32 && (n9 = "s32")), n9;
}
function h(e8) {
  let t7 = null;
  switch (e8 ? e8.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      t7 = Uint8Array;
      break;
    case "u16":
      t7 = Uint16Array;
      break;
    case "u32":
      t7 = Uint32Array;
      break;
    case "s8":
      t7 = Int8Array;
      break;
    case "s16":
      t7 = Int16Array;
      break;
    case "s32":
      t7 = Int32Array;
      break;
    default:
      t7 = Float32Array;
  }
  return t7;
}
function g(e8, t7) {
  return { x: t7[0] * e8.x + t7[1] * e8.y + t7[2], y: t7[3] * e8.x + t7[4] * e8.y + t7[5] };
}
function w(e8, t7) {
  var _a;
  return (_a = e8.get(t7)) == null ? void 0 : _a.values;
}
function p3(e8, t7) {
  var _a;
  return (_a = e8.get(t7)) == null ? void 0 : _a.values;
}
function d2(e8, t7) {
  var _a;
  return (_a = e8.get(t7)) == null ? void 0 : _a.values[0];
}
function I(e8, t7) {
  var _a;
  return (_a = e8.get(t7)) == null ? void 0 : _a.values[0];
}
function T(e8, t7, n9, a9 = 0, i10 = n6.TIFF_TAGS, r11 = 4) {
  const l6 = 8 === r11, o7 = l6 ? U(new DataView(e8, n9, 8), 0, t7) : new DataView(e8, n9, 2).getUint16(0, t7), f6 = 4 + 2 * r11, c5 = l6 ? 8 : 2, u7 = c5 + o7 * f6;
  if (n9 + u7 > e8.byteLength)
    return { success: false, ifd: null, nextIFD: null, requiredBufferSize: u7 };
  const h4 = n9 + u7 + 4 <= e8.byteLength ? P(new DataView(e8, n9 + u7, 8 === r11 ? 8 : 4), 0, t7, 8 === r11) : null, g5 = n9 + c5, w3 = /* @__PURE__ */ new Map();
  let p6, d5, I3, T4, E3, y4, m6;
  for (let A3 = 0; A3 < o7; A3++) {
    d5 = new DataView(e8, g5 + f6 * A3, f6), I3 = d5.getUint16(0, t7), E3 = d5.getUint16(2, t7), T4 = n6.getTagName(I3, i10);
    const n10 = [];
    2 === r11 ? (y4 = d5.getUint16(4, t7), m6 = d5.getUint16(6, t7)) : 4 === r11 ? (y4 = d5.getUint32(4, t7), m6 = d5.getUint32(8, t7)) : 8 === r11 && (y4 = P(d5, 4, t7, true), m6 = P(d5, 12, t7, true), n10.push(d5.getUint32(12, t7)), n10.push(d5.getUint32(16, t7))), p6 = { id: I3, type: E3, valueCount: y4, valueOffset: m6, valueOffsets: n10, values: null }, x(e8, t7, p6, a9, false, r11), w3.set(T4, p6);
  }
  return { success: true, ifd: w3, nextIFD: h4, requiredBufferSize: u7 };
}
var E2 = (e8, t7) => c(e8, { inputOffset: t7 }).pixels[0];
async function y2(e8, a9, s10, o7, f6) {
  const c5 = r9 === a9, g5 = I(s10, "BITSPERSAMPLE"), w3 = u3(I(s10, "SAMPLEFORMAT") ?? 1, g5), p6 = I(s10, "COMPRESSION") ?? 1, d5 = h(w3);
  let T4, y4, m6, A3, S4, M3, x4;
  if (34887 === p6)
    return await a4(), E2(e8, o7);
  if (1 === p6)
    m6 = e8.slice(o7, o7 + f6), A3 = new Uint8Array(m6);
  else if (8 === p6 || 32946 === p6)
    A3 = new Uint8Array(e8, o7, f6), M3 = new s4(A3), x4 = M3.getBytes(), m6 = new ArrayBuffer(x4.length), A3 = new Uint8Array(m6), A3.set(x4);
  else if (6 === p6) {
    A3 = new Uint8Array(e8, o7, f6);
    const n9 = new a3();
    n9.parse(A3);
    const a10 = n9.getData(n9.width, n9.height, true);
    m6 = new ArrayBuffer(a10.length), A3 = new Uint8Array(m6), A3.set(a10);
  } else if (7 === p6) {
    const n9 = s10.get("JPEGTABLES").values, a10 = n9.length - 2;
    A3 = new Uint8Array(a10 + f6 - 2);
    for (let e9 = 0; e9 < a10; e9++)
      A3[e9] = n9[e9];
    const i10 = new Uint8Array(e8, o7 + 2, f6 - 2);
    for (let e9 = 0; e9 < i10.length; e9++)
      A3[a10 + e9] = i10[e9];
    const r11 = new a3();
    r11.parse(A3);
    const l6 = r11.getData(r11.width, r11.height, true);
    m6 = new ArrayBuffer(l6.length), A3 = new Uint8Array(m6), A3.set(l6);
  } else
    5 === p6 && (A3 = i5(e8, o7, f6, a9), m6 = A3.buffer);
  if ("u8" === w3 || "s8" === w3 || c5)
    y4 = new d5(m6);
  else {
    switch (m6 = new ArrayBuffer(A3.length), S4 = new Uint8Array(m6), w3) {
      case "u16":
      case "s16":
        for (T4 = 0; T4 < A3.length; T4 += 2)
          S4[T4] = A3[T4 + 1], S4[T4 + 1] = A3[T4];
        break;
      case "u32":
      case "s32":
      case "f32":
        for (T4 = 0; T4 < A3.length; T4 += 4)
          S4[T4] = A3[T4 + 3], S4[T4 + 1] = A3[T4 + 2], S4[T4 + 2] = A3[T4 + 1], S4[T4 + 3] = A3[T4];
    }
    y4 = new d5(m6);
  }
  return y4;
}
async function m2(e8, t7, n9) {
  const a9 = p3(n9, "TILEOFFSETS");
  if (void 0 === a9)
    return null;
  const i10 = p3(n9, "TILEBYTECOUNTS"), { width: s10, height: r11, pixelType: l6, tileWidth: o7, tileHeight: f6 } = b([n9]), c5 = D(n9, t7), u7 = t7.planes, g5 = s10 * r11, w3 = I(n9, "BITSPERSAMPLE"), d5 = 34887 === (I(n9, "COMPRESSION") ?? 1), T4 = h(l6), E3 = [];
  for (let h4 = 0; h4 < u7; h4++)
    E3.push(new T4(g5));
  let m6, A3, S4, M3, x4, O3, U4, L3, P3, N2, k4, G2, R3;
  const C4 = Math.ceil(s10 / o7);
  if (w3 % 8 == 0) {
    if (d5 && c5 && u7 > 1) {
      const l7 = Math.round(a9.length / u7);
      for (m6 = 0; m6 < l7; m6++) {
        O3 = Math.floor(m6 / C4) * f6, U4 = m6 % C4 * o7, L3 = O3 * s10 + U4;
        for (let l8 = 0; l8 < u7; l8++) {
          const c6 = m6 * u7 + l8;
          if (0 !== i10[c6])
            for (S4 = await y2(e8, t7.littleEndian, n9, a9[c6], i10[c6]), N2 = 0, P3 = L3, G2 = Math.min(o7, s10 - U4), k4 = Math.min(f6, r11 - O3), R3 = E3[l8], M3 = 0; M3 < k4; M3++)
              for (P3 = L3 + M3 * s10, N2 = M3 * o7, x4 = 0; x4 < G2; x4++, P3++, N2++)
                R3[P3] = S4[N2];
        }
      }
    } else
      for (m6 = 0; m6 < a9.length; m6++)
        if (0 !== i10[m6])
          for (O3 = Math.floor(m6 / C4) * f6, U4 = m6 % C4 * o7, L3 = O3 * s10 + U4, S4 = await y2(e8, t7.littleEndian, n9, a9[m6], i10[m6]), N2 = 0, P3 = L3, G2 = Math.min(o7, s10 - U4), k4 = Math.min(f6, r11 - O3), A3 = 0; A3 < u7; A3++)
            if (R3 = E3[A3], c5 || d5)
              for (M3 = 0; M3 < k4; M3++)
                for (P3 = L3 + M3 * s10, N2 = o7 * f6 * A3 + M3 * o7, x4 = 0; x4 < G2; x4++, P3++, N2++)
                  R3[P3] = S4[N2];
            else
              for (M3 = 0; M3 < k4; M3++)
                for (P3 = L3 + M3 * s10, N2 = M3 * o7 * u7 + A3, x4 = 0; x4 < G2; x4++, P3++, N2 += u7)
                  R3[P3] = S4[N2];
  }
  return { width: s10, height: r11, pixelType: l6, pixels: E3 };
}
var A = (e8, n9, a9) => {
  const s10 = r9 === n9.littleEndian, o7 = p3(a9, "STRIPOFFSETS");
  if (void 0 === o7)
    return null;
  const { width: f6, height: c5, pixelType: u7 } = b([a9]), g5 = n9.planes, w3 = f6 * c5, d5 = I(a9, "BITSPERSAMPLE"), T4 = h(u7), E3 = new T4(w3 * g5), y4 = p3(a9, "STRIPBYTECOUNTS"), m6 = I(a9, "ROWSPERSTRIP"), A3 = I(a9, "COMPRESSION") ?? 1;
  let S4, M3, x4, D4, O3, U4, L3, P3, N2, k4, G2, R3 = m6;
  if (d5 % 8 == 0)
    for (S4 = 0; S4 < o7.length; S4++) {
      if (O3 = S4 * (m6 * f6) * g5, R3 = (S4 + 1) * m6 > c5 ? c5 - S4 * m6 : m6, "u8" === u7 || "s8" === u7 || s10) {
        if (8 === A3 || 32946 === A3)
          L3 = new Uint8Array(e8, o7[S4], y4[S4]), k4 = new s4(L3), G2 = k4.getBytes(), U4 = new ArrayBuffer(G2.length), L3 = new Uint8Array(U4), L3.set(G2), L3.length !== R3 * f6 * g5 * d5 / 8 && console.log("strip byte counts is different than expected");
        else if (6 === A3) {
          L3 = new Uint8Array(e8, o7[S4], y4[S4]);
          const n10 = new a3();
          n10.parse(L3);
          const a10 = n10.getData(n10.width, n10.height, true);
          U4 = new ArrayBuffer(a10.length), L3 = new Uint8Array(U4), L3.set(a10);
        } else
          5 === A3 ? (L3 = i5(e8, o7[S4], y4[S4], n9.littleEndian), U4 = L3.buffer) : 1 === A3 && (y4[S4] !== R3 * f6 * g5 * d5 / 8 && console.log("strip byte counts is different than expected"), U4 = e8.slice(o7[S4], o7[S4] + y4[S4]));
        D4 = new T4(U4);
      } else {
        switch (6 === A3 || 8 === A3 || 32946 === A3 ? (L3 = new Uint8Array(e8, o7[S4], y4[S4]), k4 = new s4(L3), L3 = k4.getBytes(), U4 = new ArrayBuffer(L3.length), P3 = new Uint8Array(U4), L3.length !== R3 * f6 * g5 * d5 / 8 && console.log("strip byte counts is different than expected")) : 1 === A3 && (y4[S4] !== R3 * f6 * g5 * d5 / 8 && console.log("strip byte counts is different than expected"), U4 = new ArrayBuffer(y4[S4]), L3 = new Uint8Array(e8, o7[S4], y4[S4]), P3 = new Uint8Array(U4)), u7) {
          case "u16":
          case "s16":
            for (x4 = 0; x4 < L3.length; x4 += 2)
              P3[x4] = L3[x4 + 1], P3[x4 + 1] = L3[x4];
            break;
          case "u32":
          case "s32":
          case "f32":
            for (x4 = 0; x4 < L3.length; x4 += 4)
              P3[x4] = L3[x4 + 3], P3[x4 + 1] = L3[x4 + 2], P3[x4 + 2] = L3[x4 + 1], P3[x4 + 3] = L3[x4];
        }
        D4 = new T4(U4);
      }
      E3.set(D4, O3);
    }
  const C4 = [];
  if (1 === g5)
    C4.push(E3);
  else
    for (S4 = 0; S4 < g5; S4++) {
      for (N2 = new T4(w3), M3 = 0; M3 < w3; M3++)
        N2[M3] = E3[M3 * g5 + S4];
      C4.push(N2);
    }
  return { width: f6, height: c5, pixelType: u7, pixels: C4 };
};
var S2 = (e8, t7, n9) => {
  if (!(e8 && e8.length > 0 && t7 && n9))
    return null;
  let a9, i10, s10;
  const r11 = e8[0].length, l6 = e8.length, o7 = new Uint8Array(r11);
  for (let f6 = 0; f6 < l6; f6++)
    if (a9 = e8[f6], i10 = t7[f6], s10 = n9[f6], 0 === f6)
      for (let e9 = 0; e9 < r11; e9++)
        o7[e9] = a9[e9] < i10 || a9[e9] > s10 ? 0 : 1;
    else
      for (let e9 = 0; e9 < r11; e9++)
        o7[e9] && (o7[e9] = a9[e9] < i10 || a9[e9] > s10 ? 0 : 1);
  return o7;
};
var M2 = (e8) => {
  if (!e8)
    return null;
  const t7 = e8.match(/<Item(.*?)Item>/gi);
  if (!t7 || 0 === t7.length)
    return null;
  const n9 = /* @__PURE__ */ new Map();
  let a9, i10, s10, r11, l6;
  for (let I3 = 0; I3 < t7.length; I3++)
    a9 = t7[I3], i10 = a9.slice("<Item ".length, a9.indexOf(">")), r11 = a9.indexOf("sample="), r11 > -1 && (l6 = a9.slice(r11 + 'sample="'.length, a9.indexOf('"', r11 + 'sample="'.length))), r11 = a9.indexOf("name="), r11 > -1 && (i10 = a9.slice(r11 + 'name="'.length, a9.indexOf('"', r11 + 'name="'.length))), i10 && (s10 = a9.slice(a9.indexOf(">") + 1, a9.indexOf("</Item>")).trim(), null != l6 ? n9.has(i10) ? n9.get(i10)[l6] = s10 : n9.set(i10, [s10]) : n9.set(i10, s10)), l6 = null;
  const o7 = n9.get("STATISTICS_MINIMUM"), f6 = n9.get("STATISTICS_MAXIMUM"), c5 = n9.get("STATISTICS_MEAN"), u7 = n9.get("STATISTICS_STDDEV");
  let h4 = null;
  if (o7 && f6) {
    h4 = [];
    for (let e9 = 0; e9 < o7.length; e9++)
      h4.push({ min: parseFloat(o7[e9]), max: parseFloat(f6[e9]), avg: c5 && parseFloat(c5[e9]), stddev: u7 && parseFloat(u7[e9]) });
  }
  const g5 = n9.get("BandName"), w3 = n9.get("WavelengthMin"), p6 = n9.get("WavelengthMax");
  let d5 = null;
  if (g5) {
    d5 = [];
    for (let e9 = 0; e9 < g5.length; e9++)
      d5.push({ BandName: g5[e9], WavelengthMin: w3 && parseFloat(w3[e9]), WavelengthMax: p6 && parseFloat(p6[e9]) });
  }
  return { statistics: h4, bandProperties: d5, dataType: n9.get("DataType"), rawMetadata: n9 };
};
function x(e8, t7, n9, a9 = 0, i10 = false, s10 = 4) {
  if (n9.values)
    return true;
  const r11 = n9.type, l6 = n9.valueCount;
  let c5 = n9.valueOffset, u7 = [];
  const h4 = o5[r11], g5 = 8 * h4, w3 = l6 * h4, p6 = l6 * o5[r11] * 8;
  let d5, I3;
  const T4 = 8 === s10 ? 64 : 32, E3 = n9.valueOffsets;
  if (p6 > T4) {
    if (w3 > (i10 ? e8.byteLength : e8 ? e8.byteLength - c5 + a9 : 0))
      return n9.offlineOffsetSize = [c5, w3], n9.values = null, false;
  }
  if (p6 <= T4) {
    if (!t7)
      if (T4 <= 32)
        c5 >>>= 32 - p6;
      else {
        const e9 = (E3 == null ? void 0 : E3.length) ? E3[0] : c5 >>> 0, t8 = (E3 == null ? void 0 : E3.length) ? E3[1] : Math.round((c5 - e9) / f2);
        p6 <= 32 ? (c5 = e9 >>> 32 - p6, E3[0] = c5) : (c5 = e9 * 2 ** (32 - p6) + (t8 >>> 32 - p6), E3[0] = e9, E3[1] = t8 >>> 32 - p6);
      }
    if (1 === l6 && g5 === T4)
      u7 = [c5];
    else if (64 === T4) {
      const e9 = (E3 == null ? void 0 : E3.length) ? E3[0] : c5 >>> 0, t8 = (E3 == null ? void 0 : E3.length) ? E3[1] : Math.round((c5 - e9) / f2);
      let n10 = e9, a10 = 32;
      for (I3 = 1; I3 <= l6; I3++) {
        const e10 = 32 - g5 * I3 % 32;
        if (a10 < g5) {
          const i11 = n10 << e10 >>> 32 - a10, s11 = t8 << 32 - a10 >>> 32 - a10;
          n10 = t8, u7.push(i11 + s11 * 2 ** (g5 - a10)), a10 -= 32 - (g5 - a10);
        } else
          u7.push(n10 << e10 >>> 32 - g5), a10 -= g5;
        0 === a10 && (a10 = 32, n10 = t8);
      }
    } else
      for (I3 = 1; I3 <= l6; I3++) {
        const e9 = 32 - g5 * I3;
        u7.push(c5 << e9 >>> 32 - g5);
      }
  } else {
    c5 -= a9, i10 && (c5 = 0);
    for (let n10 = c5; n10 < c5 + w3; n10 += h4) {
      switch (r11) {
        case 1:
        case 2:
        case 7:
          d5 = new DataView(e8, n10, 1).getUint8(0);
          break;
        case 3:
          d5 = new DataView(e8, n10, 2).getUint16(0, t7);
          break;
        case 4:
        case 13:
          d5 = new DataView(e8, n10, 4).getUint32(0, t7);
          break;
        case 5:
          d5 = new DataView(e8, n10, 4).getUint32(0, t7) / new DataView(e8, n10 + 4, 4).getUint32(0, t7);
          break;
        case 6:
          d5 = new DataView(e8, n10, 1).getInt8(0);
          break;
        case 8:
          d5 = new DataView(e8, n10, 2).getInt16(0, t7);
          break;
        case 9:
          d5 = new DataView(e8, n10, 4).getInt32(0, t7);
          break;
        case 10:
          d5 = new DataView(e8, n10, 4).getInt32(0, t7) / new DataView(e8, n10 + 4, 4).getInt32(0, t7);
          break;
        case 11:
          d5 = new DataView(e8, n10, 4).getFloat32(0, t7);
          break;
        case 12:
          d5 = new DataView(e8, n10, 8).getFloat64(0, t7);
          break;
        case 16:
        case 18:
          d5 = U(new DataView(e8, n10, 8), 0, t7);
          break;
        case 17:
          d5 = L(new DataView(e8, n10, 8), 0, t7);
          break;
        default:
          d5 = null;
      }
      u7.push(d5);
    }
  }
  if (2 === r11) {
    let e9 = "";
    const t8 = u7;
    for (u7 = [], I3 = 0; I3 < t8.length; I3++)
      0 === t8[I3] && "" !== e9 ? (u7.push(e9), e9 = "") : e9 += String.fromCharCode(t8[I3]);
    "" === e9 && 0 !== u7.length || u7.push(e9);
  }
  return n9.values = u7, true;
}
function b(e8) {
  const t7 = e8[0], n9 = I(t7, "TILEWIDTH"), a9 = I(t7, "TILELENGTH"), i10 = I(t7, "IMAGEWIDTH"), s10 = I(t7, "IMAGELENGTH"), r11 = I(t7, "BITSPERSAMPLE"), l6 = I(t7, "SAMPLESPERPIXEL"), o7 = I(t7, "SAMPLEFORMAT") ?? 1, f6 = u3(o7, r11), h4 = D(t7), T4 = w(t7, "GDAL_NODATA");
  let E3;
  (T4 == null ? void 0 : T4.length) && (E3 = T4.map((e9) => parseFloat(e9)), E3.some((e9) => isNaN(e9)) && (E3 = null));
  const y4 = I(t7, "COMPRESSION") ?? 1;
  let m6;
  switch (y4) {
    case 1:
      m6 = "NONE";
      break;
    case 2:
    case 3:
    case 4:
    case 32771:
      m6 = "CCITT";
      break;
    case 5:
      m6 = "LZW";
      break;
    case 6:
    case 7:
      m6 = "JPEG";
      break;
    case 32773:
      m6 = "PACKBITS";
      break;
    case 8:
    case 32946:
      m6 = "DEFLATE";
      break;
    case 34712:
      m6 = "JPEG2000";
      break;
    case 34887:
      m6 = "LERC";
      break;
    default:
      m6 = String(y4);
  }
  let A3 = true, S4 = "";
  c2.has(y4) || (A3 = false, S4 += "unsupported tag compression " + y4), o7 > 3 && (A3 = false, S4 += "unsupported tag sampleFormat " + o7), r11 % 8 != 0 && (A3 = false, S4 += "unsupported tag bitsPerSample " + r11);
  const x4 = d2(t7, "GEOASCIIPARAMS");
  let b3;
  if (x4) {
    const e9 = x4.split("|").find((e10) => e10.includes("ESRI PE String = ")), t8 = e9 ? e9.replace("ESRI PE String = ", "") : "";
    b3 = t8.startsWith("COMPD_CS") || t8.startsWith("PROJCS") || t8.startsWith("GEOGCS") ? { wkid: null, wkt: t8 } : null;
  }
  const O3 = p3(t7, "GEOTIEPOINTS"), U4 = p3(t7, "GEOPIXELSCALE"), L3 = p3(t7, "GEOTRANSMATRIX"), P3 = t7.has("GEOKEYDIRECTORY") ? t7.get("GEOKEYDIRECTORY").data : null;
  let N2, k4, R3 = false;
  if (P3) {
    R3 = 2 === I(P3, "GTRasterTypeGeoKey");
    const e9 = I(P3, "GTModelTypeGeoKey");
    if (2 === e9) {
      const e10 = I(P3, "GeographicTypeGeoKey");
      e10 >= 1024 && e10 <= 32766 && (b3 = { wkid: e10 });
    } else if (1 === e9) {
      const e10 = I(P3, "ProjectedCSTypeGeoKey");
      e10 >= 1024 && e10 <= 32766 && (b3 = { wkid: e10 });
    }
  }
  if (U4 && O3 && O3.length >= 6 ? (N2 = [U4[0], 0, O3[3] - O3[0] * U4[0], 0, -Math.abs(U4[1]), O3[4] - O3[1] * U4[1]], R3 && (N2[2] -= 0.5 * N2[0] + 0.5 * N2[1], N2[5] -= 0.5 * N2[3] + 0.5 * N2[4])) : L3 && 16 === L3.length && (N2 = R3 ? [L3[0], L3[1], L3[3] - 0.5 * L3[0], L3[4], L3[5], L3[7] - 0.5 * L3[5]] : [L3[0], L3[1], L3[3], L3[4], L3[5], L3[7]]), N2) {
    const e9 = [{ x: 0, y: s10 }, { x: 0, y: 0 }, { x: i10, y: s10 }, { x: i10, y: 0 }];
    let t8, n10 = Number.POSITIVE_INFINITY, a10 = Number.POSITIVE_INFINITY, r12 = Number.NEGATIVE_INFINITY, l7 = Number.NEGATIVE_INFINITY;
    for (let i11 = 0; i11 < e9.length; i11++)
      t8 = g(e9[i11], N2), n10 = t8.x > n10 ? n10 : t8.x, r12 = t8.x < r12 ? r12 : t8.x, a10 = t8.y > a10 ? a10 : t8.y, l7 = t8.y < l7 ? l7 : t8.y;
    k4 = { xmin: n10, xmax: r12, ymin: a10, ymax: l7, spatialReference: b3 };
  } else
    k4 = { xmin: -0.5, ymin: 0.5 - s10, xmax: i10 - 0.5, ymax: 0.5, spatialReference: b3 };
  const C4 = e8.filter((e9) => 1 === d2(e9, "NEWSUBFILETYPE"));
  let v4, F, B2, V2, W;
  if (C4.length > 0) {
    v4 = Math.round(Math.log(i10 / I(C4[0], "IMAGEWIDTH")) / Math.LN2);
    const e9 = C4[C4.length - 1];
    F = Math.round(Math.log(i10 / I(e9, "IMAGEWIDTH")) / Math.LN2), B2 = I(e9, "TILEWIDTH"), V2 = I(e9, "TILELENGTH");
  }
  B2 = F > 0 ? B2 || n9 : null, V2 = F > 0 ? V2 || a9 : null, n9 && (W = [{ maxCol: Math.ceil(i10 / n9) - 1, maxRow: Math.ceil(s10 / a9) - 1, minRow: 0, minCol: 0 }], C4.forEach((e9) => {
    W.push({ maxCol: Math.ceil(I(e9, "IMAGEWIDTH") / I(e9, "TILEWIDTH")) - 1, maxRow: Math.ceil(I(e9, "IMAGELENGTH") / I(e9, "TILELENGTH")) - 1, minRow: 0, minCol: 0 });
  }));
  const H = d2(e8[0], "GDAL_METADATA"), Y = M2(H);
  return S4 += " " + G({ width: i10, height: s10, tileWidth: n9, tileHeight: a9, planes: l6, ifds: e8 }), { width: i10, height: s10, tileWidth: n9, tileHeight: a9, planes: l6, isBSQ: h4, pixelType: f6, compression: m6, noData: E3, isSupported: A3, message: S4, extent: k4, affine: U4 ? null : N2, firstPyramidLevel: v4, maximumPyramidLevel: F, pyramidBlockWidth: B2, pyramidBlockHeight: V2, tileBoundary: W, metadata: Y };
}
function D(e8, t7) {
  const n9 = w(e8, "PLANARCONFIGURATION");
  return n9 ? 2 === n9[0] : !!t7 && t7.isBSQ;
}
function O(e8) {
  const { littleEndian: t7, isBigTiff: n9, firstIFD: a9 } = N(e8);
  let i10 = a9;
  const r11 = [];
  do {
    const a10 = k2(e8, t7, i10, 0, n6.TIFF_TAGS, n9 ? 8 : 4);
    if (!a10.success)
      break;
    r11.push(a10.ifd), i10 = a10.nextIFD;
  } while (i10 > 0);
  return { ...b(r11), littleEndian: t7, isBigTiff: n9, ifds: r11 };
}
function U(e8, t7, n9) {
  const a9 = e8.getUint32(t7, n9), i10 = e8.getUint32(t7 + 4, n9);
  return n9 ? i10 * f2 + a9 : a9 * f2 + i10;
}
function L(e8, t7, n9) {
  let a9 = n9 ? e8.getInt32(t7, n9) : e8.getUint32(t7, n9), i10 = n9 ? e8.getUint32(t7 + 4, n9) : e8.getInt32(t7 + 4, n9);
  const s10 = (n9 ? a9 : i10) >= 0 ? 1 : -1;
  n9 ? a9 *= s10 : i10 *= s10;
  return s10 * (n9 ? i10 * f2 + a9 : a9 * f2 + i10);
}
function P(e8, t7, n9, a9) {
  return a9 ? U(e8, t7, n9) : e8.getUint32(t7, n9);
}
function N(e8) {
  const t7 = new DataView(e8, 0, 16), n9 = t7.getUint16(0, false);
  let a9 = null;
  if (18761 === n9)
    a9 = true;
  else {
    if (19789 !== n9)
      throw "unexpected endianess byte";
    a9 = false;
  }
  const i10 = t7.getUint16(2, a9);
  if (42 !== i10 && 43 !== i10)
    throw "unexpected tiff identifier";
  let s10 = 4;
  const r11 = 43 === i10;
  if (r11) {
    const e9 = t7.getUint16(s10, a9);
    if (s10 += 2, 8 !== e9)
      throw "unsupported bigtiff version";
    if (0 !== t7.getUint16(s10, a9))
      throw "unsupported bigtiff version";
    s10 += 2;
  }
  return { littleEndian: a9, isBigTiff: r11, firstIFD: P(t7, s10, a9, r11) };
}
function k2(t7, n9, a9, i10 = 0, r11 = n6.TIFF_TAGS, l6 = 4) {
  const o7 = T(t7, n9, a9, i10, r11, l6);
  let f6;
  const c5 = o7.ifd;
  if (c5) {
    if (n6.ifdTags.forEach((e8, a10) => {
      c5.has(a10) && (f6 = c5.get(a10), f6.data = T(t7, n9, f6.valueOffset - i10, i10, e8).ifd);
    }), c5.has("GEOKEYDIRECTORY")) {
      f6 = c5.get("GEOKEYDIRECTORY");
      const e8 = f6.values;
      if (e8 && e8.length > 4) {
        const a10 = e8[0] + "." + e8[1] + "." + e8[2];
        f6.data = T(t7, n9, f6.valueOffset + 6 - i10, i10, n6.GEO_KEYS, 2).ifd, f6.data && f6.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a10] });
      }
    }
    if (c5.has("XMP")) {
      f6 = c5.get("XMP");
      const t8 = f6.values;
      "number" == typeof t8[0] && 7 === f6.type && (f6.values = [r8(new Uint8Array(t8))]);
    }
  }
  return o7;
}
function G(e8) {
  const { width: t7, height: n9, tileHeight: a9, tileWidth: i10 } = e8, s10 = e8.planes, r11 = i10 ? i10 * a9 : t7 * n9, l6 = I(e8.ifds[0], "BITSPERSAMPLE");
  let o7 = "";
  return r11 * s10 > 2 ** 30 / (l6 > 8 ? l6 / 8 : 1) && (o7 = i10 ? "tiled tiff exceeding 1 gigabits per tile is not supported" : "scanline tiff exceeding 1 gigabits is not supported"), o7;
}
async function R(e8, t7) {
  const { headerInfo: n9, ifd: a9, offsets: i10, sizes: s10 } = t7, r11 = [];
  for (let h4 = 0; h4 < i10.length; h4++) {
    const t8 = await y2(e8, n9.littleEndian, a9, i10[h4], s10[h4] || e8.byteLength);
    r11.push(t8);
  }
  const l6 = D(a9, n9), { pixelType: o7, planes: f6 } = n9, c5 = h(o7), u7 = I(a9, "TILEWIDTH"), g5 = I(a9, "TILELENGTH"), w3 = I(a9, "COMPRESSION") ?? 1, p6 = u7 * g5;
  let d5;
  const T4 = [];
  let E3 = r11[0];
  const m6 = 34887 === w3;
  for (let h4 = 0; h4 < f6; h4++) {
    if (d5 = new c5(p6), l6 && m6) {
      if (E3 = r11[h4], E3.length)
        for (let e9 = 0; e9 < p6; e9++)
          d5[e9] = E3[h4][e9 + h4];
    } else if (E3.length)
      if (l6 || m6 && !l6)
        d5 = E3.slice(p6 * h4, p6 * (h4 + 1));
      else
        for (let e9 = 0; e9 < p6; e9++)
          d5[e9] = E3[e9 * f6 + h4];
    T4.push(d5);
  }
  const A3 = n9.noData ? n9.noData[0] : t7.noDataValue, M3 = n9.metadata ? n9.metadata.statistics : null, x4 = M3 ? M3.map((e9) => e9.min) : null, b3 = M3 ? M3.map((e9) => e9.max) : null;
  let O3, U4;
  if (null != A3)
    if (O3 = new Uint8Array(p6), Math.abs(A3) > 1e24)
      for (U4 = 0; U4 < p6; U4++)
        Math.abs((T4[0][U4] - A3) / A3) < 1e-6 ? O3[U4] = 0 : O3[U4] = 1;
    else
      for (U4 = 0; U4 < p6; U4++)
        T4[0][U4] === A3 ? O3[U4] = 0 : O3[U4] = 1;
  else
    x4 && b3 && t7.applyMinMaxConstraint && (O3 = S2(T4, x4, b3));
  return { pixelType: o7, width: u7, height: g5, pixels: T4, mask: O3, noDataValue: A3 };
}
async function C(e8, t7 = {}) {
  const n9 = t7.pyramidLevel || 0, a9 = t7.headerInfo || O(e8), { ifds: i10, noData: s10 } = a9;
  if (0 === i10.length)
    throw "no valid image file directory";
  const r11 = G(a9);
  if (r11)
    throw r11;
  let l6, o7;
  const f6 = -1 === n9 ? i10[i10.length - 1] : i10[n9], c5 = s10 ? s10[0] : t7.noDataValue;
  if (o7 = a9.tileWidth ? await m2(e8, a9, f6) : await A(e8, a9, f6), null !== c5) {
    if (o7.mask = new Uint8Array(o7.width * o7.height), Math.abs(c5) > 1e24)
      for (l6 = 0; l6 < o7.width * o7.height; l6++)
        Math.abs((o7.pixels[0][l6] - c5) / c5) < 1e-6 ? o7.mask[l6] = 0 : o7.mask[l6] = 1;
    else
      for (l6 = 0; l6 < o7.width * o7.height; l6++)
        o7.pixels[0][l6] === c5 ? o7.mask[l6] = 0 : o7.mask[l6] = 1;
    o7.noDataValue = c5;
  }
  return o7;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/RasterCodec.js
var d3 = function(t7) {
  var e8, i10, a9, s10, r11, n9;
  function h4(t8) {
    var e9, i11, a10, s11, r12, n10, o7, h5, c5, p6, l6, d5, u7;
    for (this.data = t8, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, r12 = null; ; ) {
      switch (e9 = this.readUInt32(), h5 = function() {
        var t9, e10;
        for (e10 = [], t9 = 0; t9 < 4; ++t9)
          e10.push(String.fromCharCode(this.data[this.pos++]));
        return e10;
      }.call(this).join(""), h5) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e9);
          break;
        case "fcTL":
          r12 && this.animation.frames.push(r12), this.pos += 4, r12 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, s11 = this.readUInt16(), a10 = this.readUInt16() || 100, r12.delay = 1e3 * s11 / a10, r12.disposeOp = this.data[this.pos++], r12.blendOp = this.data[this.pos++], r12.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === h5 && (this.pos += 4, e9 -= 4), t8 = (null != r12 ? r12.data : void 0) || this.imgData, l6 = 0; 0 <= e9 ? l6 < e9 : l6 > e9; 0 <= e9 ? ++l6 : --l6)
            t8.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (this.transparency.indexed = this.read(e9), (c5 = 255 - this.transparency.indexed.length) > 0)
                for (d5 = 0; 0 <= c5 ? d5 < c5 : d5 > c5; 0 <= c5 ? ++d5 : --d5)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e9)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e9);
          }
          break;
        case "tEXt":
          n10 = (p6 = this.read(e9)).indexOf(0), o7 = String.fromCharCode.apply(String, p6.slice(0, n10)), this.text[o7] = String.fromCharCode.apply(String, p6.slice(n10 + 1));
          break;
        case "IEND":
          return r12 && this.animation.frames.push(r12), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = 4 === (u7 = this.colorType) || 6 === u7, i11 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * i11, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e9;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  return h4.load = function(t8, e9, i11) {
    var a10;
    return "function" == typeof e9 && (i11 = e9), (a10 = new XMLHttpRequest()).open("GET", t8, true), a10.responseType = "arraybuffer", a10.onload = function() {
      var t9;
      return t9 = new h4(new Uint8Array(a10.response || a10.mozResponseArrayBuffer)), "function" == typeof (null != e9 ? e9.getContext : void 0) && t9.render(e9), "function" == typeof i11 ? i11(t9) : void 0;
    }, a10.send(null);
  }, i10 = 1, a9 = 2, e8 = 0, h4.prototype.read = function(t8) {
    var e9, i11;
    for (i11 = [], e9 = 0; 0 <= t8 ? e9 < t8 : e9 > t8; 0 <= t8 ? ++e9 : --e9)
      i11.push(this.data[this.pos++]);
    return i11;
  }, h4.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, h4.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, h4.prototype.decodePixels = function(t8) {
    var e9, i11, a10, s11, r12, n10, h5, c5, p6, l6, d5, u7, f6, m6, g5, w3, y4, x4, b3, k4, T4, U4, I3;
    if (null == t8 && (t8 = this.imgData), 0 === t8.length)
      return new Uint8Array(0);
    for (t8 = (t8 = new s4(t8)).getBytes(), w3 = (u7 = this.pixelBitlength / 8) * this.width, f6 = new Uint8Array(w3 * this.height), n10 = t8.length, g5 = 0, m6 = 0, i11 = 0; m6 < n10; ) {
      switch (t8[m6++]) {
        case 0:
          for (s11 = b3 = 0; b3 < w3; s11 = b3 += 1)
            f6[i11++] = t8[m6++];
          break;
        case 1:
          for (s11 = k4 = 0; k4 < w3; s11 = k4 += 1)
            e9 = t8[m6++], r12 = s11 < u7 ? 0 : f6[i11 - u7], f6[i11++] = (e9 + r12) % 256;
          break;
        case 2:
          for (s11 = T4 = 0; T4 < w3; s11 = T4 += 1)
            e9 = t8[m6++], a10 = (s11 - s11 % u7) / u7, y4 = g5 && f6[(g5 - 1) * w3 + a10 * u7 + s11 % u7], f6[i11++] = (y4 + e9) % 256;
          break;
        case 3:
          for (s11 = U4 = 0; U4 < w3; s11 = U4 += 1)
            e9 = t8[m6++], a10 = (s11 - s11 % u7) / u7, r12 = s11 < u7 ? 0 : f6[i11 - u7], y4 = g5 && f6[(g5 - 1) * w3 + a10 * u7 + s11 % u7], f6[i11++] = (e9 + Math.floor((r12 + y4) / 2)) % 256;
          break;
        case 4:
          for (s11 = I3 = 0; I3 < w3; s11 = I3 += 1)
            e9 = t8[m6++], a10 = (s11 - s11 % u7) / u7, r12 = s11 < u7 ? 0 : f6[i11 - u7], 0 === g5 ? y4 = x4 = 0 : (y4 = f6[(g5 - 1) * w3 + a10 * u7 + s11 % u7], x4 = a10 && f6[(g5 - 1) * w3 + (a10 - 1) * u7 + s11 % u7]), h5 = r12 + y4 - x4, c5 = Math.abs(h5 - r12), l6 = Math.abs(h5 - y4), d5 = Math.abs(h5 - x4), p6 = c5 <= l6 && c5 <= d5 ? r12 : l6 <= d5 ? y4 : x4, f6[i11++] = (e9 + p6) % 256;
          break;
        default:
          throw new Error("Invalid filter algorithm: " + t8[m6 - 1]);
      }
      g5++;
    }
    return f6;
  }, h4.prototype.decodePalette = function() {
    var t8, e9, i11, a10, s11, r12, n10, o7, h5;
    for (i11 = this.palette, r12 = this.transparency.indexed || [], s11 = new Uint8Array((r12.length || 0) + i11.length), a10 = 0, i11.length, t8 = 0, e9 = n10 = 0, o7 = i11.length; n10 < o7; e9 = n10 += 3)
      s11[a10++] = i11[e9], s11[a10++] = i11[e9 + 1], s11[a10++] = i11[e9 + 2], s11[a10++] = null != (h5 = r12[t8++]) ? h5 : 255;
    return s11;
  }, h4.prototype.copyToImageData = function(t8, e9) {
    var i11, a10, s11, r12, n10, o7, h5, c5, p6, l6, d5;
    if (a10 = this.colors, p6 = null, i11 = this.hasAlphaChannel, this.palette.length && (p6 = null != (d5 = this._decodedPalette) ? d5 : this._decodedPalette = this.decodePalette(), a10 = 4, i11 = true), c5 = (s11 = t8.data || t8).length, n10 = p6 || e9, r12 = o7 = 0, 1 === a10)
      for (; r12 < c5; )
        h5 = p6 ? 4 * e9[r12 / 4] : o7, l6 = n10[h5++], s11[r12++] = l6, s11[r12++] = l6, s11[r12++] = l6, s11[r12++] = i11 ? n10[h5++] : this.transparency.grayscale && this.transparency.grayscale === l6 ? 0 : 255, o7 = h5;
    else
      for (; r12 < c5; )
        h5 = p6 ? 4 * e9[r12 / 4] : o7, s11[r12++] = n10[h5++], s11[r12++] = n10[h5++], s11[r12++] = n10[h5++], s11[r12++] = i11 ? n10[h5++] : this.transparency.rgb && this.transparency.rgb[1] === n10[h5 - 3] && this.transparency.rgb[3] === n10[h5 - 2] && this.transparency.rgb[5] === n10[h5 - 1] ? 0 : 255, o7 = h5;
  }, h4.prototype.decode = function() {
    var t8;
    return t8 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t8, this.decodePixels()), t8;
  }, r11 = t7.document && t7.document.createElement("canvas"), n9 = r11 && r11.getContext("2d"), s10 = function(t8) {
    var e9;
    return n9.width = t8.width, n9.height = t8.height, n9.clearRect(0, 0, t8.width, t8.height), n9.putImageData(t8, 0, 0), (e9 = new Image()).src = r11.toDataURL(), e9;
  }, h4.prototype.decodeFrames = function(t8) {
    var e9, i11, a10, r12, n10, o7, h5, c5;
    if (this.animation) {
      for (c5 = [], i11 = n10 = 0, o7 = (h5 = this.animation.frames).length; n10 < o7; i11 = ++n10)
        e9 = h5[i11], a10 = t8.createImageData(e9.width, e9.height), r12 = this.decodePixels(new Uint8Array(e9.data)), this.copyToImageData(a10, r12), e9.imageData = a10, c5.push(e9.image = s10(a10));
      return c5;
    }
  }, h4.prototype.renderFrame = function(t8, s11) {
    var r12, n10, o7;
    return r12 = (n10 = this.animation.frames)[s11], o7 = n10[s11 - 1], 0 === s11 && t8.clearRect(0, 0, this.width, this.height), (null != o7 ? o7.disposeOp : void 0) === i10 ? t8.clearRect(o7.xOffset, o7.yOffset, o7.width, o7.height) : (null != o7 ? o7.disposeOp : void 0) === a9 && t8.putImageData(o7.imageData, o7.xOffset, o7.yOffset), r12.blendOp === e8 && t8.clearRect(r12.xOffset, r12.yOffset, r12.width, r12.height), t8.drawImage(r12.image, r12.xOffset, r12.yOffset);
  }, h4.prototype.animate = function(t8) {
    var e9, i11, a10, s11, r12, n10, o7 = this;
    return i11 = 0, n10 = this.animation, s11 = n10.numFrames, a10 = n10.frames, r12 = n10.numPlays, (e9 = function() {
      var n11, h5;
      if (n11 = i11++ % s11, h5 = a10[n11], o7.renderFrame(t8, n11), s11 > 1 && i11 / s11 < r12)
        return o7.animation._timeout = setTimeout(e9, h5.delay);
    })();
  }, h4.prototype.stopAnimation = function() {
    var t8;
    return clearTimeout(null != (t8 = this.animation) ? t8._timeout : void 0);
  }, h4.prototype.render = function(t8) {
    var e9, i11;
    return t8._png && t8._png.stopAnimation(), t8._png = this, t8.width = this.width, t8.height = this.height, e9 = t8.getContext("2d"), this.animation ? (this.decodeFrames(e9), this.animate(e9)) : (i11 = e9.createImageData(this.width, this.height), this.copyToImageData(i11, this.decodePixels()), e9.putImageData(i11, 0, 0));
  }, h4;
}(self);
var u4 = /* @__PURE__ */ new Set(["jpg", "png", "bmp", "gif"]);
var f3 = /* @__PURE__ */ new Set(["S8", "U8", "S16", "U16", "S32", "U32", "F32", "F64"]);
async function m3(i10, a9) {
  var _a;
  if (!r9)
    throw new s2("rasterCoded:decode", "lerc decoder is not supported on big endian platform");
  await a4();
  const { offset: n9, noDataValue: o7 } = a9;
  let h4 = (_a = a9.pixelType) == null ? void 0 : _a.toUpperCase();
  h4 && !f3.has(h4) && (h4 = null);
  const { width: c5, height: p6, pixelType: d5, statistics: u7, pixels: m6, mask: g5 } = c(i10, { inputOffset: n9, noDataValue: o7, pixelType: h4, returnPixelInterleavedDims: a9.returnPixelInterleavedDims });
  return new u({ width: c5, height: p6, pixelType: d5.toLowerCase(), pixels: m6, mask: g5, statistics: u7 });
}
async function g2(t7, i10) {
  const a9 = await C(t7, i10), s10 = new u({ width: a9.width, height: a9.height, pixels: a9.pixels, pixelType: a9.pixelType.toLowerCase(), mask: a9.mask, statistics: null });
  return s10.updateStatistics(), s10;
}
async function w2(t7, i10) {
  const a9 = await R(t7, i10.customOptions), s10 = new u({ width: a9.width, height: a9.height, pixels: a9.pixels, pixelType: a9.pixelType.toLowerCase(), mask: a9.mask, statistics: null });
  return s10.updateStatistics(), s10;
}
function y3(t7, i10) {
  const a9 = i10.pixelType || "u8", s10 = u.getPixelArrayConstructor(a9), r11 = "u8" === a9 ? t7 : new s10(t7.buffer), n9 = [], o7 = i10.planes || 1;
  if (1 === o7)
    n9.push(r11);
  else
    for (let e8 = 0; e8 < o7; e8++) {
      const a10 = (i10.width || 1) * (i10.height || t7.length), h5 = new s10(a10);
      for (let t8 = 0; t8 < a10; t8++)
        h5[t8] = r11[t8 * o7 + e8];
      n9.push(h5);
    }
  const h4 = new u({ width: i10.width || 1, height: i10.height || t7.length, pixels: n9, pixelType: a9, statistics: null });
  return h4.updateStatistics(), h4;
}
function x2(t7, e8) {
  return y3(new s4(new Uint8Array(t7)).getBytes(), e8);
}
function b2(t7, e8) {
  return y3(i5(t7, e8.offset, e8.eof, !e8.isInputBigEndian), e8);
}
function k3(t7, i10, a9) {
  const { pixelTypeCtor: s10 } = A2(i10.pixelType), r11 = (0, a5.decode)(t7, { width: i10.width, height: i10.height, pixelType: s10, format: a9 }), n9 = new u({ width: i10.width, height: i10.height, pixels: r11.pixels, pixelType: i10.pixelType, mask: r11.mask, statistics: null });
  return n9.updateStatistics(), n9;
}
function T2(t7, i10) {
  const s10 = n3.decode(t7, i10.hasNoZlibMask), r11 = new u({ width: s10.width, height: s10.height, pixels: s10.pixels, pixelType: "U8", mask: s10.mask, statistics: null });
  return r11.updateStatistics(), r11;
}
function U2(t7, i10) {
  const a9 = new Uint8Array(t7), s10 = new d3(a9), { width: r11, height: n9 } = i10, o7 = r11 * n9, h4 = s10.decode();
  let c5, p6 = 0, l6 = 0;
  const u7 = new Uint8Array(o7);
  for (p6 = 0; p6 < o7; p6++)
    u7[p6] = h4[4 * p6 + 3];
  const f6 = new u({ width: r11, height: n9, pixels: [], pixelType: "U8", mask: u7, statistics: [] });
  for (p6 = 0; p6 < 3; p6++) {
    for (c5 = new Uint8Array(o7), l6 = 0; l6 < o7; l6++)
      c5[l6] = h4[4 * l6 + p6];
    f6.addData({ pixels: c5 });
  }
  return f6.updateStatistics(), f6;
}
async function I2(t7, a9, s10, r11) {
  const n9 = new i3(), o7 = { applyJpegMask: false, format: a9, ...s10 }, h4 = await n9.decode(t7, o7, r11), c5 = new u(h4);
  return c5.updateStatistics(), c5;
}
function v2(e8) {
  if (null == e8)
    throw new s2("rasterCodec:decode", "parameter encodeddata is required.");
  const i10 = new Uint8Array(e8, 0, 10);
  let a9 = "";
  return 255 === i10[0] && 216 === i10[1] ? a9 = "jpg" : 137 === i10[0] && 80 === i10[1] && 78 === i10[2] && 71 === i10[3] ? a9 = "png" : 67 === i10[0] && 110 === i10[1] && 116 === i10[2] && 90 === i10[3] && 73 === i10[4] && 109 === i10[5] && 97 === i10[6] && 103 === i10[7] && 101 === i10[8] && 32 === i10[9] ? a9 = "lerc" : 76 === i10[0] && 101 === i10[1] && 114 === i10[2] && 99 === i10[3] && 50 === i10[4] && 32 === i10[5] ? a9 = "lerc2" : 73 === i10[0] && 73 === i10[1] && 42 === i10[2] && 0 === i10[3] || 77 === i10[0] && 77 === i10[1] && 0 === i10[2] && 42 === i10[3] || 73 === i10[0] && 73 === i10[1] && 43 === i10[2] && 0 === i10[3] || 77 === i10[0] && 77 === i10[1] && 0 === i10[2] && 43 === i10[3] ? a9 = "tiff" : 71 === i10[0] && 73 === i10[1] && 70 === i10[2] ? a9 = "gif" : 66 === i10[0] && 77 === i10[1] ? a9 = "bmp" : String.fromCharCode.apply(null, i10).toLowerCase().includes("error") && (a9 = "error"), a9;
}
function C2(e8) {
  let i10 = null;
  switch (e8) {
    case "lerc":
    case "lerc2":
      i10 = m3;
      break;
    case "jpg":
      i10 = T2;
      break;
    case "png":
      i10 = U2;
      break;
    case "bsq":
    case "bip":
      i10 = (t7, i11) => k3(t7, i11, e8);
      break;
    case "tiff":
      i10 = g2;
      break;
    case "deflate":
      i10 = x2;
      break;
    case "lzw":
      i10 = b2;
      break;
    case "error":
      i10 = () => {
        throw new s2("rasterCodec:decode", "input data contains error");
      };
      break;
    default:
      i10 = () => {
        throw new s2("rasterCodec:decode", "unsupported raster format");
      };
  }
  return i10;
}
function A2(t7) {
  let e8 = null, i10 = null;
  switch (t7 ? t7.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      i10 = 255, e8 = Uint8Array;
      break;
    case "u16":
      i10 = i10 || 65535, e8 = Uint16Array;
      break;
    case "u32":
      i10 = i10 || 2 ** 32 - 1, e8 = Uint32Array;
      break;
    case "s8":
      i10 = i10 || -128, e8 = Int8Array;
      break;
    case "s16":
      i10 = i10 || -32768, e8 = Int16Array;
      break;
    case "s32":
      i10 = i10 || 0 - 2 ** 31, e8 = Int32Array;
      break;
    default:
      e8 = Float32Array;
  }
  return { pixelTypeCtor: e8, noDataValue: i10 };
}
function D2(t7, i10 = 1) {
  if (!t7)
    return;
  const { pixels: a9, width: s10, height: r11, mask: n9 } = t7;
  if (!a9 || 0 === a9.length)
    return;
  const o7 = a9.length, h4 = s10 - 1, c5 = r11 - 1, p6 = [];
  let l6, d5, u7, f6, m6, g5, w3;
  const y4 = u.getPixelArrayConstructor(t7.pixelType);
  if (0 === i10) {
    for (l6 = 0; l6 < o7; l6++) {
      for (m6 = a9[l6], g5 = new y4(h4 * c5), d5 = 0; d5 < c5; d5++)
        for (f6 = d5 * s10, u7 = 0; u7 < h4; u7++)
          g5[d5 * h4 + u7] = m6[f6 + u7];
      p6.push(g5);
    }
    if (n9)
      for (w3 = new Uint8Array(h4 * c5), d5 = 0; d5 < c5; d5++)
        for (f6 = d5 * s10, u7 = 0; u7 < h4; u7++)
          w3[d5 * h4 + u7] = n9[f6 + u7];
  } else {
    for (l6 = 0; l6 < o7; l6++) {
      for (m6 = a9[l6], g5 = new y4(h4 * c5), d5 = 0; d5 < c5; d5++)
        for (f6 = d5 * s10, u7 = 0; u7 < h4; u7++)
          g5[d5 * h4 + u7] = (m6[f6 + u7] + m6[f6 + u7 + 1] + m6[f6 + s10 + u7] + m6[f6 + s10 + u7 + 1]) / 4;
      p6.push(g5);
    }
    if (n9)
      for (w3 = new Uint8Array(h4 * c5), d5 = 0; d5 < c5; d5++)
        for (f6 = d5 * s10, u7 = 0; u7 < h4; u7++)
          w3[d5 * h4 + u7] = Math.min.apply(null, [n9[f6 + u7], n9[f6 + u7 + 1], n9[f6 + s10 + u7], n9[f6 + s10 + u7 + 1]]);
  }
  t7.width = h4, t7.height = c5, t7.mask = w3, t7.pixels = p6;
}
function P2(t7) {
  let e8 = v2(t7);
  return "lerc2" === e8 ? e8 = "lerc" : "error" === e8 && (e8 = ""), e8;
}
async function S3(e8, i10 = {}, a9) {
  if (null == e8)
    throw new s2("rasterCodec:decode", "missing encodeddata parameter.");
  let s10, r11, n9 = i10.format && i10.format.toLowerCase();
  if (!("bsq" !== n9 && "bip" !== n9 || null != i10.width && null != i10.height))
    throw new s2("rasterCodec:decode", "requires width and height in options parameter.");
  return "tiff" === n9 && i10.customOptions ? w2(e8, i10) : ((!n9 || "bsq" !== n9 && "bip" !== n9 && "deflate" !== n9 && "lzw" !== n9) && (n9 = v2(e8)), i10.useCanvas && u4.has(n9) ? r11 = await I2(e8, n9, i10, a9) : (s10 = C2(n9), i10.isPoint && ((i10 = { ...i10 }).width++, i10.height++), r11 = await s10(e8, i10), i10.isPoint && D2(r11)), r11);
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/stretchUtils.js
var i7 = { u1: [0, 1], u2: [0, 3], u4: [0, 15], u8: [0, 255], s8: [-128, 127], u16: [0, 65535], s16: [-32768, 32767], u32: [0, 4294967295], s32: [-2147483648, 2147483647], f32: [-34e38, 34e38], f64: [-Number.MAX_VALUE, Number.MAX_VALUE] };
var s6 = 1;
var o6 = [0.299, 0.587, 0.114];
function r10(t7, n9 = 256) {
  n9 = Math.min(n9, 256);
  const { size: e8, counts: i10 } = t7, s10 = new Uint8Array(e8), o7 = i10.reduce((t8, e9) => t8 + e9 / n9, 0);
  let r11 = 0, a9 = 0, f6 = 0, l6 = o7;
  for (let u7 = 0; u7 < e8; u7++)
    if (f6 += i10[u7], !(u7 < e8 - 1 && f6 + i10[u7 + 1] < l6)) {
      for (; r11 < n9 - 1 && l6 < f6; )
        r11++, l6 += o7;
      for (let t8 = a9; t8 <= u7; t8++)
        s10[t8] = r11;
      a9 = u7 + 1;
    }
  for (let u7 = a9; u7 < e8; u7++)
    s10[u7] = n9 - 1;
  return s10;
}
function a6(t7) {
  const { minCutOff: n9, maxCutOff: e8, gamma: i10, pixelType: s10 } = t7, o7 = t7.outMin || 0, r11 = t7.outMax || 255;
  if (!["u8", "u16", "s8", "s16"].includes(s10))
    return null;
  const a9 = n9.length;
  let l6, u7, m6 = 0;
  "s8" === s10 ? m6 = -127 : "s16" === s10 && (m6 = -32767);
  let c5 = 256;
  ["u16", "s16"].includes(s10) && (c5 = 65536);
  const h4 = [], g5 = r11 - o7;
  for (l6 = 0; l6 < a9; l6++)
    h4[l6] = e8[l6] - n9[l6], e8[l6], n9[l6];
  const x4 = i10 && i10.length >= a9, M3 = [];
  if (x4)
    for (l6 = 0; l6 < a9; l6++)
      i10[l6] > 1 ? i10[l6] > 2 ? M3[l6] = 6.5 + (i10[l6] - 2) ** 2.5 : M3[l6] = 6.5 + 100 * (2 - i10[l6]) ** 4 : M3[l6] = 1;
  let p6;
  const d5 = [];
  let b3, O3, y4;
  if (x4)
    for (l6 = 0; l6 < a9; l6++) {
      for (y4 = [], u7 = 0; u7 < c5; u7++)
        b3 = u7 + m6, p6 = (b3 - n9[l6]) / h4[l6], O3 = 1, i10[l6] > 1 && (O3 -= (1 / g5) ** (p6 * M3[l6])), b3 < e8[l6] && b3 > n9[l6] ? y4[u7] = Math.floor(O3 * g5 * p6 ** (1 / i10[l6])) + o7 : b3 >= e8[l6] ? y4[u7] = r11 : y4[u7] = o7;
      d5[l6] = y4;
    }
  else
    for (l6 = 0; l6 < a9; l6++) {
      for (y4 = [], u7 = 0; u7 < c5; u7++)
        b3 = u7 + m6, b3 <= n9[l6] ? y4[u7] = o7 : b3 >= e8[l6] ? y4[u7] = r11 : y4[u7] = Math.floor((b3 - n9[l6]) / h4[l6] * g5) + o7;
      d5[l6] = y4;
    }
  if (null != t7.contrastOffset) {
    const n10 = f4(t7.contrastOffset, t7.brightnessOffset);
    for (l6 = 0; l6 < a9; l6++)
      for (y4 = d5[l6], u7 = 0; u7 < c5; u7++)
        y4[u7] = n10[y4[u7]];
  }
  return { lut: d5, offset: m6 };
}
function f4(t7, n9) {
  const e8 = Math.min(Math.max(t7, -100), 100), i10 = Math.min(Math.max(n9, -100), 100), s10 = 255, o7 = 128;
  let r11, a9;
  const f6 = new Uint8Array(256);
  for (r11 = 0; r11 < 256; r11++)
    e8 > 0 && e8 < 100 ? a9 = (200 * r11 - 100 * s10 + 2 * s10 * i10) / (2 * (100 - e8)) + o7 : e8 <= 0 && e8 > -100 ? a9 = (200 * r11 - 100 * s10 + 2 * s10 * i10) * (100 + e8) / 2e4 + o7 : 100 === e8 ? (a9 = 200 * r11 - 100 * s10 + (s10 + 1) * (100 - e8) + 2 * s10 * i10, a9 = a9 > 0 ? s10 : 0) : -100 === e8 && (a9 = o7), f6[r11] = a9 > s10 ? s10 : a9 < 0 ? 0 : a9;
  return f6;
}
function l4(t7, n9, e8) {
  const i10 = [];
  for (let s10 = 0; s10 < n9.length; s10++) {
    let r11 = 0, a9 = 0, f6 = 0;
    "min" in n9[s10] ? { min: r11, max: a9, avg: f6 } = n9[s10] : [r11, a9, f6] = n9[s10];
    let l6 = f6;
    "u8" !== t7 && (l6 = 255 * (l6 - r11) / (a9 - r11)), e8 && (l6 *= o6[s10]), i10.push(u5(l6));
  }
  return i10;
}
function u5(t7) {
  if (t7 <= 0 || t7 >= 255)
    return s6;
  let n9 = 0;
  150 !== t7 && (n9 = t7 <= 150 ? 45 * Math.cos(0.01047 * t7) : 17 * Math.sin(0.021 * t7));
  const e8 = 255, i10 = t7 + n9, o7 = Math.log(t7 / e8), r11 = Math.log(i10 / e8);
  if (0 === r11)
    return s6;
  const a9 = o7 / r11;
  return isNaN(a9) ? s6 : Math.min(9.9, Math.max(0.01, a9));
}
function m4(n9) {
  var _a;
  if (t(n9) || !((_a = n9.pixels) == null ? void 0 : _a.length))
    return null;
  n9.statistics || n9.updateStatistics();
  const { pixels: e8, mask: i10, pixelType: s10, statistics: o7 } = n9, r11 = n9.width * n9.height, a9 = e8.length;
  let f6, l6, u7, m6, c5;
  const h4 = [], g5 = [];
  let x4, M3, p6, d5, b3, O3, y4, C4, z2, A3;
  const k4 = 256;
  for (m6 = 0; m6 < a9; m6++) {
    if (x4 = new Uint32Array(k4), p6 = e8[m6], "u8" === s10)
      if (f6 = -0.5, l6 = 255.5, i10)
        for (c5 = 0; c5 < r11; c5++)
          i10[c5] && x4[p6[c5]]++;
      else
        for (c5 = 0; c5 < r11; c5++)
          x4[p6[c5]]++;
    else {
      if (f6 = o7[m6].minValue, l6 = o7[m6].maxValue, u7 = (l6 - f6) / k4, M3 = new Uint32Array(k4 + 1), i10)
        for (c5 = 0; c5 < r11; c5++)
          i10[c5] && M3[Math.floor((p6[c5] - f6) / u7)]++;
      else
        for (c5 = 0; c5 < r11; c5++)
          M3[Math.floor((p6[c5] - f6) / u7)]++;
      for (c5 = 0; c5 < 255; c5++)
        x4[c5] = M3[c5];
      x4[255] = M3[255] + M3[256];
    }
    for (h4.push({ min: f6, max: l6, size: k4, counts: x4 }), d5 = 0, b3 = 0, C4 = 0, c5 = 0; c5 < k4; c5++)
      d5 += x4[c5], b3 += c5 * x4[c5];
    for (z2 = b3 / d5, c5 = 0; c5 < k4; c5++)
      C4 += x4[c5] * (c5 - z2) ** 2;
    A3 = Math.sqrt(C4 / (d5 - 1)), u7 = (l6 - f6) / k4, O3 = (z2 + 0.5) * u7 + f6, y4 = A3 * u7, g5.push({ min: f6, max: l6, avg: O3, stddev: y4 });
  }
  return { statistics: g5, histograms: h4 };
}
function c3(t7) {
  const n9 = [];
  for (let e8 = 0; e8 < t7.length; e8++) {
    const { min: i10, max: s10, size: o7, counts: r11 } = t7[e8];
    let a9 = 0, f6 = 0;
    for (let t8 = 0; t8 < o7; t8++)
      a9 += r11[t8], f6 += t8 * r11[t8];
    const l6 = f6 / a9;
    let u7 = 0;
    for (let t8 = 0; t8 < o7; t8++)
      u7 += r11[t8] * (t8 - l6) ** 2;
    const m6 = (s10 - i10) / o7, c5 = (l6 + 0.5) * m6 + i10, h4 = Math.sqrt(u7 / (a9 - 1)) * m6;
    n9.push({ min: i10, max: s10, avg: c5, stddev: h4 });
  }
  return n9;
}
function h2(t7, s10) {
  var _a;
  const { pixelBlock: o7, bandIds: a9, returnHistogramLut: f6, rasterInfo: l6 } = s10;
  let u7, c5, h4 = t7.stretchType;
  if (t7.dra)
    if ("minMax" === h4 && r(o7) && o7.statistics)
      u7 = o7.statistics.map((t8) => [t8.minValue, t8.maxValue, 0, 0]);
    else {
      const t8 = m4(o7);
      u7 = r(t8) ? t8.statistics : null, c5 = r(t8) ? t8.histograms : null;
    }
  else
    u7 = ((_a = t7.statistics) == null ? void 0 : _a.length) > 0 ? t7.statistics : e2(l6.statistics), c5 = t7.histograms || e2(l6.histograms);
  "percentClip" !== h4 && "histogramEqualization" !== h4 || (c5 == null ? void 0 : c5.length) || (h4 = "minMax");
  const x4 = (u7 == null ? void 0 : u7.length) || (c5 == null ? void 0 : c5.length) || l6.bandCount, M3 = [], p6 = [];
  let d5, b3, O3, y4, C4, z2, A3, k4, v4, w3, U4, L3;
  switch (u7 && !Array.isArray(u7[0]) && (u7 = u7.map((t8) => [t8.min, t8.max, t8.avg, t8.stddev])), h4) {
    case "none":
      {
        const t8 = i7[l6.pixelType] || i7.f32;
        for (k4 = 0; k4 < x4; k4++)
          M3[k4] = t8[0], p6[k4] = t8[1];
      }
      break;
    case "minMax":
      for (k4 = 0; k4 < x4; k4++)
        M3[k4] = u7[k4][0], p6[k4] = u7[k4][1];
      break;
    case "standardDeviation":
      for (k4 = 0; k4 < x4; k4++)
        M3[k4] = u7[k4][2] - t7.numberOfStandardDeviations * u7[k4][3], p6[k4] = u7[k4][2] + t7.numberOfStandardDeviations * u7[k4][3], M3[k4] < u7[k4][0] && (M3[k4] = u7[k4][0]), p6[k4] > u7[k4][1] && (p6[k4] = u7[k4][1]);
      break;
    case "histogramEqualization":
      for (k4 = 0; k4 < x4; k4++)
        M3[k4] = c5[k4].min, p6[k4] = c5[k4].max;
      break;
    case "percentClip":
      for (k4 = 0; k4 < c5.length; k4++) {
        for (d5 = c5[k4], C4 = new Uint32Array(d5.size), y4 = [...d5.counts], y4.length >= 20 && (y4[0] = y4[1] = y4[2] = y4[y4.length - 1] = y4[y4.length - 2] = 0), O3 = 0, b3 = (d5.max - d5.min) / d5.size, A3 = -0.5 === d5.min && 1 === b3 ? 0.5 : 0, v4 = 0; v4 < d5.size; v4++)
          O3 += y4[v4], C4[v4] = O3;
        for (z2 = (t7.minPercent || 0) * O3 / 100, v4 = 0; v4 < d5.size; v4++)
          if (C4[v4] > z2) {
            M3[k4] = d5.min + b3 * (v4 + A3);
            break;
          }
        for (z2 = (1 - (t7.maxPercent || 0) / 100) * O3, v4 = d5.size - 2; v4 >= 0; v4--)
          if (C4[v4] < z2) {
            p6[k4] = d5.min + b3 * (v4 + 2 - A3);
            break;
          }
      }
      break;
    default:
      for (k4 = 0; k4 < x4; k4++)
        M3[k4] = u7[k4][0], p6[k4] = u7[k4][1];
  }
  "histogramEqualization" === h4 ? (U4 = c5[0].size || 256, w3 = 0, f6 && (L3 = c5.map((t8) => r10(t8)))) : (U4 = t7.max || 255, w3 = t7.min || 0);
  return g3({ minCutOff: M3, maxCutOff: p6, outMax: U4, outMin: w3, histogramLut: L3 }, a9);
}
function g3(t7, n9) {
  if (null == n9 || 0 === n9.length)
    return t7;
  const e8 = Math.max.apply(null, n9), { minCutOff: i10, maxCutOff: s10, outMin: o7, outMax: r11, histogramLut: a9 } = t7;
  return i10.length === n9.length || i10.length <= e8 ? t7 : { minCutOff: n9.map((t8) => i10[t8]), maxCutOff: n9.map((t8) => s10[t8]), histogramLut: a9 ? n9.map((t8) => a9[t8]) : null, outMin: o7, outMax: r11 };
}
function x3(n9, e8) {
  var _a;
  if (t(n9) || !((_a = n9.pixels) == null ? void 0 : _a.length))
    return n9;
  const i10 = n9.clone(), { pixels: s10, mask: o7 } = i10, { minCutOff: r11, maxCutOff: a9, gamma: f6 } = e8, l6 = e8.outMin || 0, u7 = e8.outMax || 255, m6 = i10.width * i10.height, c5 = s10.length;
  let h4, g5, x4, M3, p6;
  const d5 = u7 - l6, b3 = [];
  for (h4 = 0; h4 < c5; h4++)
    b3[h4] = a9[h4] - r11[h4], a9[h4], r11[h4];
  const O3 = f6 && f6.length >= c5, y4 = [];
  if (O3)
    for (h4 = 0; h4 < c5; h4++)
      f6[h4] > 1 ? f6[h4] > 2 ? y4[h4] = 6.5 + (f6[h4] - 2) ** 2.5 : y4[h4] = 6.5 + 100 * (2 - f6[h4]) ** 4 : y4[h4] = 1;
  if (O3)
    if (null != o7) {
      for (g5 = 0; g5 < m6; g5++)
        if (o7[g5])
          for (h4 = 0; h4 < c5; h4++)
            x4 = s10[h4][g5], p6 = (x4 - r11[h4]) / b3[h4], M3 = 1, f6[h4] > 1 && (M3 -= (1 / d5) ** (p6 * y4[h4])), x4 < a9[h4] && x4 > r11[h4] ? s10[h4][g5] = Math.floor(M3 * d5 * p6 ** (1 / f6[h4])) + l6 : x4 >= a9[h4] ? s10[h4][g5] = u7 : s10[h4][g5] = l6;
    } else
      for (g5 = 0; g5 < m6; g5++)
        for (h4 = 0; h4 < c5; h4++)
          x4 = s10[h4][g5], p6 = (x4 - r11[h4]) / b3[h4], M3 = 1, f6[h4] > 1 && (M3 -= (1 / d5) ** (p6 * y4[h4])), x4 < a9[h4] && x4 > r11[h4] ? s10[h4][g5] = Math.floor(M3 * d5 * p6 ** (1 / f6[h4])) + l6 : x4 >= a9[h4] ? s10[h4][g5] = u7 : s10[h4][g5] = l6;
  else if (null != o7) {
    for (g5 = 0; g5 < m6; g5++)
      if (o7[g5])
        for (h4 = 0; h4 < c5; h4++)
          x4 = s10[h4][g5], x4 < a9[h4] && x4 > r11[h4] ? s10[h4][g5] = Math.floor((x4 - r11[h4]) / b3[h4] * d5) + l6 : x4 >= a9[h4] ? s10[h4][g5] = u7 : s10[h4][g5] = l6;
  } else
    for (g5 = 0; g5 < m6; g5++)
      for (h4 = 0; h4 < c5; h4++)
        x4 = s10[h4][g5], x4 < a9[h4] && x4 > r11[h4] ? s10[h4][g5] = Math.floor((x4 - r11[h4]) / b3[h4] * d5) + l6 : x4 >= a9[h4] ? s10[h4][g5] = u7 : s10[h4][g5] = l6;
  return i10.pixelType = "u8", i10.updateStatistics(), i10;
}

// node_modules/@arcgis/core/layers/support/RasterStorageInfo.js
var s7 = class extends l {
  constructor() {
    super(...arguments), this.blockWidth = void 0, this.blockHeight = void 0, this.compression = null, this.origin = null, this.firstPyramidLevel = null, this.maximumPyramidLevel = null, this.pyramidScalingFactor = 2, this.pyramidBlockWidth = null, this.pyramidBlockHeight = null, this.isVirtualTileInfo = false, this.tileInfo = null, this.transposeInfo = null, this.blockBoundary = null;
  }
};
e([d({ type: Number, json: { write: true } })], s7.prototype, "blockWidth", void 0), e([d({ type: Number, json: { write: true } })], s7.prototype, "blockHeight", void 0), e([d({ type: String, json: { write: true } })], s7.prototype, "compression", void 0), e([d({ type: j, json: { write: true } })], s7.prototype, "origin", void 0), e([d({ type: Number, json: { write: true } })], s7.prototype, "firstPyramidLevel", void 0), e([d({ type: Number, json: { write: true } })], s7.prototype, "maximumPyramidLevel", void 0), e([d({ json: { write: true } })], s7.prototype, "pyramidResolutions", void 0), e([d({ type: Number, json: { write: true } })], s7.prototype, "pyramidScalingFactor", void 0), e([d({ type: Number, json: { write: true } })], s7.prototype, "pyramidBlockWidth", void 0), e([d({ type: Number, json: { write: true } })], s7.prototype, "pyramidBlockHeight", void 0), e([d({ type: Boolean, json: { write: true } })], s7.prototype, "isVirtualTileInfo", void 0), e([d({ json: { write: true } })], s7.prototype, "tileInfo", void 0), e([d()], s7.prototype, "transposeInfo", void 0), e([d()], s7.prototype, "blockBoundary", void 0), s7 = e([n("esri.layers.support.RasterStorageInfo")], s7);
var p4 = s7;

// node_modules/@arcgis/core/layers/support/RasterInfo.js
var a7 = class extends l {
  constructor(t7) {
    super(t7), this.attributeTable = null, this.bandCount = null, this.colormap = null, this.extent = null, this.format = void 0, this.height = null, this.width = null, this.histograms = null, this.keyProperties = {}, this.multidimensionalInfo = null, this.noDataValue = null, this.pixelSize = null, this.pixelType = null, this.isPseudoSpatialReference = false, this.spatialReference = null, this.statistics = null, this.storageInfo = null, this.transform = null;
  }
  get dataType() {
    var _a, _b;
    const t7 = ((_b = (_a = this.keyProperties) == null ? void 0 : _a.DataType) == null ? void 0 : _b.toLowerCase()) ?? "generic";
    return "stdtime" === t7 ? "standard-time" : t7;
  }
  get nativeExtent() {
    return this._get("nativeExtent") || this.extent;
  }
  set nativeExtent(t7) {
    t7 && this._set("nativeExtent", t7);
  }
  get nativePixelSize() {
    if (t(this.transform) || !this.transform.affectsPixelSize)
      return this.pixelSize;
    const t7 = this.nativeExtent;
    return { x: t7.width / this.width, y: t7.height / this.height };
  }
  get hasMultidimensionalTranspose() {
    var _a;
    return !!((_a = this.storageInfo) == null ? void 0 : _a.transposeInfo);
  }
};
e([d({ json: { write: true } })], a7.prototype, "attributeTable", void 0), e([d({ json: { write: true } })], a7.prototype, "bandCount", void 0), e([d({ json: { write: true } })], a7.prototype, "colormap", void 0), e([d({ type: String, readOnly: true })], a7.prototype, "dataType", null), e([d({ type: M, json: { write: true } })], a7.prototype, "extent", void 0), e([d({ type: M, json: { write: true } })], a7.prototype, "nativeExtent", null), e([d({ json: { write: true } })], a7.prototype, "nativePixelSize", null), e([d({ json: { write: true } })], a7.prototype, "format", void 0), e([d({ json: { write: true } })], a7.prototype, "height", void 0), e([d({ json: { write: true } })], a7.prototype, "width", void 0), e([d({ json: { write: true } })], a7.prototype, "hasMultidimensionalTranspose", null), e([d({ json: { write: true } })], a7.prototype, "histograms", void 0), e([d({ json: { write: true } })], a7.prototype, "keyProperties", void 0), e([d({ json: { write: true } })], a7.prototype, "multidimensionalInfo", void 0), e([d({ json: { write: true } })], a7.prototype, "noDataValue", void 0), e([d({ json: { write: true } })], a7.prototype, "pixelSize", void 0), e([d({ json: { write: true } })], a7.prototype, "pixelType", void 0), e([d()], a7.prototype, "isPseudoSpatialReference", void 0), e([d({ type: k, json: { write: true } })], a7.prototype, "spatialReference", void 0), e([d({ json: { write: true } })], a7.prototype, "statistics", void 0), e([d({ type: p4, json: { write: true } })], a7.prototype, "storageInfo", void 0), e([d({ json: { write: true } })], a7.prototype, "transform", void 0), a7 = e([n("esri.layers.support.RasterInfo")], a7);
var l5 = a7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/surfaceUtils.js
function i8(t7) {
  let { altitude: e8, azimuth: i10 } = t7;
  const { hillshadeType: s10, pixelSizePower: n9, pixelSizeFactor: a9, scalingType: l6, isGCS: o7, resolution: r11 } = t7, c5 = "multi-directional" === s10 ? 2 * t7.zFactor : t7.zFactor, { x: h4, y: f6 } = r11;
  let u7 = c5 / (8 * h4), d5 = c5 / (8 * f6);
  if (o7 && c5 > 1e-3 && (u7 /= 111e3, d5 /= 111e3), "adjusted" === l6)
    if (o7) {
      const t8 = 111e3 * h4, e9 = 111e3 * f6;
      u7 = (c5 + t8 ** n9 * a9) / (8 * t8), d5 = (c5 + e9 ** n9 * a9) / (8 * e9);
    } else
      u7 = (c5 + h4 ** n9 * a9) / (8 * h4), d5 = (c5 + f6 ** n9 * a9) / (8 * f6);
  let p6 = (90 - e8) * Math.PI / 180, m6 = Math.cos(p6), M3 = (360 - i10 + 90) * Math.PI / 180, x4 = Math.sin(p6) * Math.cos(M3), A3 = Math.sin(p6) * Math.sin(M3);
  const w3 = [315, 270, 225, 360, 180, 0], y4 = [60, 60, 60, 60, 60, 90], g5 = new Float32Array([3, 5, 3, 2, 1, 4]), Z = g5.reduce((t8, e9) => t8 + e9), k4 = g5.map((t8) => t8 / Z), P3 = "multi-directional" === s10 ? w3.length : 1, F = new Float32Array(6), b3 = new Float32Array(6), C4 = new Float32Array(6);
  if ("multi-directional" === s10)
    for (let U4 = 0; U4 < P3; U4++)
      e8 = y4[U4], i10 = w3[U4], p6 = (90 - e8) * Math.PI / 180, m6 = Math.cos(p6), M3 = (360 - i10 + 90) * Math.PI / 180, x4 = Math.sin(p6) * Math.cos(M3), A3 = Math.sin(p6) * Math.sin(M3), F[U4] = m6, b3[U4] = x4, C4[U4] = A3;
  else
    F.fill(m6), b3.fill(x4), C4.fill(A3);
  return { resolution: r11, factor: [u7, d5], sinZcosA: x4, sinZsinA: A3, cosZ: m6, sinZcosAs: b3, sinZsinAs: C4, cosZs: F, weights: k4, hillshadeType: ["traditional", "multi-directional"].indexOf(s10) };
}
function s8(s10, n9) {
  if (!i(s10))
    return s10;
  const { width: a9, height: l6, mask: o7 } = s10, r11 = new Uint8Array(a9 * l6);
  o7 && r11.set(o7);
  const { factor: c5, sinZcosA: h4, sinZsinA: f6, cosZ: u7, sinZcosAs: d5, sinZsinAs: p6, cosZs: m6, weights: M3 } = i8(n9), [x4, A3] = c5, { hillshadeType: w3 } = n9, y4 = s10.pixels[0], g5 = new Uint8Array(a9 * l6);
  let Z, k4, P3, F, b3, C4, U4, z2;
  const T4 = 1;
  for (let t7 = T4; t7 < l6 - T4; t7++) {
    const e8 = t7 * a9;
    for (let t8 = T4; t8 < a9 - T4; t8++) {
      if (o7 && !o7[e8 + t8]) {
        g5[e8 + t8] = 0;
        continue;
      }
      let i10 = 8;
      if (o7 && (i10 = o7[e8 - a9 + t8 - 1] + o7[e8 - a9 + t8] + o7[e8 - a9 + t8 + 1] + o7[e8 + t8 - 1] + o7[e8 + t8 + 1] + o7[e8 + a9 + t8 - 1] + o7[e8 + a9 + t8] + o7[e8 + a9 + t8 + 1], i10 < 7)) {
        g5[e8 + t8] = 0, r11[e8 + t8] = 0;
        continue;
      }
      7 === i10 ? (Z = o7[e8 - a9 + t8 - 1] ? y4[e8 - a9 + t8 - 1] : y4[e8 + t8], k4 = o7[e8 - a9 + t8] ? y4[e8 - a9 + t8] : y4[e8 + t8], P3 = o7[e8 - a9 + t8 + 1] ? y4[e8 - a9 + t8 + 1] : y4[e8 + t8], F = o7[e8 + t8 - 1] ? y4[e8 + t8 - 1] : y4[e8 + t8], b3 = o7[e8 + t8 + 1] ? y4[e8 + t8 + 1] : y4[e8 + t8], C4 = o7[e8 + a9 + t8 - 1] ? y4[e8 + a9 + t8 - 1] : y4[e8 + t8], U4 = o7[e8 + a9 + t8] ? y4[e8 + a9 + t8] : y4[e8 + t8], z2 = o7[e8 + a9 + t8 + 1] ? y4[e8 + a9 + t8 + 1] : y4[e8 + t8]) : (Z = y4[e8 - a9 + t8 - 1], k4 = y4[e8 - a9 + t8], P3 = y4[e8 - a9 + t8 + 1], F = y4[e8 + t8 - 1], b3 = y4[e8 + t8 + 1], C4 = y4[e8 + a9 + t8 - 1], U4 = y4[e8 + a9 + t8], z2 = y4[e8 + a9 + t8 + 1]);
      const s11 = (P3 + b3 + b3 + z2 - (Z + F + F + C4)) * x4, n10 = (C4 + U4 + U4 + z2 - (Z + k4 + k4 + P3)) * A3, l7 = Math.sqrt(1 + s11 * s11 + n10 * n10);
      let c6 = 0;
      if ("traditional" === w3) {
        let t9 = 255 * (u7 + f6 * n10 - h4 * s11) / l7;
        t9 < 0 && (t9 = 0), c6 = t9;
      } else {
        const t9 = p6.length;
        for (let e9 = 0; e9 < t9; e9++) {
          let t10 = 255 * (m6[e9] + p6[e9] * n10 - d5[e9] * s11) / l7;
          t10 < 0 && (t10 = 0), c6 += t10 * M3[e9];
        }
      }
      g5[e8 + t8] = 255 & c6;
    }
  }
  for (let t7 = 0; t7 < l6; t7++)
    g5[t7 * a9] = g5[t7 * a9 + 1], g5[(t7 + 1) * a9 - 1] = g5[(t7 + 1) * a9 - 2];
  for (let t7 = 1; t7 < a9 - 1; t7++)
    g5[t7] = g5[t7 + a9], g5[t7 + (l6 - 1) * a9] = g5[t7 + (l6 - 2) * a9];
  return new u({ width: a9, height: l6, pixels: [g5], mask: o7 ? r11 : null, pixelType: "u8", validPixelCount: s10.validPixelCount, statistics: [{ minValue: 0, maxValue: 255 }] });
}
function n7(t7, i10, s10, n9) {
  if (!i(t7) || !i(i10))
    return;
  const { min: a9, max: l6 } = n9, o7 = t7.pixels[0], { pixels: r11, mask: c5 } = i10, h4 = r11[0], f6 = 255.00001 / (l6 - a9), u7 = new Uint8ClampedArray(h4.length), d5 = new Uint8ClampedArray(h4.length), p6 = new Uint8ClampedArray(h4.length), m6 = s10.length - 1;
  for (let e8 = 0; e8 < h4.length; e8++) {
    if (c5 && 0 === c5[e8])
      continue;
    const t8 = Math.floor((h4[e8] - a9) * f6), [i11, n10] = s10[t8 < 0 ? 0 : t8 > m6 ? m6 : t8], l7 = o7[e8], r12 = l7 * n10, M3 = r12 * (1 - Math.abs(i11 % 2 - 1)), x4 = l7 - r12;
    switch (Math.floor(i11)) {
      case 0:
        u7[e8] = r12 + x4, d5[e8] = M3 + x4, p6[e8] = x4;
        break;
      case 1:
        u7[e8] = M3 + x4, d5[e8] = r12 + x4, p6[e8] = x4;
        break;
      case 2:
        u7[e8] = x4, d5[e8] = r12 + x4, p6[e8] = M3 + x4;
        break;
      case 3:
        u7[e8] = x4, d5[e8] = M3 + x4, p6[e8] = r12 + x4;
        break;
      case 4:
        u7[e8] = M3 + x4, d5[e8] = x4, p6[e8] = r12 + x4;
        break;
      case 5:
      case 6:
        u7[e8] = r12 + x4, d5[e8] = x4, p6[e8] = M3 + x4;
    }
  }
  t7.pixels = [u7, d5, p6], t7.updateStatistics();
}

// node_modules/@arcgis/core/renderers/support/colorRampUtils.js
var i9 = [{ id: "aspect_predefined", type: "multipart", colorRamps: [{ fromColor: [190, 190, 190], toColor: [255, 45, 8] }, { fromColor: [255, 45, 8], toColor: [255, 181, 61] }, { fromColor: [255, 181, 61], toColor: [255, 254, 52] }, { fromColor: [255, 254, 52], toColor: [0, 251, 50] }, { fromColor: [0, 251, 50], toColor: [255, 254, 52] }, { fromColor: [0, 253, 255], toColor: [0, 181, 255] }, { fromColor: [0, 181, 255], toColor: [26, 35, 253] }, { fromColor: [26, 35, 253], toColor: [255, 57, 251] }, { fromColor: [255, 57, 251], toColor: [255, 45, 8] }] }, { id: "blackToWhite_predefined", fromColor: [0, 0, 0], toColor: [255, 255, 255] }, { id: "blueBright_predefined", fromColor: [204, 204, 255], toColor: [0, 0, 224] }, { id: "blueLightToDark_predefined", fromColor: [211, 229, 232], toColor: [46, 100, 140] }, { id: "blueGreenBright_predefined", fromColor: [203, 245, 234], toColor: [48, 207, 146] }, { id: "blueGreenLightToDark_predefined", fromColor: [216, 242, 237], toColor: [21, 79, 74] }, { id: "brownLightToDark_predefined", fromColor: [240, 236, 170], toColor: [102, 72, 48] }, { id: "brownToBlueGreenDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [156, 85, 31], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [33, 130, 145] }] }, { id: "brownToBlueGreenDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [110, 70, 45], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [48, 100, 102] }] }, { id: "coefficientBias_predefined", fromColor: [214, 214, 255], toColor: [0, 57, 148] }, { id: "coldToHotDiverging_predefined", type: "multipart", colorRamps: [{ fromColor: [69, 117, 181], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [214, 47, 39] }] }, { id: "conditionNumber_predefined", type: "multipart", colorRamps: [{ fromColor: [0, 97, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 34, 0] }] }, { id: "cyanToPurple_predefined", type: "multipart", colorRamps: [{ fromColor: [0, 245, 245], toColor: [0, 0, 245] }, { fromColor: [0, 0, 245], toColor: [245, 0, 245] }] }, { id: "cyanLightToBlueDark_predefined", type: "multipart", colorRamps: [{ fromColor: [182, 237, 240], toColor: [31, 131, 224] }, { fromColor: [31, 131, 224], toColor: [9, 9, 145] }] }, { id: "distance_predefined", fromColor: [255, 200, 0], toColor: [0, 0, 255] }, { id: "elevation1_predefined", type: "multipart", colorRamps: [{ fromColor: [175, 240, 233], toColor: [255, 255, 179] }, { fromColor: [255, 255, 179], toColor: [0, 128, 64] }, { fromColor: [0, 128, 64], toColor: [252, 186, 3] }, { fromColor: [252, 186, 3], toColor: [128, 0, 0] }, { fromColor: [120, 0, 0], toColor: [105, 48, 13] }, { fromColor: [105, 48, 13], toColor: [171, 171, 171] }, { fromColor: [171, 171, 171], toColor: [255, 252, 255] }] }, { id: "elevation2_predefined", type: "multipart", colorRamps: [{ fromColor: [118, 219, 211], toColor: [255, 255, 199] }, { fromColor: [255, 255, 199], toColor: [255, 255, 128] }, { fromColor: [255, 255, 128], toColor: [217, 194, 121] }, { fromColor: [217, 194, 121], toColor: [135, 96, 38] }, { fromColor: [135, 96, 38], toColor: [150, 150, 181] }, { fromColor: [150, 150, 181], toColor: [181, 150, 181] }, { fromColor: [181, 150, 181], toColor: [255, 252, 255] }] }, { id: "errors_predefined", fromColor: [255, 235, 214], toColor: [196, 10, 10] }, { id: "grayLightToDark_predefined", fromColor: [219, 219, 219], toColor: [69, 69, 69] }, { id: "greenBright_predefined", fromColor: [204, 255, 204], toColor: [14, 204, 14] }, { id: "greenLightToDark_predefined", fromColor: [220, 245, 233], toColor: [34, 102, 51] }, { id: "greenToBlue_predefined", type: "multipart", colorRamps: [{ fromColor: [32, 204, 16], toColor: [0, 242, 242] }, { fromColor: [0, 242, 242], toColor: [2, 33, 227] }] }, { id: "orangeBright_predefined", fromColor: [255, 235, 204], toColor: [240, 118, 5] }, { id: "orangeLightToDark_predefined", fromColor: [250, 233, 212], toColor: [171, 65, 36] }, { id: "partialSpectrum_predefined", type: "multipart", colorRamps: [{ fromColor: [242, 241, 162], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }, { fromColor: [252, 3, 69], toColor: [176, 7, 237] }, { fromColor: [176, 7, 237], toColor: [2, 29, 173] }] }, { id: "partialSpectrum1Diverging_predefined", type: "multipart", colorRamps: [{ fromColor: [135, 38, 38], toColor: [240, 149, 12] }, { fromColor: [240, 149, 12], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [74, 80, 181] }, { fromColor: [74, 80, 181], toColor: [39, 32, 122] }] }, { id: "partialSpectrum2Diverging_predefined", type: "multipart", colorRamps: [{ fromColor: [115, 77, 42], toColor: [201, 137, 52] }, { fromColor: [201, 137, 52], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [91, 63, 176] }, { fromColor: [91, 63, 176], toColor: [81, 13, 97] }] }, { id: "pinkToYellowGreenDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [158, 30, 113], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [99, 110, 45] }] }, { id: "pinkToYellowGreenDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [97, 47, 73], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [22, 59, 15] }] }, { id: "precipitation_predefined", type: "multipart", colorRamps: [{ fromColor: [194, 82, 60], toColor: [237, 161, 19] }, { fromColor: [237, 161, 19], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 219, 0] }, { fromColor: [0, 219, 0], toColor: [32, 153, 143] }, { fromColor: [32, 153, 143], toColor: [11, 44, 122] }] }, { id: "prediction_predefined", type: "multipart", colorRamps: [{ fromColor: [40, 146, 199], toColor: [250, 250, 100] }, { fromColor: [250, 250, 100], toColor: [232, 16, 20] }] }, { id: "purpleBright_predefined", fromColor: [255, 204, 255], toColor: [199, 0, 199] }, { id: "purpleToGreenDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [77, 32, 150], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [20, 122, 11] }] }, { id: "purpleToGreenDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [67, 14, 89], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [24, 79, 15] }] }, { id: "purpleBlueBright_predefined", fromColor: [223, 184, 230], toColor: [112, 12, 242] }, { id: "purpleBlueLightToDark_predefined", fromColor: [229, 213, 242], toColor: [93, 44, 112] }, { id: "purpleRedBright_predefined", fromColor: [255, 204, 225], toColor: [199, 0, 99] }, { id: "purpleRedLightToDark_predefined", fromColor: [250, 215, 246], toColor: [143, 17, 57] }, { id: "redBright_predefined", fromColor: [255, 204, 204], toColor: [219, 0, 0] }, { id: "redLightToDark_predefined", fromColor: [255, 224, 224], toColor: [143, 10, 10] }, { id: "redToBlueDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [196, 69, 57], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [48, 95, 207] }] }, { id: "redToBlueDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [107, 13, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [13, 53, 97] }] }, { id: "redToGreen_predefined", type: "multipart", colorRamps: [{ fromColor: [245, 0, 0], toColor: [245, 245, 0] }, { fromColor: [245, 245, 0], toColor: [0, 245, 0] }] }, { id: "redToGreenDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [186, 20, 20], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [54, 145, 33] }] }, { id: "redToGreenDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [97, 21, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [16, 69, 16] }] }, { id: "slope_predefined", type: "multipart", colorRamps: [{ fromColor: [56, 168, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }] }, { id: "spectrumFullBright_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 0, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 0, 255] }] }, { id: "spectrumFullDark_predefined", type: "multipart", colorRamps: [{ fromColor: [153, 0, 0], toColor: [153, 153, 0] }, { fromColor: [153, 153, 0], toColor: [0, 153, 153] }, { fromColor: [0, 153, 153], toColor: [0, 0, 153] }] }, { id: "spectrumFullLight_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 153, 153], toColor: [255, 255, 153] }, { fromColor: [255, 255, 153], toColor: [153, 255, 255] }, { fromColor: [153, 255, 255], toColor: [153, 153, 255] }] }, { id: "surface_predefined", type: "multipart", colorRamps: [{ fromColor: [112, 153, 89], toColor: [242, 238, 162] }, { fromColor: [242, 238, 162], toColor: [242, 206, 133] }, { fromColor: [242, 206, 133], toColor: [194, 140, 124] }, { fromColor: [194, 140, 124], toColor: [255, 242, 255] }] }, { id: "temperature_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 252, 255], toColor: [255, 0, 255] }, { fromColor: [255, 0, 255], toColor: [0, 0, 255] }, { fromColor: [0, 0, 255], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 255, 0] }, { fromColor: [0, 255, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 128, 0] }, { fromColor: [255, 128, 0], toColor: [128, 0, 0] }] }, { id: "whiteToBlack_predefined", fromColor: [255, 255, 255], toColor: [0, 0, 0] }, { id: "yellowToDarkRed_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [242, 167, 46] }, { fromColor: [242, 167, 46], toColor: [107, 0, 0] }] }, { id: "yellowToGreenToDarkBlue_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [56, 224, 9] }, { fromColor: [56, 224, 9], toColor: [26, 147, 171] }, { fromColor: [26, 147, 171], toColor: [12, 16, 120] }] }, { id: "yellowToRed_predefined", fromColor: [245, 245, 0], toColor: [255, 0, 0] }, { id: "yellowGreenBright_predefined", fromColor: [236, 252, 204], toColor: [157, 204, 16] }, { id: "yellowGreenLightToDark_predefined", fromColor: [215, 240, 175], toColor: [96, 107, 45] }];
var n8 = { aspect_predefined: "Aspect", blackToWhite_predefined: "Black to White", blueBright_predefined: "Blue Bright", blueLightToDark_predefined: "Blue Light to Dark", blueGreenBright_predefined: "Blue-Green Bright", blueGreenLightToDark_predefined: "Blue-Green Light to Dark", brownLightToDark_predefined: "Brown Light to Dark", brownToBlueGreenDivergingBright_predefined: "Brown to Blue Green Diverging, Bright", brownToBlueGreenDivergingDark_predefined: "Brown to Blue Green Diverging, Dark", coefficientBias_predefined: "Coefficient Bias", coldToHotDiverging_predefined: "Cold to Hot Diverging", conditionNumber_predefined: "Condition Number", cyanToPurple_predefined: "Cyan to Purple", cyanLightToBlueDark_predefined: "Cyan-Light to Blue-Dark", distance_predefined: "Distance", elevation1_predefined: "Elevation #1", elevation2_predefined: "Elevation #2", errors_predefined: "Errors", grayLightToDark_predefined: "Gray Light to Dark", greenBright_predefined: "Green Bright", greenLightToDark_predefined: "Green Light to Dark", greenToBlue_predefined: "Green to Blue", orangeBright_predefined: "Orange Bright", orangeLightToDark_predefined: "Orange Light to Dark", partialSpectrum_predefined: "Partial Spectrum", partialSpectrum1Diverging_predefined: "Partial Spectrum 1 Diverging", partialSpectrum2Diverging_predefined: "Partial Spectrum 2 Diverging", pinkToYellowGreenDivergingBright_predefined: "Pink to YellowGreen Diverging, Bright", pinkToYellowGreenDivergingDark_predefined: "Pink to YellowGreen Diverging, Dark", precipitation_predefined: "Precipitation", prediction_predefined: "Prediction", purpleBright_predefined: "Purple Bright", purpleToGreenDivergingBright_predefined: "Purple to Green Diverging, Bright", purpleToGreenDivergingDark_predefined: "Purple to Green Diverging, Dark", purpleBlueBright_predefined: "Purple-Blue Bright", purpleBlueLightToDark_predefined: "Purple-Blue Light to Dark", purpleRedBright_predefined: "Purple-Red Bright", purpleRedLightToDark_predefined: "Purple-Red Light to Dark", redBright_predefined: "Red Bright", redLightToDark_predefined: "Red Light to Dark", redToBlueDivergingBright_predefined: "Red to Blue Diverging, Bright", redToBlueDivergingDark_predefined: "Red to Blue Diverging, Dark", redToGreen_predefined: "Red to Green", redToGreenDivergingBright_predefined: "Red to Green Diverging, Bright", redToGreenDivergingDark_predefined: "Red to Green Diverging, Dark", slope_predefined: "Slope", spectrumFullBright_predefined: "Spectrum-Full Bright", spectrumFullDark_predefined: "Spectrum-Full Dark", spectrumFullLight_predefined: "Spectrum-Full Light", surface_predefined: "Surface", temperature_predefined: "Temperature", whiteToBlack_predefined: "White to Black", yellowToDarkRed_predefined: "Yellow to Dark Red", yellowToGreenToDarkBlue_predefined: "Yellow to Green to Dark Blue", yellowToRed_predefined: "Yellow to Red", yellowGreenBright_predefined: "Yellow-Green Bright", yellowGreenLightToDark_predefined: "Yellow-Green Light to Dark" };
function d4(o7, r11) {
  if (!o7 || !r11 || o7.length !== r11.length)
    return false;
  for (let e8 = 0; e8 < o7.length; e8++)
    if (o7[e8] > r11[e8] + 2 || o7[e8] < r11[e8] - 2)
      return false;
  return true;
}
function p5(r11, e8) {
  if (!r11)
    return;
  const t7 = e8 || i9;
  let l6, n9 = null;
  return "algorithmic" === r11.type ? t7.some((o7) => {
    if (d4(r11.fromColor.toRgb(), o7.fromColor) && d4(r11.toColor.toRgb(), o7.toColor))
      return n9 = o7.id, true;
  }) : "multipart" === r11.type && t7.some((e9) => {
    if (r11.colorRamps && e9.colorRamps && r11.colorRamps.length === e9.colorRamps.length && (l6 = r11.colorRamps, !e9.colorRamps.some((r12, e10) => {
      if (!d4(l6[e10].fromColor.toRgb(), new l2(r12.fromColor).toRgb()) || !d4(l6[e10].toColor.toRgb(), new l2(r12.toColor).toRgb()))
        return true;
    }))) {
      if (n9)
        return true;
      n9 = e9.id;
    }
  }), n9;
}
function f5(o7) {
  const r11 = p5(o7);
  return r11 ? n8[r11] : null;
}
function C3(o7) {
  const r11 = (o7 = o7 || {}).numColors || 256, e8 = o7.distanceOffset || 0, t7 = null != o7.isCustomInterval ? o7.isCustomInterval : null !== o7.distanceInterval && o7.distanceInterval !== 1 / (r11 - 1), l6 = o7.distanceInterval || 1 / (r11 - 1);
  return { ...o7, numColors: r11, distanceOffset: e8, interpolateAlpha: !!o7.interpolateAlpha, distanceInterval: l6, isCustomInterval: t7, weights: o7.weights };
}
function a8(o7, r11, e8) {
  const { numColors: t7, distanceOffset: l6, distanceInterval: i10, isCustomInterval: n9 } = C3(e8), d5 = 0 === o7.s, p6 = 0 === r11.s;
  let f6 = o7.h, a9 = r11.h;
  d5 && !p6 ? f6 = a9 : p6 && !d5 && (r11 = { ...r11, h: f6 }, a9 = f6);
  let m6, u7 = Math.abs(a9 - f6);
  const g5 = 360;
  u7 < g5 / 2 ? m6 = (a9 - f6) * i10 : (u7 = g5 - u7, m6 = f6 > a9 ? u7 * i10 : -u7 * i10);
  const s10 = (r11.s - o7.s) * i10, c5 = (r11.v - o7.v) * i10;
  let { s: h4, v: _3 } = o7, D4 = f6;
  if (l6) {
    const o8 = l6 / i10;
    D4 = (D4 + o8 * m6 + g5) % g5, h4 += o8 * s10, _3 += o8 * c5;
  }
  const B2 = [];
  for (let C4 = 0; C4 < t7 - 1; C4++)
    B2.push({ h: D4, s: h4, v: _3 }), D4 = (D4 + m6 + g5) % g5, h4 += s10, _3 += c5;
  return B2.push(n9 ? { h: D4, s: h4, v: _3 } : r11), B2;
}
function m5(o7, r11, e8) {
  const { numColors: t7, distanceOffset: l6, distanceInterval: i10, isCustomInterval: n9 } = C3(e8);
  let { l: d5, a: p6, b: f6 } = o7;
  const a9 = (r11.l - d5) * i10, m6 = (r11.a - p6) * i10, u7 = (r11.b - f6) * i10, g5 = [];
  if (l6) {
    const o8 = l6 / i10;
    d5 += o8 * a9, p6 += o8 * m6, f6 += o8 * u7;
  }
  for (let C4 = 0; C4 < t7 - 1; C4++)
    g5.push({ l: d5, a: p6, b: f6 }), d5 += a9, p6 += m6, f6 += u7;
  return g5.push(n9 ? { l: d5, a: p6, b: f6 } : r11), g5;
}
function u6(o7, r11, e8) {
  const { numColors: t7, distanceOffset: l6, distanceInterval: i10, isCustomInterval: n9 } = C3(e8), d5 = o7.h, p6 = r11.h, f6 = 2 * Math.PI;
  let a9;
  if (d5 <= p6) {
    const o8 = p6 - d5, r12 = p6 - d5 - f6;
    a9 = Math.abs(r12) < Math.abs(o8) ? r12 : o8;
  } else {
    const o8 = p6 + f6 - d5, r12 = p6 - d5;
    a9 = Math.abs(r12) < Math.abs(o8) ? r12 : o8;
  }
  const m6 = a9 * i10, u7 = (r11.l - o7.l) * i10, g5 = (r11.c - o7.c) * i10;
  let { l: s10, c: c5, h: h4 } = o7;
  if (l6) {
    const o8 = l6 / i10;
    s10 += o8 * u7, c5 += o8 * g5, h4 = (h4 + o8 * m6 + f6) % f6;
  }
  const _3 = [];
  for (let C4 = 0; C4 < t7 - 1; C4++)
    _3.push({ l: s10, c: c5, h: h4 }), s10 += u7, c5 += g5, h4 = (h4 + m6 + f6) % f6;
  return _3.push(n9 ? { l: s10, c: c5, h: h4 } : r11), _3;
}
function g4(o7, i10) {
  let { fromColor: n9, toColor: d5 } = o7;
  3 === n9.length && (n9 = n9.concat([255])), 3 === d5.length && (d5 = d5.concat([255]));
  const p6 = o7.algorithm || "esriCIELabAlgorithm", { numColors: f6, distanceOffset: g5, isCustomInterval: s10, interpolateAlpha: c5 } = C3(i10);
  if (1 === f6 && 0 === g5)
    return [n9];
  if (2 === f6 && 0 === g5 && !s10)
    return [n9, d5];
  const h4 = { r: n9[0], g: n9[1], b: n9[2] }, _3 = { r: d5[0], g: d5[1], b: d5[2] }, D4 = "esriCIELabAlgorithm" === p6 ? m5(z(h4), z(_3), i10) : "esriHSVAlgorithm" === p6 ? a8(y(h4), y(_3), i10) : u6(v(h4), v(_3), i10), B2 = [], R3 = n9[3] ?? 255, k4 = ((d5[3] ?? 255) - R3) / (f6 - 1);
  for (let r11 = 0; r11 < f6; r11++) {
    const { r: o8, g: e8, b: t7 } = p2(D4[r11]), i11 = c5 ? Math.round(R3 + k4 * r11) : 255;
    B2.push([o8, e8, t7, i11]);
  }
  return B2;
}
function s9(o7, r11) {
  const { numColors: e8, interpolateAlpha: t7 } = C3(r11);
  let l6 = r11 == null ? void 0 : r11.weights;
  const { colorRamps: i10 } = o7;
  if (l6) {
    const o8 = l6.reduce((o9, r12) => o9 + r12);
    l6 = l6.map((r12) => r12 / o8);
  } else {
    l6 = [];
    for (let o8 = 0; o8 < i10.length; o8++)
      l6[o8] = 1 / i10.length;
  }
  const n9 = [];
  let d5 = 0, p6 = 0;
  const f6 = 1 / (e8 - 1);
  let a9 = false;
  for (let C4 = 0; C4 < i10.length; C4++) {
    let o8 = a9 ? 0 : d5 * f6 - p6, r12 = C4 === i10.length - 1 ? e8 - 1 - d5 : (l6[C4] - o8) / f6;
    if (a9 = Math.ceil(r12) === r12, r12 = Math.ceil(r12), 0 === r12)
      continue;
    o8 /= l6[C4];
    const m7 = g4(i10[C4], { numColors: r12, interpolateAlpha: t7, distanceOffset: o8, distanceInterval: f6 / l6[C4] });
    d5 += m7.length, n9.push(...m7), p6 += l6[C4];
  }
  const m6 = [...i10[i10.length - 1].toColor];
  return 3 === m6.length && m6.push(255), n9.push(m6), n9;
}
function c4(o7, r11 = 256, e8 = false) {
  const t7 = "toJSON" in o7 ? o7.toJSON() : o7, l6 = { numColors: r11, interpolateAlpha: e8 };
  return "multipart" === t7.type ? s9(t7, l6) : g4(t7, l6);
}
function h3(o7, r11 = 256, e8 = false) {
  const t7 = c4(o7, r11, e8);
  return t7.forEach((o8, r12) => {
    o8.unshift(r12), e8 || o8.pop();
  }), t7;
}
function _(o7) {
  const r11 = f5(o7);
  if (o7) {
    if ("algorithmic" === o7.type)
      return { ...D3(o7), Name: r11 };
    if (o7.colorRamps) {
      const e8 = o7.colorRamps.map(D3);
      return { type: "MultiPartColorRamp", NumColorRamps: e8.length, ArrayOfColorRamp: e8, Name: r11 };
    }
  }
}
function D3(o7) {
  var _a;
  if (!o7)
    return;
  return { Algorithm: ((_a = o7.toJSON()) == null ? void 0 : _a.Algorithm) || "esriHSVAlgorithm", type: "AlgorithmicColorRamp", FromColor: B(o7.fromColor), ToColor: B(o7.toColor) };
}
function B(o7) {
  const e8 = y(o7);
  return { type: "HsvColor", Hue: e8.h, Saturation: e8.s, Value: e8.v, AlphaValue: 255 };
}
function R2(o7) {
  const r11 = o7.reverse().map((o8) => {
    const r12 = o8.toString(16);
    return r12.length < 2 ? "0" + r12 : r12;
  });
  return 4294967295 & Number.parseInt(r11.join(""), 16);
}

// node_modules/@arcgis/core/renderers/support/RasterSymbolizer.js
var _2 = s.getLogger("esri.renderers.support.RasterSymbolizer");
function L2(e8, t7) {
  const { attributeTable: r11, bandCount: s10 } = e8;
  if (t(r11) || s10 > 1)
    return false;
  if (t7) {
    if (null == r11.fields.find((e9) => e9.name.toLowerCase() === t7.toLowerCase()))
      return false;
  }
  return true;
}
function V(e8) {
  const { bandCount: t7, dataType: r11, pixelType: s10 } = e8;
  return "elevation" === r11 || "generic" === r11 && 1 === t7 && ("s16" === s10 || "f32" === s10 || "f64" === s10);
}
function v3(e8) {
  const { bandCount: t7, colormap: r11 } = e8;
  return r(r11) && r11.length && 1 === t7;
}
var O2 = class extends l {
  constructor(e8) {
    super(e8);
  }
  bind() {
    const { rendererJSON: e8 } = this;
    if (!e8)
      return { success: false };
    let t7;
    switch (this.lookup = { rendererJSON: {} }, e8.type) {
      case "uniqueValue":
        t7 = this._updateUVRenderer(e8);
        break;
      case "rasterColormap":
        t7 = this._updateColormapRenderer(e8);
        break;
      case "rasterStretch":
        t7 = this._updateStretchRenderer(e8);
        break;
      case "classBreaks":
        t7 = this._updateClassBreaksRenderer(e8);
        break;
      case "rasterShadedRelief":
        t7 = this._updateShadedReliefRenderer(e8);
        break;
      case "vectorField":
        t7 = this._updateVectorFieldRenderer();
        break;
      case "flowRenderer":
        t7 = this._updateFlowRenderer();
    }
    return t7;
  }
  symbolize(e8) {
    let t7 = e8 && e8.pixelBlock;
    if (!T3(t7))
      return t7;
    if (e8.simpleStretchParams && "rasterStretch" === this.rendererJSON.type)
      return this.simpleStretch(t7, e8.simpleStretchParams);
    try {
      let r11;
      switch (t7.pixels.length > 3 && (t7 = l3(t7, [0, 1, 2])), this.rendererJSON.type) {
        case "uniqueValue":
        case "rasterColormap":
          r11 = this._symbolizeColormap(t7);
          break;
        case "classBreaks":
          r11 = this._symbolizeClassBreaks(t7);
          break;
        case "rasterStretch":
          r11 = this._symbolizeStretch(t7, e8.bandIds);
          break;
        case "rasterShadedRelief": {
          const { extent: s10 } = e8, o7 = s10.spatialReference.isGeographic, a9 = { x: (s10.xmax - s10.xmin) / t7.width, y: (s10.ymax - s10.ymin) / t7.height };
          r11 = this._symbolizeShadedRelief(t7, { isGCS: o7, resolution: a9 });
          break;
        }
      }
      return r11;
    } catch (r11) {
      return _2.error("symbolize", r11.message), t7;
    }
  }
  simpleStretch(e8, t7) {
    if (!T3(e8))
      return e8;
    try {
      return e8.pixels.length > 3 && (e8 = l3(e8, [0, 1, 2])), x3(e8, t7);
    } catch (r11) {
      return _2.error("symbolize", r11.message), e8;
    }
  }
  generateWebGLParameters(e8) {
    var _a;
    if (["uniqueValue", "rasterColormap", "classBreaks"].includes(this.rendererJSON.type)) {
      const { indexedColormap: e9, offset: t8 } = ((_a = this.lookup) == null ? void 0 : _a.colormapLut) || {};
      return { colormap: e9, colormapOffset: t8, type: "lut" };
    }
    const { pixelBlock: t7, isGCS: r11, resolution: s10, bandIds: o7 } = e8, { rendererJSON: a9 } = this;
    return "rasterStretch" === a9.type ? this._generateStretchWebGLParams(t7, a9, o7) : "rasterShadedRelief" === a9.type ? this._generateShadedReliefWebGLParams(a9, r11, s10) : "vectorField" === a9.type ? this._generateVectorFieldWebGLParams(a9) : null;
  }
  _isLUTChanged(e8) {
    if (!this.lookup || !this.lookup.rendererJSON)
      return true;
    if ("colorRamp" in this.rendererJSON) {
      const t7 = this.rendererJSON.colorRamp;
      return e8 ? JSON.stringify(t7) !== JSON.stringify(this.lookup.rendererJSON.colorRamp) : (this.rendererJSON, this.lookup.rendererJSON, JSON.stringify(this.rendererJSON) !== JSON.stringify(this.lookup.rendererJSON));
    }
    return JSON.stringify(this.rendererJSON) !== JSON.stringify(this.lookup.rendererJSON);
  }
  _symbolizeColormap(e8) {
    if (this._isLUTChanged()) {
      if (!this.bind().success)
        return e8;
    }
    return r2(e8, this.lookup.colormapLut);
  }
  _symbolizeClassBreaks(e8) {
    const { canUseIndexedLUT: t7 } = this._analyzeClassBreaks(this.rendererJSON);
    if (this._isLUTChanged()) {
      if (!this.bind().success)
        return e8;
    }
    return t7 ? r2(e8, this.lookup.colormapLut) : a2(e8, this.lookup.remapLut);
  }
  _symbolizeStretch(e8, t7) {
    var _a;
    const { rasterInfo: r11 } = this, { pixelType: s10, bandCount: a9 } = r11, n9 = this.rendererJSON, i10 = ["u8", "u16", "s8", "s16"].includes(s10);
    let l6, u7;
    const { dra: c5 } = n9, { gamma: p6 } = this.lookup;
    if ("histogramEqualization" === n9.stretchType) {
      const s11 = c5 ? null : this.lookup.histogramLut, o7 = h2(n9, { rasterInfo: r11, pixelBlock: e8, bandIds: t7, returnHistogramLut: !s11 }), a10 = x3(e8, { ...o7, gamma: p6 });
      u7 = s3(a10, { lut: c5 ? o7.histogramLut : s11, offset: 0 });
    } else if (i10) {
      if (c5) {
        const o7 = h2(n9, { rasterInfo: r11, pixelBlock: e8, bandIds: t7 });
        l6 = a6({ pixelType: s10, ...o7, gamma: p6 });
      } else if (this._isLUTChanged()) {
        if (!this.bind().success)
          return e8;
        l6 = this.lookup ? this.lookup.stretchLut : null;
      } else
        l6 = this.lookup ? this.lookup.stretchLut : null;
      if (!l6)
        return e8;
      a9 > 1 && (t7 == null ? void 0 : t7.length) === ((_a = e2(e8)) == null ? void 0 : _a.pixels.length) && (l6 == null ? void 0 : l6.lut.length) === a9 && (l6 = { lut: t7.map((e9) => l6.lut[e9]), offset: l6.offset }), u7 = s3(e8, l6);
    } else {
      const s11 = h2(n9, { rasterInfo: r11, pixelBlock: e8, bandIds: t7 });
      u7 = x3(e8, { ...s11, gamma: p6 });
    }
    if (n9.colorRamp) {
      if (this._isLUTChanged(true)) {
        if (!this.bind().success)
          return e8;
      }
      u7 = r2(u7, this.lookup.colormapLut);
    }
    return u7;
  }
  _symbolizeShadedRelief(e8, t7) {
    var _a;
    const r11 = this.rendererJSON, s10 = { ...r11, ...t7 }, a9 = s8(e8, s10);
    if (!r11.colorRamp)
      return a9;
    let n9;
    if (this._isLUTChanged(true)) {
      if (!this.bind().success)
        return a9;
      n9 = this.lookup ? this.lookup.hsvMap : null;
    } else
      n9 = this.lookup ? this.lookup.hsvMap : null;
    if (!n9)
      return a9;
    const i10 = ((_a = e2(this.rasterInfo.statistics)) == null ? void 0 : _a[0]) ?? { min: 0, max: 8e3 };
    return n7(a9, e8, n9, i10), a9;
  }
  _isVectorFieldData() {
    const { bandCount: e8, dataType: t7 } = this.rasterInfo;
    return 2 === e8 && ("vector-magdir" === t7 || "vector-uv" === t7);
  }
  _updateVectorFieldRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateFlowRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateUVRenderer(e8) {
    const { bandCount: t7, attributeTable: r11, pixelType: s10 } = this.rasterInfo, o7 = e8.field1;
    if (!o7)
      return { success: false, error: "Unsupported renderer; missing UniqueValueRenderer.field." };
    const a9 = e8.defaultSymbol, n9 = 1 === t7 && ["u8", "s8"].includes(s10);
    if (!L2(this.rasterInfo, o7) && !n9)
      return { success: false, error: "Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table." };
    const i10 = [];
    if (r11) {
      const t8 = r11.fields.find((e9) => "value" === e9.name.toLowerCase());
      if (!t8)
        return { success: false, error: "Unsupported data; the data's raster attribute table does not have a value field." };
      r11.features.forEach((r12) => {
        var _a, _b;
        const s11 = (_b = (_a = e8.uniqueValueInfos.find((e9) => String(e9.value) === String(r12.attributes[o7]))) == null ? void 0 : _a.symbol) == null ? void 0 : _b.color;
        s11 ? i10.push([r12.attributes[t8.name]].concat(s11)) : a9 && i10.push([r12.attributes[t8.name]].concat(a9.color));
      });
    } else {
      if ("value" !== o7.toLowerCase())
        return { success: false, error: 'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not availalbe.' };
      e8.uniqueValueInfos.forEach((e9) => {
        var _a;
        const t8 = (_a = e9 == null ? void 0 : e9.symbol) == null ? void 0 : _a.color;
        t8 ? i10.push([parseInt("" + e9.value, 10)].concat(t8)) : a9 && i10.push([parseInt("" + e9.value, 10)].concat(a9.color));
      });
    }
    if (0 === i10.length)
      return { success: false, error: "Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table." };
    const l6 = o({ colormap: i10 });
    return this.lookup = { rendererJSON: e8, colormapLut: l6 }, this.canRenderInWebGL = true, { success: true };
  }
  _updateColormapRenderer(e8) {
    if (!v3(this.rasterInfo))
      return { success: false, error: "Unsupported data; the data source does not have a colormap." };
    const t7 = e8.colormapInfos.map((e9) => [e9.value].concat(e9.color)).sort((e9, t8) => e9[0] - t8[0]);
    if (!t7 || 0 === t7.length)
      return { success: false, error: "Unsupported renderer; ColormapRenderer must have meaningful colormapInfos." };
    const r11 = o({ colormap: t7 });
    return this.lookup = { rendererJSON: e8, colormapLut: r11 }, this.canRenderInWebGL = true, { success: true };
  }
  _updateShadedReliefRenderer(e8) {
    if (!V(this.rasterInfo))
      return { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.` };
    if (e8.colorRamp) {
      const r11 = h3(e8.colorRamp, 256, true), s10 = o({ colormap: r11 }), o7 = [], a9 = s10.indexedColormap;
      for (let e9 = 0; e9 < a9.length; e9 += 4) {
        const r12 = y({ r: a9[e9], g: a9[e9 + 1], b: a9[e9 + 2] });
        o7.push([r12.h / 60, r12.s / 100, 255 * r12.v / 100]);
      }
      this.lookup = { rendererJSON: e8, colormapLut: s10, hsvMap: o7 };
    } else
      this.lookup = null;
    return this.canRenderInWebGL = true, { success: true };
  }
  _analyzeClassBreaks(e8) {
    const { attributeTable: t7, pixelType: r11 } = this.rasterInfo, s10 = r(t7) ? t7.fields.find((e9) => "value" === e9.name.toLowerCase()) : null, o7 = r(t7) ? t7.fields.find((t8) => t8.name.toLowerCase() === e8.field.toLowerCase()) : null, n9 = null != s10 && null !== o7;
    return { canUseIndexedLUT: ["u8", "u16", "s8", "s16"].includes(r11) || n9, tableValueField: s10, tableBreakField: o7 };
  }
  _updateClassBreaksRenderer(e8) {
    const { attributeTable: t7 } = this.rasterInfo, { canUseIndexedLUT: r11, tableValueField: s10, tableBreakField: o7 } = this._analyzeClassBreaks(e8), a9 = e8.classBreakInfos;
    if (!(a9 == null ? void 0 : a9.length))
      return { success: false, error: "Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos." };
    const n9 = a9.sort((e9, t8) => e9.classMaxValue - t8.classMaxValue), i10 = n9[n9.length - 1];
    let l6 = e8.minValue;
    if (!r11) {
      const t8 = [];
      for (let e9 = 0; e9 < n9.length; e9++)
        t8.push({ value: n9[e9].classMinValue ?? l6, mappedColor: n9[e9].symbol.color }), l6 = n9[e9].classMaxValue;
      return t8.push({ value: i10.classMaxValue, mappedColor: i10.symbol.color }), this.lookup = { rendererJSON: e8, remapLut: t8 }, this.canRenderInWebGL = false, { success: true };
    }
    const u7 = [];
    if (null != s10 && null !== o7 && s10 !== o7) {
      const r12 = s10.name, a10 = o7.name, i11 = n9[n9.length - 1], { classMaxValue: c6 } = i11;
      l6 = e8.minValue;
      for (const e9 of t7.features) {
        const t8 = e9.attributes[r12], s11 = e9.attributes[a10], o8 = s11 === c6 ? i11 : s11 < l6 ? null : n9.find(({ classMaxValue: e10 }) => e10 > s11);
        o8 && u7.push([t8].concat(o8.symbol.color));
      }
    } else {
      l6 = Math.floor(e8.minValue);
      for (let e9 = 0; e9 < n9.length; e9++) {
        const t8 = n9[e9];
        for (let e10 = l6; e10 < t8.classMaxValue; e10++)
          u7.push([e10].concat(t8.symbol.color));
        l6 = Math.ceil(t8.classMaxValue);
      }
      i10.classMaxValue === l6 && u7.push([i10.classMaxValue].concat(i10.symbol.color));
    }
    const c5 = o({ colormap: u7, fillUnspecified: false });
    return this.lookup = { rendererJSON: e8, colormapLut: c5 }, this.canRenderInWebGL = true, { success: true };
  }
  _isHistogramRequired(e8) {
    return "percentClip" === e8 || "histogramEqualization" === e8;
  }
  _isValidRasterStatistics(e8) {
    return r(e8) && e8.length > 0 && null != e8[0].min && null != e8[0].max;
  }
  _updateStretchRenderer(e8) {
    var _a, _b;
    let { stretchType: t7, dra: r11 } = e8;
    if (!("none" === t7 || ((_a = e8.statistics) == null ? void 0 : _a.length) || this._isValidRasterStatistics(this.rasterInfo.statistics) || r11))
      return { success: false, error: "Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used." };
    const s10 = e2(e8.histograms || this.rasterInfo.histograms);
    !this._isHistogramRequired(e8.stretchType) || (s10 == null ? void 0 : s10.length) || r11 || (t7 = "minMax");
    const { computeGamma: a9, useGamma: n9, colorRamp: i10 } = e8;
    let { gamma: l6 } = e8;
    if (n9 && a9 && !(l6 == null ? void 0 : l6.length)) {
      const t8 = ((_b = e8.statistics) == null ? void 0 : _b.length) ? e8.statistics : e2(this.rasterInfo.statistics);
      l6 = l4(this.rasterInfo.pixelType, t8);
    }
    const u7 = this.rasterInfo.pixelType, c5 = !r11 && ["u8", "u16", "s8", "s16"].includes(u7);
    if ("histogramEqualization" === t7) {
      const t8 = s10.map((e9) => r10(e9));
      this.lookup = { rendererJSON: e8, histogramLut: t8 };
    } else if (c5) {
      const t8 = h2(e8, { rasterInfo: this.rasterInfo }), r12 = a6({ pixelType: u7, ...t8, gamma: n9 ? l6 : null });
      this.lookup = { rendererJSON: e8, stretchLut: r12 };
    }
    if (i10) {
      const t8 = h3(i10, 256, true);
      this.lookup || (this.lookup = { rendererJSON: e8 }), this.lookup.colormapLut = o({ colormap: t8 }), this.lookup.rendererJSON = e8;
    }
    return this.lookup.gamma = n9 && (l6 == null ? void 0 : l6.length) ? l6 : null, this.canRenderInWebGL = true, { success: true };
  }
  _generateStretchWebGLParams(e8, t7, r11) {
    let s10 = null, o7 = null;
    const n9 = this.lookup && this.lookup.colormapLut;
    t7.colorRamp && n9 && (s10 = n9.indexedColormap, o7 = n9.offset), "histogramEqualization" === t7.stretchType && (t7 = { ...t7, stretchType: "minMax" });
    const { gamma: i10 } = this.lookup, l6 = !!(t7.useGamma && i10 && i10.some((e9) => 1 !== e9)), { minCutOff: u7, maxCutOff: c5, outMin: p6, outMax: d5 } = h2(t7, { rasterInfo: this.rasterInfo, pixelBlock: e8, bandIds: r11 });
    let h4 = 0;
    r(e8) && (h4 = e8.getPlaneCount(), 2 === h4 && ((e8 = e8.clone()).statistics = [e8.statistics[0]], e8.pixels = [e8.pixels[0]]));
    const m6 = Math.min(3, (r11 == null ? void 0 : r11.length) || h4 || this.rasterInfo.bandCount), f6 = new Float32Array(m6), b3 = s10 || l6 ? 1 : 255;
    let g5;
    for (g5 = 0; g5 < m6; g5++)
      f6[g5] = (d5 - p6) / (c5[g5] - u7[g5]) / b3;
    const S4 = new Float32Array(m6);
    if (l6)
      for (g5 = 0; g5 < m6; g5++)
        i10[g5] > 1 ? i10[g5] > 2 ? S4[g5] = 6.5 + (i10[g5] - 2) ** 2.5 : S4[g5] = 6.5 + 100 * (2 - i10[g5]) ** 4 : S4[g5] = 1;
    return { bandCount: m6, outMin: p6 / b3, outMax: d5 / b3, minCutOff: u7, maxCutOff: c5, factor: f6, useGamma: l6, gamma: l6 ? i10 : [1, 1, 1], gammaCorrection: l6 ? S4 : [1, 1, 1], colormap: s10, colormapOffset: o7, stretchType: t7.stretchType, type: "stretch" };
  }
  _generateShadedReliefWebGLParams(e8, t7, r11) {
    var _a;
    let s10 = null, a9 = null;
    const n9 = this.lookup && this.lookup.colormapLut;
    e8.colorRamp && n9 && (s10 = n9.indexedColormap, a9 = n9.offset);
    const i10 = { ...e8, isGCS: t7, resolution: r11 }, l6 = i8(i10), u7 = (_a = e2(this.rasterInfo.statistics)) == null ? void 0 : _a[0];
    return { ...l6, minValue: (u7 == null ? void 0 : u7.min) ?? 0, maxValue: (u7 == null ? void 0 : u7.max) ?? 8e3, hillshadeType: "traditional" === e8.hillshadeType ? 0 : 1, type: "hillshade", colormap: s10, colormapOffset: a9 };
  }
  _generateVectorFieldWebGLParams(e8) {
    var _a, _b, _c;
    const { style: t7, inputUnit: r11, outputUnit: s10, visualVariables: o7, symbolTileSize: n9, flowRepresentation: i10 } = e8;
    let l6;
    const u7 = ((_a = this.rasterInfo.statistics) == null ? void 0 : _a[0].min) ?? 0, c5 = ((_b = this.rasterInfo.statistics) == null ? void 0 : _b[0].max) ?? 50, p6 = (o7 == null ? void 0 : o7.find((e9) => "sizeInfo" === e9.type)) ?? { type: "sizeInfo", field: "Magnitude", maxDataValue: c5, maxSize: 0.8 * n9, minDataValue: u7, minSize: 0.2 * n9 }, d5 = p6.minDataValue ?? u7, h4 = p6.maxDataValue ?? c5, m6 = r(p6.maxSize) && r(p6.minSize) ? [p6.minSize / n9, p6.maxSize / n9] : [0.2, 0.8];
    if ("wind_speed" === t7) {
      const e9 = (m6[0] + m6[1]) / 2;
      m6[0] = m6[1] = e9;
    }
    const f6 = r(d5) && r(h4) ? [d5, h4] : null;
    if ("classified_arrow" === t7)
      if (r(d5) && r(h4) && r(p6)) {
        l6 = [];
        const e9 = (p6.maxDataValue - p6.minDataValue) / 5;
        for (let t8 = 0; t8 < 6; t8++)
          l6.push(p6.minDataValue + e9 * t8);
      } else
        l6 = [0, 1e-6, 3.5, 7, 10.5, 14];
    const b3 = "flow_to" === i10 === ("ocean_current_kn" === t7 || "ocean_current_m" === t7) ? 0 : Math.PI, y4 = o7 == null ? void 0 : o7.find((e9) => "rotationInfo" === e9.type);
    return { breakValues: l6, dataRange: f6, inputUnit: r11, outputUnit: s10, symbolTileSize: n9, symbolPercentRange: m6, style: t7 || "single_arrow", rotation: b3, rotationType: ((_c = this.rasterInfo.storageInfo) == null ? void 0 : _c.tileInfo) && "vector-uv" === this.rasterInfo.dataType ? "geographic" : (y4 == null ? void 0 : y4.rotationType) || e8.rotationType, type: "vectorField" };
  }
};
function T3(e8) {
  return i(e8) && 0 !== e8.validPixelCount;
}
e([d({ json: { write: true } })], O2.prototype, "rendererJSON", void 0), e([d({ type: l5, json: { write: true } })], O2.prototype, "rasterInfo", void 0), e([d({ json: { write: true } })], O2.prototype, "lookup", void 0), e([d()], O2.prototype, "canRenderInWebGL", void 0), O2 = e([n("esri.renderers.support.RasterSymbolizer")], O2);
var U3 = O2;

export {
  i9 as i,
  f5 as f,
  h3 as h,
  _,
  R2 as R,
  p4 as p,
  l5 as l,
  r8 as r,
  n6 as n,
  r9 as r2,
  x,
  b,
  D,
  N,
  k2 as k,
  P2 as P,
  S3 as S,
  m4 as m,
  c3 as c,
  U3 as U
};
//# sourceMappingURL=chunk-3SB6OSK7.js.map
