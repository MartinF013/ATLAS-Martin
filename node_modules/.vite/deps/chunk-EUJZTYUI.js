import {
  I,
  f,
  m,
  n
} from "./chunk-45USOESC.js";
import {
  a
} from "./chunk-HMUUQDIL.js";
import {
  s as s2
} from "./chunk-7USXBUJ4.js";
import {
  b
} from "./chunk-P3QN5DXX.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";

// node_modules/@arcgis/core/portal/support/portalLayers.js
function u(e) {
  return !e.portalItem || e.portalItem instanceof b || (e = { ...e, portalItem: new b(e.portalItem) }), i(e.portalItem).then((r) => {
    const t = { portalItem: e.portalItem, ...r.properties };
    return new (0, r.constructor)(t);
  });
}
function i(e) {
  return e.load().then(l).then(y);
}
function l(r) {
  switch (r.type) {
    case "Map Service":
      return m2(r);
    case "Feature Service":
      return p(r);
    case "Feature Collection":
      return L(r);
    case "Scene Service":
      return f2(r);
    case "Image Service":
      return d(r);
    case "Stream Service":
      return N();
    case "Vector Tile Service":
      return S();
    case "KML":
      return I2();
    case "WFS":
      return h();
    case "WMTS":
      return w();
    case "WMS":
      return g();
    case "Feed":
      return T();
    default:
      return Promise.reject(new s("portal:unknown-item-type", "Unknown item type '${type}'", { type: r.type }));
  }
}
function y(e) {
  return (0, a[e.className])().then((r) => ({ constructor: r, properties: e.properties }));
}
function m2(e) {
  return M(e).then((e2) => e2 ? { className: "TileLayer" } : { className: "MapImageLayer" });
}
function p(e) {
  return j(e).then((e2) => {
    if ("object" == typeof e2) {
      const r = {};
      return null != e2.id && (r.layerId = e2.id), { className: "FeatureLayer", properties: r };
    }
    return { className: "GroupLayer" };
  });
}
function f2(e) {
  return j(e).then((r) => {
    if ("object" == typeof r) {
      const t = {};
      let a2;
      if (null != r.id ? (t.layerId = r.id, a2 = `${e.url}/layers/${r.id}`) : a2 = e.url, Array.isArray(e.typeKeywords) && e.typeKeywords.length > 0) {
        const r2 = { IntegratedMesh: "IntegratedMeshLayer", "3DObject": "SceneLayer", Point: "SceneLayer", PointCloud: "PointCloudLayer", Building: "BuildingSceneLayer" };
        for (const t2 of Object.keys(r2))
          if (e.typeKeywords.includes(t2))
            return { className: r2[t2] };
      }
      return n(a2).then((e2) => {
        let r2 = "SceneLayer";
        const a3 = { Point: "SceneLayer", "3DObject": "SceneLayer", IntegratedMesh: "IntegratedMeshLayer", PointCloud: "PointCloudLayer", Building: "BuildingSceneLayer" };
        return e2 && e2.layerType && a3[e2.layerType] && (r2 = a3[e2.layerType]), { className: r2, properties: t };
      });
    }
    return false === r ? n(e.url).then((e2) => "Voxel" === (e2 == null ? void 0 : e2.layerType) ? { className: "VoxelLayer" } : { className: "GroupLayer" }) : { className: "GroupLayer" };
  });
}
async function L(e) {
  await e.load();
  if (s2(e, "Map Notes"))
    return { className: "MapNotesLayer" };
  if (s2(e, "Route Layer"))
    return { className: "RouteLayer" };
  const r = await e.fetchData();
  return 1 === I(r) ? { className: "FeatureLayer" } : { className: "GroupLayer" };
}
async function d(e) {
  var _a, _b, _c;
  await e.load();
  const r = ((_a = e.typeKeywords) == null ? void 0 : _a.map((e2) => e2.toLowerCase())) ?? [];
  if (r.includes("elevation 3d layer"))
    return { className: "ElevationLayer" };
  if (r.includes("tiled imagery"))
    return { className: "ImageryTileLayer" };
  const t = (_b = await e.fetchData()) == null ? void 0 : _b.layerType;
  if ("ArcGISTiledImageServiceLayer" === t)
    return { className: "ImageryTileLayer" };
  if ("ArcGISImageServiceLayer" === t)
    return { className: "ImageryLayer" };
  const a2 = (_c = (await n(e.url)).cacheType) == null ? void 0 : _c.toLowerCase();
  return "map" === a2 ? { className: "ImageryTileLayer" } : { className: "ImageryLayer" };
}
function N() {
  return { className: "StreamLayer" };
}
function S() {
  return { className: "VectorTileLayer" };
}
function I2() {
  return { className: "KMLLayer" };
}
function h() {
  return { className: "WFSLayer" };
}
function g() {
  return { className: "WMSLayer" };
}
function w() {
  return { className: "WMTSLayer" };
}
function T() {
  return { className: "StreamLayer" };
}
function M(e) {
  return n(e.url).then((e2) => e2.tileInfo);
}
function j(e) {
  return !e.url || e.url.match(/\/\d+$/) ? Promise.resolve({}) : e.load().then(() => e.fetchData()).then(async (r) => {
    if ("Feature Service" === e.type)
      return v(r = await f(r, e.url));
    return I(r) > 0 ? v(r) : n(e.url).then(v);
  });
}
function v(e) {
  return 1 === I(e) && { id: m(e) };
}

export {
  u,
  l
};
//# sourceMappingURL=chunk-EUJZTYUI.js.map
