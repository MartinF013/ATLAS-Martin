import {
  t
} from "./chunk-WN3KE5M2.js";
import {
  s
} from "./chunk-EQNRDJV7.js";

// node_modules/@arcgis/core/chunks/geometryEngineJSON.js
function t2(n) {
  return s.extendedSpatialReferenceInfo(n);
}
function r(t3, r2, i2) {
  return s.clip(t, t3, r2, i2);
}
function i(t3, r2, i2) {
  return s.cut(t, t3, r2, i2);
}
function s2(t3, r2, i2) {
  return s.contains(t, t3, r2, i2);
}
function o(t3, r2, i2) {
  return s.crosses(t, t3, r2, i2);
}
function u(t3, r2, i2, s3) {
  return s.distance(t, t3, r2, i2, s3);
}
function a(t3, r2, i2) {
  return s.equals(t, t3, r2, i2);
}
function c(t3, r2, i2) {
  return s.intersects(t, t3, r2, i2);
}
function f(t3, r2, i2) {
  return s.touches(t, t3, r2, i2);
}
function l(t3, r2, i2) {
  return s.within(t, t3, r2, i2);
}
function p(t3, r2, i2) {
  return s.disjoint(t, t3, r2, i2);
}
function g(t3, r2, i2) {
  return s.overlaps(t, t3, r2, i2);
}
function d(t3, r2, i2, s3) {
  return s.relate(t, t3, r2, i2, s3);
}
function m(t3, r2) {
  return s.isSimple(t, t3, r2);
}
function y(t3, r2) {
  return s.simplify(t, t3, r2);
}
function h(t3, r2, i2 = false) {
  return s.convexHull(t, t3, r2, i2);
}
function x(t3, r2, i2) {
  return s.difference(t, t3, r2, i2);
}
function w(t3, r2, i2) {
  return s.symmetricDifference(t, t3, r2, i2);
}
function A(t3, r2, i2) {
  return s.intersect(t, t3, r2, i2);
}
function j(t3, r2, i2 = null) {
  return s.union(t, t3, r2, i2);
}
function E(t3, r2, i2, s3, o2, u2, a2) {
  return s.offset(t, t3, r2, i2, s3, o2, u2, a2);
}
function b(t3, r2, i2, s3, o2 = false) {
  return s.buffer(t, t3, r2, i2, s3, o2);
}
function v(t3, r2, i2, s3, o2, u2, a2) {
  return s.geodesicBuffer(t, t3, r2, i2, s3, o2, u2, a2);
}
function z(t3, r2, i2, s3 = true) {
  return s.nearestCoordinate(t, t3, r2, i2, s3);
}
function I(t3, r2, i2) {
  return s.nearestVertex(t, t3, r2, i2);
}
function S(t3, r2, i2, s3, o2) {
  return s.nearestVertices(t, t3, r2, i2, s3, o2);
}
function V(n, t3, r2, i2) {
  if (null == t3 || null == i2)
    throw new Error("Illegal Argument Exception");
  const s3 = s.rotate(t3, r2, i2);
  return s3.spatialReference = n, s3;
}
function D(n, t3, r2) {
  if (null == t3 || null == r2)
    throw new Error("Illegal Argument Exception");
  const i2 = s.flipHorizontal(t3, r2);
  return i2.spatialReference = n, i2;
}
function H(n, t3, r2) {
  if (null == t3 || null == r2)
    throw new Error("Illegal Argument Exception");
  const i2 = s.flipVertical(t3, r2);
  return i2.spatialReference = n, i2;
}
function R(t3, r2, i2, s3, o2) {
  return s.generalize(t, t3, r2, i2, s3, o2);
}
function B(t3, r2, i2, s3) {
  return s.densify(t, t3, r2, i2, s3);
}
function L(t3, r2, i2, s3, o2 = 0) {
  return s.geodesicDensify(t, t3, r2, i2, s3, o2);
}
function _(t3, r2, i2) {
  return s.planarArea(t, t3, r2, i2);
}
function q(t3, r2, i2) {
  return s.planarLength(t, t3, r2, i2);
}
function C(t3, r2, i2, s3) {
  return s.geodesicArea(t, t3, r2, i2, s3);
}
function G(t3, r2, i2, s3) {
  return s.geodesicLength(t, t3, r2, i2, s3);
}
var O = Object.freeze(Object.defineProperty({ __proto__: null, extendedSpatialReferenceInfo: t2, clip: r, cut: i, contains: s2, crosses: o, distance: u, equals: a, intersects: c, touches: f, within: l, disjoint: p, overlaps: g, relate: d, isSimple: m, simplify: y, convexHull: h, difference: x, symmetricDifference: w, intersect: A, union: j, offset: E, buffer: b, geodesicBuffer: v, nearestCoordinate: z, nearestVertex: I, nearestVertices: S, rotate: V, flipHorizontal: D, flipVertical: H, generalize: R, densify: B, geodesicDensify: L, planarArea: _, planarLength: q, geodesicArea: C, geodesicLength: G }, Symbol.toStringTag, { value: "Module" }));

export {
  t2 as t,
  r,
  i,
  s2 as s,
  o,
  u,
  a,
  c,
  f,
  l,
  p,
  g,
  d,
  m,
  y,
  h,
  x,
  w,
  A,
  j,
  E,
  b,
  v,
  z,
  I,
  S,
  V,
  D,
  H,
  R,
  B,
  L,
  _,
  q,
  C,
  G,
  O
};
//# sourceMappingURL=chunk-K4GR3GHO.js.map
