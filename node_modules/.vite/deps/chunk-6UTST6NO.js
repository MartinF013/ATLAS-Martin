import {
  i as i4,
  n as n6
} from "./chunk-BYHUWBKS.js";
import {
  f as f6,
  se
} from "./chunk-IEPHENP2.js";
import {
  a as a3,
  g as g2,
  j as j2,
  n
} from "./chunk-436X6OVY.js";
import {
  a,
  d,
  n as n5,
  o as o6
} from "./chunk-XP3NTQW6.js";
import {
  M,
  h
} from "./chunk-UJS24K6P.js";
import {
  C,
  N,
  O,
  P,
  U,
  Z,
  b,
  f as f4,
  w as w2
} from "./chunk-UKBGUXUQ.js";
import {
  a as a2,
  c as c2,
  i as i3,
  n as n2,
  o as o7,
  r as r4,
  s as s5
} from "./chunk-AKNCAMEF.js";
import {
  f as f2,
  p as p2
} from "./chunk-WL7AHHN3.js";
import {
  G,
  ee,
  f as f3,
  s as s4,
  te as te2
} from "./chunk-UGLXR5OV.js";
import {
  w,
  x
} from "./chunk-RGZ7VIMW.js";
import {
  E,
  S
} from "./chunk-6FQZDXGD.js";
import {
  s as s6
} from "./chunk-4V2P7IXX.js";
import {
  l
} from "./chunk-AKQ6VRGN.js";
import {
  X,
  at,
  ct,
  et,
  f,
  ft,
  gt,
  ht,
  i,
  j,
  k,
  lt,
  mt,
  nt,
  o as o4,
  pt,
  rt,
  st,
  vt
} from "./chunk-HH3D3A65.js";
import {
  e as e3,
  i as i2,
  o as o5
} from "./chunk-YDPQRKY4.js";
import {
  s as s7
} from "./chunk-ZEIWFXXO.js";
import {
  n as n4,
  t as t3
} from "./chunk-RB3LJE4I.js";
import {
  e as e2
} from "./chunk-PQO66WZ2.js";
import {
  r as r3,
  z
} from "./chunk-YZNDHJDJ.js";
import {
  n as n3
} from "./chunk-4P4OV7G6.js";
import {
  e as e4,
  f as f5
} from "./chunk-ZUDEVIXR.js";
import {
  e as e5
} from "./chunk-IG4CY4XM.js";
import {
  te,
  we
} from "./chunk-6SWQ7R36.js";
import {
  t as t2
} from "./chunk-OZT6RDST.js";
import {
  r as r2,
  s as s3,
  y
} from "./chunk-CQ47VEUP.js";
import {
  e as e6
} from "./chunk-ORGMKDYR.js";
import {
  i as i5
} from "./chunk-D7DLEBS2.js";
import {
  o as o3,
  u
} from "./chunk-NWRK6QLX.js";
import {
  o as o2
} from "./chunk-BPZGJQOB.js";
import {
  D,
  g,
  p
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  c,
  e,
  o,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/heuristics.js
var i6 = /* @__PURE__ */ new Map();
function c3(r12, t8, c10) {
  const { indicesPerRecord: s10, multiplier: o12, verticesPerRecord: d8 } = i6.get(r12);
  return { recordBytes: c10 * ct * Uint32Array.BYTES_PER_ELEMENT, indexBytes: o12 * s10 * c10 * Uint32Array.BYTES_PER_ELEMENT, vertexBytes: o12 * d8 * c10 * t8 };
}
i6.set(E.MARKER, { multiplier: 1, indicesPerRecord: 6, verticesPerRecord: 4 }), i6.set(E.LINE, { multiplier: 1, indicesPerRecord: 24, verticesPerRecord: 8 }), i6.set(E.FILL, { multiplier: 1, indicesPerRecord: 10, verticesPerRecord: 10 }), i6.set(E.TEXT, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 }), i6.set(E.LABEL, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 });

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Writer.js
var t4 = 1.25;
var e7 = class {
  constructor(t8, e12) {
    this._pos = 0;
    const r12 = e12 ? this._roundToNearest(e12, t8.BYTES_PER_ELEMENT) : 40;
    this._array = new ArrayBuffer(r12), this._buffer = new t8(this._array), this._ctor = t8, this._i16View = new Int16Array(this._array);
  }
  get length() {
    return this._pos;
  }
  _roundToNearest(t8, e12) {
    const r12 = Math.round(t8);
    return r12 + (e12 - r12 % e12);
  }
  _ensureSize(e12) {
    if (this._pos + e12 >= this._buffer.length) {
      const r12 = this._roundToNearest((this._array.byteLength + e12 * this._buffer.BYTES_PER_ELEMENT) * t4, this._buffer.BYTES_PER_ELEMENT), s10 = new ArrayBuffer(r12), i10 = new this._ctor(s10);
      i10.set(this._buffer, 0), this._array = s10, this._buffer = i10, this._i16View = new Int16Array(this._array);
    }
  }
  ensureSize(t8) {
    this._ensureSize(t8);
  }
  writeF32(t8) {
    this._ensureSize(1);
    const e12 = this._pos;
    return new Float32Array(this._array, 4 * this._pos, 1)[0] = t8, this._pos++, e12;
  }
  push(t8) {
    this._ensureSize(1);
    const e12 = this._pos;
    return this._buffer[this._pos++] = t8, e12;
  }
  writeFixed(t8) {
    this._buffer[this._pos++] = t8;
  }
  setValue(t8, e12) {
    this._buffer[t8] = e12;
  }
  i1616Add(t8, e12, r12) {
    this._i16View[2 * t8] += e12, this._i16View[2 * t8 + 1] += r12;
  }
  getValue(t8) {
    return this._buffer[t8];
  }
  incr(t8) {
    if (this._buffer.length < t8)
      throw new Error("Increment index overflows the target buffer");
    this._buffer[t8]++;
  }
  decr(t8) {
    this._buffer[t8]--;
  }
  writeRegion(t8) {
    this._ensureSize(t8.length);
    const e12 = this._pos;
    return this._buffer.set(t8, this._pos), this._pos += t8.length, e12;
  }
  writeManyFrom(t8, e12, r12) {
    this._ensureSize(r12 - e12);
    for (let s10 = e12; s10 !== r12; s10++)
      this.writeFixed(t8._buffer[s10]);
  }
  buffer() {
    const t8 = this._array.slice(0, 4 * this._pos);
    return this.destroy(), t8;
  }
  toArray() {
    const t8 = this._array, e12 = [];
    for (let r12 = 0; r12 < t8.byteLength / 4; r12++)
      e12.push(t8[r12]);
    return e12;
  }
  seek(t8) {
    this._pos = t8;
  }
  destroy() {
    this._array = null, this._buffer = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexDataWriter.js
var r5 = class {
  constructor(e12, r12, i10) {
    this._start = { index: 0, vertex: 0 };
    const h6 = c3(e12, r12, i10), c10 = r12 / 4;
    this.geometryType = e12, this._records = new e7(Int32Array, h6.recordBytes), this._indices = new e7(Uint32Array, h6.indexBytes), this._vertices = new e7(Uint32Array, h6.vertexBytes), this._metrics = new e7(Float32Array, 0), this._strideInt = c10;
  }
  serialize(e12) {
    const t8 = this._records.buffer(), s10 = this._indices.buffer(), r12 = this._vertices.buffer(), i10 = this._metrics.length ? this._metrics.buffer() : null, h6 = 4 * this._strideInt;
    return e12.push(t8, s10, r12), { stride: h6, records: t8, indices: s10, vertices: r12, metrics: i10 };
  }
  get strideInt() {
    return this._strideInt;
  }
  get recordCount() {
    return this._records.length / ct;
  }
  get vertexCount() {
    return this._vertices.length / this._strideInt;
  }
  get indexCount() {
    return this._indices.length;
  }
  get indexWriter() {
    return this._indices;
  }
  get vertexWriter() {
    return this._vertices;
  }
  get metricWriter() {
    return this._metrics;
  }
  vertexEnsureSize(e12) {
    this._vertices.ensureSize(e12);
  }
  indexEnsureSize(e12) {
    this._indices.ensureSize(e12);
  }
  recordStart() {
    this._start.index = this._indices.length, this._start.vertex = this._vertices.length;
  }
  recordEnd(e12, t8, s10, r12, i10, h6, c10, n10) {
    this._records.push(e12), this._records.push(t8), this._records.push(s10), this._records.push(r12), this._records.push(i10), this._records.push(h6), this._records.push(c10), this._records.writeF32(n10);
  }
  writeIndex(e12) {
    this._indices.push(e12);
  }
  writeVertex(e12) {
    this._vertices.push(e12);
  }
  writeVertexF32(e12) {
    this._vertices.writeF32(e12);
  }
  copyLastFrom(t8, s10, r12) {
    const i10 = t8._records.length - ct, h6 = t8._records.getValue(i10), c10 = t8._records.getValue(i10 + 1), n10 = t8._records.getValue(i10 + 2), _5 = t8._records.getValue(i10 + 4), d8 = t8._records.getValue(i10 + 6), o12 = t8._records.getValue(i10 + 7), u12 = this._vertices.length, l7 = (t8._start.vertex - this._vertices.length) / this._strideInt, g9 = this._indices.length, p8 = this.vertexCount;
    for (let e12 = t8._start.index; e12 !== t8._indices.length; e12++) {
      const s11 = t8._indices.getValue(e12);
      this._indices.push(s11 - l7);
    }
    for (let e12 = t8._start.vertex; e12 !== t8._vertices.length; e12++) {
      const s11 = t8._vertices.getValue(e12);
      this._vertices.push(s11);
    }
    for (let e12 = u12; e12 <= this._vertices.length; e12 += this._strideInt)
      this._vertices.i1616Add(e12, s10, r12);
    this._records.push(h6), this._records.push(c10), this._records.push(n10), this._records.push(g9), this._records.push(_5), this._records.push(p8), this._records.push(d8), this._records.push(o12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MeshData.js
var u2 = 1;
var c4 = 2;
var o8 = 4;
var _ = 8;
var l2 = 16;
var d2 = 32;
var g3 = 64;
var p3 = 128;
function x2(e12) {
  switch (e12) {
    case u2:
    case _:
    case d2:
      return -1;
    case c4:
    case g3:
      return 0;
    case o8:
    case l2:
    case p3:
      return 1;
  }
}
function m(e12) {
  switch (e12) {
    case u2:
    case c4:
    case o8:
      return -1;
    case _:
    case l2:
      return 0;
    case d2:
    case g3:
    case p3:
      return 1;
  }
}
var f7 = u2 | _ | d2;
var y2 = o8 | l2 | p3;
var w3 = u2 | c4 | o8;
var v = d2 | g3 | p3;
var E2 = class {
  constructor(e12, t8, r12, i10, s10, n10 = 0) {
    this._hasAggregate = false, this.hasRecords = false, this._data = { self: /* @__PURE__ */ new Map(), neighbors: new Array() }, this._version = 0, this._current = { geometryType: 0, writer: null, overlaps: 0, start: 0, insertAfter: 0, sortKey: 0, id: 0, materialKey: 0, indexStart: 0, vertStart: 0, isDotDensity: false, bufferingEnabled: false, metricBoxLenPointer: 0 }, this.hint = t8, this.tileKey = e12, this._hasAggregate = i10, this._pixelBufferEnabled = s10, this._version = n10, this._symbologyType = r12;
  }
  get hasAggregates() {
    return this._hasAggregate;
  }
  get hasPixelBufferEnabled() {
    return this._pixelBufferEnabled;
  }
  serialize(t8) {
    const r12 = [];
    return r12.push(this._serializeTileVertexData(this.tileKey, this.tileKey, this._data.self)), this._data.neighbors.forEach((i10, s10) => {
      const n10 = 1 << s10, a7 = x2(n10), u12 = m(n10), c10 = l(new e2(this.tileKey), a7, u12, t8), o12 = this._serializeTileVertexData(this.tileKey, c10.id, i10.vertexData);
      o12.message.bufferIds = i10.displayIds, r12.push(o12);
    }), r12;
  }
  _serializeTileVertexData(e12, t8, r12) {
    var _a, _b, _c, _d, _e;
    const i10 = new Array();
    return { message: { tileKeyOrigin: e12, tileKey: t8, data: { [E.MARKER]: (_a = r12.get(E.MARKER)) == null ? void 0 : _a.serialize(i10), [E.FILL]: (_b = r12.get(E.FILL)) == null ? void 0 : _b.serialize(i10), [E.LINE]: (_c = r12.get(E.LINE)) == null ? void 0 : _c.serialize(i10), [E.TEXT]: (_d = r12.get(E.TEXT)) == null ? void 0 : _d.serialize(i10), [E.LABEL]: (_e = r12.get(E.LABEL)) == null ? void 0 : _e.serialize(i10) }, version: this._version }, transferList: i10 };
  }
  featureStart(e12, t8) {
    this._current.insertAfter = e12, this._current.sortKey = t8;
  }
  featureEnd() {
  }
  recordStart(e12, t8, r12, i10) {
    this._current.writer = this._getVertexWriter(r12), this._current.overlaps = 0, this._current.indexStart = this._current.writer.indexCount, this._current.vertStart = this._current.writer.vertexCount, this._current.bufferingEnabled = i10, this._current.id = e12, this._current.materialKey = t8, this._current.geometryType = r12, this._current.isDotDensity = false, this._current.writer.recordStart();
  }
  recordCount() {
    return this._current.writer.recordCount;
  }
  vertexCount() {
    return this._current.writer.vertexCount;
  }
  indexCount() {
    return this._current.writer.indexCount;
  }
  vertexEnsureSize(e12) {
    this._current.writer.vertexEnsureSize(e12);
  }
  indexEnsureSize(e12) {
    this._current.writer.indexEnsureSize(e12);
  }
  vertexBounds(e12, t8, r12, i10) {
    this._current.bufferingEnabled && this._addOverlap(e12, t8, r12, i10);
  }
  vertexWrite(e12) {
    this._current.writer.writeVertex(e12);
  }
  vertexWriteF32(e12) {
    this._current.writer.writeVertexF32(e12);
  }
  vertexEnd() {
  }
  vertexWriter() {
    return this._current.writer.vertexWriter;
  }
  indexWrite(e12) {
    this._current.writer.writeIndex(e12);
  }
  indexWriter() {
    return this._current.writer.indexWriter;
  }
  metricWriter() {
    return this._current.writer.metricWriter;
  }
  metricStart(e12, t8, r12, n10, a7, h6, u12, c10) {
    this._current.writer = this._getVertexWriter(E.LABEL);
    const o12 = this._current.writer.metricWriter;
    o12.push(f2(e12)), o12.push(t8), o12.push(r12), o12.push(n10), o12.push(a7), o12.push(h6), o12.push(u12), o12.push(c10), o12.push(255), this._current.metricBoxLenPointer = o12.push(0);
  }
  metricEnd() {
    const e12 = this._current.writer.metricWriter;
    0 === e12.getValue(this._current.metricBoxLenPointer) && e12.seek(e12.length - 10);
  }
  metricBoxWrite(e12, t8, r12, i10) {
    const s10 = this._current.writer.metricWriter;
    s10.incr(this._current.metricBoxLenPointer), s10.push(0), s10.push(0), s10.push(e12), s10.push(t8), s10.push(r12), s10.push(i10);
  }
  recordEnd() {
    const e12 = this._current.vertStart, r12 = this._current.writer.vertexCount - e12;
    if (!r12)
      return false;
    this.hasRecords = true;
    const i10 = this._current.indexStart, h6 = this._current.writer.indexCount - i10;
    if (this._current.writer.recordEnd(this._current.id, this._current.materialKey, this._current.insertAfter, i10, h6, e12, r12, this._current.sortKey), !this._pixelBufferEnabled || this._hasAggregate || 0 === this._current.overlaps || this._current.geometryType === E.LABEL)
      return true;
    const u12 = this._current.writer;
    for (let s10 = 0; s10 < 8; s10++) {
      const e13 = 1 << s10;
      if (!!(this._current.overlaps & e13)) {
        this._data.neighbors[s10] || (this._data.neighbors[s10] = { vertexData: /* @__PURE__ */ new Map(), displayIds: /* @__PURE__ */ new Set() });
        const r13 = this._data.neighbors[s10], i11 = this._current.geometryType;
        if (!r13.vertexData.has(i11)) {
          const e14 = G(i11, this._symbologyType).geometry, s11 = new r5(i11, e14, ht);
          r13.vertexData.set(i11, s11);
        }
        const h7 = r13.vertexData.get(this._current.geometryType), c10 = 8, o12 = 512 * -x2(e13) * c10, _5 = 512 * -m(e13) * c10;
        h7.copyLastFrom(u12, o12, _5), r13.displayIds.add(this._current.id);
      }
    }
    return true;
  }
  _addOverlap(e12, t8, i10, s10) {
    const n10 = 255 ^ ((e12 < 0 + i10 ? y2 : e12 >= o4 - i10 ? f7 : y2 | f7) | (t8 < 0 + s10 ? v : t8 >= o4 - s10 ? w3 : v | w3));
    this._current.overlaps |= n10;
  }
  _getVertexWriter(e12) {
    if (!this._data.self.has(e12)) {
      const t8 = this._data.self, r12 = G(e12, this._symbologyType).geometry;
      t8.set(e12, new r5(e12, r12, this.hint.records));
    }
    return this._data.self.get(e12);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/textUtils.js
function t5(t8) {
  const e12 = new Array(t8.length);
  for (let n10 = 0; n10 < t8.length; n10++)
    e12[n10] = t8.charCodeAt(n10);
  return e12;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/util.js
var n7 = 0;
var o9 = 100;
function t6(n10, o12, t8) {
  return n10[0] = o12[0] - t8[0], n10[1] = o12[1] - t8[1], n10;
}
function i7(n10, o12) {
  return Math.sqrt(n10 * n10 + o12 * o12);
}
function r6(n10) {
  const o12 = i7(n10[0], n10[1]);
  n10[0] /= o12, n10[1] /= o12;
}
function u3(n10, o12) {
  return i7(n10[0] - o12[0], n10[1] - o12[1]);
}
function c5(n10) {
  return "function" == typeof n10;
}
function e8(n10 = 2) {
  return 1 / Math.max(n10, 1);
}
function x3(t8, i10) {
  return [!!t8.minScale && i10.scaleToZoom(t8.minScale) || n7, !!t8.maxScale && i10.scaleToZoom(t8.maxScale) || o9];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/bufcut.js
function e9(e12, t8, r12, i10, u12, l7, o12) {
  D2 = 0;
  const f14 = (i10 - r12) * l7, p8 = u12 && u12.length, c10 = p8 ? (u12[0] - r12) * l7 : f14;
  let v5, s10, h6, d8, Z4, a7 = n8(t8, r12, i10, 0, c10, l7, true);
  if (a7 && a7.next !== a7.prev) {
    if (p8 && (a7 = y3(t8, r12, i10, u12, a7, l7)), f14 > 80 * l7) {
      v5 = h6 = t8[0 + r12 * l7], s10 = d8 = t8[1 + r12 * l7];
      for (let e13 = l7; e13 < c10; e13 += l7) {
        const n10 = t8[e13 + r12 * l7], x10 = t8[e13 + 1 + r12 * l7];
        v5 = Math.min(v5, n10), s10 = Math.min(s10, x10), h6 = Math.max(h6, n10), d8 = Math.max(d8, x10);
      }
      Z4 = Math.max(h6 - v5, d8 - s10), Z4 = 0 !== Z4 ? 1 / Z4 : 0;
    }
    x4(a7, e12, l7, v5, s10, Z4, o12, 0);
  }
}
function n8(e12, n10, t8, x10, r12, i10, o12) {
  let y8;
  if (o12 === Z2(e12, n10, t8, x10, r12, i10) > 0)
    for (let l7 = x10; l7 < r12; l7 += i10)
      y8 = u4(l7 + n10 * i10, e12[l7 + n10 * i10], e12[l7 + 1 + n10 * i10], y8);
  else
    for (let l7 = r12 - i10; l7 >= x10; l7 -= i10)
      y8 = u4(l7 + n10 * i10, e12[l7 + n10 * i10], e12[l7 + 1 + n10 * i10], y8);
  return y8 && M2(y8, y8.next) && (l3(y8), y8 = y8.next), y8;
}
function t7(e12, n10 = e12) {
  if (!e12)
    return e12;
  let t8, x10 = e12;
  do {
    if (t8 = false, x10.steiner || !M2(x10, x10.next) && 0 !== s8(x10.prev, x10, x10.next))
      x10 = x10.next;
    else {
      if (l3(x10), x10 = n10 = x10.prev, x10 === x10.next)
        break;
      t8 = true;
    }
  } while (t8 || x10 !== n10);
  return n10;
}
function x4(e12, n10, u12, o12, y8, f14, p8, v5) {
  if (!e12)
    return;
  !v5 && f14 && (e12 = c6(e12, o12, y8, f14));
  let s10 = e12;
  for (; e12.prev !== e12.next; ) {
    const c10 = e12.prev, h6 = e12.next;
    if (f14 ? i8(e12, o12, y8, f14) : r7(e12))
      n10.push(c10.index / u12 + p8), n10.push(e12.index / u12 + p8), n10.push(h6.index / u12 + p8), l3(e12), e12 = h6.next, s10 = h6.next;
    else if ((e12 = h6) === s10) {
      v5 ? 1 === v5 ? x4(e12 = b2(e12, n10, u12, p8), n10, u12, o12, y8, f14, p8, 2) : 2 === v5 && g4(e12, n10, u12, o12, y8, f14, p8) : x4(t7(e12), n10, u12, o12, y8, f14, p8, 1);
      break;
    }
  }
}
function r7(e12) {
  const n10 = e12.prev, t8 = e12, x10 = e12.next;
  if (s8(n10, t8, x10) >= 0)
    return false;
  let r12 = e12.next.next;
  const i10 = r12;
  let u12 = 0;
  for (; r12 !== e12.prev && (0 === u12 || r12 !== i10); ) {
    if (u12++, a4(n10.x, n10.y, t8.x, t8.y, x10.x, x10.y, r12.x, r12.y) && s8(r12.prev, r12, r12.next) >= 0)
      return false;
    r12 = r12.next;
  }
  return true;
}
function i8(e12, n10, t8, x10) {
  const r12 = e12.prev, i10 = e12, u12 = e12.next;
  if (s8(r12, i10, u12) >= 0)
    return false;
  const l7 = r12.x < i10.x ? r12.x < u12.x ? r12.x : u12.x : i10.x < u12.x ? i10.x : u12.x, o12 = r12.y < i10.y ? r12.y < u12.y ? r12.y : u12.y : i10.y < u12.y ? i10.y : u12.y, y8 = r12.x > i10.x ? r12.x > u12.x ? r12.x : u12.x : i10.x > u12.x ? i10.x : u12.x, f14 = r12.y > i10.y ? r12.y > u12.y ? r12.y : u12.y : i10.y > u12.y ? i10.y : u12.y, p8 = z2(l7, o12, n10, t8, x10), c10 = z2(y8, f14, n10, t8, x10);
  let v5 = e12.prevZ, h6 = e12.nextZ;
  for (; v5 && v5.z >= p8 && h6 && h6.z <= c10; ) {
    if (v5 !== e12.prev && v5 !== e12.next && a4(r12.x, r12.y, i10.x, i10.y, u12.x, u12.y, v5.x, v5.y) && s8(v5.prev, v5, v5.next) >= 0)
      return false;
    if (v5 = v5.prevZ, h6 !== e12.prev && h6 !== e12.next && a4(r12.x, r12.y, i10.x, i10.y, u12.x, u12.y, h6.x, h6.y) && s8(h6.prev, h6, h6.next) >= 0)
      return false;
    h6 = h6.nextZ;
  }
  for (; v5 && v5.z >= p8; ) {
    if (v5 !== e12.prev && v5 !== e12.next && a4(r12.x, r12.y, i10.x, i10.y, u12.x, u12.y, v5.x, v5.y) && s8(v5.prev, v5, v5.next) >= 0)
      return false;
    v5 = v5.prevZ;
  }
  for (; h6 && h6.z <= c10; ) {
    if (h6 !== e12.prev && h6 !== e12.next && a4(r12.x, r12.y, i10.x, i10.y, u12.x, u12.y, h6.x, h6.y) && s8(h6.prev, h6, h6.next) >= 0)
      return false;
    h6 = h6.nextZ;
  }
  return true;
}
function u4(e12, n10, t8, x10) {
  const r12 = q.create(e12, n10, t8);
  return x10 ? (r12.next = x10.next, r12.prev = x10, x10.next.prev = r12, x10.next = r12) : (r12.prev = r12, r12.next = r12), r12;
}
function l3(e12) {
  e12.next.prev = e12.prev, e12.prev.next = e12.next, e12.prevZ && (e12.prevZ.nextZ = e12.nextZ), e12.nextZ && (e12.nextZ.prevZ = e12.prevZ);
}
function o10(e12) {
  let n10 = e12, t8 = e12;
  do {
    (n10.x < t8.x || n10.x === t8.x && n10.y < t8.y) && (t8 = n10), n10 = n10.next;
  } while (n10 !== e12);
  return t8;
}
function y3(e12, x10, r12, i10, u12, l7) {
  const y8 = new Array();
  for (let t8 = 0, f14 = i10.length; t8 < f14; t8++) {
    const u13 = n8(e12, x10, r12, i10[t8] * l7, t8 < f14 - 1 ? i10[t8 + 1] * l7 : r12 * l7, l7, false);
    u13 === u13.next && (u13.steiner = true), y8.push(o10(u13));
  }
  y8.sort(m2);
  for (const n10 of y8)
    f8(n10, u12), u12 = t7(u12, u12.next);
  return u12;
}
function f8(e12, n10) {
  if (n10 = p4(e12, n10)) {
    const x10 = j3(n10, e12);
    t7(x10, x10.next);
  }
}
function p4(e12, n10) {
  let t8 = n10;
  const x10 = e12.x, r12 = e12.y;
  let i10, u12 = -1 / 0;
  do {
    if (r12 <= t8.y && r12 >= t8.next.y && t8.next.y !== t8.y) {
      const e13 = t8.x + (r12 - t8.y) * (t8.next.x - t8.x) / (t8.next.y - t8.y);
      if (e13 <= x10 && e13 > u12) {
        if (u12 = e13, e13 === x10) {
          if (r12 === t8.y)
            return t8;
          if (r12 === t8.next.y)
            return t8.next;
        }
        i10 = t8.x < t8.next.x ? t8 : t8.next;
      }
    }
    t8 = t8.next;
  } while (t8 !== n10);
  if (!i10)
    return null;
  if (x10 === u12)
    return i10.prev;
  const l7 = i10, o12 = i10.x, y8 = i10.y;
  let f14, p8 = 1 / 0;
  for (t8 = i10.next; t8 !== l7; )
    x10 >= t8.x && t8.x >= o12 && x10 !== t8.x && a4(r12 < y8 ? x10 : u12, r12, o12, y8, r12 < y8 ? u12 : x10, r12, t8.x, t8.y) && (f14 = Math.abs(r12 - t8.y) / (x10 - t8.x), (f14 < p8 || f14 === p8 && t8.x > i10.x) && w4(t8, e12) && (i10 = t8, p8 = f14)), t8 = t8.next;
  return i10;
}
function c6(e12, n10, t8, x10) {
  for (let r12; r12 !== e12; r12 = r12.next) {
    if (r12 = r12 || e12, null === r12.z && (r12.z = z2(r12.x, r12.y, n10, t8, x10)), r12.prev.next !== r12 || r12.next.prev !== r12)
      return r12.prev.next = r12, r12.next.prev = r12, c6(e12, n10, t8, x10);
    r12.prevZ = r12.prev, r12.nextZ = r12.next;
  }
  return e12.prevZ.nextZ = null, e12.prevZ = null, v2(e12);
}
function v2(e12) {
  let n10, t8 = 1;
  for (; ; ) {
    let x10, r12 = e12;
    e12 = null, n10 = null;
    let i10 = 0;
    for (; r12; ) {
      i10++, x10 = r12;
      let u12 = 0;
      for (; u12 < t8 && x10; u12++)
        x10 = x10.nextZ;
      let l7 = t8;
      for (; u12 > 0 || l7 > 0 && x10; ) {
        let t9;
        0 === u12 ? (t9 = x10, x10 = x10.nextZ, l7--) : 0 !== l7 && x10 ? r12.z <= x10.z ? (t9 = r12, r12 = r12.nextZ, u12--) : (t9 = x10, x10 = x10.nextZ, l7--) : (t9 = r12, r12 = r12.nextZ, u12--), n10 ? n10.nextZ = t9 : e12 = t9, t9.prevZ = n10, n10 = t9;
      }
      r12 = x10;
    }
    if (n10.nextZ = null, t8 *= 2, i10 < 2)
      return e12;
  }
}
function s8(e12, n10, t8) {
  return (n10.y - e12.y) * (t8.x - n10.x) - (n10.x - e12.x) * (t8.y - n10.y);
}
function h2(e12, n10, t8, x10) {
  return !!(M2(e12, n10) && M2(t8, x10) || M2(e12, x10) && M2(t8, n10)) || s8(e12, n10, t8) > 0 != s8(e12, n10, x10) > 0 && s8(t8, x10, e12) > 0 != s8(t8, x10, n10) > 0;
}
function d3(e12, n10) {
  let t8 = e12;
  do {
    if (t8.index !== e12.index && t8.next.index !== e12.index && t8.index !== n10.index && t8.next.index !== n10.index && h2(t8, t8.next, e12, n10))
      return true;
    t8 = t8.next;
  } while (t8 !== e12);
  return false;
}
function Z2(e12, n10, t8, x10, r12, i10) {
  let u12 = 0;
  for (let l7 = x10, o12 = r12 - i10; l7 < r12; l7 += i10)
    u12 += (e12[o12 + n10 * i10] - e12[l7 + n10 * i10]) * (e12[l7 + 1 + n10 * i10] + e12[o12 + 1 + n10 * i10]), o12 = l7;
  return u12;
}
function a4(e12, n10, t8, x10, r12, i10, u12, l7) {
  return (r12 - u12) * (n10 - l7) - (e12 - u12) * (i10 - l7) >= 0 && (e12 - u12) * (x10 - l7) - (t8 - u12) * (n10 - l7) >= 0 && (t8 - u12) * (i10 - l7) - (r12 - u12) * (x10 - l7) >= 0;
}
function w4(e12, n10) {
  return s8(e12.prev, e12, e12.next) < 0 ? s8(e12, n10, e12.next) >= 0 && s8(e12, e12.prev, n10) >= 0 : s8(e12, n10, e12.prev) < 0 || s8(e12, e12.next, n10) < 0;
}
function z2(e12, n10, t8, x10, r12) {
  return (e12 = 1431655765 & ((e12 = 858993459 & ((e12 = 252645135 & ((e12 = 16711935 & ((e12 = 32767 * (e12 - t8) * r12) | e12 << 8)) | e12 << 4)) | e12 << 2)) | e12 << 1)) | (n10 = 1431655765 & ((n10 = 858993459 & ((n10 = 252645135 & ((n10 = 16711935 & ((n10 = 32767 * (n10 - x10) * r12) | n10 << 8)) | n10 << 4)) | n10 << 2)) | n10 << 1)) << 1;
}
function M2(e12, n10) {
  return e12.x === n10.x && e12.y === n10.y;
}
function m2(e12, n10) {
  return e12.x - n10.x;
}
function b2(e12, n10, t8, x10) {
  let r12 = e12;
  do {
    const i10 = r12.prev, u12 = r12.next.next;
    !M2(i10, u12) && h2(i10, r12, r12.next, u12) && w4(i10, u12) && w4(u12, i10) && (n10.push(i10.index / t8 + x10), n10.push(r12.index / t8 + x10), n10.push(u12.index / t8 + x10), l3(r12), l3(r12.next), r12 = e12 = u12), r12 = r12.next;
  } while (r12 !== e12);
  return r12;
}
function g4(e12, n10, r12, i10, u12, l7, o12) {
  let y8 = e12;
  do {
    let e13 = y8.next.next;
    for (; e13 !== y8.prev; ) {
      if (y8.index !== e13.index && k2(y8, e13)) {
        let f14 = j3(y8, e13);
        return y8 = t7(y8, y8.next), f14 = t7(f14, f14.next), x4(y8, n10, r12, i10, u12, l7, o12, 0), void x4(f14, n10, r12, i10, u12, l7, o12, 0);
      }
      e13 = e13.next;
    }
    y8 = y8.next;
  } while (y8 !== e12);
}
function k2(e12, n10) {
  return e12.next.index !== n10.index && e12.prev.index !== n10.index && !d3(e12, n10) && w4(e12, n10) && w4(n10, e12) && A(e12, n10);
}
function A(e12, n10) {
  let t8 = e12, x10 = false;
  const r12 = (e12.x + n10.x) / 2, i10 = (e12.y + n10.y) / 2;
  do {
    t8.y > i10 != t8.next.y > i10 && t8.next.y !== t8.y && r12 < (t8.next.x - t8.x) * (i10 - t8.y) / (t8.next.y - t8.y) + t8.x && (x10 = !x10), t8 = t8.next;
  } while (t8 !== e12);
  return x10;
}
function j3(e12, n10) {
  const t8 = q.create(e12.index, e12.x, e12.y), x10 = q.create(n10.index, n10.x, n10.y), r12 = e12.next, i10 = n10.prev;
  return e12.next = n10, n10.prev = e12, t8.next = r12, r12.prev = t8, x10.next = t8, t8.prev = x10, i10.next = x10, x10.prev = i10, x10;
}
var q = class {
  constructor() {
    this.index = 0, this.x = 0, this.y = 0, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  static create(e12, n10, t8) {
    const x10 = D2 < B.length ? B[D2++] : new q();
    return x10.index = e12, x10.x = n10, x10.y = t8, x10.prev = null, x10.next = null, x10.z = null, x10.prevZ = null, x10.nextZ = null, x10.steiner = false, x10;
  }
};
var B = new Array();
var C2 = 8096;
var D2 = 0;
for (let E4 = 0; E4 < C2; E4++)
  B.push(new q());

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/templateUtils.js
var f9 = 1e-5;
var c7 = new n5(0, 0, 0, 1, 0);
var u5 = new n5(0, 0, 0, 1, 0);
function h3(t8, e12, n10) {
  let o12 = 0;
  for (let r12 = 1; r12 < n10; r12++) {
    const n11 = t8[2 * (e12 + r12 - 1)], s10 = t8[2 * (e12 + r12 - 1) + 1];
    o12 += (t8[2 * (e12 + r12)] - n11) * (t8[2 * (e12 + r12) + 1] + s10);
  }
  return o12;
}
function a5(t8, e12, n10, o12, r12) {
  let s10 = 0;
  const l7 = 2;
  for (let i10 = n10; i10 < o12; i10 += 3) {
    const n11 = (t8[i10] - r12) * l7, o13 = (t8[i10 + 1] - r12) * l7, f14 = (t8[i10 + 2] - r12) * l7;
    s10 += Math.abs((e12[n11] - e12[f14]) * (e12[o13 + 1] - e12[n11 + 1]) - (e12[n11] - e12[o13]) * (e12[f14 + 1] - e12[n11 + 1]));
  }
  return s10;
}
function m3(t8, e12) {
  const { coords: n10, lengths: o12, hasIndeterminateRingOrder: r12 } = e12, s10 = 0, l7 = t8;
  if (r12)
    return false;
  let c10 = 0;
  for (let u12 = 0; u12 < o12.length; ) {
    let t9 = u12, e13 = o12[u12], r13 = h3(n10, c10, e13);
    const g9 = [];
    for (; ++t9 < o12.length; ) {
      const s11 = o12[t9], l8 = h3(n10, c10 + e13, s11);
      if (!(l8 > 0))
        break;
      r13 += l8, g9.push(c10 + e13), e13 += s11;
    }
    const m6 = l7.length;
    e9(l7, n10, c10, c10 + e13, g9, 2, s10);
    const p8 = a5(l7, n10, m6, l7.length, s10), d8 = Math.abs(r13);
    if (Math.abs((p8 - d8) / Math.max(1e-7, d8)) > f9)
      return l7.length = 0, false;
    u12 = t9, c10 += e13;
  }
  return true;
}
function d4(t8) {
  const { coords: e12, lengths: o12 } = t8, { buffer: r12 } = a(e12, o12);
  return r12;
}
function b3(t8, e12, n10) {
  let o12 = 0;
  for (let r12 = 0; r12 < t8.lengths.length; r12++) {
    const s10 = t8.lengths[r12];
    for (let r13 = 0; r13 < s10; r13++) {
      const s11 = t8.coords[2 * (r13 + o12)], l7 = t8.coords[2 * (r13 + o12) + 1];
      if (s11 < e12 || s11 > n10 || l7 < e12 || l7 > n10)
        return true;
    }
    o12 += s10;
  }
  return false;
}
function x6(e12, n10) {
  if (t(e12))
    return null;
  if (!b3(e12, -128, o4 + 128))
    return e12;
  c7.setPixelMargin(n10), c7.reset(s6.Polygon);
  let l7 = 0;
  for (let t8 = 0; t8 < e12.lengths.length; t8++) {
    const n11 = e12.lengths[t8];
    let o12 = e12.coords[2 * (0 + l7)], r12 = e12.coords[2 * (0 + l7) + 1];
    c7.moveTo(o12, r12);
    for (let t9 = 1; t9 < n11; t9++)
      o12 = e12.coords[2 * (t9 + l7)], r12 = e12.coords[2 * (t9 + l7) + 1], c7.lineTo(o12, r12);
    c7.close(), l7 += n11;
  }
  const i10 = c7.result(false);
  if (!i10)
    return null;
  const f14 = [], u12 = [];
  for (const t8 of i10) {
    let e13 = 0;
    for (const n11 of t8)
      u12.push(n11.x), u12.push(n11.y), e13++;
    f14.push(e13);
  }
  return new t2(f14, u12);
}
function y4(t8, e12) {
  u5.setPixelMargin(e12);
  const n10 = u5, o12 = -e12, l7 = o4 + e12;
  let i10 = [], f14 = false, c10 = 0;
  for (; c10 < t8.length; ) {
    const e13 = [], r12 = t8[c10];
    if (!r12)
      return null;
    n10.reset(s6.LineString);
    let [u12, h6] = r12[0];
    if (f14)
      n10.moveTo(u12, h6);
    else {
      if (u12 < o12 || u12 > l7 || h6 < o12 || h6 > l7) {
        f14 = true;
        continue;
      }
      e13.push({ x: u12, y: h6 });
    }
    let a7 = false;
    const g9 = r12.length;
    for (let t9 = 1; t9 < g9; ++t9)
      if (u12 += r12[t9][0], h6 += r12[t9][1], f14)
        n10.lineTo(u12, h6);
      else {
        if (u12 < o12 || u12 > l7 || h6 < o12 || h6 > l7) {
          a7 = true;
          break;
        }
        e13.push({ x: u12, y: h6 });
      }
    if (a7)
      f14 = true;
    else {
      if (f14) {
        const t9 = n10.resultWithStarts();
        if (t9)
          for (const e14 of t9)
            i10.push(e14);
      } else
        i10.push({ line: e13, start: 0 });
      c10++, f14 = false;
    }
  }
  return i10 = i10.filter((t9) => t9.line.length > 1), 0 === i10.length ? null : i10;
}
c7.setExtent(o4), u5.setExtent(o4);

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseLineTemplate.js
var m4 = 8;
var x7 = 16;
var p5 = 65535;
var f10 = (r12) => class extends r12 {
  constructor(...e12) {
    super(...e12), this.tessellationProperties = {}, this._tessellationOptions = { halfWidth: 0, pixelCoordRatio: 1, offset: 0 }, this.geometryType = E.LINE;
  }
  writeGeometry(e12, t8, i10, r13) {
    this._writeGeometry(e12, t8, i10, r13);
  }
  _initializeTessellator(e12) {
    const i10 = C.load(this._materialKey), r13 = w2.load(this._materialKey), s10 = this._tessellationOptions, h6 = i10.vvSizeFieldStops || i10.vvSizeMinMaxValue || i10.vvSizeScaleStops || i10.vvSizeUnitValue, d8 = this.tessellationProperties._halfWidth < X && !e12 && !h6;
    this.tessellationProperties.minMaxZoom = this._minMaxZoom, s10.wrapDistance = p5, s10.textured = this._isDashed || this._hasPattern, s10.offset = this.tessellationProperties.offset, s10.halfWidth = this.tessellationProperties._halfWidth;
    const m6 = d8 ? 0 : 1, x10 = O(r13) ? v3 : _2;
    this._lineTessellator = new d(x10(this.tessellationProperties, m6, m6), u6(this.tessellationProperties), d8);
  }
  _write(e12, t8, i10, r13) {
    const s10 = "esriGeometryPoint" === t8.geometryType;
    e12.recordStart(t8.getDisplayId(), this._materialKey, this.geometryType, s10), this._writeGeometry(e12, t8, r13, s10), e12.recordEnd();
  }
  _writeGeometry(t8, i10, r13, s10) {
    const o12 = r13 ?? i10.readLegacyGeometryForDisplay(), n10 = this._getLines(o12, s10);
    t(n10) || this._writeVertices(t8, i10, n10);
  }
  _getLines(t8, i10) {
    if (t(t8))
      return null;
    const r13 = t8.paths || t8.rings;
    if (t(r13))
      return null;
    return y4(r13, i10 ? 256 : 16);
  }
  _writeVertices(e12, t8, i10) {
    const r13 = t8.getDisplayId(), s10 = e12.vertexCount(), o12 = this.tessellationProperties, h6 = this._tessellationOptions;
    o12.out = e12, o12.id = r13, o12.indexCount = 0, o12.vertexCount = 0, o12.offset = s10, h6.capType = this._capType, h6.joinType = this._joinType;
    const d8 = w2.load(this._materialKey);
    this.tessellationProperties.key = O(d8) ? d8 : C.load(this._materialKey);
    for (const { line: n10, start: l7 } of i10)
      h6.initialDistance = l7 % p5, this._lineTessellator.tessellate(n10, h6);
  }
};
var _2 = (e12, t8, i10) => (o12, n10, l7, a7, h6, d8, p8, f14, _5, v5, u12) => {
  const c10 = w(u12, Math.ceil(x7 * e12._halfWidth)), y8 = x(Math.round(x7 * p8), Math.round(x7 * f14), Math.round(x7 * _5), Math.round(x7 * v5)), W = x(x7 * h6, x7 * d8, 0, e12._bitset), M7 = e12.out;
  return M7.vertexBounds(o12, n10, t8, i10), M7.vertexWrite(w(m4 * o12, m4 * n10)), M7.vertexWrite(e12.id), M7.vertexWrite(e12._fillColor), M7.vertexWrite(y8), M7.vertexWrite(c10), M7.vertexWrite(e12._tl), M7.vertexWrite(e12._br), M7.vertexWrite(W), M7.vertexWrite(w(Math.ceil(x7 * e12._halfReferenceWidth), 0)), M7.vertexWrite(e12.minMaxZoom), M7.vertexEnd(), e12.offset + e12.vertexCount++;
};
var v3 = (e12, t8, i10) => (o12, n10, l7, a7, d8, p8, f14, _5, v5, u12, c10) => {
  const y8 = w(x7 * e12._halfWidth, x7 * e12._halfReferenceWidth), W = x(x7 * f14 + 128, x7 * _5 + 128, x7 * v5 + 128, x7 * u12 + 128), M7 = e12.out, P5 = e12._bitset << 24 | e12.id;
  M7.vertexBounds(o12, n10, t8, i10), M7.vertexWrite(w(m4 * o12, m4 * n10)), M7.vertexWrite(P5), M7.vertexWrite(e12._fillColor);
  const T = b(e12.key);
  return T || (M7.vertexWrite(0), M7.vertexWrite(0)), M7.vertexWrite(0), M7.vertexWrite(y8), M7.vertexWrite(W), T || M7.vertexWrite(e12.minMaxZoom), M7.vertexEnd(), e12.offset + e12.vertexCount++;
};
var u6 = (e12) => (t8, i10, r12) => {
  const s10 = e12.out;
  s10.indexWrite(t8), s10.indexWrite(i10), s10.indexWrite(r12), e12.indexCount += 3;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMeshTemplate.js
var r8 = class {
  bindFeature(e12, t8, r12) {
  }
  write(r12, s10, f14, i10) {
    var _a;
    if (t(this._effects) || 0 === ((_a = this._effects) == null ? void 0 : _a.length))
      return this._write(r12, s10, i10);
    const c10 = f6.executeEffects(this._effects, s10.readLegacyGeometryForDisplay(), i10.geometryEngine);
    let o12 = f6.next(c10);
    for (; o12; )
      this._write(r12, s10, i10, o12), o12 = f6.next(c10);
  }
  _write(e12, t8, r12, s10) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLineTemplate.js
var K = s.getLogger("esri.views.2d.engine.webgl.WGLLineTemplate");
var P2 = class extends f10(r8) {
  constructor(e12, t8, i10, r12, s10, l7, p8, f14, d8, y8, S4, _5, j6, g9, w7, K2, P5, x10, b6, O3) {
    super();
    const T = C.load(e12);
    t8 && (T.sdf = t8.sdf, T.pattern = true, T.textureBinding = t8.textureBinding), this._capType = r12, this._joinType = s10, this._miterLimitCosine = e8(l7), this.tessellationProperties._fillColor = p8, this.tessellationProperties._tl = f14, this.tessellationProperties._br = d8, this._hasPattern = y8, this._isDashed = S4, this._zOrder = P5, this._effects = x10, this._minMaxZoom = w(Math.round(b6 * at), Math.round(O3 * at)), this._materialKey = T.data;
    const M7 = (j6 ? nt : 0) | (g9 ? mt : 0) | (_5 ? lt : 0) | (w7 ? gt : 0);
    this.tessellationProperties._bitset = M7, this.tessellationProperties._halfWidth = 0.5 * i10, this.tessellationProperties._halfReferenceWidth = 0.5 * K2, this.tessellationProperties.offset = 0, this._initializeTessellator(false);
  }
  static fromCIMLine(e12, r12, o12) {
    const n10 = e12.color, a7 = e12.scaleFactor || 1, m6 = !!e12.dashTemplate;
    let c10 = e12.cap;
    m6 && c10 === e3.ROUND && (c10 = e3.SQUARE);
    const p8 = e12.join, f14 = u(e12.width) * a7, u12 = u(e12.referenceWidth), d8 = u(e12.miterLimit), y8 = n10 && f3(n10) || 0, [L4, _5] = x3(e12.scaleInfo, o12), j6 = false;
    if (!r12)
      return new P2(e12.materialKey, r12, f14, c10, p8, d8, y8, 0, 0, false, m6, e12.scaleDash, e12.colorLocked, j6, e12.sampleAlphaOnly, u12, e12.zOrder, e12.effects, L4, _5);
    const { rect: g9, width: w7, height: K2 } = r12, x10 = g9.x + et, b6 = g9.y + et, O3 = x10 + w7, T = b6 + K2, M7 = w(x10, b6), W = w(O3, T), z4 = false;
    return new P2(e12.materialKey, r12, f14, c10, p8, d8, y8, M7, W, true, m6, e12.scaleDash, e12.colorLocked, z4, e12.sampleAlphaOnly, u12, e12.zOrder, e12.effects, L4, _5);
  }
  static fromFillOutline(e12) {
    var _a;
    const t8 = w2.load(e12.materialKey);
    return O(t8) && e12.outline && "esriSLSSolid" === ((_a = e12.outline) == null ? void 0 : _a.style) ? P2.fromSimpleLine({ hash: "", materialKey: e12.materialKey, ...e12.outline }, null, true) : null;
  }
  static fromSimpleLine(e12, i10, s10 = false) {
    const { color: o12 } = e12, n10 = "esriSLSSolid" !== e12.style && "esriSLSNull" !== e12.style, a7 = ee(e12.cap || "round"), m6 = te2(e12.join || "round");
    let c10 = o12 && "esriSLSNull" !== e12.style && s4(o12) || 0;
    "esriSLSNull" === e12.style && (c10 = 0);
    const u12 = u(e12.width), d8 = e12.miterLimit;
    if (!i10)
      return new P2(e12.materialKey, i10, u12, a7, m6, d8, c10, 0, 0, false, n10, true, false, s10, false, u12, 0, null, n7, o9);
    const { rect: y8, width: L4, height: S4 } = i10, g9 = y8.x + et, w7 = y8.y + et, K2 = g9 + L4, x10 = w7 + S4, b6 = w(g9, w7), O3 = w(K2, x10);
    return new P2(e12.materialKey, i10, u12, a7, m6, d8, c10, b6, O3, true, n10, true, false, s10, false, u12, 0, null, n7, o9);
  }
  static fromPictureLineSymbol(e12, t8, i10, r12) {
    return K.error("PictureLineSymbol support does not exist!"), null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseFillTemplate.js
var _3 = 100;
var f11 = 1;
var u7 = (u12) => class extends u12 {
  constructor(...e12) {
    super(...e12), this.forceLibtess = false, this._bitset = 0, this._lineTemplate = null, this.geometryType = E.FILL;
  }
  _maybeAddLineTemplate(e12) {
    this._lineTemplate = P2.fromFillOutline(e12);
  }
  _write(t8, r12, i10, s10) {
    const o12 = "esriGeometryPoint" === r12.geometryType, m6 = w2.load(this._materialKey);
    t8.recordStart(r12.getDisplayId(), this._materialKey, this.geometryType, o12), this._writeGeometry(t8, r12, m6, s10, o12), O(m6) && r(this._lineTemplate) && this._lineTemplate.writeGeometry(t8, r12, s10, o12), t8.recordEnd();
  }
  _writeGeometry(e12, r12, i10, s10, o12) {
    const m6 = this._getGeometry(r12, s10, o12);
    if (t(m6))
      return;
    const l7 = [];
    if (!(m6.maxLength > _3) && !this.forceLibtess && m3(l7, m6))
      return void (l7.length && this._writeVertices(e12, r12, m6.coords, m6.lengths, i10, l7));
    const n10 = d4(m6);
    this._writeVertices(e12, r12, n10, [n10.length / 2], i10);
  }
  _writeVertex(e12, t8, r12, i10, s10, l7) {
    const n10 = w(f11 * i10, f11 * s10);
    if (e12.vertexBounds(i10, s10, 0, 0), e12.vertexWrite(n10), e12.vertexWrite(t8), r12.symbologyType === S.DOT_DENSITY)
      e12.vertexWriteF32(1 / Math.abs(l7.readGeometryArea()));
    else {
      e12.vertexWrite(this.fillColor);
      const t9 = b(r12);
      t9 || (e12.vertexWrite(this.tl), e12.vertexWrite(this.br)), e12.vertexWrite(this.aux2_1), e12.vertexWrite(this.aux2_2), e12.vertexWrite(this.aux3), t9 || e12.vertexWrite(this._minMaxZoom);
    }
  }
  _writeVertices(e12, t8, r12, i10, s10, o12) {
    const m6 = t8.getDisplayId(), n10 = this._bitset << 24 | m6, a7 = i10.reduce((e13, t9) => e13 + t9), h6 = G(s10.geometryType, s10.symbologyType).geometry / 4, y8 = e12.vertexCount();
    e12.vertexEnsureSize(h6 * a7);
    let p8 = 0;
    if (o12)
      for (const l7 of o12) {
        const i11 = r12[2 * l7], o13 = r12[2 * l7 + 1];
        this._writeVertex(e12, n10, s10, i11, o13, t8), p8++;
      }
    else
      for (let l7 = 0; l7 < r12.length; l7 += 2) {
        const i11 = Math.round(r12[l7]), o13 = Math.round(r12[l7 + 1]);
        this._writeVertex(e12, n10, s10, i11, o13, t8), p8++;
      }
    e12.indexEnsureSize(p8);
    for (let l7 = 0; l7 < p8; l7++)
      e12.indexWrite(l7 + y8);
  }
  _getGeometry(e12, t8, s10) {
    const o12 = t8 ? we(te(t8), 2) : e12.readGeometryForDisplay();
    if (!o12)
      return null;
    return x6(o12, s10 ? 256 : 8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMeshTemplate.js
var i9 = s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMeshTemplate");
var r9 = class extends r8 {
  constructor(e12) {
    super(), this._ongoingMaterialRequestMap = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._dynamicPropertyMap = /* @__PURE__ */ new Map(), this._cimLayer = e12;
  }
  analyze(e12, s10, r12, n10, o12) {
    if (o12 && 0 === o12.length)
      return null;
    const l7 = o12 && o12.length > 0, m6 = s10.readLegacyFeature(), c10 = s10.getObjectId(), h6 = this._materialCache, u12 = this._cimLayer.materialHash;
    if (!u12)
      return i9.error("A Dynamic mesh template must have a material hash value or function!"), Promise.reject(null);
    const p8 = "function" == typeof u12 ? u12(m6, r12, n10, c10) : u12;
    if (h6.has(p8)) {
      const e13 = h6.get(p8);
      return Promise.resolve(e13);
    }
    const g9 = this._ongoingMaterialRequestMap.get(p8);
    if (g9)
      return g9;
    const y8 = this._cimLayer, M7 = se(y8.cim, this._cimLayer.materialOverrides);
    M7.mosaicHash = p8;
    const { type: d8, url: f14 } = y8, _5 = { cim: M7, type: d8, mosaicHash: p8, url: f14, size: null, dashTemplate: null, text: null, fontName: null, objectId: c10, animatedSymbolProperties: null };
    switch (d8) {
      case "marker":
        _5.size = e5(y8.size, m6, r12, n10), _5.animatedSymbolProperties = e5(y8.animatedSymbolProperties, m6, r12, n10);
        break;
      case "line":
        _5.dashTemplate = y8.dashTemplate;
        break;
      case "text":
        _5.text = e5(y8.text, m6, r12, n10), _5.fontName = e5(y8.fontName, m6, r12, n10);
    }
    const b6 = e12.getMosaicItem(_5, o12).then((e13) => (l7 || (this._ongoingMaterialRequestMap.delete(p8), h6.set(p8, e13)), e13)).catch((e13) => (this._ongoingMaterialRequestMap.delete(p8), i9.error(".analyze()", e13.message), null));
    return l7 || this._ongoingMaterialRequestMap.set(p8, b6), b6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Result.js
function e10(e12, n10) {
  if (e12 && "name" in e12) {
    const o12 = e12;
    return n10 && n10.error(new s2(o12.name, o12.message, o12.details)), false;
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicFillTemplate.js
var u8 = class extends u7(r9) {
  constructor(l7, c10, p8) {
    var _a;
    if (super(l7), this._minMaxZoom = w(Math.round(c10 * at), Math.round(p8 * at)), c5(l7.color)) {
      const t8 = (t9, e12, i10) => {
        const o12 = l7.color(t9, e12, i10);
        return o12 && f3(o12) || 0;
      };
      this._dynamicPropertyMap.set("fillColor", t8);
    } else {
      const t8 = l7.color;
      this.fillColor = t8 && f3(t8) || 0;
    }
    const _5 = "CIMMarkerPlacementInsidePolygon" === ((_a = l7.cim.placement) == null ? void 0 : _a.type) && l7.cim.placement.shiftOddRows ? 2 : 1, y8 = l7.height;
    if (c5(y8)) {
      const t8 = (t9, e12, s10) => y8(t9, e12, s10) * _5;
      this._dynamicPropertyMap.set("_height", t8);
    } else
      this._height = (y8 || 0) * _5;
    const d8 = l7.offsetX;
    if (c5(d8)) {
      const t8 = (t9, s10, i10) => u(d8(t9, s10, i10));
      this._dynamicPropertyMap.set("_offsetX", t8);
    } else
      this._offsetX = u(d8 || 0);
    const u12 = l7.offsetY;
    if (c5(u12)) {
      const t8 = (t9, s10, i10) => u(-u12(t9, s10, i10));
      this._dynamicPropertyMap.set("_offsetY", t8);
    } else
      this._offsetY = u(-u12 || 0);
    const M7 = l7.scaleX;
    c5(M7) ? this._dynamicPropertyMap.set("_scaleX", M7) : this._scaleX = M7 || 1;
    const g9 = l7.angle;
    if (c5(g9)) {
      const t8 = (t9, e12, s10) => h(g9(t9, e12, s10));
      this._dynamicPropertyMap.set("_angle", t8);
    } else
      this._angle = h(g9) || 0;
    if (r(l7.effects)) {
      const t8 = l7.effects;
      c5(t8) ? this._dynamicPropertyMap.set("_effects", t8) : this._effects = t8;
    }
    this._cimFillLayer = l7, this._bitset = (l7.colorLocked ? nt : 0) | (l7.applyRandomOffset ? vt : 0) | (l7.sampleAlphaOnly ? gt : 0), this._fillMaterialKey = w2.load(l7.materialKey);
  }
  static fromCIMFill(t8, e12) {
    const [s10, i10] = x3(t8.scaleInfo, e12);
    return new u8(t8, s10, i10);
  }
  bindFeature(t8, s10, i10) {
    const o12 = t8.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t9, e12) => {
      this[e12] = t9(o12, s10, i10);
    });
    const r12 = this._fillMaterialKey, a7 = this._materialCache, h6 = (0, this._cimFillLayer.materialHash)(o12, s10, i10), f14 = a7.get(h6);
    let m6 = null;
    if (f14 && e10(f14.spriteMosaicItem) && (m6 = f14.spriteMosaicItem), m6) {
      const { rect: t9, width: s11, height: i11 } = m6, o13 = t9.x + et, a8 = t9.y + et, h7 = o13 + s11, f15 = a8 + i11;
      let p8 = Math.round(u(this._height));
      p8 <= 0 && (p8 = f15 - a8);
      let _5 = Math.round(u(this._height / i11 * s11 || 0));
      _5 <= 0 && (_5 = h7 - o13);
      const y8 = this._scaleX, d8 = 1;
      this.tl = w(o13, a8), this.br = w(h7, f15), this.aux2_1 = w(_5, p8), this.aux2_2 = w(this._offsetX, this._offsetY), this.aux3 = x(y8, d8, this._angle, 0), r12.sdf = m6.sdf, r12.pattern = true, r12.textureBinding = m6.textureBinding;
    } else
      this.tl = 0, this.br = 0, this.aux2_1 = 0, this.aux2_2 = 0, this.aux3 = 0, r12.sdf = false, r12.pattern = false, r12.textureBinding = 0;
    this._materialKey = r12.data;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicLineTemplate.js
var y5 = class extends f10(r9) {
  constructor(l7, n10, p8) {
    super(l7), this._minMaxZoom = w(Math.round(n10 * at), Math.round(p8 * at)), this._cimLineLayer = l7;
    let _5 = 0;
    c5(l7.width) || (_5 = 0.5 * u(l7.width));
    const f14 = (t8, i10, s10) => c5(l7.width) ? 0.5 * u(l7.width(t8, i10, s10)) : _5;
    this._dynamicPropertyMap.set("_halfWidth", f14), c5(l7.cap) ? this._dynamicPropertyMap.set("_capType", l7.cap) : this._capType = l7.cap, c5(l7.join) ? this._dynamicPropertyMap.set("_joinType", l7.join) : this._joinType = l7.join;
    const d8 = l7.color;
    if (c5(d8)) {
      const t8 = (t9, e12, s10) => f3(d8(t9, e12, s10));
      this._dynamicPropertyMap.set("_fillColor", t8);
    } else
      this._fillColor = d8 && f3(d8) || 0;
    const y8 = l7.miterLimit;
    if (c5(y8)) {
      const t8 = (t9, e12, i10) => e8(y8(t9, e12, i10));
      this._dynamicPropertyMap.set("_miterLimitCosine", t8);
    } else
      this._miterLimitCosine = e8(y8);
    if (r(l7.effects)) {
      const t8 = l7.effects;
      c5(t8) ? this._dynamicPropertyMap.set("_effects", t8) : this._effects = t8;
    }
    this._scaleFactor = l7.scaleFactor || 1, this._isDashed = null != l7.dashTemplate;
    const P5 = l7.colorLocked ? nt : 0, u12 = l7.scaleDash ? lt : 0, j6 = l7.sampleAlphaOnly ? gt : 0;
    this.tessellationProperties._bitset = P5 | u12 | j6, this._materialKey = l7.materialKey, this._initializeTessellator(true);
  }
  static fromCIMLine(t8, e12) {
    const [i10, s10] = x3(t8.scaleInfo, e12);
    return new y5(t8, i10, s10);
  }
  bindFeature(t8, e12, i10) {
    const s10 = t8.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t9, r13) => {
      this[r13] = t9(s10, e12, i10);
    }), this._halfWidth *= this._scaleFactor;
    const r12 = this._materialCache, o12 = (0, this._cimLineLayer.materialHash)(s10, e12, i10), a7 = r12.get(o12);
    let c10 = null;
    if (a7 && e10(a7.spriteMosaicItem) && (c10 = a7.spriteMosaicItem), c10) {
      this._hasPattern = true;
      const { rect: t9, width: e13, height: i11 } = c10, s11 = t9.x + et, r13 = t9.y + et, o13 = s11 + e13, a8 = r13 + i11;
      this.tessellationProperties._tl = w(s11, r13), this.tessellationProperties._br = w(o13, a8);
    } else
      this._hasPattern = false, this.tessellationProperties._tl = 0, this.tessellationProperties._br = 0;
    this.tessellationProperties._fillColor = this._fillColor, this.tessellationProperties._halfWidth = this._halfWidth, this.tessellationProperties.offset = 0, this.tessellationProperties._halfReferenceWidth = this.tessellationProperties._halfWidth;
    const m6 = C.load(this._materialKey);
    c10 && (m6.sdf = c10.sdf, m6.pattern = true, m6.textureBinding = c10.textureBinding), this._materialKey = m6.data;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/CIMMarkerPlacementHelper.js
var e11 = class {
  static getPlacement(e12, o12, s10, c10) {
    const n10 = g2(o12);
    if (!n10)
      return null;
    const m6 = a3(e12);
    return n10.execute(m6, o12, s10, c10);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseMarkerTemplate.js
var g5 = 3.14159265359 / 180;
var y6 = 8;
var u9 = (u12) => class extends u12 {
  constructor(...t8) {
    super(...t8), this.angle = 0, this.xOffset = 0, this.yOffset = 0, this.width = 0, this.height = 0, this.boundsType = "square", this._anchorX = 0, this._anchorY = 0, this._computedWidth = 0, this._computedHeight = 0, this._vertexBoundsScaleX = 1, this._vertexBoundsScaleY = 1, this._offsets = { xUpperLeft: 0, yUpperLeft: 0, xUpperRight: 0, yUpperRight: 0, xBottomLeft: 0, yBottomLeft: 0, xBottomRight: 0, yBottomRight: 0 }, this.geometryType = E.MARKER;
  }
  _write(t8, e12, i10, r12) {
    const s10 = e12.getDisplayId();
    t8.recordStart(s10, this._materialKey, this.geometryType, true), this._writeGeometry(t8, e12, s10, i10, r12), t8.recordEnd();
  }
  _writeGeometry(i10, r12, s10, o12, h6) {
    if (r(this._markerPlacement))
      return this._writePlacedMarkers(i10, r12, o12, h6);
    if (!h6 && "esriGeometryPoint" === r12.geometryType) {
      const t8 = r12.getX(), e12 = r12.getY();
      if (!i10.hasAggregates && i10.hasPixelBufferEnabled && (t8 < 0 || t8 >= 513 || e12 < 0 || e12 >= 513))
        return;
      return this._writeVertices(i10, s10, this._getPos(t8, e12), t8, e12);
    }
    const f14 = h6 ? we(te(h6), 2) : "esriGeometryPolygon" === r12.geometryType ? r12.readCentroid() : r12.readGeometryForDisplay();
    if (!t(f14)) {
      if (f14.isPoint) {
        const [t8, e12] = f14.coords;
        if (!i10.hasAggregates && i10.hasPixelBufferEnabled && (t8 < 0 || t8 >= 512 || e12 < 0 || e12 >= 512))
          return;
        return this._writeVertices(i10, s10, this._getPos(t8, e12), t8, e12);
      }
      f14.forEachVertex((t8, e12) => {
        const r13 = 2 * o4;
        t8 < -r13 || t8 >= r13 || e12 < -r13 || e12 >= r13 || this._writeVertices(i10, s10, this._getPos(t8, e12), t8, e12);
      });
    }
  }
  _writePlacedMarkers(t8, e12, s10, o12) {
    const f14 = o12 ?? e12.readLegacyGeometryForDisplay(), n10 = e11.getPlacement(f14, e(this._markerPlacement), u(1), s10.geometryEngine);
    if (!n10)
      return;
    const x10 = e12.getDisplayId(), m6 = n4(), _5 = n3(), c10 = -128, v5 = 640;
    let l7 = n10.next();
    for (; null != l7; ) {
      const e13 = l7.tx, i10 = -l7.ty;
      e13 >= c10 && e13 <= v5 && i10 >= c10 && i10 <= v5 && (this._applyTransformation(_5, m6, -l7.getAngle() / g5), this._writeVertices(t8, x10, this._getPos(e13, i10), e13, i10)), l7 = n10.next();
    }
  }
  _writeVertices(t8, e12, i10, r12, s10) {
    const o12 = N.load(this._materialKey);
    return o12.symbologyType === S.HEATMAP ? this._writeHeatmapVertices(t8, e12, i10, r12, s10) : this._writeMarkerVertices(t8, e12, o12, i10, r12, s10);
  }
  _writeMarkerVertices(t8, e12, i10, r12, s10, o12) {
    const h6 = i10.vvRotation, f14 = t8.vertexCount();
    let n10 = this._computedWidth * this._vertexBoundsScaleX, x10 = this._computedHeight * this._vertexBoundsScaleY;
    if (this.angle) {
      const t9 = Math.max(n10, x10);
      n10 = t9, x10 = t9;
    }
    if (h6) {
      const t9 = Math.max(this.xOffset, this.yOffset);
      n10 += t9, x10 += t9;
    }
    t8.vertexBounds(s10 + this.xOffset, o12 - this.yOffset, n10, x10), t8.vertexWrite(r12), t8.vertexWrite(this._offsetUpperLeft), t8.vertexWrite(this._texUpperLeft), t8.vertexWrite(this._bitestAndDistRatio), t8.vertexWrite(e12), t8.vertexWrite(this._fillColor), t8.vertexWrite(this._outlineColor), t8.vertexWrite(this._sizeOutlineWidth), t8.vertexWrite(this._minMaxZoom), t8.vertexEnd(), t8.vertexWrite(r12), t8.vertexWrite(this._offsetUpperRight), t8.vertexWrite(this._texUpperRight), t8.vertexWrite(this._bitestAndDistRatio), t8.vertexWrite(e12), t8.vertexWrite(this._fillColor), t8.vertexWrite(this._outlineColor), t8.vertexWrite(this._sizeOutlineWidth), t8.vertexWrite(this._minMaxZoom), t8.vertexEnd(), t8.vertexWrite(r12), t8.vertexWrite(this._offsetBottomLeft), t8.vertexWrite(this._texBottomLeft), t8.vertexWrite(this._bitestAndDistRatio), t8.vertexWrite(e12), t8.vertexWrite(this._fillColor), t8.vertexWrite(this._outlineColor), t8.vertexWrite(this._sizeOutlineWidth), t8.vertexWrite(this._minMaxZoom), t8.vertexEnd(), t8.vertexWrite(r12), t8.vertexWrite(this._offsetBottomRight), t8.vertexWrite(this._texBottomRight), t8.vertexWrite(this._bitestAndDistRatio), t8.vertexWrite(e12), t8.vertexWrite(this._fillColor), t8.vertexWrite(this._outlineColor), t8.vertexWrite(this._sizeOutlineWidth), t8.vertexWrite(this._minMaxZoom), t8.vertexEnd(), this._writeIndices(t8, f14);
  }
  _writeHeatmapVertices(t8, e12, i10, r12, s10) {
    const o12 = t8.vertexCount();
    t8.vertexBounds(r12 + this.xOffset, s10 - this.yOffset, this.width, this.height), t8.vertexWrite(i10), t8.vertexWrite(this._offsetUpperLeft), t8.vertexWrite(e12), t8.vertexEnd(), t8.vertexWrite(i10), t8.vertexWrite(this._offsetUpperRight), t8.vertexWrite(e12), t8.vertexEnd(), t8.vertexWrite(i10), t8.vertexWrite(this._offsetBottomLeft), t8.vertexWrite(e12), t8.vertexEnd(), t8.vertexWrite(i10), t8.vertexWrite(this._offsetBottomRight), t8.vertexWrite(e12), t8.vertexEnd(), this._writeIndices(t8, o12);
  }
  _writeIndices(t8, e12) {
    t8.indexWrite(e12 + 0), t8.indexWrite(e12 + 1), t8.indexWrite(e12 + 2), t8.indexWrite(e12 + 1), t8.indexWrite(e12 + 3), t8.indexWrite(e12 + 2);
  }
  _applyTransformation(t8, e12, i10 = 0) {
    f5(t8, t3(this.xOffset, -this.yOffset)), this.angle + i10 !== 0 && e4(t8, t8, g5 * (this.angle + i10));
    const r12 = this._computedWidth, h6 = this._computedHeight, a7 = (this._anchorX - 0.5) * r12, m6 = (this._anchorY - 0.5) * h6;
    r3(e12, a7, m6), z(e12, e12, t8), this._offsetUpperLeft = w(16 * e12[0], 16 * e12[1]), this._offsets.xUpperLeft = e12[0], this._offsets.yUpperLeft = e12[1], r3(e12, a7 + r12, m6), z(e12, e12, t8), this._offsetUpperRight = w(16 * e12[0], 16 * e12[1]), this._offsets.xUpperRight = e12[0], this._offsets.yUpperRight = e12[1], r3(e12, a7, m6 + h6), z(e12, e12, t8), this._offsetBottomLeft = w(16 * e12[0], 16 * e12[1]), this._offsets.xBottomLeft = e12[0], this._offsets.yBottomLeft = e12[1], r3(e12, a7 + r12, m6 + h6), z(e12, e12, t8), this._offsetBottomRight = w(16 * e12[0], 16 * e12[1]), this._offsets.xBottomRight = e12[0], this._offsets.yBottomRight = e12[1];
  }
  _getPos(t8, e12) {
    return w(Math.round(y6 * t8), Math.round(y6 * e12));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMarkerTemplate.js
var g6 = n4();
var k3 = n3();
var P3 = s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMarkerTemplate");
var L = class extends u9(r9) {
  constructor(t8, e12, o12) {
    super(t8), this._cimMarkerLayer = t8, this._minMaxZoom = w(Math.round(e12 * at), Math.round(o12 * at));
    const a7 = t8.color;
    if (c5(a7)) {
      const t9 = (t10, e13, i10) => f3(a7(t10, e13, i10));
      this._dynamicPropertyMap.set("_fillColor", t9);
    } else
      this._fillColor = f3(a7);
    const m6 = t8.outlineColor;
    if (c5(m6)) {
      const t9 = (t10, e13, i10) => f3(m6(t10, e13, i10));
      this._dynamicPropertyMap.set("_outlineColor", t9);
    } else
      this._outlineColor = f3(m6);
    const f14 = t8.size;
    if (c5(f14)) {
      const t9 = (t10, e13, i10) => u(f14(t10, e13, i10));
      this._dynamicPropertyMap.set("_size", t9);
    } else
      this._size = u(f14) || 0;
    const _5 = t8.scaleX;
    c5(_5) ? this._dynamicPropertyMap.set("_scaleX", _5) : this._scaleX = _5 || 1;
    const y8 = t8.offsetX;
    if (c5(y8)) {
      const t9 = (t10, e13, i10) => u(y8(t10, e13, i10));
      this._dynamicPropertyMap.set("xOffset", t9);
    } else
      this.xOffset = u(y8) || 0;
    const d8 = t8.offsetY;
    if (c5(d8)) {
      const t9 = (t10, e13, i10) => u(d8(t10, e13, i10));
      this._dynamicPropertyMap.set("yOffset", t9);
    } else
      this.yOffset = u(d8) || 0;
    const M7 = t8.outlineWidth;
    if (c5(M7)) {
      const t9 = (t10, e13, i10) => u(M7(t10, e13, i10));
      this._dynamicPropertyMap.set("_outlineWidth", t9);
    } else
      this._outlineWidth = u(M7) || 0;
    const u12 = t8.rotation;
    if (c5(u12) ? this._dynamicPropertyMap.set("_angle", u12) : this._angle = u12 || 0, r(t8.effects)) {
      const e13 = t8.effects;
      c5(e13) ? this._dynamicPropertyMap.set("_effects", e13) : this._effects = e13;
    }
    if (r(t8.markerPlacement)) {
      const e13 = t8.markerPlacement;
      c5(e13) ? this._dynamicPropertyMap.set("_markerPlacement", e13) : this._markerPlacement = e13;
    }
    this._scaleFactor = c(t8.scaleFactor, 1), this._bitSet = (t8.alignment === i2.MAP ? 1 : 0) | (t8.colorLocked ? 1 : 0) << 1 | (t8.scaleSymbolsProportionally ? 1 : 0) << 3, this._materialKey = t8.materialKey;
  }
  static fromCIMMarker(t8, e12) {
    const [i10, s10] = x3(t8.scaleInfo, e12);
    return new L(t8, i10, s10);
  }
  bindFeature(e12, i10, s10) {
    const o12 = e12.readLegacyFeature(), a7 = e12.getObjectId();
    this._dynamicPropertyMap.forEach((t8, e13) => {
      this[e13] = t8(o12, i10, s10);
    });
    const h6 = this._cimMarkerLayer.materialHash, c10 = "function" == typeof h6 ? h6(o12, i10, s10, a7) : h6, n10 = this._materialCache.get(c10);
    if (!n10 || !e10(n10.spriteMosaicItem) || !n10.spriteMosaicItem)
      return void P3.error(new s2("mapview-cim", "Encountered an error when binding feature"));
    const p8 = n10.spriteMosaicItem, y8 = this._cimMarkerLayer.sizeRatio, d8 = p8.width / p8.height * this._scaleX, M7 = this._cimMarkerLayer.rotateClockwise ? this._angle : -this._angle;
    let L4 = this._size, x10 = L4 * d8;
    const j6 = this.xOffset, b6 = this.yOffset;
    this.xOffset *= this._scaleFactor, this.yOffset *= this._scaleFactor;
    const w7 = this._cimMarkerLayer.scaleSymbolsProportionally && this._cimMarkerLayer.frameHeight ? this._size / u(this._cimMarkerLayer.frameHeight) : 1, O3 = this._outlineWidth * w7, z4 = u(this._cimMarkerLayer.referenceSize);
    let W = 0, C4 = 0;
    const F2 = this._cimMarkerLayer.anchorPoint;
    F2 && (this._cimMarkerLayer.isAbsoluteAnchorPoint ? this._size && (W = -F2.x / (this._size * d8), C4 = F2.y / this._size) : (W = F2.x, C4 = F2.y)), this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * x10), 255)), Math.round(Math.min(Math.sqrt(128 * L4), 255)), Math.round(Math.min(Math.sqrt(128 * O3), 255)), Math.round(Math.min(Math.sqrt(128 * z4), 255))), this.angle = M7;
    const I2 = Math.round(64 * y8);
    this._bitestAndDistRatio = w(this._bitSet, I2);
    const K2 = p8.rect.x + et, X2 = p8.rect.y + et, B2 = K2 + p8.width, R = X2 + p8.height;
    this._texUpperLeft = w(K2, X2), this._texUpperRight = w(B2, X2), this._texBottomLeft = w(K2, R), this._texBottomRight = w(B2, R);
    const S4 = N.load(this._materialKey);
    S4.sdf = p8.sdf, S4.pattern = true, S4.textureBinding = p8.textureBinding, this._materialKey = S4.data, this._anchorX = 0.5 - (0.5 + W) * p8.width / p8.width, this._anchorY = 0.5 - (0.5 + C4) * p8.height / p8.height, x10 *= y8, L4 *= y8, x10 *= this._scaleFactor, L4 *= this._scaleFactor, x10 *= p8.rect.width / p8.width, L4 *= p8.rect.height / p8.height, this._computedWidth = x10, this._computedHeight = L4, this._applyTransformation(k3, g6), this.xOffset = j6, this.yOffset = b6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseTextTemplate.js
var f12 = 8;
var _4 = (_5) => class extends _5 {
  constructor(...e12) {
    super(...e12), this._isCIM = false, this._vertexBoundsScale = 1, this.geometryType = E.TEXT, this._aux = x(0, 0, this._referenceSize, this._bitset);
  }
  bindTextInfo(t8, i10) {
    t8 && t8.length ? this._shapingInfo = o(t8, (e12) => j2(e12, i10, { scale: this._scale, angle: this._angle, xOffset: this._xOffset, yOffset: this._yOffset, hAlign: this._xAlignD, vAlign: this._yAlignD, maxLineWidth: Math.max(32, Math.min(this._lineWidth, 512)), lineHeight: f * Math.max(0.25, Math.min(this._lineHeight, 4)), decoration: this._decoration, isCIM: this._isCIM })) : this._shapingInfo = null;
  }
  _write(e12, t8, i10, r12) {
    const s10 = t8.getDisplayId();
    this._writeGeometry(e12, t8, s10, i10, r12);
  }
  _writeGeometry(e12, r12, s10, h6, a7) {
    const x10 = this._shapingInfo;
    if (t(x10))
      return;
    if (r(this._textPlacement)) {
      const t8 = a7 ?? r12.readLegacyGeometryForDisplay();
      return this._writePlacedText(e12, s10, t8, x10, h6);
    }
    const l7 = a7 ? we(te(a7), 2) : "esriGeometryPolygon" === r12.geometryType ? r12.readCentroid() : r12.readGeometryForDisplay();
    if (!t(l7)) {
      if (l7.isPoint) {
        const [t8, i10] = l7.coords;
        if (!e12.hasAggregates && e12.hasPixelBufferEnabled && (t8 < 0 || t8 >= 512 || i10 < 0 || i10 >= 512))
          return;
        return this._writeGlyphs(e12, s10, { x: t8, y: i10 }, x10);
      }
      l7.forEachVertex((t8, i10) => this._writeGlyphs(e12, s10, { x: t8, y: i10 }, x10));
    }
  }
  _writePlacedText(e12, t8, i10, o12, n10) {
    const a7 = e(this._textPlacement), x10 = e11.getPlacement(i10, a7, u(1), n10.geometryEngine);
    if (!x10)
      return;
    let l7 = x10.next();
    for (; null != l7; ) {
      const i11 = -l7.getAngle();
      o12.setRotation(i11);
      const r12 = l7.tx, s10 = -l7.ty;
      r12 < 0 || r12 >= 512 || s10 < 0 || s10 >= 512 ? l7 = x10.next() : (this._writeGlyphs(e12, t8, { x: r12, y: s10 }, o12), o12.setRotation(-i11), l7 = x10.next());
    }
  }
  _writeGlyphs(e12, t8, i10, r12) {
    const s10 = U.load(this._materialKey), o12 = w(Math.round(f12 * i10.x), Math.round(f12 * i10.y)), n10 = this._vertexBoundsScale, h6 = r12.bounds, a7 = 2 * Math.max(h6.width, h6.height);
    for (const x10 of r12.glyphs)
      s10.textureBinding = x10.textureBinding, e12.recordStart(t8, s10.data, this.geometryType, true), e12.vertexBounds(i10.x + h6.x + this._xOffset, i10.y + h6.y - this._yOffset, a7 * n10, a7 * n10), this._writeVertices(e12, t8, o12, x10), e12.recordEnd();
  }
  _writeGlyph(e12, t8, i10, r12, s10) {
    const o12 = U.load(this._materialKey), n10 = w(Math.round(f12 * i10), Math.round(f12 * r12));
    o12.textureBinding = s10.textureBinding, e12.recordStart(t8, o12.data, this.geometryType, true);
    const h6 = s10.bounds, a7 = this._vertexBoundsScale;
    e12.vertexBounds(i10 + h6.x * a7, r12 + h6.y * a7, h6.width * a7, h6.height * a7), this._writeVertices(e12, t8, n10, s10), e12.recordEnd();
  }
  _writeVertices(e12, t8, i10, r12) {
    const s10 = e12.vertexCount();
    this._writeVertexCommon(e12, t8, i10, r12), e12.vertexWrite(r12.offsets.upperLeft), e12.vertexWrite(r12.texcoords.upperLeft), e12.vertexEnd(), this._writeVertexCommon(e12, t8, i10, r12), e12.vertexWrite(r12.offsets.upperRight), e12.vertexWrite(r12.texcoords.upperRight), e12.vertexEnd(), this._writeVertexCommon(e12, t8, i10, r12), e12.vertexWrite(r12.offsets.lowerLeft), e12.vertexWrite(r12.texcoords.lowerLeft), e12.vertexEnd(), this._writeVertexCommon(e12, t8, i10, r12), e12.vertexWrite(r12.offsets.lowerRight), e12.vertexWrite(r12.texcoords.lowerRight), e12.vertexEnd(), e12.indexWrite(s10 + 0), e12.indexWrite(s10 + 1), e12.indexWrite(s10 + 2), e12.indexWrite(s10 + 1), e12.indexWrite(s10 + 3), e12.indexWrite(s10 + 2);
  }
  _writeVertexCommon(e12, t8, i10, r12) {
    const s10 = this._color, o12 = this._haloColor, n10 = x(0, 0, this._referenceSize, this._bitset), h6 = x(0, 0, this._size, this._haloSize);
    e12.vertexWrite(i10), e12.vertexWrite(t8), e12.vertexWrite(s10), e12.vertexWrite(o12), e12.vertexWrite(h6), e12.vertexWrite(n10), e12.vertexWrite(this._minMaxZoom);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicTextTemplate.js
var M3 = 5;
function d5(t8, e12, i10, s10) {
  return "string" == typeof t8.text ? t8.text : "function" == typeof t8.text ? t8.text(e12, i10, s10) : "";
}
var g7 = class extends _4(r9) {
  constructor(e12, o12, a7) {
    super(e12), this._horizontalAlignment = "center", this._verticalAlignment = "middle", this._textToGlyphs = /* @__PURE__ */ new Map(), this._minMaxZoom = w(Math.round(o12 * at), Math.round(a7 * at));
    const l7 = e12.scaleFactor || 1;
    this._cimTextLayer = e12;
    const _5 = e12.color;
    if (c5(_5)) {
      const t8 = (t9, e13, i10) => f3(_5(t9, e13, i10));
      this._dynamicPropertyMap.set("_color", t8);
    } else
      this._color = f3(_5);
    const f14 = e12.outlineColor;
    if (c5(f14)) {
      const t8 = (t9, e13, i10) => f3(f14(t9, e13, i10));
      this._dynamicPropertyMap.set("_haloColor", t8);
    } else
      this._haloColor = f3(f14);
    let y8;
    c5(e12.size) || (y8 = Math.min(Math.round(u(e12.size * e12.sizeRatio)), 127));
    const p8 = (t8, s10, o13) => c5(e12.size) ? Math.min(Math.round(u(e12.size(t8, s10, o13) * e12.sizeRatio)), 127) : y8;
    if (this._dynamicPropertyMap.set("_size", p8), c5(e12.outlineSize)) {
      const t8 = (t9, s10, o13) => Math.min(Math.floor(M3 * u(e12.outlineSize(t9, s10, o13) * e12.sizeRatio)), 127);
      this._dynamicPropertyMap.set("_haloSize", t8);
    } else
      this._haloSize = Math.min(Math.floor(M3 * u(e12.outlineSize * e12.sizeRatio)), 127);
    let d8;
    c5(e12.offsetX) || (d8 = Math.round(u(e12.offsetX * e12.sizeRatio)));
    const g9 = (t8, s10, o13) => c5(e12.offsetX) ? Math.round(u(e12.offsetX(t8, s10, o13) * e12.sizeRatio)) : d8;
    let u12;
    this._dynamicPropertyMap.set("_xOffset", g9), c5(e12.offsetY) || (u12 = Math.round(u(e12.offsetY * e12.sizeRatio)));
    const z4 = (t8, s10, o13) => c5(e12.offsetY) ? Math.round(u(e12.offsetY(t8, s10, o13) * e12.sizeRatio)) : u12;
    if (this._dynamicPropertyMap.set("_yOffset", z4), c5(e12.angle) ? this._dynamicPropertyMap.set("_angle", e12.angle) : this._angle = e12.angle, c5(e12.horizontalAlignment) ? this._dynamicPropertyMap.set("_horizontalAlignment", e12.horizontalAlignment) : this._horizontalAlignment = e12.horizontalAlignment, c5(e12.verticalAlignment) ? this._dynamicPropertyMap.set("_verticalAlignment", e12.verticalAlignment) : this._verticalAlignment = e12.verticalAlignment, r(e12.effects)) {
      const t8 = e12.effects;
      c5(t8) ? this._dynamicPropertyMap.set("_effects", t8) : this._effects = t8;
    }
    if (r(e12.markerPlacement)) {
      const t8 = e12.markerPlacement;
      c5(t8) ? this._dynamicPropertyMap.set("_markerPlacement", t8) : this._textPlacement = t8;
    }
    c5(e12.text) ? this._dynamicPropertyMap.set("_text", e12.text) : this._text = e12.text, this._scaleFactor = l7;
    const x10 = Math.min(Math.round(u(e12.referenceSize * e12.sizeRatio)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * x10)), this._materialKey = e12.materialKey;
    const P5 = P.load(this._materialKey);
    P5.sdf = true, this._bitset = (e12.alignment === i2.MAP ? 1 : 0) | (e12.colorLocked ? 1 : 0) << 1, this._materialKey = P5.data, this._decoration = "none", this._lineHeight = 1, this._lineWidth = 512, this._isCIM = true;
  }
  static fromCIMText(t8, e12) {
    const [i10, s10] = x3(t8.scaleInfo, e12);
    return new g7(t8, i10, s10);
  }
  async analyze(t8, e12, i10, s10) {
    const o12 = e12.readLegacyFeature(), a7 = d5(this._cimTextLayer, o12, i10, s10), n10 = await super.analyze(t8, e12, i10, s10, t5(a7));
    return n10 && n10.glyphMosaicItems && this._textToGlyphs.set(a7, n10.glyphMosaicItems), n10;
  }
  bindFeature(t8, i10, s10) {
    const n10 = t8.readLegacyFeature();
    if (this._dynamicPropertyMap.forEach((t9, e12) => {
      this[e12] = t9(n10, i10, s10);
    }), !this._text || 0 === this._text.length)
      return void (this._shapingInfo = null);
    this._size *= this._scaleFactor, this._scale = this._size / j, this._xOffset *= this._scaleFactor, this._yOffset *= this._scaleFactor, this._xAlignD = r4(c(this._horizontalAlignment, "center")), this._yAlignD = n2(c(this._verticalAlignment, "baseline"));
    const r12 = this._textToGlyphs.get(this._text);
    this.bindTextInfo(r12, false);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLFillTemplate.js
var M4 = 128;
var j4 = class extends u7(r8) {
  constructor(t8, e12, r12, o12, s10, l7, a7, n10, m6, u12, d8, p8, y8, x10, M7, j6) {
    super(), this._effects = x10;
    const w7 = w2.load(t8);
    e12 && (w7.sdf = e12.sdf, w7.pattern = true, w7.textureBinding = e12.textureBinding), this.fillColor = r12, this.tl = o12, this.br = s10, this.aux2_1 = w(l7, a7), this.aux2_2 = w(n10, m6), this.aux3 = x(u12, d8, p8, 0), this._bitset = y8, this._minMaxZoom = w(Math.round(M7 * at), Math.round(j6 * at)), this._materialKey = w7.data;
  }
  static fromCIMFill(e12, i10, n10) {
    const c10 = e12.color, h6 = c10 && f3(c10) || 0, d8 = e12.materialKey, [p8, y8] = x3(e12.scaleInfo, n10), x10 = (e12.colorLocked ? nt : 0) | (e12.applyRandomOffset ? vt : 0) | (e12.sampleAlphaOnly ? gt : 0);
    if (!i10)
      return new j4(d8, null, h6, 0, 0, 0, 0, 0, 0, 0, 0, 0, x10, e12.effects, p8, y8);
    const { rect: w7, width: g9, height: _5 } = i10, K2 = e12.scaleX || 1, b6 = w7.x + et, F2 = w7.y + et, L4 = b6 + g9, T = F2 + _5, A3 = e12.height, B2 = K2 * A3;
    let G4 = Math.round(A3);
    G4 <= 0 && (G4 = T - F2);
    let S4 = Math.round(B2);
    S4 <= 0 && (S4 = L4 - b6);
    const C4 = u(e12.offsetX || 0), I2 = u(-e12.offsetY || 0), O3 = w(b6, F2), U2 = w(L4, T);
    return new j4(d8, i10, h6, O3, U2, S4, G4, C4, I2, M4, M4, M(e12.angle), x10, e12.effects, p8, y8);
  }
  static fromSimpleFill(t8, r12, i10 = false) {
    const { color: s10 } = t8, l7 = s10 && "esriSFSNull" !== t8.style && s4(s10) || 0, n10 = i10 ? nt : 0, m6 = t8.materialKey;
    let c10;
    if (r12) {
      const { rect: t9, width: e12, height: i11 } = r12, o12 = t9.x + et, s11 = t9.y + et, h6 = o12 + e12, u12 = s11 + i11, y8 = w(o12, s11), x10 = w(h6, u12);
      c10 = new j4(m6, r12, l7, y8, x10, e12, i11, 0, 0, M4, M4, 0, n10, null, n7, o9);
    } else
      c10 = new j4(m6, null, l7, 0, 0, 0, 0, 0, 0, 0, 0, 0, n10, null, n7, o9);
    return c10._maybeAddLineTemplate(t8), c10;
  }
  static fromPictureFill(e12, r12, i10 = false) {
    const s10 = i, { rect: l7, width: m6, height: c10 } = r12, h6 = l7.x + et, u12 = l7.y + et, y8 = h6 + m6, x10 = u12 + c10, w7 = w(h6, u12), g9 = w(y8, x10), _5 = Math.round(u(e12.width)), K2 = Math.round(u(e12.height)), b6 = u(e12.xoffset), F2 = u(-e12.yoffset), L4 = e12.materialKey, T = i10 ? nt : 0, A3 = new j4(L4, r12, s10, w7, g9, _5, K2, b6, F2, M4 * e12.xscale, M4 * e12.yscale, 0, T, null, n7, o9);
    return A3._maybeAddLineTemplate(e12), A3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMarkerTemplate.js
var b4 = class extends u9(r8) {
  constructor(t8, e12, r12, a7, n10, p8, S4, g9, V, z4, B2, b6, k5, w7, L4, R, j6, C4, P5, E4, U2, A3, T) {
    super(), this.angle = a7, this.height = S4, this.width = p8, this.xOffset = e12 * P5, this.yOffset = r12 * P5, this._markerPlacement = E4, this._effects = U2, this._anchorX = 0.5 - (0.5 + R) * L4.width / L4.width, this._anchorY = 0.5 - (0.5 + j6) * L4.height / L4.height, this._minMaxZoom = w(Math.round(A3 * at), Math.round(T * at));
    const v5 = (w7 === i2.MAP ? rt : pt) | (B2 ? nt : 0) | (k5 ? st : 0) | (b6 ? ft : 0), K2 = L4 && L4.sdf, W = N.load(t8);
    W.sdf = K2, W.pattern = true, W.textureBinding = L4.textureBinding, this._materialKey = W.data, this._fillColor = n10, this._outlineColor = V, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * p8), 255)), Math.round(Math.min(Math.sqrt(128 * S4), 255)), Math.round(Math.min(Math.sqrt(128 * z4), 255)), Math.round(Math.min(Math.sqrt(128 * g9), 255)));
    const X2 = L4.rect.x + et, q2 = L4.rect.y + et, Y = X2 + L4.width, H = q2 + L4.height;
    this._offsets.xUpperLeft = X2, this._offsets.yUpperLeft = q2, this._offsets.xUpperRight = Y, this._offsets.yUpperRight = q2, this._offsets.xBottomLeft = X2, this._offsets.yBottomLeft = H, this._offsets.xBottomRight = Y, this._offsets.yBottomRight = H, W.symbologyType === S.PIE_CHART ? (this._texUpperLeft = w(0, 1), this._texUpperRight = w(1, 1), this._texBottomLeft = w(0, 0), this._texBottomRight = w(1, 0)) : (this._texUpperLeft = w(X2, q2), this._texUpperRight = w(Y, q2), this._texBottomLeft = w(X2, H), this._texBottomRight = w(Y, H)), p8 *= C4, S4 *= C4, p8 *= P5, S4 *= P5;
    const I2 = Math.round(64 * C4);
    this._bitestAndDistRatio = w(v5, I2), this._computedWidth = p8, this._computedHeight = S4;
    const N2 = n4(), O3 = n3();
    this._applyTransformation(O3, N2);
  }
  static fromCIMMarker(o12, s10, r12) {
    const n10 = s10 && s10.width || 1, h6 = s10 && s10.height || 1, l7 = o12.size, m6 = n10 / h6 * o12.scaleX, f14 = o12.scaleSymbolsProportionally && o12.frameHeight ? l7 / o12.frameHeight : 1;
    let c10 = f3(o12.color);
    const u12 = f3(o12.outlineColor), d8 = u(l7), p8 = d8 * m6, x10 = u(o12.offsetX || 0), M7 = u(o12.offsetY || 0), y8 = u(o12.outlineWidth || 0) * f14, _5 = o12.alignment || i2.SCREEN, g9 = u(o12.referenceSize), [V, z4] = x3(o12.scaleInfo, r12);
    s10.sdf || 0 !== c10 || (c10 = -1);
    let B2 = o12.rotation || 0;
    o12.rotateClockwise || (B2 = -B2);
    let k5 = 0, w7 = 0;
    const L4 = o12.anchorPoint;
    L4 && (o12.isAbsoluteAnchorPoint ? l7 && (k5 = -L4.x / (l7 * m6), w7 = L4.y / l7) : (k5 = L4.x, w7 = L4.y));
    const R = new b4(o12.materialKey, x10, M7, B2, c10, p8, d8, g9, u12, y8, o12.colorLocked, o12.scaleSymbolsProportionally, false, _5, s10, k5, w7, o12.sizeRatio, c(o12.scaleFactor, 1), o12.markerPlacement, o12.effects, V, z4);
    return R._vertexBoundsScaleX = o12.maxVVSize ? o12.maxVVSize / p8 : 1, R._vertexBoundsScaleY = o12.maxVVSize ? o12.maxVVSize / d8 : 1, R;
  }
  static fromPictureMarker(t8, o12) {
    const s10 = Math.round(u(t8.width)), r12 = Math.round(u(t8.height)), a7 = i, n10 = Math.round(u(t8.xoffset || 0)), h6 = Math.round(u(t8.yoffset || 0)), l7 = new b4(t8.materialKey, n10, h6, t8.angle, a7, s10, r12, r12, 0, 0, false, false, false, i2.SCREEN, o12, 0, 0, 1, 1, null, null, n7, o9);
    return l7._vertexBoundsScaleX = t8.maxVVSize ? t8.maxVVSize / t8.width : 1, l7._vertexBoundsScaleY = t8.maxVVSize ? t8.maxVVSize / t8.height : 1, l7;
  }
  static fromSimpleMarker(t8, o12) {
    const s10 = s4(t8.color), r12 = Math.round(u(t8.size)), a7 = r12, h6 = Math.round(u(t8.xoffset || 0)), l7 = Math.round(u(t8.yoffset || 0)), m6 = t8.style, f14 = t8.outline, c10 = 0 | (f14 && f14.color && s4(f14.color)), u12 = 0 | (f14 && f14.width && Math.round(u(f14.width))), d8 = new b4(t8.materialKey, h6, l7, t8.angle, s10, r12, a7, a7, c10, u12, false, false, "esriSMSCross" === m6 || "esriSMSX" === m6, i2.SCREEN, o12, 0, 0, 126 / 64, 1, null, null, n7, o9);
    return d8.boundsType = "esriSMSCircle" === m6 ? "circle" : "square", d8._vertexBoundsScaleX = t8.maxVVSize ? t8.maxVVSize / t8.size : 1, d8._vertexBoundsScaleY = t8.maxVVSize ? t8.maxVVSize / t8.size : 1, d8;
  }
  static fromLineSymbolMarker(t8, o12) {
    const s10 = s4(t8.color), a7 = 6, h6 = Math.round(u(a7 * t8.lineWidth)), l7 = h6, m6 = "cross" === t8.style || "x" === t8.style;
    let f14;
    switch (t8.placement) {
      case "begin-end":
        f14 = o5.Both;
        break;
      case "begin":
        f14 = o5.JustBegin;
        break;
      case "end":
        f14 = o5.JustEnd;
        break;
      default:
        f14 = o5.None;
    }
    const c10 = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: f14, offsetAlongLine: 0 }, u12 = new b4(t8.materialKey, 0, 0, 0, s10, h6, l7, l7 / a7, s10, m6 ? Math.round(u(t8.lineWidth)) : 0, false, false, m6, i2.MAP, o12, 0, 0, 126 / 64, 1, c10, null, n7, o9);
    return u12.boundsType = "circle" === t8.style ? "circle" : "square", u12;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTextTemplate.js
var M5 = 5;
var p6 = class extends _4(r8) {
  constructor(t8, a7, l7, _5, d8, x10, z4, u12, p8, g9, j6, S4, y8, b6, T, V, A3, C4, I2 = false, K2, R) {
    super(), this._xOffset = u(y8), this._yOffset = u(b6), this._decoration = g9 || "none", this._color = d8, this._haloColor = x10, this._haloSize = Math.min(Math.floor(M5 * u(o3(l7))), 127), this._size = Math.min(Math.round(u(a7)), 127);
    const v5 = Math.min(Math.round(u(_5 || a7)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * v5)), this._scale = this._size / j, this._angle = S4, this._justify = s5(z4 || "center"), this._xAlignD = r4(z4 || "center"), this._yAlignD = n2(u12 || "baseline"), this._baseline = "baseline" === (u12 || "baseline"), this._bitset = (p8 === i2.MAP ? 1 : 0) | (j6 ? 1 : 0) << 1;
    const B2 = U.load(t8);
    B2.sdf = true, this._materialKey = B2.data, this._lineWidth = u(T) || 512, this._lineHeight = V || 1, this._textPlacement = A3, this._effects = C4, this._isCIM = I2, this._minMaxZoom = w(Math.round(K2 * at), Math.round(R * at));
  }
  static fromText(e12, i10) {
    const s10 = new p6(e12.materialKey, e12.font.size, e12.haloSize || 0, e12.font.size, e12.color && s4(e12.color) || 0, e12.haloColor && s4(e12.haloColor) || 0, e12.horizontalAlignment, e12.verticalAlignment, i2.SCREEN, e12.font.decoration, false, e12.angle || 0, e12.xoffset, e12.yoffset, e12.lineWidth, e12.lineHeight, null, null, false, n7, o9), [, n10] = n(e12.text);
    return s10.bindTextInfo(i10, n10), s10._vertexBoundsScale = e12.maxVVSize ? e12.maxVVSize / e12.font.size : 1, s10;
  }
  static fromCIMText(e12, i10, o12) {
    const s10 = e12.scaleFactor || 1, n10 = e12.size * e12.sizeRatio * s10, [r12, a7] = x3(e12.scaleInfo, o12), m6 = new p6(e12.materialKey, n10, e12.outlineSize * e12.sizeRatio, e12.referenceSize, f3(e12.color), f3(e12.outlineColor), e12.horizontalAlignment, e12.verticalAlignment, e12.alignment, e12.decoration, e12.colorLocked, e12.angle, e12.offsetX * e12.sizeRatio * s10, e12.offsetY * e12.sizeRatio * s10, 512, 1, e12.markerPlacement, e12.effects, true, r12, a7), [, h6] = n(e12.text);
    return m6.bindTextInfo(i10, h6), m6._vertexBoundsScale = e12.maxVVSize ? e12.maxVVSize / n10 : 1, m6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Lock.js
var r10 = class {
  constructor() {
    this._resolver = null;
  }
  isHeld() {
    return !!this._resolver;
  }
  async acquire() {
    this._resolver ? (await this._resolver.promise, await this.acquire()) : this._resolver = D();
  }
  release() {
    const e12 = this._resolver;
    this._resolver = null, e12.resolve();
  }
};
async function s9(e12, r12, s10) {
  try {
    await e12.acquire(), await r12(s10), e12.release();
  } catch (t8) {
    throw e12.release(), t8;
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTemplateStore.js
var S2 = s.getLogger("esri.views.2d.engine.webgl.mesh.templates.WGLTemplateStore");
var w5 = new Array();
var k4 = { isOutline: false, placement: null, symbologyType: S.DEFAULT, vvFlags: 0 };
var C3 = { ...r2, hash: JSON.stringify(r2), materialKey: f4(E.MARKER, k4) };
var L2 = { ...s3, hash: JSON.stringify(s3), materialKey: f4(E.LINE, k4) };
var b5 = { ...y, hash: JSON.stringify(y), materialKey: f4(E.FILL, k4) };
function E3(e12, t8) {
  const r12 = e12.length;
  return e12.push(null), t8.then((t9) => e12[r12] = t9), e12;
}
function G2(e12) {
  return !!(1 & e12);
}
function j5(e12) {
  return "worker:port-closed" === e12.name;
}
var x8 = class {
  constructor(e12, t8) {
    this._idCounter = 1, this._templateIdCounter = 1, this._idToTemplateGroup = /* @__PURE__ */ new Map(), this._symbolToTemplate = /* @__PURE__ */ new Map(), this._fetchQueue = [], this._idToResolver = /* @__PURE__ */ new Map(), this._cimTemplateCache = /* @__PURE__ */ new Map(), this._cimAnalyses = [], this._lock = new r10(), this._fetchResource = e12, this._tileInfo = t8;
  }
  get _markerError() {
    return this._errorTemplates.marker[0];
  }
  get _fillError() {
    return this._errorTemplates.fill[0];
  }
  get _lineError() {
    return this._errorTemplates.line[0];
  }
  get _textError() {
    return this._errorTemplates.line[0];
  }
  createTemplateGroup(e12, t8) {
    this._initErrorTemplates();
    const r12 = e12.hash;
    if (this._symbolToTemplate.has(r12))
      return this._symbolToTemplate.get(r12);
    const s10 = new Array();
    t8 && this._createMeshTemplates(s10, t8, true), this._createMeshTemplates(s10, e12, false);
    const i10 = this._createGroupId("expanded-cim" === e12.type && F(e12));
    return this._idToTemplateGroup.set(i10, s10), this._symbolToTemplate.set(r12, i10), i10;
  }
  getTemplateGroup(e12) {
    return this._idToTemplateGroup.has(e12) ? this._idToTemplateGroup.get(e12) : w5;
  }
  getDynamicTemplateGroup(e12) {
    return this._idToTemplateGroup.has(e12) ? (G2(e12) || S2.error("mapview-template-store", `Id ${e12} does not refer to a dynamic template`), this._idToTemplateGroup.get(e12)) : w5;
  }
  getMosaicItem(e12, t8) {
    const r12 = this._createTemplateId(), s10 = new Promise((e13) => this._idToResolver.set(r12, e13));
    return this._fetchQueue.push({ symbol: e12, id: r12, glyphIds: t8 }), s10;
  }
  finalize(e12) {
    return this._fetchQueue.length || this._lock.isHeld() ? s9(this._lock, this._fetchAllQueuedResources.bind(this), e12) : Promise.resolve();
  }
  _initErrorTemplates() {
    this._errorTemplates || (this._errorTemplates = { fill: this._createMeshTemplates([], b5, false), marker: this._createMeshTemplates([], C3, false), line: this._createMeshTemplates([], L2, false) });
  }
  _fetchAllQueuedResources(t8) {
    if (!this._fetchQueue.length)
      return Promise.resolve();
    const s10 = this._fetchQueue, i10 = this._cimAnalyses;
    return this._fetchQueue = [], this._cimAnalyses = [], Promise.all(i10).then(() => this._fetchResource(s10, t8).then((e12) => {
      for (const { id: t9, mosaicItem: r12 } of e12) {
        this._idToResolver.get(t9)(r12), this._idToResolver.delete(t9);
      }
    })).catch((t9) => {
      g(t9) ? this._fetchQueue = this._fetchQueue.concat(s10) : j5(t9) || S2.error(new s2("mapview-template-store", "Unable to fetch requested texture resources", t9));
    });
  }
  _createGroupId(e12) {
    return this._idCounter++ << 1 | (e12 ? 1 : 0);
  }
  _createTemplateId() {
    return this._templateIdCounter++;
  }
  async _createSMS(e12) {
    const { spriteMosaicItem: t8 } = await this.getMosaicItem(e12);
    return e10(t8, S2) ? b4.fromSimpleMarker(e12, t8) : this._markerError;
  }
  async _createPMS(e12) {
    const { spriteMosaicItem: t8 } = await this.getMosaicItem(e12);
    return e10(t8, S2) ? b4.fromPictureMarker(e12, t8) : this._markerError;
  }
  async _createSFS(e12, t8) {
    const { spriteMosaicItem: r12 } = await this.getMosaicItem(e12);
    return e10(r12, S2) ? j4.fromSimpleFill(e12, r12, t8) : this._fillError;
  }
  async _createPFS(e12, t8) {
    const { spriteMosaicItem: r12 } = await this.getMosaicItem(e12);
    return e10(r12, S2) ? j4.fromPictureFill(e12, r12, t8) : this._fillError;
  }
  async _createSLS(e12, t8) {
    const { spriteMosaicItem: r12 } = await this.getMosaicItem(e12);
    return e10(r12, S2) ? P2.fromSimpleLine(e12, r12) : this._lineError;
  }
  async _createLMS(e12) {
    const { spriteMosaicItem: t8 } = await this.getMosaicItem(e12);
    return e10(t8, S2) ? b4.fromLineSymbolMarker(e12, t8) : this._markerError;
  }
  async _createTS(e12) {
    const { glyphMosaicItems: t8 } = await this.getMosaicItem(e12);
    return p6.fromText(e12, t8);
  }
  async _createCIMText(e12) {
    const { glyphMosaicItems: t8 } = await this.getMosaicItem(i4(e12), t5(e12.text));
    return e10(t8, S2) ? p6.fromCIMText(e12, t8, this._tileInfo) : this._textError;
  }
  async _createCIMFill(e12) {
    const { spriteMosaicItem: t8 } = await this.getMosaicItem(i4(e12));
    return e10(t8, S2) ? j4.fromCIMFill(e12, t8, this._tileInfo) : this._fillError;
  }
  async _createCIMLine(e12) {
    const { spriteMosaicItem: t8 } = await this.getMosaicItem(i4(e12));
    return e10(t8, S2) ? P2.fromCIMLine(e12, t8, this._tileInfo) : this._lineError;
  }
  async _createCIMMarker(e12) {
    const { spriteMosaicItem: t8 } = await this.getMosaicItem(i4(e12));
    return e10(t8, S2) ? b4.fromCIMMarker(e12, t8, this._tileInfo) : this._markerError;
  }
  async _createCIM(e12) {
    const t8 = e12.templateHash;
    if (this._cimTemplateCache.has(t8))
      return this._cimTemplateCache.get(t8);
    let r12;
    switch (e12.type) {
      case "marker":
        r12 = await this._createCIMMarker(e12);
        break;
      case "line":
        r12 = await this._createCIMLine(e12);
        break;
      case "fill":
        r12 = await this._createCIMFill(e12);
        break;
      case "text":
        r12 = await this._createCIMText(e12);
    }
    return this._cimTemplateCache.set(t8, r12), r12;
  }
  async _createDynamicCIM(e12) {
    const t8 = e12.templateHash;
    if (this._cimTemplateCache.has(t8))
      return this._cimTemplateCache.get(t8);
    let r12;
    switch (e12.type) {
      case "marker":
        r12 = L.fromCIMMarker(e12, this._tileInfo);
        break;
      case "line":
        r12 = y5.fromCIMLine(e12, this._tileInfo);
        break;
      case "fill":
        r12 = u8.fromCIMFill(e12, this._tileInfo);
        break;
      case "text":
        r12 = g7.fromCIMText(e12, this._tileInfo);
    }
    return this._cimTemplateCache.set(t8, r12), r12;
  }
  _createPrimitiveMeshTemplates(e12, t8, r12) {
    switch (t8.type) {
      case "esriSMS":
        return E3(e12, this._createSMS(t8));
      case "esriPMS":
        return E3(e12, this._createPMS(t8));
      case "esriSFS":
        return E3(e12, this._createSFS(t8, r12));
      case "line-marker":
        return E3(e12, this._createLMS(t8));
      case "esriPFS":
        return E3(e12, this._createPFS(t8, r12));
      case "esriSLS":
        return E3(e12, this._createSLS(t8, false));
      case "esriTS":
        return E3(e12, this._createTS(t8));
      default:
        return S2.error("Unable to create mesh template for unknown symbol type {: $ }{symbol.type}"), e12;
    }
  }
  _createMeshTemplates(e12, t8, r12) {
    if (t8.type.includes("3d"))
      return S2.error("3D symbols are not supported with MapView"), e12;
    if ("expanded-cim" === t8.type) {
      for (const r13 of t8.layers)
        "function" == typeof r13.materialHash ? E3(e12, this._createDynamicCIM(r13)) : E3(e12, this._createCIM(r13));
      return e12;
    }
    if ("composite-symbol" === t8.type) {
      for (const s10 of t8.layers)
        this._createPrimitiveMeshTemplates(e12, s10, r12);
      return e12;
    }
    return "cim" === t8.type || "label" === t8.type || "web-style" === t8.type ? e12 : this._createPrimitiveMeshTemplates(e12, t8, r12);
  }
};
var F = (e12) => {
  if (!e12.layers)
    return false;
  for (const t8 of e12.layers)
    if ("function" == typeof t8.materialHash)
      return true;
  return false;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/segmentUtils.js
function r11(t8, e12) {
  return t8[e12 + 1];
}
function h4(t8) {
  return t8.length - 1;
}
function a6(t8) {
  let e12 = 0;
  for (let s10 = 0; s10 < h4(t8); s10++)
    e12 += d6(t8, s10);
  return e12;
}
function d6(t8, e12, s10 = 1) {
  const [n10, i10] = r11(t8, e12);
  return Math.sqrt(n10 * n10 + i10 * i10) * s10;
}
var c8 = class {
  constructor(t8, e12, s10, n10, i10) {
    this._segments = t8, this._index = e12, this._distance = s10, this._xStart = n10, this._yStart = i10, this._done = false;
  }
  static create(t8) {
    return new c8(t8, 0, 0, t8[0][0], t8[0][1]);
  }
  clone() {
    return new c8(this._segments, this._index, this._distance, this.xStart, this.yStart);
  }
  equals(t8) {
    return this._index === t8._index || t8._index === this._index - 1 && (0 === this._distance || 1 === t8._distance) || t8._index === this._index + 1 && (1 === this._distance || 0 === t8._distance);
  }
  leq(t8) {
    return this._index < t8._index || this._index === t8._index && this._distance <= t8._distance;
  }
  geq(t8) {
    return this._index > t8._index || this._index === t8._index && this._distance >= t8._distance;
  }
  get _segment() {
    return this._segments[this._index + 1];
  }
  get angle() {
    const t8 = this.dy, e12 = (0 * t8 + -1 * -this.dx) / (1 * this.length);
    let s10 = Math.acos(e12);
    return t8 > 0 && (s10 = 2 * Math.PI - s10), s10;
  }
  get xStart() {
    return this._xStart;
  }
  get yStart() {
    return this._yStart;
  }
  get x() {
    return this.xStart + this.distance * this.dx;
  }
  get y() {
    return this.yStart + this.distance * this.dy;
  }
  get dx() {
    return this._segment[0];
  }
  get dy() {
    return this._segment[1];
  }
  get xMidpoint() {
    return this.xStart + 0.5 * this.dx;
  }
  get yMidpoint() {
    return this.yStart + 0.5 * this.dy;
  }
  get xEnd() {
    return this.xStart + this.dx;
  }
  get yEnd() {
    return this.yStart + this.dy;
  }
  get length() {
    const { dx: t8, dy: e12 } = this;
    return Math.sqrt(t8 * t8 + e12 * e12);
  }
  get remainingLength() {
    return this.length * (1 - this._distance);
  }
  get backwardLength() {
    return this.length * this._distance;
  }
  get distance() {
    return this._distance;
  }
  get done() {
    return this._done;
  }
  hasPrev() {
    return this._index - 1 >= 0;
  }
  hasNext() {
    return this._index + 1 < h4(this._segments);
  }
  next() {
    return this.hasNext() ? (this._xStart += this.dx, this._yStart += this.dy, this._distance = 0, this._index += 1, this) : null;
  }
  prev() {
    return this.hasPrev() ? (this._index -= 1, this._xStart -= this.dx, this._yStart -= this.dy, this._distance = 1, this) : (this._done = true, null);
  }
  _seekBackwards(t8, e12) {
    const s10 = this.backwardLength;
    if (t8 <= s10)
      return this._distance = (s10 - t8) / this.length, this;
    let n10 = this.backwardLength;
    for (; this.prev(); ) {
      if (n10 + this.length > t8)
        return this._seekBackwards(t8 - n10);
      n10 += this.length;
    }
    return this._distance = 0, e12 ? this : null;
  }
  seek(t8, e12 = false) {
    if (t8 < 0)
      return this._seekBackwards(Math.abs(t8), e12);
    if (t8 <= this.remainingLength)
      return this._distance = (this.backwardLength + t8) / this.length, this;
    let s10 = this.remainingLength;
    for (; this.next(); ) {
      if (s10 + this.length > t8)
        return this.seek(t8 - s10, e12);
      s10 += this.length;
    }
    return this._distance = 1, e12 ? this : null;
  }
};
function u10(t8, e12, s10, n10 = true) {
  const i10 = a6(t8), r12 = c8.create(t8), h6 = i10 / 2;
  if (!n10)
    return r12.seek(h6), void s10(r12.clone(), 0, h6 + 0 * e12, i10);
  const d8 = Math.max((i10 - e12) / 2, 0), u12 = Math.floor(d8 / e12), o12 = h6 - u12 * e12;
  r12.seek(o12);
  for (let a7 = -u12; a7 <= u12; a7++)
    r12.x < 512 && r12.x >= 0 && r12.y < 512 && r12.y >= 0 && s10(r12.clone(), a7, h6 + a7 * e12, i10), r12.seek(e12);
}
function l4(t8, e12) {
  const s10 = e12;
  for (let n10 = 0; n10 < t8.length; n10++) {
    let e13 = t8[n10];
    const i10 = [];
    i10.push(e13[0]);
    for (let t9 = 1; t9 < e13.length; t9++) {
      let [s11, n11] = i10[t9 - 1];
      s11 += e13[t9][0], n11 += e13[t9][1], i10.push([s11, n11]);
    }
    g8(i10, s10);
    const r12 = [];
    r12.push(i10[0]);
    for (let t9 = 1; t9 < i10.length; t9++) {
      const [e14, s11] = i10[t9 - 1], [n11, h6] = i10[t9], a7 = Math.round(n11 - e14), d8 = Math.round(h6 - s11);
      r12.push([a7, d8]);
    }
    t8[n10] = r12, e13 = r12;
  }
  return t8;
}
function g8(t8, e12) {
  const r12 = 1e-6;
  if (e12 <= 0)
    return;
  const h6 = t8.length;
  if (h6 < 3)
    return;
  const a7 = [];
  let d8 = 0;
  a7.push(0);
  for (let n10 = 1; n10 < h6; n10++)
    d8 += u3(t8[n10], t8[n10 - 1]), a7.push(d8);
  e12 = Math.min(e12, 0.2 * d8);
  const c10 = [];
  c10.push(t8[0][0]), c10.push(t8[0][1]);
  const u12 = t8[h6 - 1][0], o12 = t8[h6 - 1][1], _5 = t6([0, 0], t8[0], t8[1]);
  r6(_5), t8[0][0] += e12 * _5[0], t8[0][1] += e12 * _5[1], t6(_5, t8[h6 - 1], t8[h6 - 2]), r6(_5), t8[h6 - 1][0] += e12 * _5[0], t8[h6 - 1][1] += e12 * _5[1];
  for (let s10 = 1; s10 < h6; s10++)
    a7[s10] += e12;
  a7[h6 - 1] += e12;
  const l7 = 0.5 * e12;
  for (let s10 = 1; s10 < h6 - 1; s10++) {
    let n10 = 0, i10 = 0, d9 = 0;
    for (let h7 = s10 - 1; h7 >= 0 && !(a7[h7 + 1] < a7[s10] - l7); h7--) {
      const c11 = l7 + a7[h7 + 1] - a7[s10], u13 = a7[h7 + 1] - a7[h7], o13 = a7[s10] - a7[h7] < l7 ? 1 : c11 / u13;
      if (Math.abs(o13) < r12)
        break;
      const _6 = o13 * o13, g9 = o13 * c11 - 0.5 * _6 * u13, x10 = o13 * u13 / e12, f14 = t8[h7 + 1], y8 = t8[h7][0] - f14[0], k5 = t8[h7][1] - f14[1];
      n10 += x10 / g9 * (f14[0] * o13 * c11 + 0.5 * _6 * (c11 * y8 - u13 * f14[0]) - _6 * o13 * u13 * y8 / 3), i10 += x10 / g9 * (f14[1] * o13 * c11 + 0.5 * _6 * (c11 * k5 - u13 * f14[1]) - _6 * o13 * u13 * k5 / 3), d9 += x10;
    }
    for (let c11 = s10 + 1; c11 < h6 && !(a7[c11 - 1] > a7[s10] + l7); c11++) {
      const h7 = l7 - a7[c11 - 1] + a7[s10], u13 = a7[c11] - a7[c11 - 1], o13 = a7[c11] - a7[s10] < l7 ? 1 : h7 / u13;
      if (Math.abs(o13) < r12)
        break;
      const _6 = o13 * o13, g9 = o13 * h7 - 0.5 * _6 * u13, x10 = o13 * u13 / e12, f14 = t8[c11 - 1], y8 = t8[c11][0] - f14[0], k5 = t8[c11][1] - f14[1];
      n10 += x10 / g9 * (f14[0] * o13 * h7 + 0.5 * _6 * (h7 * y8 - u13 * f14[0]) - _6 * o13 * u13 * y8 / 3), i10 += x10 / g9 * (f14[1] * o13 * h7 + 0.5 * _6 * (h7 * k5 - u13 * f14[1]) - _6 * o13 * u13 * k5 / 3), d9 += x10;
    }
    c10.push(n10 / d9), c10.push(i10 / d9);
  }
  c10.push(u12), c10.push(o12);
  for (let s10 = 0, n10 = 0; s10 < h6; s10++)
    t8[s10][0] = c10[n10++], t8[s10][1] = c10[n10++];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLabelTemplate.js
var y7 = s.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate");
var x9 = (t8, i10 = "mapview-labeling") => y7.error(new s2(i10, t8));
var L3 = 1;
var P4 = 0;
var M6 = 4;
var S3 = 25;
function w6(e12, t8) {
  const n10 = !!e12.minScale && t8.scaleToZoom(e12.minScale) || 0;
  return o2(n10, 0, 25.5);
}
function v4(e12, t8) {
  const n10 = !!e12.maxScale && t8.scaleToZoom(e12.maxScale) || 255;
  return o2(n10, 0, 25.5);
}
function A2(e12) {
  const t8 = /* @__PURE__ */ new Map();
  return (i10) => (t8.has(i10) || t8.set(i10, e12(i10)), t8.get(i10));
}
var Z3 = A2((e12) => {
  let t8 = 0;
  if (0 === e12)
    return 1 / 0;
  for (; !(e12 % 2); )
    t8++, e12 /= 2;
  return t8;
});
var I = (e12) => Math.floor(127 * e12 + 127);
var O2 = (e12) => Math.floor(10 * e12);
var z3 = (e12) => Math.round(e12 * (254 / 360));
var G3 = class extends p6 {
  constructor(e12, t8, i10, n10) {
    super(e12, i10.font.size, i10.haloSize || 0, i10.font.size, i10.color && s4(i10.color) || 0, i10.haloColor && s4(i10.haloColor) || 0, i10.horizontalAlignment, i10.verticalAlignment, i3(t8.labelPlacement) ? i2.MAP : i2.SCREEN, i10.font.decoration, false, i10.angle || 0, i10.xoffset, i10.yoffset, i10.lineWidth, i10.lineHeight, null, null, null, null, null), this._outLineLabelAngle = 0, this._refPlacementPadding = 0, this._refPlacementDirX = 0, this._refPlacementDirY = 0, this._refOffsetX = 0, this._refOffsetY = 0, this._zoomLevel = 0, this.geometryType = E.LABEL, this._allowOverrun = t8.allowOverrun ?? false, this._repeatLabel = t8.repeatLabel ?? true, this._labelPosition = t8.labelPosition ?? "curved";
    const o12 = w6(t8, n10), h6 = v4(t8, n10), c10 = t8.labelPlacement, [g9, u12] = a2(c10);
    this._xAlignD = g9, this._yAlignD = u12, this._minZoom = o12, this._maxZoom = h6, this._refPlacementPadding = u(i10.haloSize) + k, this._repeatLabelDistance = t8.repeatLabelDistance ? u(t8.repeatLabelDistance) : 128;
    const d8 = Z.load(e12);
    d8.sdf = true, this._materialKey = d8.data;
  }
  static fromLabelClass(e12, t8) {
    if ("esriServerLinePlacementCenterAlong" === e12.labelPlacement) {
      const t9 = e12.symbol;
      t9.xoffset = 0, t9.yoffset = 0, t9.angle = 0, t9.font.decoration = "none";
    }
    return new G3(e12.materialKey, e12, e12.symbol, t8);
  }
  get _shapedBox() {
    return e(this._shapingInfo).bounds;
  }
  setZoomLevel(e12) {
    this._zoomLevel = e12;
  }
  bindReferenceTemplate(e12) {
    let t8 = c2(this._xAlignD), i10 = o7(this._yAlignD);
    if (this._refOffsetX = 0, this._refOffsetY = 0, t(e12))
      return void (this._refSymbolAndPlacementOffset = x(0, 0, I(t8), I(i10)));
    if ("circle" === e12.boundsType && (t8 || i10)) {
      const e13 = Math.sqrt(t8 * t8 + i10 * i10);
      t8 /= e13, i10 /= e13;
    }
    const n10 = Math.max(e12.height, e12.width), s10 = this._refPlacementPadding * M6;
    this._refSymbolAndPlacementOffset = x(s10, n10, I(t8), I(i10)), this._referenceSize = n10, this._refPlacementDirX = t8, this._refPlacementDirY = i10, this._refOffsetX = e12.xOffset, this._refOffsetY = e12.yOffset;
  }
  _write(e12, t8) {
    if (t(this._shapingInfo))
      return;
    const i10 = this._shapingInfo, n10 = t8.getDisplayId(), s10 = "esriGeometryPolygon" === t8.geometryType ? t8.readLegacyCentroid() : t8.readLegacyGeometry();
    if (s10)
      switch (this.current = { out: e12, inId: n10, inShaping: i10, zoomLevel: this._zoomLevel }, t8.geometryType) {
        case "esriGeometryPolyline":
          this._placeLineLabels(s10);
          break;
        case "esriGeometryPoint":
        case "esriGeometryPolygon":
          this._placePointLabels(s10);
          break;
        default:
          x9("mapview-labeling", `Geometry of type ${t8.geometryType} is not supported`);
      }
  }
  _isVisible(e12, t8) {
    const i10 = O2(this.current.zoomLevel);
    return O2(e12) <= i10 && i10 <= O2(t8);
  }
  _placePointLabels(e12) {
    const { out: t8, inId: i10, inShaping: n10 } = this.current;
    this._writeGlyphs(t8, i10, e12, n10);
  }
  _placeLineLabels(e12) {
    const t8 = l4(e12.paths, this.current.inShaping.bounds.width), i10 = this._placeSubdivGlyphs.bind(this), n10 = (this._shapedBox.width + this._repeatLabelDistance) / (1 << L3);
    for (const o12 of t8)
      u10(o12, n10, i10, this._repeatLabel);
  }
  _placeSubdivGlyphs(e12, t8, i10, n10) {
    const o12 = Z3(t8), s10 = this._shapedBox.width / (1 << L3), r12 = Math.sqrt(this._repeatLabelDistance) / (1 << L3), a7 = Math.min(i10, n10 - i10), l7 = this.current.inShaping.isMultiline ? S3 : Math.log2(a7 / (r12 + s10 / 2)), h6 = 0 === t8 ? l7 : Math.min(o12, l7), c10 = Math.max(this._minZoom, this.current.zoomLevel + L3 - h6), m6 = this.current.zoomLevel - c10, f14 = this._shapedBox.width / 2 * 2 ** m6;
    this.current.inShaping.isMultiline ? 0 === t8 && this._placeStraight(e12, c10) : this._allowOverrun && m6 < 0 ? this._placeStraightAlong(e12, this._minZoom) : "parallel" === this._labelPosition ? this._placeStraightAlong(e12, c10) : "curved" === this._labelPosition && this._placeCurved(e12, c10, f14);
  }
  _placeStraight(e12, t8) {
    const { out: i10, inId: n10, inShaping: o12 } = this.current, s10 = Math.ceil(e12.angle * (180 / Math.PI) % 360), r12 = Math.ceil((e12.angle * (180 / Math.PI) + 180) % 360);
    this._outLineLabelAngle = z3(s10), this._writeGlyphs(i10, n10, e12, o12, t8), this._outLineLabelAngle = z3(r12), this._writeGlyphs(i10, n10, e12, o12, t8);
  }
  _placeCurved(e12, t8, i10) {
    const { out: n10, inId: o12 } = this.current;
    n10.metricStart(o12, t8, e12.x, e12.y, 0, 0, 0, 0);
    const s10 = e12.clone(), r12 = e12.angle * (180 / Math.PI) % 360, a7 = (e12.angle * (180 / Math.PI) + 180) % 360;
    this._outLineLabelAngle = z3(r12), this._placeFirst(s10, t8, 1), this._placeBack(e12, s10, t8, i10, 1), this._placeForward(e12, s10, t8, i10, 1), this._outLineLabelAngle = z3(a7), this._placeFirst(s10, t8, 0), this._placeBack(e12, s10, t8, i10, 0), this._placeForward(e12, s10, t8, i10, 0), n10.metricEnd();
  }
  _placeStraightAlong(e12, t8) {
    const { out: i10, inId: n10 } = this.current;
    i10.metricStart(n10, t8, e12.x, e12.y, 0, 0, 0, 0);
    const o12 = e12.clone(), s10 = e12.angle * (180 / Math.PI) % 360, r12 = (e12.angle * (180 / Math.PI) + 180) % 360;
    this._outLineLabelAngle = z3(s10), this._placeFirst(o12, t8, 1, true), this._outLineLabelAngle = z3(r12), this._placeFirst(o12, t8, 0, true), i10.metricEnd();
  }
  _placeBack(e12, t8, i10, n10, o12) {
    const s10 = e12.clone();
    let r12 = e12.backwardLength + P4;
    for (; s10.prev() && !(r12 >= n10); )
      this._placeOnSegment(s10, t8, r12, i10, -1, o12), r12 += s10.length + P4;
  }
  _placeForward(e12, t8, i10, n10, o12) {
    const s10 = e12.clone();
    let r12 = e12.remainingLength + P4;
    for (; s10.next() && !(r12 >= n10); )
      this._placeOnSegment(s10, t8, r12, i10, 1, o12), r12 += s10.length + P4;
  }
  _placeFirst(e12, t8, i10, n10 = false) {
    const o12 = e12, s10 = this.current.inShaping, r12 = s10.glyphs, a7 = this.current.zoomLevel, { out: l7, inId: h6 } = this.current;
    for (const c10 of r12) {
      const r13 = c10.x > s10.bounds.x ? i10 : 1 - i10, m6 = r13 * e12.remainingLength + (1 - r13) * e12.backwardLength, f14 = Math.abs(c10.x + c10.width / 2 - s10.bounds.x), _5 = Math.max(0, a7 + Math.log2(f14 / (m6 + P4))), g9 = Math.max(t8, n10 ? 0 : _5);
      if (c10.maxZoom = S3, c10.angle = e12.angle + (1 - i10) * Math.PI, c10.minZoom = g9, this._writeGlyph(l7, h6, o12.x, o12.y, c10), i10 && this._isVisible(c10.minZoom, c10.maxZoom)) {
        const e13 = c10.bounds;
        l7.metricBoxWrite(e13.center[0], e13.center[1], e13.width, e13.height);
      }
    }
  }
  _placeOnSegment(e12, t8, i10, n10, o12, s10) {
    const r12 = this.current.inShaping.glyphs, { out: a7, inId: l7 } = this.current, h6 = this.current.inShaping, c10 = this.current.zoomLevel, m6 = e12.dx / e12.length, f14 = e12.dy / e12.length, _5 = { x: e12.x + i10 * -o12 * m6, y: e12.y + i10 * -o12 * f14 };
    for (const g9 of r12) {
      const r13 = g9.x > h6.bounds.x ? s10 : 1 - s10;
      if (!(r13 && 1 === o12 || !r13 && -1 === o12))
        continue;
      const m7 = Math.abs(g9.x + g9.width / 2 - h6.bounds.x), f15 = Math.max(0, c10 + Math.log2(m7 / i10) - 0.1), p8 = Math.max(n10, c10 + Math.log2(m7 / (i10 + e12.length + P4)));
      if (0 !== f15 && (g9.angle = e12.angle + (1 - s10) * Math.PI, g9.minZoom = p8, g9.maxZoom = f15, this._writeGlyph(a7, l7, _5.x, _5.y, g9), s10 && this._isVisible(g9.minZoom, g9.maxZoom))) {
        const i11 = g9.bounds, n11 = e12.x - t8.x, o13 = e12.y - t8.y;
        a7.metricBoxWrite(i11.center[0] + n11, i11.center[1] + o13, i11.width, i11.height);
      }
    }
  }
  _writeGlyphs(e12, t8, i10, n10, o12 = this._minZoom) {
    if (i10.x < 0 || i10.x >= 512 || i10.y < 0 || i10.y >= 512)
      return;
    const s10 = i10.x + this._refOffsetX, r12 = i10.y - this._refOffsetY;
    for (const c10 of n10.glyphs)
      c10.minZoom = o12, c10.maxZoom = this._maxZoom, this._writeGlyph(e12, t8, s10, r12, c10);
    const a7 = this._refPlacementDirX, l7 = this._refPlacementDirY, h6 = n10.boundsT;
    e12.metricStart(t8, o12, s10, r12, a7, l7, this._referenceSize, this._materialKey), e12.metricBoxWrite(h6.center[0], h6.center[1], h6.width, h6.height), e12.metricEnd();
  }
  _writeVertexCommon(e12, t8, i10, n10) {
    const o12 = this._color, s10 = this._haloColor, r12 = x(0, 0, this._size, this._haloSize), a7 = Math.max(n10.minZoom, this._minZoom), l7 = Math.min(n10.maxZoom, this._maxZoom), h6 = x(O2(a7), O2(l7), this._outLineLabelAngle, 0);
    e12.vertexWrite(i10), e12.vertexWrite(t8), e12.vertexWrite(o12), e12.vertexWrite(s10), e12.vertexWrite(r12), e12.vertexWrite(this._refSymbolAndPlacementOffset), e12.vertexWrite(h6);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/WGLMeshFactory.js
var l5 = class {
  constructor(e12, t8, s10) {
    this._loadPromise = o6(), this._geometryType = e12, this._idField = t8, this._templateStore = s10;
  }
  update(t8, r12) {
    r(t8.mesh.labels) && (this._labelTemplates = this._createLabelTemplates(t8.mesh.labels, r12)), this._schema = t8;
  }
  _createLabelTemplates(e12, t8) {
    const r12 = /* @__PURE__ */ new Map();
    if ("simple" === e12.type) {
      for (const s10 of e12.classes) {
        const e13 = G3.fromLabelClass(s10, t8);
        r12.set(s10.index, e13);
      }
      return r12;
    }
    for (const s10 in e12.classes) {
      const o12 = e12.classes[s10];
      for (const e13 of o12) {
        const s11 = G3.fromLabelClass(e13, t8);
        r12.set(e13.index, s11);
      }
    }
    return r12;
  }
  get templates() {
    return this._templateStore;
  }
  async analyze(r12, i10, o12, l7, n10, m6, p8) {
    if (p(p8))
      return;
    let f14;
    "dictionary" === o12.type && (f14 = await o12.analyze(this._idField, r12.copy(), i10, n10, m6, p8));
    let c10 = 0;
    for (; r12.next(); ) {
      let t8;
      if (t8 = f14 ? f14[c10++] : r(l7) && p2(r12.getDisplayId()) && 1 !== r12.readAttribute("cluster_count") ? l7.match(this._idField, r12, this._geometryType, n10, m6) : o12.match(this._idField, r12, this._geometryType, n10, m6), r12.setGroupId(t8), G2(t8)) {
        const e12 = this._templateStore.getDynamicTemplateGroup(t8);
        for (const t9 of e12)
          t9 && t9.analyze && t9.analyze(this._templateStore, r12, n10, m6);
      }
    }
    return await this._loadPromise, this._templateStore.finalize(p8);
  }
  async analyzeGraphics(e12, r12, s10, i10, o12, l7) {
    if (p(l7))
      return;
    const n10 = e12.getCursor();
    for (s10 && await s10.analyze(this._idField, n10.copy(), r12, i10, o12, l7); n10.next(); ) {
      let e13 = n10.getGroupId();
      if (null != e13 && -1 !== e13 || (e13 = s10.match(this._idField, n10, n10.geometryType, i10, o12), n10.setGroupId(e13)), G2(e13)) {
        const t8 = this._templateStore.getDynamicTemplateGroup(e13);
        for (const e14 of t8)
          e14 && e14.analyze && e14.analyze(this._templateStore, n10, i10, o12);
      }
      n10.setGroupId(e13);
    }
    return await this._loadPromise, this._templateStore.finalize(l7);
  }
  writeGraphic(e12, t8, r12, s10) {
    const i10 = t8.getGroupId(), o12 = t8.getDisplayId(), l7 = this._templateStore.getTemplateGroup(i10);
    if (e12.featureStart(t8.insertAfter, 0), null != o12) {
      if (G2(i10))
        for (const e13 of l7)
          e13 && e13.bindFeature(t8, null, null);
      if (l7) {
        for (const i11 of l7)
          i11 && i11.write(e12, t8, r12, s10);
        e12.featureEnd();
      }
    }
  }
  writeCursor(t8, r12, s10, i10, o12, l7, n10) {
    const m6 = r12.getGroupId(), p8 = r12.getDisplayId(), f14 = this._templateStore.getTemplateGroup(m6), c10 = this._schema.mesh.sortKey;
    let d8 = 0;
    if (r(c10) && (d8 = null != c10.fieldIndex ? r12.getComputedNumericAtIndex(c10.fieldIndex) : null != c10.field ? r12.readAttribute(c10.field) : r12.readAttribute(this._idField), d8 *= "asc" === c10.order ? 1 : -1), t8.featureStart(0, null == d8 || isNaN(d8) ? 0 : d8), null != p8 && f14) {
      if (G2(m6))
        for (const e12 of f14)
          e12.bindFeature(r12, s10, i10);
      for (const e12 of f14)
        e12.write(t8, r12, o12, n10);
      if (r(l7) && t8.hasRecords) {
        const e12 = l7 && this._findLabelRef(f14);
        this._writeLabels(t8, r12, l7, e12, o12, n10);
      }
      t8.featureEnd();
    }
  }
  _findLabelRef(e12) {
    for (const t8 of e12)
      if (t8 instanceof b4)
        return t8;
    return null;
  }
  _writeLabels(t8, r12, s10, i10, o12, a7) {
    for (const l7 of s10)
      if (r(l7) && l7) {
        const { glyphs: e12, rtl: s11, index: n10 } = l7, m6 = this._labelTemplates.get(n10);
        m6.setZoomLevel(o12), m6.bindReferenceTemplate(i10), m6.bindTextInfo(e12, s11), m6.write(t8, r12, null, a7);
      }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var n9 = s.getLogger("esri/views/2d/engine/webgl/util/Matcher");
async function l6(e12, t8, s10, r12) {
  switch (e12.type) {
    case "simple":
    case "heatmap":
      return o11.fromBasicRenderer(e12, t8, s10, r12);
    case "map":
      return m5.fromUVRenderer(e12, t8, s10, r12);
    case "interval":
      return c9.fromCBRenderer(e12, t8, s10, r12);
    case "dictionary":
      return p7.fromDictionaryRenderer(e12, t8, s10, r12);
    case "pie-chart":
      return u11.fromPieChartRenderer(e12, t8, s10, r12);
    case "subtype":
      return u11.fromSubtypes(e12, t8, s10, r12);
  }
}
var o11 = class {
  constructor() {
    this.type = "feature", this._defaultResult = null;
  }
  static async fromBasicRenderer(e12, t8, s10, r12) {
    const i10 = new o11();
    if (e12.symbol) {
      const n10 = await n6(e12.symbol, s10, r12), l7 = t8.createTemplateGroup(n10, null);
      i10.setDefault(l7);
    }
    return i10;
  }
  static async fromPieChartRenderer(e12, t8, s10, r12) {
    const i10 = new o11();
    if (e12.markerSymbol) {
      const n10 = await n6(e12.markerSymbol, s10, r12);
      let l7;
      e12.fillSymbol && (l7 = await n6(e12.fillSymbol, s10, r12));
      const o12 = t8.createTemplateGroup(n10, l7);
      i10.setDefault(o12);
    }
    return i10;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(e12) {
    this._defaultResult = e12;
  }
  match(e12, t8, s10, r12, i10) {
    return this.getDefault();
  }
  async analyze(e12, t8, s10, r12, i10, a7) {
    return null;
  }
};
var u11 = class extends o11 {
  constructor(e12, t8) {
    super(), this._subMatchers = e12, this._subtypeField = t8;
  }
  static async fromSubtypes(e12, t8, s10, r12) {
    const i10 = /* @__PURE__ */ new Map(), a7 = [];
    for (const n10 in e12.renderers) {
      const o12 = parseInt(n10, 10), u12 = l6(e12.renderers[n10], t8, s10, r12).then((e13) => i10.set(o12, e13));
      a7.push(u12);
    }
    return await Promise.all(a7), new u11(i10, e12.subtypeField);
  }
  match(e12, t8, s10, r12, i10) {
    const a7 = t8.readAttribute(this._subtypeField), n10 = this._subMatchers.get(a7);
    return n10 ? n10.match(e12, t8, s10, r12, i10) : null;
  }
};
var c9 = class extends o11 {
  constructor(e12, t8, s10, r12) {
    super(), this.type = "interval", this._intervals = [], this._isMaxInclusive = t8, this._fieldIndex = r12, this._field = e12, this._normalizationInfo = s10;
  }
  static async fromCBRenderer(e12, t8, s10, r12) {
    const { isMaxInclusive: i10, normalizationField: n10, normalizationTotal: l7, normalizationType: o12 } = e12, u12 = e12.field, m6 = new c9(u12, i10, { normalizationField: n10, normalizationTotal: l7, normalizationType: o12 }, e12.fieldIndex), d8 = await n6(e12.backgroundFillSymbol, s10, r12);
    await Promise.all(e12.intervals.map(async (e13) => {
      const i11 = await n6(e13.symbol, s10, r12), n11 = await t8.createTemplateGroup(i11, d8), l8 = { min: e13.min, max: e13.max };
      m6.add(l8, n11);
    }));
    const h6 = await n6(e12.defaultSymbol, s10, r12);
    if (h6) {
      const e13 = await t8.createTemplateGroup(h6, d8);
      m6.setDefault(e13);
    }
    return m6;
  }
  add(e12, t8) {
    this._intervals.push({ interval: e12, result: t8 }), this._intervals.sort((e13, t9) => e13.interval.min - t9.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  match(e12, t8, s10, r12, i10) {
    if (null == this._fieldIndex && !this._field)
      return this.getDefault();
    const a7 = null != this._fieldIndex ? t8.getComputedNumericAtIndex(this._fieldIndex) : this._getValueFromField(t8);
    if (!a7 && (null == a7 || isNaN(a7)))
      return this.getDefault();
    for (let n10 = 0; n10 < this._intervals.length; n10++) {
      const { interval: e13, result: t9 } = this._intervals[n10], s11 = a7 >= e13.min, r13 = this._isMaxInclusive ? a7 <= e13.max : a7 < e13.max;
      if (s11 && r13)
        return t9;
    }
    return this.getDefault();
  }
  _needsNormalization() {
    const e12 = this._normalizationInfo;
    return e12 && (e12.normalizationField || e12.normalizationTotal || e12.normalizationType);
  }
  _getValueFromField(e12) {
    const t8 = e12.readAttribute(this._field);
    if (!this._needsNormalization() || null == t8)
      return t8;
    const { normalizationField: s10, normalizationTotal: r12, normalizationType: i10 } = this._normalizationInfo, a7 = !!s10 && e12.readAttribute(s10);
    if (i10)
      switch (i10) {
        case "esriNormalizeByField":
          return a7 ? t8 / a7 : void 0;
        case "esriNormalizeByLog":
          return Math.log(t8) * Math.LOG10E;
        case "esriNormalizeByPercentOfTotal":
          return t8 / r12 * 100;
        default:
          return void n9.error(`Found unknown normalization type: ${i10}`);
      }
    else
      n9.error("Normalization is required, but no type was set!");
  }
};
var m5 = class extends o11 {
  constructor(e12, t8, s10) {
    super(), this.type = "map", this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fieldsIndex = s10, this._fields = e12, this._seperator = t8 || "";
  }
  static async fromUVRenderer(e12, t8, s10, r12) {
    const i10 = e12.fieldDelimiter, n10 = [e12.field];
    e12.field2 && n10.push(e12.field2), e12.field3 && n10.push(e12.field3);
    const l7 = await n6(e12.backgroundFillSymbol, s10, r12), o12 = new m5(n10, i10, e12.fieldIndex);
    await Promise.all(e12.map.map(async (e13) => {
      const i11 = await n6(e13.symbol, s10, r12), n11 = await t8.createTemplateGroup(i11, l7);
      "<Null>" === e13.value ? o12.setNullResult(n11) : o12.add(e13.value, n11);
    }));
    const u12 = await n6(e12.defaultSymbol, s10, r12);
    if (u12) {
      const e13 = await t8.createTemplateGroup(u12, l7);
      o12.setDefault(e13);
    }
    return o12;
  }
  setNullResult(e12) {
    this._nullResult = e12;
  }
  add(e12, t8) {
    this._resultsMap.set(e12.toString(), t8);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  match(e12, t8, s10, r12, i10) {
    if (null == this._fieldsIndex && !this._fields)
      return this.getDefault();
    const a7 = null != this._fieldsIndex ? t8.getComputedStringAtIndex(this._fieldsIndex) : this._getValueFromFields(t8);
    if (null !== this._nullResult && (null == a7 || "" === a7 || "<Null>" === a7))
      return this._nullResult;
    if (!a7 && null == a7)
      return this.getDefault();
    const n10 = a7.toString();
    return this._resultsMap.has(n10) ? this._resultsMap.get(n10) : this.getDefault();
  }
  _getValueFromFields(e12) {
    const t8 = [];
    for (const s10 of this._fields) {
      const r12 = e12.readAttribute(s10);
      null == r12 || "" === r12 ? t8.push("<Null>") : t8.push(r12);
    }
    return t8.join(this._seperator);
  }
};
async function d7(e12, t8) {
  const s10 = e12 || 1;
  if ("number" == typeof s10)
    return (e13, t9, r12) => s10;
  const a7 = await i5(s10, t8.spatialReference, t8.fields);
  return (e13, s11, r12) => s7(a7, e13, { $view: r12 }, t8.geometryType, s11) || 1;
}
var h5;
async function f13() {
  return h5 || (h5 = import("./createSymbolSchema-FBPRWCBE.js")), h5;
}
var p7 = class extends o11 {
  constructor(e12, t8, r12, i10, a7, n10) {
    super(), this.type = "dictionary", this._groupIdCache = new e6(100), this._loader = e12, this._fieldMap = e12.fieldMap, this._symbolFields = e12.getSymbolFields(), this._templates = t8, this._info = r12, this._scaleFn = i10, this._schemaUtilsModule = a7, this._symbolOptions = n10;
  }
  static async fromDictionaryRenderer(e12, t8, s10, r12) {
    const [{ DictionaryLoader: i10 }, a7] = await Promise.all([import("./DictionaryLoader-7CC7ZIBQ.js"), f13()]), n10 = new i10(e12.url, e12.config, e12.fieldMap);
    await n10.fetchResources({ spatialReference: s10.spatialReference, fields: s10.fields });
    const l7 = await d7(e12.scaleExpression, s10);
    return new p7(n10, t8, s10, l7, a7, e12.symbolOptions);
  }
  async _analyzeFeature(t8, s10, r12, i10, l7) {
    const o12 = t8.readLegacyFeature(), u12 = this._scaleFn(o12, r12, i10), c10 = this._attributeHash(o12) + "-" + u12, m6 = this._groupIdCache.get(c10);
    if (m6)
      return m6;
    const d8 = { ...i10, spatialReference: this._info.spatialReference, abortOptions: l7, fields: this._info.fields }, h6 = await this._loader.getSymbolAsync(o12, d8), f14 = this._schemaUtilsModule.createSymbolSchema(h6, this._symbolOptions), p8 = n6(f14, this._info, s10, l7).then((t9) => {
      if ("expanded-cim" !== t9.type)
        return n9.error(new s2("mapview-bad-type", `Found unexpected type ${t9.type} in dictionary response`)), null;
      t9.hash += "-" + u12;
      for (const e12 of t9.layers)
        e12.scaleFactor = u12, e12.templateHash += "-" + u12;
      return this._templates.createTemplateGroup(t9, null);
    });
    return this._groupIdCache.put(c10, p8, 1), p8;
  }
  async analyze(e12, t8, s10, r12, i10, a7) {
    const n10 = t8.getCursor(), l7 = [];
    for (; n10.next(); )
      l7.push(this._analyzeFeature(n10, s10, r12, i10, a7));
    return Promise.all(l7);
  }
  match(e12, t8, s10, r12, i10) {
    return null;
  }
  _attributeHash(e12) {
    let t8 = "";
    for (const s10 of this._symbolFields) {
      const r12 = this._fieldMap[s10];
      r12 && (t8 += e12.attributes[r12] + "-");
    }
    return t8;
  }
};

export {
  e7 as e,
  E2 as E,
  e10 as e2,
  t5 as t,
  x8 as x,
  l5 as l,
  l6 as l2
};
//# sourceMappingURL=chunk-6UTST6NO.js.map
