import {
  O,
  e2
} from "./chunk-25QHXOZB.js";
import "./chunk-AA7FGPNP.js";
import {
  n as n2
} from "./chunk-UHJVTABQ.js";
import {
  g
} from "./chunk-W66LN57L.js";
import "./chunk-PNUWGOXY.js";
import {
  s as s4
} from "./chunk-WBX2MY5R.js";
import "./chunk-3DZ4BNVJ.js";
import {
  o
} from "./chunk-T7SYNS2R.js";
import "./chunk-G4IZ2HTT.js";
import "./chunk-T7BEWVV3.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-FTLBKDGL.js";
import {
  j
} from "./chunk-TT2HIXWQ.js";
import "./chunk-OIPX3EDD.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-OOZMA7DN.js";
import "./chunk-Y7FSCP47.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-DMJWTK32.js";
import {
  s as s3
} from "./chunk-XRL56EGK.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  i
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/widgets/Slider/SliderViewModel.js
var l = "esri.widgets.Slider.SliderViewModel";
var u = s.getLogger(l);
var p = class extends y {
  constructor(t2) {
    super(t2), this.precision = 4, this.thumbsConstrained = true;
  }
  set effectiveMax(t2) {
    this.setEffectiveMax(t2);
  }
  set effectiveMin(t2) {
    this.setEffectiveMin(t2);
  }
  set labelFormatFunction(t2) {
    this._set("labelFormatFunction", t2);
  }
  set inputFormatFunction(t2) {
    this._set("inputFormatFunction", t2);
  }
  set inputParseFunction(t2) {
    this._set("inputParseFunction", t2);
  }
  get labels() {
    const { max: t2, min: e3, values: i2 } = this, s5 = i2 && i2.length ? i2.map((t3, e4) => this.getLabelForValue(t3, "value", e4)) : [];
    return { max: this.getLabelForValue(t2, "max"), min: this.getLabelForValue(e3, "min"), values: s5 };
  }
  set max(t2) {
    this.setMax(t2);
  }
  set min(t2) {
    this.setMin(t2);
  }
  get state() {
    const { max: t2, min: e3 } = this;
    return r(t2) && r(e3) && t2 > e3 ? "ready" : "disabled";
  }
  set values(t2) {
    const { max: e3, min: i2 } = this, s5 = this.values;
    s5 && t2 && s5.length === t2.length && s5.every((e4, i3) => e4 === t2[i3]) || (this._set("values", null), t2 && t2.length && (r(i2) && t2.some((t3) => t3 < i2) && (this.min = Math.min(...t2)), r(e3) && t2.some((t3) => t3 > e3) && (this.max = Math.max(...t2))), this._set("values", t2));
  }
  toPrecision(t2) {
    return parseFloat(t2.toFixed(this.precision));
  }
  defaultLabelFormatFunction(t2) {
    const { max: e3, min: i2, precision: s5 } = this, r2 = e3 - i2 > 10 ? 2 : s5;
    return parseFloat(t2.toFixed(r2)).toString();
  }
  defaultInputFormatFunction(t2) {
    return t2.toString();
  }
  defaultInputParseFunction(t2) {
    return parseFloat(t2);
  }
  getBounds() {
    const { effectiveMax: t2, effectiveMin: e3, max: i2, min: s5 } = this;
    return { min: r(e3) ? Math.max(s5, e3) : s5, max: r(t2) ? Math.min(i2, t2) : i2 };
  }
  getBoundsForValueAtIndex(t2) {
    const { thumbsConstrained: e3, values: i2 } = this, { min: s5, max: o2 } = this.getBounds();
    if (e3) {
      const e4 = t2 - 1, n3 = t2 + 1;
      return { min: r(i2[e4]) ? i2[e4] : s5, max: r(i2[n3]) ? i2[n3] : o2 };
    }
    return { min: s5, max: o2 };
  }
  getLabelForValue(t2, e3, i2) {
    return t(t2) ? null : this.labelFormatFunction ? this.labelFormatFunction(t2, e3, i2) : this.defaultLabelFormatFunction(t2);
  }
  setMax(t2) {
    const { max: e3, values: i2 } = this;
    if (isNaN(t2))
      return void this._logError("slider:invalid-value", "Supplied value for property 'max' is NaN.");
    if (null === t2)
      return void this._set("max", null);
    const s5 = this.toPrecision(t2);
    if (e3 !== s5 && (this._set("max", s5), i2 && i2.length))
      for (let r2 = 0; r2 < i2.length; r2++)
        s5 < i2[r2] && this.setValue(r2, s5);
  }
  setMin(t2) {
    const { min: e3, values: i2 } = this;
    if (isNaN(t2))
      return void this._logError("slider:invalid-value", "Supplied value for property 'min' is NaN.");
    if (null === t2)
      return void this._set("min", null);
    const s5 = this.toPrecision(t2);
    if (e3 !== s5 && (this._set("min", s5), i2 && i2.length))
      for (let r2 = 0; r2 < i2.length; r2++)
        s5 > i2[r2] && this.setValue(r2, s5);
  }
  setEffectiveMax(t2) {
    if (isNaN(t2))
      return void this._logError("slider:invalid-value", "Supplied value for property 'effectiveMax' is NaN.");
    if (null === t2)
      return void this._set("effectiveMax", null);
    const e3 = this.toPrecision(t2);
    this.effectiveMax !== e3 && this._set("effectiveMax", this._applyBoundsToValue(e3));
  }
  setEffectiveMin(t2) {
    if (isNaN(t2))
      return void this._logError("slider:invalid-value", "Supplied value for property 'effectiveMin' is NaN.");
    if (null === t2)
      return void this._set("effectiveMin", null);
    const e3 = this.toPrecision(t2);
    this.effectiveMin !== e3 && this._set("effectiveMin", this._applyBoundsToValue(e3));
  }
  setValue(t2, e3) {
    if (isNaN(e3))
      return void this._logError("slider:invalid-value", "Supplied value for member of property 'values' is NaN.");
    const { values: i2 } = this, s5 = i2[t2], r2 = this.toPrecision(e3);
    if (s5 === r2)
      return;
    const o2 = [...i2];
    o2[t2] = r2, this._set("values", o2), this.notifyChange("labels");
  }
  _applyBoundsToValue(t2) {
    const { max: e3, min: i2 } = this;
    return r(i2) && t2 < i2 ? i2 : r(e3) && t2 > e3 ? e3 : t2;
  }
  _logError(t2, e3, s5) {
    u.error(new s2(t2, e3, s5));
  }
};
e([d()], p.prototype, "effectiveMax", null), e([d()], p.prototype, "effectiveMin", null), e([d()], p.prototype, "labelFormatFunction", null), e([d()], p.prototype, "inputFormatFunction", null), e([d()], p.prototype, "inputParseFunction", null), e([d({ readOnly: true })], p.prototype, "labels", null), e([d()], p.prototype, "max", null), e([d()], p.prototype, "min", null), e([d()], p.prototype, "precision", void 0), e([d({ readOnly: true })], p.prototype, "state", null), e([d()], p.prototype, "thumbsConstrained", void 0), e([d()], p.prototype, "values", null), p = e([n(l)], p);
var c = p;

// node_modules/@arcgis/core/widgets/Slider.js
var p2 = { base: "esri-slider", reversed: "esri-slider--reversed", horizontalLayout: "esri-slider--horizontal", verticalLayout: "esri-slider--vertical", contentElement: "esri-slider__content", extraContentElement: "esri-slider__extra-content", trackElement: "esri-slider__track", ticksContainerElement: "esri-slider__ticks", tickElement: "esri-slider__tick", tickLabelElement: "esri-slider__tick-label", maxElement: "esri-slider__max", minElement: "esri-slider__min", maxElementInteractive: "esri-slider__max--interactive", minElementInteractive: "esri-slider__min--interactive", rangeElementActive: "esri-slider__range--active", rangeInput: "esri-slider__range-input", anchorElement: "esri-slider__anchor", movingAnchorElement: "esri-slider__anchor--moving", lastMovedAnchorElement: "esri-slider__anchor--moved", anchorElementActive: "esri-slider__anchor--active", anchorElementIndexPrefix: "esri-slider__anchor-", segmentElement: "esri-slider__segment", segmentElementIndexPrefix: "esri-slider__segment-", segmentElementInteractive: "esri-slider__segment--interactive", segmentElementActive: "esri-slider__segment--active", effectiveSegmentElement: "esri-slider__effective-segment", effectiveMaxSegmentElement: "esri-slider__effective-max-segment", effectiveMinSegmentElement: "esri-slider__effective-min-segment", thumbElement: "esri-slider__thumb", labelElement: "esri-slider__label", labelElementInteractive: "esri-slider__label--interactive", labelInput: "esri-slider__label-input", esriWidget: "esri-widget", widgetIcon: "esri-icon-edit", disabled: "esri-disabled", hidden: "esri-hidden" };
var v = { showInput: "Enter", hideInput1: "Enter", hideInput2: "Escape", hideInput3: "Tab", moveAnchorUp: "ArrowUp", moveAnchorDown: "ArrowDown", moveAnchorLeft: "ArrowLeft", moveAnchorRight: "ArrowRight", moveAnchorToMax: "End", moveAnchorToMin: "Home" };
var g2 = "esri.widgets.Slider";
var f = { labels: false, rangeLabels: false };
var b = class extends O {
  constructor(e3, i2) {
    super(e3, i2), this._activeLabelInputIndex = null, this._anchorElements = [], this._dragged = false, this._dragStartInfo = null, this._focusedAnchorIndex = null, this._isMinInputActive = false, this._isMaxInputActive = false, this._lastMovedHandleIndex = null, this._positionPrecision = 5, this._segmentDragStartInfo = null, this._trackHeight = null, this._trackWidth = null, this._zIndices = null, this._zIndexOffset = 3, this.disabled = false, this.draggableSegmentsEnabled = true, this.effectiveMax = null, this.effectiveMin = null, this.effectiveSegmentElements = new j(), this.extraNodes = [], this.inputCreatedFunction = null, this.inputFormatFunction = null, this.inputParseFunction = null, this.label = void 0, this.labelElements = new j(), this.labelInputsEnabled = false, this.labelFormatFunction = null, this.labels = null, this.max = null, this.maxLabelElement = null, this.messages = null, this.min = null, this.minLabelElement = null, this.precision = 4, this.rangeLabelInputsEnabled = false, this.segmentElements = new j(), this.snapOnClickEnabled = true, this.steps = null, this.syncedSegmentsEnabled = false, this.thumbsConstrained = true, this.thumbCreatedFunction = null, this.thumbElements = new j(), this.tickElements = new j(), this.trackElement = null, this.values = null, this.viewModel = new c(), this.visibleElements = { ...f }, this._onAnchorPointerDown = this._onAnchorPointerDown.bind(this), this._onAnchorPointerMove = this._onAnchorPointerMove.bind(this), this._onAnchorPointerUp = this._onAnchorPointerUp.bind(this), this._onLabelPointerDown = this._onLabelPointerDown.bind(this), this._onLabelPointerUp = this._onLabelPointerUp.bind(this), this._onSegmentPointerDown = this._onSegmentPointerDown.bind(this), this._onSegmentPointerMove = this._onSegmentPointerMove.bind(this), this._onSegmentPointerUp = this._onSegmentPointerUp.bind(this), this._onTrackPointerDown = this._onTrackPointerDown.bind(this), this._onTrackPointerMove = this._onTrackPointerMove.bind(this), this._onTrackPointerUp = this._onTrackPointerUp.bind(this);
  }
  destroy() {
    document.removeEventListener("pointerup", this._onLabelPointerUp), document.removeEventListener("pointermove", this._onLabelPointerMove), document.removeEventListener("pointerup", this._onAnchorPointerUp), document.removeEventListener("pointermove", this._onAnchorPointerMove), this.labelElements.removeAll(), this.labelElements.destroy(), this.segmentElements.removeAll(), this.segmentElements.destroy(), this.effectiveSegmentElements.removeAll(), this.effectiveSegmentElements.destroy(), this.thumbElements.removeAll(), this.thumbElements.destroy(), this.tickElements.removeAll(), this.tickElements.destroy();
  }
  set layout(e3) {
    ["vertical", "vertical-reversed", "horizontal", "horizontal-reversed"].includes(e3) || (e3 = "horizontal"), this._set("layout", e3);
  }
  get state() {
    const { _activeLabelInputIndex: e3, _isMaxInputActive: t2, _isMinInputActive: i2, _dragStartInfo: n3, _segmentDragStartInfo: o2, disabled: r2, viewModel: a } = this, l2 = r(n3) || r(o2);
    return r2 ? "disabled" : !(null === e3 && !t2 && !i2) ? "editing" : l2 ? "dragging" : a.state;
  }
  set tickConfigs(e3) {
    this._set("tickConfigs", e3), this.scheduleRender();
  }
  castVisibleElements(e3) {
    return { ...f, ...e3 };
  }
  render() {
    const { label: e3 } = this, t2 = this.classes(p2.base, p2.esriWidget, this._isHorizontalLayout() ? p2.horizontalLayout : p2.verticalLayout, this._isReversedLayout() ? p2.reversed : null, this._isDisabled() ? p2.disabled : null);
    return this._storeTrackDimensions(), n2("div", { "aria-label": e3, class: t2, "touch-action": "none", bind: this, afterCreate: this._afterContainerCreate }, this.renderContent());
  }
  toNextStep(e3) {
    this._toStep(e3, 1);
  }
  toPreviousStep(e3) {
    this._toStep(e3, -1);
  }
  renderContent() {
    const { max: e3, min: t2 } = this;
    if (!(t(t2) || t(e3) || t2 >= e3))
      return [this.renderMin(), this.renderSliderContainer(), this.renderMax()];
  }
  renderSliderContainer() {
    return n2("div", { key: "slider-container", bind: this, class: p2.contentElement }, this.renderTrackElement(), this.renderTicksContainer(), this.renderExtraContentElements());
  }
  renderTrackElement() {
    return n2("div", { afterCreate: this._afterTrackCreate, afterRemoved: this._afterTrackRemoved, bind: this, class: p2.trackElement, "data-node-ref": "trackElement", "touch-action": "none" }, this.renderEffectiveSegmentElements(), this.renderSegmentElements(), this.renderAnchorElements());
  }
  renderEffectiveSegmentElements() {
    if (!this.trackElement || !this.values || !this.values.length)
      return;
    const e3 = r(this.effectiveMax), t2 = r(this.effectiveMin);
    if (!e3 && !t2)
      return;
    const { max: i2, min: n3, viewModel: o2 } = this, r2 = o2.getBounds(), a = [];
    return t2 && a.push(this.renderEffectiveSegmentElement(n3, r2.min, true)), e3 && a.push(this.renderEffectiveSegmentElement(r2.max, i2, false)), a;
  }
  renderSegmentElements() {
    if (!this.trackElement || !this.values || !this.values.length)
      return;
    const e3 = this.values.length, t2 = [];
    for (let i2 = 0; i2 <= e3; i2++)
      t2.push(this.renderSegmentElement(i2));
    return t2;
  }
  renderSegmentElement(e3) {
    const { _trackHeight: t2, _trackWidth: i2, draggableSegmentsEnabled: n3, id: o2, state: r2, values: a } = this, l2 = this._isHorizontalLayout(), h = l2 ? i2 : t2, d2 = this.viewModel.getBounds(), c2 = this._positionFromValue(d2.max), m = this._positionFromValue(d2.min), _ = e3 === a.length ? null : e3, v2 = 0 === e3 ? null : e3 - 1, g3 = r(_), f2 = r(v2);
    let b2, E2;
    const x = [...a].sort((e4, t3) => e4 - t3);
    this._isReversedLayout() ? (b2 = f2 ? this._positionFromValue(x[v2]) : m, E2 = g3 ? this._positionFromValue(x[_]) : c2) : (b2 = g3 ? this._positionFromValue(x[_]) : c2, E2 = f2 ? this._positionFromValue(x[v2]) : m);
    const k = this._applyPrecisionToPosition(100 * E2 / h), y2 = (b2 - E2) / h, I = l2 ? `transform: translate(${k}%, 0px) scale(${y2}, 1);` : `transform: translate(0px, ${k}%) scale(1, ${y2});`, P = this.classes(p2.segmentElement, p2.segmentElementIndexPrefix + e3, n3 && g3 && f2 && "disabled" !== r2 ? p2.segmentElementInteractive : null);
    return n2("div", { afterCreate: this._afterSegmentCreate, afterRemoved: this._afterSegmentRemoved, bind: this, class: P, "data-max-thumb-index": _, "data-min-thumb-index": v2, "data-segment-index": e3, key: `${o2}-segment-${e3}`, style: I, "touch-action": "none" });
  }
  renderEffectiveSegmentElement(e3, t2, i2) {
    const { _trackHeight: n3, _trackWidth: s5, layout: o2 } = this, r2 = this._positionFromValue(e3), a = this._positionFromValue(t2), l2 = this._isHorizontalLayout(), h = l2 ? s5 : n3, d2 = this._applyPrecisionToPosition(100 * r2 / h);
    let c2 = null;
    if ("horizontal" === o2) {
      const e4 = i2 ? h - a : a, t3 = r2 === h ? 0 : d2;
      c2 = `clip-path: inset(0% ${a === h ? 0 : this._applyPrecisionToPosition(e4 / h * 100)}% 0% ${t3}%);`;
    } else {
      const e4 = (a - r2) / h;
      c2 = l2 ? `transform: translate(${d2}%, 0px) scale(${e4}, 1);` : `transform: translate(0px, ${d2}%) scale(1, ${e4});`;
    }
    const m = i2 ? p2.effectiveMinSegmentElement : p2.effectiveMaxSegmentElement, _ = this.classes(p2.segmentElement, p2.effectiveSegmentElement, m);
    return n2("div", { afterCreate: this._afterEffectiveSegmentCreate, afterRemoved: this._afterEffectiveSegmentRemoved, bind: this, class: _, style: c2, "touch-action": "none" });
  }
  renderAnchorElements() {
    const { trackElement: e3, values: t2 } = this;
    if (t2 && t2.length)
      return this._zIndices = t2.map((e4, i2) => {
        const n3 = this._positionFromValue(e4), s5 = this._positionToPercent(n3), o2 = (this._isHorizontalLayout() ? s5 > 50 : s5 < 50) ? -1 : 1;
        return this._zIndexOffset + (t2.length + o2 * i2);
      }), e3 && t2 && t2.length ? t2.map((e4, t3) => this.renderAnchorElement(e4, t3)) : null;
  }
  renderAnchorElement(e3, t2) {
    const i2 = this._positionFromValue(e3), s5 = this._valueFromPosition(i2);
    if (t(s5) || isNaN(s5))
      return;
    const { _dragStartInfo: o2, _lastMovedHandleIndex: r2, id: a, layout: l2, values: h, visibleElements: { labels: d2 } } = this, c2 = o2 && o2.index === t2, m = r2 === t2, v2 = this.classes(p2.anchorElement, p2.anchorElementIndexPrefix + t2, c2 ? p2.movingAnchorElement : null, m ? p2.lastMovedAnchorElement : null), g3 = this.labels.values[t2], f2 = this._getStyleForAnchor(e3, t2, c2 || m), { min: b2, max: E2 } = this.viewModel.getBoundsForValueAtIndex(t2), { disabled: x, messages: k } = this, y2 = 2 === h.length ? s4(0 === t2 ? k.rangeMinimum : k.rangeMaximum, { value: e3 }) : g3, I = 1 === h.length ? null : 0 === t2 ? `${a}-handle-${t2 + 1}` : t2 === h.length - 1 ? `${a}-handle-${t2 - 1}` : `${a}-handle-${t2 - 1} ${a}-handle-${t2 + 1}`;
    return n2("div", { afterCreate: this._afterAnchorCreate, afterUpdate: this._afterAnchorUpdate, afterRemoved: this._afterAnchorRemoved, "aria-controls": I, "aria-label": k.sliderValue, "aria-labelledby": d2 ? `${a}-label-${t2}` : null, "aria-orientation": l2, "aria-valuemax": E2.toString(), "aria-valuemin": b2.toString(), "aria-valuenow": e3.toString(), "aria-valuetext": y2, bind: this, class: v2, "data-thumb-index": t2, "data-value": e3, id: `${a}-handle-${t2}`, key: `${a}-handle-${t2}`, onkeydown: this._onAnchorKeyDown, "touch-action": "none", role: "slider", style: f2, tabIndex: x ? -1 : 0 }, n2("span", { afterCreate: this._afterThumbCreate, afterRemoved: this._afterThumbRemoved, bind: this, class: p2.thumbElement, "data-thumb-index": t2, "touch-action": "none" }), this.renderThumbLabel(t2));
  }
  renderThumbLabel(e3) {
    const { id: t2, labels: i2, labelInputsEnabled: n3, state: s5 } = this, o2 = this.visibleElements.labels, r2 = i2.values[e3], a = this.classes(p2.labelElement, o2 ? null : p2.hidden, n3 && "disabled" !== s5 ? p2.labelElementInteractive : null);
    return n2("span", { afterCreate: this._afterLabelCreate, afterRemoved: this._afterLabelRemoved, "aria-hidden": (!o2).toString(), bind: this, class: a, "data-thumb-index": e3, key: `${t2}-label-${e3}`, id: `${t2}-label-${e3}`, role: n3 ? "button" : null, "touch-action": "none" }, this._activeLabelInputIndex === e3 ? this.renderValueInput(e3) : r2);
  }
  renderValueInput(e3) {
    const { disabled: t2, values: i2 } = this, n3 = i2[e3];
    return n2("input", { key: `value-input-${e3}`, afterCreate: this._afterInputCreate, "aria-label": this.messages.sliderValue, bind: this, class: p2.labelInput, "data-input-type": "thumb", "data-input-index": e3, required: true, tabIndex: t2 ? -1 : 0, type: "text", value: this._formatInputValue(n3, "value", e3), onblur: this._onLabelInputBlur, onkeydown: this._onInputKeyDown });
  }
  renderMax() {
    const { _isMaxInputActive: e3, labels: t2, rangeLabelInputsEnabled: i2, state: n3 } = this, s5 = this.visibleElements.rangeLabels, o2 = this.classes(p2.maxElement, { [p2.hidden]: !s5, [p2.maxElementInteractive]: i2 && "disabled" !== n3, [p2.rangeElementActive]: e3 });
    return n2("div", { "aria-hidden": (!s5).toString(), afterCreate: this._afterMaxLabelCreate, bind: this, class: o2, onclick: this._onMaxLabelClick, onkeydown: this._onMaxLabelKeyDown, role: i2 ? "button" : null, tabIndex: !this.disabled && i2 ? 0 : -1 }, e3 ? this.renderMaxInput() : t2.max);
  }
  renderMin() {
    const { _isMinInputActive: e3, labels: t2, rangeLabelInputsEnabled: i2, state: n3 } = this, s5 = this.visibleElements.rangeLabels, o2 = this.classes(p2.minElement, { [p2.hidden]: !s5, [p2.minElementInteractive]: i2 && "disabled" !== n3, [p2.rangeElementActive]: e3 });
    return n2("div", { "aria-hidden": (!s5).toString(), afterCreate: this._afterMinLabelCreate, bind: this, class: o2, onclick: this._onMinLabelClick, onkeydown: this._onMinLabelKeyDown, role: i2 ? "button" : null, tabIndex: !this.disabled && i2 ? 0 : -1 }, e3 ? this.renderMinInput() : t2.min);
  }
  renderMaxInput() {
    return n2("input", { afterCreate: this._afterInputCreate, "aria-label": this.messages.maximumValue, bind: this, class: p2.rangeInput, "data-input-type": "max", required: true, tabIndex: this.disabled ? -1 : 0, type: "text", value: this._formatInputValue(this.max, "max"), onblur: this._onMaxInputBlur, onkeydown: this._onInputKeyDown });
  }
  renderMinInput() {
    return n2("input", { afterCreate: this._afterInputCreate, "aria-label": this.messages.minimumValue, bind: this, class: p2.rangeInput, "data-input-type": "min", required: true, tabIndex: this.disabled ? -1 : 0, type: "text", value: this._formatInputValue(this.min, "min"), onblur: this._onMinInputBlur, onkeydown: this._onInputKeyDown });
  }
  renderExtraContentElements() {
    return n2("div", { bind: this, class: p2.extraContentElement }, this.extraNodes);
  }
  renderTicksContainer() {
    if (this.tickConfigs && this.trackElement && (0 !== this._trackHeight || 0 !== this._trackWidth))
      return this.tickConfigs.map((e3, t2) => n2("div", { key: "ticks-container", class: this.classes(p2.ticksContainerElement) }, this.renderTicks(e3, t2)));
  }
  renderTicks(e3, i2) {
    const { mode: n3, values: s5 } = e3;
    if (this.tickElements.getItemAt(i2) || this.tickElements.add(new j(), i2), "position" === n3) {
      const t2 = Array.isArray(s5) ? s5 : [s5];
      return this._calculateTickPositions(t2).map((t3, n4) => this.renderTickGroup(e3, n4, i2, t3));
    }
    if ("percent" === n3 && Array.isArray(s5)) {
      const { max: t2, min: n4 } = this, o3 = t2 - n4, r3 = s5.map((e4) => this._applyPrecisionToPosition(e4 / 100 * o3 + n4));
      return this._calculateTickPositions(r3).map((t3, n5) => this.renderTickGroup(e3, n5, i2, t3));
    }
    const o2 = Array.isArray(s5) && s5.length ? s5[0] : isNaN(s5) ? null : s5, r2 = this._getTickCounts(o2, e3);
    return this._calculateEquidistantTickPositions(r2).map((t2, n4) => this.renderTickGroup(e3, n4, i2, t2));
  }
  renderTickGroup(e3, t2, i2, s5) {
    const o2 = "position" === e3.mode ? Array.isArray(e3.values) ? e3.values[t2] : e3.values : this._valueFromPosition(s5);
    if (!t(o2) && !isNaN(o2))
      return n2("div", { afterCreate: this._afterTickGroupCreate, afterRemoved: this._afterTickGroupRemoved, bind: this, "data-config": e3, "data-position": s5, "data-tick-config-index": i2, "data-tick-group-index": t2, "data-value": o2, onclick: this._onTickGroupClick, key: `tick-group-${t2}` }, this.renderTickLine(e3, t2, i2, o2), e3.labelsVisible ? this.renderTickLabel(e3, t2, i2, o2) : null);
  }
  renderTickLine(e3, t2, i2, n3) {
    return n2("div", { afterCreate: this._afterTickLineCreate, "aria-valuenow": n3.toString(), bind: this, class: p2.tickElement, "data-config": e3, "data-tick-config-index": i2, "data-tick-group-index": t2, "data-value": n3, key: `tick-label-${t2}`, style: this._getPositionStyleForElement(n3) });
  }
  renderTickLabel(e3, t2, i2, n3) {
    const s5 = e3.labelFormatFunction ? e3.labelFormatFunction(n3, "tick", t2) : this.viewModel.getLabelForValue(n3, "tick", t2);
    return n2("div", { afterCreate: this._afterTickLabelCreate, "aria-label": s5, "aria-valuenow": n3.toString(), "aria-valuetext": s5, bind: this, class: p2.tickLabelElement, "data-config": e3, "data-tick-config-index": i2, "data-tick-group-index": t2, "data-value": n3, key: `tick-label-${t2}`, style: `transform: translate(-50%); ${this._getPositionStyleForElement(n3)}` }, s5);
  }
  _afterContainerCreate(e3) {
    this.own(g(e3, () => this.scheduleRender()));
  }
  _afterTrackCreate(e3) {
    this._set("trackElement", e3), e3.addEventListener("pointerdown", this._onTrackPointerDown), this.scheduleRender();
  }
  _afterTrackRemoved(e3) {
    e3.removeEventListener("pointerdown", this._onTrackPointerDown), document.removeEventListener("pointermove", this._onTrackPointerMove), document.removeEventListener("pointerup", this._onTrackPointerUp);
  }
  _afterSegmentCreate(e3) {
    this.segmentElements.add(e3), e3.addEventListener("pointerdown", this._onSegmentPointerDown);
  }
  _afterSegmentRemoved(e3) {
    this.segmentElements.remove(e3), e3.removeEventListener("pointerdown", this._onSegmentPointerDown);
  }
  _afterEffectiveSegmentCreate(e3) {
    this.effectiveSegmentElements.add(e3);
  }
  _afterEffectiveSegmentRemoved(e3) {
    this.effectiveSegmentElements.remove(e3);
  }
  _afterAnchorCreate(e3) {
    if (this._anchorElements.push(e3), e3.addEventListener("pointerdown", this._onAnchorPointerDown), this.thumbCreatedFunction) {
      const t2 = e3["data-thumb-index"], i2 = e3["data-value"], n3 = this.thumbElements.getItemAt(t2) || null, s5 = this.labelElements.getItemAt(t2) || null;
      this.thumbCreatedFunction(t2, i2, n3, s5);
    }
  }
  _afterAnchorUpdate(e3) {
    if (r(this._focusedAnchorIndex)) {
      e3["data-thumb-index"] === this._focusedAnchorIndex && (e3.focus(), this._focusedAnchorIndex = null);
    }
  }
  _afterAnchorRemoved(e3) {
    const t2 = this._anchorElements.indexOf(e3, 0);
    t2 > -1 && this._anchorElements.splice(t2, 1), e3.removeEventListener("pointerdown", this._onAnchorPointerDown);
  }
  _afterThumbCreate(e3) {
    this.thumbElements.add(e3);
  }
  _afterThumbRemoved(e3) {
    this.thumbElements.remove(e3);
  }
  _afterLabelCreate(e3) {
    this.labelElements.add(e3), e3.addEventListener("pointerdown", this._onLabelPointerDown), e3.addEventListener("pointerup", this._onLabelPointerUp);
  }
  _afterLabelRemoved(e3) {
    this.labelElements.remove(e3), e3.removeEventListener("pointerdown", this._onLabelPointerDown), e3.removeEventListener("pointerup", this._onLabelPointerUp);
  }
  _afterInputCreate(e3) {
    if (e3.focus(), e3.select(), this.inputCreatedFunction) {
      const t2 = e3.getAttribute("data-input-type"), i2 = "thumb" === t2 ? e3["data-input-index"] : null;
      this.inputCreatedFunction(e3, t2, i2);
    }
  }
  _afterTickLineCreate(e3) {
    const t2 = e3["data-tick-config-index"], i2 = e3["data-tick-group-index"], n3 = this.tickElements.getItemAt(t2);
    n3.getItemAt(i2) ? n3.getItemAt(i2).tickElement = e3 : n3.add({ groupElement: null, tickElement: e3, labelElement: null }, i2);
  }
  _afterTickLabelCreate(e3) {
    const t2 = e3["data-tick-config-index"], i2 = e3["data-tick-group-index"], n3 = this.tickElements.getItemAt(t2);
    n3.getItemAt(i2) ? n3.getItemAt(i2).labelElement = e3 : n3.add({ groupElement: null, labelElement: e3, tickElement: null }, i2);
  }
  _afterTickGroupRemoved(e3) {
    const t2 = e3["data-tick-config-index"], i2 = this.tickElements.items[t2], n3 = i2 == null ? void 0 : i2.find((t3) => t3.groupElement === e3);
    n3 && i2.remove(n3);
  }
  _afterTickGroupCreate(e3) {
    var _a, _b;
    const t2 = e3["data-config"];
    if (t2 && t2.tickCreatedFunction) {
      const i2 = e3["data-tick-config-index"], n3 = e3["data-tick-group-index"], s5 = e3["data-value"], o2 = (_b = (_a = this.tickElements) == null ? void 0 : _a.getItemAt(i2)) == null ? void 0 : _b.getItemAt(n3);
      if (o2) {
        o2.groupElement = e3;
        const i3 = o2.tickElement || null, n4 = o2.labelElement || null;
        t2.tickCreatedFunction(s5, i3, n4);
      }
    }
  }
  _afterMaxLabelCreate(e3) {
    this._set("maxLabelElement", e3);
  }
  _afterMinLabelCreate(e3) {
    this._set("minLabelElement", e3);
  }
  _onAnchorKeyDown(e3) {
    if (this._isDisabled() || "editing" === this.state)
      return;
    const { target: t2 } = e3, n3 = i(e3), { _anchorElements: o2, values: r2 } = this, a = t2["data-thumb-index"], l2 = o2[a], h = r2[a], d2 = [v.moveAnchorUp, v.moveAnchorDown, v.moveAnchorLeft, v.moveAnchorRight];
    if (n3 === v.showInput && this.labelInputsEnabled)
      this._activeLabelInputIndex = a, this.notifyChange("state");
    else if (d2.includes(n3)) {
      e3.preventDefault();
      const { steps: t3 } = this, i2 = n3 === v.moveAnchorUp || n3 === v.moveAnchorRight ? 1 : -1;
      if (r(t3))
        this._toStep(a, this._isReversedLayout() ? -1 * i2 : i2);
      else {
        const { precision: e4 } = this, t4 = this._getPositionOfElement(l2), n4 = this._valueFromPosition(t4), s5 = this._isHorizontalLayout() ? i2 : -1 * i2;
        let o4;
        o4 = 0 === e4 ? this._positionFromValue(n4 + s5) : 1 === e4 ? this._positionFromValue(n4 + 0.1 * s5) : t4 + s5, this._toPosition(a, o4);
      }
      const o3 = this.values[a];
      h !== o3 && this._emitThumbChangeEvent({ index: a, oldValue: h, value: o3 });
    } else if (n3 === v.moveAnchorToMax || n3 === v.moveAnchorToMin) {
      e3.preventDefault();
      const { min: t3, max: i2 } = this._getAnchorBoundsInPixels(a), s5 = this._isPositionInverted() ? n3 === v.moveAnchorToMax ? t3 : i2 : n3 === v.moveAnchorToMin ? t3 : i2;
      this._toPosition(a, s5);
      const o3 = this.values[a];
      h !== o3 && this._emitThumbChangeEvent({ index: a, oldValue: h, value: o3 });
    }
  }
  _onAnchorPointerDown(e3) {
    if (this._isDisabled())
      return;
    const { target: t2, clientX: i2, clientY: n3 } = e3, s5 = t2["data-thumb-index"];
    void 0 !== s5 && (e3.preventDefault(), this._anchorElements[s5] && this._anchorElements[s5].focus(), this._storeTrackDimensions(), this._dragStartInfo = { clientX: i2, clientY: n3, index: s5, position: this._getPositionOfElement(this._anchorElements[s5]) }, this.notifyChange("state"), document.addEventListener("pointerup", this._onAnchorPointerUp), document.addEventListener("pointermove", this._onAnchorPointerMove));
  }
  _onAnchorPointerMove(e3) {
    if ("editing" === this.state || !this._dragStartInfo)
      return;
    e3.preventDefault();
    const { values: t2, _anchorElements: i2, _dragged: n3, _dragStartInfo: s5, _dragStartInfo: { index: o2, position: r2 } } = this, { clientX: a, clientY: l2 } = e3, h = n3 ? "drag" : "start", d2 = i2[o2], c2 = this._getPositionOfElement(d2), m = this._applyPrecisionToPosition(this._isHorizontalLayout() ? r2 + a - s5.clientX : r2 + l2 - s5.clientY);
    if (c2 === m)
      return;
    const u2 = t2[o2];
    this._dragged = true, this._toPosition(o2, m);
    const _ = this.values[o2];
    n3 ? u2 !== _ && this._emitThumbDragEvent({ index: o2, state: h, value: _ }) : this._emitThumbDragEvent({ index: o2, state: h, value: u2 });
  }
  _onAnchorPointerUp(e3) {
    if (document.removeEventListener("pointerup", this._onAnchorPointerUp), document.removeEventListener("pointermove", this._onAnchorPointerMove), !this._dragStartInfo)
      return;
    e3.preventDefault();
    const { index: t2 } = this._dragStartInfo, i2 = this._dragged, n3 = this.values[t2];
    this._dragged = false, this._dragStartInfo = null, this._lastMovedHandleIndex = t2, this.notifyChange("state"), i2 ? this._emitThumbDragEvent({ index: t2, state: "stop", value: n3 }) : (this.scheduleRender(), "editing" !== this.state && this._emitThumbClickEvent({ index: t2, value: n3 }));
  }
  _onTrackPointerDown(e3) {
    const { _dragStartInfo: t2, snapOnClickEnabled: i2, state: o2, values: r2 } = this;
    if (this._isDisabled() || "editing" === o2 || t2)
      return;
    if (document.addEventListener("pointermove", this._onTrackPointerMove), document.addEventListener("pointerup", this._onTrackPointerUp), !i2 || !r2.length)
      return;
    const { steps: a } = this, { clientX: l2, clientY: h } = e3, d2 = this._getCursorPositionFromEvent(e3), c2 = this._valueFromPosition(d2), m = this._getIndexOfNearestValue(c2), u2 = r2[m], _ = r2.some((e4, t3) => e4 === u2 && t3 !== m) && c2 > u2 ? this.values.lastIndexOf(u2) : m;
    if (t(_))
      return;
    const p3 = r2[_], v2 = r(a) ? this._calculateNearestStepPosition(d2) : d2;
    this._toPosition(_, v2), this._dragged = true, this._dragStartInfo = { clientX: l2, clientY: h, index: _, position: v2 }, this._focusedAnchorIndex = _, this.notifyChange("state"), this._emitThumbDragEvent({ index: _, state: "start", value: p3 });
    const g3 = this.values[_];
    p3 !== g3 && this._emitThumbDragEvent({ index: _, state: "drag", value: g3 }), document.addEventListener("pointerup", this._onAnchorPointerUp), document.addEventListener("pointermove", this._onAnchorPointerMove);
  }
  _onTrackPointerMove(e3) {
    e3.preventDefault(), this._dragged = true;
  }
  _onTrackPointerUp(e3) {
    if (e3.preventDefault(), document.removeEventListener("pointermove", this._onTrackPointerMove), document.removeEventListener("pointerup", this._onTrackPointerUp), this.snapOnClickEnabled || (this._dragged = false), !this._dragged) {
      const t2 = this._getCursorPositionFromEvent(e3), i2 = this._valueFromPosition(t2);
      this._emitTrackClickEvent({ value: i2 });
    }
  }
  _onSegmentPointerDown(e3) {
    var _a, _b;
    e3.preventDefault();
    const t2 = e3.target, i2 = t2["data-segment-index"], s5 = t2["data-min-thumb-index"], o2 = t2["data-max-thumb-index"];
    if (this._isDisabled() || t(s5) || t(o2))
      return;
    e3.stopPropagation(), this._storeTrackDimensions(), document.addEventListener("pointerup", this._onSegmentPointerUp);
    const r2 = this._getAnchorDetails(s5), a = this._getAnchorDetails(o2);
    this.syncedSegmentsEnabled ? (this.segmentElements.forEach((e4) => e4.classList.add(p2.segmentElementActive)), this._anchorElements.forEach((e4) => e4.classList.add(p2.anchorElementActive))) : (this.segmentElements.getItemAt(i2).classList.add(p2.segmentElementActive), (_a = this._anchorElements[r2.index]) == null ? void 0 : _a.classList.add(p2.anchorElementActive), (_b = this._anchorElements[a.index]) == null ? void 0 : _b.classList.add(p2.anchorElementActive)), this._segmentDragStartInfo = { cursorPosition: this._getCursorPositionFromEvent(e3), index: i2, details: this._normalizeSegmentDetails({ min: r2, max: a }) }, this.draggableSegmentsEnabled && (document.addEventListener("pointermove", this._onSegmentPointerMove), this.notifyChange("state"), this._emitSegmentDragEvent({ index: i2, state: "start", thumbIndices: [s5, o2] }));
  }
  _onSegmentPointerMove(e3) {
    if (!this._segmentDragStartInfo)
      return;
    e3.preventDefault();
    const { _trackHeight: t2, _trackWidth: i2, _segmentDragStartInfo: { index: n3, cursorPosition: s5, details: { min: o2, max: r2 } } } = this, { index: a, position: l2, value: h } = o2, { index: d2, position: c2, value: m } = r2;
    this._dragged = true;
    const u2 = this._getCursorPositionFromEvent(e3);
    if (u2 === s5)
      return;
    const _ = this._positionToPercent(s5), p3 = this._positionToPercent(u2) - _, v2 = this._positionToPercent(l2) + p3, g3 = this._positionToPercent(c2) + p3, { min: f2 } = this._getAnchorBoundsAsPercents(a), { max: b2 } = this._getAnchorBoundsAsPercents(d2);
    let E2 = false, x = false;
    if (v2 < f2 ? E2 = true : g3 > b2 && (x = true), E2) {
      const { min: e4, max: t3 } = this.viewModel.getBoundsForValueAtIndex(a), i3 = this._isPositionInverted() ? t3 : e4, n4 = i3, s6 = m + (i3 - h), o3 = s6 - this.values[d2];
      return void (this.syncedSegmentsEnabled ? this._updateAnchorValuesByDifference(o3) : this._updateAnchorValues([a, d2], [n4, s6]));
    }
    if (x) {
      const { min: e4, max: t3 } = this.viewModel.getBoundsForValueAtIndex(d2), i3 = this._isPositionInverted() ? e4 : t3, n4 = i3, s6 = h + (i3 - m), o3 = s6 - this.values[a];
      return void (this.syncedSegmentsEnabled ? this._updateAnchorValuesByDifference(o3) : this._updateAnchorValues([a, d2], [s6, n4]));
    }
    const k = this._isHorizontalLayout() ? i2 : t2, y2 = g3 / 100 * k, I = v2 / 100 * k, P = this.values, A = [P[a], P[d2]], L = this._getValueForAnchorAtPosition(a, I), S = this._getValueForAnchorAtPosition(d2, y2);
    this.syncedSegmentsEnabled ? this._updateAnchorValuesByDifference(L - A[0]) : this._updateAnchorValues([a, d2], [L, S]);
    [this.values[a], this.values[d2]].every((e4, t3) => e4 === A[t3]) || this._emitSegmentDragEvent({ index: n3, state: "drag", thumbIndices: [a, d2] });
  }
  _onSegmentPointerUp(e3) {
    if (e3.preventDefault(), document.removeEventListener("pointerup", this._onSegmentPointerUp), document.removeEventListener("pointermove", this._onSegmentPointerMove), !this._segmentDragStartInfo)
      return;
    const { _dragged: t2, max: i2, min: n3, values: s5 } = this, { index: o2, details: { min: { index: r2 }, max: { index: a } } } = this._segmentDragStartInfo;
    if (this.segmentElements.forEach((e4) => e4.classList.remove(p2.segmentElementActive)), this._anchorElements.forEach((e4) => e4.classList.remove(p2.anchorElementActive)), this.draggableSegmentsEnabled) {
      const e4 = i2 - n3, t3 = s5[r2], l2 = s5[a];
      this._lastMovedHandleIndex = t3 === l2 ? t3 > e4 / 2 ? r2 : a : null, this._dragged = false, this._segmentDragStartInfo = null, this.notifyChange("state"), this._emitSegmentDragEvent({ index: o2, state: "stop", thumbIndices: [r2, a] });
    }
    if (!t2) {
      const t3 = this._getCursorPositionFromEvent(e3), i3 = this._valueFromPosition(t3);
      this._emitSegmentClickEvent({ index: o2, value: i3, thumbIndices: [r2, a] });
    }
  }
  _onTickGroupClick(e3) {
    const t2 = e3.target;
    if (t2["data-config"]) {
      const e4 = t2["data-tick-config-index"], i2 = t2["data-tick-group-index"], n3 = t2["data-value"];
      this._emitTickClickEvent({ configIndex: e4, groupIndex: i2, value: n3 });
    }
  }
  _storeTrackDimensions() {
    if (this.trackElement) {
      const e3 = this._getDimensions(this.trackElement);
      this._trackHeight = e3.height, this._trackWidth = e3.width;
    }
  }
  _onLabelPointerDown() {
    this._isDisabled() || (this._dragged = false, document.addEventListener("pointerup", this._onAnchorPointerUp), document.addEventListener("pointermove", this._onAnchorPointerMove));
  }
  _onLabelPointerMove() {
    this._isDisabled() || (this._dragged = true);
  }
  _onLabelPointerUp(e3) {
    if (this._isDisabled())
      return;
    const t2 = e3.target["data-thumb-index"];
    this.labelInputsEnabled && !this._dragged && r(t2) && (this._activeLabelInputIndex = t2), this._dragged = false, this.notifyChange("state"), document.removeEventListener("pointerup", this._onLabelPointerUp), document.removeEventListener("pointermove", this._onLabelPointerMove);
  }
  _onLabelInputBlur(e3) {
    const { _activeLabelInputIndex: t2, values: i2, viewModel: n3 } = this, s5 = e3.target.value;
    if (this._activeLabelInputIndex = null, this.notifyChange("state"), !s5)
      return;
    const o2 = this._parseInputValue(s5, "value", t2), r2 = i2[t2], { min: a, max: l2 } = this.viewModel.getBoundsForValueAtIndex(t2);
    if (o2 < a || o2 > l2)
      return;
    n3.setValue(t2, o2);
    const h = this.values[t2];
    r2 !== h && this._emitThumbChangeEvent({ index: t2, oldValue: r2, value: h });
  }
  _onInputKeyDown(e3) {
    if (this._isDisabled())
      return;
    const { target: t2 } = e3, n3 = i(e3), { hideInput1: o2, hideInput2: r2, hideInput3: a } = v, { _activeLabelInputIndex: l2, _anchorElements: h } = this, d2 = t2;
    if (n3 === o2 || n3 === r2 || n3 === a) {
      e3.stopPropagation();
      const t3 = l2;
      d2.blur(), r(t3) ? h[t3].focus() : d2.parentElement.focus();
    }
  }
  _onMaxLabelClick() {
    this._isDisabled() || (this._emitRangeLabelClickEvent({ type: "max-click", value: this.max }), this.rangeLabelInputsEnabled && (this._isMaxInputActive = true, this.notifyChange("state")));
  }
  _onMaxLabelKeyDown(e3) {
    this._isDisabled() || i(e3) !== v.showInput || (this._isMaxInputActive = true, this.notifyChange("state"));
  }
  _onMaxInputBlur(e3) {
    const t2 = e3.target.value;
    if (this._isMaxInputActive = false, this.notifyChange("state"), !t2)
      return;
    const i2 = this.max, n3 = this._parseInputValue(t2, "max");
    n3 <= this.min || (this.viewModel.set("max", n3), this.max !== i2 && this._emitMaxChangeEvent({ oldValue: i2, value: this.max }));
  }
  _onMinLabelClick() {
    this._isDisabled() || (this._emitRangeLabelClickEvent({ type: "min-click", value: this.min }), this.rangeLabelInputsEnabled && (this._isMinInputActive = true, this.notifyChange("state")));
  }
  _onMinLabelKeyDown(e3) {
    this._isDisabled() || i(e3) !== v.showInput || (this._isMinInputActive = true, this.notifyChange("state"));
  }
  _onMinInputBlur(e3) {
    const t2 = e3.target.value;
    if (this._isMinInputActive = false, this.notifyChange("state"), !t2)
      return;
    const i2 = this.min, n3 = this._parseInputValue(t2, "min");
    n3 >= this.max || (this.viewModel.set("min", n3), this.min !== i2 && this._emitMinChangeEvent({ oldValue: i2, value: this.min }));
  }
  _isDisabled() {
    return this.disabled || "disabled" === this.state;
  }
  _positionFromValue(e3) {
    const { max: t2, min: i2 } = this, n3 = t2 - i2;
    if (0 === n3)
      return 0;
    const { _trackHeight: s5, _trackWidth: o2 } = this, r2 = this._isHorizontalLayout();
    let a = r2 ? parseFloat((o2 * (e3 - i2) / n3).toFixed(2)) : parseFloat((s5 * (t2 - e3) / n3).toFixed(2));
    return this._isReversedLayout() && (a = r2 ? o2 - a : s5 - a), a;
  }
  _valueFromPosition(e3) {
    const { _trackHeight: t2, _trackWidth: i2, max: n3, min: s5, precision: o2 } = this, r2 = n3 - s5;
    let a = this._isHorizontalLayout() ? e3 * r2 / i2 + s5 : r2 * (1e3 - e3 / t2 * 1e3) / 1e3 + s5;
    return this._isReversedLayout() && (a = n3 + s5 - a), parseFloat(a.toFixed(o2));
  }
  _positionToPercent(e3) {
    const { _trackHeight: t2, _trackWidth: i2 } = this, n3 = 100 * e3 / (this._isHorizontalLayout() ? i2 : t2);
    return this._applyPrecisionToPosition(n3);
  }
  _applyPrecisionToPosition(e3) {
    return parseFloat(e3.toFixed(this._positionPrecision));
  }
  _isPositionInverted() {
    const { layout: e3 } = this;
    return "horizontal-reversed" === e3 || "vertical" === e3;
  }
  _isHorizontalLayout() {
    return this.layout.includes("horizontal");
  }
  _isReversedLayout() {
    return this.layout.includes("reversed");
  }
  _normalizeSegmentDetails(e3) {
    if (this._isPositionInverted()) {
      const { min: t2, max: i2 } = e3;
      return { min: i2, max: t2 };
    }
    return e3;
  }
  _parseInputValue(e3, t2, i2) {
    return this.inputParseFunction ? this.inputParseFunction(e3, t2, i2) : this.viewModel.defaultInputParseFunction(e3);
  }
  _formatInputValue(e3, t2, i2) {
    return this.inputFormatFunction ? this.inputFormatFunction(e3, t2, i2) : this.viewModel.defaultInputFormatFunction(e3);
  }
  _getAnchorDetails(e3) {
    const t2 = [...this.values].sort((e4, t3) => e4 - t3)[e3], i2 = this.values.indexOf(t2);
    return { index: i2, position: this._getPositionOfElement(this._anchorElements[i2]), value: t2 };
  }
  _updateAnchorStyle(e3, t2) {
    const i2 = this._anchorElements[e3];
    i2 && (this._isHorizontalLayout() ? i2.style.left = `${t2}` : i2.style.top = `${t2}`);
  }
  _getStyleForAnchor(e3, t2, i2) {
    const n3 = this._getPositionStyleForElement(e3);
    if (1 === this.values.length)
      return `${n3}`;
    const s5 = this._zIndices[t2];
    return `${n3}; z-index: ${i2 ? this._zIndexOffset + s5 : s5}`;
  }
  _getPositionStyleForElement(e3) {
    const t2 = this._positionFromValue(e3), i2 = this._positionToPercent(t2);
    return `${this._isHorizontalLayout() ? "left" : "top"}: ${i2 + "%"}`;
  }
  _getPositionOfElement(e3) {
    const t2 = this._getDimensions(e3.offsetParent), i2 = this._getDimensions(e3);
    return this._isHorizontalLayout() ? this._applyPrecisionToPosition(i2.left - t2.left) : this._applyPrecisionToPosition(i2.top - t2.top);
  }
  _updateAnchorValues(e3, t2) {
    e3.forEach((e4, i2) => this._toValue(e4, t2[i2]));
  }
  _updateAnchorValuesByDifference(e3) {
    const { min: t2, max: i2, values: n3 } = this;
    n3.forEach((n4, s5) => this._toValue(s5, Math.max(Math.min(n4 + e3, i2), t2)));
  }
  _toValue(e3, t2) {
    if (r(this.steps)) {
      t2 = this._getStepValues()[this._getIndexOfNearestStepValue(t2)];
    }
    this._updateAnchorStyle(e3, this._getPositionStyleForElement(t2)), this.viewModel.setValue(e3, t2);
  }
  _toPosition(e3, t2) {
    const i2 = r(this.steps) ? this._getStepValueForAnchorAtPosition(e3, t2) : this._getValueForAnchorAtPosition(e3, t2);
    this._updateAnchorStyle(e3, this._getPositionStyleForElement(i2)), this.viewModel.setValue(e3, i2);
  }
  _getValueForAnchorAtPosition(e3, t2) {
    const { min: i2, max: n3 } = this._getAnchorBoundsInPixels(e3), { min: s5, max: o2 } = this.viewModel.getBoundsForValueAtIndex(e3);
    let r2, a, l2 = null;
    return this._isPositionInverted() ? (r2 = s5, a = o2) : (r2 = o2, a = s5), l2 = t2 > n3 ? r2 : t2 < i2 ? a : this._valueFromPosition(t2), l2 > o2 ? l2 = o2 : l2 < s5 && (l2 = s5), l2;
  }
  _getStepValueForAnchorAtPosition(e3, t2) {
    const i2 = this._getStepValues(), n3 = this._calculateNearestStepPosition(t2), s5 = this._getValueForAnchorAtPosition(e3, n3);
    return i2[this._getIndexOfNearestStepValue(s5)];
  }
  _getAnchorBoundsAsPercents(e3) {
    const { min: t2, max: i2 } = this._getAnchorBoundsInPixels(e3);
    return { min: this._positionToPercent(t2), max: this._positionToPercent(i2) };
  }
  _getAnchorBoundsInPixels(e3) {
    const { _anchorElements: t2, _trackHeight: i2, _trackWidth: n3, effectiveMax: o2, effectiveMin: r2, thumbsConstrained: a } = this, l2 = t2[e3 - 1], h = t2[e3 + 1], d2 = this._isHorizontalLayout() ? n3 : i2;
    let c2, m;
    return this._isPositionInverted() ? (c2 = r(r2) ? this._positionFromValue(r2) : d2, m = r(o2) ? this._positionFromValue(o2) : 0) : (c2 = r(o2) ? this._positionFromValue(o2) : d2, m = r(r2) ? this._positionFromValue(r2) : 0), a ? this._isPositionInverted() ? { max: l2 ? this._getPositionOfElement(l2) : c2, min: h ? this._getPositionOfElement(h) : m } : { max: h ? this._getPositionOfElement(h) : c2, min: l2 ? this._getPositionOfElement(l2) : m } : { max: c2, min: m };
  }
  _getIndexOfNearestValue(e3) {
    return this.values.indexOf(this.values.reduce((t2, i2) => Math.abs(i2 - e3) < Math.abs(t2 - e3) ? i2 : t2));
  }
  _getCursorPositionFromEvent(e3) {
    const t2 = this._getDimensions(this.trackElement);
    return this._isHorizontalLayout() ? e3.clientX - t2.left : e3.clientY - t2.top;
  }
  _getStepValues() {
    const { steps: e3 } = this;
    if (Array.isArray(e3))
      return e3;
    const { max: t2, min: i2 } = this, n3 = Math.ceil((t2 - i2) / e3), s5 = [];
    for (let o2 = 0; o2 <= n3; o2++) {
      const n4 = i2 + e3 * o2;
      s5.push(n4 > t2 ? t2 : n4);
    }
    return s5;
  }
  _toStep(e3, t2) {
    const { values: i2, viewModel: n3 } = this, s5 = i2[e3], o2 = this._getStepValues(), r2 = o2.indexOf(s5);
    let a = null;
    if (r2 > -1) {
      let i3 = o2[r2 + t2];
      isNaN(i3) && (i3 = o2[r2]);
      const n4 = this._positionFromValue(i3);
      a = this._getStepValueForAnchorAtPosition(e3, n4);
    } else {
      a = o2[this._getIndexOfNearestStepValue(s5) + t2];
    }
    n3.setValue(e3, a);
  }
  _getIndexOfNearestStepValue(e3) {
    const { steps: t2 } = this;
    if (t(t2))
      return null;
    const i2 = this._getStepValues(), s5 = i2.reduce((t3, i3) => Math.abs(i3 - e3) < Math.abs(t3 - e3) ? i3 : t3);
    return i2.indexOf(s5);
  }
  _calculateNearestStepPosition(e3) {
    const t2 = this._valueFromPosition(e3), i2 = this._getIndexOfNearestStepValue(t2), n3 = this._getStepValues();
    return this._positionFromValue(n3[i2]);
  }
  _getTickCounts(e3, t2) {
    const { mode: i2 } = t2;
    return "count" === i2 || "position" === i2 ? e3 || 0 : "percent" === i2 && 100 / e3 || 0;
  }
  _calculateTickPositions(e3) {
    return e3.map((e4) => this._positionFromValue(e4));
  }
  _calculateEquidistantTickPositions(e3) {
    const { _trackWidth: t2, _trackHeight: i2 } = this, n3 = this._isHorizontalLayout() ? t2 : i2, s5 = n3 / (e3 - 1), o2 = [];
    if (1 === e3)
      return [n3 / 2];
    for (let r2 = 0; r2 < e3; r2++) {
      const e4 = r2 * s5;
      e4 <= n3 && o2.push(e4);
    }
    return o2;
  }
  _getDimensions(e3) {
    try {
      return e3.getBoundingClientRect();
    } catch (t2) {
      if ("object" == typeof t2 && null !== t2)
        return new DOMRect(0, 0, 0, 0);
      throw t2;
    }
  }
  _emitTrackClickEvent(e3) {
    this.emit("track-click", { ...e3, type: "track-click" });
  }
  _emitTickClickEvent(e3) {
    this.emit("tick-click", { ...e3, type: "tick-click" });
  }
  _emitMaxChangeEvent(e3) {
    this.emit("max-change", { ...e3, type: "max-change" });
  }
  _emitMinChangeEvent(e3) {
    this.emit("min-change", { ...e3, type: "min-change" });
  }
  _emitThumbChangeEvent(e3) {
    this.emit("thumb-change", { ...e3, type: "thumb-change" });
  }
  _emitThumbClickEvent(e3) {
    this.emit("thumb-click", { ...e3, type: "thumb-click" });
  }
  _emitThumbDragEvent(e3) {
    this.emit("thumb-drag", { ...e3, type: "thumb-drag" });
  }
  _emitSegmentClickEvent(e3) {
    this.emit("segment-click", { ...e3, type: "segment-click" });
  }
  _emitSegmentDragEvent(e3) {
    this.emit("segment-drag", { ...e3, type: "segment-drag" });
  }
  _emitRangeLabelClickEvent(e3) {
    this.emit(e3.type, { ...e3 });
  }
};
e([d()], b.prototype, "disabled", void 0), e([d()], b.prototype, "draggableSegmentsEnabled", void 0), e([o("viewModel.effectiveMax")], b.prototype, "effectiveMax", void 0), e([o("viewModel.effectiveMin")], b.prototype, "effectiveMin", void 0), e([d({ readOnly: true })], b.prototype, "effectiveSegmentElements", void 0), e([d()], b.prototype, "extraNodes", void 0), e([d()], b.prototype, "inputCreatedFunction", void 0), e([o("viewModel.inputFormatFunction")], b.prototype, "inputFormatFunction", void 0), e([o("viewModel.inputParseFunction")], b.prototype, "inputParseFunction", void 0), e([d({ aliasOf: { source: "messages.widgetLabel", overridable: true } })], b.prototype, "label", void 0), e([d({ readOnly: true })], b.prototype, "labelElements", void 0), e([d()], b.prototype, "labelInputsEnabled", void 0), e([o("viewModel.labelFormatFunction")], b.prototype, "labelFormatFunction", void 0), e([o("viewModel.labels")], b.prototype, "labels", void 0), e([d({ value: "horizontal" })], b.prototype, "layout", null), e([o("viewModel.max")], b.prototype, "max", void 0), e([d({ readOnly: true })], b.prototype, "maxLabelElement", void 0), e([d(), e2("esri/widgets/Slider/t9n/Slider")], b.prototype, "messages", void 0), e([o("viewModel.min")], b.prototype, "min", void 0), e([d({ readOnly: true })], b.prototype, "minLabelElement", void 0), e([o("viewModel.precision")], b.prototype, "precision", void 0), e([d()], b.prototype, "rangeLabelInputsEnabled", void 0), e([d({ readOnly: true })], b.prototype, "segmentElements", void 0), e([d()], b.prototype, "snapOnClickEnabled", void 0), e([d({ readOnly: true })], b.prototype, "state", null), e([d()], b.prototype, "steps", void 0), e([d()], b.prototype, "syncedSegmentsEnabled", void 0), e([o("viewModel.thumbsConstrained")], b.prototype, "thumbsConstrained", void 0), e([d()], b.prototype, "thumbCreatedFunction", void 0), e([d({ readOnly: true })], b.prototype, "thumbElements", void 0), e([d()], b.prototype, "tickConfigs", null), e([d({ readOnly: true })], b.prototype, "tickElements", void 0), e([d({ readOnly: true })], b.prototype, "trackElement", void 0), e([o("viewModel.values")], b.prototype, "values", void 0), e([d()], b.prototype, "viewModel", void 0), e([d()], b.prototype, "visibleElements", void 0), e([s3("visibleElements")], b.prototype, "castVisibleElements", null), b = e([n(g2)], b);
var E = b;
export {
  E as default
};
//# sourceMappingURL=@arcgis_core_widgets_Slider.js.map
