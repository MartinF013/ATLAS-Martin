import {
  i
} from "./chunk-HXGHH25J.js";
import {
  M as M3,
  V,
  k
} from "./chunk-B5VZTE6L.js";
import {
  S,
  U as U2,
  m as m2
} from "./chunk-3SB6OSK7.js";
import {
  m,
  p,
  u2 as u3
} from "./chunk-I2XAFJCJ.js";
import {
  C,
  M as M2,
  U,
  u,
  u2
} from "./chunk-YRAX326I.js";
import "./chunk-HB4HVKJV.js";
import {
  s2 as s
} from "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import "./chunk-5N3FSR63.js";
import "./chunk-C4LU7RDX.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import {
  M
} from "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  e,
  r
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var O = class {
  convertVectorFieldData(e2) {
    const t = u.fromJSON(e2.pixelBlock), o = m(t, e2.type);
    return Promise.resolve(r(o) && o.toJSON());
  }
  async decode(r2) {
    const e2 = await S(r2.data, r2.options);
    return e2 && e2.toJSON();
  }
  symbolize(e2) {
    e2.pixelBlock = u.fromJSON(e2.pixelBlock), e2.extent = e2.extent ? M.fromJSON(e2.extent) : null;
    const t = this.symbolizer.symbolize(e2);
    return Promise.resolve(r(t) && t.toJSON());
  }
  async updateSymbolizer(r2) {
    var _a;
    this.symbolizer = U2.fromJSON(r2.symbolizerJSON), r2.histograms && "rasterStretch" === ((_a = this.symbolizer) == null ? void 0 : _a.rendererJSON.type) && (this.symbolizer.rendererJSON.histograms = r2.histograms);
  }
  stretch(e2) {
    const t = this.symbolizer.simpleStretch(u.fromJSON(e2.srcPixelBlock), e2.stretchParams);
    return Promise.resolve(r(t) && t.toJSON());
  }
  estimateStatisticsHistograms(r2) {
    const e2 = m2(u.fromJSON(r2.srcPixelBlock));
    return Promise.resolve(e2);
  }
  split(r2) {
    const e2 = M2(u.fromJSON(r2.srcPixelBlock), r2.tileSize, r2.maximumPyramidLevel);
    return e2 && e2.forEach((r3, t) => {
      e2.set(t, r3 == null ? void 0 : r3.toJSON());
    }), Promise.resolve(e2);
  }
  async mosaicAndTransform(r2) {
    const t = r2.srcPixelBlocks.map((r3) => r3 ? new u(r3) : null), o = u2(t, r2.srcMosaicSize, { blockWidths: r2.blockWidths, alignmentInfo: r2.alignmentInfo, clipOffset: r2.clipOffset, clipSize: r2.clipSize });
    let i2, l = o;
    return r2.coefs && (l = C(o, r2.destDimension, r2.coefs, r2.sampleSpacing, r2.interpolation)), r2.projectDirections && r2.gcsGrid && (i2 = U(r2.destDimension, r2.gcsGrid), l = e(p(l, r2.isUV ? "vector-uv" : "vector-magdir", i2))), { pixelBlock: l == null ? void 0 : l.toJSON(), localNorthDirections: i2 };
  }
  async createFlowMesh(r2, e2) {
    const t = { data: new Float32Array(r2.flowData.buffer), mask: new Uint8Array(r2.flowData.maskBuffer), width: r2.flowData.width, height: r2.flowData.height }, { vertexData: s2, indexData: o } = await u3(r2.meshType, r2.simulationSettings, t, e2.signal);
    return { result: { vertexBuffer: s2.buffer, indexBuffer: o.buffer }, transferList: [s2.buffer, o.buffer] };
  }
  async getProjectionOffsetGrid(r2) {
    const e2 = M.fromJSON(r2.projectedExtent), s2 = M.fromJSON(r2.srcBufferExtent);
    let o = null;
    r2.datumTransformationSteps && (o = new s({ steps: r2.datumTransformationSteps })), (r2.includeGCSGrid || M3(e2.spatialReference, s2.spatialReference, o)) && await k();
    const i2 = r2.rasterTransform ? i(r2.rasterTransform) : null;
    return V({ ...r2, projectedExtent: e2, srcBufferExtent: s2, datumTransformation: o, rasterTransform: i2 });
  }
};
export {
  O as default
};
//# sourceMappingURL=RasterWorker-GXHNZJWN.js.map
