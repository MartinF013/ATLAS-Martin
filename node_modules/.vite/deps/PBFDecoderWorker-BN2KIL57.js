import {
  N,
  j
} from "./chunk-SOZCO2CU.js";
import "./chunk-Z7BSDVJ3.js";
import {
  t as t2
} from "./chunk-ZWMYDR2G.js";
import "./chunk-ZZY5IDKU.js";
import {
  me,
  ne
} from "./chunk-6SWQ7R36.js";
import "./chunk-Z4FD36CT.js";
import "./chunk-OZT6RDST.js";
import {
  o
} from "./chunk-YG6VFATO.js";
import "./chunk-7ZPDA3EC.js";
import {
  y
} from "./chunk-WODSLTZT.js";
import "./chunk-JMZLJZMP.js";
import {
  n
} from "./chunk-P6G64ARX.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-TMBOFNWA.js";
import "./chunk-2HDG7SIE.js";
import "./chunk-56RHM4A6.js";
import "./chunk-EPCCNF3D.js";
import "./chunk-4PRVTUEZ.js";
import "./chunk-DMJWTK32.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import "./chunk-PKZEO23A.js";
import "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import "./chunk-YPZEGNLG.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import {
  e3 as e
} from "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/rest/query/operations/pbfDehydratedFeatureSet.js
function u(t4, e2) {
  return e2;
}
function p(t4, e2, r, o2) {
  switch (r) {
    case 0:
      return m(t4, e2 + o2, 0);
    case 1:
      return "lowerLeft" === t4.originPosition ? m(t4, e2 + o2, 1) : y2(t4, e2 + o2, 1);
  }
}
function d(t4, e2, r, o2) {
  return 2 === r ? m(t4, e2, 2) : p(t4, e2, r, o2);
}
function c(t4, e2, r, o2) {
  return 2 === r ? m(t4, e2, 3) : p(t4, e2, r, o2);
}
function f(t4, e2, r, o2) {
  return 3 === r ? m(t4, e2, 3) : d(t4, e2, r, o2);
}
function m({ translate: t4, scale: e2 }, r, o2) {
  return t4[o2] + r * e2[o2];
}
function y2({ translate: t4, scale: e2 }, r, o2) {
  return t4[o2] - r * e2[o2];
}
var g = class {
  constructor(t4) {
    this.options = t4, this.geometryTypes = ["point", "multipoint", "polyline", "polygon"], this.previousCoordinate = [0, 0], this.transform = null, this.applyTransform = u, this.lengths = [], this.currentLengthIndex = 0, this.toAddInCurrentPath = 0, this.vertexDimension = 0, this.coordinateBuffer = null, this.coordinateBufferPtr = 0, this._attributesConstructor = () => {
    };
  }
  createFeatureResult() {
    return new N();
  }
  finishFeatureResult(t4) {
    if (this.options.applyTransform && (t4.transform = null), this._attributesConstructor = () => {
    }, this.coordinateBuffer = null, this.lengths.length = 0, !t4.hasZ)
      return;
    const r = o(t4.geometryType, this.options.sourceSpatialReference, t4.spatialReference);
    if (!t(r))
      for (const e2 of t4.features)
        r(e2.geometry);
  }
  createSpatialReference() {
    return new k();
  }
  addField(t4, e2) {
    t4.fields.push(y.fromJSON(e2));
    const r = t4.fields.map((t5) => t5.name);
    this._attributesConstructor = function() {
      for (const t5 of r)
        this[t5] = null;
    };
  }
  addFeature(t4, e2) {
    const r = this.options.maxStringAttributeLength ? this.options.maxStringAttributeLength : 0;
    if (r > 0)
      for (const o2 in e2.attributes) {
        const t5 = e2.attributes[o2];
        "string" == typeof t5 && t5.length > r && (e2.attributes[o2] = "");
      }
    t4.features.push(e2);
  }
  addQueryGeometry(t4, e2) {
    const { queryGeometry: r, queryGeometryType: o2 } = e2, s2 = me(r.clone(), r, false, false, this.transform), i = ne(s2, o2, false, false);
    let n2 = null;
    switch (o2) {
      case "esriGeometryPoint":
        n2 = "point";
        break;
      case "esriGeometryPolygon":
        n2 = "polygon";
        break;
      case "esriGeometryPolyline":
        n2 = "polyline";
        break;
      case "esriGeometryMultipoint":
        n2 = "multipoint";
    }
    i.type = n2, t4.queryGeometryType = o2, t4.queryGeometry = i;
  }
  prepareFeatures(e2) {
    switch (this.transform = e2.transform, this.options.applyTransform && e2.transform && (this.applyTransform = this._deriveApplyTransform(e2)), this.vertexDimension = 2, e2.hasZ && this.vertexDimension++, e2.hasM && this.vertexDimension++, e2.geometryType) {
      case "point":
        this.addCoordinate = (t4, e3, r) => this.addCoordinatePoint(t4, e3, r), this.createGeometry = (t4) => this.createPointGeometry(t4);
        break;
      case "polygon":
        this.addCoordinate = (t4, e3, r) => this._addCoordinatePolygon(t4, e3, r), this.createGeometry = (t4) => this._createPolygonGeometry(t4);
        break;
      case "polyline":
        this.addCoordinate = (t4, e3, r) => this._addCoordinatePolyline(t4, e3, r), this.createGeometry = (t4) => this._createPolylineGeometry(t4);
        break;
      case "multipoint":
        this.addCoordinate = (t4, e3, r) => this._addCoordinateMultipoint(t4, e3, r), this.createGeometry = (t4) => this._createMultipointGeometry(t4);
        break;
      case "mesh":
      case "extent":
        break;
      default:
        n(e2.geometryType);
    }
  }
  createFeature() {
    return this.lengths.length = 0, this.currentLengthIndex = 0, this.previousCoordinate[0] = 0, this.previousCoordinate[1] = 0, new j(e(), null, new this._attributesConstructor());
  }
  allocateCoordinates() {
    const t4 = this.lengths.reduce((t5, e2) => t5 + e2, 0);
    this.coordinateBuffer = new Float64Array(t4 * this.vertexDimension), this.coordinateBufferPtr = 0;
  }
  addLength(t4, e2, r) {
    0 === this.lengths.length && (this.toAddInCurrentPath = e2), this.lengths.push(e2);
  }
  createPointGeometry(t4) {
    const e2 = { type: "point", x: 0, y: 0, spatialReference: t4.spatialReference, hasZ: !!t4.hasZ, hasM: !!t4.hasM };
    return e2.hasZ && (e2.z = 0), e2.hasM && (e2.m = 0), e2;
  }
  addCoordinatePoint(t4, e2, r) {
    switch (e2 = this.applyTransform(this.transform, e2, r, 0), r) {
      case 0:
        t4.x = e2;
        break;
      case 1:
        t4.y = e2;
        break;
      case 2:
        t4.hasZ ? t4.z = e2 : t4.m = e2;
        break;
      case 3:
        t4.m = e2;
    }
  }
  _transformPathLikeValue(t4, e2) {
    let r = 0;
    return e2 <= 1 && (r = this.previousCoordinate[e2], this.previousCoordinate[e2] += t4), this.applyTransform(this.transform, t4, e2, r);
  }
  _addCoordinatePolyline(t4, e2, r) {
    this._dehydratedAddPointsCoordinate(t4.paths, e2, r);
  }
  _addCoordinatePolygon(t4, e2, r) {
    this._dehydratedAddPointsCoordinate(t4.rings, e2, r);
  }
  _addCoordinateMultipoint(t4, e2, r) {
    0 === r && t4.points.push([]);
    const o2 = this._transformPathLikeValue(e2, r);
    t4.points[t4.points.length - 1].push(o2);
  }
  _createPolygonGeometry(t4) {
    return { type: "polygon", rings: [[]], spatialReference: t4.spatialReference, hasZ: !!t4.hasZ, hasM: !!t4.hasM };
  }
  _createPolylineGeometry(t4) {
    return { type: "polyline", paths: [[]], spatialReference: t4.spatialReference, hasZ: !!t4.hasZ, hasM: !!t4.hasM };
  }
  _createMultipointGeometry(t4) {
    return { type: "multipoint", points: [], spatialReference: t4.spatialReference, hasZ: !!t4.hasZ, hasM: !!t4.hasM };
  }
  _dehydratedAddPointsCoordinate(t4, e2, r) {
    0 === r && 0 == this.toAddInCurrentPath-- && (t4.push([]), this.toAddInCurrentPath = this.lengths[++this.currentLengthIndex] - 1, this.previousCoordinate[0] = 0, this.previousCoordinate[1] = 0);
    const o2 = this._transformPathLikeValue(e2, r), s2 = t4[t4.length - 1];
    0 === r && s2.push(new Float64Array(this.coordinateBuffer.buffer, this.coordinateBufferPtr * Float64Array.BYTES_PER_ELEMENT, this.vertexDimension)), this.coordinateBuffer[this.coordinateBufferPtr++] = o2;
  }
  _deriveApplyTransform(t4) {
    const { hasZ: e2, hasM: r } = t4;
    return e2 && r ? f : e2 ? d : r ? c : p;
  }
};

// node_modules/@arcgis/core/views/3d/support/PBFDecoderWorker.js
var t3 = class {
  _parseFeatureQuery(t4) {
    const s2 = t2(t4.buffer, new g(t4.options)), o2 = { ...s2, spatialReference: s2.spatialReference.toJSON(), fields: s2.fields ? s2.fields.map((e2) => e2.toJSON()) : void 0 };
    return Promise.resolve(o2);
  }
};
function s() {
  return new t3();
}
export {
  s as default
};
//# sourceMappingURL=PBFDecoderWorker-BN2KIL57.js.map
