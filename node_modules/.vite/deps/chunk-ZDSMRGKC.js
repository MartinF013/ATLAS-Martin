import {
  n as n4
} from "./chunk-4P4OV7G6.js";
import {
  c,
  e,
  i as i2,
  n as n3,
  o
} from "./chunk-ZUDEVIXR.js";
import {
  q
} from "./chunk-RRFFPL7N.js";
import {
  p,
  y
} from "./chunk-HB4HVKJV.js";
import {
  n
} from "./chunk-UHJVTABQ.js";
import {
  i
} from "./chunk-W66LN57L.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  n as n2
} from "./chunk-GVELBHGI.js";
import {
  l
} from "./chunk-FVPTCNCX.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  a
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/symbols/support/svgUtils.js
var h = "http://www.w3.org/2000/svg";
var f = 0;
var c2 = 0;
var d = a("android");
var u = a("chrome") || d && d >= 4 ? "auto" : "optimizeLegibility";
var y2 = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7, z: 0 };
var p2 = /([A-DF-Za-df-z])|([-+]?\d*[.]?\d+(?:[eE][-+]?\d+)?)/g;
var g = {};
var x = {};
var m = { solid: "none", shortdash: [4, 1], shortdot: [1, 1], shortdashdot: [4, 1, 1, 1], shortdashdotdot: [4, 1, 1, 1, 1, 1], dot: [1, 3], dash: [4, 3], longdash: [8, 3], dashdot: [4, 3, 1, 3], longdashdot: [8, 3, 1, 3], longdashdotdot: [8, 3, 1, 3, 1, 3] };
var w = Math.PI;
var k = 1;
function b(t, e2) {
  const i3 = t * (w / 180);
  return Math.abs(e2 * Math.sin(i3)) + Math.abs(e2 * Math.cos(i3));
}
function j(t) {
  return t.map((t2) => `${t2.command} ${t2.values.join(" ")}`).join(" ").trim();
}
function v(t, e2, i3, r) {
  if (t) {
    if ("circle" === t.type)
      return n("circle", { fill: e2, "fill-rule": "evenodd", stroke: i3.color, "stroke-width": i3.width, "stroke-linecap": i3.cap, "stroke-linejoin": i3.join, "stroke-dasharray": i3.dashArray, "stroke-dashoffset": i3.dashOffset, "stroke-miterlimit": "4", cx: t.cx, cy: t.cy, r: t.r });
    if ("ellipse" === t.type)
      return n("ellipse", { fill: e2, "fill-rule": "evenodd", stroke: i3.color, "stroke-width": i3.width, "stroke-linecap": i3.cap, "stroke-linejoin": i3.join, "stroke-dasharray": i3.dashArray, "stroke-miterlimit": "4", cx: t.cx, cy: t.cy, rx: t.rx, ry: t.ry });
    if ("rect" === t.type)
      return n("rect", { fill: e2, "fill-rule": "evenodd", stroke: i3.color, "stroke-width": i3.width, "stroke-linecap": i3.cap, "stroke-linejoin": i3.join, "stroke-dasharray": i3.dashArray, "stroke-miterlimit": "4", x: t.x, y: t.y, width: t.width, height: t.height });
    if ("image" === t.type)
      return n("image", { href: t.src, x: t.x, y: t.y, width: t.width, height: t.height, preserveAspectRatio: "none" });
    if ("path" === t.type) {
      const r2 = "string" != typeof t.path ? j(t.path) : t.path;
      return n("path", { fill: e2, "fill-rule": "evenodd", stroke: i3.color, "stroke-width": i3.width, "stroke-linecap": i3.cap, "stroke-linejoin": i3.join, "stroke-dasharray": i3.dashArray, "stroke-miterlimit": "4", d: r2 });
    }
    if ("text" === t.type)
      return n("text", { "alignment-baseline": r.alignBaseline, fill: e2, "fill-rule": "evenodd", stroke: i3.color, "stroke-width": i3.width, "stroke-linecap": i3.cap, "stroke-linejoin": i3.join, "stroke-dasharray": i3.dashArray, "stroke-miterlimit": "4", "text-anchor": r.align, "text-decoration": r.decoration, kerning: r.kerning, rotate: r.rotate, "text-rendering": u, "font-style": r.font.style, "font-variant": r.font.variant, "font-weight": r.font.weight, "font-size": r.font.size, "font-family": r.font.family, x: t.x, y: t.y }, t.text);
  }
  return null;
}
function M(e2) {
  const i3 = { fill: "none", pattern: null, linearGradient: null };
  if (e2) {
    if ("type" in e2 && "pattern" === e2.type) {
      const t = "patternId-" + ++f;
      i3.fill = `url(#${t})`, i3.pattern = { id: t, x: e2.x, y: e2.y, width: e2.width, height: e2.height, image: { x: 0, y: 0, width: e2.width, height: e2.height, href: e2.src } };
    } else if ("type" in e2 && "linear" === e2.type) {
      const r = "linearGradientId-" + ++c2;
      i3.fill = `url(#${r})`, i3.linearGradient = { id: r, x1: e2.x1, y1: e2.y1, x2: e2.x2, y2: e2.y2, stops: e2.colors.map((e3) => ({ offset: e3.offset, color: e3.color && new l(e3.color).toString() })) };
    } else if (e2) {
      const r = new l(e2);
      i3.fill = r.toString();
    }
  }
  return i3;
}
function A(e2) {
  const i3 = { color: "none", width: 1, cap: "butt", join: "4", dashArray: "none", dashOffset: "0" };
  if (e2 && (null != e2.width && (i3.width = e2.width), e2.cap && (i3.cap = e2.cap), e2.join && (i3.join = e2.join.toString()), e2.color && (i3.color = new l(e2.color).toString()), e2.dashArray && (i3.dashArray = e2.dashArray), e2.dashArray && (i3.dashOffset = e2.dashoffset), e2.style)) {
    let t = null;
    if (e2.style in m && (t = m[e2.style]), Array.isArray(t)) {
      t = t.slice(0);
      for (let i4 = 0; i4 < t.length; ++i4)
        t[i4] *= e2.width;
      if ("butt" !== e2.cap) {
        for (let i4 = 0; i4 < t.length; i4 += 2)
          t[i4] -= e2.width, t[i4] < 1 && (t[i4] = 1);
        for (let i4 = 1; i4 < t.length; i4 += 2)
          t[i4] += e2.width;
      }
      t = t.join(",");
    }
    i3.dashArray = t;
  }
  return i3;
}
function S(t, e2) {
  const i3 = { align: null, decoration: null, kerning: null, rotate: null, font: { style: null, variant: null, weight: null, size: null, family: null } };
  return t && (i3.align = t.align, i3.alignBaseline = t.alignBaseline, i3.decoration = t.decoration, i3.kerning = t.kerning ? "auto" : "0", i3.rotate = t.rotated ? "90" : "0", i3.font.style = e2.style || "normal", i3.font.variant = e2.variant || "normal", i3.font.weight = e2.weight || "normal", i3.font.size = e2.size && e2.size.toString() || "10pt", i3.font.family = e2.family || "serif"), i3;
}
function $(t) {
  const { pattern: e2, linearGradient: i3 } = t;
  if (e2)
    return n("pattern", { id: e2.id, patternUnits: "userSpaceOnUse", x: e2.x, y: e2.y, width: e2.width, height: e2.height }, n("image", { x: e2.image.x, y: e2.image.y, width: e2.image.width, height: e2.image.height, href: e2.image.href }));
  if (i3) {
    const t2 = i3.stops.map((t3, e3) => n("stop", { key: `${e3}-stop`, offset: t3.offset, "stop-color": t3.color }));
    return n("linearGradient", { id: i3.id, gradientUnits: "userSpaceOnUse", x1: i3.x1, y1: i3.y1, x2: i3.x2, y2: i3.y2 }, t2);
  }
  return null;
}
function N(t, e2) {
  if (!t)
    return null;
  const i3 = [];
  for (const r of t) {
    const { shape: t2, fill: e3, stroke: n5, font: o2 } = r, s2 = M(e3), a2 = A(n5), l3 = "text" === t2.type ? S(t2, o2) : null;
    i3.push(v(t2, s2.fill, a2, l3));
  }
  return n("mask", { id: e2, maskUnits: "userSpaceOnUse" }, n("g", null, i3));
}
function G(t, e2, i3) {
  return i2(t, n3(t), [e2, i3]);
}
function I(t, e2, i3, r, n5) {
  return c(t, n3(t), [e2, i3]), t[4] = t[4] * e2 - r * e2 + r, t[5] = t[5] * i3 - n5 * i3 + n5, t;
}
function z(t, e2, i3, r) {
  const n5 = e2 % 360 * Math.PI / 180;
  e(t, n3(t), n5);
  const s2 = Math.cos(n5), l3 = Math.sin(n5), h3 = t[4], f3 = t[5];
  return t[4] = h3 * s2 - f3 * l3 + r * l3 - i3 * s2 + i3, t[5] = f3 * s2 + h3 * l3 - i3 * l3 - r * s2 + r, t;
}
function B(t, e2) {
  g && "left" in g ? (g.left > t && (g.left = t), g.right < t && (g.right = t), g.top > e2 && (g.top = e2), g.bottom < e2 && (g.bottom = e2)) : g = { left: t, bottom: e2, right: t, top: e2 };
}
function U2(t) {
  const e2 = t.args, i3 = e2.length;
  let r;
  switch (t.action) {
    case "M":
    case "L":
    case "C":
    case "S":
    case "Q":
    case "T":
      for (r = 0; r < i3; r += 2)
        B(e2[r], e2[r + 1]);
      x.x = e2[i3 - 2], x.y = e2[i3 - 1];
      break;
    case "H":
      for (r = 0; r < i3; ++r)
        B(e2[r], x.y);
      x.x = e2[i3 - 1];
      break;
    case "V":
      for (r = 0; r < i3; ++r)
        B(x.x, e2[r]);
      x.y = e2[i3 - 1];
      break;
    case "m": {
      let t2 = 0;
      "x" in x || (B(x.x = e2[0], x.y = e2[1]), t2 = 2);
      for (r = t2; r < i3; r += 2)
        B(x.x += e2[r], x.y += e2[r + 1]);
      break;
    }
    case "l":
    case "t":
      for (r = 0; r < i3; r += 2)
        B(x.x += e2[r], x.y += e2[r + 1]);
      break;
    case "h":
      for (r = 0; r < i3; ++r)
        B(x.x += e2[r], x.y);
      break;
    case "v":
      for (r = 0; r < i3; ++r)
        B(x.x, x.y += e2[r]);
      break;
    case "c":
      for (r = 0; r < i3; r += 6)
        B(x.x + e2[r], x.y + e2[r + 1]), B(x.x + e2[r + 2], x.y + e2[r + 3]), B(x.x += e2[r + 4], x.y += e2[r + 5]);
      break;
    case "s":
    case "q":
      for (r = 0; r < i3; r += 4)
        B(x.x + e2[r], x.y + e2[r + 1]), B(x.x += e2[r + 2], x.y += e2[r + 3]);
      break;
    case "A":
      for (r = 0; r < i3; r += 7)
        B(e2[r + 5], e2[r + 6]);
      x.x = e2[i3 - 2], x.y = e2[i3 - 1];
      break;
    case "a":
      for (r = 0; r < i3; r += 7)
        B(x.x += e2[r + 5], x.y += e2[r + 6]);
  }
}
function F(t, e2, i3) {
  const r = y2[t.toLowerCase()];
  let n5;
  "number" == typeof r && (r ? e2.length >= r && (n5 = { action: t, args: e2.slice(0, e2.length - e2.length % r) }, i3.push(n5), U2(n5)) : (n5 = { action: t, args: [] }, i3.push(n5), U2(n5)));
}
function O(t) {
  const e2 = ("string" != typeof t.path ? j(t.path) : t.path).match(p2), i3 = [];
  if (g = {}, x = {}, !e2)
    return null;
  let r = "", n5 = [];
  const o2 = e2.length;
  for (let a2 = 0; a2 < o2; ++a2) {
    const t2 = e2[a2], o3 = parseFloat(t2);
    isNaN(o3) ? (r && F(r, n5, i3), n5 = [], r = t2) : n5.push(o3);
  }
  F(r, n5, i3);
  const s2 = { x: 0, y: 0, width: 0, height: 0 };
  return g && "left" in g && (s2.x = g.left, s2.y = g.top, s2.width = g.right - g.left, s2.height = g.bottom - g.top), s2;
}
function T(t) {
  const e2 = { x: 0, y: 0, width: 0, height: 0 };
  if ("circle" === t.type)
    e2.x = t.cx - t.r, e2.y = t.cy - t.r, e2.width = 2 * t.r, e2.height = 2 * t.r;
  else if ("ellipse" === t.type)
    e2.x = t.cx - t.rx, e2.y = t.cy - t.ry, e2.width = 2 * t.rx, e2.height = 2 * t.ry;
  else if ("image" === t.type || "rect" === t.type)
    e2.x = t.x, e2.y = t.y, e2.width = t.width, e2.height = t.height;
  else if ("path" === t.type) {
    const i3 = O(t);
    e2.x = i3.x, e2.y = i3.y, e2.width = i3.width, e2.height = i3.height;
  }
  return e2;
}
function E(t) {
  const e2 = { x: 0, y: 0, width: 0, height: 0 };
  let i3 = null, r = Number.NEGATIVE_INFINITY, n5 = Number.NEGATIVE_INFINITY;
  for (const o2 of t)
    i3 ? (i3.x = Math.min(i3.x, o2.x), i3.y = Math.min(i3.y, o2.y), r = Math.max(r, o2.x + o2.width), n5 = Math.max(n5, o2.y + o2.height)) : (i3 = e2, i3.x = o2.x, i3.y = o2.y, r = o2.x + o2.width, n5 = o2.y + o2.height);
  return i3 && (i3.width = r - i3.x, i3.height = n5 - i3.y), i3;
}
function V(t, e2, n5, o2, s2, a2, l3, h3, f3) {
  let c3 = (l3 && a2 ? b(a2, e2) : e2) / 2, d3 = (l3 && a2 ? b(a2, n5) : n5) / 2;
  if (f3) {
    const t2 = f3[0], e3 = f3[1];
    c3 = (l3 && a2 ? b(a2, t2) : t2) / 2, d3 = (l3 && a2 ? b(a2, e3) : e3) / 2;
  }
  const u3 = t.width + o2, y3 = t.height + o2, p3 = n4(), g3 = n4();
  let x2 = false;
  if (s2 && 0 !== u3 && 0 !== y3) {
    const t2 = e2 !== n5 ? e2 / n5 : u3 / y3, i3 = e2 > n5 ? e2 : n5;
    let o3 = 1, s3 = 1;
    isNaN(i3) || (t2 > 1 ? (o3 = i3 / u3, s3 = i3 / t2 / y3) : (s3 = i3 / y3, o3 = i3 * t2 / u3)), o(g3, g3, I(p3, o3, s3, c3, d3)), x2 = true;
  }
  const m3 = t.x + (u3 - o2) / 2, w2 = t.y + (y3 - o2) / 2;
  if (o(g3, g3, G(p3, c3 - m3, d3 - w2)), !x2 && (u3 > e2 || y3 > n5)) {
    const t2 = u3 / e2 > y3 / n5, i3 = (t2 ? e2 : n5) / (t2 ? u3 : y3);
    o(g3, g3, I(p3, i3, i3, m3, w2));
  }
  return a2 && o(g3, g3, z(p3, a2, m3, w2)), h3 && o(g3, g3, G(p3, h3[0], h3[1])), `matrix(${g3[0]},${g3[1]},${g3[2]},${g3[3]},${g3[4]},${g3[5]})`;
}
function C(t, e2, i3) {
  const r = t == null ? void 0 : t.effects.find((t2) => "bloom" === t2.type);
  if (!r)
    return null;
  const { strength: n5, radius: o2 } = r, s2 = n5 > 0 ? o2 : 0, a2 = (n5 + s2) * e2, h3 = 4 * n5 + 1;
  return n("filter", { id: `bloom${i3}`, x: "-100%", y: "-100%", width: "300%", height: "300%", filterUnits: "userSpaceOnUse" }, n("feMorphology", { operator: "dilate", radius: (n5 + 0.5 * s2) * (5 ** (e2 / 100) * (0.4 + e2 / 100)), in: "SourceGraphic", result: "dilate" }), n("feGaussianBlur", { in: "dilate", stdDeviation: a2 / 25, result: "blur" }), n("feGaussianBlur", { in: "blur", stdDeviation: a2 / 50, result: "intensityBlur" }), n("feComponentTransfer", { in: "SourceGraphic", result: "intensityBrightness" }, n("feFuncR", { type: "linear", slope: h3 }), n("feFuncG", { type: "linear", slope: h3 }), n("feFuncB", { type: "linear", slope: h3 })), n("feMerge", null, n("feMergeNode", { in: "intensityBlur" }), n("feMergeNode", { in: "intensityBrightness" }), n("feGaussianBlur", { stdDeviation: n5 / 10 })));
}
function D(t, e2, i3, r = {}) {
  var _a;
  const n5 = [], o2 = [], s2 = ++k, a2 = C(r.effectView, e2, s2);
  let f3 = null;
  if (a2) {
    const t2 = (_a = r.effectView) == null ? void 0 : _a.effects.find((t3) => "bloom" === t3.type), n6 = (t2.strength ? t2.strength + t2.radius / 2 : 0) / 3, o3 = e2 + e2 * n6, s3 = i3 + i3 * n6;
    f3 = [Math.max(o3, 10), Math.max(s3, 10)];
  }
  for (let h3 = 0; h3 < t.length; h3++) {
    const s3 = t[h3], a3 = [], c3 = [];
    let d3 = 0, u3 = 0, y3 = 0;
    for (const t2 of s3) {
      const { shape: e3, fill: i4, stroke: o3, font: s4, offset: l3 } = t2;
      r.ignoreStrokeWidth || (d3 += o3 && o3.width || 0);
      const h4 = M(i4), f4 = A(o3), p4 = "text" === e3.type ? S(e3, s4) : null;
      n5.push($(h4)), a3.push(v(e3, h4.fill, f4, p4)), c3.push(T(e3)), l3 && (u3 += l3[0], y3 += l3[1]);
    }
    const p3 = V(E(c3), e2, i3, d3, r.scale, r.rotation, r.useRotationSize, [u3, y3], f3);
    let g3 = null;
    if (r.masking) {
      const t2 = `mask-${h3}`, e3 = r.masking[h3];
      n5.push(N(e3, t2)), g3 = `url(#${t2})`;
    }
    o2.push(g3 ? n("g", { mask: g3 }, n("g", { transform: p3 }, a3)) : n("g", { transform: p3 }, a3));
  }
  r.useRotationSize && r.rotation && (e2 = b(r.rotation, e2), i3 = b(r.rotation, i3)), a2 && (e2 = f3[0], i3 = f3[1]);
  return n("svg", { xmlns: h, width: e2, height: i3, style: "display: block;" }, a2, n("defs", null, n5), a2 ? n("g", { filter: `url(#bloom${s2})` }, o2) : o2);
}

// node_modules/@arcgis/core/symbols/support/renderUtils.js
var h2 = i();
function l2(t, e2, i3) {
  const r = Math.ceil(e2[0]), n5 = Math.ceil(e2[1]);
  if (!t.some((t2) => !!t2.length))
    return null;
  const o2 = i3 && i3.node || document.createElement("div");
  return null != i3.opacity && (o2.style.opacity = i3.opacity.toString()), null != i3.effectView && (o2.style.filter = q(i3.effectView)), h2.append(o2, D.bind(null, t, r, n5, i3)), o2;
}
function m2(t, e2) {
  t = Math.ceil(t), e2 = Math.ceil(e2);
  const i3 = document.createElement("canvas");
  i3.width = t, i3.height = e2, i3.style.width = t + "px", i3.style.height = e2 + "px";
  const r = i3.getContext("2d");
  return r.clearRect(0, 0, t, e2), r;
}
function g2(t, i3, r) {
  return t ? U(t, { responseType: "image" }).then((t2) => {
    const e2 = t2.data, n5 = e2.width, o2 = e2.height, a2 = n5 / o2;
    let c3 = i3;
    if (r) {
      const t3 = Math.max(n5, o2);
      c3 = Math.min(c3, t3);
    }
    return { image: e2, width: a2 <= 1 ? Math.ceil(c3 * a2) : c3, height: a2 <= 1 ? c3 : Math.ceil(c3 / a2) };
  }) : Promise.reject(new s("renderUtils: imageDataSize", "href not provided."));
}
function u2(t, e2) {
  return !(!t || "ignore" === e2) && ("multiply" !== e2 || 255 !== t.r || 255 !== t.g || 255 !== t.b || 1 !== t.a);
}
function d2(t, e2, n5, o2, a2) {
  switch (a2) {
    case "multiply":
      t[e2 + 0] *= n5[0], t[e2 + 1] *= n5[1], t[e2 + 2] *= n5[2], t[e2 + 3] *= n5[3];
      break;
    default: {
      const a3 = y({ r: t[e2 + 0], g: t[e2 + 1], b: t[e2 + 2] });
      a3.h = o2.h, a3.s = o2.s, a3.v = a3.v / 100 * o2.v;
      const c3 = p(a3);
      t[e2 + 0] = c3.r, t[e2 + 1] = c3.g, t[e2 + 2] = c3.b, t[e2 + 3] *= n5[3];
      break;
    }
  }
}
function f2(e2, r, n5, a2, c3) {
  return g2(e2, r, c3).then((c4) => {
    const s2 = c4.width ? c4.width : r, h3 = c4.height ? c4.height : r;
    if (c4.image && u2(n5, a2)) {
      let t = c4.image.width, r2 = c4.image.height;
      a("edge") && /\.svg$/i.test(e2) && (t -= 1, r2 -= 1);
      const l3 = m2(s2, h3);
      l3.drawImage(c4.image, 0, 0, t, r2, 0, 0, s2, h3);
      const g3 = l3.getImageData(0, 0, s2, h3), u3 = [n5.r / 255, n5.g / 255, n5.b / 255, n5.a], f3 = y(n5);
      for (let e3 = 0; e3 < g3.data.length; e3 += 4)
        d2(g3.data, e3, u3, f3, a2);
      l3.putImageData(g3, 0, 0), e2 = l3.canvas.toDataURL("image/png");
    } else {
      const i3 = n2 && n2.findCredential(e2);
      if (i3 && i3.token) {
        const t = e2.includes("?") ? "&" : "?";
        e2 = `${e2}${t}token=${i3.token}`;
      }
    }
    return { url: e2, width: s2, height: h3 };
  }).catch(() => ({ url: e2, width: r, height: r }));
}

export {
  v,
  M,
  A,
  $,
  T,
  E,
  V,
  D,
  l2 as l,
  f2 as f
};
//# sourceMappingURL=chunk-ZDSMRGKC.js.map
