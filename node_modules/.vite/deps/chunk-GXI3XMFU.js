import {
  u
} from "./chunk-M2WA2LMI.js";
import {
  d
} from "./chunk-4PRVTUEZ.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";

// node_modules/@arcgis/core/geometry/geometryEngineAsync.js
function e(n) {
  var _a;
  return Array.isArray(n) ? (_a = n[0]) == null ? void 0 : _a.spatialReference : n == null ? void 0 : n.spatialReference;
}
function i(n) {
  return n ? Array.isArray(n) ? n.map(i) : n.toJSON ? n.toJSON() : n : n;
}
function o(n) {
  return Array.isArray(n) ? n.map((n2) => d(n2)) : d(n);
}
function a(n, t) {
  let r;
  return Array.isArray(n) ? r = n : (r = [], r.push(n), null != t && r.push(t)), r;
}
var c;
async function u2() {
  return c || (c = u("geometryEngineWorker", { strategy: "distributed" })), c;
}
async function s(n, t) {
  return (await u2()).invoke("executeGEOperation", { operation: n, parameters: i(t) });
}
function f(n) {
  return s("extendedSpatialReferenceInfo", [n]);
}
async function l(n, t) {
  return o(await s("clip", [e(n), n, t]));
}
async function y(n, t) {
  return o(await s("cut", [e(n), n, t]));
}
function p(n, t) {
  return s("contains", [e(n), n, t]);
}
function w(n, t) {
  return s("crosses", [e(n), n, t]);
}
function m(n, t, r) {
  return s("distance", [e(n), n, t, r]);
}
function d2(n, t) {
  return s("equals", [e(n), n, t]);
}
function g(n, t) {
  return s("intersects", [e(n), n, t]);
}
function A(n, t) {
  return s("touches", [e(n), n, t]);
}
function x(n, t) {
  return s("within", [e(n), n, t]);
}
function S(n, t) {
  return s("disjoint", [e(n), n, t]);
}
function O(n, t) {
  return s("overlaps", [e(n), n, t]);
}
function h(n, t, r) {
  return s("relate", [e(n), n, t, r]);
}
function J(n) {
  return s("isSimple", [e(n), n]);
}
async function N(n) {
  return o(await s("simplify", [e(n), n]));
}
async function R(n, t = false) {
  return o(await s("convexHull", [e(n), n, t]));
}
async function E(n, t) {
  return o(await s("difference", [e(n), n, t]));
}
async function j2(n, t) {
  return o(await s("symmetricDifference", [e(n), n, t]));
}
async function k(n, t) {
  return o(await s("intersect", [e(n), n, t]));
}
async function I(n, t = null) {
  const r = a(n, t);
  return o(await s("union", [e(r), r]));
}
async function v(n, t, r, i2, a2, c2) {
  return o(await s("offset", [e(n), n, t, r, i2, a2, c2]));
}
async function V(n, t, r, i2 = false) {
  const a2 = [e(n), n, t, r, i2];
  return o(await s("buffer", a2));
}
async function b(n, t, r, i2, a2, c2) {
  const u3 = [e(n), n, t, r, i2, a2, c2];
  return o(await s("geodesicBuffer", u3));
}
async function z(n, r, i2 = true) {
  const o2 = await s("nearestCoordinate", [e(n), n, r, i2]);
  return { ...o2, coordinate: j.fromJSON(o2.coordinate) };
}
async function D(n, r) {
  const i2 = await s("nearestVertex", [e(n), n, r]);
  return { ...i2, coordinate: j.fromJSON(i2.coordinate) };
}
async function H(n, r, i2, o2) {
  return (await s("nearestVertices", [e(n), n, r, i2, o2])).map((n2) => ({ ...n2, coordinate: j.fromJSON(n2.coordinate) }));
}
function L(n) {
  return "xmin" in n ? n.center : "x" in n ? n : n.extent.center;
}
async function q(n, t, r) {
  if (null == n)
    throw new Error("Illegal Argument Exception");
  const e2 = n.spatialReference;
  r = r ?? L(n);
  const i2 = n.constructor.fromJSON(await s("rotate", [e2, n, t, r]));
  return i2.spatialReference = e2, i2;
}
async function B(n, t) {
  if (null == n)
    throw new Error("Illegal Argument Exception");
  const r = n.spatialReference;
  t = t ?? L(n);
  const e2 = n.constructor.fromJSON(await s("flipHorizontal", [r, n, t]));
  return e2.spatialReference = r, e2;
}
async function C(n, t) {
  if (null == n)
    throw new Error("Illegal Argument Exception");
  const r = n.spatialReference;
  t = t ?? L(n);
  const e2 = n.constructor.fromJSON(await s("flipVertical", [r, n, t]));
  return e2.spatialReference = r, e2;
}
async function G(n, t, r, i2) {
  return o(await s("generalize", [e(n), n, t, r, i2]));
}
async function P(n, t, r) {
  return o(await s("densify", [e(n), n, t, r]));
}
async function U(n, t, r, i2 = 0) {
  return o(await s("geodesicDensify", [e(n), n, t, r, i2]));
}
function W(n, t) {
  return s("planarArea", [e(n), n, t]);
}
function F(n, t) {
  return s("planarLength", [e(n), n, t]);
}
function K(n, t, r) {
  return s("geodesicArea", [e(n), n, t, r]);
}
function M(n, t, r) {
  return s("geodesicLength", [e(n), n, t, r]);
}

export {
  f,
  l,
  y,
  p,
  w,
  m,
  d2 as d,
  g,
  A,
  x,
  S,
  O,
  h,
  J,
  N,
  R,
  E,
  j2 as j,
  k,
  I,
  v,
  V,
  b,
  z,
  D,
  H,
  q,
  B,
  C,
  G,
  P,
  U,
  W,
  F,
  K,
  M
};
//# sourceMappingURL=chunk-GXI3XMFU.js.map
