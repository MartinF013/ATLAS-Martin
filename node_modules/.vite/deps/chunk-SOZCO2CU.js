import {
  B,
  C,
  q,
  v
} from "./chunk-Z7BSDVJ3.js";
import {
  r as r2
} from "./chunk-7ZPDA3EC.js";
import {
  y
} from "./chunk-WODSLTZT.js";
import {
  B as B2,
  a,
  s
} from "./chunk-TMBOFNWA.js";
import {
  D,
  u,
  x
} from "./chunk-56RHM4A6.js";
import {
  i
} from "./chunk-EPCCNF3D.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  e3 as e
} from "./chunk-2QOWZFCU.js";
import {
  m3 as m,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/graphics/dehydratedFeatureComparison.js
function n(e3, n2) {
  if (e3 === n2)
    return true;
  if (null == e3 || null == n2)
    return false;
  if (e3.length !== n2.length)
    return false;
  for (let t3 = 0; t3 < e3.length; t3++) {
    const r4 = e3[t3], a3 = n2[t3];
    if (r4.length !== a3.length)
      return false;
    for (let e4 = 0; e4 < r4.length; e4++)
      if (r4[e4] !== a3[e4])
        return false;
  }
  return true;
}
function t2(e3, t3) {
  if (e3 === t3)
    return true;
  if (null == e3 || null == t3)
    return false;
  if (e3.length !== t3.length)
    return false;
  for (let r4 = 0; r4 < e3.length; r4++)
    if (!n(e3[r4], t3[r4]))
      return false;
  return true;
}
function r3(e3, n2) {
  return !!f(e3.spatialReference, n2.spatialReference) && (e3.x === n2.x && e3.y === n2.y && e3.z === n2.z && e3.m === n2.m);
}
function a2(e3, n2) {
  return e3.hasZ === n2.hasZ && e3.hasM === n2.hasM && (!!f(e3.spatialReference, n2.spatialReference) && t2(e3.paths, n2.paths));
}
function i2(e3, n2) {
  return e3.hasZ === n2.hasZ && e3.hasM === n2.hasM && (!!f(e3.spatialReference, n2.spatialReference) && t2(e3.rings, n2.rings));
}
function u2(e3, t3) {
  return e3.hasZ === t3.hasZ && e3.hasM === t3.hasM && (!!f(e3.spatialReference, t3.spatialReference) && n(e3.points, t3.points));
}
function s2(e3, n2) {
  return e3.hasZ === n2.hasZ && e3.hasM === n2.hasM && (!!f(e3.spatialReference, n2.spatialReference) && (e3.xmin === n2.xmin && e3.ymin === n2.ymin && e3.zmin === n2.zmin && e3.xmax === n2.xmax && e3.ymax === n2.ymax && e3.zmax === n2.zmax));
}
function f(e3, n2) {
  return e3 === n2 || e3 && n2 && e3.equals(n2);
}
function l(n2, t3) {
  if (n2 === t3)
    return true;
  if (t(n2) || t(t3))
    return false;
  if (n2.type !== t3.type)
    return false;
  switch (n2.type) {
    case "point":
      return r3(n2, t3);
    case "extent":
      return s2(n2, t3);
    case "polyline":
      return a2(n2, t3);
    case "polygon":
      return i2(n2, t3);
    case "multipoint":
      return u2(n2, t3);
    case "mesh":
      return false;
    default:
      return;
  }
}
function c(e3, n2) {
  if (e3 === n2)
    return true;
  if (!e3 || !n2)
    return false;
  const t3 = Object.keys(e3), r4 = Object.keys(n2);
  if (t3.length !== r4.length)
    return false;
  for (const a3 of t3)
    if (e3[a3] !== n2[a3])
      return false;
  return true;
}
function o(e3, n2) {
  return e3 === n2 || null != e3 && null != n2 && e3.objectId === n2.objectId && (!!l(e3.geometry, n2.geometry) && !!c(e3.attributes, n2.attributes));
}

// node_modules/@arcgis/core/layers/graphics/dehydratedFeatures.js
var j = class {
  constructor(e3, t3, s3) {
    this.uid = e3, this.geometry = t3, this.attributes = s3, this.visible = true, this.objectId = null, this.centroid = null;
  }
};
function M(e3) {
  return r(e3.geometry);
}
var N = class {
  constructor() {
    this.exceededTransferLimit = false, this.features = [], this.fields = [], this.hasM = false, this.hasZ = false, this.geometryType = null, this.objectIdFieldName = null, this.globalIdFieldName = null, this.geometryProperties = null, this.geohashFieldName = null, this.spatialReference = null, this.transform = null;
  }
};
function z(e3) {
  const s3 = i.fromJSON(e3.geometryType), r4 = k.fromJSON(e3.spatialReference), n2 = e3.transform, a3 = e3.features.map((o2) => {
    const a4 = F(o2, s3, r4, e3.objectIdFieldName), i3 = a4.geometry;
    if (r(i3) && n2)
      switch (i3.type) {
        case "point":
          a4.geometry = v(n2, i3, i3, i3.hasZ, i3.hasM);
          break;
        case "multipoint":
          a4.geometry = q(n2, i3, i3, i3.hasZ, i3.hasM);
          break;
        case "polygon":
          a4.geometry = B(n2, i3, i3, i3.hasZ, i3.hasM);
          break;
        case "polyline":
          a4.geometry = C(n2, i3, i3, i3.hasZ, i3.hasM);
          break;
        case "extent":
        case "mesh":
          a4.geometry = i3;
      }
    return a4;
  });
  return { geometryType: s3, features: a3, spatialReference: r4, fields: e3.fields ? e3.fields.map((e4) => y.fromJSON(e4)) : null, objectIdFieldName: e3.objectIdFieldName, globalIdFieldName: e3.globalIdFieldName, geohashFieldName: e3.geohashFieldName, geometryProperties: e3.geometryProperties, hasZ: e3.hasZ, hasM: e3.hasM, exceededTransferLimit: e3.exceededTransferLimit, transform: null };
}
function F(e3, t3, s3, r4) {
  return { uid: e(), objectId: r4 && e3.attributes ? e3.attributes[r4] : null, attributes: e3.attributes, geometry: I(e3.geometry, t3, s3), visible: true };
}
function I(e3, t3, r4) {
  if (t(e3))
    return null;
  switch (t3) {
    case "point": {
      const t4 = e3;
      return { x: t4.x, y: t4.y, z: t4.z, m: t4.m, hasZ: null != t4.z, hasM: null != t4.m, type: "point", spatialReference: r4 };
    }
    case "polyline": {
      const t4 = e3;
      return { paths: t4.paths, hasZ: !!t4.hasZ, hasM: !!t4.hasM, type: "polyline", spatialReference: r4 };
    }
    case "polygon": {
      const t4 = e3;
      return { rings: t4.rings, hasZ: !!t4.hasZ, hasM: !!t4.hasM, type: "polygon", spatialReference: r4 };
    }
    case "multipoint": {
      const t4 = e3;
      return { points: t4.points, hasZ: !!t4.hasZ, hasM: !!t4.hasM, type: "multipoint", spatialReference: r4 };
    }
  }
}
function v2(e3, t3, s3, r4) {
  return { x: e3, y: t3, z: s3, hasZ: null != s3, hasM: false, spatialReference: r4, type: "point" };
}
function R(e3) {
  if (t(e3))
    return 0;
  let t3 = 32;
  switch (e3.type) {
    case "point":
      t3 += 42;
      break;
    case "polyline":
    case "polygon": {
      let s3 = 0;
      const r4 = 2 + (e3.hasZ ? 1 : 0) + (e3.hasM ? 1 : 0), n2 = "polyline" === e3.type ? e3.paths : e3.rings;
      for (const e4 of n2)
        s3 += e4.length;
      t3 += 8 * s3 * r4 + 64, t3 += 128 * s3, t3 += 34, t3 += 32 * (n2.length + 1);
      break;
    }
    case "multipoint": {
      const s3 = 2 + (e3.hasZ ? 1 : 0) + (e3.hasM ? 1 : 0), r4 = e3.points.length;
      t3 += 8 * r4 * s3 + 64, t3 += 128 * r4, t3 += 34, t3 += 32;
      break;
    }
    case "extent":
      t3 += 98, e3.hasM && (t3 += 32), e3.hasZ && (t3 += 32);
      break;
    case "mesh":
      t3 += m(e3.vertexAttributes.position), t3 += m(e3.vertexAttributes.normal), t3 += m(e3.vertexAttributes.uv), t3 += m(e3.vertexAttributes.tangent);
  }
  return t3;
}
function A(t3) {
  let s3 = 32;
  return s3 += r2(t3.attributes), s3 += 3, s3 += 8 + R(t3.geometry), s3;
}
function w(e3) {
  if (t(e3))
    return 0;
  switch (e3.type) {
    case "point":
      return 1;
    case "polyline": {
      let t3 = 0;
      for (const s3 of e3.paths)
        t3 += s3.length;
      return t3;
    }
    case "polygon": {
      let t3 = 0;
      for (const s3 of e3.rings)
        t3 += s3.length;
      return t3;
    }
    case "multipoint":
      return e3.points.length;
    case "extent":
      return 2;
    case "mesh": {
      const t3 = e3.vertexAttributes && e3.vertexAttributes.position;
      return t3 ? t3.length / 3 : 0;
    }
    default:
      return;
  }
}
function S(e3) {
  if (t(e3))
    return false;
  switch (e3.type) {
    case "extent":
    case "point":
      return true;
    case "polyline":
      for (const t3 of e3.paths)
        if (t3.length > 0)
          return true;
      return false;
    case "polygon":
      for (const t3 of e3.rings)
        if (t3.length > 0)
          return true;
      return false;
    case "multipoint":
      return e3.points.length > 0;
    case "mesh":
      return !e3.loaded || e3.vertexAttributes.position.length > 0;
  }
}
function T(e3, t3) {
  switch (B2(t3), "mesh" === e3.type && (e3 = e3.extent), e3.type) {
    case "point":
      t3[0] = t3[3] = e3.x, t3[1] = t3[4] = e3.y, e3.hasZ && (t3[2] = t3[5] = e3.z);
      break;
    case "polyline":
      for (let s3 = 0; s3 < e3.paths.length; s3++)
        s(t3, e3.paths[s3], e3.hasZ);
      break;
    case "polygon":
      for (let s3 = 0; s3 < e3.rings.length; s3++)
        s(t3, e3.rings[s3], e3.hasZ);
      break;
    case "multipoint":
      s(t3, e3.points, e3.hasZ);
      break;
    case "extent":
      t3[0] = e3.xmin, t3[1] = e3.ymin, t3[3] = e3.xmax, t3[4] = e3.ymax, null != e3.zmin && (t3[2] = e3.zmin), null != e3.zmax && (t3[5] = e3.zmax);
  }
}
function J(e3, t3) {
  switch (D(t3), "mesh" === e3.type && (e3 = e3.extent), e3.type) {
    case "point":
      t3[0] = t3[2] = e3.x, t3[1] = t3[3] = e3.y;
      break;
    case "polyline":
      for (let s3 = 0; s3 < e3.paths.length; s3++)
        x(t3, e3.paths[s3]);
      break;
    case "polygon":
      for (let s3 = 0; s3 < e3.rings.length; s3++)
        x(t3, e3.rings[s3]);
      break;
    case "multipoint":
      x(t3, e3.points);
      break;
    case "extent":
      t3[0] = e3.xmin, t3[1] = e3.ymin, t3[2] = e3.xmax, t3[3] = e3.ymax;
  }
}
function O(e3, t3) {
  return null != e3.objectId ? e3.objectId : e3.attributes && t3 ? e3.attributes[t3] : null;
}
var P = a();
var U = u();

export {
  r3 as r,
  o,
  j,
  M,
  N,
  z,
  v2 as v,
  A,
  w,
  S,
  T,
  J,
  O
};
//# sourceMappingURL=chunk-SOZCO2CU.js.map
