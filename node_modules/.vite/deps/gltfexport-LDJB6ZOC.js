import {
  g,
  i,
  o as o3,
  s
} from "./chunk-VYKXSWPZ.js";
import {
  P
} from "./chunk-C3M7GLTQ.js";
import "./chunk-EQ3EWUVK.js";
import {
  c
} from "./chunk-MFOJFHT7.js";
import {
  C,
  D
} from "./chunk-FPMD6IB4.js";
import "./chunk-FFHGE66H.js";
import "./chunk-MOZ4GR2L.js";
import "./chunk-MQBVOUKB.js";
import {
  K,
  k
} from "./chunk-DLM6NKXW.js";
import {
  e as e2,
  o as o2,
  r as r3
} from "./chunk-TQLSOIYV.js";
import "./chunk-YFBAFAZ2.js";
import "./chunk-LUU3J646.js";
import "./chunk-MZ4JF5C6.js";
import "./chunk-3NPGGTI6.js";
import "./chunk-YZNDHJDJ.js";
import "./chunk-PZWU5EHT.js";
import "./chunk-YG6VFATO.js";
import "./chunk-ASC3X65B.js";
import "./chunk-KVF4M6PZ.js";
import "./chunk-CLGCKZUR.js";
import "./chunk-RN2KRYDN.js";
import "./chunk-56RHM4A6.js";
import "./chunk-OO2JXX7L.js";
import "./chunk-HPH3FMVB.js";
import "./chunk-65A2N4LL.js";
import "./chunk-GVELBHGI.js";
import {
  it
} from "./chunk-5N3FSR63.js";
import "./chunk-DMJWTK32.js";
import "./chunk-FVPTCNCX.js";
import "./chunk-BPZGJQOB.js";
import "./chunk-ZOKX6UGH.js";
import {
  F as F2,
  _,
  e,
  o,
  z
} from "./chunk-PKZEO23A.js";
import "./chunk-43S7PUMG.js";
import {
  f,
  l,
  n,
  t as t2
} from "./chunk-AIRC226G.js";
import "./chunk-BNPOKP6A.js";
import "./chunk-CHNDTVQJ.js";
import "./chunk-VLCG72SW.js";
import "./chunk-Q72YFZUL.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import "./chunk-3NMRL5CR.js";
import "./chunk-SN4RUQ4N.js";
import "./chunk-XRL56EGK.js";
import "./chunk-ZIHDQYKE.js";
import "./chunk-GSRNZQFV.js";
import "./chunk-ICD7AJSY.js";
import "./chunk-2QOWZFCU.js";
import "./chunk-IVBXK6OP.js";
import "./chunk-YAAIZ67O.js";
import "./chunk-5EQKHR4M.js";
import {
  E
} from "./chunk-U3PSONS6.js";
import "./chunk-HFTNOKM2.js";
import {
  r as r2
} from "./chunk-23NWA6WL.js";
import "./chunk-CVWDM4C7.js";
import "./chunk-G5JBUC5N.js";
import {
  F,
  r,
  t
} from "./chunk-CBQWMOBK.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/glb.js
var t3;
!function(t4) {
  t4[t4.JSON = 1313821514] = "JSON", t4[t4.BIN = 5130562] = "BIN";
}(t3 || (t3 = {}));
var e3 = class {
  constructor(i3, r6) {
    if (!i3)
      throw new Error("GLB requires a JSON gltf chunk");
    this.length = e3.HEADER_SIZE, this.length += e3.CHUNK_HEADER_SIZE;
    const n2 = this._textToArrayBuffer(i3);
    if (this.length += this._alignTo(n2.byteLength, 4), r6 && (this.length += e3.CHUNK_HEADER_SIZE, this.length += r6.byteLength, r6.byteLength % 4))
      throw new Error("Expected BIN chunk length to be divisible by 4 at this point");
    this.buffer = new ArrayBuffer(this.length), this.outView = new DataView(this.buffer), this._writeHeader();
    const h2 = this._writeChunk(n2, 12, t3.JSON, 32);
    r6 && this._writeChunk(r6, h2, t3.BIN);
  }
  _writeHeader() {
    this.outView.setUint32(0, e3.MAGIC, true), this.outView.setUint32(4, e3.VERSION, true), this.outView.setUint32(8, this.length, true);
  }
  _writeChunk(t4, e4, i3, r6 = 0) {
    const n2 = this._alignTo(t4.byteLength, 4);
    for (this.outView.setUint32(e4, n2, true), this.outView.setUint32(e4 += 4, i3, true), this._writeArrayBuffer(this.outView.buffer, t4, e4 += 4, 0, t4.byteLength), e4 += t4.byteLength; e4 % 4; )
      r6 && this.outView.setUint8(e4, r6), e4++;
    return e4;
  }
  _writeArrayBuffer(t4, e4, i3, r6, n2) {
    new Uint8Array(t4, i3, n2).set(new Uint8Array(e4, r6, n2), 0);
  }
  _textToArrayBuffer(t4) {
    return new TextEncoder().encode(t4).buffer;
  }
  _alignTo(t4, e4) {
    return e4 * Math.ceil(t4 / e4);
  }
};
e3.HEADER_SIZE = 12, e3.CHUNK_HEADER_SIZE = 8, e3.MAGIC = 1179937895, e3.VERSION = 2;

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/types.js
var E2;
var A;
var R;
var L;
var o4;
var I;
var N;
!function(E3) {
  E3[E3.External = 0] = "External", E3[E3.DataURI = 1] = "DataURI", E3[E3.GLB = 2] = "GLB";
}(E2 || (E2 = {})), function(E3) {
  E3[E3.External = 0] = "External", E3[E3.DataURI = 1] = "DataURI", E3[E3.GLB = 2] = "GLB";
}(A || (A = {})), function(E3) {
  E3[E3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", E3[E3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(R || (R = {})), function(E3) {
  E3.SCALAR = "SCALAR", E3.VEC2 = "VEC2", E3.VEC3 = "VEC3", E3.VEC4 = "VEC4", E3.MAT2 = "MAT2", E3.MAT3 = "MAT3", E3.MAT4 = "MAT4";
}(L || (L = {})), function(E3) {
  E3[E3.POINTS = 0] = "POINTS", E3[E3.LINES = 1] = "LINES", E3[E3.LINE_LOOP = 2] = "LINE_LOOP", E3[E3.LINE_STRIP = 3] = "LINE_STRIP", E3[E3.TRIANGLES = 4] = "TRIANGLES", E3[E3.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", E3[E3.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
}(o4 || (o4 = {})), function(E3) {
  E3.OPAQUE = "OPAQUE", E3.MASK = "MASK", E3.BLEND = "BLEND";
}(I || (I = {})), function(E3) {
  E3[E3.NoColor = 0] = "NoColor", E3[E3.FaceColor = 1] = "FaceColor", E3[E3.VertexColor = 2] = "VertexColor";
}(N || (N = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/bufferview.js
var r4 = class {
  constructor(e4, s4, i3, r6, n2) {
    this.buffer = e4, this.componentType = i3, this.dataType = r6, this.data = [], this.isFinalized = false, this.accessorIndex = -1, this.accessorAttribute = null, this.accessorMin = null, this.accessorMax = null, s4.bufferViews || (s4.bufferViews = []), this.index = s4.bufferViews.length, this.bufferView = { buffer: e4.index, byteLength: -1, target: n2 };
    const a2 = this._getElementSize();
    a2 >= 4 && n2 !== R.ELEMENT_ARRAY_BUFFER && (this.bufferView.byteStride = a2), s4.bufferViews.push(this.bufferView), this.numComponentsForDataType = this._calculateNumComponentsForDataType();
  }
  push(e4) {
    const t4 = this.data.length;
    if (this.data.push(e4), this.accessorIndex >= 0) {
      const s4 = t4 % this.numComponentsForDataType, i3 = this.accessorMin[s4];
      this.accessorMin[s4] = "number" != typeof i3 ? e4 : Math.min(i3, e4);
      const r6 = this.accessorMax[s4];
      this.accessorMax[s4] = "number" != typeof r6 ? e4 : Math.max(r6, e4);
    }
  }
  get dataSize() {
    return this.data.length * this._sizeComponentType();
  }
  get byteSize() {
    function e4(e5, t4) {
      return t4 * Math.ceil(e5 / t4);
    }
    return e4(this.dataSize, 4);
  }
  getByteOffset() {
    if (!this.isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this.buffer.getByteOffset(this);
  }
  get byteOffset() {
    if (!this.isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this.buffer.getByteOffset(this);
  }
  _createTypedArray(e4, t4) {
    switch (this.componentType) {
      case C.BYTE:
        return new Int8Array(e4, t4);
      case C.FLOAT:
        return new Float32Array(e4, t4);
      case C.SHORT:
        return new Int16Array(e4, t4);
      case C.UNSIGNED_BYTE:
        return new Uint8Array(e4, t4);
      case C.UNSIGNED_INT:
        return new Uint32Array(e4, t4);
      case C.UNSIGNED_SHORT:
        return new Uint16Array(e4, t4);
    }
  }
  writeOutToBuffer(e4, t4) {
    this._createTypedArray(e4, t4).set(this.data);
  }
  writeAsync(e4) {
    if (this.asyncWritePromise)
      throw new Error("Can't write multiple bufferView values asynchronously");
    return this.asyncWritePromise = e4.then((e5) => {
      const t4 = new Uint8Array(e5);
      for (let s4 = 0; s4 < t4.length; ++s4)
        this.data.push(t4[s4]);
      delete this.asyncWritePromise;
    }), this.asyncWritePromise;
  }
  startAccessor(e4) {
    if (this.accessorIndex >= 0)
      throw new Error("Accessor was started without ending the previous one");
    this.accessorIndex = this.data.length, this.accessorAttribute = e4;
    const t4 = this.numComponentsForDataType;
    this.accessorMin = new Array(t4), this.accessorMax = new Array(t4);
  }
  endAccessor() {
    if (this.accessorIndex < 0)
      throw new Error("An accessor was not started, but was attempted to be ended");
    const e4 = this._getElementSize(), t4 = this.numComponentsForDataType, s4 = (this.data.length - this.accessorIndex) / t4;
    if (s4 % 1)
      throw new Error("An accessor was ended with missing component values");
    for (let i3 = 0; i3 < this.accessorMin.length; ++i3)
      "number" != typeof this.accessorMin[i3] && (this.accessorMin[i3] = 0), "number" != typeof this.accessorMax[i3] && (this.accessorMax[i3] = 0);
    const r6 = { byteOffset: e4 * (this.accessorIndex / t4), componentType: this.componentType, count: s4, type: this.dataType, min: this.accessorMin, max: this.accessorMax, name: this.accessorAttribute };
    switch (this.accessorAttribute) {
      case "TEXCOORD_0":
      case "TEXCOORD_1":
      case "COLOR_0":
      case "WEIGHTS_0":
        switch (this.componentType) {
          case C.UNSIGNED_BYTE:
          case C.UNSIGNED_SHORT:
            r6.normalized = true;
        }
    }
    return this.accessorIndex = -1, this.accessorAttribute = null, this.accessorMin = null, this.accessorMax = null, r6;
  }
  get finalized() {
    return this.finalizedPromise ? this.finalizedPromise : this.isFinalized ? this.finalizedPromise = Promise.resolve() : this.finalizedPromise = new Promise((e4) => this.finalizedPromiseResolve = e4);
  }
  finalize() {
    const t4 = this.bufferView;
    return new Promise((t5) => {
      const s4 = this.buffer.getViewFinalizePromises(this);
      this.asyncWritePromise && s4.push(this.asyncWritePromise), t5(E(s4));
    }).then(() => {
      this.isFinalized = true, t4.byteOffset = this.getByteOffset(), t4.byteLength = this.dataSize, this.finalizedPromiseResolve && this.finalizedPromiseResolve();
    });
  }
  _getElementSize() {
    return this._sizeComponentType() * this.numComponentsForDataType;
  }
  _sizeComponentType() {
    switch (this.componentType) {
      case C.BYTE:
      case C.UNSIGNED_BYTE:
        return 1;
      case C.SHORT:
      case C.UNSIGNED_SHORT:
        return 2;
      case C.UNSIGNED_INT:
      case C.FLOAT:
        return 4;
    }
  }
  _calculateNumComponentsForDataType() {
    switch (this.dataType) {
      case L.SCALAR:
        return 1;
      case L.VEC2:
        return 2;
      case L.VEC3:
        return 3;
      case L.VEC4:
      case L.MAT2:
        return 4;
      case L.MAT3:
        return 9;
      case L.MAT4:
        return 16;
    }
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/buffer.js
var r5 = class {
  constructor(e4) {
    this.gltf = e4, this.bufferViews = [], this.isFinalized = false, e4.buffers || (e4.buffers = []), this.index = e4.buffers.length;
    const i3 = { byteLength: -1 };
    e4.buffers.push(i3), this.buffer = i3;
  }
  addBufferView(e4, r6, t4) {
    if (this.finalizePromise)
      throw new Error("Cannot add buffer view after fiinalizing buffer");
    const f5 = new r4(this, this.gltf, e4, r6, t4);
    return this.bufferViews.push(f5), f5;
  }
  getByteOffset(e4) {
    let i3 = 0;
    for (const r6 of this.bufferViews) {
      if (r6 === e4)
        return i3;
      i3 += r6.byteSize;
    }
    throw new Error("Given bufferView was not present in this buffer");
  }
  getViewFinalizePromises(e4) {
    const i3 = [];
    for (const r6 of this.bufferViews) {
      if (e4 && r6 === e4)
        return i3;
      i3.push(r6.finalized);
    }
    return i3;
  }
  getArrayBuffer() {
    if (!this.isFinalized)
      throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");
    const e4 = this._getTotalSize(), i3 = new ArrayBuffer(e4);
    let r6 = 0;
    for (const t4 of this.bufferViews)
      t4.writeOutToBuffer(i3, r6), r6 += t4.byteSize;
    return i3;
  }
  finalize() {
    if (this.finalizePromise)
      throw new Error(`Buffer ${this.index} was already finalized`);
    return this.finalizePromise = new Promise((i3) => {
      i3(E(this.getViewFinalizePromises()));
    }).then(() => {
      this.isFinalized = true;
      const e4 = this.getArrayBuffer();
      this.buffer.byteLength = e4.byteLength, this.buffer.uri = e4;
    }), this.gltf.extras.promises.push(this.finalizePromise), this.finalizePromise;
  }
  _getTotalSize() {
    let e4 = 0;
    for (const i3 of this.bufferViews)
      e4 += i3.byteSize;
    return e4;
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/geometry.js
function f2(t4, n2) {
  if (t4.components)
    for (const e4 of t4.components)
      e4.faces && "smooth" === e4.shading && c2(e4, n2);
}
function c2(n2, a2) {
  t(a2.normal) && (a2.normal = new Float32Array(a2.position.length));
  const i3 = n2.faces, { position: f5, normal: c3 } = a2, m3 = i3.length / 3;
  for (let t4 = 0; t4 < m3; ++t4) {
    const n3 = 3 * i3[3 * t4 + 0], s4 = 3 * i3[3 * t4 + 1], a3 = 3 * i3[3 * t4 + 2], m4 = o(l2, f5[n3 + 0], f5[n3 + 1], f5[n3 + 2]), h2 = o(p, f5[s4 + 0], f5[s4 + 1], f5[s4 + 2]), g2 = o(x, f5[a3 + 0], f5[a3 + 1], f5[a3 + 2]), u = e(h2, h2, m4), j2 = e(g2, g2, m4), y = _(u, u, j2);
    c3[n3 + 0] += y[0], c3[n3 + 1] += y[1], c3[n3 + 2] += y[2], c3[s4 + 0] += y[0], c3[s4 + 1] += y[1], c3[s4 + 2] += y[2], c3[a3 + 0] += y[0], c3[a3 + 1] += y[1], c3[a3 + 2] += y[2];
  }
  for (let t4 = 0; t4 < c3.length; t4 += 3)
    o(h, c3[t4], c3[t4 + 1], c3[t4 + 2]), z(h, h), c3[t4 + 0] = h[0], c3[t4 + 1] = h[1], c3[t4 + 2] = h[2];
}
function m(t4) {
  if (r(t4.transform))
    return t4.transform.getOriginPoint(t4.spatialReference);
  const e4 = t4.extent.xmax - t4.extent.width / 2, o5 = t4.extent.ymax - t4.extent.height / 2, r6 = t4.extent.zmin;
  return new j({ x: e4, y: o5, z: r6, spatialReference: t4.extent.spatialReference });
}
var l2 = n();
var p = n();
var x = n();
var h = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltf.js
var M = class {
  constructor(e4, t4, s4) {
    this.params = {}, this.materialMap = new Array(), this.imageMap = /* @__PURE__ */ new Map(), this.textureMap = /* @__PURE__ */ new Map(), this.gltf = { asset: { version: "2.0", copyright: e4.copyright, generator: e4.generator }, extras: { options: t4, binChunkBuffer: null, promises: [] } }, s4 && (this.params = s4), this._addScenes(e4);
  }
  _addScenes(e4) {
    this.gltf.scene = e4.defaultScene;
    const t4 = this.gltf.extras.options.bufferOutputType === E2.GLB || this.gltf.extras.options.imageOutputType === A.GLB;
    t4 && (this.gltf.extras.binChunkBuffer = new r5(this.gltf)), e4.forEachScene((e5) => {
      this._addScene(e5);
    }), t4 && this.gltf.extras.binChunkBuffer.finalize();
  }
  _addScene(e4) {
    this.gltf.scenes || (this.gltf.scenes = []);
    const t4 = {};
    e4.name && (t4.name = e4.name), e4.forEachNode((e5) => {
      t4.nodes || (t4.nodes = []);
      const s4 = this._addNode(e5);
      t4.nodes.push(s4);
    }), this.gltf.scenes.push(t4);
  }
  _addNode(e4) {
    this.gltf.nodes || (this.gltf.nodes = []);
    const t4 = {};
    e4.name && (t4.name = e4.name);
    const s4 = e4.translation;
    F2(s4, f) || (t4.translation = t2(s4));
    const c3 = e4.rotation;
    K(c3, o2) || (t4.rotation = r3(c3));
    const u = e4.scale;
    F2(u, l) || (t4.scale = t2(u)), e4.mesh && e4.mesh.vertexAttributes.position ? t4.mesh = this._addMesh(e4.mesh) : e4.forEachNode((e5) => {
      t4.children || (t4.children = []);
      const s5 = this._addNode(e5);
      t4.children.push(s5);
    });
    const f5 = this.gltf.nodes.length;
    return this.gltf.nodes.push(t4), f5;
  }
  _addMesh(e4) {
    this.gltf.meshes || (this.gltf.meshes = []);
    const s4 = { primitives: [] }, i3 = this.gltf.extras.options.bufferOutputType === E2.GLB;
    let r6;
    r6 = i3 ? this.gltf.extras.binChunkBuffer : new r5(this.gltf), this.params.origin || (this.params.origin = m(e4));
    const a2 = P(e4.vertexAttributes, e4.transform, this.params.origin, { geographic: this.params.geographic, unit: "meters" });
    f2(e4, a2), this._flipYZAxis(a2);
    const o5 = r6.addBufferView(C.FLOAT, L.VEC3, R.ARRAY_BUFFER);
    let n2, l3, h2, c3;
    a2.normal && (n2 = r6.addBufferView(C.FLOAT, L.VEC3, R.ARRAY_BUFFER)), e4.vertexAttributes.uv && (l3 = r6.addBufferView(C.FLOAT, L.VEC2, R.ARRAY_BUFFER)), a2.tangent && (h2 = r6.addBufferView(C.FLOAT, L.VEC4, R.ARRAY_BUFFER)), e4.vertexAttributes.color && (c3 = r6.addBufferView(C.UNSIGNED_BYTE, L.VEC4, R.ARRAY_BUFFER)), o5.startAccessor("POSITION"), n2 && n2.startAccessor("NORMAL"), l3 && l3.startAccessor("TEXCOORD_0"), h2 && h2.startAccessor("TANGENT"), c3 && c3.startAccessor("COLOR_0");
    const g2 = a2.position.length / 3, { position: A2, normal: R2, tangent: T } = a2, { color: b, uv: M2 } = e4.vertexAttributes;
    for (let u = 0; u < g2; ++u)
      o5.push(A2[3 * u + 0]), o5.push(A2[3 * u + 1]), o5.push(A2[3 * u + 2]), n2 && r(R2) && (n2.push(R2[3 * u + 0]), n2.push(R2[3 * u + 1]), n2.push(R2[3 * u + 2])), l3 && r(M2) && (l3.push(M2[2 * u + 0]), l3.push(M2[2 * u + 1])), h2 && r(T) && (h2.push(T[4 * u + 0]), h2.push(T[4 * u + 1]), h2.push(T[4 * u + 2]), h2.push(T[4 * u + 3])), c3 && r(b) && (c3.push(b[4 * u + 0]), c3.push(b[4 * u + 1]), c3.push(b[4 * u + 2]), c3.push(b[4 * u + 3]));
    const O = o5.endAccessor(), N2 = this._addAccessor(o5.index, O);
    let C2, B, w, y, I2;
    if (n2) {
      const e5 = n2.endAccessor();
      C2 = this._addAccessor(n2.index, e5);
    }
    if (l3) {
      const e5 = l3.endAccessor();
      B = this._addAccessor(l3.index, e5);
    }
    if (h2) {
      const e5 = h2.endAccessor();
      w = this._addAccessor(h2.index, e5);
    }
    if (c3) {
      const e5 = c3.endAccessor();
      y = this._addAccessor(c3.index, e5);
    }
    e4.components && e4.components.length > 0 && e4.components[0].faces ? (I2 = r6.addBufferView(C.UNSIGNED_INT, L.SCALAR, R.ELEMENT_ARRAY_BUFFER), this._addMeshVertexIndexed(I2, e4.components, s4, N2, C2, B, w, y)) : this._addMeshVertexNonIndexed(e4.components, s4, N2, C2, B, w, y), o5.finalize(), n2 && n2.finalize(), l3 && l3.finalize(), h2 && h2.finalize(), I2 && I2.finalize(), c3 && c3.finalize(), i3 || r6.finalize();
    const S = this.gltf.meshes.length;
    return this.gltf.meshes.push(s4), S;
  }
  _flipYZAxis({ position: e4, normal: t4, tangent: s4 }) {
    this._flipYZBuffer(e4, 3), this._flipYZBuffer(t4, 3), this._flipYZBuffer(s4, 4);
  }
  _flipYZBuffer(e4, t4) {
    if (!t(e4))
      for (let s4 = 1, i3 = 2; s4 < e4.length; s4 += t4, i3 += t4) {
        const t5 = e4[s4], r6 = e4[i3];
        e4[s4] = r6, e4[i3] = -t5;
      }
  }
  _addMaterial(e4) {
    if (null === e4)
      return;
    const s4 = this.materialMap.indexOf(e4);
    if (-1 !== s4)
      return s4;
    this.gltf.materials || (this.gltf.materials = []);
    const i3 = {};
    switch (e4.alphaMode) {
      case "mask":
        i3.alphaMode = I.MASK;
        break;
      case "auto":
      case "blend":
        i3.alphaMode = I.BLEND;
    }
    0.5 !== e4.alphaCutoff && (i3.alphaCutoff = e4.alphaCutoff), e4.doubleSided && (i3.doubleSided = e4.doubleSided), i3.pbrMetallicRoughness = {};
    const r6 = (e5) => e5 ** 2.1, a2 = (e5) => {
      const t4 = e5.toRgba();
      return t4[0] = r6(t4[0] / 255), t4[1] = r6(t4[1] / 255), t4[2] = r6(t4[2] / 255), t4;
    };
    if (r(e4.color) && (i3.pbrMetallicRoughness.baseColorFactor = a2(e4.color)), r(e4.colorTexture) && (i3.pbrMetallicRoughness.baseColorTexture = { index: this._addTexture(e4.colorTexture) }), r(e4.normalTexture) && (i3.normalTexture = { index: this._addTexture(e4.normalTexture) }), e4 instanceof c) {
      if (r(e4.emissiveTexture) && (i3.emissiveTexture = { index: this._addTexture(e4.emissiveTexture) }), r(e4.emissiveColor)) {
        const t4 = a2(e4.emissiveColor);
        i3.emissiveFactor = [t4[0], t4[1], t4[2]];
      }
      r(e4.occlusionTexture) && (i3.occlusionTexture = { index: this._addTexture(e4.occlusionTexture) }), r(e4.metallicRoughnessTexture) && (i3.pbrMetallicRoughness.metallicRoughnessTexture = { index: this._addTexture(e4.metallicRoughnessTexture) }), i3.pbrMetallicRoughness.metallicFactor = e4.metallic, i3.pbrMetallicRoughness.roughnessFactor = e4.roughness;
    } else
      i3.pbrMetallicRoughness.metallicFactor = 1, i3.pbrMetallicRoughness.roughnessFactor = 1;
    const o5 = this.gltf.materials.length;
    return this.gltf.materials.push(i3), this.materialMap.push(e4), o5;
  }
  _addTexture(t4) {
    return this.gltf.textures || (this.gltf.textures = []), r2(this.textureMap, t4, () => {
      const e4 = { sampler: this._addSampler(t4), source: this._addImage(t4) }, s4 = this.gltf.textures.length;
      return this.gltf.textures.push(e4), s4;
    });
  }
  _addImage(e4) {
    const t4 = this.imageMap.get(e4);
    if (null != t4)
      return t4;
    this.gltf.images || (this.gltf.images = []);
    const s4 = {};
    if (e4.url)
      s4.uri = e4.url;
    else {
      s4.extras = e4.data;
      for (let t5 = 0; t5 < this.gltf.images.length; ++t5)
        if (e4.data === this.gltf.images[t5].extras)
          return t5;
      switch (this.gltf.extras.options.imageOutputType) {
        case A.GLB: {
          const t5 = this.gltf.extras.binChunkBuffer.addBufferView(C.UNSIGNED_BYTE, L.SCALAR), i4 = o3(e4.data).then(({ data: e5, type: t6 }) => (s4.mimeType = t6, e5));
          t5.writeAsync(i4).then(() => {
            t5.finalize();
          }), s4.bufferView = t5.index;
          break;
        }
        case A.DataURI:
          s4.uri = i(e4.data);
          break;
        default:
          this.gltf.extras.promises.push(o3(e4.data).then(({ data: e5, type: t5 }) => {
            s4.uri = e5, s4.mimeType = t5;
          }));
      }
    }
    const i3 = this.gltf.images.length;
    return this.gltf.images.push(s4), this.imageMap.set(e4, i3), i3;
  }
  _addSampler(e4) {
    this.gltf.samplers || (this.gltf.samplers = []);
    let t4 = D.REPEAT, s4 = D.REPEAT;
    if ("string" == typeof e4.wrap)
      switch (e4.wrap) {
        case "clamp":
          t4 = D.CLAMP_TO_EDGE, s4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t4 = D.MIRRORED_REPEAT, s4 = D.MIRRORED_REPEAT;
      }
    else {
      switch (e4.wrap.vertical) {
        case "clamp":
          s4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          s4 = D.MIRRORED_REPEAT;
      }
      switch (e4.wrap.horizontal) {
        case "clamp":
          t4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t4 = D.MIRRORED_REPEAT;
      }
    }
    const i3 = { wrapS: t4, wrapT: s4 };
    for (let a2 = 0; a2 < this.gltf.samplers.length; ++a2)
      if (JSON.stringify(i3) === JSON.stringify(this.gltf.samplers[a2]))
        return a2;
    const r6 = this.gltf.samplers.length;
    return this.gltf.samplers.push(i3), r6;
  }
  _addAccessor(e4, t4) {
    this.gltf.accessors || (this.gltf.accessors = []);
    const s4 = { bufferView: e4, byteOffset: t4.byteOffset, componentType: t4.componentType, count: t4.count, type: t4.type, min: t4.min, max: t4.max, name: t4.name };
    t4.normalized && (s4.normalized = true);
    const i3 = this.gltf.accessors.length;
    return this.gltf.accessors.push(s4), i3;
  }
  _addMeshVertexIndexed(e4, t4, s4, i3, r6, a2, o5, n2) {
    for (const l3 of t4) {
      e4.startAccessor("INDICES");
      for (let s5 = 0; s5 < l3.faces.length; ++s5)
        e4.push(l3.faces[s5]);
      const t5 = e4.endAccessor(), h2 = { attributes: { POSITION: i3 }, indices: this._addAccessor(e4.index, t5), material: this._addMaterial(l3.material) };
      r6 && "flat" !== l3.shading && (h2.attributes.NORMAL = r6), a2 && (h2.attributes.TEXCOORD_0 = a2), o5 && "flat" !== l3.shading && (h2.attributes.TANGENT = o5), n2 && (h2.attributes.COLOR_0 = n2), s4.primitives.push(h2);
    }
  }
  _addMeshVertexNonIndexed(e4, t4, s4, i3, r6, a2, o5) {
    const n2 = { attributes: { POSITION: s4 } };
    i3 && (n2.attributes.NORMAL = i3), r6 && (n2.attributes.TEXCOORD_0 = r6), a2 && (n2.attributes.TANGENT = a2), o5 && (n2.attributes.COLOR_0 = o5), e4 && (n2.material = this._addMaterial(e4[0].material)), t4.primitives.push(n2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/asset.js
var s2 = class {
  constructor() {
    this.copyright = "", this.defaultScene = 0, this.generator = "", this._scenes = [];
  }
  addScene(e4) {
    if (this._scenes.includes(e4))
      throw new Error("Scene already added");
    this._scenes.push(e4);
  }
  removeScene(s4) {
    F(this._scenes, s4);
  }
  forEachScene(e4) {
    this._scenes.forEach(e4);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/scene.js
var d = class {
  constructor() {
    this.name = "", this._nodes = [];
  }
  addNode(d2) {
    if (this._nodes.includes(d2))
      throw new Error("Node already added");
    this._nodes.push(d2);
  }
  forEachNode(d2) {
    this._nodes.forEach(d2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/node.js
var i2 = class {
  constructor(s4) {
    this.mesh = s4, this.name = "", this.translation = n(), this.rotation = e2(), this.scale = t2(l), this._nodes = [];
  }
  addNode(s4) {
    if (this._nodes.includes(s4))
      throw new Error("Node already added");
    this._nodes.push(s4);
  }
  forEachNode(s4) {
    this._nodes.forEach(s4);
  }
  set rotationAngles(t4) {
    k(this.rotation, t4[0], t4[1], t4[2]);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/index.js
var f3 = "model.gltf";
var p2 = "model.glb";
function a(a2, m3, c3) {
  const l3 = new M(a2, m3 = m3 || {}, c3);
  let g2 = l3.params;
  g2 ? g2.origin || (g2.origin = new j({ x: -1, y: -1, z: -1 })) : g2 = { origin: new j({ x: -1, y: -1, z: -1 }) };
  const y = g2.origin, d2 = l3.gltf, j2 = d2.extras.promises;
  let x2 = 1, b = 1, B = null;
  return E(j2).then(() => {
    const e4 = { origin: y };
    delete d2.extras;
    const t4 = "number" == typeof m3.jsonSpacing ? m3.jsonSpacing : 4, o5 = JSON.stringify(d2, (t5, r6) => {
      if ("extras" !== t5) {
        if (r6 instanceof ArrayBuffer) {
          if (g(r6))
            switch (m3.imageOutputType) {
              case A.DataURI:
              case A.GLB:
                break;
              case A.External:
              default: {
                const t6 = `img${b}.png`;
                return b++, e4[t6] = r6, t6;
              }
            }
          switch (m3.bufferOutputType) {
            case E2.DataURI:
              return s(r6);
            case E2.GLB:
              if (B)
                throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");
              return void (B = r6);
            case E2.External:
            default: {
              const t6 = `data${x2}.bin`;
              return x2++, e4[t6] = r6, t6;
            }
          }
        }
        return r6;
      }
    }, t4);
    return m3.bufferOutputType === E2.GLB || m3.imageOutputType === A.GLB ? e4[p2] = new e3(o5, B).buffer : e4[f3] = o5, e4;
  });
}
function m2(e4, t4) {
  return a(e4, { bufferOutputType: E2.GLB, imageOutputType: A.GLB, jsonSpacing: 0 }, t4);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltfexport.js
var s3 = class {
  constructor(e4, o5) {
    this._file = { type: "model/gltf-binary", data: e4 }, this.origin = o5;
  }
  buffer() {
    return Promise.resolve(this._file);
  }
  download(o5) {
    it(new Blob([this._file.data], { type: this._file.type }), o5);
  }
};
function f4(e4, f5) {
  const d2 = new s2(), l3 = new d();
  return d2.addScene(l3), l3.addNode(new i2(e4)), m2(d2, f5).then((e5) => new s3(e5[p2], e5.origin));
}
export {
  f4 as toBinaryGLTF
};
//# sourceMappingURL=gltfexport-LDJB6ZOC.js.map
