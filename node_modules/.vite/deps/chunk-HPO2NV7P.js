import {
  t as t3
} from "./chunk-22O7HU3A.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  v
} from "./chunk-SOZCO2CU.js";
import {
  e as e2
} from "./chunk-YFBAFAZ2.js";
import {
  Pn
} from "./chunk-PZWU5EHT.js";
import {
  _,
  t as t2
} from "./chunk-U7B2WKBH.js";
import {
  b,
  l as l4,
  m as m2
} from "./chunk-ASC3X65B.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import {
  S,
  z
} from "./chunk-TMBOFNWA.js";
import {
  u
} from "./chunk-56RHM4A6.js";
import {
  d
} from "./chunk-4PRVTUEZ.js";
import {
  r as r2
} from "./chunk-ZOKX6UGH.js";
import {
  e,
  l as l3
} from "./chunk-AIRC226G.js";
import {
  l as l2,
  o2 as o,
  s
} from "./chunk-VLCG72SW.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  A3 as A,
  c,
  l3 as l,
  r,
  t,
  y3 as y
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/layers/graphics/hydratedFeatures.js
function m3(e3) {
  return "declaredClass" in e3;
}
function u2(e3) {
  return "declaredClass" in e3;
}
function l5(e3) {
  return "declaredClass" in e3;
}
function c2(r3, t5) {
  if (!r3)
    return null;
  if (l5(r3))
    return r3;
  const s2 = new g({ layer: t5, sourceLayer: t5 });
  return s2.visible = r3.visible, s2.symbol = m(r3.symbol), s2.attributes = m(r3.attributes), s2.geometry = f(r3.geometry), s2;
}
function f(e3) {
  return t(e3) ? null : m3(e3) ? e3 : d(h(e3));
}
function h(e3) {
  const n = e3.spatialReference.toJSON();
  switch (e3.type) {
    case "point": {
      const { x: r3, y: t5, z: s2, m: a2 } = e3;
      return { x: r3, y: t5, z: s2, m: a2, spatialReference: n };
    }
    case "polygon": {
      const { rings: r3, hasZ: t5, hasM: s2 } = e3;
      return { rings: p(r3), hasZ: t5, hasM: s2, spatialReference: n };
    }
    case "polyline": {
      const { paths: r3, hasZ: t5, hasM: s2 } = e3;
      return { paths: p(r3), hasZ: t5, hasM: s2, spatialReference: n };
    }
    case "extent": {
      const { xmin: r3, xmax: t5, ymin: s2, ymax: a2, zmin: i2, zmax: o2, mmin: m4, mmax: u3, hasZ: l6, hasM: c3 } = e3;
      return { xmin: r3, xmax: t5, ymin: s2, ymax: a2, zmin: i2, zmax: o2, mmin: m4, mmax: u3, hasZ: l6, hasM: c3, spatialReference: n };
    }
    case "multipoint": {
      const { points: r3, hasZ: t5, hasM: s2 } = e3;
      return { points: M(r3) ? y2(r3) : r3, hasZ: t5, hasM: s2, spatialReference: n };
    }
    default:
      return;
  }
}
function p(e3) {
  return x(e3) ? e3.map((e4) => y2(e4)) : e3;
}
function y2(e3) {
  return e3.map((e4) => l(e4));
}
function x(e3) {
  for (const n of e3)
    if (0 !== n.length)
      return M(n);
  return false;
}
function M(e3) {
  return e3.length && (y(e3[0]) || A(e3[0]));
}
function Z(e3, n) {
  if (!e3)
    return null;
  let r3;
  if (u2(e3)) {
    if (null == n)
      return e3.clone();
    if (u2(n))
      return n.copy(e3);
  }
  return null != n ? (r3 = n, r3.x = e3.x, r3.y = e3.y, r3.spatialReference = e3.spatialReference, e3.hasZ ? (r3.z = e3.z, r3.hasZ = e3.hasZ) : (r3.z = null, r3.hasZ = false), e3.hasM ? (r3.m = e3.m, r3.hasM = true) : (r3.m = null, r3.hasM = false)) : (r3 = v(e3.x, e3.y, e3.z, e3.spatialReference), e3.hasM && (r3.m = e3.m, r3.hasM = true)), r3;
}

// node_modules/@arcgis/core/views/3d/support/ElevationProvider.js
var t4 = class {
  constructor(e3, r3 = null, t5 = 0) {
    this.array = e3, this.spatialReference = r3, this.offset = t5;
  }
};
function a(e3) {
  return "array" in e3;
}
function i(t5, i2, n = "ground") {
  if (t3(i2))
    return t5.getElevation(i2.x, i2.y, i2.z || 0, i2.spatialReference, n);
  if (a(i2)) {
    let r3 = i2.offset;
    return t5.getElevation(i2.array[r3++], i2.array[r3++], i2.array[r3] || 0, c(i2.spatialReference, t5.spatialReference), n);
  }
  return t5.getElevation(i2[0], i2[1], i2[2] || 0, t5.spatialReference, n);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/graphicUtils.js
function w(t5, e3) {
  if ("point" === t5.type)
    return P(t5, e3, false);
  if (m3(t5))
    switch (t5.type) {
      case "extent":
        return P(t5.center, e3, false);
      case "polygon":
        return P(t5.centroid, e3, false);
      case "polyline":
        return P(R(t5), e3, true);
      case "mesh":
        return P(t5.origin, e3, false);
    }
  else
    switch (t5.type) {
      case "extent":
        return P(A2(t5), e3, true);
      case "polygon":
        return P(M2(t5), e3, true);
      case "polyline":
        return P(R(t5), e3, true);
    }
}
function R(t5) {
  const e3 = t5.paths[0];
  if (!e3 || 0 === e3.length)
    return null;
  const r3 = l2(e3, s(e3) / 2);
  return v(r3[0], r3[1], r3[2], t5.spatialReference);
}
function A2(t5) {
  const e3 = isFinite(t5.zmin);
  return v(0.5 * (t5.xmax + t5.xmin), 0.5 * (t5.ymax + t5.ymin), e3 ? 0.5 * (t5.zmax + t5.zmin) : void 0, t5.spatialReference);
}
function M2(t5) {
  const e3 = t5.rings[0];
  if (!e3 || 0 === e3.length)
    return null;
  const r3 = o(t5.rings, t5.hasZ);
  return v(r3[0], r3[1], r3[2], t5.spatialReference);
}
function P(t5, e3, r3) {
  const n = r3 ? t5 : Z(t5);
  return e3 && t5 ? Pn(t5, n, e3) ? n : null : n;
}
function k(t5, e3, r3, n = 0) {
  if (t5) {
    e3 || (e3 = u());
    const o2 = t5;
    let i2 = 0.5 * o2.width * (r3 - 1), s2 = 0.5 * o2.height * (r3 - 1);
    return o2.width < 1e-7 * o2.height ? i2 += s2 / 20 : o2.height < 1e-7 * o2.width && (s2 += i2 / 20), r2(e3, o2.xmin - i2 - n, o2.ymin - s2 - n, o2.xmax + i2 + n, o2.ymax + s2 + n), e3;
  }
  return null;
}
function F(t5, e3) {
  for (let r3 = 0; r3 < t5.geometries.length; ++r3) {
    const n = t5.geometries[r3].getMutableAttribute(O.AUXPOS1);
    n && n.data[3] !== e3 && (n.data[3] = e3, t5.geometryVertexAttrsUpdated(t5.geometryRecords[r3]));
  }
}
function z2(e3, r3) {
  const n = t2(_);
  return r(e3) && (n[0] = e3[0], n[1] = e3[1], n[2] = e3[2]), r(r3) ? n[3] = r3 : r(e3) && e3.length > 3 && (n[3] = e3[3]), n;
}
function B(e3, r3, n, o2, i2, s2 = [0, 0, 0, 0]) {
  for (let u3 = 0; u3 < 3; ++u3)
    r(e3) && null != e3[u3] ? s2[u3] = e3[u3] : r(n) && null != n[u3] ? s2[u3] = n[u3] : s2[u3] = i2[u3];
  return r(r3) ? s2[3] = r3 : r(o2) ? s2[3] = o2 : s2[3] = i2[3], s2;
}
function D(t5 = l3, r3, n, o2 = 1) {
  const i2 = new Array(3);
  if (t(r3) || t(n))
    i2[0] = 1, i2[1] = 1, i2[2] = 1;
  else {
    let e3, o3 = 0;
    for (let s2 = 2; s2 >= 0; s2--) {
      const u3 = t5[s2];
      let a2;
      const l6 = null != u3, m4 = 0 === s2 && !e3 && !l6, c3 = n[s2];
      "symbol-value" === u3 || m4 ? a2 = 0 !== c3 ? r3[s2] / c3 : 1 : l6 && "proportional" !== u3 && isFinite(u3) && (a2 = 0 !== c3 ? u3 / c3 : 1), null != a2 && (i2[s2] = a2, e3 = a2, o3 = Math.max(o3, Math.abs(a2)));
    }
    for (let t6 = 2; t6 >= 0; t6--)
      null == i2[t6] ? i2[t6] = e3 : 0 === i2[t6] && (i2[t6] = 1e-3 * o3);
  }
  for (let e3 = 2; e3 >= 0; e3--)
    i2[e3] /= o2;
  return e(i2);
}
function I(t5) {
  return null != t5.isPrimitive;
}
function O2(t5) {
  return I(t5) && (t5 = [t5.width, t5.depth, t5.height]), U(t5) ? null : "Symbol sizes may not be negative values";
}
function U(t5) {
  if (Array.isArray(t5)) {
    for (const e3 of t5)
      if (!U(e3))
        return false;
    return true;
  }
  return null == t5 || t5 >= 0;
}
function S2(t5, e3, s2, u3 = e2()) {
  const a2 = t5 || 0, l6 = e3 || 0, m4 = s2 || 0;
  return 0 !== a2 && m2(u3, u3, -a2 / 180 * Math.PI), 0 !== l6 && b(u3, u3, l6 / 180 * Math.PI), 0 !== m4 && l4(u3, u3, m4 / 180 * Math.PI), u3;
}
function V(t5, e3) {
  return null != e3.minDemResolution ? e3.minDemResolution : S(t5) ? e3.minDemResolutionForPoints : 0.01 * z(t5);
}

export {
  c2 as c,
  f,
  Z,
  w,
  k,
  F,
  z2 as z,
  B,
  D,
  O2 as O,
  U,
  S2 as S,
  V,
  t4 as t,
  a,
  i
};
//# sourceMappingURL=chunk-HPO2NV7P.js.map
