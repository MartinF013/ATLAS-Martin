import {
  l,
  n as n2,
  r as r2
} from "./chunk-3CED37X7.js";
import {
  c as c2,
  e as e3,
  f,
  i,
  n,
  s as s3,
  u
} from "./chunk-WL7AHHN3.js";
import {
  me as me2
} from "./chunk-UGLXR5OV.js";
import {
  A as A2,
  t as t2
} from "./chunk-ZUKXZSOF.js";
import {
  N,
  O,
  P,
  S,
  T,
  c
} from "./chunk-HH3D3A65.js";
import {
  G
} from "./chunk-FPMD6IB4.js";
import {
  W,
  be,
  ce,
  ee,
  me,
  ne
} from "./chunk-6SWQ7R36.js";
import {
  e as e2
} from "./chunk-OZT6RDST.js";
import {
  d
} from "./chunk-FU5UMT3R.js";
import {
  m
} from "./chunk-EGR3VVZG.js";
import {
  o as o2
} from "./chunk-BPZGJQOB.js";
import {
  D,
  g
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  A,
  a,
  e,
  o,
  r,
  t,
  v
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderJSON.js
function c3({ coords: t3, lengths: e4 }) {
  let r5 = 0;
  for (const s4 of e4) {
    for (let e5 = 1; e5 < s4; e5++)
      t3[2 * (r5 + e5)] += t3[2 * (r5 + e5) - 2], t3[2 * (r5 + e5) + 1] += t3[2 * (r5 + e5) - 1];
    r5 += s4;
  }
}
var d2 = class extends A2 {
  constructor(t3, e4, r5) {
    super(t3, r5), this._featureIndex = -1, this._dateFields = /* @__PURE__ */ new Set(), this._geometryType = r5 == null ? void 0 : r5.geometryType, this._features = e4;
  }
  static fromFeatures(t3, e4) {
    const { objectIdField: s4, geometryType: i2 } = e4, n4 = W([], t3, i2, false, false, s4);
    for (let r5 = 0; r5 < n4.length; r5++)
      n4[r5].displayId = t3[r5].displayId;
    return d2.fromOptimizedFeatures(n4, e4);
  }
  static fromFeatureSet(t3, e4) {
    const r5 = ce(t3, e4.objectIdField);
    return d2.fromOptimizedFeatureSet(r5, e4);
  }
  static fromOptimizedFeatureSet(t3, e4) {
    const { features: r5 } = t3, s4 = d2.fromOptimizedFeatures(r5, e4);
    s4._exceededTransferLimit = t3.exceededTransferLimit, s4._transform = t3.transform;
    for (const i2 of t3.fields)
      "esriFieldTypeDate" === i2.type && s4._dateFields.add(i2.name);
    return s4;
  }
  static fromOptimizedFeatures(t3, e4, r5) {
    const s4 = A2.createInstance(), i2 = new d2(s4, t3, e4);
    return i2._transform = r5, i2;
  }
  get _current() {
    return this._features[this._featureIndex];
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasFeatures() {
    return !!this._features.length;
  }
  get hasNext() {
    return this._featureIndex + 1 < this._features.length;
  }
  get exceededTransferLimit() {
    return this._exceededTransferLimit;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  removeIds(t3) {
    const e4 = new Set(t3);
    this._features = this._features.filter((t4) => !e4.has(t4.objectId));
  }
  append(t3) {
    for (const e4 of t3)
      this._features.push(e4);
  }
  getSize() {
    return this._features.length;
  }
  getCursor() {
    return this.copy();
  }
  getQuantizationTransform() {
    return this._transform;
  }
  getAttributeHash() {
    let t3 = "";
    for (const e4 in this._current.attributes)
      t3 += this._current.attributes[e4];
    return t3;
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(t3) {
    this._featureIndex = t3;
  }
  getObjectId() {
    return this._current.objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(t3) {
    this._current.displayId = t3;
  }
  getGroupId() {
    return this._current.groupId;
  }
  setGroupId(t3) {
    this._current.groupId = t3;
  }
  copy() {
    const t3 = new d2(this.instance, this._features, this.fullSchema());
    return this.copyInto(t3), t3;
  }
  next() {
    for (; ++this._featureIndex < this._features.length && !this._getExists(); )
      ;
    return this._featureIndex < this._features.length;
  }
  readLegacyFeature() {
    return ee(this._current, this.geometryType, this.hasZ, this.hasM);
  }
  readOptimizedFeature() {
    return this._current;
  }
  readLegacyPointGeometry() {
    return this.readGeometry() ? { x: this.getX(), y: this.getY() } : null;
  }
  readLegacyGeometry() {
    const t3 = this.readGeometry();
    return ne(t3, this.geometryType, this.hasZ, this.hasM);
  }
  readLegacyCentroid() {
    const e4 = this.readCentroid();
    return t(e4) ? null : { x: e4.coords[0] * this._sx + this._tx, y: e4.coords[1] * this._sy + this._ty };
  }
  readGeometryArea() {
    return e2(this._current) ? be(this._current.geometry, 2) : 0;
  }
  readUnquantizedGeometry() {
    const t3 = this.readGeometry();
    if ("esriGeometryPoint" === this.geometryType || !t3)
      return t3;
    const e4 = t3.clone();
    return c3(e4), e4;
  }
  readHydratedGeometry() {
    const r5 = this._current.geometry;
    if (t(r5))
      return null;
    const s4 = r5.clone();
    return r(this._transform) && me(s4, s4, this.hasZ, this.hasM, this._transform), s4;
  }
  getXHydrated() {
    if (!e2(this._current))
      return 0;
    const e4 = this._current.geometry.coords[0], r5 = this.getQuantizationTransform();
    return t(r5) ? e4 : e4 * r5.scale[0] + r5.translate[0];
  }
  getYHydrated() {
    if (!e2(this._current))
      return 0;
    const e4 = this._current.geometry.coords[1], r5 = this.getQuantizationTransform();
    return t(r5) ? e4 : r5.translate[1] - e4 * r5.scale[1];
  }
  getX() {
    return e2(this._current) ? this._current.geometry.coords[0] * this._sx + this._tx : 0;
  }
  getY() {
    return e2(this._current) ? this._current.geometry.coords[1] * this._sy + this._ty : 0;
  }
  readGeometry() {
    if (!e2(this._current))
      return null;
    const t3 = this._current.geometry.clone();
    if (t3.isPoint)
      return t3.coords[0] = t3.coords[0] * this._sx + this._tx, t3.coords[1] = t3.coords[1] * this._sy + this._ty, t3;
    let e4 = 0;
    for (const r5 of t3.lengths)
      t3.coords[2 * e4] = t3.coords[2 * e4] * this._sx + this._tx, t3.coords[2 * e4 + 1] = t3.coords[2 * e4 + 1] * this._sy + this._ty, e4 += r5;
    return t3;
  }
  readCentroid() {
    if (!e2(this._current))
      return null;
    if (t(this._current.centroid)) {
      const e5 = this._computeCentroid();
      if (t(e5))
        return null;
      e5.coords[0] = (e5.coords[0] - this._tx) / this._sx, e5.coords[1] = (e5.coords[1] - this._ty) / this._sy, this._current.centroid = e5;
    }
    const e4 = this._current.centroid.clone();
    return e4.coords[0] = e4.coords[0] * this._sx + this._tx, e4.coords[1] = e4.coords[1] * this._sx + this._ty, e4;
  }
  hasField(t3) {
    if (t3 in this._current.attributes)
      return true;
    return this.getFieldNames().map((t4) => t4.toLowerCase()).includes(t3.toLowerCase());
  }
  getFieldNames() {
    return Object.keys(this._current.attributes);
  }
  _readAttribute(t3, e4) {
    const r5 = this._current.attributes[t3];
    if (void 0 !== r5)
      return null != r5 && e4 && this._dateFields.has(t3) ? new Date(r5) : r5;
    const s4 = this.readAttributes(), i2 = t3.toLocaleLowerCase().trim();
    for (const n4 in s4)
      if (n4.toLocaleLowerCase().trim() === i2) {
        const t4 = this._current.attributes[n4];
        return null != t4 && e4 && this._dateFields.has(n4) ? new Date(t4) : t4;
      }
  }
  copyInto(t3) {
    super.copyInto(t3), t3._featureIndex = this._featureIndex, t3._transform = this._transform, t3._dateFields = this._dateFields;
  }
  _readAttributes() {
    return this._current.attributes;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/AttributeStore.js
var C = s.getLogger("esri.views.layers.2d.features.support.AttributeStore");
var F = n2(l, C);
var M = { sharedArrayBuffer: a("esri-shared-array-buffer"), atomics: a("esri-atomics") };
function B(t3, e4) {
  return (i2) => e4(t3(i2));
}
var v2 = class {
  constructor(t3, e4, i2, s4) {
    this.size = 0, this.texelSize = 4;
    const { pixelType: r5, layout: a2, textureOnly: o3 } = s4;
    this.textureOnly = o3 || false, this.pixelType = r5, this._ctype = e4, this.layout = a2, this._resetRange(), this._shared = t3, this.size = i2, o3 || (this.data = this._initData(r5, i2, t3, e4));
  }
  get buffer() {
    return o(this.data, (t3) => t3.buffer);
  }
  unsetComponentAllTexels(t3, e4) {
    const i2 = e(this.data);
    for (let s4 = 0; s4 < this.size * this.size; s4++)
      i2[s4 * this.texelSize + t3] &= ~e4;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponentAllTexels(t3, e4) {
    const i2 = e(this.data);
    for (let s4 = 0; s4 < this.size * this.size; s4++)
      i2[s4 * this.texelSize + t3] |= 255 & e4;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponent(t3, e4, i2) {
    const s4 = e(this.data);
    for (const r5 of i2)
      s4[r5 * this.texelSize + t3] |= e4, this.dirtyStart = Math.min(this.dirtyStart, r5), this.dirtyEnd = Math.max(this.dirtyEnd, r5);
  }
  setComponentTexel(t3, e4, i2) {
    e(this.data)[i2 * this.texelSize + t3] |= e4, this.dirtyStart = Math.min(this.dirtyStart, i2), this.dirtyEnd = Math.max(this.dirtyEnd, i2);
  }
  unsetComponentTexel(t3, e4, i2) {
    e(this.data)[i2 * this.texelSize + t3] &= ~e4, this.dirtyStart = Math.min(this.dirtyStart, i2), this.dirtyEnd = Math.max(this.dirtyEnd, i2);
  }
  getData(t3, e4) {
    const i2 = f(t3);
    return e(this.data)[i2 * this.texelSize + e4];
  }
  setData(t3, e4, i2) {
    const s4 = f(t3), r5 = 1 << e4;
    0 != (this.layout & r5) ? (this.data[s4 * this.texelSize + e4] = i2, this.dirtyStart = Math.min(this.dirtyStart, s4), this.dirtyEnd = Math.max(this.dirtyEnd, s4)) : C.error("mapview-attributes-store", "Tried to set a value for a texel's readonly component");
  }
  lock() {
    this.pixelType === G.UNSIGNED_BYTE && this._shared && M.atomics && "local" !== this._ctype && Atomics.store(this.data, 0, 1);
  }
  unlock() {
    this.pixelType === G.UNSIGNED_BYTE && this._shared && M.atomics && "local" !== this._ctype && Atomics.store(this.data, 0, 0);
  }
  expand(t3) {
    if (this.size = t3, !this.textureOnly) {
      const e4 = this._initData(this.pixelType, t3, this._shared, this._ctype), i2 = e(this.data);
      e4.set(i2), this.data = e4;
    }
  }
  toMessage() {
    const t3 = this.dirtyStart, e4 = this.dirtyEnd, i2 = this.texelSize;
    if (t3 > e4)
      return null;
    this._resetRange();
    const s4 = !(this._shared || "local" === this._ctype), r5 = this.pixelType, a2 = this.layout, o3 = e(this.data);
    return { start: t3, end: e4, data: s4 && o3.slice(t3 * i2, (e4 + 1) * i2) || null, pixelType: r5, layout: a2 };
  }
  _initData(t3, e4, i2, s4) {
    const r5 = i2 && "local" !== s4 ? SharedArrayBuffer : ArrayBuffer, a2 = me2(t3), o3 = new a2(new r5(e4 * e4 * 4 * a2.BYTES_PER_ELEMENT));
    for (let n4 = 0; n4 < o3.length; n4 += 4)
      o3[n4 + 1] = 255;
    return o3;
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
};
var R = class {
  constructor(t3, e4, i2 = () => {
  }) {
    this._client = t3, this.config = e4, this._notifyChange = i2, this._attributeComputeMap = /* @__PURE__ */ new Map(), this._blocks = new Array(), this._filters = new Array(S), this._targetType = 0, this._abortController = new AbortController(), this._hasScaleExpr = false, this._size = 32, this._idsToHighlight = /* @__PURE__ */ new Set();
    const s4 = e4.supportsTextureFloat ? G.FLOAT : G.UNSIGNED_BYTE;
    F(`Creating AttributeStore ${M.sharedArrayBuffer ? "with" : "without"} shared memory`), this._blockDescriptors = [{ pixelType: G.UNSIGNED_BYTE, layout: 1 }, { pixelType: G.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: G.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: s4, layout: 15 }, { pixelType: s4, layout: 15 }, { pixelType: s4, layout: 15 }, { pixelType: s4, layout: 15 }], this._blocks = this._blockDescriptors.map(() => null);
  }
  destroy() {
    this._abortController.abort();
  }
  get hasScaleExpr() {
    return this._hasScaleExpr;
  }
  get _signal() {
    return this._abortController.signal;
  }
  get hasHighlight() {
    return this._idsToHighlight.size > 0;
  }
  isUpdating() {
    return !!this._currUpdate || !!this._nextUpdate;
  }
  update(t3, i2) {
    this.config = i2;
    const s4 = i2.schema.processors[0].storage, o3 = m(this._schema, s4);
    if ((t3.targets.feature || t3.targets.aggregate) && (t3.storage.data = true), o3 && (a("esri-2d-update-debug") && console.debug("Applying Update - AttributeStore:", o3), t3.storage.data = true, this._schema = s4, this._attributeComputeMap.clear(), !t(s4))) {
      switch (s4.target) {
        case "feature":
          this._targetType = u;
          break;
        case "aggregate":
          this._targetType = c2;
      }
      if ("subtype" === s4.type)
        for (const t4 in s4.mapping) {
          const e4 = s4.mapping[t4];
          if (r(e4) && r(e4.vvMapping))
            for (const t5 of e4.vvMapping)
              this._bindAttribute(t5);
        }
      else {
        if (r(s4.vvMapping))
          for (const t4 of s4.vvMapping)
            this._bindAttribute(t4);
        if (r(s4.attributeMapping))
          for (const t4 of s4.attributeMapping)
            this._bindAttribute(t4);
      }
    }
  }
  onTileData(t3, e4) {
    if (t(e4.addOrUpdate))
      return;
    const i2 = e4.addOrUpdate.getCursor();
    for (; i2.next(); ) {
      const t4 = i2.getDisplayId();
      this.setAttributeData(t4, i2);
    }
  }
  invalidateResources() {
    this._createResourcesPromise = null, this._abortController.abort(), this._abortController = new AbortController();
  }
  async setHighlight(t3, e4) {
    const i2 = 1, s4 = this._getBlock(0), r5 = e4.map((t4) => f(t4));
    s4.lock(), s4.unsetComponentAllTexels(0, i2), s4.setComponent(0, i2, r5), s4.unlock(), this._idsToHighlight.clear();
    for (const a2 of t3)
      this._idsToHighlight.add(a2);
    await this.sendUpdates();
  }
  async updateFilters(t3, i2, s4) {
    const { service: r5, spatialReference: a2 } = s4, { filters: o3 } = i2, n4 = o3.map((t4, e4) => this._updateFilter(t4, e4, r5, a2));
    (await Promise.all(n4)).some((t4) => t4) && (t3.storage.filters = true, a("esri-2d-update-debug") && console.debug("Applying Update - AttributeStore:", "Filters changed"));
  }
  setData(t3, e4, i2, s4) {
    const r5 = f(t3);
    this._ensureSizeForTexel(r5), this._getBlock(e4).setData(t3, i2, s4);
  }
  getData(t3, e4, i2) {
    return this._getBlock(e4).getData(t3, i2);
  }
  getHighlightFlag(t3) {
    return this._idsToHighlight.has(t3) ? T : 0;
  }
  unsetAttributeData(t3) {
    const e4 = f(t3);
    this._getBlock(0).setData(e4, 0, 0);
  }
  setAttributeData(t3, e4) {
    const i2 = f(t3);
    if (this._ensureSizeForTexel(i2), this._getBlock(0).setData(i2, 0, this.getFilterFlags(e4)), this._targetType !== e3(t3))
      return;
    const r5 = this._attributeComputeMap, a2 = this.config.supportsTextureFloat ? 1 : 2, o3 = 4;
    r5.size && r5.forEach((t4, r6) => {
      const n4 = r6 * a2 % o3, l2 = Math.floor(r6 * a2 / o3), h = this._getBlock(l2 + P), u2 = t4(e4);
      if (this.config.supportsTextureFloat)
        h.setData(i2, n4, u2);
      else if (u2 === c)
        h.setData(i2, n4, 255), h.setData(i2, n4 + 1, 255);
      else {
        const t5 = o2(Math.round(u2), -32767, 32766) + 32768, e5 = 255 & t5, r7 = (65280 & t5) >> 8;
        h.setData(i2, n4, e5), h.setData(i2, n4 + 1, r7);
      }
    });
  }
  sendUpdates() {
    if (a("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate"), this._notifyChange(), this._nextUpdate)
      return this._nextUpdate.promise;
    if (this._currUpdate)
      return this._nextUpdate = D(), this._nextUpdate.promise;
    const i2 = { blocks: this._blocks.map((t3) => r(t3) ? t3.toMessage() : null) };
    return this._currUpdate = this._createResources().then(() => {
      const t3 = () => {
        if (this._currUpdate = null, this._nextUpdate) {
          const t4 = this._nextUpdate;
          this._nextUpdate = null, this.sendUpdates().then(() => t4.resolve());
        } else
          a("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate::No additional updates queued");
        this._notifyChange();
      };
      a("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate::client.update");
      const s4 = this._client.update(i2, this._signal).then(t3).catch(t3);
      return this._client.render(this._signal), s4;
    }).catch((e4) => {
      if (g(e4))
        return this._createResourcesPromise = null, this._createResources();
      this._notifyChange(), C.error(new s2("mapview-attribute-store", "Encountered an error during client update", e4));
    }), this._currUpdate;
  }
  _ensureSizeForTexel(t3) {
    for (; t3 >= this._size * this._size; )
      if (this._expand())
        return;
  }
  _bindAttribute(t3) {
    function e4() {
      return t3.normalizationField ? (e5) => {
        const i3 = e5.readAttribute(t3.normalizationField);
        if (!i3)
          return null;
        return e5.readAttribute(t3.field) / i3;
      } : (e5) => e5.readAttribute(t3.field);
    }
    function i2() {
      return t3.normalizationField && C.warn("mapview-arcade", "Ignoring normalizationField specified with an arcade expression which is not supported."), (e5) => e5.getComputedNumericAtIndex(t3.fieldIndex);
    }
    let s4;
    if (null != t3.fieldIndex)
      s4 = i2();
    else {
      if (!t3.field)
        return;
      s4 = e4();
    }
    if (t3.valueRepresentation) {
      s4 = B(s4, (e5) => r2(e5, t3.valueRepresentation));
    }
    const r5 = (t4) => null === t4 || isNaN(t4) || t4 === 1 / 0 ? c : t4;
    this._attributeComputeMap.set(t3.binding, B(s4, r5));
  }
  _createResources() {
    if (r(this._createResourcesPromise))
      return this._createResourcesPromise;
    this._getBlock(N), this._getBlock(O), F("Initializing AttributeStore");
    const e4 = { shared: M.sharedArrayBuffer && !("local" === this._client.type), size: this._size, blocks: v(this._blocks, (t3) => ({ textureOnly: t3.textureOnly, buffer: t3.buffer, pixelType: t3.pixelType })) }, i2 = this._client.initialize(e4, this._signal).catch((e5) => {
      g(e5) ? this._createResourcesPromise = null : C.error(new s2("mapview-attribute-store", "Encountered an error during client initialization", e5));
    });
    return this._createResourcesPromise = i2, i2.then(() => t(this._createResourcesPromise) ? this._createResources() : void 0), i2;
  }
  _getBlock(t3) {
    const e4 = this._blocks[t3];
    if (r(e4))
      return e4;
    F(`Initializing AttributeBlock at index ${t3}`);
    const i2 = M.sharedArrayBuffer, s4 = this._client.type, r5 = new v2(i2, s4, this._size, this._blockDescriptors[t3]);
    return this._blocks[t3] = r5, this._createResourcesPromise = null, r5;
  }
  _expand() {
    if (this._size < this.config.maxTextureSize) {
      const t3 = this._size <<= 1;
      return F("Expanding block size to", t3, this._blocks), A(this._blocks, (e4) => e4.expand(t3)), this._createResourcesPromise = null, this._size = t3, 0;
    }
    return C.error(new s2("mapview-limitations", "Maximum number of onscreen features exceeded.")), -1;
  }
  async _updateFilter(t3, e4, i2, s4) {
    const o3 = this._filters[e4], n4 = r(o3) && o3.hash;
    if (!o3 && !t3)
      return false;
    if (n4 === JSON.stringify(t3))
      return false;
    if (t(t3)) {
      if (!o3)
        return false;
      const t4 = 1 << e4 + 1, i3 = this._getBlock(0);
      return this._filters[e4] = null, i3.setComponentAllTexels(0, t4), this.sendUpdates(), true;
    }
    const l2 = await this._getFilter(e4, i2);
    return await l2.update(t3, s4), true;
  }
  async _getFilter(t3, e4) {
    const i2 = this._filters[t3];
    if (r(i2))
      return i2;
    const { default: s4 } = await import("./FeatureFilter-Z763KGOJ.js"), r5 = new s4({ geometryType: e4.geometryType, hasM: false, hasZ: false, timeInfo: e4.timeInfo, fieldsIndex: new d(e4.fields) });
    return this._filters[t3] = r5, r5;
  }
  isVisible(t3) {
    return !!(2 & this._getBlock(0).getData(t3, 0));
  }
  getFilterFlags(t3) {
    let e4 = 0;
    const i2 = i(t3.getDisplayId());
    for (let a2 = 0; a2 < this._filters.length; a2++) {
      const s5 = !!(i2 & 1 << a2), o3 = this._filters[a2];
      e4 |= (!s5 || t(o3) || o3.check(t3) ? 1 : 0) << a2;
    }
    let s4 = 0;
    if (this._idsToHighlight.size) {
      const e5 = t3.getObjectId();
      s4 = this.getHighlightFlag(e5);
    }
    return e4 << 1 | s4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/DisplayIdGenerator.js
var r3 = class {
  constructor() {
    this._freeIds = [], this._idCounter = 1;
  }
  createId(r5 = false) {
    return s3(this._getFreeId(), r5);
  }
  releaseId(e4) {
    this._freeIds.push(e4);
  }
  _getFreeId() {
    return this._freeIds.length ? this._freeIds.pop() : this._idCounter++;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedAttributeStorage.js
function n3(t3, e4, s4) {
  if (!(t3.length > e4))
    for (; t3.length <= e4; )
      t3.push(s4);
}
var r4 = class {
  constructor() {
    this._numerics = [], this._strings = [], this._idGenerator = new r3(), this._allocatedSize = 256, this._bitsets = [], this._instanceIds = [], this._bounds = [];
  }
  createBitset() {
    const e4 = this._bitsets.length;
    return this._bitsets.push(t2.create(this._allocatedSize, n)), e4 + 1;
  }
  getBitset(t3) {
    return this._bitsets[t3 - 1];
  }
  _expand() {
    this._allocatedSize <<= 1;
    for (const t3 of this._bitsets)
      t3.resize(this._allocatedSize);
  }
  _ensureNumeric(t3, e4) {
    this._numerics[t3] || (this._numerics[t3] = []);
    n3(this._numerics[t3], e4, 0);
  }
  _ensureInstanceId(t3) {
    n3(this._instanceIds, t3, 0);
  }
  _ensureString(t3, e4) {
    this._strings[t3] || (this._strings[t3] = []);
    n3(this._strings[t3], e4, null);
  }
  createDisplayId(t3 = false) {
    const s4 = this._idGenerator.createId();
    return s4 > this._allocatedSize && this._expand(), s3(s4, t3);
  }
  releaseDisplayId(e4) {
    for (const t3 of this._bitsets)
      t3.unset(e4);
    return this._idGenerator.releaseId(e4 & n);
  }
  getComputedNumeric(e4, s4) {
    return this.getComputedNumericAtIndex(e4 & n, 0);
  }
  setComputedNumeric(e4, s4, i2) {
    return this.setComputedNumericAtIndex(e4 & n, i2, 0);
  }
  getComputedString(e4, s4) {
    return this.getComputedStringAtIndex(e4 & n, 0);
  }
  setComputedString(e4, s4, i2) {
    return this.setComputedStringAtIndex(e4 & n, 0, i2);
  }
  getComputedNumericAtIndex(e4, s4) {
    const i2 = e4 & n;
    return this._ensureNumeric(s4, i2), this._numerics[s4][i2];
  }
  setComputedNumericAtIndex(e4, s4, i2) {
    const n4 = e4 & n;
    this._ensureNumeric(s4, n4), this._numerics[s4][n4] = i2;
  }
  getInstanceId(e4) {
    const s4 = e4 & n;
    return this._ensureInstanceId(s4), this._instanceIds[s4];
  }
  setInstanceId(e4, s4) {
    const i2 = e4 & n;
    this._ensureInstanceId(i2), this._instanceIds[i2] = s4;
  }
  getComputedStringAtIndex(e4, s4) {
    const i2 = e4 & n;
    return this._ensureString(s4, i2), this._strings[s4][i2];
  }
  setComputedStringAtIndex(e4, s4, i2) {
    const n4 = e4 & n;
    this._ensureString(s4, n4), this._strings[s4][n4] = i2;
  }
  getXMin(e4) {
    return this._bounds[4 * (e4 & n)];
  }
  getYMin(e4) {
    return this._bounds[4 * (e4 & n) + 1];
  }
  getXMax(e4) {
    return this._bounds[4 * (e4 & n) + 2];
  }
  getYMax(e4) {
    return this._bounds[4 * (e4 & n) + 3];
  }
  setBounds(e4, s4) {
    const i2 = s4.readHydratedGeometry();
    if (!i2 || !i2.coords.length)
      return false;
    let r5 = 1 / 0, u2 = 1 / 0, o3 = -1 / 0, h = -1 / 0;
    i2.forEachVertex((t3, e5) => {
      r5 = Math.min(r5, t3), u2 = Math.min(u2, e5), o3 = Math.max(o3, t3), h = Math.max(h, e5);
    });
    const d3 = e4 & n;
    return n3(this._bounds, 4 * d3 + 4, 0), this._bounds[4 * d3] = r5, this._bounds[4 * d3 + 1] = u2, this._bounds[4 * d3 + 2] = o3, this._bounds[4 * d3 + 3] = h, true;
  }
};

export {
  d2 as d,
  R,
  r4 as r
};
//# sourceMappingURL=chunk-SNC4BDIX.js.map
