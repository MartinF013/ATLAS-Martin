import {
  ee
} from "./chunk-436X6OVY.js";
import {
  t as t2
} from "./chunk-RB2H3SKO.js";
import {
  l,
  n,
  r as r2
} from "./chunk-PNNMRFHO.js";
import {
  n as n2,
  o
} from "./chunk-5CPRHNFX.js";
import {
  e as e2,
  t as t3
} from "./chunk-IYLBVJ6T.js";
import {
  u
} from "./chunk-EJ7RFMRW.js";
import {
  D,
  G,
  P
} from "./chunk-FPMD6IB4.js";
import {
  r as r3
} from "./chunk-MEW2XKT2.js";
import {
  e
} from "./chunk-PQO66WZ2.js";
import {
  a
} from "./chunk-ZZY5IDKU.js";
import {
  u as u2
} from "./chunk-M2WA2LMI.js";
import {
  U
} from "./chunk-65A2N4LL.js";
import {
  Bt
} from "./chunk-5N3FSR63.js";
import {
  E,
  g
} from "./chunk-U3PSONS6.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/debugging.js
function t4(t6, e5, n4, o4, l5, i4) {
  t6.fillStyle = e5, t6.fillRect(n4, o4, l5, i4);
}
function e3(t6, e5, n4, o4, l5, i4) {
  t6.strokeStyle = e5, t6.strokeRect(n4, o4, l5, i4);
}
function o2(n4, o4) {
  const l5 = window.COLLISION_XRAY;
  for (let i4 = 0; i4 < o4.length; ++i4) {
    const r7 = !o4[i4].unique.show;
    if (l5 || !r7)
      for (const s3 of o4[i4].colliders) {
        if (!s3.enabled)
          continue;
        const d = !o4[i4].unique.parts[s3.partIndex].show;
        if (!l5 && d)
          continue;
        const a3 = s3.xScreen, c2 = s3.yScreen, m = s3.dxScreen, h = s3.dyScreen;
        n4.globalAlpha = r7 || d ? 0.2 : 1, t4(n4, "green", a3 - 1, c2 - 1, 3, 3), e3(n4, "red", a3 + m, c2 + h, s3.width, s3.height), t4(n4, "blue", a3 + m - 1, c2 + h - 1, 3, 3), n4.globalAlpha = 1;
      }
  }
}
function l2(t6, e5, n4) {
  if (!window.PERFORMANCE_RECORDING_STORAGE)
    return;
  const o4 = window.PERFORMANCE_RECORDING_STORAGE;
  o4.perf = o4.perf || {};
  const l5 = o4.perf;
  l5[t6] = l5[t6] || { start: null, time: 0, min: void 0, max: void 0, samples: [], unit: n4 }, l5[t6].time += e5, l5[t6].samples.push(e5), (null == l5[t6].min || e5 < l5[t6].min) && (l5[t6].min = e5), (null == l5[t6].max || e5 > l5[t6].max) && (l5[t6].max = e5);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e4 = class {
  constructor(e5, t6) {
    this._width = 0, this._height = 0, this._free = [], this._width = e5, this._height = t6, this._free.push(new t2(0, 0, e5, t6));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e5, t6) {
    if (e5 > this._width || t6 > this._height)
      return new t2();
    let i4 = null, s3 = -1;
    for (let h = 0; h < this._free.length; ++h) {
      const w = this._free[h];
      e5 <= w.width && t6 <= w.height && (null === i4 || w.y <= i4.y && w.x <= i4.x) && (i4 = w, s3 = h);
    }
    return null === i4 ? new t2() : (this._free.splice(s3, 1), i4.width < i4.height ? (i4.width > e5 && this._free.push(new t2(i4.x + e5, i4.y, i4.width - e5, t6)), i4.height > t6 && this._free.push(new t2(i4.x, i4.y + t6, i4.width, i4.height - t6))) : (i4.width > e5 && this._free.push(new t2(i4.x + e5, i4.y, i4.width - e5, i4.height)), i4.height > t6 && this._free.push(new t2(i4.x, i4.y + t6, e5, i4.height - t6))), new t2(i4.x, i4.y, e5, t6));
  }
  release(h) {
    for (let e5 = 0; e5 < this._free.length; ++e5) {
      const t6 = this._free[e5];
      if (t6.y === h.y && t6.height === h.height && t6.x + t6.width === h.x)
        t6.width += h.width;
      else if (t6.x === h.x && t6.width === h.width && t6.y + t6.height === h.y)
        t6.height += h.height;
      else if (h.y === t6.y && h.height === t6.height && h.x + h.width === t6.x)
        t6.x = h.x, t6.width += h.width;
      else {
        if (h.x !== t6.x || h.width !== t6.width || h.y + h.height !== t6.y)
          continue;
        t6.y = h.y, t6.height += h.height;
      }
      this._free.splice(e5, 1), this.release(h);
    }
    this._free.push(h);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var r4 = class {
  constructor(e5, i4, s3) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e5, this.height = i4, this._glyphSource = s3, this._binPack = new e4(e5 - 4, i4 - 4), this._glyphData.push(new Uint8Array(e5 * i4)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(i4, s3) {
    const h = [], r7 = this._glyphSource, n4 = /* @__PURE__ */ new Set(), a3 = 1 / 256;
    for (const t6 of s3) {
      const e5 = Math.floor(t6 * a3);
      n4.add(e5);
    }
    const o4 = [];
    return n4.forEach((t6) => {
      if (t6 <= 256) {
        const e5 = i4 + t6;
        if (this._rangePromises.has(e5))
          o4.push(this._rangePromises.get(e5));
        else {
          const s4 = r7.getRange(i4, t6).then(() => {
            this._rangePromises.delete(e5);
          }, () => {
            this._rangePromises.delete(e5);
          });
          this._rangePromises.set(e5, s4), o4.push(s4);
        }
      }
    }), Promise.all(o4).then(() => {
      let n5 = this._glyphIndex[i4];
      n5 || (n5 = {}, this._glyphIndex[i4] = n5);
      for (const a4 of s3) {
        const s4 = n5[a4];
        if (s4) {
          h[a4] = { sdf: true, rect: s4.rect, metrics: s4.metrics, page: s4.page, code: a4 };
          continue;
        }
        const o5 = r7.getGlyph(i4, a4);
        if (!o5 || !o5.metrics)
          continue;
        const l5 = o5.metrics;
        let c2;
        if (0 === l5.width)
          c2 = new t2(0, 0, 0, 0);
        else {
          const e5 = 3, i5 = l5.width + 2 * e5, s5 = l5.height + 2 * e5;
          let h2 = i5 % 4 ? 4 - i5 % 4 : 4, r8 = s5 % 4 ? 4 - s5 % 4 : 4;
          1 === h2 && (h2 = 5), 1 === r8 && (r8 = 5), c2 = this._binPack.allocate(i5 + h2, s5 + r8), c2.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e4(this.width - 4, this.height - 4), c2 = this._binPack.allocate(i5 + h2, s5 + r8));
          const n6 = this._glyphData[this._currentPage], a5 = o5.bitmap;
          let g2, _2;
          if (a5)
            for (let t6 = 0; t6 < s5; t6++) {
              g2 = i5 * t6, _2 = this.width * (c2.y + t6 + 1) + c2.x;
              for (let t7 = 0; t7 < i5; t7++)
                n6[_2 + t7 + 1] = a5[g2 + t7];
            }
        }
        n5[a4] = { rect: c2, metrics: l5, tileIDs: null, page: this._currentPage }, h[a4] = { sdf: true, rect: c2, metrics: l5, page: this._currentPage, code: a4 }, this._dirties[this._currentPage] = true;
      }
      return h;
    });
  }
  removeGlyphs(t6) {
    for (const e5 in this._glyphIndex) {
      const i4 = this._glyphIndex[e5];
      if (!i4)
        continue;
      let s3;
      for (const e6 in i4)
        if (s3 = i4[e6], s3.tileIDs.delete(t6), 0 === s3.tileIDs.size) {
          const t7 = this._glyphData[s3.page], h = s3.rect;
          let r7, n4;
          for (let e7 = 0; e7 < h.height; e7++)
            for (r7 = this.width * (h.y + e7) + h.x, n4 = 0; n4 < h.width; n4++)
              t7[r7 + n4] = 0;
          delete i4[e6], this._dirties[s3.page] = true;
        }
    }
  }
  bind(t6, e5, r7, n4 = 0) {
    this._textures[r7] || (this._textures[r7] = new u(t6, { pixelFormat: P.ALPHA, dataType: G.UNSIGNED_BYTE, width: this.width, height: this.height }, new Uint8Array(this.width * this.height)));
    const a3 = this._textures[r7];
    a3.setSamplingMode(e5), this._dirties[r7] && a3.setData(this._glyphData[r7]), t6.bindTexture(a3, n4), this._dirties[r7] = false;
  }
  dispose() {
    this._binPack = null;
    for (const t6 of this._textures)
      t6 && t6.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s = class {
  constructor(e5) {
    if (this._metrics = [], this._bitmaps = [], e5)
      for (; e5.next(); )
        switch (e5.tag()) {
          case 1: {
            const t6 = e5.getMessage();
            for (; t6.next(); )
              switch (t6.tag()) {
                case 3: {
                  const e6 = t6.getMessage();
                  let s3, a3, r7, n4, i4, c2, g2;
                  for (; e6.next(); )
                    switch (e6.tag()) {
                      case 1:
                        s3 = e6.getUInt32();
                        break;
                      case 2:
                        a3 = e6.getBytes();
                        break;
                      case 3:
                        r7 = e6.getUInt32();
                        break;
                      case 4:
                        n4 = e6.getUInt32();
                        break;
                      case 5:
                        i4 = e6.getSInt32();
                        break;
                      case 6:
                        c2 = e6.getSInt32();
                        break;
                      case 7:
                        g2 = e6.getUInt32();
                        break;
                      default:
                        e6.skip();
                    }
                  e6.release(), s3 && (this._metrics[s3] = { width: r7, height: n4, left: i4, top: c2, advance: g2 }, this._bitmaps[s3] = a3);
                  break;
                }
                default:
                  t6.skip();
              }
            t6.release();
            break;
          }
          default:
            e5.skip();
        }
  }
  getMetrics(e5) {
    return this._metrics[e5];
  }
  getBitmap(e5) {
    return this._bitmaps[e5];
  }
};
var a2 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e5) {
    return this._ranges[e5];
  }
  addRange(e5, t6) {
    this._ranges[e5] = t6;
  }
};
var r5 = class {
  constructor(e5) {
    this._glyphInfo = {}, this._baseURL = e5;
  }
  getRange(a3, r7) {
    const n4 = this._getFontStack(a3);
    if (n4.getRange(r7))
      return Promise.resolve();
    const i4 = 256 * r7, c2 = i4 + 255;
    if (this._baseURL) {
      const g2 = this._baseURL.replace("{fontstack}", a3).replace("{range}", i4 + "-" + c2);
      return U(g2, { responseType: "array-buffer" }).then((e5) => {
        n4.addRange(r7, new s(new a(new Uint8Array(e5.data), new DataView(e5.data))));
      }).catch(() => {
        n4.addRange(r7, new s());
      });
    }
    return n4.addRange(r7, new s()), Promise.resolve();
  }
  getGlyph(e5, t6) {
    const s3 = this._getFontStack(e5);
    if (!s3)
      return;
    const a3 = Math.floor(t6 / 256);
    if (a3 > 256)
      return;
    const r7 = s3.getRange(a3);
    return r7 ? { metrics: r7.getMetrics(t6), bitmap: r7.getBitmap(t6) } : void 0;
  }
  _getFontStack(e5) {
    let t6 = this._glyphInfo[e5];
    return t6 || (t6 = this._glyphInfo[e5] = new a2()), t6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var o3 = "dasharray-";
var _ = class {
  constructor(t6, e5, s3 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, (t6 <= 0 || e5 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t6, this._pageHeight = e5, s3 > 0 && (this._maxItemSize = s3), this._binPack = new e4(t6 - 4, e5 - 4);
  }
  dispose() {
    this._binPack = null, this._mosaicRects = {};
    for (const t6 of this._textures)
      t6 && t6.dispose();
    this._textures.length = 0;
  }
  getWidth(t6) {
    return t6 >= this._size.length ? -1 : this._size[t6][0];
  }
  getHeight(t6) {
    return t6 >= this._size.length ? -1 : this._size[t6][1];
  }
  getPageSize(t6) {
    return t6 >= this._size.length ? null : this._size[t6];
  }
  setSpriteSource(t6) {
    if (this.dispose(), this.pixelRatio = t6.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e4(this._pageWidth - 4, this._pageHeight - 4);
      const t7 = Math.floor(this._pageWidth), e5 = Math.floor(this._pageHeight), s3 = new Uint32Array(t7 * e5);
      this._mosaicsData[0] = s3, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t6;
  }
  getSpriteItem(t6, i4 = false) {
    let e5, s3, h = this._mosaicRects[t6];
    if (h)
      return h;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus)
      return null;
    if (t6 && t6.startsWith(o3) ? ([e5, s3] = this._rasterizeDash(t6), i4 = true) : e5 = this._sprites.getSpriteInfo(t6), !e5 || !e5.width || !e5.height || e5.width < 0 || e5.height < 0)
      return null;
    const a3 = e5.width, r7 = e5.height, [_2, n4, g2] = this._allocateImage(a3, r7);
    return _2.width <= 0 ? null : (this._copy(_2, e5, n4, g2, i4, s3), h = { rect: _2, width: a3, height: r7, sdf: e5.sdf, simplePattern: false, pixelRatio: e5.pixelRatio, page: n4 }, this._mosaicRects[t6] = h, h);
  }
  getSpriteItems(t6) {
    const i4 = {};
    for (const e5 of t6)
      i4[e5.name] = this.getSpriteItem(e5.name, e5.repeat);
    return i4;
  }
  getMosaicItemPosition(t6, i4) {
    const e5 = this.getSpriteItem(t6, i4), s3 = e5 && e5.rect;
    if (!s3)
      return null;
    s3.width = e5.width, s3.height = e5.height;
    const h = e5.width, a3 = e5.height, r7 = 2;
    return { tl: [s3.x + r7, s3.y + r7], br: [s3.x + r7 + h, s3.y + r7 + a3], page: e5.page };
  }
  bind(t6, i4, e5 = 0, o4 = 0) {
    this._textures[e5] || (this._textures[e5] = new u(t6, { pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D.CLAMP_TO_EDGE, width: this._size[e5][0], height: this._size[e5][1] }, new Uint8Array(this._mosaicsData[e5].buffer)));
    const _2 = this._textures[e5];
    _2.setSamplingMode(i4), this._dirties[e5] && _2.setData(new Uint8Array(this._mosaicsData[e5].buffer)), t6.bindTexture(_2, o4), this._dirties[e5] = false;
  }
  static _copyBits(t6, i4, e5, s3, h, a3, r7, o4, _2, n4, g2) {
    let p = s3 * i4 + e5, c2 = o4 * a3 + r7;
    if (g2) {
      c2 -= a3;
      for (let r8 = -1; r8 <= n4; r8++, p = ((r8 + n4) % n4 + s3) * i4 + e5, c2 += a3)
        for (let i5 = -1; i5 <= _2; i5++)
          h[c2 + i5] = t6[p + (i5 + _2) % _2];
    } else
      for (let l5 = 0; l5 < n4; l5++) {
        for (let i5 = 0; i5 < _2; i5++)
          h[c2 + i5] = t6[p + i5];
        p += i4, c2 += a3;
      }
  }
  _copy(t6, i4, e5, s3, h, a3) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || e5 >= this._mosaicsData.length)
      return;
    const r7 = new Uint32Array(a3 ? a3.buffer : this._sprites.image.buffer), o4 = this._mosaicsData[e5];
    o4 && r7 || console.error("Source or target images are uninitialized!");
    const n4 = 2, g2 = a3 ? i4.width : this._sprites.width;
    _._copyBits(r7, g2, i4.x, i4.y, o4, s3[0], t6.x + n4, t6.y + n4, i4.width, i4.height, h), this._dirties[e5] = true;
  }
  _allocateImage(t6, s3) {
    t6 += 2, s3 += 2;
    const h = Math.max(t6, s3);
    if (this._maxItemSize && this._maxItemSize < h) {
      const i4 = new t2(0, 0, t6, s3);
      return this._mosaicsData.push(new Uint32Array(t6 * s3)), this._dirties.push(true), this._size.push([t6, s3]), this._textures.push(void 0), [i4, this._mosaicsData.length - 1, [t6, s3]];
    }
    let a3 = t6 % 4 ? 4 - t6 % 4 : 4, r7 = s3 % 4 ? 4 - s3 % 4 : 4;
    1 === a3 && (a3 = 5), 1 === r7 && (r7 = 5);
    const o4 = this._binPack.allocate(t6 + a3, s3 + r7);
    return o4.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e4(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t6, s3)) : [o4, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i4) {
    const e5 = /\[(.*?)\]/, s3 = i4.match(e5);
    if (!s3)
      return null;
    const h = s3[1].split(",").map(Number), a3 = i4.slice(i4.lastIndexOf("-") + 1), [r7, o4, _2] = ee.rasterizeDash(h, a3);
    return [{ x: 0, y: 0, width: o4, height: _2, sdf: true, pixelRatio: 1 }, new Uint8Array(r7.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var c = class {
  constructor(e5, t6, s3) {
    this._layer = e5, this._styleRepository = t6, this.devicePixelRatio = s3, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null;
  }
  destroy() {
    this._connection && (this._connection.close(), this._connection = null), this._styleRepository = null, this._layer = null, this._spriteMosaic && (this._spriteMosaic = null), this._glyphMosaic && (this._glyphMosaic = null);
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(e5) {
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, e5), this._spriteSourcePromise.then((e6) => {
      this._spriteMosaic = new _(1024, 1024, 250), this._spriteMosaic.setSpriteSource(e6);
    });
    const t6 = new r5(this._layer.currentStyleInfo.glyphsUrl ? Bt(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new r4(1024, 1024, t6), this._broadcastPromise = u2("WorkerTileHandler", { client: this, schedule: e5.schedule, signal: e5.signal }).then((t7) => {
      this._connection = t7, this._connection.broadcast("setStyle", this._layer.currentStyleInfo.style, e5);
    });
  }
  async updateStyle(e5) {
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", e5)), this._broadcastPromise;
  }
  setSpriteSource(e5) {
    const t6 = new _(1024, 1024, 250);
    return t6.setSpriteSource(e5), this._spriteMosaic = t6, this._spriteSourcePromise = Promise.resolve(e5), t6;
  }
  async setStyle(e5, t6) {
    await this._broadcastPromise, this._styleRepository = e5, this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, null), this._spriteSourcePromise.then((e6) => {
      this._spriteMosaic = new _(1024, 1024, 250), this._spriteMosaic.setSpriteSource(e6);
    });
    const r7 = new r5(this._layer.currentStyleInfo.glyphsUrl ? Bt(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new r4(1024, 1024, r7), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", t6)), this._broadcastPromise;
  }
  fetchTileData(e5, t6) {
    return this._getRefKeys(e5, t6).then((e6) => {
      const s3 = this._layer.sourceNameToSource, r7 = [];
      for (const t7 in s3)
        r7.push(t7);
      return this._getSourcesData(r7, e6, t6);
    });
  }
  parseTileData(e5, t6) {
    const s3 = e5 && e5.data;
    if (!s3)
      return Promise.resolve(null);
    const { sourceName2DataAndRefKey: r7, transferList: i4 } = s3;
    return 0 === Object.keys(r7).length ? Promise.resolve(null) : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: e5.key.id, sourceName2DataAndRefKey: r7, styleLayerUIDs: e5.styleLayerUIDs }, { ...t6, transferList: i4 }));
  }
  async getSprites(e5) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(e5);
  }
  getGlyphs(e5) {
    return this._glyphMosaic.getGlyphItems(e5.font, e5.codePoints);
  }
  perfReport({ key: e5, milliseconds: t6 }) {
    l2(e5, t6, "ms");
  }
  async _getTilePayload(t6, s3, r7) {
    const i4 = e.pool.acquire(t6.id), o4 = this._layer.sourceNameToSource[s3], { level: l5, row: a3, col: c2 } = i4;
    e.pool.release(i4);
    try {
      return { protobuff: await o4.requestTile(l5, a3, c2, r7), sourceName: s3 };
    } catch (h) {
      if (g(h))
        throw h;
      return { protobuff: null, sourceName: s3 };
    }
  }
  _getRefKeys(e5, s3) {
    const r7 = this._layer.sourceNameToSource, i4 = new Array();
    for (const t6 in r7) {
      const o4 = r7[t6].getRefKey(e5, s3);
      i4.push(o4);
    }
    return E(i4);
  }
  _getSourcesData(e5, s3, r7) {
    const i4 = [];
    for (let t6 = 0; t6 < s3.length; t6++)
      if (null == s3[t6].value || null == e5[t6])
        i4.push(null);
      else {
        const o4 = this._getTilePayload(s3[t6].value, e5[t6], r7);
        i4.push(o4);
      }
    return E(i4).then((e6) => {
      const t6 = {}, r8 = [];
      for (let i5 = 0; i5 < e6.length; i5++)
        if (e6[i5].value && e6[i5].value && e6[i5].value.protobuff && e6[i5].value.protobuff.byteLength > 0) {
          const o4 = s3[i5].value.id;
          t6[e6[i5].value.sourceName] = { refKey: o4, protobuff: e6[i5].value.protobuff }, r8.push(e6[i5].value.protobuff);
        }
      return { sourceName2DataAndRefKey: t6, transferList: r8 };
    });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i(e5, t6, n4, o4, i4, l5) {
  const { iconRotationAlignment: a3, textRotationAlignment: c2, iconTranslate: h, iconTranslateAnchor: u3, textTranslate: d, textTranslateAnchor: y } = o4;
  let x = 0;
  for (const g2 of e5.colliders) {
    const [e6, o5] = 0 === g2.partIndex ? h : d, m = 0 === g2.partIndex ? u3 : y, f = g2.minLod <= l5 && l5 <= g2.maxLod;
    x += f ? 0 : 1, g2.enabled = f, g2.xScreen = g2.xTile * i4[0] + g2.yTile * i4[3] + i4[6], g2.yScreen = g2.xTile * i4[1] + g2.yTile * i4[4] + i4[7], m === r2.MAP ? (g2.xScreen += n4 * e6 - t6 * o5, g2.yScreen += t6 * e6 + n4 * o5) : (g2.xScreen += e6, g2.yScreen += o5), l.VIEWPORT === (0 === g2.partIndex ? a3 : c2) ? (g2.dxScreen = g2.dxPixels, g2.dyScreen = g2.dyPixels) : (g2.dxScreen = n4 * (g2.dxPixels + g2.width / 2) - t6 * (g2.dyPixels + g2.height / 2) - g2.width / 2, g2.dyScreen = t6 * (g2.dxPixels + g2.width / 2) + n4 * (g2.dyPixels + g2.height / 2) - g2.height / 2);
  }
  e5.colliders.length > 0 && x === e5.colliders.length && (e5.unique.show = false);
}
var l3 = class {
  constructor(o4, r7, s3, i4, l5, a3) {
    this._symbols = o4, this._styleRepository = i4, this._zoom = l5, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new n2(r7, s3, t3), this._si = Math.sin(Math.PI * a3 / 180), this._co = Math.cos(Math.PI * a3 / 180);
    for (const t6 of o4)
      for (const n4 of t6.symbols)
        this._allNeededMatrices.has(n4.tile) || this._allNeededMatrices.set(n4.tile, r3(n4.tile.transforms.tileUnitsToPixels));
  }
  work(e5) {
    const t6 = this._gridIndex;
    function n4(e6) {
      const n5 = e6.xScreen + e6.dxScreen, o5 = e6.yScreen + e6.dyScreen, r7 = n5 + e6.width, s3 = o5 + e6.height, [i4, l5, a3, c2] = t6.getCellSpan(n5, o5, r7, s3);
      for (let h = l5; h <= c2; h++)
        for (let e7 = i4; e7 <= a3; e7++) {
          const i5 = t6.cells[h][e7];
          for (const e8 of i5) {
            const t7 = e8.xScreen + e8.dxScreen, i6 = e8.yScreen + e8.dyScreen, l6 = t7 + e8.width, a4 = i6 + e8.height;
            if (!(r7 < t7 || n5 > l6 || s3 < i6 || o5 > a4))
              return true;
          }
        }
      return false;
    }
    const o4 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t7 = this._symbols[this._currentLayerCursor], r7 = this._getProperties(t7.styleLayerUID);
      for (; this._currentSymbolCursor < t7.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o4 > e5)
          return false;
        const s3 = t7.symbols[this._currentSymbolCursor];
        if (!s3.unique.show)
          continue;
        i(s3, this._si, this._co, r7, this._allNeededMatrices.get(s3.tile), this._zoom);
        const l5 = s3.unique;
        if (!l5.show)
          continue;
        const { iconAllowOverlap: a3, iconIgnorePlacement: c2, textAllowOverlap: h, textIgnorePlacement: u3 } = r7;
        for (const e6 of s3.colliders) {
          if (!e6.enabled)
            continue;
          const t8 = l5.parts[e6.partIndex];
          if (!t8.show)
            continue;
          !(e6.partIndex ? h : a3) && n4(e6) && (e6.hard ? l5.show = false : t8.show = false);
        }
        if (l5.show)
          for (const e6 of s3.colliders) {
            if (!e6.enabled)
              continue;
            if (e6.partIndex ? u3 : c2)
              continue;
            if (!l5.parts[e6.partIndex].show)
              continue;
            const t8 = e6.xScreen + e6.dxScreen, n5 = e6.yScreen + e6.dyScreen, o5 = t8 + e6.width, r8 = n5 + e6.height, [s4, i4, a4, h2] = this._gridIndex.getCellSpan(t8, n5, o5, r8);
            for (let l6 = i4; l6 <= h2; l6++)
              for (let t9 = s4; t9 <= a4; t9++) {
                this._gridIndex.cells[l6][t9].push(e6);
              }
          }
      }
    }
    return true;
  }
  _getProperties(e5) {
    const t6 = this._styleProps.get(e5);
    if (t6)
      return t6;
    const n4 = this._zoom, s3 = this._styleRepository.getStyleLayerByUID(e5), i4 = s3.getLayoutValue("symbol-placement", n4) !== n.POINT;
    let l5 = s3.getLayoutValue("icon-rotation-alignment", n4);
    l5 === l.AUTO && (l5 = i4 ? l.MAP : l.VIEWPORT);
    let a3 = s3.getLayoutValue("text-rotation-alignment", n4);
    a3 === l.AUTO && (a3 = i4 ? l.MAP : l.VIEWPORT);
    const c2 = s3.getPaintValue("icon-translate", n4), h = s3.getPaintValue("icon-translate-anchor", n4), u3 = s3.getPaintValue("text-translate", n4), d = s3.getPaintValue("text-translate-anchor", n4), y = { iconAllowOverlap: s3.getLayoutValue("icon-allow-overlap", n4), iconIgnorePlacement: s3.getLayoutValue("icon-ignore-placement", n4), textAllowOverlap: s3.getLayoutValue("text-allow-overlap", n4), textIgnorePlacement: s3.getLayoutValue("text-ignore-placement", n4), iconRotationAlignment: l5, textRotationAlignment: a3, iconTranslateAnchor: h, iconTranslate: c2, textTranslateAnchor: d, textTranslate: u3 };
    return this._styleProps.set(e5, y), y;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function t5(o4, e5) {
  if (o4.priority - e5.priority)
    return o4.priority - e5.priority;
  const t6 = o4.tile.key, i4 = e5.tile.key;
  return t6.world - i4.world ? t6.world - i4.world : t6.level - i4.level ? t6.level - i4.level : t6.row - i4.row ? t6.row - i4.row : t6.col - i4.col ? t6.col - i4.col : o4.xTile - e5.xTile ? o4.xTile - e5.xTile : o4.yTile - e5.yTile;
}
var i2 = class {
  constructor(o4, e5, t6, i4, s3, r7) {
    this._visibleTiles = o4, this._symbolRepository = e5, this._createCollisionJob = t6, this._assignTileSymbolsOpacity = i4, this._symbolLayerSorter = s3, this._isLayerVisible = r7, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  get running() {
    return this._running;
  }
  setScreenSize(o4, e5) {
    this._screenWidth === o4 && this._screenHeight === e5 || this.restart(), this._screenWidth = o4, this._screenHeight = e5;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o4) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const e5 = performance.now();
      if (!this._selectionJob.work(o4))
        return false;
      if (this._selectionJobCompleted = true, 0 === (o4 = Math.max(0, o4 - (performance.now() - e5))))
        return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const e5 = performance.now();
      if (!this._collisionJob.work(o4))
        return false;
      if (this._collisionJobCompleted = true, 0 === (o4 = Math.max(0, o4 - (performance.now() - e5))))
        return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const e5 = performance.now();
      if (!this._opacityJob.work(o4))
        return false;
      if (this._opacityJobCompleted = true, 0 === (o4 = Math.max(0, o4 - (performance.now() - e5))))
        return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o4 = this._symbolRepository.uniqueSymbols;
    for (let t6 = 0; t6 < o4.length; t6++) {
      const e6 = o4[t6];
      for (let o5 = 0; o5 < e6.uniqueSymbols.length; o5++) {
        const t7 = e6.uniqueSymbols[o5];
        for (const o6 of t7.tileSymbols)
          o6.selectedForRendering = false;
      }
    }
    const e5 = [];
    let i4 = 0, s3 = 0;
    const r7 = this._isLayerVisible;
    function n4(n5) {
      let l6;
      const c2 = performance.now();
      for (; s3 < o4.length; s3++, i4 = 0) {
        const t6 = o4[s3], h = t6.styleLayerUID;
        if (!r7(h)) {
          e5[s3] || (e5[s3] = { styleLayerUID: h, symbols: [] });
          continue;
        }
        e5[s3] = e5[s3] || { styleLayerUID: h, symbols: [] };
        const a3 = e5[s3];
        for (; i4 < t6.uniqueSymbols.length; i4++) {
          if (l6 = t6.uniqueSymbols[i4], i4 % 100 == 99 && performance.now() - c2 > n5)
            return false;
          let o5 = null, e6 = false, s4 = false;
          for (const t7 of l6.tileSymbols)
            if (!s4 || !e6) {
              const i5 = t7.tile;
              (!o5 || i5.isCoverage || i5.neededForCoverage && !e6) && (o5 = t7, (i5.neededForCoverage || i5.isCoverage) && (s4 = true), i5.isCoverage && (e6 = true));
            }
          if (o5.selectedForRendering = true, s4) {
            a3.symbols.push(o5), l6.show = true;
            for (const o6 of l6.parts)
              o6.show = true;
          } else
            l6.show = false;
        }
      }
      for (const o5 of e5)
        o5.symbols.sort(t5);
      return true;
    }
    const l5 = this._symbolLayerSorter;
    return { work: n4, get sortedSymbols() {
      return e5.sort(l5);
    } };
  }
  _createOpacityJob() {
    const e5 = this._assignTileSymbolsOpacity, t6 = this._visibleTiles;
    let i4 = 0;
    function r7(o4, t7) {
      const i5 = o4.symbols;
      for (const [e6, r8] of i5)
        s2(r8, t7);
      e5(o4, t7);
      for (const e6 of o4.childrenTiles)
        r7(e6, t7);
    }
    return { work(e6) {
      const s3 = performance.now();
      for (; i4 < t6.length; i4++) {
        if (performance.now() - s3 > e6)
          return false;
        const n4 = t6[i4];
        if (r(n4.parentTile))
          continue;
        r7(n4, performance.now());
      }
      return true;
    } };
  }
};
function s2(o4, t6) {
  for (const i4 of o4) {
    const o5 = i4.unique;
    for (const i5 of o5.parts) {
      const s3 = i5.targetOpacity > 0.5 ? 1 : -1;
      i5.startOpacity += s3 * ((t6 - i5.startTime) / e2), i5.startOpacity = Math.min(Math.max(i5.startOpacity, 0), 1), i5.startTime = t6, i5.targetOpacity = o5.show && i5.show ? 1 : 0;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var l4 = 32;
var i3 = 8;
var n3 = 64;
var r6 = class {
  constructor(e5, s3, o4) {
    this.tileCoordRange = e5, this._visibleTiles = s3, this._createUnique = o4, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return t(this._uniqueSymbolLayerArray) && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  add(e5, s3) {
    this._uniqueSymbolLayerArray = null;
    let t6 = this._tiles.get(e5.id);
    t6 || (t6 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(e5.id, t6));
    const r7 = /* @__PURE__ */ new Map();
    if (s3)
      for (const o4 of s3)
        t6.symbols.has(o4) && (r7.set(o4, t6.symbols.get(o4)), t6.symbols.delete(o4));
    else
      for (const [o4, l5] of e5.layerData)
        t6.symbols.has(o4) && (r7.set(o4, t6.symbols.get(o4)), t6.symbols.delete(o4));
    this._removeSymbols(r7);
    const y = e5.symbols, a3 = /* @__PURE__ */ new Map();
    for (const [f, c2] of y) {
      let e6 = c2.length;
      if (e6 >= l4) {
        let s4 = this.tileCoordRange;
        do {
          s4 /= 2, e6 /= 4;
        } while (e6 > i3 && s4 > n3);
        const l5 = new n2(this.tileCoordRange, this.tileCoordRange, s4);
        a3.set(f, { flat: c2, index: l5 }), t6.symbols.set(f, { flat: c2, index: l5 });
        for (const e7 of c2)
          l5.getCell(e7.xTile, e7.yTile).push(e7);
      } else
        a3.set(f, { flat: c2 }), t6.symbols.set(f, { flat: c2 });
    }
    this._addSymbols(e5.key, y);
  }
  deleteStyleLayers(e5) {
    this._uniqueSymbolLayerArray = null;
    for (const [s3, o4] of this._tiles) {
      const t6 = /* @__PURE__ */ new Map();
      for (const s4 of e5)
        o4.symbols.has(s4) && (t6.set(s4, o4.symbols.get(s4)), o4.symbols.delete(s4));
      this._removeSymbols(t6), 0 === o4.symbols.size && this._tiles.delete(s3);
    }
  }
  removeTile(e5) {
    this._uniqueSymbolLayerArray = null;
    const s3 = this._tiles.get(e5.id);
    if (!s3)
      return;
    const o4 = /* @__PURE__ */ new Map();
    for (const [t6, l5] of e5.symbols)
      s3.symbols.has(t6) && (o4.set(t6, s3.symbols.get(t6)), s3.symbols.delete(t6));
    this._removeSymbols(o4), 0 === s3.symbols.size && this._tiles.delete(e5.id);
  }
  _removeSymbols(e5) {
    for (const [s3, { flat: o4 }] of e5)
      for (const e6 of o4) {
        const o5 = e6.unique, t6 = o5.tileSymbols, l5 = t6.length - 1;
        for (let s4 = 0; s4 < l5; s4++)
          if (t6[s4] === e6) {
            t6[s4] = t6[l5];
            break;
          }
        if (t6.length = l5, 0 === l5) {
          const e7 = this._uniqueSymbolsReferences.get(s3);
          e7.delete(o5), 0 === e7.size && this._uniqueSymbolsReferences.delete(s3);
        }
        e6.unique = null;
      }
  }
  _addSymbols(s3, o4) {
    if (0 === o4.size)
      return;
    const t6 = this._visibleTiles;
    for (const e5 of t6)
      e5.parentTile || e5.key.world !== s3.world || e5.key.level === s3.level && !e5.key.equals(s3) || this._matchSymbols(e5, s3, o4);
    for (const [l5, i4] of o4)
      for (const s4 of i4)
        if (t(s4.unique)) {
          const e5 = this._createUnique();
          s4.unique = e5, e5.tileSymbols.push(s4);
          let o5 = this._uniqueSymbolsReferences.get(l5);
          o5 || (o5 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(l5, o5)), o5.add(e5);
        }
  }
  _matchSymbols(e5, o4, l5) {
    if (e5.key.level > o4.level) {
      const s3 = e5.key.level - o4.level;
      if (e5.key.row >> s3 !== o4.row || e5.key.col >> s3 !== o4.col)
        return;
    }
    if (o4.level > e5.key.level) {
      const s3 = o4.level - e5.key.level;
      if (o4.row >> s3 !== e5.key.row || o4.col >> s3 !== e5.key.col)
        return;
    }
    if (o4.equals(e5.key)) {
      for (const s3 of e5.childrenTiles)
        this._matchSymbols(s3, o4, l5);
      return;
    }
    const i4 = /* @__PURE__ */ new Map();
    for (const [n4, r7] of l5) {
      const l6 = [];
      for (const s3 of r7) {
        const i5 = o(this.tileCoordRange, s3.xTile, o4.level, o4.col, e5.key.level, e5.key.col), n5 = o(this.tileCoordRange, s3.yTile, o4.level, o4.row, e5.key.level, e5.key.row);
        i5 >= 0 && i5 < this.tileCoordRange && n5 >= 0 && n5 < this.tileCoordRange && l6.push({ symbol: s3, xTransformed: i5, yTransformed: n5 });
      }
      const y = [], a3 = e5.key.level < o4.level ? 1 : 1 << e5.key.level - o4.level, f = this._tiles.get(e5.id).symbols.get(n4);
      if (f) {
        const e6 = f.flat;
        for (const o5 of l6) {
          let t6, l7 = false;
          const i5 = o5.xTransformed, n5 = o5.yTransformed;
          t6 = r(f.index) ? f.index.getCell(i5, n5) : e6;
          const r8 = o5.symbol, c2 = r8.hash;
          for (const e7 of t6)
            if (c2 === e7.hash && Math.abs(i5 - e7.xTile) <= a3 && Math.abs(n5 - e7.yTile) <= a3) {
              const s3 = e7.unique;
              r8.unique = s3, s3.tileSymbols.push(r8), l7 = true;
              break;
            }
          l7 || y.push(r8);
        }
      }
      y.length > 0 && i4.set(n4, y);
    }
    for (const s3 of e5.childrenTiles)
      this._matchSymbols(s3, o4, i4);
  }
  _createUniqueSymbolLayerArray() {
    const e5 = this._uniqueSymbolsReferences, s3 = new Array(e5.size);
    let o4, t6 = 0;
    for (const [l5, i4] of e5) {
      const e6 = new Array(i4.size);
      o4 = 0;
      for (const s4 of i4)
        e6[o4++] = s4;
      s3[t6] = { styleLayerUID: l5, uniqueSymbols: e6 }, t6++;
    }
    return s3;
  }
};

export {
  o2 as o,
  c,
  l3 as l,
  i2 as i,
  r6 as r
};
//# sourceMappingURL=chunk-YEGLNVAS.js.map
