import {
  o as o4
} from "./chunk-JX3YCNPL.js";
import {
  c as c2,
  e as e4
} from "./chunk-KXE4LGFJ.js";
import {
  l as l2,
  n as n2
} from "./chunk-3CED37X7.js";
import {
  f
} from "./chunk-WL7AHHN3.js";
import {
  J,
  Q,
  le,
  me
} from "./chunk-UGLXR5OV.js";
import {
  B,
  C,
  D as D3,
  E as E2,
  F,
  G as G2,
  H,
  M as M2,
  N,
  O,
  P as P2,
  R,
  ct,
  o as o2
} from "./chunk-HH3D3A65.js";
import {
  r as r2
} from "./chunk-567AWHAB.js";
import {
  D as D4
} from "./chunk-Z7AZMEL6.js";
import {
  u as u2
} from "./chunk-EJ7RFMRW.js";
import {
  D as D2,
  G,
  L,
  M,
  P,
  V,
  Y
} from "./chunk-FPMD6IB4.js";
import {
  e as e3
} from "./chunk-MEW2XKT2.js";
import {
  n
} from "./chunk-RB3LJE4I.js";
import {
  l
} from "./chunk-6EODZIDR.js";
import {
  i,
  s as s3
} from "./chunk-3NPGGTI6.js";
import {
  z as z2
} from "./chunk-YZNDHJDJ.js";
import {
  f as f2,
  o as o3
} from "./chunk-ZUDEVIXR.js";
import {
  e as e2
} from "./chunk-YL26MZEL.js";
import {
  m
} from "./chunk-GD6ALUPQ.js";
import {
  z
} from "./chunk-RN2KRYDN.js";
import {
  u
} from "./chunk-NWRK6QLX.js";
import {
  D
} from "./chunk-U3PSONS6.js";
import {
  s2
} from "./chunk-HFTNOKM2.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  A,
  E,
  a,
  c,
  e,
  o,
  r,
  t,
  v
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLTile.js
var m2 = class {
  acquire(s4) {
    return { refCount: 1, version: -1, labelMat2d: e3(), tileMat3: e3(), dvs: e3() };
  }
  release(s4) {
  }
};
var c3 = class extends r2 {
  constructor(s4, t2, r4) {
    super(s4, t2, r4, o2, o2);
  }
  destroy() {
    super.destroy(), this._transforms && c3.TransformCache.release(this.key.hash);
  }
  setTransform(a2, n3) {
    const h2 = n3 / (a2.resolution * a2.pixelRatio), m3 = this.transforms.tileMat3, [c5, f3] = a2.toScreenNoRotation([0, 0], [this.x, this.y]), l3 = this.width / this.rangeX * h2, u3 = this.height / this.rangeY * h2;
    s3(m3, l3, 0, 0, 0, u3, 0, c5, f3, 1), i(this.transforms.dvs, a2.displayViewMat3, m3);
    const d = this.transforms.labelMat2d, p = a2.getScreenTransform(d, n3), j = n();
    z2(j, [this.x, this.y], p), f2(d, j), o3(d, a2.viewMat2d, d);
  }
  _createTransforms() {
    return c3.TransformCache.acquire(this.key.hash);
  }
};
c3.TransformCache = new m2();

// node_modules/@arcgis/core/views/2d/engine/webgl/AttributeStoreView.js
var V2 = s.getLogger("esri.views.2d.engine.webgl.AttributeStoreView");
var L2 = n2(l2, V2);
var G3 = class {
  constructor(t2, e5, i3) {
    this._texture = null, this._lastTexture = null, this._fbos = {}, this.texelSize = 4;
    const { buffer: s4, pixelType: r4, textureOnly: a2 } = t2, d = me(r4);
    this.shared = i3, this.pixelType = r4, this.size = e5, this.textureOnly = a2, a2 || (this.data = new d(e(s4))), this._resetRange();
  }
  destroy() {
    o(this._texture, (t2) => t2.dispose());
    for (const t2 in this._fbos)
      o(this._fbos[t2], (e5) => {
        "0" === t2 && e5.detachColorTexture(), e5.dispose();
      }), this._fbos[t2] = null;
    this._texture = null;
  }
  get _textureDesc() {
    return { target: M.TEXTURE_2D, wrapMode: D2.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: this.pixelType, samplingMode: L.NEAREST, width: this.size, height: this.size };
  }
  setData(t2, e5, i3) {
    const s4 = f(t2), r4 = e(this.data), a2 = s4 * this.texelSize + e5;
    !r4 || a2 >= r4.length || (r4[a2] = i3, this.dirtyStart = Math.min(this.dirtyStart, s4), this.dirtyEnd = Math.max(this.dirtyEnd, s4));
  }
  getData(t2, e5) {
    if (t(this.data))
      return null;
    const i3 = f(t2) * this.texelSize + e5;
    return !this.data || i3 >= this.data.length ? null : this.data[i3];
  }
  getTexture(t2) {
    return c(this._texture, () => this._initTexture(t2));
  }
  getFBO(t2, e5 = 0) {
    if (t(this._fbos[e5])) {
      const i3 = { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, s4 = 0 === e5 ? this.getTexture(t2) : this._textureDesc;
      this._fbos[e5] = new D4(t2, i3, s4);
    }
    return this._fbos[e5];
  }
  get locked() {
    return !(this.pixelType !== G.UNSIGNED_BYTE || !this.shared || this.textureOnly || !a("esri-atomics") || !this.data) && 1 === Atomics.load(this.data, 0);
  }
  get hasDirty() {
    const t2 = this.dirtyStart;
    return this.dirtyEnd >= t2;
  }
  updateTexture(e5, i3) {
    if (!this.locked) {
      try {
        const i4 = this.dirtyStart, s4 = this.dirtyEnd;
        if (!this.hasDirty)
          return;
        this._resetRange();
        const r4 = e(this.data).buffer, a2 = this.getTexture(e5), d = 4, n3 = (i4 - i4 % this.size) / this.size, o6 = (s4 - s4 % this.size) / this.size, u3 = n3, l3 = this.size, p = o6, x = n3 * this.size * d, _2 = (l3 + p * this.size) * d - x, g = me(this.pixelType), c5 = new g(r4, x * g.BYTES_PER_ELEMENT, _2), T = this.size, f3 = p - u3 + 1;
        if (f3 > this.size)
          return void V2.error(new s2("mapview-webgl", "Out-of-bounds index when updating AttributeData"));
        a2.updateData(0, 0, u3, T, f3, c5);
      } catch (s4) {
      }
      i3();
    }
  }
  update(t2) {
    const { data: e5, start: i3, end: s4 } = t2;
    if (r(e5)) {
      const s5 = this.data, r4 = i3 * this.texelSize;
      for (let i4 = 0; i4 < e5.length; i4++) {
        const a2 = 1 << i4 % this.texelSize;
        t2.layout & a2 && (s5[r4 + i4] = e5[i4]);
      }
    }
    this.dirtyStart = Math.min(this.dirtyStart, i3), this.dirtyEnd = Math.max(this.dirtyEnd, s4);
  }
  resize(t2, e5) {
    const i3 = this.size;
    if (this.size = e5, this.textureOnly)
      return void (i3 !== this.size && (this._lastTexture = this._texture, this._texture = null));
    const s4 = me(this.pixelType);
    this.destroy(), this.data = new s4(e(t2.buffer));
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
  _initTexture(t2) {
    const e5 = new u2(t2, this._textureDesc, c(this.data, void 0));
    if (r(this._lastTexture) && this._fbos[0]) {
      const i3 = this._lastTexture.descriptor.width, s4 = this._lastTexture.descriptor.height, r4 = this._lastTexture.descriptor.dataType, a2 = this._lastTexture.descriptor.pixelFormat, d = this.getFBO(t2), h2 = le(r4), n3 = new (me(r4))(new ArrayBuffer(i3 * s4 * h2 * this.texelSize)), o6 = t2.getBoundFramebufferObject(), { x: u3, y: l3, width: p, height: x } = t2.getViewport();
      t2.bindFramebuffer(d), d.readPixels(0, 0, i3, s4, a2, r4, n3), e5.updateData(0, 0, 0, 2 * i3, s4 / 2, n3), t2.setViewport(u3, l3, p, x), t2.bindFramebuffer(o6);
    }
    return this.destroy(), this._texture = e5, this._texture;
  }
};
var P3 = class {
  constructor(t2) {
    this._onUpdate = t2, this._initialized = false, this._forceNextUpload = false, this._locked = false;
  }
  initialize(t2) {
    const { blocks: e5, shared: i3, size: d } = t2;
    if (this.shared = i3, this.size = d, L2("Initializing AttributeStoreView", t2), t(this._data))
      this._data = v(e5, (t3) => new G3(t3, d, i3));
    else
      for (let r4 = 0; r4 < this._data.length; r4++) {
        const t3 = this._data[r4], h2 = e5[r4];
        r(h2) && (t(t3) ? this._data[r4] = new G3(h2, d, i3) : t3.resize(h2, d));
      }
    this._initialized = true;
  }
  destroy() {
    o(this._data, (t2) => v(t2, (t3) => t3.destroy())), o(this._defaultTexture, (t2) => t2.dispose());
  }
  isEmpty() {
    const t2 = this._data;
    return t(t2);
  }
  isUpdating() {
    const t2 = r(this._pendingAttributeUpdate), i3 = t2;
    return a("esri-2d-log-updating") && console.log(`Updating AttributeStoreView ${i3}
  -> hasPendingUpdate ${t2}`), i3;
  }
  getBlock(t2) {
    if (t(this._data))
      return null;
    return this._data[t2];
  }
  setLabelMinZoom(t2, e5) {
    this.setData(t2, 0, 1, e5);
  }
  getLabelMinZoom(t2) {
    return this.getData(t2, 0, 1, 255);
  }
  getFilterFlags(t2) {
    return this.getData(t2, 0, 0, 0);
  }
  getVVSize(t2) {
    return this.getData(t2, P2, 0, 0);
  }
  getData(t2, e5, i3, r4) {
    if (!this._data)
      return 0;
    const d = e(this._data)[e5];
    if (t(d))
      return 0;
    const n3 = d.getData(t2, i3);
    return r(n3) ? n3 : r4;
  }
  setData(t2, e5, i3, s4) {
    const r4 = e(this._data)[e5];
    e(r4).setData(t2, i3, s4);
  }
  lockTextureUpload() {
    this._locked = true;
  }
  unlockTextureUpload() {
    this._locked = false;
  }
  forceTextureUpload() {
    this._forceNextUpload = true;
  }
  async requestUpdate(e5) {
    if (this._pendingAttributeUpdate)
      return void V2.error(new s2("mapview-webgl", "Tried to update attribute data with a pending update"));
    const i3 = D();
    return L2("AttributeStoreView Update Requested", e5), this._pendingAttributeUpdate = { data: e5, resolver: i3 }, i3.promise;
  }
  update() {
    if (this._initialized && r(this._pendingAttributeUpdate)) {
      a("esri-2d-update-debug") && console.debug("AttributeStoreView::update");
      const { data: t2, resolver: i3 } = this._pendingAttributeUpdate, s4 = e(this._data);
      for (let e5 = 0; e5 < t2.blocks.length; e5++) {
        const i4 = t2.blocks[e5], r4 = s4[e5];
        o(r4, (t3) => o(i4, (i5) => {
          L2(`Updating block ${e5}`, i5), t3.update(i5);
        }));
      }
      this._pendingAttributeUpdate = null, i3(), this._onUpdate();
    }
  }
  bindTextures(t2, e5 = true) {
    this.update();
    const i3 = this._getDefaultTexture(t2);
    if (!this._initialized)
      return t2.bindTexture(i3, B), void (e5 && (t2.bindTexture(i3, C), t2.bindTexture(i3, D3), t2.bindTexture(i3, E2), t2.bindTexture(i3, F), t2.bindTexture(i3, G2), t2.bindTexture(i3, H)));
    const s4 = e(this._data);
    this._locked && !this._forceNextUpload || (A(s4, (e6) => e6.updateTexture(t2, () => this._onUpdate())), this._forceNextUpload = false), t2.bindTexture(E(s4[M2], i3, (e6) => e6.getTexture(t2)), B), e5 && (t2.bindTexture(E(s4[O], i3, (e6) => e6.getTexture(t2)), H), t2.bindTexture(E(s4[N], i3, (e6) => e6.getTexture(t2)), C), t2.bindTexture(E(s4[P2], i3, (e6) => e6.getTexture(t2)), D3), t2.bindTexture(E(s4[R], i3, (e6) => e6.getTexture(t2)), E2), t2.bindTexture(E(s4[F], i3, (e6) => e6.getTexture(t2)), F), t2.bindTexture(E(s4[G2], i3, (e6) => e6.getTexture(t2)), G2));
  }
  _getDefaultTexture(t2) {
    if (t(this._defaultTexture)) {
      const e5 = { wrapMode: D2.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 };
      this._defaultTexture = new u2(t2, e5, new Uint8Array(4));
    }
    return this._defaultTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLRendererInfo.js
function c4(e5, t2) {
  const i3 = t2.length;
  if (e5 < t2[0].value || 1 === i3)
    return t2[0].size;
  for (let s4 = 1; s4 < i3; s4++)
    if (e5 < t2[s4].value) {
      const i4 = (e5 - t2[s4 - 1].value) / (t2[s4].value - t2[s4 - 1].value);
      return t2[s4 - 1].size + i4 * (t2[s4].size - t2[s4 - 1].size);
    }
  return t2[i3 - 1].size;
}
var h = class {
  constructor() {
    this.symbolLevels = [], this.vvColorValues = new Float32Array(8), this.vvColors = new Float32Array(32), this.vvOpacityValues = new Float32Array(8), this.vvOpacities = new Float32Array(8), this.vvSizeMinMaxValue = new Float32Array(4), this._vvMaterialParameters = { vvSizeEnabled: false, vvColorEnabled: false, vvRotationEnabled: false, vvRotationType: "geographic", vvOpacityEnabled: false }, this._technique = e4;
  }
  getSizeVVFieldStops(i3) {
    const s4 = this._vvSizeFieldStops;
    switch (s4.type) {
      case "static":
        return s4;
      case "level-dependent":
        return c(s4.levels[i3], () => {
          let e5 = 1 / 0, a2 = 0;
          for (const t2 in s4.levels) {
            const s5 = parseFloat(t2), r5 = Math.abs(i3 - s5);
            r5 < e5 && (e5 = r5, a2 = s5);
          }
          if (e5 === 1 / 0)
            return { sizes: new Float32Array([0, 0, 0, 0, 0, 0]), values: new Float32Array([0, 0, 0, 0, 0, 0]) };
          const r4 = 2 ** ((i3 - a2) / 2), o6 = e(s4.levels[a2]), l3 = new Float32Array(o6.values);
          return l3[2] *= r4, l3[3] *= r4, { sizes: e(o6.sizes), values: l3 };
        });
    }
  }
  get vvMaterialParameters() {
    return this._vvMaterialParameters;
  }
  update(e5) {
    r(this._vvInfo) && this._updateVisualVariables(this._vvInfo.vvRanges, e5);
  }
  setInfo(e5, t2, i3) {
    this._updateEffects(i3), this._vvInfo = t2, this._technique = c2(e5), this.rendererSchema = this._technique.createOrUpdateRendererSchema(this.rendererSchema, e5);
  }
  getVariation() {
    return { ...this._technique.getVariation(this.rendererSchema), outsideLabelsVisible: this.outsideLabelsVisible, supportsTextureFloat: l("2d").supportsTextureFloat };
  }
  getVariationHash() {
    return this._technique.getVariationHash(this.rendererSchema) << 1 | (this.outsideLabelsVisible ? 1 : 0);
  }
  _updateEffects(e5) {
    r(e5) ? this.outsideLabelsVisible = e5.excludedLabelsVisible : this.outsideLabelsVisible = false;
  }
  _updateVisualVariables(e5, t2) {
    const i3 = this._vvMaterialParameters;
    if (i3.vvOpacityEnabled = false, i3.vvSizeEnabled = false, i3.vvColorEnabled = false, i3.vvRotationEnabled = false, !e5)
      return;
    const n3 = e5.size;
    if (n3) {
      if (i3.vvSizeEnabled = true, n3.minMaxValue) {
        const e6 = n3.minMaxValue;
        let i4, a2;
        if (J(e6.minSize) && J(e6.maxSize))
          if (Q(e6.minSize) && Q(e6.maxSize))
            i4 = u(e6.minSize), a2 = u(e6.maxSize);
          else {
            const r4 = t2.scale;
            i4 = u(c4(r4, e6.minSize.stops)), a2 = u(c4(r4, e6.maxSize.stops));
          }
        this.vvSizeMinMaxValue.set([e6.minDataValue, e6.maxDataValue, i4, a2]);
      }
      if (n3.scaleStops && (this.vvSizeScaleStopsValue = u(c4(t2.scale, n3.scaleStops.stops))), n3.unitValue) {
        const e6 = z(t2.spatialReference) / m[n3.unitValue.unit];
        this.vvSizeUnitValueToPixelsRatio = e6 / t2.resolution;
      }
      n3.fieldStops && (this._vvSizeFieldStops = n3.fieldStops);
    }
    const v2 = e5.color;
    v2 && (i3.vvColorEnabled = true, this.vvColorValues.set(v2.values), this.vvColors.set(v2.colors));
    const u3 = e5.opacity;
    u3 && (i3.vvOpacityEnabled = true, this.vvOpacityValues.set(u3.values), this.vvOpacities.set(u3.opacities));
    const h2 = e5.rotation;
    h2 && (i3.vvRotationEnabled = true, i3.vvRotationType = h2.type);
  }
};

// node_modules/@arcgis/core/views/2d/engine/FeatureContainer.js
var o5 = class extends o4 {
  constructor(e5) {
    super(e5), this._rendererInfo = new h(), this._materialItemsRequestQueue = new e2(), this.attributeView = new P3(() => this.onAttributeStoreUpdate());
  }
  destroy() {
    this.removeAllChildren(), this.children.forEach((e5) => e5.destroy()), this.attributeView.destroy(), this._materialItemsRequestQueue.clear();
  }
  setRendererInfo(e5, t2, r4) {
    this._rendererInfo.setInfo(e5, t2, r4), this.requestRender();
  }
  async getMaterialItems(t2, r4) {
    if (!t2 || 0 === t2.length)
      return null;
    const s4 = D();
    return this._materialItemsRequestQueue.push({ items: t2, abortOptions: r4, resolver: s4 }), this.requestRender(), s4.promise;
  }
  doRender(e5) {
    if (e5.context.capabilities.enable("textureFloat"), e5.context.capabilities.enable("vao"), this._materialItemsRequestQueue.length > 0) {
      let t2 = this._materialItemsRequestQueue.pop();
      for (; t2; )
        this._processMaterialItemRequest(e5, t2), t2 = this._materialItemsRequestQueue.pop();
    }
    super.doRender(e5);
  }
  renderChildren(e5) {
    for (const t2 of this.children)
      t2.commit(e5);
    this._rendererInfo.update(e5.state), super.renderChildren(e5);
  }
  createRenderParams(e5) {
    const t2 = super.createRenderParams(e5);
    return t2.rendererInfo = this._rendererInfo, t2.attributeView = this.attributeView, t2;
  }
  onAttributeStoreUpdate() {
  }
  _processMaterialItemRequest(e5, { items: t2, abortOptions: r4, resolver: s4 }) {
    const { painter: i3, pixelRatio: o6 } = e5, n3 = t2.map((e6) => i3.textureManager.rasterizeItem(e6.symbol, o6, e6.glyphIds, r4));
    Promise.all(n3).then((e6) => {
      if (!this.stage)
        return void s4.reject();
      const r5 = e6.map((e7, r6) => ({ id: t2[r6].id, mosaicItem: e7 }));
      s4.resolve(r5);
    }, s4.reject);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/DisplayRecordReader.js
var r3 = 2147483647;
var i2 = class {
  constructor(t2) {
    this._head = t2, this._cursor = t2;
  }
  static from(t2, e5 = 0, s4 = t2.byteLength / _.BYTES_PER_RECORD - e5) {
    const r4 = new _(new Int32Array(t2, e5 * _.BYTES_PER_RECORD, s4 * _.ELEMENTS_PER_RECORD));
    return new i2(r4);
  }
  size() {
    let t2 = this._cursor, e5 = 0;
    for (; t2; )
      e5 += t2.size(), t2 = t2._link;
    return e5;
  }
  get id() {
    return this._cursor.id;
  }
  set id(t2) {
    this._cursor.id = t2;
  }
  get materialKey() {
    return this._cursor.materialKey;
  }
  set materialKey(t2) {
    this._cursor.materialKey = t2;
  }
  get insertAfter() {
    return this._cursor.insertAfter;
  }
  get indexFrom() {
    return this._cursor.indexFrom;
  }
  set indexFrom(t2) {
    this._cursor.indexFrom = t2;
  }
  get indexCount() {
    return this._cursor.indexCount;
  }
  set indexCount(t2) {
    this._cursor.indexCount = t2;
  }
  get vertexFrom() {
    return this._cursor.vertexFrom;
  }
  set vertexFrom(t2) {
    this._cursor.vertexFrom = t2;
  }
  get vertexCount() {
    return this._cursor.vertexCount;
  }
  set vertexCount(t2) {
    this._cursor.vertexCount = t2;
  }
  get sortKey() {
    return this._cursor.sortKey;
  }
  set sortKey(t2) {
    this._cursor.sortKey = t2;
  }
  get index() {
    return this._cursor._indexStart + this._cursor._index;
  }
  seekIndex(t2) {
    let e5 = t2;
    for (this._cursor = this._head; this._cursor; ) {
      const t3 = this._cursor.size();
      if (e5 < t3)
        return this._cursor._index = e5, true;
      e5 -= t3, this._cursor = this._cursor._link;
    }
    return false;
  }
  forEach(t2) {
    const e5 = this.getCursor();
    for (; e5.next(); )
      t2(e5);
  }
  link(t2) {
    if (!this._head)
      return void (this._head = t2._head);
    let e5 = this._head;
    for (; e5._link; )
      e5 = e5._link;
    e5._link = t2._head, e5._link._indexStart = e5._indexStart + e5.size();
  }
  getCursor() {
    return this.copy();
  }
  lookup(t2) {
    for (this._cursor = this._head; this._cursor && !this._cursor.lookup(t2); ) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link;
    }
    return !!this._cursor;
  }
  copy() {
    var _a;
    const t2 = new i2((_a = this._head) == null ? void 0 : _a.copy());
    if (!t2._head)
      return t2;
    let e5 = t2._head, s4 = t2._head._link;
    for (; s4; )
      e5._link = s4.copy(), e5 = s4, s4 = e5._link;
    return t2;
  }
  next() {
    return !!this._cursor && (!!this._cursor.next() || !!this._cursor._link && (this._cursor = this._cursor._link, this.next()));
  }
  peekId() {
    return this._cursor.peekId() ?? this._cursor._link.peekId();
  }
  delete(e5) {
    let s4 = this._head, r4 = null;
    for (; s4; ) {
      if (s4.delete(e5))
        return s4.isEmpty() && (r(r4) && (r4._link = s4._link), s4 === this._head && (this._head = s4._link), s4 === this._cursor && (this._cursor = s4._link)), true;
      r4 = s4, s4 = s4._link;
    }
    return false;
  }
};
i2.ELEMENTS_PER_RECORD = ct, i2.BYTES_PER_RECORD = i2.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;
var _ = class {
  constructor(t2) {
    this._link = null, this._index = -1, this._indexStart = 0, this._deletedCount = 0, this._offsets = { instance: null }, this._packedRecords = t2;
  }
  static from(t2, e5 = 0, s4 = t2.byteLength / this.BYTES_PER_RECORD - e5) {
    return new _(new Int32Array(t2, e5 * this.BYTES_PER_RECORD, s4 * this.ELEMENTS_PER_RECORD));
  }
  delete(t2) {
    const e5 = this._index, s4 = this.lookup(t2);
    if (s4)
      for (this.id = r3, ++this._deletedCount; this.next() && this.id === t2; )
        this.id = r3, ++this._deletedCount;
    return this._index = e5, s4;
  }
  isEmpty() {
    return this._deletedCount === this.size();
  }
  link(t2) {
    this._link ? this._link.link(t2) : this._link = t2;
  }
  lookup(t2) {
    if (t(this._offsets.instance)) {
      this._offsets.instance = /* @__PURE__ */ new Map();
      const t3 = this.copy();
      t3._index = -1;
      let e5 = 0;
      for (; t3.next(); )
        t3.id !== e5 && (this._offsets.instance.set(t3.id, t3._index), e5 = t3.id);
    }
    if (!this._offsets.instance.has(t2))
      return false;
    const s4 = this._index;
    return this._index = this._offsets.instance.get(t2), this.id !== r3 || (this._index = s4, false);
  }
  get id() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD];
  }
  set id(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD] = t2;
  }
  get materialKey() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 1];
  }
  set materialKey(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 1] = t2;
  }
  get insertAfter() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 2];
  }
  get indexFrom() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 3];
  }
  set indexFrom(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 3] = t2;
  }
  get indexCount() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 4];
  }
  set indexCount(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 4] = t2;
  }
  get vertexFrom() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 5];
  }
  set vertexFrom(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 5] = t2;
  }
  get vertexCount() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 6];
  }
  set vertexCount(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 6] = t2;
  }
  get sortKey() {
    return this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _.ELEMENTS_PER_RECORD + 7];
  }
  set sortKey(t2) {
    this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _.ELEMENTS_PER_RECORD + 7] = t2;
  }
  get index() {
    return this._index;
  }
  size() {
    return this._packedRecords.length / _.ELEMENTS_PER_RECORD;
  }
  next() {
    for (; ++this._index < this.size() && this.id === r3; )
      ;
    return this._index < this.size();
  }
  peekId() {
    const t2 = (this._index + 1) * _.ELEMENTS_PER_RECORD;
    return t2 >= this._packedRecords.length ? 0 : this._packedRecords[t2];
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t2 = new _(this._packedRecords);
    return t2._indexStart = this._indexStart, t2._link = this._link, t2._index = this._index, t2._offsets = this._offsets, t2._deletedCount = this._deletedCount, t2;
  }
};
_.ELEMENTS_PER_RECORD = ct, _.BYTES_PER_RECORD = _.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;

export {
  c3 as c,
  i2 as i,
  o5 as o
};
//# sourceMappingURL=chunk-2HUXPKKU.js.map
