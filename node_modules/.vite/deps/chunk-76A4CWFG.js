import {
  u as u5
} from "./chunk-OZAI2STL.js";
import {
  f as f2,
  i2 as i4,
  u as u4
} from "./chunk-YLSPLHY5.js";
import {
  k as k2
} from "./chunk-ZEDAE7EU.js";
import {
  h as h2
} from "./chunk-7OZR6JFF.js";
import {
  e as e3,
  e2 as e4,
  f,
  i as i2,
  o as o4,
  o2 as o5,
  t as t3
} from "./chunk-NXOQBIK7.js";
import {
  E as E4
} from "./chunk-ERNXFM5T.js";
import {
  i as i3
} from "./chunk-6ITXWFMK.js";
import {
  e as e5
} from "./chunk-SV4VP57N.js";
import {
  W,
  a as a2,
  c,
  l as l2
} from "./chunk-B7F3T673.js";
import {
  t as t2
} from "./chunk-WJDUBZ7S.js";
import {
  o as o2
} from "./chunk-TEJEYVH4.js";
import {
  h
} from "./chunk-EYJ2F5XB.js";
import {
  E,
  R
} from "./chunk-FPMD6IB4.js";
import {
  i,
  u as u2
} from "./chunk-MQBVOUKB.js";
import {
  E as E3,
  d2 as d,
  o2 as o3
} from "./chunk-EEJIELE6.js";
import {
  E as E2,
  u as u3
} from "./chunk-Y55TYMBP.js";
import {
  O
} from "./chunk-VMF4NMEB.js";
import {
  M
} from "./chunk-NAIF4GWX.js";
import {
  W as W2,
  Z,
  j,
  p2 as p
} from "./chunk-53KI6WDE.js";
import {
  b,
  k,
  l,
  v
} from "./chunk-Q6AASANP.js";
import {
  a
} from "./chunk-YZNDHJDJ.js";
import {
  _
} from "./chunk-U7B2WKBH.js";
import {
  x as x2
} from "./chunk-NWRK6QLX.js";
import {
  L,
  P,
  e as e2,
  o,
  q,
  r as r2,
  s as s2,
  u,
  x
} from "./chunk-PKZEO23A.js";
import {
  n
} from "./chunk-AIRC226G.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  s
} from "./chunk-CVWDM4C7.js";
import {
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/NativeLineTechnique.js
var g = class extends e3 {
  constructor(e6, t4, i5) {
    super(e6, t4, i5), this.stipplePattern = null, this.stippleTextureBind = null, this.stippleTextureRepository = e6.stippleTextureRepository;
  }
  get stippleEnabled() {
    return this.configuration.stippleEnabled && this.configuration.output !== o2.Highlight;
  }
  initializeProgram(e6) {
    const t4 = g.shader.get().build(this.configuration);
    return new o4(e6.rctx, t4, E2);
  }
  destroy() {
    super.destroy(), this.stippleTextureRepository.release(this.stipplePattern), this.stipplePattern = null, this.stippleTextureBind = null;
  }
  bindPass(t4, i5) {
    if (this.program.bindPass(t4, i5), this.stipplePattern !== t4.stipplePattern) {
      const e6 = t4.stipplePattern;
      this.stippleTextureBind = this.stippleTextureRepository.swap(this.stipplePattern, e6), this.stipplePattern = e6;
    }
    if (this.stippleEnabled) {
      const { pixelSize: t5, sdfNormalizer: i6, pixels: r4 } = r(this.stippleTextureBind) ? this.stippleTextureBind(this.program) : { pixelSize: 1, sdfNormalizer: 1, pixels: 1 };
      this.program.setUniform1f("stipplePatternSDFNormalizer", i6), this.program.setUniform1f("stipplePatternTextureSize", r4), this.program.setUniform1f("stipplePatternPixelSize", t5), this.program.setUniform1f("stipplePatternPixelSizeInv", 1 / t5);
    }
  }
  initializePipeline() {
    const e6 = this.configuration, i5 = l2(R.SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE_MINUS_SRC_ALPHA), r4 = (t4, i6 = null, r5 = null) => W({ blending: i6, depthTest: i2, depthWrite: r5, colorWrite: c, stencilWrite: e6.hasOccludees ? e4 : null, stencilTest: e6.hasOccludees ? t4 ? o5 : f : null });
    return e6.output === o2.Color ? (this._occludeePipelineState = r4(true, e6.transparent || this.stippleEnabled ? i5 : null, a2), r4(false, e6.transparent || this.stippleEnabled ? i5 : null, a2)) : r4(false);
  }
  get primitiveType() {
    return E.LINES;
  }
  getPipelineState(e6, t4) {
    return t4 ? this._occludeePipelineState : super.getPipelineState(e6, t4);
  }
};
g.shader = new t3(u5, () => import("./NativeLine.glsl-CU3YWX4M.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/NativeLineTechniqueConfiguration.js
var r3 = class extends i3 {
  constructor() {
    super(...arguments), this.output = o2.Color, this.hasSlicePlane = false, this.hasVertexColors = false, this.transparent = false, this.draped = false, this.stippleEnabled = false, this.stippleOffColorEnabled = false, this.stipplePreferContinuous = true, this.hasOccludees = false;
  }
};
e([e5({ count: o2.COUNT })], r3.prototype, "output", void 0), e([e5()], r3.prototype, "hasSlicePlane", void 0), e([e5()], r3.prototype, "hasVertexColors", void 0), e([e5()], r3.prototype, "transparent", void 0), e([e5()], r3.prototype, "draped", void 0), e([e5()], r3.prototype, "stippleEnabled", void 0), e([e5()], r3.prototype, "stippleOffColorEnabled", void 0), e([e5()], r3.prototype, "stipplePreferContinuous", void 0), e([e5()], r3.prototype, "hasOccludees", void 0), e([e5({ constValue: false })], r3.prototype, "stippleRequiresClamp", void 0), e([e5({ constValue: false })], r3.prototype, "stippleScaleWithLineWidth", void 0), e([e5({ constValue: false })], r3.prototype, "stippleRequiresStretchMeasure", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/NativeLineMaterial.js
var X = s.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");
var F;
!function(e6) {
  e6[e6.START = 0] = "START", e6[e6.END = 1] = "END";
}(F || (F = {}));
var W3 = class extends d {
  constructor(e6) {
    super(e6, new z()), this._techniqueConfig = new r3();
  }
  getConfiguration(e6, r4) {
    this._techniqueConfig.output = e6, this._techniqueConfig.hasSlicePlane = this.parameters.hasSlicePlane, this._techniqueConfig.hasVertexColors = this.parameters.hasVertexColors, this._techniqueConfig.transparent = this.parameters.color[3] < 1 || this.parameters.width < 1, this._techniqueConfig.draped = r4.slot === E4.DRAPED_MATERIAL;
    const s3 = r(this.parameters.stipplePattern);
    return this._techniqueConfig.stippleEnabled = s3, this._techniqueConfig.stippleOffColorEnabled = s3 && r(this.parameters.stippleOffColor), this._techniqueConfig.hasOccludees = this.parameters.hasOccludees, this._techniqueConfig.stipplePreferContinuous = this.parameters.stipplePreferContinuous, this._techniqueConfig;
  }
  intersect(e6, r4, s3, i5, o6, n2, a3, c2, u6) {
    r(u6) ? E3(e6, i5, u6, n2, 1, a3) : this._intersectLineGeometry(e6, r4, s3, i5, a3);
  }
  _intersectLineGeometry(e6, t4, r4, s3, p2) {
    if (!s3.options.selectionMode || u3(t4))
      return;
    if (!M(r4))
      return void X.error("intersection assumes a translation-only matrix");
    const h3 = e6.vertexAttributes.get(O.POSITION).data, d2 = s3.camera, A = oe;
    a(A, s3.point);
    const T = 2;
    o(ne[0], A[0] - T, A[1] + T, 0), o(ne[1], A[0] + T, A[1] + T, 0), o(ne[2], A[0] + T, A[1] - T, 0), o(ne[3], A[0] - T, A[1] - T, 0);
    for (let i5 = 0; i5 < 4; i5++)
      if (!d2.unprojectFromRenderScreen(ne[i5], ae[i5]))
        return;
    j(d2.eye, ae[0], ae[1], ce), j(d2.eye, ae[1], ae[2], ue), j(d2.eye, ae[2], ae[3], fe), j(d2.eye, ae[3], ae[0], le);
    let y = Number.MAX_VALUE, P2 = 0;
    for (let i5 = 0; i5 < h3.length - 5; i5 += 3) {
      if (J[0] = h3[i5] + r4[12], J[1] = h3[i5 + 1] + r4[13], J[2] = h3[i5 + 2] + r4[14], K[0] = h3[i5 + 3] + r4[12], K[1] = h3[i5 + 4] + r4[13], K[2] = h3[i5 + 5] + r4[14], W2(ce, J) < 0 && W2(ce, K) < 0 || W2(ue, J) < 0 && W2(ue, K) < 0 || W2(fe, J) < 0 && W2(fe, K) < 0 || W2(le, J) < 0 && W2(le, K) < 0)
        continue;
      if (d2.projectToRenderScreen(J, $), d2.projectToRenderScreen(K, ee), $[2] < 0 && ee[2] > 0) {
        e2(Y, J, K);
        const e8 = d2.frustum, t5 = -W2(e8[k2.NEAR], J) / P(Y, Z(e8[k2.NEAR]));
        q(Y, Y, t5), u(J, J, Y), d2.projectToRenderScreen(J, $);
      } else if ($[2] > 0 && ee[2] < 0) {
        e2(Y, K, J);
        const e8 = d2.frustum, t5 = -W2(e8[k2.NEAR], K) / P(Y, Z(e8[k2.NEAR]));
        q(Y, Y, t5), u(K, K, Y), d2.projectToRenderScreen(K, ee);
      } else if ($[2] < 0 && ee[2] < 0)
        continue;
      $[2] = 0, ee[2] = 0;
      const e7 = b(l($, ee, se), A);
      e7 < y && (y = e7, r2(te, J), r2(re, K), P2 = i5 / 3);
    }
    const v2 = s3.rayBegin, x3 = s3.rayEnd;
    if (y < T * T) {
      let e7 = Number.MAX_VALUE;
      if (k(l(te, re, se), l(v2, x3, ie), Z2)) {
        e2(Z2, Z2, v2);
        const t5 = s2(Z2);
        q(Z2, Z2, 1 / t5), e7 = t5 / x(v2, x3);
      }
      p2(e7, Z2, P2, false);
    }
  }
  computeAttachmentOrigin(e6, t4) {
    const r4 = e6.vertexAttributes;
    if (!r4)
      return false;
    const s3 = r4.get(O.POSITION);
    return h(s3, null, false, t4);
  }
  requiresSlot(e6) {
    return e6 === E4.OPAQUE_MATERIAL || e6 === E4.DRAPED_MATERIAL;
  }
  createGLMaterial(e6) {
    return e6.output === o2.Color || e6.output === o2.Highlight ? new H(e6) : null;
  }
  createBufferWriter() {
    const e6 = this.parameters.hasVertexColors ? u4 : f2;
    return t(this.parameters.stipplePattern) ? new i4(e6) : new Q(e6.clone().vec3f(O.AUXPOS1).vec2f(O.UV0));
  }
};
var H = class extends t2 {
  _updateOccludeeState(e6) {
    e6.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e6.hasOccludees });
  }
  beginSlot(e6) {
    return this._output === o2.Color && this._updateOccludeeState(e6), this.ensureTechnique(g, e6);
  }
};
var Q = class {
  constructor(e6) {
    this.vertexBufferLayout = e6;
  }
  allocate(e6) {
    return this.vertexBufferLayout.createBuffer(e6);
  }
  elementCount(e6) {
    return e6.indices.get(O.POSITION).length;
  }
  write(e6, t4, r4, s3) {
    h2(t4, this.vertexBufferLayout, e6.transformation, e6.invTranspTransformation, r4, s3), this._writeAuxpos1(e6, t4, r4, s3), this._writeUV0(e6, t4, r4, s3);
  }
  _writeAuxpos1(e6, t4, r4, s3) {
    const i5 = r4.getField(O.AUXPOS1, i), o6 = t4.indices.get(O.POSITION), n2 = t4.vertexAttributes.get(O.POSITION).data, a3 = e6.transformation, c2 = i5.typedBufferStride, u6 = i5.typedBuffer;
    s3 *= c2;
    for (let f3 = 0; f3 < o6.length - 1; f3 += 2)
      for (const e7 of [1, 0]) {
        const t5 = 3 * o6[f3 + e7], r5 = n2[t5], i6 = n2[t5 + 1], l3 = n2[t5 + 2], m = a3[0] * r5 + a3[4] * i6 + a3[8] * l3 + a3[12], p2 = a3[1] * r5 + a3[5] * i6 + a3[9] * l3 + a3[13], h3 = a3[2] * r5 + a3[6] * i6 + a3[10] * l3 + a3[14];
        u6[s3] = m, u6[s3 + 1] = p2, u6[s3 + 2] = h3, s3 += c2;
      }
  }
  _writeUV0(e6, t4, r4, s3) {
    var _a;
    const i5 = r4.getField(O.UV0, u2), n2 = t4.indices.get(O.POSITION), a3 = t4.vertexAttributes.get(O.POSITION).data, c2 = (_a = t4.vertexAttributes.get(O.DISTANCETOSTART)) == null ? void 0 : _a.data, u6 = e6.transformation, l3 = i5.typedBufferStride, h3 = i5.typedBuffer;
    let d2 = 0;
    h3[s3 *= l3] = F.START, h3[s3 + 1] = d2, s3 += l3;
    const g2 = 3 * n2[0], A = o(J, a3[g2], a3[g2 + 1], a3[g2 + 2]);
    u6 && L(A, A, u6);
    const O2 = K, S = n2.length - 1;
    let j2 = 1;
    const T = c2 ? (e7, t5, r5) => d2 = c2[r5] : (e7, t5, r5) => d2 += x(e7, t5);
    for (let m = 1; m < S; m += 2) {
      const e7 = 3 * n2[m];
      o(O2, a3[e7], a3[e7 + 1], a3[e7 + 2]), u6 && L(O2, O2, u6), T(A, O2, j2++);
      for (let t5 = 0; t5 < 2; ++t5)
        h3[s3] = 1 - t5, h3[s3 + 1] = d2, s3 += l3;
      r2(A, O2);
    }
    const _2 = 3 * n2[S];
    o(O2, a3[_2], a3[_2 + 1], a3[_2 + 2]), u6 && L(O2, O2, u6), T(A, O2, j2), h3[s3] = F.END, h3[s3 + 1] = d2;
  }
};
var z = class extends o3 {
  constructor() {
    super(...arguments), this.color = _, this.hasVertexColors = false, this.hasSlicePlane = false, this.width = 1, this.stipplePreferContinuous = true, this.hasOccludees = false;
  }
};
var J = n();
var K = n();
var Y = n();
var Z2 = n();
var $ = x2();
var ee = x2();
var te = n();
var re = n();
var se = v();
var ie = v();
var oe = n();
var ne = [x2(), x2(), x2(), x2()];
var ae = [n(), n(), n(), n()];
var ce = p();
var ue = p();
var fe = p();
var le = p();

export {
  W3 as W
};
//# sourceMappingURL=chunk-76A4CWFG.js.map
