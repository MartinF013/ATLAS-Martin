import {
  E as E2,
  I,
  S
} from "./chunk-3KS2GHSC.js";
import {
  r as r2
} from "./chunk-BYJOVCOT.js";
import {
  n as n3
} from "./chunk-WLVMYWO2.js";
import {
  A
} from "./chunk-43ZVVGJH.js";
import {
  i
} from "./chunk-UMSO3HI4.js";
import {
  u
} from "./chunk-6UGZAJSY.js";
import {
  f as f3
} from "./chunk-HPO2NV7P.js";
import {
  t as t2
} from "./chunk-LAHCYKZK.js";
import {
  n as n2
} from "./chunk-KETNREBT.js";
import {
  o
} from "./chunk-MDCKEJ7B.js";
import {
  z
} from "./chunk-SOZCO2CU.js";
import {
  E,
  c
} from "./chunk-TB42IUV7.js";
import {
  y as y2
} from "./chunk-WODSLTZT.js";
import {
  f as f2,
  h,
  l as l2,
  w
} from "./chunk-T7BEWVV3.js";
import {
  g
} from "./chunk-BLINZ65M.js";
import {
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  d,
  n8 as n,
  y3 as y
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  f,
  m
} from "./chunk-U3PSONS6.js";
import {
  s2 as s
} from "./chunk-HFTNOKM2.js";
import {
  l,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/3d/support/PBFDecoder.js
var i2 = class {
  constructor(e2) {
    this._schedule = e2, this._handle = new n4(e2);
  }
  destroy() {
    this._handle.destroy();
  }
  invoke(o2, i3) {
    return o2.buffer && 0 !== o2.buffer.byteLength ? (o2.options.sourceSpatialReference && o2.options.sourceSpatialReference instanceof k && (o2.options = { ...o2.options, sourceSpatialReference: o2.options.sourceSpatialReference.toJSON() }), this._handle.invoke(o2, i3).then((o3) => this._schedule(() => {
      if (o3.spatialReference = k.fromJSON(o3.spatialReference), o3.fields)
        for (let e2 = 0; e2 < o3.fields.length; e2++)
          o3.fields[e2] = y2.fromJSON(o3.fields[e2]);
      const i4 = o3.spatialReference;
      for (const t3 of o3.features)
        t3.uid = g.generateUID(), r(t3.geometry) && (t3.geometry.spatialReference = i4);
      return o3;
    }))) : Promise.resolve(null);
  }
};
var n4 = class extends n2 {
  constructor(e2) {
    super("PBFDecoderWorker", "_parseFeatureQuery", { _parseFeatureQuery: (e3) => [e3.buffer] }, e2);
  }
};

// node_modules/@arcgis/core/views/3d/layers/support/featureTileQuery3D.js
var d2 = class extends y {
  constructor(e2) {
    super(e2);
  }
  get queryFeaturesDehydrated() {
    var _a;
    const e2 = this.layer.capabilities, r3 = e2 && e2.query;
    if (r3 && r3.supportsFormatPBF) {
      t(this._decoder) && (this._decoder = new i2(this.schedule));
      const e3 = { sourceSpatialReference: ((_a = this.layer.spatialReference) == null ? void 0 : _a.toJSON()) ?? null, applyTransform: true, maxStringAttributeLength: 1024 };
      return (r4, t3) => E(this.layer.parsedUrl, r4, "pbf", this._createRequestOptions(t3)).then((r5) => (f(t3), r(this._decoder) ? this._decoder.invoke({ buffer: r5.data, options: e3 }, t3.signal) : Promise.reject(m())));
    }
    return (e3, r4) => c(this.layer.parsedUrl, e3, this.layer.spatialReference, this._createRequestOptions(r4)).then((e4) => z(e4.data));
  }
  queryFeatureCount(e2, r3) {
    return this.layer.queryFeatureCount(e2, r3);
  }
  destroy() {
    this._decoder = l(this._decoder);
  }
  _createRequestOptions(e2) {
    return { ...e2, query: { ...this.layer.customParameters, token: this.layer.apiKey, ...e2 == null ? void 0 : e2.query } };
  }
};
e([d({ constructOnly: true })], d2.prototype, "layer", void 0), e([d({ constructOnly: true })], d2.prototype, "schedule", void 0), e([d({ readOnly: true })], d2.prototype, "queryFeaturesDehydrated", null), d2 = e([n("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileServiceQuery3D")], d2);
var h2 = class extends y {
  constructor(e2) {
    super(e2);
  }
  queryFeaturesDehydrated(e2, r3) {
    return this.layer.queryFeatures(e2, r3);
  }
  queryFeatureCount(e2, r3) {
    return this.layer.queryFeatureCount(e2, r3);
  }
};
e([d({ constructOnly: true })], h2.prototype, "layer", void 0), e([d({ readOnly: true })], h2.prototype, "queryFeaturesDehydrated", null), h2 = e([n("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileServiceMeshQuery3D")], h2);
var m2 = class extends y {
  constructor(e2) {
    super(e2);
  }
  queryFeaturesDehydrated(e2, r3) {
    return this.layer.queryFeatures(e2, r3);
  }
};
e([d({ constructOnly: true })], m2.prototype, "layer", void 0), m2 = e([n("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileServiceQuery3D")], m2);
var f4 = class extends y {
  constructor(e2) {
    super(e2);
  }
  queryFeaturesDehydrated(e2, r3) {
    return this.source.queryFeaturesJSON(e2, r3).then(z, (t3) => {
      if (t3 && "query-features-json:unsupported" === t3.name)
        return this.layer.queryFeatures(e2, r3);
      throw t3;
    });
  }
  queryFeatureCount(e2, r3) {
    return this.layer.queryFeatureCount(e2, r3);
  }
};
function q(e2, r3) {
  return "feature" === e2.type && "feature-layer" === e2.source.type ? r(e2.infoFor3D) ? new h2({ layer: e2 }) : new d2({ layer: e2, schedule: r3 }) : "feature" === e2.type && "memory" === e2.source.type || "csv" === e2.type || "geojson" === e2.type || "wfs" === e2.type ? new f4({ layer: e2, source: e2.source }) : "ogc-feature" === e2.type ? new m2({ layer: e2 }) : null;
}
e([d({ constructOnly: true })], f4.prototype, "layer", void 0), e([d({ constructOnly: true })], f4.prototype, "source", void 0), f4 = e([n("esri.views.3d.layers.support.featureTileQuery3D.FeatureTileClientQuery3D")], f4);

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3DLayerViewContext.js
var l3 = class {
  constructor(e2) {
    this._memoryCache = null, this._capabilities = null;
    const r3 = e2.layerView.layer;
    this.layerView = e2.layerView, this.objectIdField = r3.objectIdField, this.globalIdField = "globalIdField" in r3 ? r3.globalIdField : null, this.returnZ = e2.returnZ, this.returnM = e2.returnM;
    const t3 = this.layerView.view.resourceController;
    this.query = q(r3, (e3) => t3.schedule(e3)), t3 && this.memoryCacheEnabled && (this._memoryCache = t3.memoryController.newCache(r3.uid));
  }
  get memoryCacheEnabled() {
    switch (this.layerView.layer.source.type) {
      case "feature-layer":
      case "ogc-feature":
        return true;
      case "csv":
      case "geojson":
      case "memory":
      case "wfs":
        return false;
    }
  }
  destroy() {
    this._memoryCache = l(this._memoryCache), this.query.destroy();
  }
  createQuery() {
    const e2 = this.layerView.layer.createQuery();
    return e2.outFields = this.layerView.availableFields, e2.returnZ = this.returnZ, e2.returnM = this.returnM, e2.outSpatialReference = this.tilingScheme.spatialReference, e2;
  }
  get memoryCache() {
    return this._memoryCache;
  }
  get viewingMode() {
    return this.layerView.view.state.viewingMode;
  }
  get tilingScheme() {
    return this.layerView.view.featureTiles.tilingScheme;
  }
  get scheduler() {
    const e2 = this.layerView.view.resourceController;
    return e2 ? e2.scheduler : null;
  }
  get geometryType() {
    return this.layerView.layer.geometryType;
  }
  get fullExtent() {
    return this.layerView.layer.fullExtent;
  }
  get tileMaxRecordCount() {
    return this.layerView.layer.capabilities.query.tileMaxRecordCount;
  }
  get maxRecordCount() {
    return this.layerView.layer.capabilities.query.maxRecordCount;
  }
  get capabilities() {
    return r(this._capabilities) || (this._capabilities = S(this.layerView.layer)), this._capabilities;
  }
  logFetchError(e2, r3) {
    e2.error("#fetchTile()", this.layerView.layer, r3 && r3.message ? r3.message : r3);
  }
};

// node_modules/@arcgis/core/views/3d/layers/FeatureLayerViewBase3D.js
var j = class extends i(E2(A(n3(u)))) {
  constructor(e2) {
    super(e2), this._controllerTotal = 0, this._processorTotal = 0, this.suspendResumeExtentMode = "data";
  }
  initialize() {
    this.updatingHandles.add(() => this.view.floors, () => r(this.processor.filterVisibility) && this.processor.filterVisibility.filterChanged()), this.handles.add(l2(() => this._updatingRequiredFieldsPromise, (e2) => this.updatingHandles.addPromise(e2), w));
  }
  destroy() {
    this.updatingHandles.removeAll(), this.handles.removeAll(), this.fetcherContext = l(this.fetcherContext);
  }
  get maximumNumberOfFeatures() {
    var _a;
    return ((_a = this.controller) == null ? void 0 : _a.maximumNumberOfFeatures) ?? this._get("maximumNumberOfFeatures");
  }
  set maximumNumberOfFeatures(e2) {
    this._set("maximumNumberOfFeatures", e2), this.controller && (this.controller.maximumNumberOfFeatures = e2);
  }
  get maximumNumberOfFeaturesExceeded() {
    return !!this.controller && !(this.suspended || !this.controller.maximumNumberOfFeaturesExceeded);
  }
  get updatingProgressValue() {
    var _a, _b;
    let e2 = 0;
    if ((_a = this.controller) == null ? void 0 : _a.updating) {
      const t4 = this.controller.updatingRemaining, r3 = Math.max(this.controller.updatingTotal, this._controllerTotal);
      r3 > 0 && (e2 = (r3 - t4) / r3, this._controllerTotal = r3);
    }
    let t3 = 0;
    if ((_b = this.processor) == null ? void 0 : _b.updating) {
      const e3 = this.processor.updatingRemaining, r3 = Math.max(e3, this._processorTotal);
      r3 > 0 && (t3 = (r3 - e3) / r3, this._processorTotal = r3);
    }
    return 0.5 * (e2 + t3);
  }
  get updatePolicy() {
    if (!this.controller)
      return o.ASYNC;
    switch (this.controller.mode) {
      case "snapshot": {
        const e2 = v[this.layer.geometryType];
        return null == e2 || this.controller.serviceDataCount > e2 ? o.ASYNC : o.SYNC;
      }
      case "tiles":
        return o.ASYNC;
    }
  }
  get hasZ() {
    const e2 = this.layer, t3 = e2.capabilities && e2.capabilities.data;
    return !(!t3 || !t3.supportsZ) && ("returnZ" in e2 && null != e2.returnZ ? e2.returnZ : t3.supportsZ);
  }
  get hasM() {
    const e2 = this.layer, t3 = e2.capabilities && e2.capabilities.data;
    return !(!t3 || !t3.supportsM) && ("returnM" in e2 && null != e2.returnM && e2.returnM);
  }
  setVisibility(e2, t3) {
    var _a;
    (_a = this.processor) == null ? void 0 : _a.setObjectIdVisibility(e2, t3);
  }
  createQuery() {
    return super.createQuery();
  }
  queryFeatures(e2, t3) {
    const r3 = () => super.queryFeatures(e2, t3);
    return "mesh" === this.layer.geometryType ? this._queryFeaturesMesh(this._ensureQuery(e2), r3) : r3();
  }
  beforeSetController(e2) {
    e2.maximumNumberOfFeatures = this.maximumNumberOfFeatures;
  }
  createController() {
    this.fetcherContext = new l3({ layerView: this, returnZ: this.hasZ, returnM: this.hasM });
    const e2 = new I({ layerView: this, context: this.fetcherContext, graphics: new r2(), extent: this.clippingExtent });
    return this.updatingHandles.add(() => e2.serviceDataExtent, (e3) => {
      this.processor && (this.processor.dataExtent = e3);
    }, h), this.handles.add(l2(() => this.suspended, (t3) => {
      t3 ? e2.suspend() : e2.resume();
    }, w)), this.updatingHandles.add(() => {
      var _a;
      return (_a = this.processor) == null ? void 0 : _a.displayFeatureLimit;
    }, (t3) => e2.displayFeatureLimit = t3, h), this.handles.add(f2(() => !this.updating, () => {
      this._controllerTotal = 0, this._processorTotal = 0;
    })), e2;
  }
  async doRefresh(e2) {
    e2 && !this.suspended && this.controller && this.controller.refetch(), r(this.processor.filterVisibility) && (this.processor.filterVisibility.dirty = true);
  }
  getUsedMemory() {
    var _a, _b;
    return (((_a = this.processor) == null ? void 0 : _a.usedMemory) ?? 0) + (((_b = this.controller) == null ? void 0 : _b.memoryForUnusedFeatures) ?? 0);
  }
  getUnloadedMemory() {
    var _a, _b, _c;
    return (((_a = this.processor) == null ? void 0 : _a.unprocessedMemoryEstimate) ?? 0) + ((_b = this.controller) == null ? void 0 : _b.expectedFeatureDiff) * ((_c = this.processor) == null ? void 0 : _c.usedMemoryPerFeature);
  }
  ignoresMemoryFactor() {
    var _a;
    return (_a = this.controller) == null ? void 0 : _a.hasMaximumNumberOfFeaturesOverride;
  }
  async _queryFeaturesMesh(e2, t3) {
    await this._validateQueryFeaturesMesh(e2);
    const r3 = await t3();
    if (e2 && e2.outStatistics || t(this.graphics3DProcessor))
      return r3;
    const s2 = this.layer.objectIdField, i3 = this.graphics3DProcessor.graphics3DGraphicsByObjectID, a = [];
    for (const o2 of r3.features)
      if (o2.geometry) {
        const e3 = i3.get(o2.attributes[s2]);
        e3 && (o2.geometry = f3(e3.graphic.geometry), a.push(o2));
      } else
        a.push(o2);
    return r3.features = a, r3;
  }
  async _validateQueryFeaturesMesh(e2) {
    if (!e2)
      return;
    const s2 = (e3) => {
      throw new s("feature-layer-view:unsupported-query", `Queries on Mesh feature collection layers do not support '${e3}'`);
    }, o2 = ["quantizationParameters", "geometryPrecision", "maxAllowableOffset"];
    for (const t3 of o2)
      null != e2[t3] && s2(t3);
    "returnM" in e2 && e2.returnM && s2("returnM"), "returnCentroid" in e2 && e2.returnCentroid && s2("returnCentroid"), r(e2.outSpatialReference) && !e2.outSpatialReference.equals(this.view.spatialReference) && s2("outSpatialReference");
  }
  get performanceInfo() {
    var _a, _b, _c;
    const e2 = (_a = this.controller) == null ? void 0 : _a.displayFeatureLimit, t3 = r(e2) && e2.averageSymbolComplexity, s2 = r(t3) ? `f:${t3.primitivesPerFeature},v:${t3.primitivesPerCoordinate}` : "n/a", o2 = { ...this._getResourceInfo(), storedFeatures: 0, totalVertices: 0, partial: this.maximumNumberOfFeaturesExceeded, mode: ((_b = this.controller) == null ? void 0 : _b.mode) ?? "n/a", symbolComplexity: s2, nodes: ((_c = this.controller) == null ? void 0 : _c.tileDescriptors.length) ?? 0 };
    if (this.controller && o2.displayedNumberOfFeatures) {
      const e3 = this.controller.debug;
      o2.storedFeatures = e3.storedFeatures, o2.totalVertices = e3.totalVertices;
    }
    return o2;
  }
  get test() {
    var _a;
    return { updatePolicy: this.updatePolicy, controller: this.controller, loadedGraphics: (_a = this.controller) == null ? void 0 : _a.graphics };
  }
};
e([d()], j.prototype, "layer", void 0), e([d()], j.prototype, "controller", void 0), e([d()], j.prototype, "_controllerTotal", void 0), e([d()], j.prototype, "_processorTotal", void 0), e([d()], j.prototype, "maximumNumberOfFeatures", null), e([d()], j.prototype, "maximumNumberOfFeaturesExceeded", null), e([d(t2)], j.prototype, "updatingProgress", void 0), e([d({ readOnly: true })], j.prototype, "updatingProgressValue", null), e([d({ readOnly: true })], j.prototype, "updatePolicy", null), e([d({ readOnly: true })], j.prototype, "hasZ", null), e([d({ readOnly: true })], j.prototype, "hasM", null), e([d()], j.prototype, "suspendResumeExtentMode", void 0), j = e([n("esri.views.3d.layers.FeatureLayerViewBase3D")], j);
var v = { point: 5e3, polygon: 500, polyline: 1e3 };
var w2 = j;

export {
  w2 as w
};
//# sourceMappingURL=chunk-B6Y5V4Y7.js.map
