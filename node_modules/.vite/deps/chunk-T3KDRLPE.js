import {
  s as s3
} from "./chunk-VQLKKADV.js";
import {
  A,
  B,
  C,
  F,
  P,
  U,
  t as t2,
  u
} from "./chunk-FPMD6IB4.js";
import {
  o
} from "./chunk-MV2XZ5BA.js";
import {
  s as s2
} from "./chunk-CVWDM4C7.js";
import {
  a3 as a,
  i3 as i,
  r,
  s3 as s,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/webgl/BufferObject.js
var _ = s2.getLogger("esri.views.webgl.BufferObject");
function b(t3) {
  return a(t3);
}
var c = class {
  constructor(e, t3, r2, i3) {
    this._context = e, this.bufferType = t3, this.usage = r2, this._glName = null, this._size = -1, this._indexType = void 0, e.instanceCounter.increment(t2.BufferObject, this), this._glName = this._context.gl.createBuffer(), s3(this._context.gl), i3 && this.setData(i3);
  }
  static createIndex(e, t3, r2) {
    return new c(e, A.ELEMENT_ARRAY_BUFFER, t3, r2);
  }
  static createVertex(e, t3, r2) {
    return new c(e, A.ARRAY_BUFFER, t3, r2);
  }
  static createUniform(e, t3, r2) {
    if (e.type !== o.WEBGL2)
      throw new Error("Uniform buffers are supported in WebGL2 only!");
    return new c(e, A.UNIFORM_BUFFER, t3, r2);
  }
  static createPixelPack(e, t3 = F.STREAM_READ, r2) {
    if (e.type !== o.WEBGL2)
      throw new Error("Pixel pack buffers are supported in WebGL2 only!");
    const i3 = new c(e, A.PIXEL_PACK_BUFFER, t3);
    return r2 && i3.setSize(r2), i3;
  }
  static createPixelUnpack(e, t3 = F.STREAM_DRAW, r2) {
    if (e.type !== o.WEBGL2)
      throw new Error("Pixel unpack buffers are supported in WebGL2 only!");
    return new c(e, A.PIXEL_UNPACK_BUFFER, t3, r2);
  }
  get glName() {
    return this._glName;
  }
  get size() {
    return this._size;
  }
  get indexType() {
    return this._indexType;
  }
  get byteSize() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER ? this._indexType === C.UNSIGNED_INT ? 4 * this._size : 2 * this._size : this._size;
  }
  get _isVAOAware() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER || this.bufferType === A.ARRAY_BUFFER;
  }
  dispose() {
    var _a;
    if ((_a = this._context) == null ? void 0 : _a.gl) {
      if (this._glName) {
        this._context.gl.deleteBuffer(this._glName), this._glName = null;
      }
      this._context.instanceCounter.decrement(t2.BufferObject, this), this._context = null;
    } else
      this._glName && _.warn("Leaked WebGL buffer object");
  }
  setSize(e, t3 = null) {
    if (e <= 0 && _.error("Buffer size needs to be positive!"), this.bufferType === A.ELEMENT_ARRAY_BUFFER && r(t3))
      switch (this._indexType = t3, t3) {
        case C.UNSIGNED_SHORT:
          e *= 2;
          break;
        case C.UNSIGNED_INT:
          e *= 4;
      }
    this._setBufferData(e);
  }
  setData(e) {
    if (!e)
      return;
    let t3 = e.byteLength;
    this.bufferType === A.ELEMENT_ARRAY_BUFFER && (i(e) && (t3 /= 2, this._indexType = C.UNSIGNED_SHORT), s(e) && (t3 /= 4, this._indexType = C.UNSIGNED_INT)), this._setBufferData(t3, e);
  }
  _setBufferData(e, t3 = null) {
    this._size = e;
    const i3 = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const s4 = this._context.gl;
    r(t3) ? s4.bufferData(this.bufferType, t3, this.usage) : s4.bufferData(this.bufferType, e, this.usage), s3(s4), this._isVAOAware && this._context.bindVAO(i3);
  }
  setSubData(e, t3 = 0, r2 = 0, o3 = e.byteLength) {
    if (!e)
      return;
    (t3 < 0 || t3 >= this._size) && _.error("offset is out of range!");
    let a2 = t3, u3 = r2, h = o3, b2 = e.byteLength;
    this.bufferType === A.ELEMENT_ARRAY_BUFFER && (i(e) ? (b2 /= 2, a2 *= 2, u3 *= 2, h *= 2) : s(e) && (b2 /= 4, a2 *= 4, u3 *= 4, h *= 4)), void 0 === o3 && (o3 = b2 - 1), r2 >= o3 && _.error("end must be bigger than start!"), t3 + r2 - o3 > this._size && _.error("An attempt to write beyond the end of the buffer!");
    const c2 = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const E2 = this._context.gl, l = ArrayBuffer.isView(e) ? e.buffer : e, d = 0 === u3 && h === e.byteLength ? l : l.slice(u3, h);
    E2.bufferSubData(this.bufferType, a2, d), s3(E2), this._isVAOAware && this._context.bindVAO(c2);
  }
  setSubDataFromView(e, t3, r2, i3) {
    if (!e)
      return;
    (t3 < 0 || t3 >= this._size) && _.error("offset is out of range!"), r2 >= i3 && _.error("end must be bigger than start!"), t3 + r2 - i3 > this._size && _.error("An attempt to write beyond the end of the buffer!");
    const s4 = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const f = this._context.gl;
    if (this._context.type === o.WEBGL2)
      f.bufferSubData(this.bufferType, t3 * e.BYTES_PER_ELEMENT, e, r2, i3 - r2);
    else {
      const s5 = 0 === r2 && i3 === e.length ? e : e.subarray(r2, i3);
      f.bufferSubData(this.bufferType, t3 * e.BYTES_PER_ELEMENT, s5);
    }
    s3(f), this._isVAOAware && this._context.bindVAO(s4);
  }
  getSubData(e, t3 = 0, r2, i3) {
    if (this._context.type !== o.WEBGL2)
      return void _.error("Get buffer subdata is supported in WebGL2 only!");
    if (r2 < 0 || i3 < 0)
      return void _.error("Problem getting subdata: offset and length were less than zero!");
    const s4 = b(e) ? e.BYTES_PER_ELEMENT : 1;
    if (s4 * ((r2 ?? 0) + (i3 ?? 0)) > e.byteLength)
      return void _.error("Problem getting subdata: offset and length exceeded destination size!");
    t3 + s4 * (i3 ?? 0) > this.byteSize && _.warn("Potential problem getting subdata: requested data exceeds buffer size!");
    const n2 = this._context.gl;
    this._context.bindBuffer(this, A.COPY_READ_BUFFER), n2.getBufferSubData(A.COPY_READ_BUFFER, t3, e, r2, i3), this._context.unbindBuffer(A.COPY_READ_BUFFER);
  }
  async getSubDataAsync(e, t3 = 0, r2, i3) {
    this._context.type === o.WEBGL2 ? (await this._context.clientWaitAsync(), this.getSubData(e, t3, r2, i3)) : _.error("Get buffer subdata is supported in WebGL2 only!");
  }
};

// node_modules/@arcgis/core/views/webgl/Util.js
function i2(e) {
  const r2 = e.gl;
  switch (r2.getError()) {
    case r2.NO_ERROR:
      return null;
    case r2.INVALID_ENUM:
      return "An unacceptable value has been specified for an enumerated argument";
    case r2.INVALID_VALUE:
      return "A numeric argument is out of range";
    case r2.INVALID_OPERATION:
      return "The specified command is not allowed for the current state";
    case r2.INVALID_FRAMEBUFFER_OPERATION:
      return "The currently bound framebuffer is not framebuffer complete";
    case r2.OUT_OF_MEMORY:
      return "Not enough memory is left to execute the command";
    case r2.CONTEXT_LOST_WEBGL:
      return "WebGL context is lost";
  }
  return "Unknown error";
}
function n(e, r2) {
  return e.vertexBuffers[r2].size / o2(e.layout[r2]);
}
function o2(e) {
  return e[0].stride;
}
function R(e, r2, t3, s4, a2 = 0) {
  const c2 = e.gl, i3 = e.capabilities.instancing;
  e.bindBuffer(t3);
  for (const n2 of s4) {
    const e2 = r2.get(n2.name);
    void 0 === e2 && console.error(`There is no location for vertex attribute '${n2.name}' defined.`);
    const t4 = a2 * n2.stride;
    if (n2.count <= 4)
      c2.vertexAttribPointer(e2, n2.count, n2.type, n2.normalized, n2.stride, n2.offset + t4), c2.enableVertexAttribArray(e2), n2.divisor > 0 && i3 && i3.vertexAttribDivisor(e2, n2.divisor);
    else if (9 === n2.count)
      for (let r3 = 0; r3 < 3; r3++)
        c2.vertexAttribPointer(e2 + r3, 3, n2.type, n2.normalized, n2.stride, n2.offset + 12 * r3 + t4), c2.enableVertexAttribArray(e2 + r3), n2.divisor > 0 && i3 && i3.vertexAttribDivisor(e2 + r3, n2.divisor);
    else if (16 === n2.count)
      for (let r3 = 0; r3 < 4; r3++)
        c2.vertexAttribPointer(e2 + r3, 4, n2.type, n2.normalized, n2.stride, n2.offset + 16 * r3 + t4), c2.enableVertexAttribArray(e2 + r3), n2.divisor > 0 && i3 && i3.vertexAttribDivisor(e2 + r3, n2.divisor);
    else
      console.error("Unsupported vertex attribute element count: " + n2.count);
  }
}
function E(e, t3, s4, a2) {
  const c2 = e.gl, i3 = e.capabilities.instancing;
  e.bindBuffer(s4);
  for (const r2 of a2) {
    const e2 = t3.get(r2.name);
    if (r2.count <= 4)
      c2.disableVertexAttribArray(e2), r2.divisor && r2.divisor > 0 && i3 && i3.vertexAttribDivisor(e2, 0);
    else if (9 === r2.count)
      for (let t4 = 0; t4 < 3; t4++)
        c2.disableVertexAttribArray(e2 + t4), r2.divisor && r2.divisor > 0 && i3 && i3.vertexAttribDivisor(e2 + t4, 0);
    else if (16 === r2.count)
      for (let t4 = 0; t4 < 4; t4++)
        c2.disableVertexAttribArray(e2 + t4), r2.divisor && r2.divisor > 0 && i3 && i3.vertexAttribDivisor(e2 + t4, 0);
    else
      console.error("Unsupported vertex attribute element count: " + r2.count);
  }
  e.unbindBuffer(A.ARRAY_BUFFER);
}
function _2(e) {
  switch (e) {
    case P.ALPHA:
    case P.LUMINANCE:
    case P.RED:
    case P.RED_INTEGER:
    case U.R8:
    case U.R8I:
    case U.R8UI:
    case U.R8_SNORM:
    case B.STENCIL_INDEX8:
      return 1;
    case P.LUMINANCE_ALPHA:
    case P.RG:
    case P.RG_INTEGER:
    case U.RGBA4:
    case U.R16F:
    case U.R16I:
    case U.R16UI:
    case U.RG8:
    case U.RG8I:
    case U.RG8UI:
    case U.RG8_SNORM:
    case U.RGB565:
    case U.RGB5_A1:
    case B.DEPTH_COMPONENT16:
      return 2;
    case P.DEPTH_COMPONENT:
    case P.RGB:
    case P.RGB_INTEGER:
    case U.RGB8:
    case U.RGB8I:
    case U.RGB8UI:
    case U.RGB8_SNORM:
    case U.SRGB8:
    case B.DEPTH_COMPONENT24:
      return 3;
    case P.DEPTH_STENCIL:
    case P.RGBA:
    case P.RGBA_INTEGER:
    case U.RGBA8:
    case U.R32F:
    case U.R11F_G11F_B10F:
    case U.RG16F:
    case U.R32I:
    case U.R32UI:
    case U.RG16I:
    case U.RG16UI:
    case U.RGBA8I:
    case U.RGBA8UI:
    case U.RGBA8_SNORM:
    case U.SRGB8_ALPHA8:
    case U.RGB9_E5:
    case U.RGB10_A2UI:
    case U.RGB10_A2:
    case B.DEPTH_STENCIL:
    case B.DEPTH_COMPONENT32F:
    case B.DEPTH24_STENCIL8:
      return 4;
    case B.DEPTH32F_STENCIL8:
      return 5;
    case U.RGB16F:
    case U.RGB16I:
    case U.RGB16UI:
      return 6;
    case U.RG32F:
    case U.RG32I:
    case U.RG32UI:
    case U.RGBA16F:
    case U.RGBA16I:
    case U.RGBA16UI:
      return 8;
    case U.RGB32F:
    case U.RGB32I:
    case U.RGB32UI:
      return 12;
    case U.RGBA32F:
    case U.RGBA32I:
    case U.RGBA32UI:
      return 16;
    case u.COMPRESSED_RGB_S3TC_DXT1_EXT:
    case u.COMPRESSED_RGBA_S3TC_DXT1_EXT:
      return 0.5;
    case u.COMPRESSED_RGBA_S3TC_DXT3_EXT:
    case u.COMPRESSED_RGBA_S3TC_DXT5_EXT:
      return 1;
    case u.COMPRESSED_R11_EAC:
    case u.COMPRESSED_SIGNED_R11_EAC:
    case u.COMPRESSED_RGB8_ETC2:
    case u.COMPRESSED_SRGB8_ETC2:
    case u.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
    case u.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return 0.5;
    case u.COMPRESSED_RG11_EAC:
    case u.COMPRESSED_SIGNED_RG11_EAC:
    case u.COMPRESSED_RGBA8_ETC2_EAC:
    case u.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      return 1;
  }
  return 0;
}
function u2(r2) {
  if (t(r2))
    return 0;
  if ("descriptor" in r2)
    return r2.glName ? u2(r2.descriptor) : 0;
  const t3 = r2.internalFormat || "pixelFormat" in r2 && r2.pixelFormat;
  if (!t3)
    return 0;
  const s4 = "hasMipmap" in r2 && r2.hasMipmap ? 1.3 : 1, a2 = r2.width * r2.height;
  return _2(t3) * a2 * s4;
}

export {
  i2 as i,
  n,
  R,
  E,
  _2 as _,
  u2 as u,
  c
};
//# sourceMappingURL=chunk-T3KDRLPE.js.map
