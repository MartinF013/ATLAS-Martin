import {
  M as M2,
  c,
  p as p2
} from "./chunk-Q72YFZUL.js";
import {
  M,
  j2 as j,
  p
} from "./chunk-YPZEGNLG.js";
import {
  R,
  k2 as k
} from "./chunk-3NMRL5CR.js";
import {
  r as r2
} from "./chunk-ZIHDQYKE.js";
import {
  d,
  n8 as n
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  i2 as i,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/geometry/support/coordsUtils.js
function t2(n3) {
  if (!n3)
    return null;
  if (Array.isArray(n3))
    return n3;
  const t5 = n3.hasZ, e6 = n3.hasM;
  if ("point" === n3.type)
    return e6 && t5 ? [n3.x, n3.y, n3.z, n3.m] : t5 ? [n3.x, n3.y, n3.z] : e6 ? [n3.x, n3.y, n3.m] : [n3.x, n3.y];
  if ("polygon" === n3.type)
    return n3.rings.slice(0);
  if ("polyline" === n3.type)
    return n3.paths.slice(0);
  if ("multipoint" === n3.type)
    return n3.points.slice(0);
  if ("extent" === n3.type) {
    const t6 = n3.clone().normalize();
    if (!t6)
      return null;
    let e7 = false, r7 = false;
    return t6.forEach((n4) => {
      n4.hasZ && (e7 = true), n4.hasM && (r7 = true);
    }), t6.map((n4) => {
      const t7 = [[n4.xmin, n4.ymin], [n4.xmin, n4.ymax], [n4.xmax, n4.ymax], [n4.xmax, n4.ymin], [n4.xmin, n4.ymin]];
      if (e7 && n4.hasZ) {
        const e8 = 0.5 * (n4.zmax - n4.zmin);
        for (let n5 = 0; n5 < t7.length; n5++)
          t7[n5].push(e8);
      }
      if (r7 && n4.hasM) {
        const e8 = 0.5 * (n4.mmax - n4.mmin);
        for (let n5 = 0; n5 < t7.length; n5++)
          t7[n5].push(e8);
      }
      return t7;
    });
  }
  return null;
}
function e2(n3, t5) {
  const e6 = t5[0] - n3[0], r7 = t5[1] - n3[1];
  if (n3.length > 2 && t5.length > 2) {
    const o5 = n3[2] - t5[2];
    return Math.sqrt(e6 * e6 + r7 * r7 + o5 * o5);
  }
  return Math.sqrt(e6 * e6 + r7 * r7);
}
function r3(n3, t5, e6) {
  const r7 = n3[0] + e6 * (t5[0] - n3[0]), o5 = n3[1] + e6 * (t5[1] - n3[1]);
  return n3.length > 2 && t5.length > 2 ? [r7, o5, n3[2] + e6 * (t5[2] - n3[2])] : [r7, o5];
}
function o(n3, t5, e6, r7) {
  const [o5, i4] = t5, [s4, l5] = e6[r7], [f4, u4] = e6[r7 + 1], h6 = f4 - s4, c4 = u4 - l5, a3 = h6 * h6 + c4 * c4, g3 = (o5 - s4) * h6 + (i4 - l5) * c4, m3 = Math.min(1, Math.max(0, g3 / a3));
  return n3[0] = s4 + h6 * m3, n3[1] = l5 + c4 * m3, n3;
}
function i2(n3, t5) {
  return r3(n3, t5, 0.5);
}
function s(n3) {
  const t5 = n3.length;
  let r7 = 0;
  for (let o5 = 0; o5 < t5 - 1; ++o5)
    r7 += e2(n3[o5], n3[o5 + 1]);
  return r7;
}
function l(n3, t5) {
  if (t5 <= 0)
    return n3[0];
  const o5 = n3.length;
  let i4 = 0;
  for (let s4 = 0; s4 < o5 - 1; ++s4) {
    const o6 = e2(n3[s4], n3[s4 + 1]);
    if (t5 - i4 < o6) {
      const e6 = (t5 - i4) / o6;
      return r3(n3[s4], n3[s4 + 1], e6);
    }
    i4 += o6;
  }
  return n3[o5 - 1];
}
function f(n3, t5, e6) {
  const r7 = n3.length;
  let o5 = 0, i4 = 0, s4 = 0;
  for (let l5 = 0; l5 < r7; l5++) {
    const f4 = n3[l5], u4 = n3[(l5 + 1) % r7];
    let h6 = 2;
    o5 += f4[0] * u4[1] - u4[0] * f4[1], f4.length > 2 && u4.length > 2 && e6 && (i4 += f4[0] * u4[2] - u4[0] * f4[2], h6 = 3), f4.length > h6 && u4.length > h6 && t5 && (s4 += f4[0] * u4[h6] - u4[0] * f4[h6]);
  }
  return o5 <= 0 && i4 <= 0 && s4 <= 0;
}
function u(n3) {
  if ("rings" in n3) {
    for (const t5 of n3.rings)
      t5.length < 3 || t5[0][0] === t5[t5.length - 1][0] && t5[0][1] === t5[t5.length - 1][1] || t5.push([t5[0][0], t5[0][1]]);
    if (n3.rings.length > 0) {
      if (!f(n3.rings[0], n3.hasM, n3.hasZ))
        for (let t5 = 0; t5 < n3.rings.length; ++t5)
          n3.rings[t5] = n3.rings[t5].reverse();
    }
  }
}
function h(n3) {
  if ("rings" in n3)
    for (const t5 of n3.rings)
      t5.length < 3 || t5[0][0] === t5[t5.length - 1][0] && t5[0][1] === t5[t5.length - 1][1] || t5.push([t5[0][0], t5[0][1]]);
}
function a(n3) {
  if ("polygon" !== n3.type && "polyline" !== n3.type)
    return n3;
  return g("polygon" === n3.type ? n3.rings : n3.paths, n3.spatialReference), n3;
}
function g(t5, e6) {
  const r7 = R(e6);
  if (!r7)
    return;
  const o5 = r7.valid[0], i4 = r7.valid[1], s4 = i4 - o5;
  for (const n3 of t5) {
    let t6 = 1 / 0, e7 = -1 / 0;
    n3.forEach((n4) => {
      let r9 = n4[0];
      for (; r9 < o5; )
        r9 += s4;
      for (; r9 > i4; )
        r9 -= s4;
      t6 = Math.min(t6, r9), e7 = Math.max(e7, r9), n4[0] = r9;
    });
    const r8 = e7 - t6;
    s4 - r8 < r8 && n3.forEach((n4) => {
      n4[0] < 0 && (n4[0] += s4);
    });
  }
}

// node_modules/@arcgis/core/geometry/support/centroid.js
function l2(n3) {
  return n3 ? n3.hasZ ? [n3.xmax - n3.xmin / 2, n3.ymax - n3.ymin / 2, n3.zmax - n3.zmin / 2] : [n3.xmax - n3.xmin / 2, n3.ymax - n3.ymin / 2] : null;
}
function e3(n3) {
  return n3 ? o2(n3.rings, n3.hasZ) : null;
}
function o2(n3, t5) {
  if (!n3 || !n3.length)
    return null;
  const l5 = [], e6 = [], o5 = t5 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let h6 = 0, i4 = n3.length; h6 < i4; h6++) {
    const l6 = r4(n3[h6], t5, o5);
    l6 && e6.push(l6);
  }
  if (e6.sort((n4, l6) => {
    let e7 = n4[2] - l6[2];
    return 0 === e7 && t5 && (e7 = n4[4] - l6[4]), e7;
  }), e6.length && (l5[0] = e6[0][0], l5[1] = e6[0][1], t5 && (l5[2] = e6[0][3]), (l5[0] < o5[0] || l5[0] > o5[1] || l5[1] < o5[2] || l5[1] > o5[3] || t5 && (l5[2] < o5[4] || l5[2] > o5[5])) && (l5.length = 0)), !l5.length) {
    const e7 = n3[0] && n3[0].length ? h2(n3[0], t5) : null;
    if (!e7)
      return null;
    l5[0] = e7[0], l5[1] = e7[1], t5 && e7.length > 2 && (l5[2] = e7[2]);
  }
  return l5;
}
function r4(n3, t5, l5) {
  let e6 = 0, o5 = 0, r7 = 0, h6 = 0, i4 = 0;
  const u4 = n3.length ? n3[0][0] : 0, g3 = n3.length ? n3[0][1] : 0, s4 = n3.length && t5 ? n3[0][2] : 0;
  for (let f4 = 0; f4 < n3.length; f4++) {
    const c5 = n3[f4], m3 = n3[(f4 + 1) % n3.length], [x3, a3, y2] = c5, d3 = x3 - u4, p3 = a3 - g3, v3 = t5 ? y2 - s4 : void 0, [z, Z, j3] = m3, U = z - u4, b = Z - g3, k2 = t5 ? j3 - s4 : void 0, q = d3 * b - U * p3;
    if (h6 += q, e6 += (d3 + U) * q, o5 += (p3 + b) * q, t5 && c5.length > 2 && m3.length > 2) {
      const n4 = d3 * k2 - U * v3;
      r7 += (v3 + k2) * n4, i4 += n4;
    }
    x3 < l5[0] && (l5[0] = x3), x3 > l5[1] && (l5[1] = x3), a3 < l5[2] && (l5[2] = a3), a3 > l5[3] && (l5[3] = a3), t5 && (y2 < l5[4] && (l5[4] = y2), y2 > l5[5] && (l5[5] = y2));
  }
  if (h6 > 0 && (h6 *= -1), i4 > 0 && (i4 *= -1), !h6)
    return null;
  h6 *= 0.5, i4 *= 0.5;
  const c4 = [e6 / (6 * h6) + u4, o5 / (6 * h6) + g3, h6];
  return t5 && (l5[4] === l5[5] || 0 === i4 ? (c4[3] = (l5[4] + l5[5]) / 2, c4[4] = 0) : (c4[3] = r7 / (6 * i4) + s4, c4[4] = i4)), c4;
}
function h2(l5, e6) {
  const o5 = e6 ? [0, 0, 0] : [0, 0], r7 = e6 ? [0, 0, 0] : [0, 0];
  let h6 = 0, i4 = 0, u4 = 0, g3 = 0;
  for (let s4 = 0, c4 = l5.length; s4 < c4 - 1; s4++) {
    const c5 = l5[s4], f4 = l5[s4 + 1];
    if (c5 && f4) {
      o5[0] = c5[0], o5[1] = c5[1], r7[0] = f4[0], r7[1] = f4[1], e6 && c5.length > 2 && f4.length > 2 && (o5[2] = c5[2], r7[2] = f4[2]);
      const l6 = e2(o5, r7);
      if (l6) {
        h6 += l6;
        const n3 = i2(c5, f4);
        i4 += l6 * n3[0], u4 += l6 * n3[1], e6 && n3.length > 2 && (g3 += l6 * n3[2]);
      }
    }
  }
  return h6 > 0 ? e6 ? [i4 / h6, u4 / h6, g3 / h6] : [i4 / h6, u4 / h6] : l5.length ? l5[0] : null;
}

// node_modules/@arcgis/core/geometry/support/boundsUtils.js
function n2(n3) {
  return void 0 !== n3.xmin && void 0 !== n3.ymin && void 0 !== n3.xmax && void 0 !== n3.ymax;
}
function t3(n3) {
  return void 0 !== n3.points;
}
function e4(n3) {
  return void 0 !== n3.x && void 0 !== n3.y;
}
function o3(n3) {
  return void 0 !== n3.paths;
}
function i3(n3) {
  return void 0 !== n3.rings;
}
function l3(n3) {
  return (t5, e6) => null == t5 ? e6 : null == e6 ? t5 : n3(t5, e6);
}
var r5 = l3(Math.min);
var u2 = l3(Math.max);
function c2(l5, r7) {
  return o3(r7) ? h3(l5, r7.paths, false, false) : i3(r7) ? h3(l5, r7.rings, false, false) : t3(r7) ? s2(l5, r7.points, false, false, false, false) : n2(r7) ? g2(l5, r7) : (e4(r7) && (l5[0] = r7.x, l5[1] = r7.y, l5[2] = r7.x, l5[3] = r7.y), l5);
}
function f2(l5, r7) {
  return o3(r7) ? h3(l5, r7.paths, true, false) : i3(r7) ? h3(l5, r7.rings, true, false) : t3(r7) ? s2(l5, r7.points, true, false, true, false) : n2(r7) ? g2(l5, r7, true, false, true, false) : (e4(r7) && (l5[0] = r7.x, l5[1] = r7.y, l5[2] = r7.z, l5[3] = r7.x, l5[4] = r7.y, l5[5] = r7.z), l5);
}
function h3(n3, t5, e6, o5) {
  const i4 = e6 ? 3 : 2;
  if (!t5.length || !t5[0].length)
    return null;
  let l5, c4, f4, h6, [g3, s4] = t5[0][0], [x3, m3] = t5[0][0];
  for (let a3 = 0; a3 < t5.length; a3++) {
    const n4 = t5[a3];
    for (let t6 = 0; t6 < n4.length; t6++) {
      const a4 = n4[t6], [d3, v3] = a4;
      if (g3 = r5(g3, d3), s4 = r5(s4, v3), x3 = u2(x3, d3), m3 = u2(m3, v3), e6 && a4.length > 2) {
        const n5 = a4[2];
        l5 = r5(l5, n5), c4 = u2(c4, n5);
      }
      if (o5 && a4.length > i4) {
        const n5 = a4[i4];
        f4 = r5(l5, n5), h6 = u2(c4, n5);
      }
    }
  }
  return e6 ? o5 ? (n3[0] = g3, n3[1] = s4, n3[2] = l5, n3[3] = f4, n3[4] = x3, n3[5] = m3, n3[6] = c4, n3[7] = h6, n3.length = 8, n3) : (n3[0] = g3, n3[1] = s4, n3[2] = l5, n3[3] = x3, n3[4] = m3, n3[5] = c4, n3.length = 6, n3) : o5 ? (n3[0] = g3, n3[1] = s4, n3[2] = f4, n3[3] = x3, n3[4] = m3, n3[5] = h6, n3.length = 6, n3) : (n3[0] = g3, n3[1] = s4, n3[2] = x3, n3[3] = m3, n3.length = 4, n3);
}
function g2(n3, t5, e6, o5, i4, l5) {
  const r7 = t5.xmin, u4 = t5.xmax, c4 = t5.ymin, f4 = t5.ymax;
  let h6 = t5.zmin, g3 = t5.zmax, s4 = t5.mmin, x3 = t5.mmax;
  return i4 ? (h6 = h6 || 0, g3 = g3 || 0, l5 ? (s4 = s4 || 0, x3 = x3 || 0, n3[0] = r7, n3[1] = c4, n3[2] = h6, n3[3] = s4, n3[4] = u4, n3[5] = f4, n3[6] = g3, n3[7] = x3, n3) : (n3[0] = r7, n3[1] = c4, n3[2] = h6, n3[3] = u4, n3[4] = f4, n3[5] = g3, n3)) : l5 ? (s4 = s4 || 0, x3 = x3 || 0, n3[0] = r7, n3[1] = c4, n3[2] = s4, n3[3] = u4, n3[4] = f4, n3[5] = x3, n3) : (n3[0] = r7, n3[1] = c4, n3[2] = u4, n3[3] = f4, n3);
}
function s2(n3, t5, e6, o5, i4, l5) {
  const c4 = e6 ? 3 : 2, f4 = o5 && l5, h6 = e6 && i4;
  if (!t5.length || !t5[0].length)
    return null;
  let g3, s4, x3, m3, [a3, d3] = t5[0], [v3, y2] = t5[0];
  for (let p3 = 0; p3 < t5.length; p3++) {
    const n4 = t5[p3], [e7, o6] = n4;
    if (a3 = r5(a3, e7), d3 = r5(d3, o6), v3 = u2(v3, e7), y2 = u2(y2, o6), h6 && n4.length > 2) {
      const t6 = n4[2];
      g3 = r5(g3, t6), s4 = u2(s4, t6);
    }
    if (f4 && n4.length > c4) {
      const t6 = n4[c4];
      x3 = r5(g3, t6), m3 = u2(s4, t6);
    }
  }
  return i4 ? (g3 = g3 || 0, s4 = s4 || 0, l5 ? (x3 = x3 || 0, m3 = m3 || 0, n3[0] = a3, n3[1] = d3, n3[2] = g3, n3[3] = x3, n3[4] = v3, n3[5] = y2, n3[6] = s4, n3[7] = m3, n3) : (n3[0] = a3, n3[1] = d3, n3[2] = g3, n3[3] = v3, n3[4] = y2, n3[5] = s4, n3)) : l5 ? (x3 = x3 || 0, m3 = m3 || 0, n3[0] = a3, n3[1] = d3, n3[2] = x3, n3[3] = v3, n3[4] = y2, n3[5] = m3, n3) : (n3[0] = a3, n3[1] = d3, n3[2] = v3, n3[3] = y2, n3);
}

// node_modules/@arcgis/core/geometry/support/extentUtils.js
function t4(n3) {
  return void 0 !== n3.xmin && void 0 !== n3.ymin && void 0 !== n3.xmax && void 0 !== n3.ymax;
}
function u3(n3) {
  return void 0 !== n3.points;
}
function m2(n3) {
  return void 0 !== n3.x && void 0 !== n3.y;
}
function o4(n3) {
  return void 0 !== n3.paths;
}
function r6(n3) {
  return void 0 !== n3.rings;
}
var x = [];
function a2(n3, i4, t5, u4) {
  return { xmin: n3, ymin: i4, xmax: t5, ymax: u4 };
}
function c3(n3, i4, t5, u4, m3, o5) {
  return { xmin: n3, ymin: i4, zmin: t5, xmax: u4, ymax: m3, zmax: o5 };
}
function s3(n3, i4, t5, u4, m3, o5) {
  return { xmin: n3, ymin: i4, mmin: t5, xmax: u4, ymax: m3, mmax: o5 };
}
function e5(n3, i4, t5, u4, m3, o5, r7, x3) {
  return { xmin: n3, ymin: i4, zmin: t5, mmin: u4, xmax: m3, ymax: o5, zmax: r7, mmax: x3 };
}
function f3(n3, i4 = false, t5 = false) {
  return i4 ? t5 ? e5(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5], n3[6], n3[7]) : c3(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]) : t5 ? s3(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]) : a2(n3[0], n3[1], n3[2], n3[3]);
}
function l4(n3) {
  return n3 ? t4(n3) ? n3 : m2(n3) ? d2(n3) : r6(n3) ? v(n3) : o4(n3) ? h4(n3) : u3(n3) ? y(n3) : null : null;
}
function y(i4) {
  const { hasZ: t5, hasM: u4, points: m3 } = i4;
  return f3(s2(x, m3, t5, u4), t5, u4);
}
function d2(n3) {
  const { x: i4, y: t5, z: u4, m: m3 } = n3, o5 = null != m3;
  return null != u4 ? o5 ? e5(i4, t5, u4, m3, i4, t5, u4, m3) : c3(i4, t5, u4, i4, t5, u4) : o5 ? s3(i4, t5, m3, i4, t5, m3) : a2(i4, t5, i4, t5);
}
function v(n3) {
  const { hasZ: t5, hasM: u4, rings: m3 } = n3, o5 = h3(x, m3, t5, u4);
  return o5 ? f3(o5, t5, u4) : null;
}
function h4(n3) {
  const { hasZ: t5, hasM: u4, paths: m3 } = n3, o5 = h3(x, m3, t5, u4);
  return o5 ? f3(o5, t5, u4) : null;
}

// node_modules/@arcgis/core/geometry/support/zmUtils.js
function h5(h6, a3, s4 = false) {
  let { hasM: t5, hasZ: e6 } = h6;
  Array.isArray(a3) ? 4 !== a3.length || t5 || e6 ? 3 === a3.length && s4 && !t5 ? (e6 = true, t5 = false) : 3 === a3.length && t5 && e6 && (t5 = false, e6 = false) : (t5 = true, e6 = true) : (e6 = !e6 && a3.hasZ && (!t5 || a3.hasM), t5 = !t5 && a3.hasM && (!e6 || a3.hasZ)), h6.hasZ = e6, h6.hasM = t5;
}

// node_modules/@arcgis/core/geometry/Polygon.js
var x2;
function j2(t5) {
  return !Array.isArray(t5[0]);
}
var w = x2 = class extends p {
  constructor(...t5) {
    super(...t5), this.rings = [], this.type = "polygon";
  }
  static fromExtent(t5) {
    const r7 = t5.clone().normalize(), e6 = t5.spatialReference;
    let s4 = false, i4 = false;
    for (const o5 of r7)
      o5.hasZ && (s4 = true), o5.hasM && (i4 = true);
    const n3 = { rings: r7.map((t6) => {
      const r8 = [[t6.xmin, t6.ymin], [t6.xmin, t6.ymax], [t6.xmax, t6.ymax], [t6.xmax, t6.ymin], [t6.xmin, t6.ymin]];
      if (s4 && t6.hasZ) {
        const e7 = t6.zmin + 0.5 * (t6.zmax - t6.zmin);
        for (let t7 = 0; t7 < r8.length; t7++)
          r8[t7].push(e7);
      }
      if (i4 && t6.hasM) {
        const e7 = t6.mmin + 0.5 * (t6.mmax - t6.mmin);
        for (let t7 = 0; t7 < r8.length; t7++)
          r8[t7].push(e7);
      }
      return r8;
    }), spatialReference: e6 };
    return s4 && (n3.hasZ = true), i4 && (n3.hasM = true), new x2(n3);
  }
  normalizeCtorArgs(t5, r7) {
    let e6, s4, i4 = null, n3 = null;
    return t5 && !Array.isArray(t5) ? (i4 = t5.rings ? t5.rings : null, r7 || (t5.spatialReference ? r7 = t5.spatialReference : t5.rings || (r7 = t5)), e6 = t5.hasZ, s4 = t5.hasM) : i4 = t5, i4 = i4 || [], r7 = r7 || k.WGS84, i4.length && i4[0] && null != i4[0][0] && "number" == typeof i4[0][0] && (i4 = [i4]), n3 = i4[0] && i4[0][0], n3 && (void 0 === e6 && void 0 === s4 ? (e6 = n3.length > 2, s4 = n3.length > 3) : void 0 === e6 ? e6 = s4 ? n3.length > 3 : n3.length > 2 : void 0 === s4 && (s4 = e6 ? n3.length > 3 : n3.length > 2)), { rings: i4, spatialReference: r7, hasZ: e6, hasM: s4 };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t5 = e3(this);
    if (!t5 || isNaN(t5[0]) || isNaN(t5[1]) || this.hasZ && isNaN(t5[2]))
      return null;
    const r7 = new j();
    return r7.x = t5[0], r7.y = t5[1], r7.spatialReference = this.spatialReference, this.hasZ && (r7.z = t5[2]), r7;
  }
  get extent() {
    const { spatialReference: t5 } = this, r7 = v(this);
    if (!r7)
      return null;
    const e6 = new M2(r7);
    return e6.spatialReference = t5, e6;
  }
  get isSelfIntersecting() {
    return p2(this.rings);
  }
  writeRings(t5, r7) {
    r7.rings = m(this.rings);
  }
  addRing(t5) {
    if (!t5)
      return;
    const r7 = this.rings, e6 = r7.length;
    if (j2(t5)) {
      const s4 = [];
      for (let r8 = 0, e7 = t5.length; r8 < e7; r8++)
        s4[r8] = t5[r8].toArray();
      r7[e6] = s4;
    } else
      r7[e6] = t5.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t5 = new x2();
    return t5.spatialReference = this.spatialReference, t5.rings = m(this.rings), t5.hasZ = this.hasZ, t5.hasM = this.hasM, t5;
  }
  equals(t5) {
    if (this === t5)
      return true;
    if (t(t5))
      return false;
    const e6 = this.spatialReference, n3 = t5.spatialReference;
    if (r(e6) !== r(n3))
      return false;
    if (r(e6) && r(n3) && !e6.equals(n3))
      return false;
    if (this.rings.length !== t5.rings.length)
      return false;
    const o5 = ([t6, r7, e7, s4], [i4, n4, o6, a3]) => t6 === i4 && r7 === n4 && (null == e7 && null == o6 || e7 === o6) && (null == s4 && null == a3 || s4 === a3);
    for (let s4 = 0; s4 < this.rings.length; s4++) {
      const e7 = this.rings[s4], i4 = t5.rings[s4];
      if (!i(e7, i4, o5))
        return false;
    }
    return true;
  }
  contains(t5) {
    if (!t5)
      return false;
    const r7 = M(t5, this.spatialReference);
    return c(this, r(r7) ? r7 : t5);
  }
  isClockwise(t5) {
    let r7;
    return r7 = j2(t5) ? t5.map((t6) => this.hasZ ? this.hasM ? [t6.x, t6.y, t6.z, t6.m] : [t6.x, t6.y, t6.z] : [t6.x, t6.y]) : t5, f(r7, this.hasM, this.hasZ);
  }
  getPoint(t5, r7) {
    if (!this._validateInputs(t5, r7))
      return null;
    const e6 = this.rings[t5][r7], s4 = this.hasZ, i4 = this.hasM;
    return s4 && !i4 ? new j(e6[0], e6[1], e6[2], void 0, this.spatialReference) : i4 && !s4 ? new j(e6[0], e6[1], void 0, e6[2], this.spatialReference) : s4 && i4 ? new j(e6[0], e6[1], e6[2], e6[3], this.spatialReference) : new j(e6[0], e6[1], this.spatialReference);
  }
  insertPoint(t5, r7, e6) {
    return this._validateInputs(t5, r7, true) ? (h5(this, e6), Array.isArray(e6) || (e6 = e6.toArray()), this.rings[t5].splice(r7, 0, e6), this.notifyChange("rings"), this) : this;
  }
  removePoint(t5, r7) {
    if (!this._validateInputs(t5, r7))
      return null;
    const e6 = new j(this.rings[t5].splice(r7, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), e6;
  }
  removeRing(t5) {
    if (!this._validateInputs(t5, null))
      return null;
    const r7 = this.rings.splice(t5, 1)[0], e6 = this.spatialReference, s4 = r7.map((t6) => new j(t6, e6));
    return this.notifyChange("rings"), s4;
  }
  setPoint(t5, r7, e6) {
    return this._validateInputs(t5, r7) ? (h5(this, e6), Array.isArray(e6) || (e6 = e6.toArray()), this.rings[t5][r7] = e6, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t5, r7, e6 = false) {
    if (null == t5 || t5 < 0 || t5 >= this.rings.length)
      return false;
    if (null != r7) {
      const s4 = this.rings[t5];
      if (e6 && (r7 < 0 || r7 > s4.length))
        return false;
      if (!e6 && (r7 < 0 || r7 >= s4.length))
        return false;
    }
    return true;
  }
  toJSON(t5) {
    return this.write({}, t5);
  }
};
e([d({ readOnly: true })], w.prototype, "cache", null), e([d({ readOnly: true })], w.prototype, "centroid", null), e([d({ readOnly: true })], w.prototype, "extent", null), e([d({ readOnly: true })], w.prototype, "isSelfIntersecting", null), e([d({ type: [[[Number]]], json: { write: { isRequired: true } } })], w.prototype, "rings", void 0), e([r2("rings")], w.prototype, "writeRings", null), w = x2 = e([n("esri.geometry.Polygon")], w), w.prototype.toJSON.isDefaultToJSON = true;
var v2 = w;

export {
  t2 as t,
  o,
  i2 as i,
  s,
  l,
  f,
  u,
  h,
  a,
  g,
  l2,
  e3 as e,
  o2,
  c2 as c,
  f2,
  h3 as h2,
  l4 as l3,
  v,
  h4 as h3,
  h5 as h4,
  v2
};
//# sourceMappingURL=chunk-VLCG72SW.js.map
