import {
  R,
  S
} from "./chunk-IEHZGLM3.js";
import {
  c
} from "./chunk-22MSECLU.js";
import {
  h
} from "./chunk-BS7TS6UC.js";
import {
  a as a2
} from "./chunk-JJRJ6TV3.js";
import {
  m as m4
} from "./chunk-6J6RPVFW.js";
import {
  z
} from "./chunk-RN2KRYDN.js";
import {
  f as f2,
  w
} from "./chunk-AWWWJUTQ.js";
import {
  g as g3
} from "./chunk-BLINZ65M.js";
import {
  n as n3
} from "./chunk-OIPX3EDD.js";
import {
  m as m2,
  m2 as m3
} from "./chunk-CHNDTVQJ.js";
import {
  a,
  f,
  g as g2,
  v2 as v
} from "./chunk-VLCG72SW.js";
import {
  j2 as j
} from "./chunk-YPZEGNLG.js";
import {
  I
} from "./chunk-3NMRL5CR.js";
import {
  d,
  n2 as n,
  n8 as n2
} from "./chunk-2QOWZFCU.js";
import {
  e
} from "./chunk-IVBXK6OP.js";
import {
  m
} from "./chunk-G5JBUC5N.js";
import {
  e as e2,
  g,
  i2 as i,
  l,
  r,
  t
} from "./chunk-CBQWMOBK.js";

// node_modules/@arcgis/core/views/draw/support/createUtils.js
function R2(e3, t2) {
  const o = new j({ x: e3[0], y: e3[1], spatialReference: t2 });
  return e3.length > 2 && (o.z = e3[2]), o;
}
function j2(e3, t2) {
  return new m2({ points: e3, spatialReference: t2 });
}
function b(e3, t2, o) {
  const n4 = new m3({ paths: e3, spatialReference: t2 });
  return o && a(n4), n4;
}
function T(o, n4, r2, a3 = true) {
  const s = m(o);
  s.forEach((t2) => {
    const o2 = t2[0], n5 = t2[t2.length - 1];
    i(o2, n5) && 1 !== t2.length || t2.push(t2[0]);
  });
  let l2 = new v({ rings: s, spatialReference: n4 });
  return l2.rings.forEach((e3) => {
    f(e3, false, false) || e3.reverse();
  }), r2 && a(l2), a3 && l2.isSelfIntersecting && I(n4) && (l2 = w(l2)), l2;
}
function U(e3, t2, n4) {
  const r2 = t2.mapToLocalMultiple(e3), a3 = [], s = { x: r2[0].x, y: r2[0].y }, i2 = { x: r2[1].x, y: r2[1].y }, l2 = Math.round(i2.x - s.x), y = Math.round(i2.y - s.y), c2 = Math.max(Math.abs(l2), Math.abs(y));
  if (n4) {
    const e4 = { x: s.x + c2, y: s.y + c2 }, t3 = { x: s.x - c2, y: s.y - c2 };
    a3.push(R(e4.x, t3.y), R(t3.x, t3.y), R(t3.x, e4.y), R(e4.x, e4.y));
  } else {
    const e4 = { x: l2 > 0 ? s.x + c2 : s.x - c2, y: y > 0 ? s.y + c2 : s.y - c2 };
    a3.push(R(s.x, s.y), R(e4.x, s.y), R(e4.x, e4.y), R(s.x, e4.y));
  }
  return T([g(a3.map((e4) => t2.localToMap(e4)))], t2.spatialReference, t2.doUnnormalization, true);
}
function w2(e3, t2, n4) {
  let r2 = t2.mapToLocalMultiple(e3);
  if (1 === r2.length) {
    const e4 = 48, t3 = r2[0];
    r2 = [R(t3.x - e4, t3.y + e4), R(t3.x + e4, t3.y - e4), R(t3.x + e4, t3.y - e4), R(t3.x - e4, t3.y + e4)];
  }
  const a3 = [], s = { x: r2[0].x, y: r2[0].y }, i2 = { x: r2[1].x, y: r2[1].y };
  if (n4) {
    const e4 = Math.round(i2.x - s.x), t3 = Math.round(i2.y - s.y);
    a3.push(R(s.x - e4, s.y - t3), R(i2.x, s.y - t3), R(i2.x, i2.y), R(s.x - e4, i2.y));
  } else
    a3.push(R(s.x, s.y), R(i2.x, s.y), R(i2.x, i2.y), R(s.x, i2.y));
  return T([g(a3.map((e4) => t2.localToMap(e4)))], t2.spatialReference, t2.doUnnormalization, true);
}
function z2(e3, t2, o, n4) {
  const i2 = t2.mapToLocalMultiple(e3);
  let y = null, c2 = null;
  if (o)
    y = i2[0], c2 = i2[1];
  else {
    const e4 = i2[0], t3 = i2[1], o2 = Math.round(t3.x - e4.x), n5 = Math.round(t3.y - e4.y), r2 = Math.max(Math.abs(o2), Math.abs(n5));
    y = R(o2 > 0 ? e4.x + r2 / 2 : e4.x - r2 / 2, n5 > 0 ? e4.y + r2 / 2 : e4.y - r2 / 2), c2 = R(Math.abs(o2) > Math.abs(n5) ? y.x - r2 / 2 : y.x, Math.abs(o2) > Math.abs(n5) ? y.y : y.y - r2 / 2);
  }
  const u = t2.localToMap(y), f3 = t2.localToMap(c2);
  if (t(u) || t(f3))
    return null;
  t2.doUnnormalization && g2([[u, f3]], t2.spatialReference);
  const h2 = R2(u, t2.spatialReference), M = R2(f3, t2.spatialReference), g4 = z(t2.spatialReference);
  let d2 = 0;
  if (I(t2.spatialReference))
    d2 = g4 * f2(h2, M, null);
  else {
    const e4 = y.x - c2.x, t3 = y.y - c2.y;
    d2 = g4 * Math.sqrt(e4 * e4 + t3 * t3) * (n4 || 1);
  }
  const j3 = new m4({ center: h2, radius: d2, radiusUnit: "meters", spatialReference: t2.spatialReference });
  return T(j3.rings, j3.spatialReference, false);
}
function L(e3, t2, n4) {
  const r2 = t2.mapToLocalMultiple(e3), a3 = r2[0], s = r2[1], i2 = Math.round(s.x - a3.x), l2 = Math.round(s.y - a3.y), y = R(n4 ? a3.x : a3.x + i2 / 2, n4 ? a3.y : a3.y + l2 / 2), c2 = n4 ? i2 : i2 / 2, p = n4 ? l2 : l2 / 2, x2 = 60, u = [], f3 = 2 * Math.PI / x2;
  for (let o = 0; o < x2; o++) {
    const e4 = Math.cos(o * f3), t3 = Math.sin(o * f3), n5 = R(c2 * e4 + y.x, p * t3 + y.y);
    u.push(n5);
  }
  return u.push(u[0]), T([g(u.map((e4) => t2.localToMap(e4)))], t2.spatialReference, t2.doUnnormalization, false);
}

// node_modules/@arcgis/core/views/draw/DrawGraphicTool.js
var _ = class extends a2(n3.EventedMixin(c)) {
  constructor(e3) {
    super(e3), this._graphic = null, this.defaultZ = 0, this.geometryType = null, this.hasZ = true, this.mode = null, this.snappingManager = null, this.snapToScene = false;
  }
  initialize() {
    this.internalGraphicsLayer = new h({ listMode: "hide", internal: true }), this.view.map.layers.add(this.internalGraphicsLayer), this.drawOperation = this.makeDrawOperation(), this.handles.add([this.drawOperation.on("vertex-add", (e3) => this.onVertexAdd(e3)), this.drawOperation.on("vertex-remove", (e3) => this.onVertexRemove(e3)), this.drawOperation.on("vertex-update", (e3) => this.onVertexUpdate(e3)), this.drawOperation.on("cursor-update", (e3) => this.onCursorUpdate(e3)), this.drawOperation.on("complete", (e3) => this.onComplete(e3))]), this.finishToolCreation();
  }
  destroy() {
    this.drawOperation = l(this.drawOperation), this._destroyAllVisualisations(), this.view.map.remove(this.internalGraphicsLayer), this.internalGraphicsLayer = l(this.internalGraphicsLayer), this._set("view", null);
  }
  get canRedo() {
    return this.drawOperation.canRedo;
  }
  get canUndo() {
    return this.drawOperation.canUndo;
  }
  set centered(e3) {
    this._set("centered", e3), this._updateGraphic();
  }
  set enabled(e3) {
    this.drawOperation.interactive = e3, this._set("enabled", e3);
  }
  set forceUniformSize(e3) {
    this._set("forceUniformSize", e3), this._updateGraphic();
  }
  get graphic() {
    return this._graphic;
  }
  set graphicSymbol(e3) {
    this._set("graphicSymbol", e3), r(this._graphic) && (this._graphic.symbol = e3);
  }
  get updating() {
    var _a;
    return ((_a = this.drawOperation) == null ? void 0 : _a.updating) ?? false;
  }
  completeCreateOperation() {
    this.drawOperation.complete();
  }
  onInputEvent(e3) {
    this.drawOperation.onInputEvent(e3);
  }
  redo() {
    this.drawOperation.redo();
  }
  reset() {
  }
  undo() {
    this.drawOperation.undo();
  }
  _createGraphic(e3) {
    this._graphic = new g3({ ...this.graphicProperties, geometry: e3, symbol: this.graphicSymbol }), this.internalGraphicsLayer.add(this._graphic), this.handles.add(this.initializeGraphic(this._graphic)), this.notifyChange("graphic"), this.handles.add(n(() => {
      r(this._graphic) && (this.internalGraphicsLayer.remove(this._graphic), this._graphic = l(this._graphic));
    }), V);
  }
  _destroyAllVisualisations() {
    this.handles.remove(x.outline), this.handles.remove(x.regularVertices), this.handles.remove(x.activeVertex), this.handles.remove(V);
  }
  _getCreateOperationGeometry(e3 = { operationComplete: false }) {
    if (null == this.drawOperation || 0 === this.drawOperation.numVertices)
      return null;
    const t2 = this.drawOperation.stagedVertex, r2 = this.drawOperation.committedVertices, i2 = r2.slice();
    r(t2) && i2.push(this.drawOperation.coordinateHelper.pointToArray(t2));
    const a3 = r(t2) ? this.drawOperation.coordinateHelper.pointToArray(t2) : r2.splice(-1)[0], o = { regularVertices: null, activeVertex: null, full: null, outline: null }, n4 = i2.length, l2 = this.view.spatialReference, p = "3d" === this.view.type && "global" === this.view.viewingMode;
    switch (this.geometryType) {
      case "point":
        o.regularVertices = r2, o.activeVertex = a3, o.full = this.drawOperation.coordinateHelper.arrayToPoint(i2[0]);
        break;
      case "multipoint":
        o.regularVertices = r2, o.activeVertex = a3, n4 > 0 && (o.full = j2(i2, l2));
        break;
      case "polyline":
        o.regularVertices = r2, o.activeVertex = a3, n4 > 0 && (o.full = b([i2], l2, p));
        break;
      case "polygon":
        o.regularVertices = r2, o.activeVertex = a3, n4 > 0 && (o.full = T([i2], l2, p, true));
        break;
      case "circle":
        if (n4 > 0) {
          const t3 = S(this.view, i2[0]);
          if (1 === n4 && e3.operationComplete) {
            const e4 = i2[0], r3 = t3.makeMapPoint(e4[0] + b2 * this.view.resolution, e4[1]);
            o.full = z2([e4, r3], t3, true);
          } else
            2 === n4 && (o.full = this.forceUniformSize ? z2(i2, t3, this.centered) : L(i2, t3, this.centered));
        }
        break;
      case "rectangle":
        if (n4 > 0) {
          const t3 = S(this.view, i2[0]);
          if (1 === n4 && e3.operationComplete) {
            const e4 = i2[0], r3 = t3.makeMapPoint(e4[0] + b2 * this.view.resolution, e4[1]);
            o.full = U([e4, r3], t3, true);
          } else
            2 === n4 && (o.full = this.forceUniformSize ? U(i2, t3, this.centered) : w2(i2, t3, this.centered));
        }
        break;
      default:
        return null;
    }
    switch (this.geometryType) {
      case "point":
      case "multipoint":
        break;
      case "polyline":
      case "polygon":
        n4 > 1 && (o.outline = b([i2], l2, p));
        break;
      case "circle":
      case "rectangle":
        r(o.full) && "polygon" === o.full.type && (o.outline = T(o.full.rings, l2, p));
    }
    return o;
  }
  initializeGraphic(e3) {
    return null;
  }
  onComplete(e3) {
    this._updateGraphic();
    let t2 = null;
    if (this.drawOperation.isCompleted) {
      const e4 = this._getCreateOperationGeometry({ operationComplete: true });
      r(e4) && (t(this._graphic) ? this._createGraphic(e4.full) : this._graphic.geometry = e4.full, t2 = e2(this._graphic).clone());
    }
    this.emit("complete", { graphic: t2, ...e3 });
  }
  onCursorUpdate(e3) {
    this._updateGraphic(), this.emit("cursor-update", e3);
  }
  onDeactivate() {
    this.drawOperation.isCompleted || this.drawOperation.cancel();
  }
  onVertexAdd(e3) {
    this._updateGraphic(), this.emit("vertex-add", e3);
  }
  onVertexRemove(e3) {
    this._updateGraphic(), this.emit("vertex-remove", e3);
  }
  onVertexUpdate(e3) {
    this._updateGraphic(), this.emit("vertex-update", e3);
  }
  _updateGraphic() {
    const e3 = this._getCreateOperationGeometry();
    t(e3) ? this._destroyAllVisualisations() : (r(e3.outline) ? this.handles.add(this.onOutlineChanged(e3.outline), x.outline) : this.handles.remove(x.outline), r(e3.regularVertices) ? this.handles.add(this.onRegularVerticesChanged(e3.regularVertices), x.regularVertices) : this.handles.remove(x.regularVertices), r(e3.activeVertex) ? this.handles.add(this.onActiveVertexChanged(e3.activeVertex), x.activeVertex) : this.handles.remove(x.activeVertex), r(e3.full) ? t(this._graphic) ? this._createGraphic(e3.full) : this._graphic.geometry = e3.full : this.handles.remove(V));
  }
};
e([d({ value: true })], _.prototype, "centered", null), e([d({ nonNullable: true })], _.prototype, "defaultZ", void 0), e([d()], _.prototype, "drawOperation", void 0), e([d({ value: true })], _.prototype, "enabled", null), e([d({ value: true })], _.prototype, "forceUniformSize", null), e([d({ constructOnly: true })], _.prototype, "geometryType", void 0), e([d()], _.prototype, "graphic", null), e([d({ constructOnly: true })], _.prototype, "graphicProperties", void 0), e([d()], _.prototype, "graphicSymbol", null), e([d({ constructOnly: true })], _.prototype, "hasZ", void 0), e([d({ constructOnly: true })], _.prototype, "mode", void 0), e([d()], _.prototype, "snappingManager", void 0), e([d()], _.prototype, "snapToScene", void 0), e([d({ readOnly: true })], _.prototype, "type", void 0), e([d({ readOnly: true })], _.prototype, "updating", null), e([d({ constructOnly: true, nonNullable: true })], _.prototype, "view", void 0), _ = e([n2("esri.views.draw.DrawGraphicTool")], _);
var V = "create-operation-graphic";
var x = { outline: "outline-visual", regularVertices: "regular-vertices-visual", activeVertex: "active-vertex-visual" };
function G(e3) {
  switch (e3) {
    case "point":
    case "polyline":
    case "polygon":
    case "multipoint":
      return e3;
    case "circle":
    case "rectangle":
      return "segment";
    default:
      return null;
  }
}
var b2 = 48;

export {
  _,
  G
};
//# sourceMappingURL=chunk-XGSJX5XD.js.map
