/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
import{_ as i}from"../../chunks/tslib.es6.js";import e from"../../core/Accessor.js";import{HandleOwnerMixin as t}from"../../core/HandleOwner.js";import{makeHandle as s}from"../../core/handleUtils.js";import{isSome as r,isNone as o,unwrap as n}from"../../core/maybe.js";import{watch as p,syncAndInitial as l}from"../../core/reactiveUtils.js";import{aliasOf as a}from"../../core/accessorSupport/decorators/aliasOf.js";import"../../core/arrayUtils.js";import"../../core/has.js";import"../../core/accessorSupport/ensureType.js";import{property as c}from"../../core/accessorSupport/decorators/property.js";import{subclass as u}from"../../core/accessorSupport/decorators/subclass.js";const d=["visibility"];let h=class extends(t(e)){constructor(i){super(i),this._expressionTrackingHandles=new Map,this.arcade=null,this.visibilityExpression=null,this.description=null,this.expressionTrackingProvider={registerExpression:()=>s()},this.feature=null,this.groupElement=null,this.label=null,this.spatialReference=null}initialize(){this.own(d.map((i=>p((()=>this.get(`${i}Function`)),(e=>{r(e)?this._registerExpressionWithTrackingProvider(i):this._unregisterExpressionWithTrackingProvider(i)}),l))))}set visibilityFunction(i){this._set("visibilityFunction",i),r(i)?this._registerExpressionWithTrackingProvider("visibility"):this._unregisterExpressionWithTrackingProvider("visibility")}get evaluatedVisibilityExpression(){const{visibilityFunction:i,spatialReference:e}=this;if(o(i))return;const{arcade:t}=this,s=t.arcadeUtils.getViewInfo({spatialReference:n(e)});return t.arcadeUtils.executeFunction(i,t.arcadeUtils.createExecContext(this.feature,s))}get inputFields(){return this._get("inputFields")}set inputFields(i){this.handles.removeAll(),i&&this.handles.add(i.map((i=>p((()=>i.visible),(()=>this._dirtyEvaluatedVisibilityExpression()))))),this._set("inputFields",i)}get state(){return r(this.groupElement)&&this.groupElement.initialState||"expanded"}set state(i){o(i)?this._clearOverride("state"):this._override("state",i)}get visible(){return!1!==this.evaluatedVisibilityExpression&&this.inputFields&&this.inputFields.some((i=>i.visible))}_registerExpressionWithTrackingProvider(i){const{_expressionTrackingHandles:e}=this;if(e.has(i))return;const t=`evaluated${v(i)}Expression`,s=this.expressionTrackingProvider.registerExpression((()=>this.notifyChange(t)));e.set(i,s)}_unregisterExpressionWithTrackingProvider(i){const{_expressionTrackingHandles:e}=this,t=e.get(i);t&&(t.remove(),e.delete(i))}_dirtyEvaluatedVisibilityExpression(){const{groupElement:i}=this;r(i)&&i.visibilityExpression&&this.notifyChange("evaluatedVisibilityExpression")}};i([c()],h.prototype,"arcade",void 0),i([a("groupElement.visibilityExpression")],h.prototype,"visibilityExpression",void 0),i([c()],h.prototype,"visibilityFunction",null),i([c()],h.prototype,"evaluatedVisibilityExpression",null),i([a("groupElement.description")],h.prototype,"description",void 0),i([c()],h.prototype,"expressionTrackingProvider",void 0),i([c()],h.prototype,"feature",void 0),i([c()],h.prototype,"groupElement",void 0),i([c()],h.prototype,"inputFields",null),i([a("groupElement.label")],h.prototype,"label",void 0),i([c()],h.prototype,"spatialReference",void 0),i([c()],h.prototype,"state",null),i([c()],h.prototype,"visible",null),h=i([u("esri.widgets.FeatureForm.InputFieldGroup")],h);const v=i=>i.charAt(0).toUpperCase()+i.slice(1),g=h;export{g as default};
